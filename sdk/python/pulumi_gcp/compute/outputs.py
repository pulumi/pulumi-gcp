# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from .. import _utilities, _tables
from . import outputs

__all__ = [
    'AutoscalarAutoscalingPolicy',
    'AutoscalarAutoscalingPolicyCpuUtilization',
    'AutoscalarAutoscalingPolicyLoadBalancingUtilization',
    'AutoscalarAutoscalingPolicyMetric',
    'AutoscalarAutoscalingPolicyScaleDownControl',
    'AutoscalarAutoscalingPolicyScaleDownControlMaxScaledDownReplicas',
    'AutoscalarAutoscalingPolicyScaleInControl',
    'AutoscalarAutoscalingPolicyScaleInControlMaxScaledInReplicas',
    'AutoscalarAutoscalingPolicyScalingSchedule',
    'AutoscalerAutoscalingPolicy',
    'AutoscalerAutoscalingPolicyCpuUtilization',
    'AutoscalerAutoscalingPolicyLoadBalancingUtilization',
    'AutoscalerAutoscalingPolicyMetric',
    'AutoscalerAutoscalingPolicyScaleDownControl',
    'AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas',
    'AutoscalerAutoscalingPolicyScaleInControl',
    'AutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas',
    'AutoscalerAutoscalingPolicyScalingSchedule',
    'BackendBucketCdnPolicy',
    'BackendBucketCdnPolicyNegativeCachingPolicy',
    'BackendServiceBackend',
    'BackendServiceCdnPolicy',
    'BackendServiceCdnPolicyCacheKeyPolicy',
    'BackendServiceCdnPolicyNegativeCachingPolicy',
    'BackendServiceCircuitBreakers',
    'BackendServiceCircuitBreakersConnectTimeout',
    'BackendServiceConsistentHash',
    'BackendServiceConsistentHashHttpCookie',
    'BackendServiceConsistentHashHttpCookieTtl',
    'BackendServiceIap',
    'BackendServiceLogConfig',
    'BackendServiceOutlierDetection',
    'BackendServiceOutlierDetectionBaseEjectionTime',
    'BackendServiceOutlierDetectionInterval',
    'DiskDiskEncryptionKey',
    'DiskIamBindingCondition',
    'DiskIamMemberCondition',
    'DiskSourceImageEncryptionKey',
    'DiskSourceSnapshotEncryptionKey',
    'ExternalVpnGatewayInterface',
    'FirewallAllow',
    'FirewallDeny',
    'FirewallLogConfig',
    'GlobalForwardingRuleMetadataFilter',
    'GlobalForwardingRuleMetadataFilterFilterLabel',
    'HaVpnGatewayVpnInterface',
    'HealthCheckGrpcHealthCheck',
    'HealthCheckHttp2HealthCheck',
    'HealthCheckHttpHealthCheck',
    'HealthCheckHttpsHealthCheck',
    'HealthCheckLogConfig',
    'HealthCheckSslHealthCheck',
    'HealthCheckTcpHealthCheck',
    'ImageGuestOsFeature',
    'ImageIamBindingCondition',
    'ImageIamMemberCondition',
    'ImageRawDisk',
    'InstanceAttachedDisk',
    'InstanceBootDisk',
    'InstanceBootDiskInitializeParams',
    'InstanceConfidentialInstanceConfig',
    'InstanceFromMachineImageAttachedDisk',
    'InstanceFromMachineImageBootDisk',
    'InstanceFromMachineImageBootDiskInitializeParams',
    'InstanceFromMachineImageConfidentialInstanceConfig',
    'InstanceFromMachineImageGuestAccelerator',
    'InstanceFromMachineImageNetworkInterface',
    'InstanceFromMachineImageNetworkInterfaceAccessConfig',
    'InstanceFromMachineImageNetworkInterfaceAliasIpRange',
    'InstanceFromMachineImageScheduling',
    'InstanceFromMachineImageSchedulingNodeAffinity',
    'InstanceFromMachineImageScratchDisk',
    'InstanceFromMachineImageServiceAccount',
    'InstanceFromMachineImageShieldedInstanceConfig',
    'InstanceFromTemplateAttachedDisk',
    'InstanceFromTemplateBootDisk',
    'InstanceFromTemplateBootDiskInitializeParams',
    'InstanceFromTemplateConfidentialInstanceConfig',
    'InstanceFromTemplateGuestAccelerator',
    'InstanceFromTemplateNetworkInterface',
    'InstanceFromTemplateNetworkInterfaceAccessConfig',
    'InstanceFromTemplateNetworkInterfaceAliasIpRange',
    'InstanceFromTemplateScheduling',
    'InstanceFromTemplateSchedulingNodeAffinity',
    'InstanceFromTemplateScratchDisk',
    'InstanceFromTemplateServiceAccount',
    'InstanceFromTemplateShieldedInstanceConfig',
    'InstanceGroupManagerAutoHealingPolicies',
    'InstanceGroupManagerNamedPort',
    'InstanceGroupManagerStatefulDisk',
    'InstanceGroupManagerUpdatePolicy',
    'InstanceGroupManagerVersion',
    'InstanceGroupManagerVersionTargetSize',
    'InstanceGroupNamedPort',
    'InstanceGuestAccelerator',
    'InstanceIAMBindingCondition',
    'InstanceIAMMemberCondition',
    'InstanceNetworkInterface',
    'InstanceNetworkInterfaceAccessConfig',
    'InstanceNetworkInterfaceAliasIpRange',
    'InstanceScheduling',
    'InstanceSchedulingNodeAffinity',
    'InstanceScratchDisk',
    'InstanceServiceAccount',
    'InstanceShieldedInstanceConfig',
    'InstanceTemplateConfidentialInstanceConfig',
    'InstanceTemplateDisk',
    'InstanceTemplateDiskDiskEncryptionKey',
    'InstanceTemplateGuestAccelerator',
    'InstanceTemplateNetworkInterface',
    'InstanceTemplateNetworkInterfaceAccessConfig',
    'InstanceTemplateNetworkInterfaceAliasIpRange',
    'InstanceTemplateScheduling',
    'InstanceTemplateSchedulingNodeAffinity',
    'InstanceTemplateServiceAccount',
    'InstanceTemplateShieldedInstanceConfig',
    'InterconnectAttachmentPrivateInterconnectInfo',
    'MachineImageIamBindingCondition',
    'MachineImageIamMemberCondition',
    'MachineImageMachineImageEncryptionKey',
    'ManagedSslCertificateManaged',
    'MangedSslCertificateManaged',
    'NodeGroupAutoscalingPolicy',
    'NodeTemplateNodeTypeFlexibility',
    'NodeTemplateServerBinding',
    'OrganizationSecurityPolicyRuleMatch',
    'OrganizationSecurityPolicyRuleMatchConfig',
    'OrganizationSecurityPolicyRuleMatchConfigLayer4Config',
    'PacketMirroringCollectorIlb',
    'PacketMirroringFilter',
    'PacketMirroringMirroredResources',
    'PacketMirroringMirroredResourcesInstance',
    'PacketMirroringMirroredResourcesSubnetwork',
    'PacketMirroringNetwork',
    'PerInstanceConfigPreservedState',
    'PerInstanceConfigPreservedStateDisk',
    'RegionAutoscalerAutoscalingPolicy',
    'RegionAutoscalerAutoscalingPolicyCpuUtilization',
    'RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization',
    'RegionAutoscalerAutoscalingPolicyMetric',
    'RegionAutoscalerAutoscalingPolicyScaleDownControl',
    'RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas',
    'RegionAutoscalerAutoscalingPolicyScaleInControl',
    'RegionAutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas',
    'RegionAutoscalerAutoscalingPolicyScalingSchedule',
    'RegionBackendServiceBackend',
    'RegionBackendServiceCdnPolicy',
    'RegionBackendServiceCdnPolicyCacheKeyPolicy',
    'RegionBackendServiceCdnPolicyNegativeCachingPolicy',
    'RegionBackendServiceCircuitBreakers',
    'RegionBackendServiceCircuitBreakersConnectTimeout',
    'RegionBackendServiceConsistentHash',
    'RegionBackendServiceConsistentHashHttpCookie',
    'RegionBackendServiceConsistentHashHttpCookieTtl',
    'RegionBackendServiceFailoverPolicy',
    'RegionBackendServiceLogConfig',
    'RegionBackendServiceOutlierDetection',
    'RegionBackendServiceOutlierDetectionBaseEjectionTime',
    'RegionBackendServiceOutlierDetectionInterval',
    'RegionDiskDiskEncryptionKey',
    'RegionDiskIamBindingCondition',
    'RegionDiskIamMemberCondition',
    'RegionDiskSourceSnapshotEncryptionKey',
    'RegionHealthCheckGrpcHealthCheck',
    'RegionHealthCheckHttp2HealthCheck',
    'RegionHealthCheckHttpHealthCheck',
    'RegionHealthCheckHttpsHealthCheck',
    'RegionHealthCheckLogConfig',
    'RegionHealthCheckSslHealthCheck',
    'RegionHealthCheckTcpHealthCheck',
    'RegionInstanceGroupManagerAutoHealingPolicies',
    'RegionInstanceGroupManagerNamedPort',
    'RegionInstanceGroupManagerStatefulDisk',
    'RegionInstanceGroupManagerUpdatePolicy',
    'RegionInstanceGroupManagerVersion',
    'RegionInstanceGroupManagerVersionTargetSize',
    'RegionNetworkEndpointGroupAppEngine',
    'RegionNetworkEndpointGroupCloudFunction',
    'RegionNetworkEndpointGroupCloudRun',
    'RegionPerInstanceConfigPreservedState',
    'RegionPerInstanceConfigPreservedStateDisk',
    'RegionUrlMapDefaultUrlRedirect',
    'RegionUrlMapHostRule',
    'RegionUrlMapPathMatcher',
    'RegionUrlMapPathMatcherDefaultUrlRedirect',
    'RegionUrlMapPathMatcherPathRule',
    'RegionUrlMapPathMatcherPathRuleRouteAction',
    'RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy',
    'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy',
    'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort',
    'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay',
    'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
    'RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy',
    'RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy',
    'RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout',
    'RegionUrlMapPathMatcherPathRuleRouteActionTimeout',
    'RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite',
    'RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService',
    'RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction',
    'RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'RegionUrlMapPathMatcherPathRuleUrlRedirect',
    'RegionUrlMapPathMatcherRouteRule',
    'RegionUrlMapPathMatcherRouteRuleHeaderAction',
    'RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd',
    'RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd',
    'RegionUrlMapPathMatcherRouteRuleMatchRule',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch',
    'RegionUrlMapPathMatcherRouteRuleRouteAction',
    'RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy',
    'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy',
    'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort',
    'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay',
    'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
    'RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy',
    'RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy',
    'RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout',
    'RegionUrlMapPathMatcherRouteRuleRouteActionTimeout',
    'RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite',
    'RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService',
    'RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction',
    'RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'RegionUrlMapPathMatcherRouteRuleUrlRedirect',
    'RegionUrlMapTest',
    'ReservationSpecificReservation',
    'ReservationSpecificReservationInstanceProperties',
    'ReservationSpecificReservationInstancePropertiesGuestAccelerator',
    'ReservationSpecificReservationInstancePropertiesLocalSsd',
    'ResourcePolicyGroupPlacementPolicy',
    'ResourcePolicySnapshotSchedulePolicy',
    'ResourcePolicySnapshotSchedulePolicyRetentionPolicy',
    'ResourcePolicySnapshotSchedulePolicySchedule',
    'ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule',
    'ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule',
    'ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule',
    'ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek',
    'ResourcePolicySnapshotSchedulePolicySnapshotProperties',
    'RouterBgp',
    'RouterBgpAdvertisedIpRange',
    'RouterNatLogConfig',
    'RouterNatSubnetwork',
    'RouterPeerAdvertisedIpRange',
    'SecurityPolicyRule',
    'SecurityPolicyRuleMatch',
    'SecurityPolicyRuleMatchConfig',
    'SecurityPolicyRuleMatchExpr',
    'SecurityScanConfigAuthentication',
    'SecurityScanConfigAuthenticationCustomAccount',
    'SecurityScanConfigAuthenticationGoogleAccount',
    'SecurityScanConfigSchedule',
    'SnapshotSnapshotEncryptionKey',
    'SnapshotSourceDiskEncryptionKey',
    'SubnetworkIAMBindingCondition',
    'SubnetworkIAMMemberCondition',
    'SubnetworkLogConfig',
    'SubnetworkSecondaryIpRange',
    'URLMapDefaultRouteAction',
    'URLMapDefaultRouteActionCorsPolicy',
    'URLMapDefaultRouteActionFaultInjectionPolicy',
    'URLMapDefaultRouteActionFaultInjectionPolicyAbort',
    'URLMapDefaultRouteActionFaultInjectionPolicyDelay',
    'URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay',
    'URLMapDefaultRouteActionRequestMirrorPolicy',
    'URLMapDefaultRouteActionRetryPolicy',
    'URLMapDefaultRouteActionRetryPolicyPerTryTimeout',
    'URLMapDefaultRouteActionTimeout',
    'URLMapDefaultRouteActionUrlRewrite',
    'URLMapDefaultRouteActionWeightedBackendService',
    'URLMapDefaultRouteActionWeightedBackendServiceHeaderAction',
    'URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'URLMapDefaultUrlRedirect',
    'URLMapHeaderAction',
    'URLMapHeaderActionRequestHeadersToAdd',
    'URLMapHeaderActionResponseHeadersToAdd',
    'URLMapHostRule',
    'URLMapPathMatcher',
    'URLMapPathMatcherDefaultRouteAction',
    'URLMapPathMatcherDefaultRouteActionCorsPolicy',
    'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicy',
    'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort',
    'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay',
    'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay',
    'URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy',
    'URLMapPathMatcherDefaultRouteActionRetryPolicy',
    'URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout',
    'URLMapPathMatcherDefaultRouteActionTimeout',
    'URLMapPathMatcherDefaultRouteActionUrlRewrite',
    'URLMapPathMatcherDefaultRouteActionWeightedBackendService',
    'URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction',
    'URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherDefaultUrlRedirect',
    'URLMapPathMatcherHeaderAction',
    'URLMapPathMatcherHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherPathRule',
    'URLMapPathMatcherPathRuleRouteAction',
    'URLMapPathMatcherPathRuleRouteActionCorsPolicy',
    'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy',
    'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort',
    'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay',
    'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
    'URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy',
    'URLMapPathMatcherPathRuleRouteActionRetryPolicy',
    'URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout',
    'URLMapPathMatcherPathRuleRouteActionTimeout',
    'URLMapPathMatcherPathRuleRouteActionUrlRewrite',
    'URLMapPathMatcherPathRuleRouteActionWeightedBackendService',
    'URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction',
    'URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherPathRuleUrlRedirect',
    'URLMapPathMatcherRouteRule',
    'URLMapPathMatcherRouteRuleHeaderAction',
    'URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherRouteRuleMatchRule',
    'URLMapPathMatcherRouteRuleMatchRuleHeaderMatch',
    'URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch',
    'URLMapPathMatcherRouteRuleMatchRuleMetadataFilter',
    'URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel',
    'URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch',
    'URLMapPathMatcherRouteRuleRouteAction',
    'URLMapPathMatcherRouteRuleRouteActionCorsPolicy',
    'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy',
    'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort',
    'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay',
    'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
    'URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy',
    'URLMapPathMatcherRouteRuleRouteActionRetryPolicy',
    'URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout',
    'URLMapPathMatcherRouteRuleRouteActionTimeout',
    'URLMapPathMatcherRouteRuleRouteActionUrlRewrite',
    'URLMapPathMatcherRouteRuleRouteActionWeightedBackendService',
    'URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction',
    'URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherRouteRuleUrlRedirect',
    'URLMapTest',
    'GetBackendBucketCdnPolicyResult',
    'GetBackendBucketCdnPolicyNegativeCachingPolicyResult',
    'GetBackendServiceBackendResult',
    'GetBackendServiceCdnPolicyResult',
    'GetBackendServiceCdnPolicyCacheKeyPolicyResult',
    'GetBackendServiceCdnPolicyNegativeCachingPolicyResult',
    'GetBackendServiceCircuitBreakerResult',
    'GetBackendServiceCircuitBreakerConnectTimeoutResult',
    'GetBackendServiceConsistentHashResult',
    'GetBackendServiceConsistentHashHttpCookyResult',
    'GetBackendServiceConsistentHashHttpCookyTtlResult',
    'GetBackendServiceIapResult',
    'GetBackendServiceLogConfigResult',
    'GetBackendServiceOutlierDetectionResult',
    'GetBackendServiceOutlierDetectionBaseEjectionTimeResult',
    'GetBackendServiceOutlierDetectionIntervalResult',
    'GetGlobalForwardingRuleMetadataFilterResult',
    'GetGlobalForwardingRuleMetadataFilterFilterLabelResult',
    'GetHealthCheckGrpcHealthCheckResult',
    'GetHealthCheckHttp2HealthCheckResult',
    'GetHealthCheckHttpHealthCheckResult',
    'GetHealthCheckHttpsHealthCheckResult',
    'GetHealthCheckLogConfigResult',
    'GetHealthCheckSslHealthCheckResult',
    'GetHealthCheckTcpHealthCheckResult',
    'GetInstanceAttachedDiskResult',
    'GetInstanceBootDiskResult',
    'GetInstanceBootDiskInitializeParamResult',
    'GetInstanceConfidentialInstanceConfigResult',
    'GetInstanceGroupNamedPortResult',
    'GetInstanceGuestAcceleratorResult',
    'GetInstanceNetworkInterfaceResult',
    'GetInstanceNetworkInterfaceAccessConfigResult',
    'GetInstanceNetworkInterfaceAliasIpRangeResult',
    'GetInstanceSchedulingResult',
    'GetInstanceSchedulingNodeAffinityResult',
    'GetInstanceScratchDiskResult',
    'GetInstanceServiceAccountResult',
    'GetInstanceShieldedInstanceConfigResult',
    'GetInstanceTemplateConfidentialInstanceConfigResult',
    'GetInstanceTemplateDiskResult',
    'GetInstanceTemplateDiskDiskEncryptionKeyResult',
    'GetInstanceTemplateGuestAcceleratorResult',
    'GetInstanceTemplateNetworkInterfaceResult',
    'GetInstanceTemplateNetworkInterfaceAccessConfigResult',
    'GetInstanceTemplateNetworkInterfaceAliasIpRangeResult',
    'GetInstanceTemplateSchedulingResult',
    'GetInstanceTemplateSchedulingNodeAffinityResult',
    'GetInstanceTemplateServiceAccountResult',
    'GetInstanceTemplateShieldedInstanceConfigResult',
    'GetRegionInstanceGroupInstanceResult',
    'GetRegionInstanceGroupInstanceNamedPortResult',
    'GetResourcePolicyGroupPlacementPolicyResult',
    'GetResourcePolicySnapshotSchedulePolicyResult',
    'GetResourcePolicySnapshotSchedulePolicyRetentionPolicyResult',
    'GetResourcePolicySnapshotSchedulePolicyScheduleResult',
    'GetResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleResult',
    'GetResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleResult',
    'GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleResult',
    'GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekResult',
    'GetResourcePolicySnapshotSchedulePolicySnapshotPropertyResult',
    'GetRouterBgpResult',
    'GetRouterBgpAdvertisedIpRangeResult',
    'GetSubnetworkSecondaryIpRangeResult',
]

@pulumi.output_type
class AutoscalarAutoscalingPolicy(dict):
    def __init__(__self__, *,
                 max_replicas: int,
                 min_replicas: int,
                 cooldown_period: Optional[int] = None,
                 cpu_utilization: Optional['outputs.AutoscalarAutoscalingPolicyCpuUtilization'] = None,
                 load_balancing_utilization: Optional['outputs.AutoscalarAutoscalingPolicyLoadBalancingUtilization'] = None,
                 metrics: Optional[Sequence['outputs.AutoscalarAutoscalingPolicyMetric']] = None,
                 mode: Optional[str] = None,
                 scale_down_control: Optional['outputs.AutoscalarAutoscalingPolicyScaleDownControl'] = None,
                 scale_in_control: Optional['outputs.AutoscalarAutoscalingPolicyScaleInControl'] = None,
                 scaling_schedules: Optional[Sequence['outputs.AutoscalarAutoscalingPolicyScalingSchedule']] = None):
        """
        :param int max_replicas: The maximum number of instances that the autoscaler can scale up
               to. This is required when creating or updating an autoscaler. The
               maximum number of replicas should not be lower than minimal number
               of replicas.
        :param int min_replicas: The minimum number of replicas that the autoscaler can scale down
               to. This cannot be less than 0. If not provided, autoscaler will
               choose a default value depending on maximum number of instances
               allowed.
        :param int cooldown_period: The number of seconds that the autoscaler should wait before it
               starts collecting information from a new instance. This prevents
               the autoscaler from collecting information when the instance is
               initializing, during which the collected usage would not be
               reliable. The default time autoscaler waits is 60 seconds.
               Virtual machine initialization times might vary because of
               numerous factors. We recommend that you test how long an
               instance may take to initialize. To do this, create an instance
               and time the startup process.
        :param 'AutoscalarAutoscalingPolicyCpuUtilizationArgs' cpu_utilization: Defines the CPU utilization policy that allows the autoscaler to
               scale based on the average CPU utilization of a managed instance
               group.
               Structure is documented below.
        :param 'AutoscalarAutoscalingPolicyLoadBalancingUtilizationArgs' load_balancing_utilization: Configuration parameters of autoscaling based on a load balancer.
               Structure is documented below.
        :param Sequence['AutoscalarAutoscalingPolicyMetricArgs'] metrics: Configuration parameters of autoscaling based on a custom metric.
               Structure is documented below.
        :param str mode: Defines operating mode for this policy.
               Default value is `ON`.
               Possible values are `OFF`, `ONLY_UP`, and `ON`.
        :param 'AutoscalarAutoscalingPolicyScaleDownControlArgs' scale_down_control: Defines scale down controls to reduce the risk of response latency
               and outages due to abrupt scale-in events
               Structure is documented below.
        :param 'AutoscalarAutoscalingPolicyScaleInControlArgs' scale_in_control: Defines scale in controls to reduce the risk of response latency
               and outages due to abrupt scale-in events
               Structure is documented below.
        :param Sequence['AutoscalarAutoscalingPolicyScalingScheduleArgs'] scaling_schedules: Scaling schedules defined for an autoscaler. Multiple schedules can be set on an autoscaler and they can overlap.
               Structure is documented below.
        """
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "min_replicas", min_replicas)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if cpu_utilization is not None:
            pulumi.set(__self__, "cpu_utilization", cpu_utilization)
        if load_balancing_utilization is not None:
            pulumi.set(__self__, "load_balancing_utilization", load_balancing_utilization)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if scale_down_control is not None:
            pulumi.set(__self__, "scale_down_control", scale_down_control)
        if scale_in_control is not None:
            pulumi.set(__self__, "scale_in_control", scale_in_control)
        if scaling_schedules is not None:
            pulumi.set(__self__, "scaling_schedules", scaling_schedules)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> int:
        """
        The maximum number of instances that the autoscaler can scale up
        to. This is required when creating or updating an autoscaler. The
        maximum number of replicas should not be lower than minimal number
        of replicas.
        """
        return pulumi.get(self, "max_replicas")

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> int:
        """
        The minimum number of replicas that the autoscaler can scale down
        to. This cannot be less than 0. If not provided, autoscaler will
        choose a default value depending on maximum number of instances
        allowed.
        """
        return pulumi.get(self, "min_replicas")

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[int]:
        """
        The number of seconds that the autoscaler should wait before it
        starts collecting information from a new instance. This prevents
        the autoscaler from collecting information when the instance is
        initializing, during which the collected usage would not be
        reliable. The default time autoscaler waits is 60 seconds.
        Virtual machine initialization times might vary because of
        numerous factors. We recommend that you test how long an
        instance may take to initialize. To do this, create an instance
        and time the startup process.
        """
        return pulumi.get(self, "cooldown_period")

    @property
    @pulumi.getter(name="cpuUtilization")
    def cpu_utilization(self) -> Optional['outputs.AutoscalarAutoscalingPolicyCpuUtilization']:
        """
        Defines the CPU utilization policy that allows the autoscaler to
        scale based on the average CPU utilization of a managed instance
        group.
        Structure is documented below.
        """
        return pulumi.get(self, "cpu_utilization")

    @property
    @pulumi.getter(name="loadBalancingUtilization")
    def load_balancing_utilization(self) -> Optional['outputs.AutoscalarAutoscalingPolicyLoadBalancingUtilization']:
        """
        Configuration parameters of autoscaling based on a load balancer.
        Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_utilization")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['outputs.AutoscalarAutoscalingPolicyMetric']]:
        """
        Configuration parameters of autoscaling based on a custom metric.
        Structure is documented below.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Defines operating mode for this policy.
        Default value is `ON`.
        Possible values are `OFF`, `ONLY_UP`, and `ON`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="scaleDownControl")
    def scale_down_control(self) -> Optional['outputs.AutoscalarAutoscalingPolicyScaleDownControl']:
        """
        Defines scale down controls to reduce the risk of response latency
        and outages due to abrupt scale-in events
        Structure is documented below.
        """
        return pulumi.get(self, "scale_down_control")

    @property
    @pulumi.getter(name="scaleInControl")
    def scale_in_control(self) -> Optional['outputs.AutoscalarAutoscalingPolicyScaleInControl']:
        """
        Defines scale in controls to reduce the risk of response latency
        and outages due to abrupt scale-in events
        Structure is documented below.
        """
        return pulumi.get(self, "scale_in_control")

    @property
    @pulumi.getter(name="scalingSchedules")
    def scaling_schedules(self) -> Optional[Sequence['outputs.AutoscalarAutoscalingPolicyScalingSchedule']]:
        """
        Scaling schedules defined for an autoscaler. Multiple schedules can be set on an autoscaler and they can overlap.
        Structure is documented below.
        """
        return pulumi.get(self, "scaling_schedules")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalarAutoscalingPolicyCpuUtilization(dict):
    def __init__(__self__, *,
                 target: float,
                 predictive_method: Optional[str] = None):
        """
        :param float target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        :param str predictive_method: Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are:
               - NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics.
               - OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
        """
        pulumi.set(__self__, "target", target)
        if predictive_method is not None:
            pulumi.set(__self__, "predictive_method", predictive_method)

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="predictiveMethod")
    def predictive_method(self) -> Optional[str]:
        """
        Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are:
        - NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics.
        - OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
        """
        return pulumi.get(self, "predictive_method")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalarAutoscalingPolicyLoadBalancingUtilization(dict):
    def __init__(__self__, *,
                 target: float):
        """
        :param float target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        """
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        return pulumi.get(self, "target")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalarAutoscalingPolicyMetric(dict):
    def __init__(__self__, *,
                 name: str,
                 filter: Optional[str] = None,
                 single_instance_assignment: Optional[float] = None,
                 target: Optional[float] = None,
                 type: Optional[str] = None):
        """
        :param str name: The identifier for this object. Format specified above.
        :param str filter: A filter string to be used as the filter string for
               a Stackdriver Monitoring TimeSeries.list API call.
               This filter is used to select a specific TimeSeries for
               the purpose of autoscaling and to determine whether the metric
               is exporting per-instance or per-group data.
               You can only use the AND operator for joining selectors.
               You can only use direct equality comparison operator (=) without
               any functions for each selector.
               You can specify the metric in both the filter string and in the
               metric field. However, if specified in both places, the metric must
               be identical.
               The monitored resource type determines what kind of values are
               expected for the metric. If it is a gce_instance, the autoscaler
               expects the metric to include a separate TimeSeries for each
               instance in a group. In such a case, you cannot filter on resource
               labels.
               If the resource type is any other value, the autoscaler expects
               this metric to contain values that apply to the entire autoscaled
               instance group and resource label filtering can be performed to
               point autoscaler at the correct TimeSeries to scale upon.
               This is called a per-group metric for the purpose of autoscaling.
               If not specified, the type defaults to gce_instance.
               You should provide a filter that is selective enough to pick just
               one TimeSeries for the autoscaled group or for each of the instances
               (if you are using gce_instance resource type). If multiple
               TimeSeries are returned upon the query execution, the autoscaler
               will sum their respective values to obtain its scaling value.
        :param float single_instance_assignment: If scaling is based on a per-group metric value that represents the
               total amount of work to be done or resource usage, set this value to
               an amount assigned for a single instance of the scaled group.
               The autoscaler will keep the number of instances proportional to the
               value of this metric, the metric itself should not change value due
               to group resizing.
               For example, a good metric to use with the target is
               `pubsub.googleapis.com/subscription/num_undelivered_messages`
               or a custom metric exporting the total number of requests coming to
               your instances.
               A bad example would be a metric exporting an average or median
               latency, since this value can't include a chunk assignable to a
               single instance, it could be better used with utilization_target
               instead.
        :param float target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        :param str type: Defines how target utilization value is expressed for a
               Stackdriver Monitoring metric.
               Possible values are `GAUGE`, `DELTA_PER_SECOND`, and `DELTA_PER_MINUTE`.
        """
        pulumi.set(__self__, "name", name)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if single_instance_assignment is not None:
            pulumi.set(__self__, "single_instance_assignment", single_instance_assignment)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        A filter string to be used as the filter string for
        a Stackdriver Monitoring TimeSeries.list API call.
        This filter is used to select a specific TimeSeries for
        the purpose of autoscaling and to determine whether the metric
        is exporting per-instance or per-group data.
        You can only use the AND operator for joining selectors.
        You can only use direct equality comparison operator (=) without
        any functions for each selector.
        You can specify the metric in both the filter string and in the
        metric field. However, if specified in both places, the metric must
        be identical.
        The monitored resource type determines what kind of values are
        expected for the metric. If it is a gce_instance, the autoscaler
        expects the metric to include a separate TimeSeries for each
        instance in a group. In such a case, you cannot filter on resource
        labels.
        If the resource type is any other value, the autoscaler expects
        this metric to contain values that apply to the entire autoscaled
        instance group and resource label filtering can be performed to
        point autoscaler at the correct TimeSeries to scale upon.
        This is called a per-group metric for the purpose of autoscaling.
        If not specified, the type defaults to gce_instance.
        You should provide a filter that is selective enough to pick just
        one TimeSeries for the autoscaled group or for each of the instances
        (if you are using gce_instance resource type). If multiple
        TimeSeries are returned upon the query execution, the autoscaler
        will sum their respective values to obtain its scaling value.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="singleInstanceAssignment")
    def single_instance_assignment(self) -> Optional[float]:
        """
        If scaling is based on a per-group metric value that represents the
        total amount of work to be done or resource usage, set this value to
        an amount assigned for a single instance of the scaled group.
        The autoscaler will keep the number of instances proportional to the
        value of this metric, the metric itself should not change value due
        to group resizing.
        For example, a good metric to use with the target is
        `pubsub.googleapis.com/subscription/num_undelivered_messages`
        or a custom metric exporting the total number of requests coming to
        your instances.
        A bad example would be a metric exporting an average or median
        latency, since this value can't include a chunk assignable to a
        single instance, it could be better used with utilization_target
        instead.
        """
        return pulumi.get(self, "single_instance_assignment")

    @property
    @pulumi.getter
    def target(self) -> Optional[float]:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines how target utilization value is expressed for a
        Stackdriver Monitoring metric.
        Possible values are `GAUGE`, `DELTA_PER_SECOND`, and `DELTA_PER_MINUTE`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalarAutoscalingPolicyScaleDownControl(dict):
    def __init__(__self__, *,
                 max_scaled_down_replicas: Optional['outputs.AutoscalarAutoscalingPolicyScaleDownControlMaxScaledDownReplicas'] = None,
                 time_window_sec: Optional[int] = None):
        """
        :param 'AutoscalarAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs' max_scaled_down_replicas: A nested object resource
               Structure is documented below.
        :param int time_window_sec: How long back autoscaling should look when computing recommendations
               to include directives regarding slower scale down, as described above.
        """
        if max_scaled_down_replicas is not None:
            pulumi.set(__self__, "max_scaled_down_replicas", max_scaled_down_replicas)
        if time_window_sec is not None:
            pulumi.set(__self__, "time_window_sec", time_window_sec)

    @property
    @pulumi.getter(name="maxScaledDownReplicas")
    def max_scaled_down_replicas(self) -> Optional['outputs.AutoscalarAutoscalingPolicyScaleDownControlMaxScaledDownReplicas']:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "max_scaled_down_replicas")

    @property
    @pulumi.getter(name="timeWindowSec")
    def time_window_sec(self) -> Optional[int]:
        """
        How long back autoscaling should look when computing recommendations
        to include directives regarding slower scale down, as described above.
        """
        return pulumi.get(self, "time_window_sec")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalarAutoscalingPolicyScaleDownControlMaxScaledDownReplicas(dict):
    def __init__(__self__, *,
                 fixed: Optional[int] = None,
                 percent: Optional[int] = None):
        """
        :param int fixed: Specifies a fixed number of VM instances. This must be a positive
               integer.
        :param int percent: Specifies a percentage of instances between 0 to 100%, inclusive.
               For example, specify 80 for 80%.
        """
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def fixed(self) -> Optional[int]:
        """
        Specifies a fixed number of VM instances. This must be a positive
        integer.
        """
        return pulumi.get(self, "fixed")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive.
        For example, specify 80 for 80%.
        """
        return pulumi.get(self, "percent")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalarAutoscalingPolicyScaleInControl(dict):
    def __init__(__self__, *,
                 max_scaled_in_replicas: Optional['outputs.AutoscalarAutoscalingPolicyScaleInControlMaxScaledInReplicas'] = None,
                 time_window_sec: Optional[int] = None):
        """
        :param 'AutoscalarAutoscalingPolicyScaleInControlMaxScaledInReplicasArgs' max_scaled_in_replicas: A nested object resource
               Structure is documented below.
        :param int time_window_sec: How long back autoscaling should look when computing recommendations
               to include directives regarding slower scale down, as described above.
        """
        if max_scaled_in_replicas is not None:
            pulumi.set(__self__, "max_scaled_in_replicas", max_scaled_in_replicas)
        if time_window_sec is not None:
            pulumi.set(__self__, "time_window_sec", time_window_sec)

    @property
    @pulumi.getter(name="maxScaledInReplicas")
    def max_scaled_in_replicas(self) -> Optional['outputs.AutoscalarAutoscalingPolicyScaleInControlMaxScaledInReplicas']:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "max_scaled_in_replicas")

    @property
    @pulumi.getter(name="timeWindowSec")
    def time_window_sec(self) -> Optional[int]:
        """
        How long back autoscaling should look when computing recommendations
        to include directives regarding slower scale down, as described above.
        """
        return pulumi.get(self, "time_window_sec")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalarAutoscalingPolicyScaleInControlMaxScaledInReplicas(dict):
    def __init__(__self__, *,
                 fixed: Optional[int] = None,
                 percent: Optional[int] = None):
        """
        :param int fixed: Specifies a fixed number of VM instances. This must be a positive
               integer.
        :param int percent: Specifies a percentage of instances between 0 to 100%, inclusive.
               For example, specify 80 for 80%.
        """
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def fixed(self) -> Optional[int]:
        """
        Specifies a fixed number of VM instances. This must be a positive
        integer.
        """
        return pulumi.get(self, "fixed")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive.
        For example, specify 80 for 80%.
        """
        return pulumi.get(self, "percent")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalarAutoscalingPolicyScalingSchedule(dict):
    def __init__(__self__, *,
                 duration_sec: int,
                 min_required_replicas: int,
                 name: str,
                 schedule: str,
                 description: Optional[str] = None,
                 disabled: Optional[bool] = None,
                 time_zone: Optional[str] = None):
        """
        :param int duration_sec: The duration of time intervals (in seconds) for which this scaling schedule will be running. The minimum allowed value is 300.
        :param int min_required_replicas: Minimum number of VM instances that autoscaler will recommend in time intervals starting according to schedule.
        :param str name: The identifier for this object. Format specified above.
        :param str schedule: The start timestamps of time intervals when this scaling schedule should provide a scaling signal. This field uses the extended cron format (with an optional year field).
        :param str description: An optional description of this resource.
        :param bool disabled: A boolean value that specifies if a scaling schedule can influence autoscaler recommendations. If set to true, then a scaling schedule has no effect.
        :param str time_zone: The time zone to be used when interpreting the schedule. The value of this field must be a time zone name from the tz database: http://en.wikipedia.org/wiki/Tz_database.
        """
        pulumi.set(__self__, "duration_sec", duration_sec)
        pulumi.set(__self__, "min_required_replicas", min_required_replicas)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="durationSec")
    def duration_sec(self) -> int:
        """
        The duration of time intervals (in seconds) for which this scaling schedule will be running. The minimum allowed value is 300.
        """
        return pulumi.get(self, "duration_sec")

    @property
    @pulumi.getter(name="minRequiredReplicas")
    def min_required_replicas(self) -> int:
        """
        Minimum number of VM instances that autoscaler will recommend in time intervals starting according to schedule.
        """
        return pulumi.get(self, "min_required_replicas")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> str:
        """
        The start timestamps of time intervals when this scaling schedule should provide a scaling signal. This field uses the extended cron format (with an optional year field).
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of this resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        A boolean value that specifies if a scaling schedule can influence autoscaler recommendations. If set to true, then a scaling schedule has no effect.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        The time zone to be used when interpreting the schedule. The value of this field must be a time zone name from the tz database: http://en.wikipedia.org/wiki/Tz_database.
        """
        return pulumi.get(self, "time_zone")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicy(dict):
    def __init__(__self__, *,
                 max_replicas: int,
                 min_replicas: int,
                 cooldown_period: Optional[int] = None,
                 cpu_utilization: Optional['outputs.AutoscalerAutoscalingPolicyCpuUtilization'] = None,
                 load_balancing_utilization: Optional['outputs.AutoscalerAutoscalingPolicyLoadBalancingUtilization'] = None,
                 metrics: Optional[Sequence['outputs.AutoscalerAutoscalingPolicyMetric']] = None,
                 mode: Optional[str] = None,
                 scale_down_control: Optional['outputs.AutoscalerAutoscalingPolicyScaleDownControl'] = None,
                 scale_in_control: Optional['outputs.AutoscalerAutoscalingPolicyScaleInControl'] = None,
                 scaling_schedules: Optional[Sequence['outputs.AutoscalerAutoscalingPolicyScalingSchedule']] = None):
        """
        :param int max_replicas: The maximum number of instances that the autoscaler can scale up
               to. This is required when creating or updating an autoscaler. The
               maximum number of replicas should not be lower than minimal number
               of replicas.
        :param int min_replicas: The minimum number of replicas that the autoscaler can scale down
               to. This cannot be less than 0. If not provided, autoscaler will
               choose a default value depending on maximum number of instances
               allowed.
        :param int cooldown_period: The number of seconds that the autoscaler should wait before it
               starts collecting information from a new instance. This prevents
               the autoscaler from collecting information when the instance is
               initializing, during which the collected usage would not be
               reliable. The default time autoscaler waits is 60 seconds.
               Virtual machine initialization times might vary because of
               numerous factors. We recommend that you test how long an
               instance may take to initialize. To do this, create an instance
               and time the startup process.
        :param 'AutoscalerAutoscalingPolicyCpuUtilizationArgs' cpu_utilization: Defines the CPU utilization policy that allows the autoscaler to
               scale based on the average CPU utilization of a managed instance
               group.
               Structure is documented below.
        :param 'AutoscalerAutoscalingPolicyLoadBalancingUtilizationArgs' load_balancing_utilization: Configuration parameters of autoscaling based on a load balancer.
               Structure is documented below.
        :param Sequence['AutoscalerAutoscalingPolicyMetricArgs'] metrics: Configuration parameters of autoscaling based on a custom metric.
               Structure is documented below.
        :param str mode: Defines operating mode for this policy.
               Default value is `ON`.
               Possible values are `OFF`, `ONLY_UP`, and `ON`.
        :param 'AutoscalerAutoscalingPolicyScaleDownControlArgs' scale_down_control: Defines scale down controls to reduce the risk of response latency
               and outages due to abrupt scale-in events
               Structure is documented below.
        :param 'AutoscalerAutoscalingPolicyScaleInControlArgs' scale_in_control: Defines scale in controls to reduce the risk of response latency
               and outages due to abrupt scale-in events
               Structure is documented below.
        :param Sequence['AutoscalerAutoscalingPolicyScalingScheduleArgs'] scaling_schedules: Scaling schedules defined for an autoscaler. Multiple schedules can be set on an autoscaler and they can overlap.
               Structure is documented below.
        """
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "min_replicas", min_replicas)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if cpu_utilization is not None:
            pulumi.set(__self__, "cpu_utilization", cpu_utilization)
        if load_balancing_utilization is not None:
            pulumi.set(__self__, "load_balancing_utilization", load_balancing_utilization)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if scale_down_control is not None:
            pulumi.set(__self__, "scale_down_control", scale_down_control)
        if scale_in_control is not None:
            pulumi.set(__self__, "scale_in_control", scale_in_control)
        if scaling_schedules is not None:
            pulumi.set(__self__, "scaling_schedules", scaling_schedules)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> int:
        """
        The maximum number of instances that the autoscaler can scale up
        to. This is required when creating or updating an autoscaler. The
        maximum number of replicas should not be lower than minimal number
        of replicas.
        """
        return pulumi.get(self, "max_replicas")

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> int:
        """
        The minimum number of replicas that the autoscaler can scale down
        to. This cannot be less than 0. If not provided, autoscaler will
        choose a default value depending on maximum number of instances
        allowed.
        """
        return pulumi.get(self, "min_replicas")

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[int]:
        """
        The number of seconds that the autoscaler should wait before it
        starts collecting information from a new instance. This prevents
        the autoscaler from collecting information when the instance is
        initializing, during which the collected usage would not be
        reliable. The default time autoscaler waits is 60 seconds.
        Virtual machine initialization times might vary because of
        numerous factors. We recommend that you test how long an
        instance may take to initialize. To do this, create an instance
        and time the startup process.
        """
        return pulumi.get(self, "cooldown_period")

    @property
    @pulumi.getter(name="cpuUtilization")
    def cpu_utilization(self) -> Optional['outputs.AutoscalerAutoscalingPolicyCpuUtilization']:
        """
        Defines the CPU utilization policy that allows the autoscaler to
        scale based on the average CPU utilization of a managed instance
        group.
        Structure is documented below.
        """
        return pulumi.get(self, "cpu_utilization")

    @property
    @pulumi.getter(name="loadBalancingUtilization")
    def load_balancing_utilization(self) -> Optional['outputs.AutoscalerAutoscalingPolicyLoadBalancingUtilization']:
        """
        Configuration parameters of autoscaling based on a load balancer.
        Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_utilization")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['outputs.AutoscalerAutoscalingPolicyMetric']]:
        """
        Configuration parameters of autoscaling based on a custom metric.
        Structure is documented below.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Defines operating mode for this policy.
        Default value is `ON`.
        Possible values are `OFF`, `ONLY_UP`, and `ON`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="scaleDownControl")
    def scale_down_control(self) -> Optional['outputs.AutoscalerAutoscalingPolicyScaleDownControl']:
        """
        Defines scale down controls to reduce the risk of response latency
        and outages due to abrupt scale-in events
        Structure is documented below.
        """
        return pulumi.get(self, "scale_down_control")

    @property
    @pulumi.getter(name="scaleInControl")
    def scale_in_control(self) -> Optional['outputs.AutoscalerAutoscalingPolicyScaleInControl']:
        """
        Defines scale in controls to reduce the risk of response latency
        and outages due to abrupt scale-in events
        Structure is documented below.
        """
        return pulumi.get(self, "scale_in_control")

    @property
    @pulumi.getter(name="scalingSchedules")
    def scaling_schedules(self) -> Optional[Sequence['outputs.AutoscalerAutoscalingPolicyScalingSchedule']]:
        """
        Scaling schedules defined for an autoscaler. Multiple schedules can be set on an autoscaler and they can overlap.
        Structure is documented below.
        """
        return pulumi.get(self, "scaling_schedules")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicyCpuUtilization(dict):
    def __init__(__self__, *,
                 target: float,
                 predictive_method: Optional[str] = None):
        """
        :param float target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        :param str predictive_method: Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are:
               - NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics.
               - OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
        """
        pulumi.set(__self__, "target", target)
        if predictive_method is not None:
            pulumi.set(__self__, "predictive_method", predictive_method)

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="predictiveMethod")
    def predictive_method(self) -> Optional[str]:
        """
        Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are:
        - NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics.
        - OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
        """
        return pulumi.get(self, "predictive_method")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicyLoadBalancingUtilization(dict):
    def __init__(__self__, *,
                 target: float):
        """
        :param float target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        """
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        return pulumi.get(self, "target")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicyMetric(dict):
    def __init__(__self__, *,
                 name: str,
                 filter: Optional[str] = None,
                 single_instance_assignment: Optional[float] = None,
                 target: Optional[float] = None,
                 type: Optional[str] = None):
        """
        :param str name: The identifier for this object. Format specified above.
        :param str filter: A filter string to be used as the filter string for
               a Stackdriver Monitoring TimeSeries.list API call.
               This filter is used to select a specific TimeSeries for
               the purpose of autoscaling and to determine whether the metric
               is exporting per-instance or per-group data.
               You can only use the AND operator for joining selectors.
               You can only use direct equality comparison operator (=) without
               any functions for each selector.
               You can specify the metric in both the filter string and in the
               metric field. However, if specified in both places, the metric must
               be identical.
               The monitored resource type determines what kind of values are
               expected for the metric. If it is a gce_instance, the autoscaler
               expects the metric to include a separate TimeSeries for each
               instance in a group. In such a case, you cannot filter on resource
               labels.
               If the resource type is any other value, the autoscaler expects
               this metric to contain values that apply to the entire autoscaled
               instance group and resource label filtering can be performed to
               point autoscaler at the correct TimeSeries to scale upon.
               This is called a per-group metric for the purpose of autoscaling.
               If not specified, the type defaults to gce_instance.
               You should provide a filter that is selective enough to pick just
               one TimeSeries for the autoscaled group or for each of the instances
               (if you are using gce_instance resource type). If multiple
               TimeSeries are returned upon the query execution, the autoscaler
               will sum their respective values to obtain its scaling value.
        :param float single_instance_assignment: If scaling is based on a per-group metric value that represents the
               total amount of work to be done or resource usage, set this value to
               an amount assigned for a single instance of the scaled group.
               The autoscaler will keep the number of instances proportional to the
               value of this metric, the metric itself should not change value due
               to group resizing.
               For example, a good metric to use with the target is
               `pubsub.googleapis.com/subscription/num_undelivered_messages`
               or a custom metric exporting the total number of requests coming to
               your instances.
               A bad example would be a metric exporting an average or median
               latency, since this value can't include a chunk assignable to a
               single instance, it could be better used with utilization_target
               instead.
        :param float target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        :param str type: Defines how target utilization value is expressed for a
               Stackdriver Monitoring metric.
               Possible values are `GAUGE`, `DELTA_PER_SECOND`, and `DELTA_PER_MINUTE`.
        """
        pulumi.set(__self__, "name", name)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if single_instance_assignment is not None:
            pulumi.set(__self__, "single_instance_assignment", single_instance_assignment)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        A filter string to be used as the filter string for
        a Stackdriver Monitoring TimeSeries.list API call.
        This filter is used to select a specific TimeSeries for
        the purpose of autoscaling and to determine whether the metric
        is exporting per-instance or per-group data.
        You can only use the AND operator for joining selectors.
        You can only use direct equality comparison operator (=) without
        any functions for each selector.
        You can specify the metric in both the filter string and in the
        metric field. However, if specified in both places, the metric must
        be identical.
        The monitored resource type determines what kind of values are
        expected for the metric. If it is a gce_instance, the autoscaler
        expects the metric to include a separate TimeSeries for each
        instance in a group. In such a case, you cannot filter on resource
        labels.
        If the resource type is any other value, the autoscaler expects
        this metric to contain values that apply to the entire autoscaled
        instance group and resource label filtering can be performed to
        point autoscaler at the correct TimeSeries to scale upon.
        This is called a per-group metric for the purpose of autoscaling.
        If not specified, the type defaults to gce_instance.
        You should provide a filter that is selective enough to pick just
        one TimeSeries for the autoscaled group or for each of the instances
        (if you are using gce_instance resource type). If multiple
        TimeSeries are returned upon the query execution, the autoscaler
        will sum their respective values to obtain its scaling value.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="singleInstanceAssignment")
    def single_instance_assignment(self) -> Optional[float]:
        """
        If scaling is based on a per-group metric value that represents the
        total amount of work to be done or resource usage, set this value to
        an amount assigned for a single instance of the scaled group.
        The autoscaler will keep the number of instances proportional to the
        value of this metric, the metric itself should not change value due
        to group resizing.
        For example, a good metric to use with the target is
        `pubsub.googleapis.com/subscription/num_undelivered_messages`
        or a custom metric exporting the total number of requests coming to
        your instances.
        A bad example would be a metric exporting an average or median
        latency, since this value can't include a chunk assignable to a
        single instance, it could be better used with utilization_target
        instead.
        """
        return pulumi.get(self, "single_instance_assignment")

    @property
    @pulumi.getter
    def target(self) -> Optional[float]:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines how target utilization value is expressed for a
        Stackdriver Monitoring metric.
        Possible values are `GAUGE`, `DELTA_PER_SECOND`, and `DELTA_PER_MINUTE`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicyScaleDownControl(dict):
    def __init__(__self__, *,
                 max_scaled_down_replicas: Optional['outputs.AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas'] = None,
                 time_window_sec: Optional[int] = None):
        """
        :param 'AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs' max_scaled_down_replicas: A nested object resource
               Structure is documented below.
        :param int time_window_sec: How long back autoscaling should look when computing recommendations
               to include directives regarding slower scale down, as described above.
        """
        if max_scaled_down_replicas is not None:
            pulumi.set(__self__, "max_scaled_down_replicas", max_scaled_down_replicas)
        if time_window_sec is not None:
            pulumi.set(__self__, "time_window_sec", time_window_sec)

    @property
    @pulumi.getter(name="maxScaledDownReplicas")
    def max_scaled_down_replicas(self) -> Optional['outputs.AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas']:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "max_scaled_down_replicas")

    @property
    @pulumi.getter(name="timeWindowSec")
    def time_window_sec(self) -> Optional[int]:
        """
        How long back autoscaling should look when computing recommendations
        to include directives regarding slower scale down, as described above.
        """
        return pulumi.get(self, "time_window_sec")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas(dict):
    def __init__(__self__, *,
                 fixed: Optional[int] = None,
                 percent: Optional[int] = None):
        """
        :param int fixed: Specifies a fixed number of VM instances. This must be a positive
               integer.
        :param int percent: Specifies a percentage of instances between 0 to 100%, inclusive.
               For example, specify 80 for 80%.
        """
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def fixed(self) -> Optional[int]:
        """
        Specifies a fixed number of VM instances. This must be a positive
        integer.
        """
        return pulumi.get(self, "fixed")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive.
        For example, specify 80 for 80%.
        """
        return pulumi.get(self, "percent")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicyScaleInControl(dict):
    def __init__(__self__, *,
                 max_scaled_in_replicas: Optional['outputs.AutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas'] = None,
                 time_window_sec: Optional[int] = None):
        """
        :param 'AutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicasArgs' max_scaled_in_replicas: A nested object resource
               Structure is documented below.
        :param int time_window_sec: How long back autoscaling should look when computing recommendations
               to include directives regarding slower scale down, as described above.
        """
        if max_scaled_in_replicas is not None:
            pulumi.set(__self__, "max_scaled_in_replicas", max_scaled_in_replicas)
        if time_window_sec is not None:
            pulumi.set(__self__, "time_window_sec", time_window_sec)

    @property
    @pulumi.getter(name="maxScaledInReplicas")
    def max_scaled_in_replicas(self) -> Optional['outputs.AutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas']:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "max_scaled_in_replicas")

    @property
    @pulumi.getter(name="timeWindowSec")
    def time_window_sec(self) -> Optional[int]:
        """
        How long back autoscaling should look when computing recommendations
        to include directives regarding slower scale down, as described above.
        """
        return pulumi.get(self, "time_window_sec")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas(dict):
    def __init__(__self__, *,
                 fixed: Optional[int] = None,
                 percent: Optional[int] = None):
        """
        :param int fixed: Specifies a fixed number of VM instances. This must be a positive
               integer.
        :param int percent: Specifies a percentage of instances between 0 to 100%, inclusive.
               For example, specify 80 for 80%.
        """
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def fixed(self) -> Optional[int]:
        """
        Specifies a fixed number of VM instances. This must be a positive
        integer.
        """
        return pulumi.get(self, "fixed")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive.
        For example, specify 80 for 80%.
        """
        return pulumi.get(self, "percent")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AutoscalerAutoscalingPolicyScalingSchedule(dict):
    def __init__(__self__, *,
                 duration_sec: int,
                 min_required_replicas: int,
                 name: str,
                 schedule: str,
                 description: Optional[str] = None,
                 disabled: Optional[bool] = None,
                 time_zone: Optional[str] = None):
        """
        :param int duration_sec: The duration of time intervals (in seconds) for which this scaling schedule will be running. The minimum allowed value is 300.
        :param int min_required_replicas: Minimum number of VM instances that autoscaler will recommend in time intervals starting according to schedule.
        :param str name: The identifier for this object. Format specified above.
        :param str schedule: The start timestamps of time intervals when this scaling schedule should provide a scaling signal. This field uses the extended cron format (with an optional year field).
        :param str description: An optional description of this resource.
        :param bool disabled: A boolean value that specifies if a scaling schedule can influence autoscaler recommendations. If set to true, then a scaling schedule has no effect.
        :param str time_zone: The time zone to be used when interpreting the schedule. The value of this field must be a time zone name from the tz database: http://en.wikipedia.org/wiki/Tz_database.
        """
        pulumi.set(__self__, "duration_sec", duration_sec)
        pulumi.set(__self__, "min_required_replicas", min_required_replicas)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="durationSec")
    def duration_sec(self) -> int:
        """
        The duration of time intervals (in seconds) for which this scaling schedule will be running. The minimum allowed value is 300.
        """
        return pulumi.get(self, "duration_sec")

    @property
    @pulumi.getter(name="minRequiredReplicas")
    def min_required_replicas(self) -> int:
        """
        Minimum number of VM instances that autoscaler will recommend in time intervals starting according to schedule.
        """
        return pulumi.get(self, "min_required_replicas")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> str:
        """
        The start timestamps of time intervals when this scaling schedule should provide a scaling signal. This field uses the extended cron format (with an optional year field).
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of this resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        A boolean value that specifies if a scaling schedule can influence autoscaler recommendations. If set to true, then a scaling schedule has no effect.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        The time zone to be used when interpreting the schedule. The value of this field must be a time zone name from the tz database: http://en.wikipedia.org/wiki/Tz_database.
        """
        return pulumi.get(self, "time_zone")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendBucketCdnPolicy(dict):
    def __init__(__self__, *,
                 cache_mode: Optional[str] = None,
                 client_ttl: Optional[int] = None,
                 default_ttl: Optional[int] = None,
                 max_ttl: Optional[int] = None,
                 negative_caching: Optional[bool] = None,
                 negative_caching_policies: Optional[Sequence['outputs.BackendBucketCdnPolicyNegativeCachingPolicy']] = None,
                 serve_while_stale: Optional[int] = None,
                 signed_url_cache_max_age_sec: Optional[int] = None):
        """
        :param str cache_mode: Specifies the cache setting for all responses from this backend.
               The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
               Possible values are `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, and `CACHE_ALL_STATIC`.
        :param int client_ttl: Specifies the maximum allowed TTL for cached content served by this origin.
        :param int default_ttl: Specifies the default TTL for cached content served by this origin for responses
               that do not have an existing valid TTL (max-age or s-max-age).
        :param int max_ttl: Specifies the maximum allowed TTL for cached content served by this origin.
        :param bool negative_caching: Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        :param Sequence['BackendBucketCdnPolicyNegativeCachingPolicyArgs'] negative_caching_policies: Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
               Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
               Structure is documented below.
        :param int serve_while_stale: Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        :param int signed_url_cache_max_age_sec: Maximum number of seconds the response to a signed URL request will
               be considered fresh. After this time period,
               the response will be revalidated before being served.
               When serving responses to signed URL requests,
               Cloud CDN will internally behave as though
               all responses from this backend had a "Cache-Control: public,
               max-age=[TTL]" header, regardless of any existing Cache-Control
               header. The actual headers served in responses will not be altered.
        """
        if cache_mode is not None:
            pulumi.set(__self__, "cache_mode", cache_mode)
        if client_ttl is not None:
            pulumi.set(__self__, "client_ttl", client_ttl)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if negative_caching is not None:
            pulumi.set(__self__, "negative_caching", negative_caching)
        if negative_caching_policies is not None:
            pulumi.set(__self__, "negative_caching_policies", negative_caching_policies)
        if serve_while_stale is not None:
            pulumi.set(__self__, "serve_while_stale", serve_while_stale)
        if signed_url_cache_max_age_sec is not None:
            pulumi.set(__self__, "signed_url_cache_max_age_sec", signed_url_cache_max_age_sec)

    @property
    @pulumi.getter(name="cacheMode")
    def cache_mode(self) -> Optional[str]:
        """
        Specifies the cache setting for all responses from this backend.
        The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
        Possible values are `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, and `CACHE_ALL_STATIC`.
        """
        return pulumi.get(self, "cache_mode")

    @property
    @pulumi.getter(name="clientTtl")
    def client_ttl(self) -> Optional[int]:
        """
        Specifies the maximum allowed TTL for cached content served by this origin.
        """
        return pulumi.get(self, "client_ttl")

    @property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[int]:
        """
        Specifies the default TTL for cached content served by this origin for responses
        that do not have an existing valid TTL (max-age or s-max-age).
        """
        return pulumi.get(self, "default_ttl")

    @property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[int]:
        """
        Specifies the maximum allowed TTL for cached content served by this origin.
        """
        return pulumi.get(self, "max_ttl")

    @property
    @pulumi.getter(name="negativeCaching")
    def negative_caching(self) -> Optional[bool]:
        """
        Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        """
        return pulumi.get(self, "negative_caching")

    @property
    @pulumi.getter(name="negativeCachingPolicies")
    def negative_caching_policies(self) -> Optional[Sequence['outputs.BackendBucketCdnPolicyNegativeCachingPolicy']]:
        """
        Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
        Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
        Structure is documented below.
        """
        return pulumi.get(self, "negative_caching_policies")

    @property
    @pulumi.getter(name="serveWhileStale")
    def serve_while_stale(self) -> Optional[int]:
        """
        Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        """
        return pulumi.get(self, "serve_while_stale")

    @property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> Optional[int]:
        """
        Maximum number of seconds the response to a signed URL request will
        be considered fresh. After this time period,
        the response will be revalidated before being served.
        When serving responses to signed URL requests,
        Cloud CDN will internally behave as though
        all responses from this backend had a "Cache-Control: public,
        max-age=[TTL]" header, regardless of any existing Cache-Control
        header. The actual headers served in responses will not be altered.
        """
        return pulumi.get(self, "signed_url_cache_max_age_sec")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendBucketCdnPolicyNegativeCachingPolicy(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 ttl: Optional[int] = None):
        """
        :param int code: The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
               can be specified as values, and you cannot specify a status code more than once.
        :param int ttl: The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
               (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
        can be specified as values, and you cannot specify a status code more than once.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
        (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        return pulumi.get(self, "ttl")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceBackend(dict):
    def __init__(__self__, *,
                 group: str,
                 balancing_mode: Optional[str] = None,
                 capacity_scaler: Optional[float] = None,
                 description: Optional[str] = None,
                 max_connections: Optional[int] = None,
                 max_connections_per_endpoint: Optional[int] = None,
                 max_connections_per_instance: Optional[int] = None,
                 max_rate: Optional[int] = None,
                 max_rate_per_endpoint: Optional[float] = None,
                 max_rate_per_instance: Optional[float] = None,
                 max_utilization: Optional[float] = None):
        """
        :param str group: The fully-qualified URL of an Instance Group or Network Endpoint
               Group resource. In case of instance group this defines the list
               of instances that serve traffic. Member virtual machine
               instances from each instance group must live in the same zone as
               the instance group itself. No two backends in a backend service
               are allowed to use same Instance Group resource.
               For Network Endpoint Groups this defines list of endpoints. All
               endpoints of Network Endpoint Group must be hosted on instances
               located in the same zone as the Network Endpoint Group.
               Backend services cannot mix Instance Group and
               Network Endpoint Group backends.
               Note that you must specify an Instance Group or Network Endpoint
               Group resource using the fully-qualified URL, rather than a
               partial URL.
        :param str balancing_mode: Specifies the balancing mode for this backend.
               For global HTTP(S) or TCP/SSL load balancing, the default is
               UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S))
               and CONNECTION (for TCP/SSL).
               Default value is `UTILIZATION`.
               Possible values are `UTILIZATION`, `RATE`, and `CONNECTION`.
        :param float capacity_scaler: A multiplier applied to the group's maximum servicing capacity
               (based on UTILIZATION, RATE or CONNECTION).
               Default value is 1, which means the group will serve up to 100%
               of its configured capacity (depending on balancingMode). A
               setting of 0 means the group is completely drained, offering
               0% of its available Capacity. Valid range is [0.0,1.0].
        :param str description: An optional description of this resource.
               Provide this property when you create the resource.
        :param int max_connections: The maximum number of connections to the backend cluster.
               Defaults to 1024.
        :param int max_connections_per_endpoint: The max number of simultaneous connections that a single backend
               network endpoint can handle. This is used to calculate the
               capacity of the group. Can be used in either CONNECTION or
               UTILIZATION balancing modes.
               For CONNECTION mode, either
               maxConnections or maxConnectionsPerEndpoint must be set.
        :param int max_connections_per_instance: The max number of simultaneous connections that a single
               backend instance can handle. This is used to calculate the
               capacity of the group. Can be used in either CONNECTION or
               UTILIZATION balancing modes.
               For CONNECTION mode, either maxConnections or
               maxConnectionsPerInstance must be set.
        :param int max_rate: The max requests per second (RPS) of the group.
               Can be used with either RATE or UTILIZATION balancing modes,
               but required if RATE mode. For RATE mode, either maxRate or one
               of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
               group type, must be set.
        :param float max_rate_per_endpoint: The max requests per second (RPS) that a single backend network
               endpoint can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerEndpoint must be set.
        :param float max_rate_per_instance: The max requests per second (RPS) that a single backend
               instance can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerInstance must be set.
        :param float max_utilization: Used when balancingMode is UTILIZATION. This ratio defines the
               CPU utilization target for the group. The default is 0.8. Valid
               range is [0.0, 1.0].
        """
        pulumi.set(__self__, "group", group)
        if balancing_mode is not None:
            pulumi.set(__self__, "balancing_mode", balancing_mode)
        if capacity_scaler is not None:
            pulumi.set(__self__, "capacity_scaler", capacity_scaler)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_connections_per_endpoint is not None:
            pulumi.set(__self__, "max_connections_per_endpoint", max_connections_per_endpoint)
        if max_connections_per_instance is not None:
            pulumi.set(__self__, "max_connections_per_instance", max_connections_per_instance)
        if max_rate is not None:
            pulumi.set(__self__, "max_rate", max_rate)
        if max_rate_per_endpoint is not None:
            pulumi.set(__self__, "max_rate_per_endpoint", max_rate_per_endpoint)
        if max_rate_per_instance is not None:
            pulumi.set(__self__, "max_rate_per_instance", max_rate_per_instance)
        if max_utilization is not None:
            pulumi.set(__self__, "max_utilization", max_utilization)

    @property
    @pulumi.getter
    def group(self) -> str:
        """
        The fully-qualified URL of an Instance Group or Network Endpoint
        Group resource. In case of instance group this defines the list
        of instances that serve traffic. Member virtual machine
        instances from each instance group must live in the same zone as
        the instance group itself. No two backends in a backend service
        are allowed to use same Instance Group resource.
        For Network Endpoint Groups this defines list of endpoints. All
        endpoints of Network Endpoint Group must be hosted on instances
        located in the same zone as the Network Endpoint Group.
        Backend services cannot mix Instance Group and
        Network Endpoint Group backends.
        Note that you must specify an Instance Group or Network Endpoint
        Group resource using the fully-qualified URL, rather than a
        partial URL.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="balancingMode")
    def balancing_mode(self) -> Optional[str]:
        """
        Specifies the balancing mode for this backend.
        For global HTTP(S) or TCP/SSL load balancing, the default is
        UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S))
        and CONNECTION (for TCP/SSL).
        Default value is `UTILIZATION`.
        Possible values are `UTILIZATION`, `RATE`, and `CONNECTION`.
        """
        return pulumi.get(self, "balancing_mode")

    @property
    @pulumi.getter(name="capacityScaler")
    def capacity_scaler(self) -> Optional[float]:
        """
        A multiplier applied to the group's maximum servicing capacity
        (based on UTILIZATION, RATE or CONNECTION).
        Default value is 1, which means the group will serve up to 100%
        of its configured capacity (depending on balancingMode). A
        setting of 0 means the group is completely drained, offering
        0% of its available Capacity. Valid range is [0.0,1.0].
        """
        return pulumi.get(self, "capacity_scaler")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of this resource.
        Provide this property when you create the resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        """
        The maximum number of connections to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxConnectionsPerEndpoint")
    def max_connections_per_endpoint(self) -> Optional[int]:
        """
        The max number of simultaneous connections that a single backend
        network endpoint can handle. This is used to calculate the
        capacity of the group. Can be used in either CONNECTION or
        UTILIZATION balancing modes.
        For CONNECTION mode, either
        maxConnections or maxConnectionsPerEndpoint must be set.
        """
        return pulumi.get(self, "max_connections_per_endpoint")

    @property
    @pulumi.getter(name="maxConnectionsPerInstance")
    def max_connections_per_instance(self) -> Optional[int]:
        """
        The max number of simultaneous connections that a single
        backend instance can handle. This is used to calculate the
        capacity of the group. Can be used in either CONNECTION or
        UTILIZATION balancing modes.
        For CONNECTION mode, either maxConnections or
        maxConnectionsPerInstance must be set.
        """
        return pulumi.get(self, "max_connections_per_instance")

    @property
    @pulumi.getter(name="maxRate")
    def max_rate(self) -> Optional[int]:
        """
        The max requests per second (RPS) of the group.
        Can be used with either RATE or UTILIZATION balancing modes,
        but required if RATE mode. For RATE mode, either maxRate or one
        of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
        group type, must be set.
        """
        return pulumi.get(self, "max_rate")

    @property
    @pulumi.getter(name="maxRatePerEndpoint")
    def max_rate_per_endpoint(self) -> Optional[float]:
        """
        The max requests per second (RPS) that a single backend network
        endpoint can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerEndpoint must be set.
        """
        return pulumi.get(self, "max_rate_per_endpoint")

    @property
    @pulumi.getter(name="maxRatePerInstance")
    def max_rate_per_instance(self) -> Optional[float]:
        """
        The max requests per second (RPS) that a single backend
        instance can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerInstance must be set.
        """
        return pulumi.get(self, "max_rate_per_instance")

    @property
    @pulumi.getter(name="maxUtilization")
    def max_utilization(self) -> Optional[float]:
        """
        Used when balancingMode is UTILIZATION. This ratio defines the
        CPU utilization target for the group. The default is 0.8. Valid
        range is [0.0, 1.0].
        """
        return pulumi.get(self, "max_utilization")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceCdnPolicy(dict):
    def __init__(__self__, *,
                 cache_key_policy: Optional['outputs.BackendServiceCdnPolicyCacheKeyPolicy'] = None,
                 cache_mode: Optional[str] = None,
                 client_ttl: Optional[int] = None,
                 default_ttl: Optional[int] = None,
                 max_ttl: Optional[int] = None,
                 negative_caching: Optional[bool] = None,
                 negative_caching_policies: Optional[Sequence['outputs.BackendServiceCdnPolicyNegativeCachingPolicy']] = None,
                 serve_while_stale: Optional[int] = None,
                 signed_url_cache_max_age_sec: Optional[int] = None):
        """
        :param 'BackendServiceCdnPolicyCacheKeyPolicyArgs' cache_key_policy: The CacheKeyPolicy for this CdnPolicy.
               Structure is documented below.
        :param str cache_mode: Specifies the cache setting for all responses from this backend.
               The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
               Possible values are `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, and `CACHE_ALL_STATIC`.
        :param int client_ttl: Specifies the maximum allowed TTL for cached content served by this origin.
        :param int default_ttl: Specifies the default TTL for cached content served by this origin for responses
               that do not have an existing valid TTL (max-age or s-max-age).
        :param int max_ttl: Specifies the maximum allowed TTL for cached content served by this origin.
        :param bool negative_caching: Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        :param Sequence['BackendServiceCdnPolicyNegativeCachingPolicyArgs'] negative_caching_policies: Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
               Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
               Structure is documented below.
        :param int serve_while_stale: Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        :param int signed_url_cache_max_age_sec: Maximum number of seconds the response to a signed URL request
               will be considered fresh, defaults to 1hr (3600s). After this
               time period, the response will be revalidated before
               being served.
               When serving responses to signed URL requests, Cloud CDN will
               internally behave as though all responses from this backend had a
               "Cache-Control: public, max-age=[TTL]" header, regardless of any
               existing Cache-Control header. The actual headers served in
               responses will not be altered.
        """
        if cache_key_policy is not None:
            pulumi.set(__self__, "cache_key_policy", cache_key_policy)
        if cache_mode is not None:
            pulumi.set(__self__, "cache_mode", cache_mode)
        if client_ttl is not None:
            pulumi.set(__self__, "client_ttl", client_ttl)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if negative_caching is not None:
            pulumi.set(__self__, "negative_caching", negative_caching)
        if negative_caching_policies is not None:
            pulumi.set(__self__, "negative_caching_policies", negative_caching_policies)
        if serve_while_stale is not None:
            pulumi.set(__self__, "serve_while_stale", serve_while_stale)
        if signed_url_cache_max_age_sec is not None:
            pulumi.set(__self__, "signed_url_cache_max_age_sec", signed_url_cache_max_age_sec)

    @property
    @pulumi.getter(name="cacheKeyPolicy")
    def cache_key_policy(self) -> Optional['outputs.BackendServiceCdnPolicyCacheKeyPolicy']:
        """
        The CacheKeyPolicy for this CdnPolicy.
        Structure is documented below.
        """
        return pulumi.get(self, "cache_key_policy")

    @property
    @pulumi.getter(name="cacheMode")
    def cache_mode(self) -> Optional[str]:
        """
        Specifies the cache setting for all responses from this backend.
        The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
        Possible values are `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, and `CACHE_ALL_STATIC`.
        """
        return pulumi.get(self, "cache_mode")

    @property
    @pulumi.getter(name="clientTtl")
    def client_ttl(self) -> Optional[int]:
        """
        Specifies the maximum allowed TTL for cached content served by this origin.
        """
        return pulumi.get(self, "client_ttl")

    @property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[int]:
        """
        Specifies the default TTL for cached content served by this origin for responses
        that do not have an existing valid TTL (max-age or s-max-age).
        """
        return pulumi.get(self, "default_ttl")

    @property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[int]:
        """
        Specifies the maximum allowed TTL for cached content served by this origin.
        """
        return pulumi.get(self, "max_ttl")

    @property
    @pulumi.getter(name="negativeCaching")
    def negative_caching(self) -> Optional[bool]:
        """
        Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        """
        return pulumi.get(self, "negative_caching")

    @property
    @pulumi.getter(name="negativeCachingPolicies")
    def negative_caching_policies(self) -> Optional[Sequence['outputs.BackendServiceCdnPolicyNegativeCachingPolicy']]:
        """
        Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
        Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
        Structure is documented below.
        """
        return pulumi.get(self, "negative_caching_policies")

    @property
    @pulumi.getter(name="serveWhileStale")
    def serve_while_stale(self) -> Optional[int]:
        """
        Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        """
        return pulumi.get(self, "serve_while_stale")

    @property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> Optional[int]:
        """
        Maximum number of seconds the response to a signed URL request
        will be considered fresh, defaults to 1hr (3600s). After this
        time period, the response will be revalidated before
        being served.
        When serving responses to signed URL requests, Cloud CDN will
        internally behave as though all responses from this backend had a
        "Cache-Control: public, max-age=[TTL]" header, regardless of any
        existing Cache-Control header. The actual headers served in
        responses will not be altered.
        """
        return pulumi.get(self, "signed_url_cache_max_age_sec")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceCdnPolicyCacheKeyPolicy(dict):
    def __init__(__self__, *,
                 include_host: Optional[bool] = None,
                 include_protocol: Optional[bool] = None,
                 include_query_string: Optional[bool] = None,
                 query_string_blacklists: Optional[Sequence[str]] = None,
                 query_string_whitelists: Optional[Sequence[str]] = None):
        """
        :param bool include_host: If true requests to different hosts will be cached separately.
        :param bool include_protocol: If true, http and https requests will be cached separately.
        :param bool include_query_string: If true, include query string parameters in the cache key
               according to query_string_whitelist and
               query_string_blacklist. If neither is set, the entire query
               string will be included.
               If false, the query string will be excluded from the cache
               key entirely.
        :param Sequence[str] query_string_blacklists: Names of query string parameters to exclude in cache keys.
               All other parameters will be included. Either specify
               query_string_whitelist or query_string_blacklist, not both.
               '&' and '=' will be percent encoded and not treated as
               delimiters.
        :param Sequence[str] query_string_whitelists: Names of query string parameters to include in cache keys.
               All other parameters will be excluded. Either specify
               query_string_whitelist or query_string_blacklist, not both.
               '&' and '=' will be percent encoded and not treated as
               delimiters.
        """
        if include_host is not None:
            pulumi.set(__self__, "include_host", include_host)
        if include_protocol is not None:
            pulumi.set(__self__, "include_protocol", include_protocol)
        if include_query_string is not None:
            pulumi.set(__self__, "include_query_string", include_query_string)
        if query_string_blacklists is not None:
            pulumi.set(__self__, "query_string_blacklists", query_string_blacklists)
        if query_string_whitelists is not None:
            pulumi.set(__self__, "query_string_whitelists", query_string_whitelists)

    @property
    @pulumi.getter(name="includeHost")
    def include_host(self) -> Optional[bool]:
        """
        If true requests to different hosts will be cached separately.
        """
        return pulumi.get(self, "include_host")

    @property
    @pulumi.getter(name="includeProtocol")
    def include_protocol(self) -> Optional[bool]:
        """
        If true, http and https requests will be cached separately.
        """
        return pulumi.get(self, "include_protocol")

    @property
    @pulumi.getter(name="includeQueryString")
    def include_query_string(self) -> Optional[bool]:
        """
        If true, include query string parameters in the cache key
        according to query_string_whitelist and
        query_string_blacklist. If neither is set, the entire query
        string will be included.
        If false, the query string will be excluded from the cache
        key entirely.
        """
        return pulumi.get(self, "include_query_string")

    @property
    @pulumi.getter(name="queryStringBlacklists")
    def query_string_blacklists(self) -> Optional[Sequence[str]]:
        """
        Names of query string parameters to exclude in cache keys.
        All other parameters will be included. Either specify
        query_string_whitelist or query_string_blacklist, not both.
        '&' and '=' will be percent encoded and not treated as
        delimiters.
        """
        return pulumi.get(self, "query_string_blacklists")

    @property
    @pulumi.getter(name="queryStringWhitelists")
    def query_string_whitelists(self) -> Optional[Sequence[str]]:
        """
        Names of query string parameters to include in cache keys.
        All other parameters will be excluded. Either specify
        query_string_whitelist or query_string_blacklist, not both.
        '&' and '=' will be percent encoded and not treated as
        delimiters.
        """
        return pulumi.get(self, "query_string_whitelists")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceCdnPolicyNegativeCachingPolicy(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 ttl: Optional[int] = None):
        """
        :param int code: The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
               can be specified as values, and you cannot specify a status code more than once.
        :param int ttl: The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
               (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
        can be specified as values, and you cannot specify a status code more than once.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
        (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        return pulumi.get(self, "ttl")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceCircuitBreakers(dict):
    def __init__(__self__, *,
                 connect_timeout: Optional['outputs.BackendServiceCircuitBreakersConnectTimeout'] = None,
                 max_connections: Optional[int] = None,
                 max_pending_requests: Optional[int] = None,
                 max_requests: Optional[int] = None,
                 max_requests_per_connection: Optional[int] = None,
                 max_retries: Optional[int] = None):
        """
        :param 'BackendServiceCircuitBreakersConnectTimeoutArgs' connect_timeout: The timeout for new network connections to hosts.  Structure is documented below.
        :param int max_connections: The maximum number of connections to the backend cluster.
               Defaults to 1024.
        :param int max_pending_requests: The maximum number of pending requests to the backend cluster.
               Defaults to 1024.
        :param int max_requests: The maximum number of parallel requests to the backend cluster.
               Defaults to 1024.
        :param int max_requests_per_connection: Maximum requests for a single backend connection. This parameter
               is respected by both the HTTP/1.1 and HTTP/2 implementations. If
               not specified, there is no limit. Setting this parameter to 1
               will effectively disable keep alive.
        :param int max_retries: The maximum number of parallel retries to the backend cluster.
               Defaults to 3.
        """
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_pending_requests is not None:
            pulumi.set(__self__, "max_pending_requests", max_pending_requests)
        if max_requests is not None:
            pulumi.set(__self__, "max_requests", max_requests)
        if max_requests_per_connection is not None:
            pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional['outputs.BackendServiceCircuitBreakersConnectTimeout']:
        """
        The timeout for new network connections to hosts.  Structure is documented below.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        """
        The maximum number of connections to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> Optional[int]:
        """
        The maximum number of pending requests to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_pending_requests")

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> Optional[int]:
        """
        The maximum number of parallel requests to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_requests")

    @property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> Optional[int]:
        """
        Maximum requests for a single backend connection. This parameter
        is respected by both the HTTP/1.1 and HTTP/2 implementations. If
        not specified, there is no limit. Setting this parameter to 1
        will effectively disable keep alive.
        """
        return pulumi.get(self, "max_requests_per_connection")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        """
        The maximum number of parallel retries to the backend cluster.
        Defaults to 3.
        """
        return pulumi.get(self, "max_retries")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceCircuitBreakersConnectTimeout(dict):
    def __init__(__self__, *,
                 seconds: int,
                 nanos: Optional[int] = None):
        """
        :param int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceConsistentHash(dict):
    def __init__(__self__, *,
                 http_cookie: Optional['outputs.BackendServiceConsistentHashHttpCookie'] = None,
                 http_header_name: Optional[str] = None,
                 minimum_ring_size: Optional[int] = None):
        """
        :param 'BackendServiceConsistentHashHttpCookieArgs' http_cookie: Hash is based on HTTP Cookie. This field describes a HTTP cookie
               that will be used as the hash key for the consistent hash load
               balancer. If the cookie is not present, it will be generated.
               This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
               Structure is documented below.
        :param str http_header_name: The hash based on the value of the specified header field.
               This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        :param int minimum_ring_size: The minimum number of virtual nodes to use for the hash ring.
               Larger ring sizes result in more granular load
               distributions. If the number of hosts in the load balancing pool
               is larger than the ring size, each host will be assigned a single
               virtual node.
               Defaults to 1024.
        """
        if http_cookie is not None:
            pulumi.set(__self__, "http_cookie", http_cookie)
        if http_header_name is not None:
            pulumi.set(__self__, "http_header_name", http_header_name)
        if minimum_ring_size is not None:
            pulumi.set(__self__, "minimum_ring_size", minimum_ring_size)

    @property
    @pulumi.getter(name="httpCookie")
    def http_cookie(self) -> Optional['outputs.BackendServiceConsistentHashHttpCookie']:
        """
        Hash is based on HTTP Cookie. This field describes a HTTP cookie
        that will be used as the hash key for the consistent hash load
        balancer. If the cookie is not present, it will be generated.
        This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
        Structure is documented below.
        """
        return pulumi.get(self, "http_cookie")

    @property
    @pulumi.getter(name="httpHeaderName")
    def http_header_name(self) -> Optional[str]:
        """
        The hash based on the value of the specified header field.
        This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        """
        return pulumi.get(self, "http_header_name")

    @property
    @pulumi.getter(name="minimumRingSize")
    def minimum_ring_size(self) -> Optional[int]:
        """
        The minimum number of virtual nodes to use for the hash ring.
        Larger ring sizes result in more granular load
        distributions. If the number of hosts in the load balancing pool
        is larger than the ring size, each host will be assigned a single
        virtual node.
        Defaults to 1024.
        """
        return pulumi.get(self, "minimum_ring_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceConsistentHashHttpCookie(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 path: Optional[str] = None,
                 ttl: Optional['outputs.BackendServiceConsistentHashHttpCookieTtl'] = None):
        """
        :param str name: Name of the cookie.
        :param str path: Path to set for the cookie.
        :param 'BackendServiceConsistentHashHttpCookieTtlArgs' ttl: The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
               (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the cookie.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to set for the cookie.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def ttl(self) -> Optional['outputs.BackendServiceConsistentHashHttpCookieTtl']:
        """
        The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
        (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        return pulumi.get(self, "ttl")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceConsistentHashHttpCookieTtl(dict):
    def __init__(__self__, *,
                 seconds: int,
                 nanos: Optional[int] = None):
        """
        :param int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceIap(dict):
    def __init__(__self__, *,
                 oauth2_client_id: str,
                 oauth2_client_secret: str,
                 oauth2_client_secret_sha256: Optional[str] = None):
        """
        :param str oauth2_client_id: OAuth2 Client ID for IAP
        :param str oauth2_client_secret: OAuth2 Client Secret for IAP
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param str oauth2_client_secret_sha256: -
               OAuth2 Client Secret SHA-256 for IAP
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "oauth2_client_id", oauth2_client_id)
        pulumi.set(__self__, "oauth2_client_secret", oauth2_client_secret)
        if oauth2_client_secret_sha256 is not None:
            pulumi.set(__self__, "oauth2_client_secret_sha256", oauth2_client_secret_sha256)

    @property
    @pulumi.getter(name="oauth2ClientId")
    def oauth2_client_id(self) -> str:
        """
        OAuth2 Client ID for IAP
        """
        return pulumi.get(self, "oauth2_client_id")

    @property
    @pulumi.getter(name="oauth2ClientSecret")
    def oauth2_client_secret(self) -> str:
        """
        OAuth2 Client Secret for IAP
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "oauth2_client_secret")

    @property
    @pulumi.getter(name="oauth2ClientSecretSha256")
    def oauth2_client_secret_sha256(self) -> Optional[str]:
        """
        -
        OAuth2 Client Secret SHA-256 for IAP
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "oauth2_client_secret_sha256")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceLogConfig(dict):
    def __init__(__self__, *,
                 enable: Optional[bool] = None,
                 sample_rate: Optional[float] = None):
        """
        :param bool enable: Whether to enable logging for the load balancer traffic served by this backend service.
        :param float sample_rate: This field can only be specified if logging is enabled for this backend service. The value of
               the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
               where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
               The default value is 1.0.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Whether to enable logging for the load balancer traffic served by this backend service.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        """
        This field can only be specified if logging is enabled for this backend service. The value of
        the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
        where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
        The default value is 1.0.
        """
        return pulumi.get(self, "sample_rate")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceOutlierDetection(dict):
    def __init__(__self__, *,
                 base_ejection_time: Optional['outputs.BackendServiceOutlierDetectionBaseEjectionTime'] = None,
                 consecutive_errors: Optional[int] = None,
                 consecutive_gateway_failure: Optional[int] = None,
                 enforcing_consecutive_errors: Optional[int] = None,
                 enforcing_consecutive_gateway_failure: Optional[int] = None,
                 enforcing_success_rate: Optional[int] = None,
                 interval: Optional['outputs.BackendServiceOutlierDetectionInterval'] = None,
                 max_ejection_percent: Optional[int] = None,
                 success_rate_minimum_hosts: Optional[int] = None,
                 success_rate_request_volume: Optional[int] = None,
                 success_rate_stdev_factor: Optional[int] = None):
        """
        :param 'BackendServiceOutlierDetectionBaseEjectionTimeArgs' base_ejection_time: The base time that a host is ejected for. The real time is equal to the base
               time multiplied by the number of times the host has been ejected. Defaults to
               30000ms or 30s.
               Structure is documented below.
        :param int consecutive_errors: Number of errors before a host is ejected from the connection pool. When the
               backend host is accessed over HTTP, a 5xx return code qualifies as an error.
               Defaults to 5.
        :param int consecutive_gateway_failure: The number of consecutive gateway failures (502, 503, 504 status or connection
               errors that are mapped to one of those status codes) before a consecutive
               gateway failure ejection occurs. Defaults to 5.
        :param int enforcing_consecutive_errors: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive 5xx. This setting can be used to disable
               ejection or to ramp it up slowly. Defaults to 100.
        :param int enforcing_consecutive_gateway_failure: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive gateway failures. This setting can be
               used to disable ejection or to ramp it up slowly. Defaults to 0.
        :param int enforcing_success_rate: The percentage chance that a host will be actually ejected when an outlier
               status is detected through success rate statistics. This setting can be used to
               disable ejection or to ramp it up slowly. Defaults to 100.
        :param 'BackendServiceOutlierDetectionIntervalArgs' interval: Time interval between ejection sweep analysis. This can result in both new
               ejections as well as hosts being returned to service. Defaults to 10 seconds.
               Structure is documented below.
        :param int max_ejection_percent: Maximum percentage of hosts in the load balancing pool for the backend service
               that can be ejected. Defaults to 10%.
        :param int success_rate_minimum_hosts: The number of hosts in a cluster that must have enough request volume to detect
               success rate outliers. If the number of hosts is less than this setting, outlier
               detection via success rate statistics is not performed for any host in the
               cluster. Defaults to 5.
        :param int success_rate_request_volume: The minimum number of total requests that must be collected in one interval (as
               defined by the interval duration above) to include this host in success rate
               based outlier detection. If the volume is lower than this setting, outlier
               detection via success rate statistics is not performed for that host. Defaults
               to 100.
        :param int success_rate_stdev_factor: This factor is used to determine the ejection threshold for success rate outlier
               ejection. The ejection threshold is the difference between the mean success
               rate, and the product of this factor and the standard deviation of the mean
               success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
               by a thousand to get a double. That is, if the desired factor is 1.9, the
               runtime value should be 1900. Defaults to 1900.
        """
        if base_ejection_time is not None:
            pulumi.set(__self__, "base_ejection_time", base_ejection_time)
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if consecutive_gateway_failure is not None:
            pulumi.set(__self__, "consecutive_gateway_failure", consecutive_gateway_failure)
        if enforcing_consecutive_errors is not None:
            pulumi.set(__self__, "enforcing_consecutive_errors", enforcing_consecutive_errors)
        if enforcing_consecutive_gateway_failure is not None:
            pulumi.set(__self__, "enforcing_consecutive_gateway_failure", enforcing_consecutive_gateway_failure)
        if enforcing_success_rate is not None:
            pulumi.set(__self__, "enforcing_success_rate", enforcing_success_rate)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        if success_rate_minimum_hosts is not None:
            pulumi.set(__self__, "success_rate_minimum_hosts", success_rate_minimum_hosts)
        if success_rate_request_volume is not None:
            pulumi.set(__self__, "success_rate_request_volume", success_rate_request_volume)
        if success_rate_stdev_factor is not None:
            pulumi.set(__self__, "success_rate_stdev_factor", success_rate_stdev_factor)

    @property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional['outputs.BackendServiceOutlierDetectionBaseEjectionTime']:
        """
        The base time that a host is ejected for. The real time is equal to the base
        time multiplied by the number of times the host has been ejected. Defaults to
        30000ms or 30s.
        Structure is documented below.
        """
        return pulumi.get(self, "base_ejection_time")

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[int]:
        """
        Number of errors before a host is ejected from the connection pool. When the
        backend host is accessed over HTTP, a 5xx return code qualifies as an error.
        Defaults to 5.
        """
        return pulumi.get(self, "consecutive_errors")

    @property
    @pulumi.getter(name="consecutiveGatewayFailure")
    def consecutive_gateway_failure(self) -> Optional[int]:
        """
        The number of consecutive gateway failures (502, 503, 504 status or connection
        errors that are mapped to one of those status codes) before a consecutive
        gateway failure ejection occurs. Defaults to 5.
        """
        return pulumi.get(self, "consecutive_gateway_failure")

    @property
    @pulumi.getter(name="enforcingConsecutiveErrors")
    def enforcing_consecutive_errors(self) -> Optional[int]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive 5xx. This setting can be used to disable
        ejection or to ramp it up slowly. Defaults to 100.
        """
        return pulumi.get(self, "enforcing_consecutive_errors")

    @property
    @pulumi.getter(name="enforcingConsecutiveGatewayFailure")
    def enforcing_consecutive_gateway_failure(self) -> Optional[int]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive gateway failures. This setting can be
        used to disable ejection or to ramp it up slowly. Defaults to 0.
        """
        return pulumi.get(self, "enforcing_consecutive_gateway_failure")

    @property
    @pulumi.getter(name="enforcingSuccessRate")
    def enforcing_success_rate(self) -> Optional[int]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through success rate statistics. This setting can be used to
        disable ejection or to ramp it up slowly. Defaults to 100.
        """
        return pulumi.get(self, "enforcing_success_rate")

    @property
    @pulumi.getter
    def interval(self) -> Optional['outputs.BackendServiceOutlierDetectionInterval']:
        """
        Time interval between ejection sweep analysis. This can result in both new
        ejections as well as hosts being returned to service. Defaults to 10 seconds.
        Structure is documented below.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[int]:
        """
        Maximum percentage of hosts in the load balancing pool for the backend service
        that can be ejected. Defaults to 10%.
        """
        return pulumi.get(self, "max_ejection_percent")

    @property
    @pulumi.getter(name="successRateMinimumHosts")
    def success_rate_minimum_hosts(self) -> Optional[int]:
        """
        The number of hosts in a cluster that must have enough request volume to detect
        success rate outliers. If the number of hosts is less than this setting, outlier
        detection via success rate statistics is not performed for any host in the
        cluster. Defaults to 5.
        """
        return pulumi.get(self, "success_rate_minimum_hosts")

    @property
    @pulumi.getter(name="successRateRequestVolume")
    def success_rate_request_volume(self) -> Optional[int]:
        """
        The minimum number of total requests that must be collected in one interval (as
        defined by the interval duration above) to include this host in success rate
        based outlier detection. If the volume is lower than this setting, outlier
        detection via success rate statistics is not performed for that host. Defaults
        to 100.
        """
        return pulumi.get(self, "success_rate_request_volume")

    @property
    @pulumi.getter(name="successRateStdevFactor")
    def success_rate_stdev_factor(self) -> Optional[int]:
        """
        This factor is used to determine the ejection threshold for success rate outlier
        ejection. The ejection threshold is the difference between the mean success
        rate, and the product of this factor and the standard deviation of the mean
        success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
        by a thousand to get a double. That is, if the desired factor is 1.9, the
        runtime value should be 1900. Defaults to 1900.
        """
        return pulumi.get(self, "success_rate_stdev_factor")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceOutlierDetectionBaseEjectionTime(dict):
    def __init__(__self__, *,
                 seconds: int,
                 nanos: Optional[int] = None):
        """
        :param int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendServiceOutlierDetectionInterval(dict):
    def __init__(__self__, *,
                 seconds: int,
                 nanos: Optional[int] = None):
        """
        :param int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DiskDiskEncryptionKey(dict):
    def __init__(__self__, *,
                 kms_key_self_link: Optional[str] = None,
                 kms_key_service_account: Optional[str] = None,
                 raw_key: Optional[str] = None,
                 sha256: Optional[str] = None):
        """
        :param str kms_key_self_link: The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
               `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param str sha256: -
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        """
        The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
        `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        return pulumi.get(self, "kms_key_self_link")

    @property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[str]:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        -
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DiskIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DiskIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DiskSourceImageEncryptionKey(dict):
    def __init__(__self__, *,
                 kms_key_self_link: Optional[str] = None,
                 kms_key_service_account: Optional[str] = None,
                 raw_key: Optional[str] = None,
                 sha256: Optional[str] = None):
        """
        :param str kms_key_self_link: The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
               `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param str sha256: -
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        """
        The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
        `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        return pulumi.get(self, "kms_key_self_link")

    @property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[str]:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        -
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DiskSourceSnapshotEncryptionKey(dict):
    def __init__(__self__, *,
                 kms_key_self_link: Optional[str] = None,
                 kms_key_service_account: Optional[str] = None,
                 raw_key: Optional[str] = None,
                 sha256: Optional[str] = None):
        """
        :param str kms_key_self_link: The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
               `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param str sha256: -
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        """
        The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
        `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        return pulumi.get(self, "kms_key_self_link")

    @property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[str]:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        -
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ExternalVpnGatewayInterface(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None,
                 ip_address: Optional[str] = None):
        """
        :param int id: The numeric ID for this interface. Allowed values are based on the redundancy type
               of this external VPN gateway
               * `0 - SINGLE_IP_INTERNALLY_REDUNDANT`
               * `0, 1 - TWO_IPS_REDUNDANCY`
               * `0, 1, 2, 3 - FOUR_IPS_REDUNDANCY`
        :param str ip_address: IP address of the interface in the external VPN gateway.
               Only IPv4 is supported. This IP address can be either from
               your on-premise gateway or another Cloud provider's VPN gateway,
               it cannot be an IP address from Google Compute Engine.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The numeric ID for this interface. Allowed values are based on the redundancy type
        of this external VPN gateway
        * `0 - SINGLE_IP_INTERNALLY_REDUNDANT`
        * `0, 1 - TWO_IPS_REDUNDANCY`
        * `0, 1, 2, 3 - FOUR_IPS_REDUNDANCY`
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        IP address of the interface in the external VPN gateway.
        Only IPv4 is supported. This IP address can be either from
        your on-premise gateway or another Cloud provider's VPN gateway,
        it cannot be an IP address from Google Compute Engine.
        """
        return pulumi.get(self, "ip_address")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FirewallAllow(dict):
    def __init__(__self__, *,
                 protocol: str,
                 ports: Optional[Sequence[str]] = None):
        """
        :param str protocol: The IP protocol to which this rule applies. The protocol type is
               required when creating a firewall rule. This value can either be
               one of the following well known protocol strings (tcp, udp,
               icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
        :param Sequence[str] ports: An optional list of ports to which this rule applies. This field
               is only applicable for UDP or TCP protocol. Each entry must be
               either an integer or a range. If not specified, this rule
               applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and
               ["12345-12349"].
        """
        pulumi.set(__self__, "protocol", protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The IP protocol to which this rule applies. The protocol type is
        required when creating a firewall rule. This value can either be
        one of the following well known protocol strings (tcp, udp,
        icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and
        ["12345-12349"].
        """
        return pulumi.get(self, "ports")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FirewallDeny(dict):
    def __init__(__self__, *,
                 protocol: str,
                 ports: Optional[Sequence[str]] = None):
        """
        :param str protocol: The IP protocol to which this rule applies. The protocol type is
               required when creating a firewall rule. This value can either be
               one of the following well known protocol strings (tcp, udp,
               icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
        :param Sequence[str] ports: An optional list of ports to which this rule applies. This field
               is only applicable for UDP or TCP protocol. Each entry must be
               either an integer or a range. If not specified, this rule
               applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and
               ["12345-12349"].
        """
        pulumi.set(__self__, "protocol", protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The IP protocol to which this rule applies. The protocol type is
        required when creating a firewall rule. This value can either be
        one of the following well known protocol strings (tcp, udp,
        icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and
        ["12345-12349"].
        """
        return pulumi.get(self, "ports")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FirewallLogConfig(dict):
    def __init__(__self__, *,
                 metadata: str):
        """
        :param str metadata: This field denotes whether to include or exclude metadata for firewall logs.
               Possible values are `EXCLUDE_ALL_METADATA` and `INCLUDE_ALL_METADATA`.
        """
        pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> str:
        """
        This field denotes whether to include or exclude metadata for firewall logs.
        Possible values are `EXCLUDE_ALL_METADATA` and `INCLUDE_ALL_METADATA`.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalForwardingRuleMetadataFilter(dict):
    def __init__(__self__, *,
                 filter_labels: Sequence['outputs.GlobalForwardingRuleMetadataFilterFilterLabel'],
                 filter_match_criteria: str):
        """
        :param Sequence['GlobalForwardingRuleMetadataFilterFilterLabelArgs'] filter_labels: The list of label value pairs that must match labels in the
               provided metadata based on filterMatchCriteria
               This list must not be empty and can have at the most 64 entries.
               Structure is documented below.
        :param str filter_match_criteria: Specifies how individual filterLabel matches within the list of
               filterLabels contribute towards the overall metadataFilter match.
               MATCH_ANY - At least one of the filterLabels must have a matching
               label in the provided metadata.
               MATCH_ALL - All filterLabels must have matching labels in the
               provided metadata.
               Possible values are `MATCH_ANY` and `MATCH_ALL`.
        """
        pulumi.set(__self__, "filter_labels", filter_labels)
        pulumi.set(__self__, "filter_match_criteria", filter_match_criteria)

    @property
    @pulumi.getter(name="filterLabels")
    def filter_labels(self) -> Sequence['outputs.GlobalForwardingRuleMetadataFilterFilterLabel']:
        """
        The list of label value pairs that must match labels in the
        provided metadata based on filterMatchCriteria
        This list must not be empty and can have at the most 64 entries.
        Structure is documented below.
        """
        return pulumi.get(self, "filter_labels")

    @property
    @pulumi.getter(name="filterMatchCriteria")
    def filter_match_criteria(self) -> str:
        """
        Specifies how individual filterLabel matches within the list of
        filterLabels contribute towards the overall metadataFilter match.
        MATCH_ANY - At least one of the filterLabels must have a matching
        label in the provided metadata.
        MATCH_ALL - All filterLabels must have matching labels in the
        provided metadata.
        Possible values are `MATCH_ANY` and `MATCH_ALL`.
        """
        return pulumi.get(self, "filter_match_criteria")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalForwardingRuleMetadataFilterFilterLabel(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the metadata label. The length must be between
               1 and 1024 characters, inclusive.
        :param str value: The value that the label must match. The value has a maximum
               length of 1024 characters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the metadata label. The length must be between
        1 and 1024 characters, inclusive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that the label must match. The value has a maximum
        length of 1024 characters.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HaVpnGatewayVpnInterface(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None,
                 ip_address: Optional[str] = None):
        """
        :param int id: an identifier for the resource with format `projects/{{project}}/regions/{{region}}/vpnGateways/{{name}}`
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        an identifier for the resource with format `projects/{{project}}/regions/{{region}}/vpnGateways/{{name}}`
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        return pulumi.get(self, "ip_address")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HealthCheckGrpcHealthCheck(dict):
    def __init__(__self__, *,
                 grpc_service_name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_name: Optional[str] = None,
                 port_specification: Optional[str] = None):
        """
        :param str grpc_service_name: The gRPC service name for the health check.
               The value of grpcServiceName has the following meanings by convention:
               - Empty serviceName means the overall status of all services at the backend.
               - Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
               The grpcServiceName can only be ASCII.
        :param int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        if grpc_service_name is not None:
            pulumi.set(__self__, "grpc_service_name", grpc_service_name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)

    @property
    @pulumi.getter(name="grpcServiceName")
    def grpc_service_name(self) -> Optional[str]:
        """
        The gRPC service name for the health check.
        The value of grpcServiceName has the following meanings by convention:
        - Empty serviceName means the overall status of all services at the backend.
        - Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
        The grpcServiceName can only be ASCII.
        """
        return pulumi.get(self, "grpc_service_name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HealthCheckHttp2HealthCheck(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional[int] = None,
                 port_name: Optional[str] = None,
                 port_specification: Optional[str] = None,
                 proxy_header: Optional[str] = None,
                 request_path: Optional[str] = None,
                 response: Optional[str] = None):
        """
        :param str host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        :param str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are `NONE` and `PROXY_V1`.
        :param str request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request_path is not None:
            pulumi.set(__self__, "request_path", request_path)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[str]:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HealthCheckHttpHealthCheck(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional[int] = None,
                 port_name: Optional[str] = None,
                 port_specification: Optional[str] = None,
                 proxy_header: Optional[str] = None,
                 request_path: Optional[str] = None,
                 response: Optional[str] = None):
        """
        :param str host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        :param str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are `NONE` and `PROXY_V1`.
        :param str request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request_path is not None:
            pulumi.set(__self__, "request_path", request_path)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[str]:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HealthCheckHttpsHealthCheck(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional[int] = None,
                 port_name: Optional[str] = None,
                 port_specification: Optional[str] = None,
                 proxy_header: Optional[str] = None,
                 request_path: Optional[str] = None,
                 response: Optional[str] = None):
        """
        :param str host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        :param str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are `NONE` and `PROXY_V1`.
        :param str request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request_path is not None:
            pulumi.set(__self__, "request_path", request_path)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[str]:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HealthCheckLogConfig(dict):
    def __init__(__self__, *,
                 enable: Optional[bool] = None):
        """
        :param bool enable: Indicates whether or not to export logs. This is false by default,
               which means no health check logging will be done.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Indicates whether or not to export logs. This is false by default,
        which means no health check logging will be done.
        """
        return pulumi.get(self, "enable")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HealthCheckSslHealthCheck(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None,
                 port_name: Optional[str] = None,
                 port_specification: Optional[str] = None,
                 proxy_header: Optional[str] = None,
                 request: Optional[str] = None,
                 response: Optional[str] = None):
        """
        :param int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        :param str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are `NONE` and `PROXY_V1`.
        :param str request: The application data to send once the SSL connection has been
               established (default value is empty). If both request and response are
               empty, the connection establishment alone will indicate health. The request
               data can only be ASCII.
        :param str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter
    def request(self) -> Optional[str]:
        """
        The application data to send once the SSL connection has been
        established (default value is empty). If both request and response are
        empty, the connection establishment alone will indicate health. The request
        data can only be ASCII.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HealthCheckTcpHealthCheck(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None,
                 port_name: Optional[str] = None,
                 port_specification: Optional[str] = None,
                 proxy_header: Optional[str] = None,
                 request: Optional[str] = None,
                 response: Optional[str] = None):
        """
        :param int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        :param str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are `NONE` and `PROXY_V1`.
        :param str request: The application data to send once the SSL connection has been
               established (default value is empty). If both request and response are
               empty, the connection establishment alone will indicate health. The request
               data can only be ASCII.
        :param str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter
    def request(self) -> Optional[str]:
        """
        The application data to send once the SSL connection has been
        established (default value is empty). If both request and response are
        empty, the connection establishment alone will indicate health. The request
        data can only be ASCII.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ImageGuestOsFeature(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
               Possible values are `MULTI_IP_SUBNET`, `SECURE_BOOT`, `SEV_CAPABLE`, `UEFI_COMPATIBLE`, `VIRTIO_SCSI_MULTIQUEUE`, `WINDOWS`, and `GVNIC`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
        Possible values are `MULTI_IP_SUBNET`, `SECURE_BOOT`, `SEV_CAPABLE`, `UEFI_COMPATIBLE`, `VIRTIO_SCSI_MULTIQUEUE`, `WINDOWS`, and `GVNIC`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ImageIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        """
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str title: A title for the expression, i.e. a short string describing its purpose.
        :param str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ImageIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        """
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str title: A title for the expression, i.e. a short string describing its purpose.
        :param str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ImageRawDisk(dict):
    def __init__(__self__, *,
                 source: str,
                 container_type: Optional[str] = None,
                 sha1: Optional[str] = None):
        """
        :param str source: The full Google Cloud Storage URL where disk storage is stored
               You must provide either this property or the sourceDisk property
               but not both.
        :param str container_type: The format used to encode and transmit the block device, which
               should be TAR. This is just a container and transmission format
               and not a runtime format. Provided by the client when the disk
               image is created.
               Default value is `TAR`.
               Possible values are `TAR`.
        :param str sha1: An optional SHA1 checksum of the disk image before unpackaging.
               This is provided by the client when the disk image is created.
        """
        pulumi.set(__self__, "source", source)
        if container_type is not None:
            pulumi.set(__self__, "container_type", container_type)
        if sha1 is not None:
            pulumi.set(__self__, "sha1", sha1)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The full Google Cloud Storage URL where disk storage is stored
        You must provide either this property or the sourceDisk property
        but not both.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="containerType")
    def container_type(self) -> Optional[str]:
        """
        The format used to encode and transmit the block device, which
        should be TAR. This is just a container and transmission format
        and not a runtime format. Provided by the client when the disk
        image is created.
        Default value is `TAR`.
        Possible values are `TAR`.
        """
        return pulumi.get(self, "container_type")

    @property
    @pulumi.getter
    def sha1(self) -> Optional[str]:
        """
        An optional SHA1 checksum of the disk image before unpackaging.
        This is provided by the client when the disk image is created.
        """
        return pulumi.get(self, "sha1")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceAttachedDisk(dict):
    def __init__(__self__, *,
                 source: str,
                 device_name: Optional[str] = None,
                 disk_encryption_key_raw: Optional[str] = None,
                 disk_encryption_key_sha256: Optional[str] = None,
                 kms_key_self_link: Optional[str] = None,
                 mode: Optional[str] = None):
        """
        :param str source: The name or self_link of the disk to attach to this instance.
        :param str device_name: Name with which the attached disk will be accessible
               under `/dev/disk/by-id/google-*`
        :param str disk_encryption_key_raw: A 256-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
               encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               to encrypt this disk. Only one of `kms_key_self_link` and `disk_encryption_key_raw` may be set.
        :param str kms_key_self_link: The self_link of the encryption key that is
               stored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`
               and `disk_encryption_key_raw` may be set.
        :param str mode: Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
               If you have a persistent disk with data that you want to share
               between multiple instances, detach it from any read-write instances and
               attach it to one or more instances in read-only mode.
        """
        pulumi.set(__self__, "source", source)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key_raw is not None:
            pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        if disk_encryption_key_sha256 is not None:
            pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The name or self_link of the disk to attach to this instance.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        Name with which the attached disk will be accessible
        under `/dev/disk/by-id/google-*`
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[str]:
        """
        A 256-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
        encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        to encrypt this disk. Only one of `kms_key_self_link` and `disk_encryption_key_raw` may be set.
        """
        return pulumi.get(self, "disk_encryption_key_raw")

    @property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[str]:
        return pulumi.get(self, "disk_encryption_key_sha256")

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        """
        The self_link of the encryption key that is
        stored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`
        and `disk_encryption_key_raw` may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
        If you have a persistent disk with data that you want to share
        between multiple instances, detach it from any read-write instances and
        attach it to one or more instances in read-only mode.
        """
        return pulumi.get(self, "mode")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceBootDisk(dict):
    def __init__(__self__, *,
                 auto_delete: Optional[bool] = None,
                 device_name: Optional[str] = None,
                 disk_encryption_key_raw: Optional[str] = None,
                 disk_encryption_key_sha256: Optional[str] = None,
                 initialize_params: Optional['outputs.InstanceBootDiskInitializeParams'] = None,
                 kms_key_self_link: Optional[str] = None,
                 mode: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param bool auto_delete: Whether the disk will be auto-deleted when the instance
               is deleted. Defaults to true.
        :param str device_name: Name with which the attached disk will be accessible
               under `/dev/disk/by-id/google-*`
        :param str disk_encryption_key_raw: A 256-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
               encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               to encrypt this disk. Only one of `kms_key_self_link` and `disk_encryption_key_raw` may be set.
        :param 'InstanceBootDiskInitializeParamsArgs' initialize_params: Parameters for a new disk that will be created
               alongside the new instance. Either `initialize_params` or `source` must be set.
               Structure is documented below.
        :param str kms_key_self_link: The self_link of the encryption key that is
               stored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`
               and `disk_encryption_key_raw` may be set.
        :param str mode: Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
               If you have a persistent disk with data that you want to share
               between multiple instances, detach it from any read-write instances and
               attach it to one or more instances in read-only mode.
        :param str source: The name or self_link of the disk to attach to this instance.
        """
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key_raw is not None:
            pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        if disk_encryption_key_sha256 is not None:
            pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[bool]:
        """
        Whether the disk will be auto-deleted when the instance
        is deleted. Defaults to true.
        """
        return pulumi.get(self, "auto_delete")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        Name with which the attached disk will be accessible
        under `/dev/disk/by-id/google-*`
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[str]:
        """
        A 256-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
        encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        to encrypt this disk. Only one of `kms_key_self_link` and `disk_encryption_key_raw` may be set.
        """
        return pulumi.get(self, "disk_encryption_key_raw")

    @property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[str]:
        return pulumi.get(self, "disk_encryption_key_sha256")

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional['outputs.InstanceBootDiskInitializeParams']:
        """
        Parameters for a new disk that will be created
        alongside the new instance. Either `initialize_params` or `source` must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "initialize_params")

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        """
        The self_link of the encryption key that is
        stored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`
        and `disk_encryption_key_raw` may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
        If you have a persistent disk with data that you want to share
        between multiple instances, detach it from any read-write instances and
        attach it to one or more instances in read-only mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        The name or self_link of the disk to attach to this instance.
        """
        return pulumi.get(self, "source")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceBootDiskInitializeParams(dict):
    def __init__(__self__, *,
                 image: Optional[str] = None,
                 labels: Optional[Mapping[str, Any]] = None,
                 size: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param str image: The image from which to initialize this disk. This can be
               one of: the image's `self_link`, `projects/{project}/global/images/{image}`,
               `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
               `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
               `{project}/{image}`, `{family}`, or `{image}`. If referred by family, the
               images names must include the family name. If they don't, use the
               [compute.Image data source](https://www.terraform.io/docs/providers/google/d/compute_image.html).
               For instance, the image `centos-6-v20180104` includes its family name `centos-6`.
               These images can be referred by family name here.
        :param Mapping[str, Any] labels: A map of key/value label pairs to assign to the instance.
        :param int size: The size of the image in gigabytes. If not specified, it
               will inherit the size of its base image.
        :param str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The image from which to initialize this disk. This can be
        one of: the image's `self_link`, `projects/{project}/global/images/{image}`,
        `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
        `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
        `{project}/{image}`, `{family}`, or `{image}`. If referred by family, the
        images names must include the family name. If they don't, use the
        [compute.Image data source](https://www.terraform.io/docs/providers/google/d/compute_image.html).
        For instance, the image `centos-6-v20180104` includes its family name `centos-6`.
        These images can be referred by family name here.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        A map of key/value label pairs to assign to the instance.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of the image in gigabytes. If not specified, it
        will inherit the size of its base image.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceConfidentialInstanceConfig(dict):
    def __init__(__self__, *,
                 enable_confidential_compute: bool):
        """
        :param bool enable_confidential_compute: Defines whether the instance should have confidential compute enabled. `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.
        """
        pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> bool:
        """
        Defines whether the instance should have confidential compute enabled. `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.
        """
        return pulumi.get(self, "enable_confidential_compute")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromMachineImageAttachedDisk(dict):
    def __init__(__self__, *,
                 source: str,
                 device_name: Optional[str] = None,
                 disk_encryption_key_raw: Optional[str] = None,
                 disk_encryption_key_sha256: Optional[str] = None,
                 kms_key_self_link: Optional[str] = None,
                 mode: Optional[str] = None):
        pulumi.set(__self__, "source", source)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key_raw is not None:
            pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        if disk_encryption_key_sha256 is not None:
            pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[str]:
        return pulumi.get(self, "disk_encryption_key_raw")

    @property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[str]:
        return pulumi.get(self, "disk_encryption_key_sha256")

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_self_link")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromMachineImageBootDisk(dict):
    def __init__(__self__, *,
                 auto_delete: Optional[bool] = None,
                 device_name: Optional[str] = None,
                 disk_encryption_key_raw: Optional[str] = None,
                 disk_encryption_key_sha256: Optional[str] = None,
                 initialize_params: Optional['outputs.InstanceFromMachineImageBootDiskInitializeParams'] = None,
                 kms_key_self_link: Optional[str] = None,
                 mode: Optional[str] = None,
                 source: Optional[str] = None):
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key_raw is not None:
            pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        if disk_encryption_key_sha256 is not None:
            pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[bool]:
        return pulumi.get(self, "auto_delete")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[str]:
        return pulumi.get(self, "disk_encryption_key_raw")

    @property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[str]:
        return pulumi.get(self, "disk_encryption_key_sha256")

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional['outputs.InstanceFromMachineImageBootDiskInitializeParams']:
        return pulumi.get(self, "initialize_params")

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_self_link")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromMachineImageBootDiskInitializeParams(dict):
    def __init__(__self__, *,
                 image: Optional[str] = None,
                 labels: Optional[Mapping[str, Any]] = None,
                 size: Optional[int] = None,
                 type: Optional[str] = None):
        if image is not None:
            pulumi.set(__self__, "image", image)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromMachineImageConfidentialInstanceConfig(dict):
    def __init__(__self__, *,
                 enable_confidential_compute: bool):
        pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> bool:
        return pulumi.get(self, "enable_confidential_compute")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromMachineImageGuestAccelerator(dict):
    def __init__(__self__, *,
                 count: int,
                 type: str):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromMachineImageNetworkInterface(dict):
    def __init__(__self__, *,
                 access_configs: Optional[Sequence['outputs.InstanceFromMachineImageNetworkInterfaceAccessConfig']] = None,
                 alias_ip_ranges: Optional[Sequence['outputs.InstanceFromMachineImageNetworkInterfaceAliasIpRange']] = None,
                 name: Optional[str] = None,
                 network: Optional[str] = None,
                 network_ip: Optional[str] = None,
                 nic_type: Optional[str] = None,
                 subnetwork: Optional[str] = None,
                 subnetwork_project: Optional[str] = None):
        """
        :param str name: A unique name for the resource, required by GCE.
               Changing this forces a new resource to be created.
        """
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if alias_ip_ranges is not None:
            pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_ip is not None:
            pulumi.set(__self__, "network_ip", network_ip)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if subnetwork is not None:
            pulumi.set(__self__, "subnetwork", subnetwork)
        if subnetwork_project is not None:
            pulumi.set(__self__, "subnetwork_project", subnetwork_project)

    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.InstanceFromMachineImageNetworkInterfaceAccessConfig']]:
        return pulumi.get(self, "access_configs")

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[Sequence['outputs.InstanceFromMachineImageNetworkInterfaceAliasIpRange']]:
        return pulumi.get(self, "alias_ip_ranges")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A unique name for the resource, required by GCE.
        Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> Optional[str]:
        return pulumi.get(self, "network_ip")

    @property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[str]:
        return pulumi.get(self, "nic_type")

    @property
    @pulumi.getter
    def subnetwork(self) -> Optional[str]:
        return pulumi.get(self, "subnetwork")

    @property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> Optional[str]:
        return pulumi.get(self, "subnetwork_project")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromMachineImageNetworkInterfaceAccessConfig(dict):
    def __init__(__self__, *,
                 nat_ip: Optional[str] = None,
                 network_tier: Optional[str] = None,
                 public_ptr_domain_name: Optional[str] = None):
        if nat_ip is not None:
            pulumi.set(__self__, "nat_ip", nat_ip)
        if network_tier is not None:
            pulumi.set(__self__, "network_tier", network_tier)
        if public_ptr_domain_name is not None:
            pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)

    @property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> Optional[str]:
        return pulumi.get(self, "nat_ip")

    @property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> Optional[str]:
        return pulumi.get(self, "network_tier")

    @property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[str]:
        return pulumi.get(self, "public_ptr_domain_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromMachineImageNetworkInterfaceAliasIpRange(dict):
    def __init__(__self__, *,
                 ip_cidr_range: str,
                 subnetwork_range_name: Optional[str] = None):
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        if subnetwork_range_name is not None:
            pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> str:
        return pulumi.get(self, "ip_cidr_range")

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> Optional[str]:
        return pulumi.get(self, "subnetwork_range_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromMachineImageScheduling(dict):
    def __init__(__self__, *,
                 automatic_restart: Optional[bool] = None,
                 min_node_cpus: Optional[int] = None,
                 node_affinities: Optional[Sequence['outputs.InstanceFromMachineImageSchedulingNodeAffinity']] = None,
                 on_host_maintenance: Optional[str] = None,
                 preemptible: Optional[bool] = None):
        if automatic_restart is not None:
            pulumi.set(__self__, "automatic_restart", automatic_restart)
        if min_node_cpus is not None:
            pulumi.set(__self__, "min_node_cpus", min_node_cpus)
        if node_affinities is not None:
            pulumi.set(__self__, "node_affinities", node_affinities)
        if on_host_maintenance is not None:
            pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> Optional[bool]:
        return pulumi.get(self, "automatic_restart")

    @property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> Optional[int]:
        return pulumi.get(self, "min_node_cpus")

    @property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Optional[Sequence['outputs.InstanceFromMachineImageSchedulingNodeAffinity']]:
        return pulumi.get(self, "node_affinities")

    @property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> Optional[str]:
        return pulumi.get(self, "on_host_maintenance")

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[bool]:
        return pulumi.get(self, "preemptible")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromMachineImageSchedulingNodeAffinity(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromMachineImageScratchDisk(dict):
    def __init__(__self__, *,
                 interface: str):
        pulumi.set(__self__, "interface", interface)

    @property
    @pulumi.getter
    def interface(self) -> str:
        return pulumi.get(self, "interface")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromMachineImageServiceAccount(dict):
    def __init__(__self__, *,
                 scopes: Sequence[str],
                 email: Optional[str] = None):
        pulumi.set(__self__, "scopes", scopes)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        return pulumi.get(self, "email")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromMachineImageShieldedInstanceConfig(dict):
    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[bool] = None,
                 enable_secure_boot: Optional[bool] = None,
                 enable_vtpm: Optional[bool] = None):
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        if enable_vtpm is not None:
            pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[bool]:
        return pulumi.get(self, "enable_integrity_monitoring")

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[bool]:
        return pulumi.get(self, "enable_secure_boot")

    @property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> Optional[bool]:
        return pulumi.get(self, "enable_vtpm")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateAttachedDisk(dict):
    def __init__(__self__, *,
                 source: str,
                 device_name: Optional[str] = None,
                 disk_encryption_key_raw: Optional[str] = None,
                 disk_encryption_key_sha256: Optional[str] = None,
                 kms_key_self_link: Optional[str] = None,
                 mode: Optional[str] = None):
        pulumi.set(__self__, "source", source)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key_raw is not None:
            pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        if disk_encryption_key_sha256 is not None:
            pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[str]:
        return pulumi.get(self, "disk_encryption_key_raw")

    @property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[str]:
        return pulumi.get(self, "disk_encryption_key_sha256")

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_self_link")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateBootDisk(dict):
    def __init__(__self__, *,
                 auto_delete: Optional[bool] = None,
                 device_name: Optional[str] = None,
                 disk_encryption_key_raw: Optional[str] = None,
                 disk_encryption_key_sha256: Optional[str] = None,
                 initialize_params: Optional['outputs.InstanceFromTemplateBootDiskInitializeParams'] = None,
                 kms_key_self_link: Optional[str] = None,
                 mode: Optional[str] = None,
                 source: Optional[str] = None):
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key_raw is not None:
            pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        if disk_encryption_key_sha256 is not None:
            pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[bool]:
        return pulumi.get(self, "auto_delete")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[str]:
        return pulumi.get(self, "disk_encryption_key_raw")

    @property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[str]:
        return pulumi.get(self, "disk_encryption_key_sha256")

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional['outputs.InstanceFromTemplateBootDiskInitializeParams']:
        return pulumi.get(self, "initialize_params")

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_self_link")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateBootDiskInitializeParams(dict):
    def __init__(__self__, *,
                 image: Optional[str] = None,
                 labels: Optional[Mapping[str, Any]] = None,
                 size: Optional[int] = None,
                 type: Optional[str] = None):
        if image is not None:
            pulumi.set(__self__, "image", image)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateConfidentialInstanceConfig(dict):
    def __init__(__self__, *,
                 enable_confidential_compute: bool):
        pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> bool:
        return pulumi.get(self, "enable_confidential_compute")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateGuestAccelerator(dict):
    def __init__(__self__, *,
                 count: int,
                 type: str):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateNetworkInterface(dict):
    def __init__(__self__, *,
                 access_configs: Optional[Sequence['outputs.InstanceFromTemplateNetworkInterfaceAccessConfig']] = None,
                 alias_ip_ranges: Optional[Sequence['outputs.InstanceFromTemplateNetworkInterfaceAliasIpRange']] = None,
                 name: Optional[str] = None,
                 network: Optional[str] = None,
                 network_ip: Optional[str] = None,
                 nic_type: Optional[str] = None,
                 subnetwork: Optional[str] = None,
                 subnetwork_project: Optional[str] = None):
        """
        :param str name: A unique name for the resource, required by GCE.
               Changing this forces a new resource to be created.
        """
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if alias_ip_ranges is not None:
            pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_ip is not None:
            pulumi.set(__self__, "network_ip", network_ip)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if subnetwork is not None:
            pulumi.set(__self__, "subnetwork", subnetwork)
        if subnetwork_project is not None:
            pulumi.set(__self__, "subnetwork_project", subnetwork_project)

    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.InstanceFromTemplateNetworkInterfaceAccessConfig']]:
        return pulumi.get(self, "access_configs")

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[Sequence['outputs.InstanceFromTemplateNetworkInterfaceAliasIpRange']]:
        return pulumi.get(self, "alias_ip_ranges")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A unique name for the resource, required by GCE.
        Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> Optional[str]:
        return pulumi.get(self, "network_ip")

    @property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[str]:
        return pulumi.get(self, "nic_type")

    @property
    @pulumi.getter
    def subnetwork(self) -> Optional[str]:
        return pulumi.get(self, "subnetwork")

    @property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> Optional[str]:
        return pulumi.get(self, "subnetwork_project")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateNetworkInterfaceAccessConfig(dict):
    def __init__(__self__, *,
                 nat_ip: Optional[str] = None,
                 network_tier: Optional[str] = None,
                 public_ptr_domain_name: Optional[str] = None):
        if nat_ip is not None:
            pulumi.set(__self__, "nat_ip", nat_ip)
        if network_tier is not None:
            pulumi.set(__self__, "network_tier", network_tier)
        if public_ptr_domain_name is not None:
            pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)

    @property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> Optional[str]:
        return pulumi.get(self, "nat_ip")

    @property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> Optional[str]:
        return pulumi.get(self, "network_tier")

    @property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[str]:
        return pulumi.get(self, "public_ptr_domain_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateNetworkInterfaceAliasIpRange(dict):
    def __init__(__self__, *,
                 ip_cidr_range: str,
                 subnetwork_range_name: Optional[str] = None):
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        if subnetwork_range_name is not None:
            pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> str:
        return pulumi.get(self, "ip_cidr_range")

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> Optional[str]:
        return pulumi.get(self, "subnetwork_range_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateScheduling(dict):
    def __init__(__self__, *,
                 automatic_restart: Optional[bool] = None,
                 min_node_cpus: Optional[int] = None,
                 node_affinities: Optional[Sequence['outputs.InstanceFromTemplateSchedulingNodeAffinity']] = None,
                 on_host_maintenance: Optional[str] = None,
                 preemptible: Optional[bool] = None):
        if automatic_restart is not None:
            pulumi.set(__self__, "automatic_restart", automatic_restart)
        if min_node_cpus is not None:
            pulumi.set(__self__, "min_node_cpus", min_node_cpus)
        if node_affinities is not None:
            pulumi.set(__self__, "node_affinities", node_affinities)
        if on_host_maintenance is not None:
            pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> Optional[bool]:
        return pulumi.get(self, "automatic_restart")

    @property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> Optional[int]:
        return pulumi.get(self, "min_node_cpus")

    @property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Optional[Sequence['outputs.InstanceFromTemplateSchedulingNodeAffinity']]:
        return pulumi.get(self, "node_affinities")

    @property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> Optional[str]:
        return pulumi.get(self, "on_host_maintenance")

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[bool]:
        return pulumi.get(self, "preemptible")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateSchedulingNodeAffinity(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateScratchDisk(dict):
    def __init__(__self__, *,
                 interface: str):
        pulumi.set(__self__, "interface", interface)

    @property
    @pulumi.getter
    def interface(self) -> str:
        return pulumi.get(self, "interface")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateServiceAccount(dict):
    def __init__(__self__, *,
                 scopes: Sequence[str],
                 email: Optional[str] = None):
        pulumi.set(__self__, "scopes", scopes)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        return pulumi.get(self, "email")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceFromTemplateShieldedInstanceConfig(dict):
    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[bool] = None,
                 enable_secure_boot: Optional[bool] = None,
                 enable_vtpm: Optional[bool] = None):
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        if enable_vtpm is not None:
            pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[bool]:
        return pulumi.get(self, "enable_integrity_monitoring")

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[bool]:
        return pulumi.get(self, "enable_secure_boot")

    @property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> Optional[bool]:
        return pulumi.get(self, "enable_vtpm")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGroupManagerAutoHealingPolicies(dict):
    def __init__(__self__, *,
                 health_check: str,
                 initial_delay_sec: int):
        """
        :param str health_check: The health check resource that signals autohealing.
        :param int initial_delay_sec: The number of seconds that the managed instance group waits before
               it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        pulumi.set(__self__, "health_check", health_check)
        pulumi.set(__self__, "initial_delay_sec", initial_delay_sec)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> str:
        """
        The health check resource that signals autohealing.
        """
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter(name="initialDelaySec")
    def initial_delay_sec(self) -> int:
        """
        The number of seconds that the managed instance group waits before
        it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        return pulumi.get(self, "initial_delay_sec")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGroupManagerNamedPort(dict):
    def __init__(__self__, *,
                 name: str,
                 port: int):
        """
        :param str name: - Version name.
        :param int port: The port number.
               - - -
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - Version name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port number.
        - - -
        """
        return pulumi.get(self, "port")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGroupManagerStatefulDisk(dict):
    def __init__(__self__, *,
                 device_name: str,
                 delete_rule: Optional[str] = None):
        """
        :param str device_name: , The device name of the disk to be attached.
        :param str delete_rule: , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the disk when the VM is deleted, but do not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
        """
        pulumi.set(__self__, "device_name", device_name)
        if delete_rule is not None:
            pulumi.set(__self__, "delete_rule", delete_rule)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        , The device name of the disk to be attached.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[str]:
        """
        , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the disk when the VM is deleted, but do not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
        """
        return pulumi.get(self, "delete_rule")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGroupManagerUpdatePolicy(dict):
    def __init__(__self__, *,
                 minimal_action: str,
                 type: str,
                 max_surge_fixed: Optional[int] = None,
                 max_surge_percent: Optional[int] = None,
                 max_unavailable_fixed: Optional[int] = None,
                 max_unavailable_percent: Optional[int] = None,
                 min_ready_sec: Optional[int] = None,
                 replacement_method: Optional[str] = None):
        """
        :param str minimal_action: - Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        :param str type: - The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        :param int max_surge_fixed: , The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `max_surge_percent`. If neither is set, defaults to 1
        :param int max_surge_percent: , The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `max_surge_fixed`.
        :param int max_unavailable_fixed: , The maximum number of instances that can be unavailable during the update process. Conflicts with `max_unavailable_percent`. If neither is set, defaults to 1
        :param int max_unavailable_percent: , The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `max_unavailable_fixed`.
        :param int min_ready_sec: , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
        :param str replacement_method: , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
               - - -
        """
        pulumi.set(__self__, "minimal_action", minimal_action)
        pulumi.set(__self__, "type", type)
        if max_surge_fixed is not None:
            pulumi.set(__self__, "max_surge_fixed", max_surge_fixed)
        if max_surge_percent is not None:
            pulumi.set(__self__, "max_surge_percent", max_surge_percent)
        if max_unavailable_fixed is not None:
            pulumi.set(__self__, "max_unavailable_fixed", max_unavailable_fixed)
        if max_unavailable_percent is not None:
            pulumi.set(__self__, "max_unavailable_percent", max_unavailable_percent)
        if min_ready_sec is not None:
            pulumi.set(__self__, "min_ready_sec", min_ready_sec)
        if replacement_method is not None:
            pulumi.set(__self__, "replacement_method", replacement_method)

    @property
    @pulumi.getter(name="minimalAction")
    def minimal_action(self) -> str:
        """
        - Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        """
        return pulumi.get(self, "minimal_action")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="maxSurgeFixed")
    def max_surge_fixed(self) -> Optional[int]:
        """
        , The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `max_surge_percent`. If neither is set, defaults to 1
        """
        return pulumi.get(self, "max_surge_fixed")

    @property
    @pulumi.getter(name="maxSurgePercent")
    def max_surge_percent(self) -> Optional[int]:
        """
        , The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `max_surge_fixed`.
        """
        return pulumi.get(self, "max_surge_percent")

    @property
    @pulumi.getter(name="maxUnavailableFixed")
    def max_unavailable_fixed(self) -> Optional[int]:
        """
        , The maximum number of instances that can be unavailable during the update process. Conflicts with `max_unavailable_percent`. If neither is set, defaults to 1
        """
        return pulumi.get(self, "max_unavailable_fixed")

    @property
    @pulumi.getter(name="maxUnavailablePercent")
    def max_unavailable_percent(self) -> Optional[int]:
        """
        , The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `max_unavailable_fixed`.
        """
        return pulumi.get(self, "max_unavailable_percent")

    @property
    @pulumi.getter(name="minReadySec")
    def min_ready_sec(self) -> Optional[int]:
        """
        , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
        """
        return pulumi.get(self, "min_ready_sec")

    @property
    @pulumi.getter(name="replacementMethod")
    def replacement_method(self) -> Optional[str]:
        """
        , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
        - - -
        """
        return pulumi.get(self, "replacement_method")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGroupManagerVersion(dict):
    def __init__(__self__, *,
                 instance_template: str,
                 name: Optional[str] = None,
                 target_size: Optional['outputs.InstanceGroupManagerVersionTargetSize'] = None):
        """
        :param str instance_template: - The full URL to an instance template from which all new instances of this version will be created.
        :param str name: - Version name.
        :param 'InstanceGroupManagerVersionTargetSizeArgs' target_size: - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
        """
        pulumi.set(__self__, "instance_template", instance_template)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_size is not None:
            pulumi.set(__self__, "target_size", target_size)

    @property
    @pulumi.getter(name="instanceTemplate")
    def instance_template(self) -> str:
        """
        - The full URL to an instance template from which all new instances of this version will be created.
        """
        return pulumi.get(self, "instance_template")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - Version name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetSize")
    def target_size(self) -> Optional['outputs.InstanceGroupManagerVersionTargetSize']:
        """
        - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
        """
        return pulumi.get(self, "target_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGroupManagerVersionTargetSize(dict):
    def __init__(__self__, *,
                 fixed: Optional[int] = None,
                 percent: Optional[int] = None):
        """
        :param int fixed: , The number of instances which are managed for this version. Conflicts with `percent`.
        :param int percent: , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
               Note that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,
               one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
        """
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def fixed(self) -> Optional[int]:
        """
        , The number of instances which are managed for this version. Conflicts with `percent`.
        """
        return pulumi.get(self, "fixed")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
        Note that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,
        one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
        """
        return pulumi.get(self, "percent")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGroupNamedPort(dict):
    def __init__(__self__, *,
                 name: str,
                 port: int):
        """
        :param str name: The name which the port will be mapped to.
        :param int port: The port number to map the name to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which the port will be mapped to.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port number to map the name to.
        """
        return pulumi.get(self, "port")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceGuestAccelerator(dict):
    def __init__(__self__, *,
                 count: int,
                 type: str):
        """
        :param int count: The number of the guest accelerator cards exposed to this instance.
        :param str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceIAMBindingCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        """
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str title: A title for the expression, i.e. a short string describing its purpose.
        :param str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceIAMMemberCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        """
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str title: A title for the expression, i.e. a short string describing its purpose.
        :param str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceNetworkInterface(dict):
    def __init__(__self__, *,
                 access_configs: Optional[Sequence['outputs.InstanceNetworkInterfaceAccessConfig']] = None,
                 alias_ip_ranges: Optional[Sequence['outputs.InstanceNetworkInterfaceAliasIpRange']] = None,
                 name: Optional[str] = None,
                 network: Optional[str] = None,
                 network_ip: Optional[str] = None,
                 nic_type: Optional[str] = None,
                 subnetwork: Optional[str] = None,
                 subnetwork_project: Optional[str] = None):
        """
        :param Sequence['InstanceNetworkInterfaceAccessConfigArgs'] access_configs: Access configurations, i.e. IPs via which this
               instance can be accessed via the Internet. Omit to ensure that the instance
               is not accessible from the Internet. If omitted, ssh will not
               work unless this provider can send traffic to the instance's network (e.g. via
               tunnel or because it is running on another cloud instance on that network).
               This block can be repeated multiple times. Structure documented below.
        :param Sequence['InstanceNetworkInterfaceAliasIpRangeArgs'] alias_ip_ranges: An
               array of alias IP ranges for this network interface. Can only be specified for network
               interfaces on subnet-mode networks. Structure documented below.
        :param str name: A unique name for the resource, required by GCE.
               Changing this forces a new resource to be created.
        :param str network: The name or self_link of the network to attach this interface to.
               Either `network` or `subnetwork` must be provided.
        :param str network_ip: The private IP address to assign to the instance. If
               empty, the address will be automatically assigned.
        :param str nic_type: The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET.
        :param str subnetwork: The name or self_link of the subnetwork to attach this
               interface to. The subnetwork must exist in the same region this instance will be
               created in. If network isn't provided it will be inferred from the subnetwork.
               Either `network` or `subnetwork` must be provided.
        :param str subnetwork_project: The project in which the subnetwork belongs.
               If the `subnetwork` is a self_link, this field is ignored in favor of the project
               defined in the subnetwork self_link. If the `subnetwork` is a name and this
               field is not provided, the provider project is used.
        """
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if alias_ip_ranges is not None:
            pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_ip is not None:
            pulumi.set(__self__, "network_ip", network_ip)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if subnetwork is not None:
            pulumi.set(__self__, "subnetwork", subnetwork)
        if subnetwork_project is not None:
            pulumi.set(__self__, "subnetwork_project", subnetwork_project)

    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.InstanceNetworkInterfaceAccessConfig']]:
        """
        Access configurations, i.e. IPs via which this
        instance can be accessed via the Internet. Omit to ensure that the instance
        is not accessible from the Internet. If omitted, ssh will not
        work unless this provider can send traffic to the instance's network (e.g. via
        tunnel or because it is running on another cloud instance on that network).
        This block can be repeated multiple times. Structure documented below.
        """
        return pulumi.get(self, "access_configs")

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[Sequence['outputs.InstanceNetworkInterfaceAliasIpRange']]:
        """
        An
        array of alias IP ranges for this network interface. Can only be specified for network
        interfaces on subnet-mode networks. Structure documented below.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A unique name for the resource, required by GCE.
        Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        """
        The name or self_link of the network to attach this interface to.
        Either `network` or `subnetwork` must be provided.
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> Optional[str]:
        """
        The private IP address to assign to the instance. If
        empty, the address will be automatically assigned.
        """
        return pulumi.get(self, "network_ip")

    @property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[str]:
        """
        The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET.
        """
        return pulumi.get(self, "nic_type")

    @property
    @pulumi.getter
    def subnetwork(self) -> Optional[str]:
        """
        The name or self_link of the subnetwork to attach this
        interface to. The subnetwork must exist in the same region this instance will be
        created in. If network isn't provided it will be inferred from the subnetwork.
        Either `network` or `subnetwork` must be provided.
        """
        return pulumi.get(self, "subnetwork")

    @property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> Optional[str]:
        """
        The project in which the subnetwork belongs.
        If the `subnetwork` is a self_link, this field is ignored in favor of the project
        defined in the subnetwork self_link. If the `subnetwork` is a name and this
        field is not provided, the provider project is used.
        """
        return pulumi.get(self, "subnetwork_project")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceNetworkInterfaceAccessConfig(dict):
    def __init__(__self__, *,
                 nat_ip: Optional[str] = None,
                 network_tier: Optional[str] = None,
                 public_ptr_domain_name: Optional[str] = None):
        """
        :param str nat_ip: The IP address that will be 1:1 mapped to the instance's
               network ip. If not given, one will be generated.
        :param str network_tier: The [networking tier][network-tier] used for configuring this instance.
               This field can take the following values: PREMIUM or STANDARD. If this field is
               not specified, it is assumed to be PREMIUM.
        :param str public_ptr_domain_name: The DNS domain name for the public PTR record.
               To set this field on an instance, you must be verified as the owner of the domain.
               See [the docs](https://cloud.google.com/compute/docs/instances/create-ptr-record) for how
               to become verified as a domain owner.
        """
        if nat_ip is not None:
            pulumi.set(__self__, "nat_ip", nat_ip)
        if network_tier is not None:
            pulumi.set(__self__, "network_tier", network_tier)
        if public_ptr_domain_name is not None:
            pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)

    @property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> Optional[str]:
        """
        The IP address that will be 1:1 mapped to the instance's
        network ip. If not given, one will be generated.
        """
        return pulumi.get(self, "nat_ip")

    @property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> Optional[str]:
        """
        The [networking tier][network-tier] used for configuring this instance.
        This field can take the following values: PREMIUM or STANDARD. If this field is
        not specified, it is assumed to be PREMIUM.
        """
        return pulumi.get(self, "network_tier")

    @property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[str]:
        """
        The DNS domain name for the public PTR record.
        To set this field on an instance, you must be verified as the owner of the domain.
        See [the docs](https://cloud.google.com/compute/docs/instances/create-ptr-record) for how
        to become verified as a domain owner.
        """
        return pulumi.get(self, "public_ptr_domain_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceNetworkInterfaceAliasIpRange(dict):
    def __init__(__self__, *,
                 ip_cidr_range: str,
                 subnetwork_range_name: Optional[str] = None):
        """
        :param str ip_cidr_range: The IP CIDR range represented by this alias IP range. This IP CIDR range
               must belong to the specified subnetwork and cannot contain IP addresses reserved by
               system or used by other network interfaces. This range may be a single IP address
               (e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).
        :param str subnetwork_range_name: The subnetwork secondary range name specifying
               the secondary range from which to allocate the IP CIDR range for this alias IP
               range. If left unspecified, the primary range of the subnetwork will be used.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        if subnetwork_range_name is not None:
            pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> str:
        """
        The IP CIDR range represented by this alias IP range. This IP CIDR range
        must belong to the specified subnetwork and cannot contain IP addresses reserved by
        system or used by other network interfaces. This range may be a single IP address
        (e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).
        """
        return pulumi.get(self, "ip_cidr_range")

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> Optional[str]:
        """
        The subnetwork secondary range name specifying
        the secondary range from which to allocate the IP CIDR range for this alias IP
        range. If left unspecified, the primary range of the subnetwork will be used.
        """
        return pulumi.get(self, "subnetwork_range_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceScheduling(dict):
    def __init__(__self__, *,
                 automatic_restart: Optional[bool] = None,
                 min_node_cpus: Optional[int] = None,
                 node_affinities: Optional[Sequence['outputs.InstanceSchedulingNodeAffinity']] = None,
                 on_host_maintenance: Optional[str] = None,
                 preemptible: Optional[bool] = None):
        """
        :param bool automatic_restart: Specifies if the instance should be
               restarted if it was terminated by Compute Engine (not a user).
               Defaults to true.
        :param Sequence['InstanceSchedulingNodeAffinityArgs'] node_affinities: Specifies node affinities or anti-affinities
               to determine which sole-tenant nodes your instances and managed instance
               groups will use as host systems. Read more on sole-tenant node creation
               [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
               Structure documented below.
        :param str on_host_maintenance: Describes maintenance behavior for the
               instance. Can be MIGRATE or TERMINATE, for more info, read
               [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options).
        :param bool preemptible: Specifies if the instance is preemptible.
               If this field is set to true, then `automatic_restart` must be
               set to false.  Defaults to false.
        """
        if automatic_restart is not None:
            pulumi.set(__self__, "automatic_restart", automatic_restart)
        if min_node_cpus is not None:
            pulumi.set(__self__, "min_node_cpus", min_node_cpus)
        if node_affinities is not None:
            pulumi.set(__self__, "node_affinities", node_affinities)
        if on_host_maintenance is not None:
            pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> Optional[bool]:
        """
        Specifies if the instance should be
        restarted if it was terminated by Compute Engine (not a user).
        Defaults to true.
        """
        return pulumi.get(self, "automatic_restart")

    @property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> Optional[int]:
        return pulumi.get(self, "min_node_cpus")

    @property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Optional[Sequence['outputs.InstanceSchedulingNodeAffinity']]:
        """
        Specifies node affinities or anti-affinities
        to determine which sole-tenant nodes your instances and managed instance
        groups will use as host systems. Read more on sole-tenant node creation
        [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
        Structure documented below.
        """
        return pulumi.get(self, "node_affinities")

    @property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> Optional[str]:
        """
        Describes maintenance behavior for the
        instance. Can be MIGRATE or TERMINATE, for more info, read
        [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options).
        """
        return pulumi.get(self, "on_host_maintenance")

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[bool]:
        """
        Specifies if the instance is preemptible.
        If this field is set to true, then `automatic_restart` must be
        set to false.  Defaults to false.
        """
        return pulumi.get(self, "preemptible")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceSchedulingNodeAffinity(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str key: The key for the node affinity label.
        :param str operator: The operator. Can be `IN` for node-affinities
               or `NOT_IN` for anti-affinities.
        :param Sequence[str] values: The values for the node affinity label.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key for the node affinity label.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator. Can be `IN` for node-affinities
        or `NOT_IN` for anti-affinities.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values for the node affinity label.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceScratchDisk(dict):
    def __init__(__self__, *,
                 interface: str):
        """
        :param str interface: The disk interface to use for attaching this disk; either SCSI or NVME.
        """
        pulumi.set(__self__, "interface", interface)

    @property
    @pulumi.getter
    def interface(self) -> str:
        """
        The disk interface to use for attaching this disk; either SCSI or NVME.
        """
        return pulumi.get(self, "interface")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceServiceAccount(dict):
    def __init__(__self__, *,
                 scopes: Sequence[str],
                 email: Optional[str] = None):
        """
        :param Sequence[str] scopes: A list of service scopes. Both OAuth2 URLs and gcloud
               short names are supported. To allow full access to all Cloud APIs, use the
               `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
               **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        :param str email: The service account e-mail address. If not given, the
               default Google Compute Engine service account is used.
               **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        pulumi.set(__self__, "scopes", scopes)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        A list of service scopes. Both OAuth2 URLs and gcloud
        short names are supported. To allow full access to all Cloud APIs, use the
        `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
        **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The service account e-mail address. If not given, the
        default Google Compute Engine service account is used.
        **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        return pulumi.get(self, "email")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceShieldedInstanceConfig(dict):
    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[bool] = None,
                 enable_secure_boot: Optional[bool] = None,
                 enable_vtpm: Optional[bool] = None):
        """
        :param bool enable_integrity_monitoring: -- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
               **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        :param bool enable_secure_boot: -- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
               **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        :param bool enable_vtpm: -- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
               **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        if enable_vtpm is not None:
            pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[bool]:
        """
        -- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[bool]:
        """
        -- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        return pulumi.get(self, "enable_secure_boot")

    @property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> Optional[bool]:
        """
        -- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        return pulumi.get(self, "enable_vtpm")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateConfidentialInstanceConfig(dict):
    def __init__(__self__, *,
                 enable_confidential_compute: bool):
        """
        :param bool enable_confidential_compute: Defines whether the instance should have confidential compute enabled. `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.
        """
        pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> bool:
        """
        Defines whether the instance should have confidential compute enabled. `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.
        """
        return pulumi.get(self, "enable_confidential_compute")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateDisk(dict):
    def __init__(__self__, *,
                 auto_delete: Optional[bool] = None,
                 boot: Optional[bool] = None,
                 device_name: Optional[str] = None,
                 disk_encryption_key: Optional['outputs.InstanceTemplateDiskDiskEncryptionKey'] = None,
                 disk_name: Optional[str] = None,
                 disk_size_gb: Optional[int] = None,
                 disk_type: Optional[str] = None,
                 interface: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 mode: Optional[str] = None,
                 resource_policies: Optional[str] = None,
                 source: Optional[str] = None,
                 source_image: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param bool auto_delete: Whether or not the disk should be auto-deleted.
               This defaults to true.
        :param bool boot: Indicates that this is a boot disk.
        :param str device_name: A unique device name that is reflected into the
               /dev/  tree of a Linux operating system running within the instance. If not
               specified, the server chooses a default device name to apply to this disk.
        :param 'InstanceTemplateDiskDiskEncryptionKeyArgs' disk_encryption_key: Encrypts or decrypts a disk using a customer-supplied encryption key.
        :param str disk_name: Name of the disk. When not provided, this defaults
               to the name of the instance.
        :param int disk_size_gb: The size of the image in gigabytes. If not
               specified, it will inherit the size of its base image. For SCRATCH disks,
               the size must be exactly 375GB.
        :param str disk_type: The GCE disk type. Can be either `"pd-ssd"`,
               `"local-ssd"`, `"pd-balanced"` or `"pd-standard"`.
        :param str interface: Specifies the disk interface to use for attaching this disk,
               which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
               and the request will fail if you attempt to attach a persistent disk in any other format
               than SCSI. Local SSDs can use either NVME or SCSI.
        :param Mapping[str, str] labels: A set of key/value label pairs to assign to instances
               created from this template,
        :param str mode: The mode in which to attach this disk, either READ_WRITE
               or READ_ONLY. If you are attaching or creating a boot disk, this must
               read-write mode.
        :param str resource_policies: -- A list (short name or id) of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
        :param str source: The name (**not self_link**)
               of the disk (such as those managed by `compute.Disk`) to attach.
               > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param str source_image: The image from which to
               initialize this disk. This can be one of: the image's `self_link`,
               `projects/{project}/global/images/{image}`,
               `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
               `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
               `{project}/{image}`, `{family}`, or `{image}`.
               > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if boot is not None:
            pulumi.set(__self__, "boot", boot)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key is not None:
            pulumi.set(__self__, "disk_encryption_key", disk_encryption_key)
        if disk_name is not None:
            pulumi.set(__self__, "disk_name", disk_name)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if resource_policies is not None:
            pulumi.set(__self__, "resource_policies", resource_policies)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if source_image is not None:
            pulumi.set(__self__, "source_image", source_image)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[bool]:
        """
        Whether or not the disk should be auto-deleted.
        This defaults to true.
        """
        return pulumi.get(self, "auto_delete")

    @property
    @pulumi.getter
    def boot(self) -> Optional[bool]:
        """
        Indicates that this is a boot disk.
        """
        return pulumi.get(self, "boot")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        A unique device name that is reflected into the
        /dev/  tree of a Linux operating system running within the instance. If not
        specified, the server chooses a default device name to apply to this disk.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskEncryptionKey")
    def disk_encryption_key(self) -> Optional['outputs.InstanceTemplateDiskDiskEncryptionKey']:
        """
        Encrypts or decrypts a disk using a customer-supplied encryption key.
        """
        return pulumi.get(self, "disk_encryption_key")

    @property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> Optional[str]:
        """
        Name of the disk. When not provided, this defaults
        to the name of the instance.
        """
        return pulumi.get(self, "disk_name")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[int]:
        """
        The size of the image in gigabytes. If not
        specified, it will inherit the size of its base image. For SCRATCH disks,
        the size must be exactly 375GB.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[str]:
        """
        The GCE disk type. Can be either `"pd-ssd"`,
        `"local-ssd"`, `"pd-balanced"` or `"pd-standard"`.
        """
        return pulumi.get(self, "disk_type")

    @property
    @pulumi.getter
    def interface(self) -> Optional[str]:
        """
        Specifies the disk interface to use for attaching this disk,
        which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
        and the request will fail if you attempt to attach a persistent disk in any other format
        than SCSI. Local SSDs can use either NVME or SCSI.
        """
        return pulumi.get(self, "interface")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        A set of key/value label pairs to assign to instances
        created from this template,
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The mode in which to attach this disk, either READ_WRITE
        or READ_ONLY. If you are attaching or creating a boot disk, this must
        read-write mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="resourcePolicies")
    def resource_policies(self) -> Optional[str]:
        """
        -- A list (short name or id) of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
        """
        return pulumi.get(self, "resource_policies")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        The name (**not self_link**)
        of the disk (such as those managed by `compute.Disk`) to attach.
        > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> Optional[str]:
        """
        The image from which to
        initialize this disk. This can be one of: the image's `self_link`,
        `projects/{project}/global/images/{image}`,
        `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
        `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
        `{project}/{image}`, `{family}`, or `{image}`.
        > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        return pulumi.get(self, "source_image")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateDiskDiskEncryptionKey(dict):
    def __init__(__self__, *,
                 kms_key_self_link: str):
        """
        :param str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS
        """
        return pulumi.get(self, "kms_key_self_link")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateGuestAccelerator(dict):
    def __init__(__self__, *,
                 count: int,
                 type: str):
        """
        :param int count: The number of the guest accelerator cards exposed to this instance.
        :param str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateNetworkInterface(dict):
    def __init__(__self__, *,
                 access_configs: Optional[Sequence['outputs.InstanceTemplateNetworkInterfaceAccessConfig']] = None,
                 alias_ip_ranges: Optional[Sequence['outputs.InstanceTemplateNetworkInterfaceAliasIpRange']] = None,
                 name: Optional[str] = None,
                 network: Optional[str] = None,
                 network_ip: Optional[str] = None,
                 subnetwork: Optional[str] = None,
                 subnetwork_project: Optional[str] = None):
        """
        :param Sequence['InstanceTemplateNetworkInterfaceAccessConfigArgs'] access_configs: Access configurations, i.e. IPs via which this
               instance can be accessed via the Internet. Omit to ensure that the instance
               is not accessible from the Internet (this means that ssh provisioners will
               not work unless you can send traffic to the instance's
               network (e.g. via tunnel or because it is running on another cloud instance
               on that network). This block can be repeated multiple times. Structure documented below.
        :param Sequence['InstanceTemplateNetworkInterfaceAliasIpRangeArgs'] alias_ip_ranges: An
               array of alias IP ranges for this network interface. Can only be specified for network
               interfaces on subnet-mode networks. Structure documented below.
        :param str name: The name of the instance template. If you leave
               this blank, the provider will auto-generate a unique name.
        :param str network: The name or self_link of the network to attach this interface to.
               Use `network` attribute for Legacy or Auto subnetted networks and
               `subnetwork` for custom subnetted networks.
        :param str network_ip: The private IP address to assign to the instance. If
               empty, the address will be automatically assigned.
        :param str subnetwork: the name of the subnetwork to attach this interface
               to. The subnetwork must exist in the same `region` this instance will be
               created in. Either `network` or `subnetwork` must be provided.
        :param str subnetwork_project: The ID of the project in which the subnetwork belongs.
               If it is not provided, the provider project is used.
        """
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if alias_ip_ranges is not None:
            pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_ip is not None:
            pulumi.set(__self__, "network_ip", network_ip)
        if subnetwork is not None:
            pulumi.set(__self__, "subnetwork", subnetwork)
        if subnetwork_project is not None:
            pulumi.set(__self__, "subnetwork_project", subnetwork_project)

    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.InstanceTemplateNetworkInterfaceAccessConfig']]:
        """
        Access configurations, i.e. IPs via which this
        instance can be accessed via the Internet. Omit to ensure that the instance
        is not accessible from the Internet (this means that ssh provisioners will
        not work unless you can send traffic to the instance's
        network (e.g. via tunnel or because it is running on another cloud instance
        on that network). This block can be repeated multiple times. Structure documented below.
        """
        return pulumi.get(self, "access_configs")

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[Sequence['outputs.InstanceTemplateNetworkInterfaceAliasIpRange']]:
        """
        An
        array of alias IP ranges for this network interface. Can only be specified for network
        interfaces on subnet-mode networks. Structure documented below.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the instance template. If you leave
        this blank, the provider will auto-generate a unique name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        """
        The name or self_link of the network to attach this interface to.
        Use `network` attribute for Legacy or Auto subnetted networks and
        `subnetwork` for custom subnetted networks.
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> Optional[str]:
        """
        The private IP address to assign to the instance. If
        empty, the address will be automatically assigned.
        """
        return pulumi.get(self, "network_ip")

    @property
    @pulumi.getter
    def subnetwork(self) -> Optional[str]:
        """
        the name of the subnetwork to attach this interface
        to. The subnetwork must exist in the same `region` this instance will be
        created in. Either `network` or `subnetwork` must be provided.
        """
        return pulumi.get(self, "subnetwork")

    @property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> Optional[str]:
        """
        The ID of the project in which the subnetwork belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "subnetwork_project")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateNetworkInterfaceAccessConfig(dict):
    def __init__(__self__, *,
                 nat_ip: Optional[str] = None,
                 network_tier: Optional[str] = None,
                 public_ptr_domain_name: Optional[str] = None):
        """
        :param str nat_ip: The IP address that will be 1:1 mapped to the instance's
               network ip. If not given, one will be generated.
        :param str network_tier: The [networking tier][network-tier] used for configuring
               this instance template. This field can take the following values: PREMIUM or
               STANDARD. If this field is not specified, it is assumed to be PREMIUM.
        """
        if nat_ip is not None:
            pulumi.set(__self__, "nat_ip", nat_ip)
        if network_tier is not None:
            pulumi.set(__self__, "network_tier", network_tier)
        if public_ptr_domain_name is not None:
            pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)

    @property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> Optional[str]:
        """
        The IP address that will be 1:1 mapped to the instance's
        network ip. If not given, one will be generated.
        """
        return pulumi.get(self, "nat_ip")

    @property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> Optional[str]:
        """
        The [networking tier][network-tier] used for configuring
        this instance template. This field can take the following values: PREMIUM or
        STANDARD. If this field is not specified, it is assumed to be PREMIUM.
        """
        return pulumi.get(self, "network_tier")

    @property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[str]:
        return pulumi.get(self, "public_ptr_domain_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateNetworkInterfaceAliasIpRange(dict):
    def __init__(__self__, *,
                 ip_cidr_range: str,
                 subnetwork_range_name: Optional[str] = None):
        """
        :param str ip_cidr_range: The IP CIDR range represented by this alias IP range. This IP CIDR range
               must belong to the specified subnetwork and cannot contain IP addresses reserved by
               system or used by other network interfaces. At the time of writing only a
               netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
               error.
        :param str subnetwork_range_name: The subnetwork secondary range name specifying
               the secondary range from which to allocate the IP CIDR range for this alias IP
               range. If left unspecified, the primary range of the subnetwork will be used.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        if subnetwork_range_name is not None:
            pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> str:
        """
        The IP CIDR range represented by this alias IP range. This IP CIDR range
        must belong to the specified subnetwork and cannot contain IP addresses reserved by
        system or used by other network interfaces. At the time of writing only a
        netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
        error.
        """
        return pulumi.get(self, "ip_cidr_range")

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> Optional[str]:
        """
        The subnetwork secondary range name specifying
        the secondary range from which to allocate the IP CIDR range for this alias IP
        range. If left unspecified, the primary range of the subnetwork will be used.
        """
        return pulumi.get(self, "subnetwork_range_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateScheduling(dict):
    def __init__(__self__, *,
                 automatic_restart: Optional[bool] = None,
                 min_node_cpus: Optional[int] = None,
                 node_affinities: Optional[Sequence['outputs.InstanceTemplateSchedulingNodeAffinity']] = None,
                 on_host_maintenance: Optional[str] = None,
                 preemptible: Optional[bool] = None):
        """
        :param bool automatic_restart: Specifies whether the instance should be
               automatically restarted if it is terminated by Compute Engine (not
               terminated by a user). This defaults to true.
        :param Sequence['InstanceTemplateSchedulingNodeAffinityArgs'] node_affinities: Specifies node affinities or anti-affinities
               to determine which sole-tenant nodes your instances and managed instance
               groups will use as host systems. Read more on sole-tenant node creation
               [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
               Structure documented below.
        :param str on_host_maintenance: Defines the maintenance behavior for this
               instance.
        :param bool preemptible: Allows instance to be preempted. This defaults to
               false. Read more on this
               [here](https://cloud.google.com/compute/docs/instances/preemptible).
        """
        if automatic_restart is not None:
            pulumi.set(__self__, "automatic_restart", automatic_restart)
        if min_node_cpus is not None:
            pulumi.set(__self__, "min_node_cpus", min_node_cpus)
        if node_affinities is not None:
            pulumi.set(__self__, "node_affinities", node_affinities)
        if on_host_maintenance is not None:
            pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> Optional[bool]:
        """
        Specifies whether the instance should be
        automatically restarted if it is terminated by Compute Engine (not
        terminated by a user). This defaults to true.
        """
        return pulumi.get(self, "automatic_restart")

    @property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> Optional[int]:
        return pulumi.get(self, "min_node_cpus")

    @property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Optional[Sequence['outputs.InstanceTemplateSchedulingNodeAffinity']]:
        """
        Specifies node affinities or anti-affinities
        to determine which sole-tenant nodes your instances and managed instance
        groups will use as host systems. Read more on sole-tenant node creation
        [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
        Structure documented below.
        """
        return pulumi.get(self, "node_affinities")

    @property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> Optional[str]:
        """
        Defines the maintenance behavior for this
        instance.
        """
        return pulumi.get(self, "on_host_maintenance")

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[bool]:
        """
        Allows instance to be preempted. This defaults to
        false. Read more on this
        [here](https://cloud.google.com/compute/docs/instances/preemptible).
        """
        return pulumi.get(self, "preemptible")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateSchedulingNodeAffinity(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str key: The key for the node affinity label.
        :param str operator: The operator. Can be `IN` for node-affinities
               or `NOT_IN` for anti-affinities.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key for the node affinity label.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator. Can be `IN` for node-affinities
        or `NOT_IN` for anti-affinities.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateServiceAccount(dict):
    def __init__(__self__, *,
                 scopes: Sequence[str],
                 email: Optional[str] = None):
        """
        :param Sequence[str] scopes: A list of service scopes. Both OAuth2 URLs and gcloud
               short names are supported. To allow full access to all Cloud APIs, use the
               `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
        :param str email: The service account e-mail address. If not given, the
               default Google Compute Engine service account is used.
        """
        pulumi.set(__self__, "scopes", scopes)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        A list of service scopes. Both OAuth2 URLs and gcloud
        short names are supported. To allow full access to all Cloud APIs, use the
        `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The service account e-mail address. If not given, the
        default Google Compute Engine service account is used.
        """
        return pulumi.get(self, "email")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InstanceTemplateShieldedInstanceConfig(dict):
    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[bool] = None,
                 enable_secure_boot: Optional[bool] = None,
                 enable_vtpm: Optional[bool] = None):
        """
        :param bool enable_integrity_monitoring: -- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        :param bool enable_secure_boot: -- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        :param bool enable_vtpm: -- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        """
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        if enable_vtpm is not None:
            pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[bool]:
        """
        -- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[bool]:
        """
        -- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        """
        return pulumi.get(self, "enable_secure_boot")

    @property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> Optional[bool]:
        """
        -- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        """
        return pulumi.get(self, "enable_vtpm")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InterconnectAttachmentPrivateInterconnectInfo(dict):
    def __init__(__self__, *,
                 tag8021q: Optional[int] = None):
        if tag8021q is not None:
            pulumi.set(__self__, "tag8021q", tag8021q)

    @property
    @pulumi.getter
    def tag8021q(self) -> Optional[int]:
        return pulumi.get(self, "tag8021q")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MachineImageIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        """
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str title: A title for the expression, i.e. a short string describing its purpose.
        :param str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MachineImageIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        """
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str title: A title for the expression, i.e. a short string describing its purpose.
        :param str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MachineImageMachineImageEncryptionKey(dict):
    def __init__(__self__, *,
                 kms_key_name: Optional[str] = None,
                 kms_key_service_account: Optional[str] = None,
                 raw_key: Optional[str] = None,
                 sha256: Optional[str] = None):
        """
        :param str kms_key_name: -
               The name of the encryption key that is stored in Google Cloud KMS.
        :param str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param str sha256: -
               The RFC 4648 base64 encoded SHA-256 hash of the
               customer-supplied encryption key that protects this resource.
        """
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[str]:
        """
        -
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_name")

    @property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[str]:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        -
        The RFC 4648 base64 encoded SHA-256 hash of the
        customer-supplied encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedSslCertificateManaged(dict):
    def __init__(__self__, *,
                 domains: Sequence[str]):
        """
        :param Sequence[str] domains: Domains for which a managed SSL certificate will be valid.  Currently,
               there can be up to 100 domains in this list.
        """
        pulumi.set(__self__, "domains", domains)

    @property
    @pulumi.getter
    def domains(self) -> Sequence[str]:
        """
        Domains for which a managed SSL certificate will be valid.  Currently,
        there can be up to 100 domains in this list.
        """
        return pulumi.get(self, "domains")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MangedSslCertificateManaged(dict):
    def __init__(__self__, *,
                 domains: Sequence[str]):
        pulumi.set(__self__, "domains", domains)

    @property
    @pulumi.getter
    def domains(self) -> Sequence[str]:
        return pulumi.get(self, "domains")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NodeGroupAutoscalingPolicy(dict):
    def __init__(__self__, *,
                 max_nodes: Optional[int] = None,
                 min_nodes: Optional[int] = None,
                 mode: Optional[str] = None):
        """
        :param int max_nodes: Maximum size of the node group. Set to a value less than or equal
               to 100 and greater than or equal to min-nodes.
        :param int min_nodes: Minimum size of the node group. Must be less
               than or equal to max-nodes. The default value is 0.
        :param str mode: The autoscaling mode. Set to one of the following:
               - OFF: Disables the autoscaler.
               - ON: Enables scaling in and scaling out.
               - ONLY_SCALE_OUT: Enables only scaling out.
               You must use this mode if your node groups are configured to
               restart their hosted VMs on minimal servers.
               Possible values are `OFF`, `ON`, and `ONLY_SCALE_OUT`.
        """
        if max_nodes is not None:
            pulumi.set(__self__, "max_nodes", max_nodes)
        if min_nodes is not None:
            pulumi.set(__self__, "min_nodes", min_nodes)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> Optional[int]:
        """
        Maximum size of the node group. Set to a value less than or equal
        to 100 and greater than or equal to min-nodes.
        """
        return pulumi.get(self, "max_nodes")

    @property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> Optional[int]:
        """
        Minimum size of the node group. Must be less
        than or equal to max-nodes. The default value is 0.
        """
        return pulumi.get(self, "min_nodes")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The autoscaling mode. Set to one of the following:
        - OFF: Disables the autoscaler.
        - ON: Enables scaling in and scaling out.
        - ONLY_SCALE_OUT: Enables only scaling out.
        You must use this mode if your node groups are configured to
        restart their hosted VMs on minimal servers.
        Possible values are `OFF`, `ON`, and `ONLY_SCALE_OUT`.
        """
        return pulumi.get(self, "mode")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NodeTemplateNodeTypeFlexibility(dict):
    def __init__(__self__, *,
                 cpus: Optional[str] = None,
                 local_ssd: Optional[str] = None,
                 memory: Optional[str] = None):
        """
        :param str cpus: Number of virtual CPUs to use.
        :param str local_ssd: -
               Use local SSD
        :param str memory: Physical memory available to the node, defined in MB.
        """
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if local_ssd is not None:
            pulumi.set(__self__, "local_ssd", local_ssd)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpus(self) -> Optional[str]:
        """
        Number of virtual CPUs to use.
        """
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter(name="localSsd")
    def local_ssd(self) -> Optional[str]:
        """
        -
        Use local SSD
        """
        return pulumi.get(self, "local_ssd")

    @property
    @pulumi.getter
    def memory(self) -> Optional[str]:
        """
        Physical memory available to the node, defined in MB.
        """
        return pulumi.get(self, "memory")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NodeTemplateServerBinding(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: Type of server binding policy. If `RESTART_NODE_ON_ANY_SERVER`,
               nodes using this template will restart on any physical server
               following a maintenance event.
               If `RESTART_NODE_ON_MINIMAL_SERVER`, nodes using this template
               will restart on the same physical server following a maintenance
               event, instead of being live migrated to or restarted on a new
               physical server. This option may be useful if you are using
               software licenses tied to the underlying server characteristics
               such as physical sockets or cores, to avoid the need for
               additional licenses when maintenance occurs. However, VMs on such
               nodes will experience outages while maintenance is applied.
               Possible values are `RESTART_NODE_ON_ANY_SERVER` and `RESTART_NODE_ON_MINIMAL_SERVERS`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of server binding policy. If `RESTART_NODE_ON_ANY_SERVER`,
        nodes using this template will restart on any physical server
        following a maintenance event.
        If `RESTART_NODE_ON_MINIMAL_SERVER`, nodes using this template
        will restart on the same physical server following a maintenance
        event, instead of being live migrated to or restarted on a new
        physical server. This option may be useful if you are using
        software licenses tied to the underlying server characteristics
        such as physical sockets or cores, to avoid the need for
        additional licenses when maintenance occurs. However, VMs on such
        nodes will experience outages while maintenance is applied.
        Possible values are `RESTART_NODE_ON_ANY_SERVER` and `RESTART_NODE_ON_MINIMAL_SERVERS`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OrganizationSecurityPolicyRuleMatch(dict):
    def __init__(__self__, *,
                 config: 'outputs.OrganizationSecurityPolicyRuleMatchConfig',
                 description: Optional[str] = None,
                 versioned_expr: Optional[str] = None):
        """
        :param 'OrganizationSecurityPolicyRuleMatchConfigArgs' config: The configuration options for matching the rule.
               Structure is documented below.
        :param str description: A description of the rule.
        :param str versioned_expr: Preconfigured versioned expression. For organization security policy rules,
               the only supported type is "FIREWALL".
               Default value is `FIREWALL`.
               Possible values are `FIREWALL`.
        """
        pulumi.set(__self__, "config", config)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if versioned_expr is not None:
            pulumi.set(__self__, "versioned_expr", versioned_expr)

    @property
    @pulumi.getter
    def config(self) -> 'outputs.OrganizationSecurityPolicyRuleMatchConfig':
        """
        The configuration options for matching the rule.
        Structure is documented below.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="versionedExpr")
    def versioned_expr(self) -> Optional[str]:
        """
        Preconfigured versioned expression. For organization security policy rules,
        the only supported type is "FIREWALL".
        Default value is `FIREWALL`.
        Possible values are `FIREWALL`.
        """
        return pulumi.get(self, "versioned_expr")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OrganizationSecurityPolicyRuleMatchConfig(dict):
    def __init__(__self__, *,
                 layer4_configs: Sequence['outputs.OrganizationSecurityPolicyRuleMatchConfigLayer4Config'],
                 dest_ip_ranges: Optional[Sequence[str]] = None,
                 src_ip_ranges: Optional[Sequence[str]] = None):
        """
        :param Sequence['OrganizationSecurityPolicyRuleMatchConfigLayer4ConfigArgs'] layer4_configs: Pairs of IP protocols and ports that the rule should match.
               Structure is documented below.
        :param Sequence[str] dest_ip_ranges: Destination IP address range in CIDR format. Required for
               EGRESS rules.
        :param Sequence[str] src_ip_ranges: Source IP address range in CIDR format. Required for
               INGRESS rules.
        """
        pulumi.set(__self__, "layer4_configs", layer4_configs)
        if dest_ip_ranges is not None:
            pulumi.set(__self__, "dest_ip_ranges", dest_ip_ranges)
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)

    @property
    @pulumi.getter(name="layer4Configs")
    def layer4_configs(self) -> Sequence['outputs.OrganizationSecurityPolicyRuleMatchConfigLayer4Config']:
        """
        Pairs of IP protocols and ports that the rule should match.
        Structure is documented below.
        """
        return pulumi.get(self, "layer4_configs")

    @property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Optional[Sequence[str]]:
        """
        Destination IP address range in CIDR format. Required for
        EGRESS rules.
        """
        return pulumi.get(self, "dest_ip_ranges")

    @property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[str]]:
        """
        Source IP address range in CIDR format. Required for
        INGRESS rules.
        """
        return pulumi.get(self, "src_ip_ranges")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OrganizationSecurityPolicyRuleMatchConfigLayer4Config(dict):
    def __init__(__self__, *,
                 ip_protocol: str,
                 ports: Optional[Sequence[str]] = None):
        """
        :param str ip_protocol: The IP protocol to which this rule applies. The protocol
               type is required when creating a firewall rule.
               This value can either be one of the following well
               known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
               or the IP protocol number.
        :param Sequence[str] ports: An optional list of ports to which this rule applies. This field
               is only applicable for UDP or TCP protocol. Each entry must be
               either an integer or a range. If not specified, this rule
               applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and
               ["12345-12349"].
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> str:
        """
        The IP protocol to which this rule applies. The protocol
        type is required when creating a firewall rule.
        This value can either be one of the following well
        known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
        or the IP protocol number.
        """
        return pulumi.get(self, "ip_protocol")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and
        ["12345-12349"].
        """
        return pulumi.get(self, "ports")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PacketMirroringCollectorIlb(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: The URL of the instances where this rule should be active.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the instances where this rule should be active.
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PacketMirroringFilter(dict):
    def __init__(__self__, *,
                 cidr_ranges: Optional[Sequence[str]] = None,
                 direction: Optional[str] = None,
                 ip_protocols: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] cidr_ranges: IP CIDR ranges that apply as a filter on the source (ingress) or
               destination (egress) IP in the IP header. Only IPv4 is supported.
        :param str direction: Direction of traffic to mirror.
               Default value is `BOTH`.
               Possible values are `INGRESS`, `EGRESS`, and `BOTH`.
        :param Sequence[str] ip_protocols: Protocols that apply as a filter on mirrored traffic.
               Each value may be one of `tcp`, `udp`, and `icmp`.
        """
        if cidr_ranges is not None:
            pulumi.set(__self__, "cidr_ranges", cidr_ranges)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if ip_protocols is not None:
            pulumi.set(__self__, "ip_protocols", ip_protocols)

    @property
    @pulumi.getter(name="cidrRanges")
    def cidr_ranges(self) -> Optional[Sequence[str]]:
        """
        IP CIDR ranges that apply as a filter on the source (ingress) or
        destination (egress) IP in the IP header. Only IPv4 is supported.
        """
        return pulumi.get(self, "cidr_ranges")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction of traffic to mirror.
        Default value is `BOTH`.
        Possible values are `INGRESS`, `EGRESS`, and `BOTH`.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="ipProtocols")
    def ip_protocols(self) -> Optional[Sequence[str]]:
        """
        Protocols that apply as a filter on mirrored traffic.
        Each value may be one of `tcp`, `udp`, and `icmp`.
        """
        return pulumi.get(self, "ip_protocols")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PacketMirroringMirroredResources(dict):
    def __init__(__self__, *,
                 instances: Optional[Sequence['outputs.PacketMirroringMirroredResourcesInstance']] = None,
                 subnetworks: Optional[Sequence['outputs.PacketMirroringMirroredResourcesSubnetwork']] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['PacketMirroringMirroredResourcesInstanceArgs'] instances: All the listed instances will be mirrored.  Specify at most 50.
               Structure is documented below.
        :param Sequence['PacketMirroringMirroredResourcesSubnetworkArgs'] subnetworks: All instances in one of these subnetworks will be mirrored.
               Structure is documented below.
        :param Sequence[str] tags: All instances with these tags will be mirrored.
        """
        if instances is not None:
            pulumi.set(__self__, "instances", instances)
        if subnetworks is not None:
            pulumi.set(__self__, "subnetworks", subnetworks)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def instances(self) -> Optional[Sequence['outputs.PacketMirroringMirroredResourcesInstance']]:
        """
        All the listed instances will be mirrored.  Specify at most 50.
        Structure is documented below.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def subnetworks(self) -> Optional[Sequence['outputs.PacketMirroringMirroredResourcesSubnetwork']]:
        """
        All instances in one of these subnetworks will be mirrored.
        Structure is documented below.
        """
        return pulumi.get(self, "subnetworks")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        All instances with these tags will be mirrored.
        """
        return pulumi.get(self, "tags")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PacketMirroringMirroredResourcesInstance(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: The URL of the instances where this rule should be active.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the instances where this rule should be active.
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PacketMirroringMirroredResourcesSubnetwork(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: The URL of the instances where this rule should be active.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the instances where this rule should be active.
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PacketMirroringNetwork(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: The URL of the instances where this rule should be active.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the instances where this rule should be active.
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PerInstanceConfigPreservedState(dict):
    def __init__(__self__, *,
                 disks: Optional[Sequence['outputs.PerInstanceConfigPreservedStateDisk']] = None,
                 metadata: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['PerInstanceConfigPreservedStateDiskArgs'] disks: Stateful disks for the instance.
               Structure is documented below.
        :param Mapping[str, str] metadata: Preserved metadata defined for this instance. This is a list of key->value pairs.
        """
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def disks(self) -> Optional[Sequence['outputs.PerInstanceConfigPreservedStateDisk']]:
        """
        Stateful disks for the instance.
        Structure is documented below.
        """
        return pulumi.get(self, "disks")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, str]]:
        """
        Preserved metadata defined for this instance. This is a list of key->value pairs.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PerInstanceConfigPreservedStateDisk(dict):
    def __init__(__self__, *,
                 device_name: str,
                 source: str,
                 delete_rule: Optional[str] = None,
                 mode: Optional[str] = None):
        """
        :param str device_name: A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
        :param str source: The URI of an existing persistent disk to attach under the specified device-name in the format
               `projects/project-id/zones/zone/disks/disk-name`.
        :param str delete_rule: A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
               The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
               `NEVER` - detach the disk when the VM is deleted, but do not delete the disk.
               `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
               deleted from the instance group.
               Default value is `NEVER`.
               Possible values are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
        :param str mode: The mode of the disk.
               Default value is `READ_WRITE`.
               Possible values are `READ_ONLY` and `READ_WRITE`.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "source", source)
        if delete_rule is not None:
            pulumi.set(__self__, "delete_rule", delete_rule)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The URI of an existing persistent disk to attach under the specified device-name in the format
        `projects/project-id/zones/zone/disks/disk-name`.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[str]:
        """
        A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
        The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
        `NEVER` - detach the disk when the VM is deleted, but do not delete the disk.
        `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
        deleted from the instance group.
        Default value is `NEVER`.
        Possible values are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
        """
        return pulumi.get(self, "delete_rule")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The mode of the disk.
        Default value is `READ_WRITE`.
        Possible values are `READ_ONLY` and `READ_WRITE`.
        """
        return pulumi.get(self, "mode")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicy(dict):
    def __init__(__self__, *,
                 max_replicas: int,
                 min_replicas: int,
                 cooldown_period: Optional[int] = None,
                 cpu_utilization: Optional['outputs.RegionAutoscalerAutoscalingPolicyCpuUtilization'] = None,
                 load_balancing_utilization: Optional['outputs.RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization'] = None,
                 metrics: Optional[Sequence['outputs.RegionAutoscalerAutoscalingPolicyMetric']] = None,
                 mode: Optional[str] = None,
                 scale_down_control: Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleDownControl'] = None,
                 scale_in_control: Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleInControl'] = None,
                 scaling_schedules: Optional[Sequence['outputs.RegionAutoscalerAutoscalingPolicyScalingSchedule']] = None):
        """
        :param int max_replicas: The maximum number of instances that the autoscaler can scale up
               to. This is required when creating or updating an autoscaler. The
               maximum number of replicas should not be lower than minimal number
               of replicas.
        :param int min_replicas: The minimum number of replicas that the autoscaler can scale down
               to. This cannot be less than 0. If not provided, autoscaler will
               choose a default value depending on maximum number of instances
               allowed.
        :param int cooldown_period: The number of seconds that the autoscaler should wait before it
               starts collecting information from a new instance. This prevents
               the autoscaler from collecting information when the instance is
               initializing, during which the collected usage would not be
               reliable. The default time autoscaler waits is 60 seconds.
               Virtual machine initialization times might vary because of
               numerous factors. We recommend that you test how long an
               instance may take to initialize. To do this, create an instance
               and time the startup process.
        :param 'RegionAutoscalerAutoscalingPolicyCpuUtilizationArgs' cpu_utilization: Defines the CPU utilization policy that allows the autoscaler to
               scale based on the average CPU utilization of a managed instance
               group.
               Structure is documented below.
        :param 'RegionAutoscalerAutoscalingPolicyLoadBalancingUtilizationArgs' load_balancing_utilization: Configuration parameters of autoscaling based on a load balancer.
               Structure is documented below.
        :param Sequence['RegionAutoscalerAutoscalingPolicyMetricArgs'] metrics: Configuration parameters of autoscaling based on a custom metric.
               Structure is documented below.
        :param str mode: Defines operating mode for this policy.
               Default value is `ON`.
               Possible values are `OFF`, `ONLY_UP`, and `ON`.
        :param 'RegionAutoscalerAutoscalingPolicyScaleDownControlArgs' scale_down_control: Defines scale down controls to reduce the risk of response latency
               and outages due to abrupt scale-in events
               Structure is documented below.
        :param 'RegionAutoscalerAutoscalingPolicyScaleInControlArgs' scale_in_control: Defines scale in controls to reduce the risk of response latency
               and outages due to abrupt scale-in events
               Structure is documented below.
        :param Sequence['RegionAutoscalerAutoscalingPolicyScalingScheduleArgs'] scaling_schedules: Scaling schedules defined for an autoscaler. Multiple schedules can be set on an autoscaler and they can overlap.
               Structure is documented below.
        """
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "min_replicas", min_replicas)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if cpu_utilization is not None:
            pulumi.set(__self__, "cpu_utilization", cpu_utilization)
        if load_balancing_utilization is not None:
            pulumi.set(__self__, "load_balancing_utilization", load_balancing_utilization)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if scale_down_control is not None:
            pulumi.set(__self__, "scale_down_control", scale_down_control)
        if scale_in_control is not None:
            pulumi.set(__self__, "scale_in_control", scale_in_control)
        if scaling_schedules is not None:
            pulumi.set(__self__, "scaling_schedules", scaling_schedules)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> int:
        """
        The maximum number of instances that the autoscaler can scale up
        to. This is required when creating or updating an autoscaler. The
        maximum number of replicas should not be lower than minimal number
        of replicas.
        """
        return pulumi.get(self, "max_replicas")

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> int:
        """
        The minimum number of replicas that the autoscaler can scale down
        to. This cannot be less than 0. If not provided, autoscaler will
        choose a default value depending on maximum number of instances
        allowed.
        """
        return pulumi.get(self, "min_replicas")

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[int]:
        """
        The number of seconds that the autoscaler should wait before it
        starts collecting information from a new instance. This prevents
        the autoscaler from collecting information when the instance is
        initializing, during which the collected usage would not be
        reliable. The default time autoscaler waits is 60 seconds.
        Virtual machine initialization times might vary because of
        numerous factors. We recommend that you test how long an
        instance may take to initialize. To do this, create an instance
        and time the startup process.
        """
        return pulumi.get(self, "cooldown_period")

    @property
    @pulumi.getter(name="cpuUtilization")
    def cpu_utilization(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyCpuUtilization']:
        """
        Defines the CPU utilization policy that allows the autoscaler to
        scale based on the average CPU utilization of a managed instance
        group.
        Structure is documented below.
        """
        return pulumi.get(self, "cpu_utilization")

    @property
    @pulumi.getter(name="loadBalancingUtilization")
    def load_balancing_utilization(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization']:
        """
        Configuration parameters of autoscaling based on a load balancer.
        Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_utilization")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['outputs.RegionAutoscalerAutoscalingPolicyMetric']]:
        """
        Configuration parameters of autoscaling based on a custom metric.
        Structure is documented below.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Defines operating mode for this policy.
        Default value is `ON`.
        Possible values are `OFF`, `ONLY_UP`, and `ON`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="scaleDownControl")
    def scale_down_control(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleDownControl']:
        """
        Defines scale down controls to reduce the risk of response latency
        and outages due to abrupt scale-in events
        Structure is documented below.
        """
        return pulumi.get(self, "scale_down_control")

    @property
    @pulumi.getter(name="scaleInControl")
    def scale_in_control(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleInControl']:
        """
        Defines scale in controls to reduce the risk of response latency
        and outages due to abrupt scale-in events
        Structure is documented below.
        """
        return pulumi.get(self, "scale_in_control")

    @property
    @pulumi.getter(name="scalingSchedules")
    def scaling_schedules(self) -> Optional[Sequence['outputs.RegionAutoscalerAutoscalingPolicyScalingSchedule']]:
        """
        Scaling schedules defined for an autoscaler. Multiple schedules can be set on an autoscaler and they can overlap.
        Structure is documented below.
        """
        return pulumi.get(self, "scaling_schedules")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyCpuUtilization(dict):
    def __init__(__self__, *,
                 target: float,
                 predictive_method: Optional[str] = None):
        """
        :param float target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        :param str predictive_method: Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are:
               - NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics.
               - OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
        """
        pulumi.set(__self__, "target", target)
        if predictive_method is not None:
            pulumi.set(__self__, "predictive_method", predictive_method)

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="predictiveMethod")
    def predictive_method(self) -> Optional[str]:
        """
        Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are:
        - NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics.
        - OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
        """
        return pulumi.get(self, "predictive_method")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization(dict):
    def __init__(__self__, *,
                 target: float):
        """
        :param float target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        """
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        return pulumi.get(self, "target")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyMetric(dict):
    def __init__(__self__, *,
                 name: str,
                 filter: Optional[str] = None,
                 single_instance_assignment: Optional[float] = None,
                 target: Optional[float] = None,
                 type: Optional[str] = None):
        """
        :param str name: The identifier for this object. Format specified above.
        :param str filter: A filter string to be used as the filter string for
               a Stackdriver Monitoring TimeSeries.list API call.
               This filter is used to select a specific TimeSeries for
               the purpose of autoscaling and to determine whether the metric
               is exporting per-instance or per-group data.
               You can only use the AND operator for joining selectors.
               You can only use direct equality comparison operator (=) without
               any functions for each selector.
               You can specify the metric in both the filter string and in the
               metric field. However, if specified in both places, the metric must
               be identical.
               The monitored resource type determines what kind of values are
               expected for the metric. If it is a gce_instance, the autoscaler
               expects the metric to include a separate TimeSeries for each
               instance in a group. In such a case, you cannot filter on resource
               labels.
               If the resource type is any other value, the autoscaler expects
               this metric to contain values that apply to the entire autoscaled
               instance group and resource label filtering can be performed to
               point autoscaler at the correct TimeSeries to scale upon.
               This is called a per-group metric for the purpose of autoscaling.
               If not specified, the type defaults to gce_instance.
               You should provide a filter that is selective enough to pick just
               one TimeSeries for the autoscaled group or for each of the instances
               (if you are using gce_instance resource type). If multiple
               TimeSeries are returned upon the query execution, the autoscaler
               will sum their respective values to obtain its scaling value.
        :param float single_instance_assignment: If scaling is based on a per-group metric value that represents the
               total amount of work to be done or resource usage, set this value to
               an amount assigned for a single instance of the scaled group.
               The autoscaler will keep the number of instances proportional to the
               value of this metric, the metric itself should not change value due
               to group resizing.
               For example, a good metric to use with the target is
               `pubsub.googleapis.com/subscription/num_undelivered_messages`
               or a custom metric exporting the total number of requests coming to
               your instances.
               A bad example would be a metric exporting an average or median
               latency, since this value can't include a chunk assignable to a
               single instance, it could be better used with utilization_target
               instead.
        :param float target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        :param str type: Defines how target utilization value is expressed for a
               Stackdriver Monitoring metric.
               Possible values are `GAUGE`, `DELTA_PER_SECOND`, and `DELTA_PER_MINUTE`.
        """
        pulumi.set(__self__, "name", name)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if single_instance_assignment is not None:
            pulumi.set(__self__, "single_instance_assignment", single_instance_assignment)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        A filter string to be used as the filter string for
        a Stackdriver Monitoring TimeSeries.list API call.
        This filter is used to select a specific TimeSeries for
        the purpose of autoscaling and to determine whether the metric
        is exporting per-instance or per-group data.
        You can only use the AND operator for joining selectors.
        You can only use direct equality comparison operator (=) without
        any functions for each selector.
        You can specify the metric in both the filter string and in the
        metric field. However, if specified in both places, the metric must
        be identical.
        The monitored resource type determines what kind of values are
        expected for the metric. If it is a gce_instance, the autoscaler
        expects the metric to include a separate TimeSeries for each
        instance in a group. In such a case, you cannot filter on resource
        labels.
        If the resource type is any other value, the autoscaler expects
        this metric to contain values that apply to the entire autoscaled
        instance group and resource label filtering can be performed to
        point autoscaler at the correct TimeSeries to scale upon.
        This is called a per-group metric for the purpose of autoscaling.
        If not specified, the type defaults to gce_instance.
        You should provide a filter that is selective enough to pick just
        one TimeSeries for the autoscaled group or for each of the instances
        (if you are using gce_instance resource type). If multiple
        TimeSeries are returned upon the query execution, the autoscaler
        will sum their respective values to obtain its scaling value.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="singleInstanceAssignment")
    def single_instance_assignment(self) -> Optional[float]:
        """
        If scaling is based on a per-group metric value that represents the
        total amount of work to be done or resource usage, set this value to
        an amount assigned for a single instance of the scaled group.
        The autoscaler will keep the number of instances proportional to the
        value of this metric, the metric itself should not change value due
        to group resizing.
        For example, a good metric to use with the target is
        `pubsub.googleapis.com/subscription/num_undelivered_messages`
        or a custom metric exporting the total number of requests coming to
        your instances.
        A bad example would be a metric exporting an average or median
        latency, since this value can't include a chunk assignable to a
        single instance, it could be better used with utilization_target
        instead.
        """
        return pulumi.get(self, "single_instance_assignment")

    @property
    @pulumi.getter
    def target(self) -> Optional[float]:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines how target utilization value is expressed for a
        Stackdriver Monitoring metric.
        Possible values are `GAUGE`, `DELTA_PER_SECOND`, and `DELTA_PER_MINUTE`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyScaleDownControl(dict):
    def __init__(__self__, *,
                 max_scaled_down_replicas: Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas'] = None,
                 time_window_sec: Optional[int] = None):
        """
        :param 'RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs' max_scaled_down_replicas: A nested object resource
               Structure is documented below.
        :param int time_window_sec: How long back autoscaling should look when computing recommendations
               to include directives regarding slower scale down, as described above.
        """
        if max_scaled_down_replicas is not None:
            pulumi.set(__self__, "max_scaled_down_replicas", max_scaled_down_replicas)
        if time_window_sec is not None:
            pulumi.set(__self__, "time_window_sec", time_window_sec)

    @property
    @pulumi.getter(name="maxScaledDownReplicas")
    def max_scaled_down_replicas(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas']:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "max_scaled_down_replicas")

    @property
    @pulumi.getter(name="timeWindowSec")
    def time_window_sec(self) -> Optional[int]:
        """
        How long back autoscaling should look when computing recommendations
        to include directives regarding slower scale down, as described above.
        """
        return pulumi.get(self, "time_window_sec")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas(dict):
    def __init__(__self__, *,
                 fixed: Optional[int] = None,
                 percent: Optional[int] = None):
        """
        :param int fixed: Specifies a fixed number of VM instances. This must be a positive
               integer.
        :param int percent: Specifies a percentage of instances between 0 to 100%, inclusive.
               For example, specify 80 for 80%.
        """
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def fixed(self) -> Optional[int]:
        """
        Specifies a fixed number of VM instances. This must be a positive
        integer.
        """
        return pulumi.get(self, "fixed")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive.
        For example, specify 80 for 80%.
        """
        return pulumi.get(self, "percent")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyScaleInControl(dict):
    def __init__(__self__, *,
                 max_scaled_in_replicas: Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas'] = None,
                 time_window_sec: Optional[int] = None):
        """
        :param 'RegionAutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicasArgs' max_scaled_in_replicas: A nested object resource
               Structure is documented below.
        :param int time_window_sec: How long back autoscaling should look when computing recommendations
               to include directives regarding slower scale down, as described above.
        """
        if max_scaled_in_replicas is not None:
            pulumi.set(__self__, "max_scaled_in_replicas", max_scaled_in_replicas)
        if time_window_sec is not None:
            pulumi.set(__self__, "time_window_sec", time_window_sec)

    @property
    @pulumi.getter(name="maxScaledInReplicas")
    def max_scaled_in_replicas(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas']:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "max_scaled_in_replicas")

    @property
    @pulumi.getter(name="timeWindowSec")
    def time_window_sec(self) -> Optional[int]:
        """
        How long back autoscaling should look when computing recommendations
        to include directives regarding slower scale down, as described above.
        """
        return pulumi.get(self, "time_window_sec")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas(dict):
    def __init__(__self__, *,
                 fixed: Optional[int] = None,
                 percent: Optional[int] = None):
        """
        :param int fixed: Specifies a fixed number of VM instances. This must be a positive
               integer.
        :param int percent: Specifies a percentage of instances between 0 to 100%, inclusive.
               For example, specify 80 for 80%.
        """
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def fixed(self) -> Optional[int]:
        """
        Specifies a fixed number of VM instances. This must be a positive
        integer.
        """
        return pulumi.get(self, "fixed")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive.
        For example, specify 80 for 80%.
        """
        return pulumi.get(self, "percent")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyScalingSchedule(dict):
    def __init__(__self__, *,
                 duration_sec: int,
                 min_required_replicas: int,
                 name: str,
                 schedule: str,
                 description: Optional[str] = None,
                 disabled: Optional[bool] = None,
                 time_zone: Optional[str] = None):
        """
        :param int duration_sec: The duration of time intervals (in seconds) for which this scaling schedule will be running. The minimum allowed value is 300.
        :param int min_required_replicas: Minimum number of VM instances that autoscaler will recommend in time intervals starting according to schedule.
        :param str name: The identifier for this object. Format specified above.
        :param str schedule: The start timestamps of time intervals when this scaling schedule should provide a scaling signal. This field uses the extended cron format (with an optional year field).
        :param str description: An optional description of this resource.
        :param bool disabled: A boolean value that specifies if a scaling schedule can influence autoscaler recommendations. If set to true, then a scaling schedule has no effect.
        :param str time_zone: The time zone to be used when interpreting the schedule. The value of this field must be a time zone name from the tz database: http://en.wikipedia.org/wiki/Tz_database.
        """
        pulumi.set(__self__, "duration_sec", duration_sec)
        pulumi.set(__self__, "min_required_replicas", min_required_replicas)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="durationSec")
    def duration_sec(self) -> int:
        """
        The duration of time intervals (in seconds) for which this scaling schedule will be running. The minimum allowed value is 300.
        """
        return pulumi.get(self, "duration_sec")

    @property
    @pulumi.getter(name="minRequiredReplicas")
    def min_required_replicas(self) -> int:
        """
        Minimum number of VM instances that autoscaler will recommend in time intervals starting according to schedule.
        """
        return pulumi.get(self, "min_required_replicas")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schedule(self) -> str:
        """
        The start timestamps of time intervals when this scaling schedule should provide a scaling signal. This field uses the extended cron format (with an optional year field).
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of this resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        A boolean value that specifies if a scaling schedule can influence autoscaler recommendations. If set to true, then a scaling schedule has no effect.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        The time zone to be used when interpreting the schedule. The value of this field must be a time zone name from the tz database: http://en.wikipedia.org/wiki/Tz_database.
        """
        return pulumi.get(self, "time_zone")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceBackend(dict):
    def __init__(__self__, *,
                 group: str,
                 balancing_mode: Optional[str] = None,
                 capacity_scaler: Optional[float] = None,
                 description: Optional[str] = None,
                 failover: Optional[bool] = None,
                 max_connections: Optional[int] = None,
                 max_connections_per_endpoint: Optional[int] = None,
                 max_connections_per_instance: Optional[int] = None,
                 max_rate: Optional[int] = None,
                 max_rate_per_endpoint: Optional[float] = None,
                 max_rate_per_instance: Optional[float] = None,
                 max_utilization: Optional[float] = None):
        """
        :param str group: The fully-qualified URL of an Instance Group or Network Endpoint
               Group resource. In case of instance group this defines the list
               of instances that serve traffic. Member virtual machine
               instances from each instance group must live in the same zone as
               the instance group itself. No two backends in a backend service
               are allowed to use same Instance Group resource.
               For Network Endpoint Groups this defines list of endpoints. All
               endpoints of Network Endpoint Group must be hosted on instances
               located in the same zone as the Network Endpoint Group.
               Backend services cannot mix Instance Group and
               Network Endpoint Group backends.
               When the `load_balancing_scheme` is INTERNAL, only instance groups
               are supported.
               Note that you must specify an Instance Group or Network Endpoint
               Group resource using the fully-qualified URL, rather than a
               partial URL.
        :param str balancing_mode: Specifies the balancing mode for this backend.
               Default value is `CONNECTION`.
               Possible values are `UTILIZATION`, `RATE`, and `CONNECTION`.
        :param float capacity_scaler: A multiplier applied to the group's maximum servicing capacity
               (based on UTILIZATION, RATE or CONNECTION).
               ~>**NOTE**: This field cannot be set for
               INTERNAL region backend services (default loadBalancingScheme),
               but is required for non-INTERNAL backend service. The total
               capacity_scaler for all backends must be non-zero.
               A setting of 0 means the group is completely drained, offering
               0% of its available Capacity. Valid range is [0.0,1.0].
        :param str description: An optional description of this resource.
               Provide this property when you create the resource.
        :param bool failover: This field designates whether this is a failover backend. More
               than one failover backend can be configured for a given RegionBackendService.
        :param int max_connections: The maximum number of connections to the backend cluster.
               Defaults to 1024.
        :param int max_connections_per_endpoint: The max number of simultaneous connections that a single backend
               network endpoint can handle. Cannot be set
               for INTERNAL backend services.
               This is used to calculate the capacity of the group. Can be
               used in either CONNECTION or UTILIZATION balancing modes. For
               CONNECTION mode, either maxConnections or
               maxConnectionsPerEndpoint must be set.
        :param int max_connections_per_instance: The max number of simultaneous connections that a single
               backend instance can handle. Cannot be set for INTERNAL backend
               services.
               This is used to calculate the capacity of the group.
               Can be used in either CONNECTION or UTILIZATION balancing modes.
               For CONNECTION mode, either maxConnections or
               maxConnectionsPerInstance must be set.
        :param int max_rate: The max requests per second (RPS) of the group. Cannot be set
               for INTERNAL backend services.
               Can be used with either RATE or UTILIZATION balancing modes,
               but required if RATE mode. Either maxRate or one
               of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
               group type, must be set.
        :param float max_rate_per_endpoint: The max requests per second (RPS) that a single backend network
               endpoint can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerEndpoint must be set. Cannot be set
               for INTERNAL backend services.
        :param float max_rate_per_instance: The max requests per second (RPS) that a single backend
               instance can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerInstance must be set. Cannot be set
               for INTERNAL backend services.
        :param float max_utilization: Used when balancingMode is UTILIZATION. This ratio defines the
               CPU utilization target for the group. Valid range is [0.0, 1.0].
               Cannot be set for INTERNAL backend services.
        """
        pulumi.set(__self__, "group", group)
        if balancing_mode is not None:
            pulumi.set(__self__, "balancing_mode", balancing_mode)
        if capacity_scaler is not None:
            pulumi.set(__self__, "capacity_scaler", capacity_scaler)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if failover is not None:
            pulumi.set(__self__, "failover", failover)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_connections_per_endpoint is not None:
            pulumi.set(__self__, "max_connections_per_endpoint", max_connections_per_endpoint)
        if max_connections_per_instance is not None:
            pulumi.set(__self__, "max_connections_per_instance", max_connections_per_instance)
        if max_rate is not None:
            pulumi.set(__self__, "max_rate", max_rate)
        if max_rate_per_endpoint is not None:
            pulumi.set(__self__, "max_rate_per_endpoint", max_rate_per_endpoint)
        if max_rate_per_instance is not None:
            pulumi.set(__self__, "max_rate_per_instance", max_rate_per_instance)
        if max_utilization is not None:
            pulumi.set(__self__, "max_utilization", max_utilization)

    @property
    @pulumi.getter
    def group(self) -> str:
        """
        The fully-qualified URL of an Instance Group or Network Endpoint
        Group resource. In case of instance group this defines the list
        of instances that serve traffic. Member virtual machine
        instances from each instance group must live in the same zone as
        the instance group itself. No two backends in a backend service
        are allowed to use same Instance Group resource.
        For Network Endpoint Groups this defines list of endpoints. All
        endpoints of Network Endpoint Group must be hosted on instances
        located in the same zone as the Network Endpoint Group.
        Backend services cannot mix Instance Group and
        Network Endpoint Group backends.
        When the `load_balancing_scheme` is INTERNAL, only instance groups
        are supported.
        Note that you must specify an Instance Group or Network Endpoint
        Group resource using the fully-qualified URL, rather than a
        partial URL.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="balancingMode")
    def balancing_mode(self) -> Optional[str]:
        """
        Specifies the balancing mode for this backend.
        Default value is `CONNECTION`.
        Possible values are `UTILIZATION`, `RATE`, and `CONNECTION`.
        """
        return pulumi.get(self, "balancing_mode")

    @property
    @pulumi.getter(name="capacityScaler")
    def capacity_scaler(self) -> Optional[float]:
        """
        A multiplier applied to the group's maximum servicing capacity
        (based on UTILIZATION, RATE or CONNECTION).
        ~>**NOTE**: This field cannot be set for
        INTERNAL region backend services (default loadBalancingScheme),
        but is required for non-INTERNAL backend service. The total
        capacity_scaler for all backends must be non-zero.
        A setting of 0 means the group is completely drained, offering
        0% of its available Capacity. Valid range is [0.0,1.0].
        """
        return pulumi.get(self, "capacity_scaler")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of this resource.
        Provide this property when you create the resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def failover(self) -> Optional[bool]:
        """
        This field designates whether this is a failover backend. More
        than one failover backend can be configured for a given RegionBackendService.
        """
        return pulumi.get(self, "failover")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        """
        The maximum number of connections to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxConnectionsPerEndpoint")
    def max_connections_per_endpoint(self) -> Optional[int]:
        """
        The max number of simultaneous connections that a single backend
        network endpoint can handle. Cannot be set
        for INTERNAL backend services.
        This is used to calculate the capacity of the group. Can be
        used in either CONNECTION or UTILIZATION balancing modes. For
        CONNECTION mode, either maxConnections or
        maxConnectionsPerEndpoint must be set.
        """
        return pulumi.get(self, "max_connections_per_endpoint")

    @property
    @pulumi.getter(name="maxConnectionsPerInstance")
    def max_connections_per_instance(self) -> Optional[int]:
        """
        The max number of simultaneous connections that a single
        backend instance can handle. Cannot be set for INTERNAL backend
        services.
        This is used to calculate the capacity of the group.
        Can be used in either CONNECTION or UTILIZATION balancing modes.
        For CONNECTION mode, either maxConnections or
        maxConnectionsPerInstance must be set.
        """
        return pulumi.get(self, "max_connections_per_instance")

    @property
    @pulumi.getter(name="maxRate")
    def max_rate(self) -> Optional[int]:
        """
        The max requests per second (RPS) of the group. Cannot be set
        for INTERNAL backend services.
        Can be used with either RATE or UTILIZATION balancing modes,
        but required if RATE mode. Either maxRate or one
        of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
        group type, must be set.
        """
        return pulumi.get(self, "max_rate")

    @property
    @pulumi.getter(name="maxRatePerEndpoint")
    def max_rate_per_endpoint(self) -> Optional[float]:
        """
        The max requests per second (RPS) that a single backend network
        endpoint can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerEndpoint must be set. Cannot be set
        for INTERNAL backend services.
        """
        return pulumi.get(self, "max_rate_per_endpoint")

    @property
    @pulumi.getter(name="maxRatePerInstance")
    def max_rate_per_instance(self) -> Optional[float]:
        """
        The max requests per second (RPS) that a single backend
        instance can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerInstance must be set. Cannot be set
        for INTERNAL backend services.
        """
        return pulumi.get(self, "max_rate_per_instance")

    @property
    @pulumi.getter(name="maxUtilization")
    def max_utilization(self) -> Optional[float]:
        """
        Used when balancingMode is UTILIZATION. This ratio defines the
        CPU utilization target for the group. Valid range is [0.0, 1.0].
        Cannot be set for INTERNAL backend services.
        """
        return pulumi.get(self, "max_utilization")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceCdnPolicy(dict):
    def __init__(__self__, *,
                 cache_key_policy: Optional['outputs.RegionBackendServiceCdnPolicyCacheKeyPolicy'] = None,
                 cache_mode: Optional[str] = None,
                 client_ttl: Optional[int] = None,
                 default_ttl: Optional[int] = None,
                 max_ttl: Optional[int] = None,
                 negative_caching: Optional[bool] = None,
                 negative_caching_policies: Optional[Sequence['outputs.RegionBackendServiceCdnPolicyNegativeCachingPolicy']] = None,
                 serve_while_stale: Optional[int] = None,
                 signed_url_cache_max_age_sec: Optional[int] = None):
        """
        :param 'RegionBackendServiceCdnPolicyCacheKeyPolicyArgs' cache_key_policy: The CacheKeyPolicy for this CdnPolicy.
               Structure is documented below.
        :param str cache_mode: Specifies the cache setting for all responses from this backend.
               The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
               Possible values are `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, and `CACHE_ALL_STATIC`.
        :param int client_ttl: Specifies the maximum allowed TTL for cached content served by this origin.
        :param int default_ttl: Specifies the default TTL for cached content served by this origin for responses
               that do not have an existing valid TTL (max-age or s-max-age).
        :param int max_ttl: Specifies the maximum allowed TTL for cached content served by this origin.
        :param bool negative_caching: Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        :param Sequence['RegionBackendServiceCdnPolicyNegativeCachingPolicyArgs'] negative_caching_policies: Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
               Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
               Structure is documented below.
        :param int serve_while_stale: Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        :param int signed_url_cache_max_age_sec: Maximum number of seconds the response to a signed URL request
               will be considered fresh, defaults to 1hr (3600s). After this
               time period, the response will be revalidated before
               being served.
               When serving responses to signed URL requests, Cloud CDN will
               internally behave as though all responses from this backend had a
               "Cache-Control: public, max-age=[TTL]" header, regardless of any
               existing Cache-Control header. The actual headers served in
               responses will not be altered.
        """
        if cache_key_policy is not None:
            pulumi.set(__self__, "cache_key_policy", cache_key_policy)
        if cache_mode is not None:
            pulumi.set(__self__, "cache_mode", cache_mode)
        if client_ttl is not None:
            pulumi.set(__self__, "client_ttl", client_ttl)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if negative_caching is not None:
            pulumi.set(__self__, "negative_caching", negative_caching)
        if negative_caching_policies is not None:
            pulumi.set(__self__, "negative_caching_policies", negative_caching_policies)
        if serve_while_stale is not None:
            pulumi.set(__self__, "serve_while_stale", serve_while_stale)
        if signed_url_cache_max_age_sec is not None:
            pulumi.set(__self__, "signed_url_cache_max_age_sec", signed_url_cache_max_age_sec)

    @property
    @pulumi.getter(name="cacheKeyPolicy")
    def cache_key_policy(self) -> Optional['outputs.RegionBackendServiceCdnPolicyCacheKeyPolicy']:
        """
        The CacheKeyPolicy for this CdnPolicy.
        Structure is documented below.
        """
        return pulumi.get(self, "cache_key_policy")

    @property
    @pulumi.getter(name="cacheMode")
    def cache_mode(self) -> Optional[str]:
        """
        Specifies the cache setting for all responses from this backend.
        The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
        Possible values are `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, and `CACHE_ALL_STATIC`.
        """
        return pulumi.get(self, "cache_mode")

    @property
    @pulumi.getter(name="clientTtl")
    def client_ttl(self) -> Optional[int]:
        """
        Specifies the maximum allowed TTL for cached content served by this origin.
        """
        return pulumi.get(self, "client_ttl")

    @property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[int]:
        """
        Specifies the default TTL for cached content served by this origin for responses
        that do not have an existing valid TTL (max-age or s-max-age).
        """
        return pulumi.get(self, "default_ttl")

    @property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[int]:
        """
        Specifies the maximum allowed TTL for cached content served by this origin.
        """
        return pulumi.get(self, "max_ttl")

    @property
    @pulumi.getter(name="negativeCaching")
    def negative_caching(self) -> Optional[bool]:
        """
        Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        """
        return pulumi.get(self, "negative_caching")

    @property
    @pulumi.getter(name="negativeCachingPolicies")
    def negative_caching_policies(self) -> Optional[Sequence['outputs.RegionBackendServiceCdnPolicyNegativeCachingPolicy']]:
        """
        Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
        Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
        Structure is documented below.
        """
        return pulumi.get(self, "negative_caching_policies")

    @property
    @pulumi.getter(name="serveWhileStale")
    def serve_while_stale(self) -> Optional[int]:
        """
        Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        """
        return pulumi.get(self, "serve_while_stale")

    @property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> Optional[int]:
        """
        Maximum number of seconds the response to a signed URL request
        will be considered fresh, defaults to 1hr (3600s). After this
        time period, the response will be revalidated before
        being served.
        When serving responses to signed URL requests, Cloud CDN will
        internally behave as though all responses from this backend had a
        "Cache-Control: public, max-age=[TTL]" header, regardless of any
        existing Cache-Control header. The actual headers served in
        responses will not be altered.
        """
        return pulumi.get(self, "signed_url_cache_max_age_sec")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceCdnPolicyCacheKeyPolicy(dict):
    def __init__(__self__, *,
                 include_host: Optional[bool] = None,
                 include_protocol: Optional[bool] = None,
                 include_query_string: Optional[bool] = None,
                 query_string_blacklists: Optional[Sequence[str]] = None,
                 query_string_whitelists: Optional[Sequence[str]] = None):
        """
        :param bool include_host: If true requests to different hosts will be cached separately.
        :param bool include_protocol: If true, http and https requests will be cached separately.
        :param bool include_query_string: If true, include query string parameters in the cache key
               according to query_string_whitelist and
               query_string_blacklist. If neither is set, the entire query
               string will be included.
               If false, the query string will be excluded from the cache
               key entirely.
        :param Sequence[str] query_string_blacklists: Names of query string parameters to exclude in cache keys.
               All other parameters will be included. Either specify
               query_string_whitelist or query_string_blacklist, not both.
               '&' and '=' will be percent encoded and not treated as
               delimiters.
        :param Sequence[str] query_string_whitelists: Names of query string parameters to include in cache keys.
               All other parameters will be excluded. Either specify
               query_string_whitelist or query_string_blacklist, not both.
               '&' and '=' will be percent encoded and not treated as
               delimiters.
        """
        if include_host is not None:
            pulumi.set(__self__, "include_host", include_host)
        if include_protocol is not None:
            pulumi.set(__self__, "include_protocol", include_protocol)
        if include_query_string is not None:
            pulumi.set(__self__, "include_query_string", include_query_string)
        if query_string_blacklists is not None:
            pulumi.set(__self__, "query_string_blacklists", query_string_blacklists)
        if query_string_whitelists is not None:
            pulumi.set(__self__, "query_string_whitelists", query_string_whitelists)

    @property
    @pulumi.getter(name="includeHost")
    def include_host(self) -> Optional[bool]:
        """
        If true requests to different hosts will be cached separately.
        """
        return pulumi.get(self, "include_host")

    @property
    @pulumi.getter(name="includeProtocol")
    def include_protocol(self) -> Optional[bool]:
        """
        If true, http and https requests will be cached separately.
        """
        return pulumi.get(self, "include_protocol")

    @property
    @pulumi.getter(name="includeQueryString")
    def include_query_string(self) -> Optional[bool]:
        """
        If true, include query string parameters in the cache key
        according to query_string_whitelist and
        query_string_blacklist. If neither is set, the entire query
        string will be included.
        If false, the query string will be excluded from the cache
        key entirely.
        """
        return pulumi.get(self, "include_query_string")

    @property
    @pulumi.getter(name="queryStringBlacklists")
    def query_string_blacklists(self) -> Optional[Sequence[str]]:
        """
        Names of query string parameters to exclude in cache keys.
        All other parameters will be included. Either specify
        query_string_whitelist or query_string_blacklist, not both.
        '&' and '=' will be percent encoded and not treated as
        delimiters.
        """
        return pulumi.get(self, "query_string_blacklists")

    @property
    @pulumi.getter(name="queryStringWhitelists")
    def query_string_whitelists(self) -> Optional[Sequence[str]]:
        """
        Names of query string parameters to include in cache keys.
        All other parameters will be excluded. Either specify
        query_string_whitelist or query_string_blacklist, not both.
        '&' and '=' will be percent encoded and not treated as
        delimiters.
        """
        return pulumi.get(self, "query_string_whitelists")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceCdnPolicyNegativeCachingPolicy(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 ttl: Optional[int] = None):
        """
        :param int code: The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
               can be specified as values, and you cannot specify a status code more than once.
        :param int ttl: The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
               (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
        can be specified as values, and you cannot specify a status code more than once.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
        (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        return pulumi.get(self, "ttl")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceCircuitBreakers(dict):
    def __init__(__self__, *,
                 connect_timeout: Optional['outputs.RegionBackendServiceCircuitBreakersConnectTimeout'] = None,
                 max_connections: Optional[int] = None,
                 max_pending_requests: Optional[int] = None,
                 max_requests: Optional[int] = None,
                 max_requests_per_connection: Optional[int] = None,
                 max_retries: Optional[int] = None):
        """
        :param 'RegionBackendServiceCircuitBreakersConnectTimeoutArgs' connect_timeout: The timeout for new network connections to hosts.  Structure is documented below.
        :param int max_connections: The maximum number of connections to the backend cluster.
               Defaults to 1024.
        :param int max_pending_requests: The maximum number of pending requests to the backend cluster.
               Defaults to 1024.
        :param int max_requests: The maximum number of parallel requests to the backend cluster.
               Defaults to 1024.
        :param int max_requests_per_connection: Maximum requests for a single backend connection. This parameter
               is respected by both the HTTP/1.1 and HTTP/2 implementations. If
               not specified, there is no limit. Setting this parameter to 1
               will effectively disable keep alive.
        :param int max_retries: The maximum number of parallel retries to the backend cluster.
               Defaults to 3.
        """
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_pending_requests is not None:
            pulumi.set(__self__, "max_pending_requests", max_pending_requests)
        if max_requests is not None:
            pulumi.set(__self__, "max_requests", max_requests)
        if max_requests_per_connection is not None:
            pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional['outputs.RegionBackendServiceCircuitBreakersConnectTimeout']:
        """
        The timeout for new network connections to hosts.  Structure is documented below.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        """
        The maximum number of connections to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> Optional[int]:
        """
        The maximum number of pending requests to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_pending_requests")

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> Optional[int]:
        """
        The maximum number of parallel requests to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_requests")

    @property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> Optional[int]:
        """
        Maximum requests for a single backend connection. This parameter
        is respected by both the HTTP/1.1 and HTTP/2 implementations. If
        not specified, there is no limit. Setting this parameter to 1
        will effectively disable keep alive.
        """
        return pulumi.get(self, "max_requests_per_connection")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        """
        The maximum number of parallel retries to the backend cluster.
        Defaults to 3.
        """
        return pulumi.get(self, "max_retries")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceCircuitBreakersConnectTimeout(dict):
    def __init__(__self__, *,
                 seconds: int,
                 nanos: Optional[int] = None):
        """
        :param int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceConsistentHash(dict):
    def __init__(__self__, *,
                 http_cookie: Optional['outputs.RegionBackendServiceConsistentHashHttpCookie'] = None,
                 http_header_name: Optional[str] = None,
                 minimum_ring_size: Optional[int] = None):
        """
        :param 'RegionBackendServiceConsistentHashHttpCookieArgs' http_cookie: Hash is based on HTTP Cookie. This field describes a HTTP cookie
               that will be used as the hash key for the consistent hash load
               balancer. If the cookie is not present, it will be generated.
               This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
               Structure is documented below.
        :param str http_header_name: The hash based on the value of the specified header field.
               This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        :param int minimum_ring_size: The minimum number of virtual nodes to use for the hash ring.
               Larger ring sizes result in more granular load
               distributions. If the number of hosts in the load balancing pool
               is larger than the ring size, each host will be assigned a single
               virtual node.
               Defaults to 1024.
        """
        if http_cookie is not None:
            pulumi.set(__self__, "http_cookie", http_cookie)
        if http_header_name is not None:
            pulumi.set(__self__, "http_header_name", http_header_name)
        if minimum_ring_size is not None:
            pulumi.set(__self__, "minimum_ring_size", minimum_ring_size)

    @property
    @pulumi.getter(name="httpCookie")
    def http_cookie(self) -> Optional['outputs.RegionBackendServiceConsistentHashHttpCookie']:
        """
        Hash is based on HTTP Cookie. This field describes a HTTP cookie
        that will be used as the hash key for the consistent hash load
        balancer. If the cookie is not present, it will be generated.
        This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
        Structure is documented below.
        """
        return pulumi.get(self, "http_cookie")

    @property
    @pulumi.getter(name="httpHeaderName")
    def http_header_name(self) -> Optional[str]:
        """
        The hash based on the value of the specified header field.
        This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        """
        return pulumi.get(self, "http_header_name")

    @property
    @pulumi.getter(name="minimumRingSize")
    def minimum_ring_size(self) -> Optional[int]:
        """
        The minimum number of virtual nodes to use for the hash ring.
        Larger ring sizes result in more granular load
        distributions. If the number of hosts in the load balancing pool
        is larger than the ring size, each host will be assigned a single
        virtual node.
        Defaults to 1024.
        """
        return pulumi.get(self, "minimum_ring_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceConsistentHashHttpCookie(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 path: Optional[str] = None,
                 ttl: Optional['outputs.RegionBackendServiceConsistentHashHttpCookieTtl'] = None):
        """
        :param str name: Name of the cookie.
        :param str path: Path to set for the cookie.
        :param 'RegionBackendServiceConsistentHashHttpCookieTtlArgs' ttl: The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
               (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the cookie.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to set for the cookie.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def ttl(self) -> Optional['outputs.RegionBackendServiceConsistentHashHttpCookieTtl']:
        """
        The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
        (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        return pulumi.get(self, "ttl")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceConsistentHashHttpCookieTtl(dict):
    def __init__(__self__, *,
                 seconds: int,
                 nanos: Optional[int] = None):
        """
        :param int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceFailoverPolicy(dict):
    def __init__(__self__, *,
                 disable_connection_drain_on_failover: Optional[bool] = None,
                 drop_traffic_if_unhealthy: Optional[bool] = None,
                 failover_ratio: Optional[float] = None):
        """
        :param bool disable_connection_drain_on_failover: On failover or failback, this field indicates whether connection drain
               will be honored. Setting this to true has the following effect: connections
               to the old active pool are not drained. Connections to the new active pool
               use the timeout of 10 min (currently fixed). Setting to false has the
               following effect: both old and new connections will have a drain timeout
               of 10 min.
               This can be set to true only if the protocol is TCP.
               The default is false.
        :param bool drop_traffic_if_unhealthy: This option is used only when no healthy VMs are detected in the primary
               and backup instance groups. When set to true, traffic is dropped. When
               set to false, new connections are sent across all VMs in the primary group.
               The default is false.
        :param float failover_ratio: The value of the field must be in [0, 1]. If the ratio of the healthy
               VMs in the primary backend is at or below this number, traffic arriving
               at the load-balanced IP will be directed to the failover backend.
               In case where 'failoverRatio' is not set or all the VMs in the backup
               backend are unhealthy, the traffic will be directed back to the primary
               backend in the "force" mode, where traffic will be spread to the healthy
               VMs with the best effort, or to all VMs when no VM is healthy.
               This field is only used with l4 load balancing.
        """
        if disable_connection_drain_on_failover is not None:
            pulumi.set(__self__, "disable_connection_drain_on_failover", disable_connection_drain_on_failover)
        if drop_traffic_if_unhealthy is not None:
            pulumi.set(__self__, "drop_traffic_if_unhealthy", drop_traffic_if_unhealthy)
        if failover_ratio is not None:
            pulumi.set(__self__, "failover_ratio", failover_ratio)

    @property
    @pulumi.getter(name="disableConnectionDrainOnFailover")
    def disable_connection_drain_on_failover(self) -> Optional[bool]:
        """
        On failover or failback, this field indicates whether connection drain
        will be honored. Setting this to true has the following effect: connections
        to the old active pool are not drained. Connections to the new active pool
        use the timeout of 10 min (currently fixed). Setting to false has the
        following effect: both old and new connections will have a drain timeout
        of 10 min.
        This can be set to true only if the protocol is TCP.
        The default is false.
        """
        return pulumi.get(self, "disable_connection_drain_on_failover")

    @property
    @pulumi.getter(name="dropTrafficIfUnhealthy")
    def drop_traffic_if_unhealthy(self) -> Optional[bool]:
        """
        This option is used only when no healthy VMs are detected in the primary
        and backup instance groups. When set to true, traffic is dropped. When
        set to false, new connections are sent across all VMs in the primary group.
        The default is false.
        """
        return pulumi.get(self, "drop_traffic_if_unhealthy")

    @property
    @pulumi.getter(name="failoverRatio")
    def failover_ratio(self) -> Optional[float]:
        """
        The value of the field must be in [0, 1]. If the ratio of the healthy
        VMs in the primary backend is at or below this number, traffic arriving
        at the load-balanced IP will be directed to the failover backend.
        In case where 'failoverRatio' is not set or all the VMs in the backup
        backend are unhealthy, the traffic will be directed back to the primary
        backend in the "force" mode, where traffic will be spread to the healthy
        VMs with the best effort, or to all VMs when no VM is healthy.
        This field is only used with l4 load balancing.
        """
        return pulumi.get(self, "failover_ratio")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceLogConfig(dict):
    def __init__(__self__, *,
                 enable: Optional[bool] = None,
                 sample_rate: Optional[float] = None):
        """
        :param bool enable: Whether to enable logging for the load balancer traffic served by this backend service.
        :param float sample_rate: This field can only be specified if logging is enabled for this backend service. The value of
               the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
               where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
               The default value is 1.0.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Whether to enable logging for the load balancer traffic served by this backend service.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        """
        This field can only be specified if logging is enabled for this backend service. The value of
        the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
        where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
        The default value is 1.0.
        """
        return pulumi.get(self, "sample_rate")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceOutlierDetection(dict):
    def __init__(__self__, *,
                 base_ejection_time: Optional['outputs.RegionBackendServiceOutlierDetectionBaseEjectionTime'] = None,
                 consecutive_errors: Optional[int] = None,
                 consecutive_gateway_failure: Optional[int] = None,
                 enforcing_consecutive_errors: Optional[int] = None,
                 enforcing_consecutive_gateway_failure: Optional[int] = None,
                 enforcing_success_rate: Optional[int] = None,
                 interval: Optional['outputs.RegionBackendServiceOutlierDetectionInterval'] = None,
                 max_ejection_percent: Optional[int] = None,
                 success_rate_minimum_hosts: Optional[int] = None,
                 success_rate_request_volume: Optional[int] = None,
                 success_rate_stdev_factor: Optional[int] = None):
        """
        :param 'RegionBackendServiceOutlierDetectionBaseEjectionTimeArgs' base_ejection_time: The base time that a host is ejected for. The real time is equal to the base
               time multiplied by the number of times the host has been ejected. Defaults to
               30000ms or 30s.
               Structure is documented below.
        :param int consecutive_errors: Number of errors before a host is ejected from the connection pool. When the
               backend host is accessed over HTTP, a 5xx return code qualifies as an error.
               Defaults to 5.
        :param int consecutive_gateway_failure: The number of consecutive gateway failures (502, 503, 504 status or connection
               errors that are mapped to one of those status codes) before a consecutive
               gateway failure ejection occurs. Defaults to 5.
        :param int enforcing_consecutive_errors: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive 5xx. This setting can be used to disable
               ejection or to ramp it up slowly. Defaults to 100.
        :param int enforcing_consecutive_gateway_failure: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive gateway failures. This setting can be
               used to disable ejection or to ramp it up slowly. Defaults to 0.
        :param int enforcing_success_rate: The percentage chance that a host will be actually ejected when an outlier
               status is detected through success rate statistics. This setting can be used to
               disable ejection or to ramp it up slowly. Defaults to 100.
        :param 'RegionBackendServiceOutlierDetectionIntervalArgs' interval: Time interval between ejection sweep analysis. This can result in both new
               ejections as well as hosts being returned to service. Defaults to 10 seconds.
               Structure is documented below.
        :param int max_ejection_percent: Maximum percentage of hosts in the load balancing pool for the backend service
               that can be ejected. Defaults to 10%.
        :param int success_rate_minimum_hosts: The number of hosts in a cluster that must have enough request volume to detect
               success rate outliers. If the number of hosts is less than this setting, outlier
               detection via success rate statistics is not performed for any host in the
               cluster. Defaults to 5.
        :param int success_rate_request_volume: The minimum number of total requests that must be collected in one interval (as
               defined by the interval duration above) to include this host in success rate
               based outlier detection. If the volume is lower than this setting, outlier
               detection via success rate statistics is not performed for that host. Defaults
               to 100.
        :param int success_rate_stdev_factor: This factor is used to determine the ejection threshold for success rate outlier
               ejection. The ejection threshold is the difference between the mean success
               rate, and the product of this factor and the standard deviation of the mean
               success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
               by a thousand to get a double. That is, if the desired factor is 1.9, the
               runtime value should be 1900. Defaults to 1900.
        """
        if base_ejection_time is not None:
            pulumi.set(__self__, "base_ejection_time", base_ejection_time)
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if consecutive_gateway_failure is not None:
            pulumi.set(__self__, "consecutive_gateway_failure", consecutive_gateway_failure)
        if enforcing_consecutive_errors is not None:
            pulumi.set(__self__, "enforcing_consecutive_errors", enforcing_consecutive_errors)
        if enforcing_consecutive_gateway_failure is not None:
            pulumi.set(__self__, "enforcing_consecutive_gateway_failure", enforcing_consecutive_gateway_failure)
        if enforcing_success_rate is not None:
            pulumi.set(__self__, "enforcing_success_rate", enforcing_success_rate)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        if success_rate_minimum_hosts is not None:
            pulumi.set(__self__, "success_rate_minimum_hosts", success_rate_minimum_hosts)
        if success_rate_request_volume is not None:
            pulumi.set(__self__, "success_rate_request_volume", success_rate_request_volume)
        if success_rate_stdev_factor is not None:
            pulumi.set(__self__, "success_rate_stdev_factor", success_rate_stdev_factor)

    @property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional['outputs.RegionBackendServiceOutlierDetectionBaseEjectionTime']:
        """
        The base time that a host is ejected for. The real time is equal to the base
        time multiplied by the number of times the host has been ejected. Defaults to
        30000ms or 30s.
        Structure is documented below.
        """
        return pulumi.get(self, "base_ejection_time")

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[int]:
        """
        Number of errors before a host is ejected from the connection pool. When the
        backend host is accessed over HTTP, a 5xx return code qualifies as an error.
        Defaults to 5.
        """
        return pulumi.get(self, "consecutive_errors")

    @property
    @pulumi.getter(name="consecutiveGatewayFailure")
    def consecutive_gateway_failure(self) -> Optional[int]:
        """
        The number of consecutive gateway failures (502, 503, 504 status or connection
        errors that are mapped to one of those status codes) before a consecutive
        gateway failure ejection occurs. Defaults to 5.
        """
        return pulumi.get(self, "consecutive_gateway_failure")

    @property
    @pulumi.getter(name="enforcingConsecutiveErrors")
    def enforcing_consecutive_errors(self) -> Optional[int]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive 5xx. This setting can be used to disable
        ejection or to ramp it up slowly. Defaults to 100.
        """
        return pulumi.get(self, "enforcing_consecutive_errors")

    @property
    @pulumi.getter(name="enforcingConsecutiveGatewayFailure")
    def enforcing_consecutive_gateway_failure(self) -> Optional[int]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive gateway failures. This setting can be
        used to disable ejection or to ramp it up slowly. Defaults to 0.
        """
        return pulumi.get(self, "enforcing_consecutive_gateway_failure")

    @property
    @pulumi.getter(name="enforcingSuccessRate")
    def enforcing_success_rate(self) -> Optional[int]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through success rate statistics. This setting can be used to
        disable ejection or to ramp it up slowly. Defaults to 100.
        """
        return pulumi.get(self, "enforcing_success_rate")

    @property
    @pulumi.getter
    def interval(self) -> Optional['outputs.RegionBackendServiceOutlierDetectionInterval']:
        """
        Time interval between ejection sweep analysis. This can result in both new
        ejections as well as hosts being returned to service. Defaults to 10 seconds.
        Structure is documented below.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[int]:
        """
        Maximum percentage of hosts in the load balancing pool for the backend service
        that can be ejected. Defaults to 10%.
        """
        return pulumi.get(self, "max_ejection_percent")

    @property
    @pulumi.getter(name="successRateMinimumHosts")
    def success_rate_minimum_hosts(self) -> Optional[int]:
        """
        The number of hosts in a cluster that must have enough request volume to detect
        success rate outliers. If the number of hosts is less than this setting, outlier
        detection via success rate statistics is not performed for any host in the
        cluster. Defaults to 5.
        """
        return pulumi.get(self, "success_rate_minimum_hosts")

    @property
    @pulumi.getter(name="successRateRequestVolume")
    def success_rate_request_volume(self) -> Optional[int]:
        """
        The minimum number of total requests that must be collected in one interval (as
        defined by the interval duration above) to include this host in success rate
        based outlier detection. If the volume is lower than this setting, outlier
        detection via success rate statistics is not performed for that host. Defaults
        to 100.
        """
        return pulumi.get(self, "success_rate_request_volume")

    @property
    @pulumi.getter(name="successRateStdevFactor")
    def success_rate_stdev_factor(self) -> Optional[int]:
        """
        This factor is used to determine the ejection threshold for success rate outlier
        ejection. The ejection threshold is the difference between the mean success
        rate, and the product of this factor and the standard deviation of the mean
        success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
        by a thousand to get a double. That is, if the desired factor is 1.9, the
        runtime value should be 1900. Defaults to 1900.
        """
        return pulumi.get(self, "success_rate_stdev_factor")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceOutlierDetectionBaseEjectionTime(dict):
    def __init__(__self__, *,
                 seconds: int,
                 nanos: Optional[int] = None):
        """
        :param int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionBackendServiceOutlierDetectionInterval(dict):
    def __init__(__self__, *,
                 seconds: int,
                 nanos: Optional[int] = None):
        """
        :param int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionDiskDiskEncryptionKey(dict):
    def __init__(__self__, *,
                 kms_key_name: Optional[str] = None,
                 raw_key: Optional[str] = None,
                 sha256: Optional[str] = None):
        """
        :param str kms_key_name: The name of the encryption key that is stored in Google Cloud KMS.
        :param str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param str sha256: -
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[str]:
        """
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_name")

    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        -
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionDiskIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionDiskIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionDiskSourceSnapshotEncryptionKey(dict):
    def __init__(__self__, *,
                 kms_key_name: Optional[str] = None,
                 raw_key: Optional[str] = None,
                 sha256: Optional[str] = None):
        """
        :param str kms_key_name: The name of the encryption key that is stored in Google Cloud KMS.
        :param str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param str sha256: -
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[str]:
        """
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_name")

    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        -
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionHealthCheckGrpcHealthCheck(dict):
    def __init__(__self__, *,
                 grpc_service_name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_name: Optional[str] = None,
                 port_specification: Optional[str] = None):
        """
        :param str grpc_service_name: The gRPC service name for the health check.
               The value of grpcServiceName has the following meanings by convention:
               * Empty serviceName means the overall status of all services at the backend.
               * Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
               The grpcServiceName can only be ASCII.
        :param int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        if grpc_service_name is not None:
            pulumi.set(__self__, "grpc_service_name", grpc_service_name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)

    @property
    @pulumi.getter(name="grpcServiceName")
    def grpc_service_name(self) -> Optional[str]:
        """
        The gRPC service name for the health check.
        The value of grpcServiceName has the following meanings by convention:
        * Empty serviceName means the overall status of all services at the backend.
        * Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
        The grpcServiceName can only be ASCII.
        """
        return pulumi.get(self, "grpc_service_name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionHealthCheckHttp2HealthCheck(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional[int] = None,
                 port_name: Optional[str] = None,
                 port_specification: Optional[str] = None,
                 proxy_header: Optional[str] = None,
                 request_path: Optional[str] = None,
                 response: Optional[str] = None):
        """
        :param str host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        :param str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are `NONE` and `PROXY_V1`.
        :param str request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request_path is not None:
            pulumi.set(__self__, "request_path", request_path)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[str]:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionHealthCheckHttpHealthCheck(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional[int] = None,
                 port_name: Optional[str] = None,
                 port_specification: Optional[str] = None,
                 proxy_header: Optional[str] = None,
                 request_path: Optional[str] = None,
                 response: Optional[str] = None):
        """
        :param str host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        :param str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are `NONE` and `PROXY_V1`.
        :param str request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request_path is not None:
            pulumi.set(__self__, "request_path", request_path)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[str]:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionHealthCheckHttpsHealthCheck(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional[int] = None,
                 port_name: Optional[str] = None,
                 port_specification: Optional[str] = None,
                 proxy_header: Optional[str] = None,
                 request_path: Optional[str] = None,
                 response: Optional[str] = None):
        """
        :param str host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        :param str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are `NONE` and `PROXY_V1`.
        :param str request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request_path is not None:
            pulumi.set(__self__, "request_path", request_path)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[str]:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionHealthCheckLogConfig(dict):
    def __init__(__self__, *,
                 enable: Optional[bool] = None):
        """
        :param bool enable: Indicates whether or not to export logs. This is false by default,
               which means no health check logging will be done.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Indicates whether or not to export logs. This is false by default,
        which means no health check logging will be done.
        """
        return pulumi.get(self, "enable")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionHealthCheckSslHealthCheck(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None,
                 port_name: Optional[str] = None,
                 port_specification: Optional[str] = None,
                 proxy_header: Optional[str] = None,
                 request: Optional[str] = None,
                 response: Optional[str] = None):
        """
        :param int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        :param str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are `NONE` and `PROXY_V1`.
        :param str request: The application data to send once the SSL connection has been
               established (default value is empty). If both request and response are
               empty, the connection establishment alone will indicate health. The request
               data can only be ASCII.
        :param str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter
    def request(self) -> Optional[str]:
        """
        The application data to send once the SSL connection has been
        established (default value is empty). If both request and response are
        empty, the connection establishment alone will indicate health. The request
        data can only be ASCII.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionHealthCheckTcpHealthCheck(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None,
                 port_name: Optional[str] = None,
                 port_specification: Optional[str] = None,
                 proxy_header: Optional[str] = None,
                 request: Optional[str] = None,
                 response: Optional[str] = None):
        """
        :param int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        :param str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are `NONE` and `PROXY_V1`.
        :param str request: The application data to send once the SSL connection has been
               established (default value is empty). If both request and response are
               empty, the connection establishment alone will indicate health. The request
               data can only be ASCII.
        :param str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are `USE_FIXED_PORT`, `USE_NAMED_PORT`, and `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are `NONE` and `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter
    def request(self) -> Optional[str]:
        """
        The application data to send once the SSL connection has been
        established (default value is empty). If both request and response are
        empty, the connection establishment alone will indicate health. The request
        data can only be ASCII.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> Optional[str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionInstanceGroupManagerAutoHealingPolicies(dict):
    def __init__(__self__, *,
                 health_check: str,
                 initial_delay_sec: int):
        """
        :param str health_check: The health check resource that signals autohealing.
        :param int initial_delay_sec: The number of seconds that the managed instance group waits before
               it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        pulumi.set(__self__, "health_check", health_check)
        pulumi.set(__self__, "initial_delay_sec", initial_delay_sec)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> str:
        """
        The health check resource that signals autohealing.
        """
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter(name="initialDelaySec")
    def initial_delay_sec(self) -> int:
        """
        The number of seconds that the managed instance group waits before
        it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        return pulumi.get(self, "initial_delay_sec")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionInstanceGroupManagerNamedPort(dict):
    def __init__(__self__, *,
                 name: str,
                 port: int):
        """
        :param str name: - Version name.
        :param int port: The port number.
               - - -
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - Version name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port number.
        - - -
        """
        return pulumi.get(self, "port")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionInstanceGroupManagerStatefulDisk(dict):
    def __init__(__self__, *,
                 device_name: str,
                 delete_rule: Optional[str] = None):
        """
        :param str device_name: , The device name of the disk to be attached.
        :param str delete_rule: , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the disk when the VM is deleted, but do not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
        """
        pulumi.set(__self__, "device_name", device_name)
        if delete_rule is not None:
            pulumi.set(__self__, "delete_rule", delete_rule)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        , The device name of the disk to be attached.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[str]:
        """
        , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the disk when the VM is deleted, but do not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
        """
        return pulumi.get(self, "delete_rule")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionInstanceGroupManagerUpdatePolicy(dict):
    def __init__(__self__, *,
                 minimal_action: str,
                 type: str,
                 instance_redistribution_type: Optional[str] = None,
                 max_surge_fixed: Optional[int] = None,
                 max_surge_percent: Optional[int] = None,
                 max_unavailable_fixed: Optional[int] = None,
                 max_unavailable_percent: Optional[int] = None,
                 min_ready_sec: Optional[int] = None,
                 replacement_method: Optional[str] = None):
        """
        :param str minimal_action: - Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        :param str type: - The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        :param str instance_redistribution_type: - The instance redistribution policy for regional managed instance groups. Valid values are: `"PROACTIVE"`, `"NONE"`. If `PROACTIVE` (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If `NONE`, proactive redistribution is disabled.
        :param int max_surge_fixed: , The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `max_surge_percent`. It has to be either 0 or at least equal to the number of zones.  If fixed values are used, at least one of `max_unavailable_fixed` or `max_surge_fixed` must be greater than 0.
        :param int max_surge_percent: , The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `max_surge_fixed`. Percent value is only allowed for regional managed instance groups with size at least 10.
        :param int max_unavailable_fixed: , The maximum number of instances that can be unavailable during the update process. Conflicts with `max_unavailable_percent`. It has to be either 0 or at least equal to the number of zones. If fixed values are used, at least one of `max_unavailable_fixed` or `max_surge_fixed` must be greater than 0.
        :param int max_unavailable_percent: , The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `max_unavailable_fixed`. Percent value is only allowed for regional managed instance groups with size at least 10.
        :param int min_ready_sec: , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
        :param str replacement_method: , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
               - - -
        """
        pulumi.set(__self__, "minimal_action", minimal_action)
        pulumi.set(__self__, "type", type)
        if instance_redistribution_type is not None:
            pulumi.set(__self__, "instance_redistribution_type", instance_redistribution_type)
        if max_surge_fixed is not None:
            pulumi.set(__self__, "max_surge_fixed", max_surge_fixed)
        if max_surge_percent is not None:
            pulumi.set(__self__, "max_surge_percent", max_surge_percent)
        if max_unavailable_fixed is not None:
            pulumi.set(__self__, "max_unavailable_fixed", max_unavailable_fixed)
        if max_unavailable_percent is not None:
            pulumi.set(__self__, "max_unavailable_percent", max_unavailable_percent)
        if min_ready_sec is not None:
            pulumi.set(__self__, "min_ready_sec", min_ready_sec)
        if replacement_method is not None:
            pulumi.set(__self__, "replacement_method", replacement_method)

    @property
    @pulumi.getter(name="minimalAction")
    def minimal_action(self) -> str:
        """
        - Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        """
        return pulumi.get(self, "minimal_action")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="instanceRedistributionType")
    def instance_redistribution_type(self) -> Optional[str]:
        """
        - The instance redistribution policy for regional managed instance groups. Valid values are: `"PROACTIVE"`, `"NONE"`. If `PROACTIVE` (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If `NONE`, proactive redistribution is disabled.
        """
        return pulumi.get(self, "instance_redistribution_type")

    @property
    @pulumi.getter(name="maxSurgeFixed")
    def max_surge_fixed(self) -> Optional[int]:
        """
        , The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `max_surge_percent`. It has to be either 0 or at least equal to the number of zones.  If fixed values are used, at least one of `max_unavailable_fixed` or `max_surge_fixed` must be greater than 0.
        """
        return pulumi.get(self, "max_surge_fixed")

    @property
    @pulumi.getter(name="maxSurgePercent")
    def max_surge_percent(self) -> Optional[int]:
        """
        , The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `max_surge_fixed`. Percent value is only allowed for regional managed instance groups with size at least 10.
        """
        return pulumi.get(self, "max_surge_percent")

    @property
    @pulumi.getter(name="maxUnavailableFixed")
    def max_unavailable_fixed(self) -> Optional[int]:
        """
        , The maximum number of instances that can be unavailable during the update process. Conflicts with `max_unavailable_percent`. It has to be either 0 or at least equal to the number of zones. If fixed values are used, at least one of `max_unavailable_fixed` or `max_surge_fixed` must be greater than 0.
        """
        return pulumi.get(self, "max_unavailable_fixed")

    @property
    @pulumi.getter(name="maxUnavailablePercent")
    def max_unavailable_percent(self) -> Optional[int]:
        """
        , The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `max_unavailable_fixed`. Percent value is only allowed for regional managed instance groups with size at least 10.
        """
        return pulumi.get(self, "max_unavailable_percent")

    @property
    @pulumi.getter(name="minReadySec")
    def min_ready_sec(self) -> Optional[int]:
        """
        , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
        """
        return pulumi.get(self, "min_ready_sec")

    @property
    @pulumi.getter(name="replacementMethod")
    def replacement_method(self) -> Optional[str]:
        """
        , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
        - - -
        """
        return pulumi.get(self, "replacement_method")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionInstanceGroupManagerVersion(dict):
    def __init__(__self__, *,
                 instance_template: str,
                 name: Optional[str] = None,
                 target_size: Optional['outputs.RegionInstanceGroupManagerVersionTargetSize'] = None):
        """
        :param str instance_template: - The full URL to an instance template from which all new instances of this version will be created.
        :param str name: - Version name.
        :param 'RegionInstanceGroupManagerVersionTargetSizeArgs' target_size: - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
        """
        pulumi.set(__self__, "instance_template", instance_template)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_size is not None:
            pulumi.set(__self__, "target_size", target_size)

    @property
    @pulumi.getter(name="instanceTemplate")
    def instance_template(self) -> str:
        """
        - The full URL to an instance template from which all new instances of this version will be created.
        """
        return pulumi.get(self, "instance_template")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - Version name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetSize")
    def target_size(self) -> Optional['outputs.RegionInstanceGroupManagerVersionTargetSize']:
        """
        - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
        """
        return pulumi.get(self, "target_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionInstanceGroupManagerVersionTargetSize(dict):
    def __init__(__self__, *,
                 fixed: Optional[int] = None,
                 percent: Optional[int] = None):
        """
        :param int fixed: , The number of instances which are managed for this version. Conflicts with `percent`.
        :param int percent: , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
               Note that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,
               one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
        """
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def fixed(self) -> Optional[int]:
        """
        , The number of instances which are managed for this version. Conflicts with `percent`.
        """
        return pulumi.get(self, "fixed")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
        Note that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,
        one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
        """
        return pulumi.get(self, "percent")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionNetworkEndpointGroupAppEngine(dict):
    def __init__(__self__, *,
                 service: Optional[str] = None,
                 url_mask: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str service: Optional serving service.
               The service name must be 1-63 characters long, and comply with RFC1035.
               Example value: "default", "my-service".
        :param str url_mask: A template to parse function field from a request URL. URL mask allows
               for routing to multiple Cloud Functions without having to create
               multiple Network Endpoint Groups and backend services.
               For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
               can be backed by the same Serverless NEG with URL mask "/". The URL mask
               will parse them to { function = "function1" } and { function = "function2" } respectively.
        :param str version: Optional serving version.
               The version must be 1-63 characters long, and comply with RFC1035.
               Example value: "v1", "v2".
        """
        if service is not None:
            pulumi.set(__self__, "service", service)
        if url_mask is not None:
            pulumi.set(__self__, "url_mask", url_mask)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Optional serving service.
        The service name must be 1-63 characters long, and comply with RFC1035.
        Example value: "default", "my-service".
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="urlMask")
    def url_mask(self) -> Optional[str]:
        """
        A template to parse function field from a request URL. URL mask allows
        for routing to multiple Cloud Functions without having to create
        multiple Network Endpoint Groups and backend services.
        For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
        can be backed by the same Serverless NEG with URL mask "/". The URL mask
        will parse them to { function = "function1" } and { function = "function2" } respectively.
        """
        return pulumi.get(self, "url_mask")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Optional serving version.
        The version must be 1-63 characters long, and comply with RFC1035.
        Example value: "v1", "v2".
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionNetworkEndpointGroupCloudFunction(dict):
    def __init__(__self__, *,
                 function: Optional[str] = None,
                 url_mask: Optional[str] = None):
        """
        :param str function: A user-defined name of the Cloud Function.
               The function name is case-sensitive and must be 1-63 characters long.
               Example value: "func1".
        :param str url_mask: A template to parse function field from a request URL. URL mask allows
               for routing to multiple Cloud Functions without having to create
               multiple Network Endpoint Groups and backend services.
               For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
               can be backed by the same Serverless NEG with URL mask "/". The URL mask
               will parse them to { function = "function1" } and { function = "function2" } respectively.
        """
        if function is not None:
            pulumi.set(__self__, "function", function)
        if url_mask is not None:
            pulumi.set(__self__, "url_mask", url_mask)

    @property
    @pulumi.getter
    def function(self) -> Optional[str]:
        """
        A user-defined name of the Cloud Function.
        The function name is case-sensitive and must be 1-63 characters long.
        Example value: "func1".
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter(name="urlMask")
    def url_mask(self) -> Optional[str]:
        """
        A template to parse function field from a request URL. URL mask allows
        for routing to multiple Cloud Functions without having to create
        multiple Network Endpoint Groups and backend services.
        For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
        can be backed by the same Serverless NEG with URL mask "/". The URL mask
        will parse them to { function = "function1" } and { function = "function2" } respectively.
        """
        return pulumi.get(self, "url_mask")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionNetworkEndpointGroupCloudRun(dict):
    def __init__(__self__, *,
                 service: Optional[str] = None,
                 tag: Optional[str] = None,
                 url_mask: Optional[str] = None):
        """
        :param str service: Optional serving service.
               The service name must be 1-63 characters long, and comply with RFC1035.
               Example value: "default", "my-service".
        :param str tag: Cloud Run tag represents the "named-revision" to provide
               additional fine-grained traffic routing information.
               The tag must be 1-63 characters long, and comply with RFC1035.
               Example value: "revision-0010".
        :param str url_mask: A template to parse function field from a request URL. URL mask allows
               for routing to multiple Cloud Functions without having to create
               multiple Network Endpoint Groups and backend services.
               For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
               can be backed by the same Serverless NEG with URL mask "/". The URL mask
               will parse them to { function = "function1" } and { function = "function2" } respectively.
        """
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if url_mask is not None:
            pulumi.set(__self__, "url_mask", url_mask)

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Optional serving service.
        The service name must be 1-63 characters long, and comply with RFC1035.
        Example value: "default", "my-service".
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Cloud Run tag represents the "named-revision" to provide
        additional fine-grained traffic routing information.
        The tag must be 1-63 characters long, and comply with RFC1035.
        Example value: "revision-0010".
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="urlMask")
    def url_mask(self) -> Optional[str]:
        """
        A template to parse function field from a request URL. URL mask allows
        for routing to multiple Cloud Functions without having to create
        multiple Network Endpoint Groups and backend services.
        For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
        can be backed by the same Serverless NEG with URL mask "/". The URL mask
        will parse them to { function = "function1" } and { function = "function2" } respectively.
        """
        return pulumi.get(self, "url_mask")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionPerInstanceConfigPreservedState(dict):
    def __init__(__self__, *,
                 disks: Optional[Sequence['outputs.RegionPerInstanceConfigPreservedStateDisk']] = None,
                 metadata: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['RegionPerInstanceConfigPreservedStateDiskArgs'] disks: Stateful disks for the instance.
               Structure is documented below.
        :param Mapping[str, str] metadata: Preserved metadata defined for this instance. This is a list of key->value pairs.
        """
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def disks(self) -> Optional[Sequence['outputs.RegionPerInstanceConfigPreservedStateDisk']]:
        """
        Stateful disks for the instance.
        Structure is documented below.
        """
        return pulumi.get(self, "disks")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, str]]:
        """
        Preserved metadata defined for this instance. This is a list of key->value pairs.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionPerInstanceConfigPreservedStateDisk(dict):
    def __init__(__self__, *,
                 device_name: str,
                 source: str,
                 delete_rule: Optional[str] = None,
                 mode: Optional[str] = None):
        """
        :param str device_name: A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
        :param str source: The URI of an existing persistent disk to attach under the specified device-name in the format
               `projects/project-id/zones/zone/disks/disk-name`.
        :param str delete_rule: A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
               The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
               `NEVER` - detach the disk when the VM is deleted, but do not delete the disk.
               `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
               deleted from the instance group.
               Default value is `NEVER`.
               Possible values are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
        :param str mode: The mode of the disk.
               Default value is `READ_WRITE`.
               Possible values are `READ_ONLY` and `READ_WRITE`.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "source", source)
        if delete_rule is not None:
            pulumi.set(__self__, "delete_rule", delete_rule)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The URI of an existing persistent disk to attach under the specified device-name in the format
        `projects/project-id/zones/zone/disks/disk-name`.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[str]:
        """
        A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
        The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
        `NEVER` - detach the disk when the VM is deleted, but do not delete the disk.
        `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
        deleted from the instance group.
        Default value is `NEVER`.
        Possible values are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
        """
        return pulumi.get(self, "delete_rule")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The mode of the disk.
        Default value is `READ_WRITE`.
        Possible values are `READ_ONLY` and `READ_WRITE`.
        """
        return pulumi.get(self, "mode")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapDefaultUrlRedirect(dict):
    def __init__(__self__, *,
                 strip_query: bool,
                 host_redirect: Optional[str] = None,
                 https_redirect: Optional[bool] = None,
                 path_redirect: Optional[str] = None,
                 prefix_redirect: Optional[str] = None,
                 redirect_response_code: Optional[str] = None):
        """
        :param bool strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param str host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param bool https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param str path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param str prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        pulumi.set(__self__, "strip_query", strip_query)
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        return pulumi.get(self, "strip_query")

    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_redirect")

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        return pulumi.get(self, "https_redirect")

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        return pulumi.get(self, "path_redirect")

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "prefix_redirect")

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapHostRule(dict):
    def __init__(__self__, *,
                 hosts: Sequence[str],
                 path_matcher: str,
                 description: Optional[str] = None):
        """
        :param Sequence[str] hosts: The list of host patterns to match. They must be valid
               hostnames, except * will match any string of ([a-z0-9-.]*). In
               that case, * must be the first character and must be followed in
               the pattern by either - or ..
        :param str path_matcher: The name of the PathMatcher to use to match the path portion of
               the URL if the hostRule matches the URL's host portion.
        :param str description: Description of this test case.
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "path_matcher", path_matcher)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def hosts(self) -> Sequence[str]:
        """
        The list of host patterns to match. They must be valid
        hostnames, except * will match any string of ([a-z0-9-.]*). In
        that case, * must be the first character and must be followed in
        the pattern by either - or ..
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter(name="pathMatcher")
    def path_matcher(self) -> str:
        """
        The name of the PathMatcher to use to match the path portion of
        the URL if the hostRule matches the URL's host portion.
        """
        return pulumi.get(self, "path_matcher")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this test case.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcher(dict):
    def __init__(__self__, *,
                 name: str,
                 default_service: Optional[str] = None,
                 default_url_redirect: Optional['outputs.RegionUrlMapPathMatcherDefaultUrlRedirect'] = None,
                 description: Optional[str] = None,
                 path_rules: Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRule']] = None,
                 route_rules: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRule']] = None):
        """
        :param str name: The name of the query parameter to match. The query parameter must exist in the
               request, in the absence of which the request match fails.
        :param str default_service: A reference to a RegionBackendService resource. This will be used if
               none of the pathRules defined by this PathMatcher is matched by
               the URL's path portion.
        :param 'RegionUrlMapPathMatcherDefaultUrlRedirectArgs' default_url_redirect: When none of the specified hostRules match, the request is redirected to a URL specified
               by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
               defaultRouteAction must not be set.
               Structure is documented below.
        :param str description: Description of this test case.
        :param Sequence['RegionUrlMapPathMatcherPathRuleArgs'] path_rules: The list of path rules. Use this list instead of routeRules when routing based
               on simple path matching is all that's required. The order by which path rules
               are specified does not matter. Matches are always done on the longest-path-first
               basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
               irrespective of the order in which those paths appear in this list. Within a
               given pathMatcher, only one of pathRules or routeRules must be set.
               Structure is documented below.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleArgs'] route_rules: The list of ordered HTTP route rules. Use this list instead of pathRules when
               advanced route matching and routing actions are desired. The order of specifying
               routeRules matters: the first rule that matches will cause its specified routing
               action to take effect. Within a given pathMatcher, only one of pathRules or
               routeRules must be set. routeRules are not supported in UrlMaps intended for
               External load balancers.
               Structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        if default_service is not None:
            pulumi.set(__self__, "default_service", default_service)
        if default_url_redirect is not None:
            pulumi.set(__self__, "default_url_redirect", default_url_redirect)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if path_rules is not None:
            pulumi.set(__self__, "path_rules", path_rules)
        if route_rules is not None:
            pulumi.set(__self__, "route_rules", route_rules)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query parameter to match. The query parameter must exist in the
        request, in the absence of which the request match fails.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="defaultService")
    def default_service(self) -> Optional[str]:
        """
        A reference to a RegionBackendService resource. This will be used if
        none of the pathRules defined by this PathMatcher is matched by
        the URL's path portion.
        """
        return pulumi.get(self, "default_service")

    @property
    @pulumi.getter(name="defaultUrlRedirect")
    def default_url_redirect(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultUrlRedirect']:
        """
        When none of the specified hostRules match, the request is redirected to a URL specified
        by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
        defaultRouteAction must not be set.
        Structure is documented below.
        """
        return pulumi.get(self, "default_url_redirect")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this test case.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="pathRules")
    def path_rules(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRule']]:
        """
        The list of path rules. Use this list instead of routeRules when routing based
        on simple path matching is all that's required. The order by which path rules
        are specified does not matter. Matches are always done on the longest-path-first
        basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
        irrespective of the order in which those paths appear in this list. Within a
        given pathMatcher, only one of pathRules or routeRules must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "path_rules")

    @property
    @pulumi.getter(name="routeRules")
    def route_rules(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRule']]:
        """
        The list of ordered HTTP route rules. Use this list instead of pathRules when
        advanced route matching and routing actions are desired. The order of specifying
        routeRules matters: the first rule that matches will cause its specified routing
        action to take effect. Within a given pathMatcher, only one of pathRules or
        routeRules must be set. routeRules are not supported in UrlMaps intended for
        External load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "route_rules")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultUrlRedirect(dict):
    def __init__(__self__, *,
                 strip_query: bool,
                 host_redirect: Optional[str] = None,
                 https_redirect: Optional[bool] = None,
                 path_redirect: Optional[str] = None,
                 prefix_redirect: Optional[str] = None,
                 redirect_response_code: Optional[str] = None):
        """
        :param bool strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param str host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param bool https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param str path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param str prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        pulumi.set(__self__, "strip_query", strip_query)
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        return pulumi.get(self, "strip_query")

    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_redirect")

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        return pulumi.get(self, "https_redirect")

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        return pulumi.get(self, "path_redirect")

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "prefix_redirect")

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRule(dict):
    def __init__(__self__, *,
                 paths: Sequence[str],
                 route_action: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteAction'] = None,
                 service: Optional[str] = None,
                 url_redirect: Optional['outputs.RegionUrlMapPathMatcherPathRuleUrlRedirect'] = None):
        """
        :param Sequence[str] paths: The list of path patterns to match. Each must start with / and the only place a
               * is allowed is at the end following a /. The string fed to the path matcher
               does not include any text after the first ? or #, and those chars are not
               allowed here.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionArgs' route_action: In response to a matching path, the load balancer performs advanced routing
               actions like URL rewrites, header transformations, etc. prior to forwarding the
               request to the selected backend. If routeAction specifies any
               weightedBackendServices, service must not be set. Conversely if service is set,
               routeAction cannot contain any  weightedBackendServices. Only one of routeAction
               or urlRedirect must be set.
               Structure is documented below.
        :param str service: A reference to expected RegionBackendService resource the given URL should be mapped to.
        :param 'RegionUrlMapPathMatcherPathRuleUrlRedirectArgs' url_redirect: When a path pattern is matched, the request is redirected to a URL specified
               by urlRedirect. If urlRedirect is specified, service or routeAction must not
               be set.
               Structure is documented below.
        """
        pulumi.set(__self__, "paths", paths)
        if route_action is not None:
            pulumi.set(__self__, "route_action", route_action)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if url_redirect is not None:
            pulumi.set(__self__, "url_redirect", url_redirect)

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        The list of path patterns to match. Each must start with / and the only place a
        * is allowed is at the end following a /. The string fed to the path matcher
        does not include any text after the first ? or #, and those chars are not
        allowed here.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="routeAction")
    def route_action(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteAction']:
        """
        In response to a matching path, the load balancer performs advanced routing
        actions like URL rewrites, header transformations, etc. prior to forwarding the
        request to the selected backend. If routeAction specifies any
        weightedBackendServices, service must not be set. Conversely if service is set,
        routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        or urlRedirect must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "route_action")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        A reference to expected RegionBackendService resource the given URL should be mapped to.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="urlRedirect")
    def url_redirect(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleUrlRedirect']:
        """
        When a path pattern is matched, the request is redirected to a URL specified
        by urlRedirect. If urlRedirect is specified, service or routeAction must not
        be set.
        Structure is documented below.
        """
        return pulumi.get(self, "url_redirect")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteAction(dict):
    def __init__(__self__, *,
                 cors_policy: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy'] = None,
                 fault_injection_policy: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy'] = None,
                 request_mirror_policy: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy'] = None,
                 retry_policy: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy'] = None,
                 timeout: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionTimeout'] = None,
                 url_rewrite: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite'] = None,
                 weighted_backend_services: Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService']] = None):
        """
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicyArgs' cors_policy: The specification for allowing client side cross-origin requests. Please see W3C
               Recommendation for Cross Origin Resource Sharing
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyArgs' fault_injection_policy: The specification for fault injection introduced into traffic to test the
               resiliency of clients to backend service failure. As part of fault injection,
               when clients send requests to a backend service, delays can be introduced by
               Loadbalancer on a percentage of requests before sending those request to the
               backend service. Similarly requests from clients can be aborted by the
               Loadbalancer for a percentage of requests. timeout and retry_policy will be
               ignored by clients that are configured with a fault_injection_policy.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicyArgs' request_mirror_policy: Specifies the policy on how requests intended for the route's backends are
               shadowed to a separate mirrored backend service. Loadbalancer does not wait for
               responses from the shadow service. Prior to sending traffic to the shadow
               service, the host / authority header is suffixed with -shadow.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyArgs' retry_policy: Specifies the retry policy associated with this route.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionTimeoutArgs' timeout: Specifies the timeout for the selected route. Timeout is computed from the time
               the request is has been fully processed (i.e. end-of-stream) up until the
               response has been completely processed. Timeout includes all retries. If not
               specified, the default value is 15 seconds.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionUrlRewriteArgs' url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to
               the matched service
               Structure is documented below.
        :param Sequence['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceArgs'] weighted_backend_services: A list of weighted backend services to send traffic to when a route match
               occurs. The weights determine the fraction of traffic that flows to their
               corresponding backend service. If all traffic needs to go to a single backend
               service, there must be one  weightedBackendService with weight set to a non 0
               number. Once a backendService is identified and before forwarding the request to
               the backend service, advanced routing actions like Url rewrites and header
               transformations are applied depending on additional settings specified in this
               HttpRouteAction.
               Structure is documented below.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if fault_injection_policy is not None:
            pulumi.set(__self__, "fault_injection_policy", fault_injection_policy)
        if request_mirror_policy is not None:
            pulumi.set(__self__, "request_mirror_policy", request_mirror_policy)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)
        if weighted_backend_services is not None:
            pulumi.set(__self__, "weighted_backend_services", weighted_backend_services)

    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see W3C
        Recommendation for Cross Origin Resource Sharing
        Structure is documented below.
        """
        return pulumi.get(self, "cors_policy")

    @property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the
        resiliency of clients to backend service failure. As part of fault injection,
        when clients send requests to a backend service, delays can be introduced by
        Loadbalancer on a percentage of requests before sending those request to the
        backend service. Similarly requests from clients can be aborted by the
        Loadbalancer for a percentage of requests. timeout and retry_policy will be
        ignored by clients that are configured with a fault_injection_policy.
        Structure is documented below.
        """
        return pulumi.get(self, "fault_injection_policy")

    @property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are
        shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        responses from the shadow service. Prior to sending traffic to the shadow
        service, the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        return pulumi.get(self, "request_mirror_policy")

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        return pulumi.get(self, "retry_policy")

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time
        the request is has been fully processed (i.e. end-of-stream) up until the
        response has been completely processed. Timeout includes all retries. If not
        specified, the default value is 15 seconds.
        Structure is documented below.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to
        the matched service
        Structure is documented below.
        """
        return pulumi.get(self, "url_rewrite")

    @property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match
        occurs. The weights determine the fraction of traffic that flows to their
        corresponding backend service. If all traffic needs to go to a single backend
        service, there must be one  weightedBackendService with weight set to a non 0
        number. Once a backendService is identified and before forwarding the request to
        the backend service, advanced routing actions like Url rewrites and header
        transformations are applied depending on additional settings specified in this
        HttpRouteAction.
        Structure is documented below.
        """
        return pulumi.get(self, "weighted_backend_services")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy(dict):
    def __init__(__self__, *,
                 disabled: bool,
                 allow_credentials: Optional[bool] = None,
                 allow_headers: Optional[Sequence[str]] = None,
                 allow_methods: Optional[Sequence[str]] = None,
                 allow_origin_regexes: Optional[Sequence[str]] = None,
                 allow_origins: Optional[Sequence[str]] = None,
                 expose_headers: Optional[Sequence[str]] = None,
                 max_age: Optional[int] = None):
        """
        :param bool disabled: If true, specifies the CORS policy is disabled.
        :param bool allow_credentials: In response to a preflight request, setting this to true indicates that the
               actual request can include user credentials. This translates to the Access-
               Control-Allow-Credentials header. Defaults to false.
        :param Sequence[str] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param Sequence[str] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param Sequence[str] allow_origin_regexes: Specifies the regular expression patterns that match allowed origins. For
               regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either allow_origins or allow_origin_regex.
        :param Sequence[str] allow_origins: Specifies the list of origins that will be allowed to do CORS requests. An
               origin is allowed if it matches either allow_origins or allow_origin_regex.
        :param Sequence[str] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param int max_age: Specifies how long the results of a preflight request can be cached. This
               translates to the content for the Access-Control-Max-Age header.
        """
        pulumi.set(__self__, "disabled", disabled)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin_regexes is not None:
            pulumi.set(__self__, "allow_origin_regexes", allow_origin_regexes)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        If true, specifies the CORS policy is disabled.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        In response to a preflight request, setting this to true indicates that the
        actual request can include user credentials. This translates to the Access-
        Control-Allow-Credentials header. Defaults to false.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[Sequence[str]]:
        """
        Specifies the regular expression patterns that match allowed origins. For
        regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either allow_origins or allow_origin_regex.
        """
        return pulumi.get(self, "allow_origin_regexes")

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests. An
        origin is allowed if it matches either allow_origins or allow_origin_regex.
        """
        return pulumi.get(self, "allow_origins")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        Specifies how long the results of a preflight request can be cached. This
        translates to the content for the Access-Control-Max-Age header.
        """
        return pulumi.get(self, "max_age")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy(dict):
    def __init__(__self__, *,
                 abort: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort'] = None,
                 delay: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay'] = None):
        """
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortArgs' abort: The specification for how client requests are aborted as part of fault
               injection.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayArgs' delay: The specification for how client requests are delayed as part of fault
               injection, before being sent to a backend service.
               Structure is documented below.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @property
    @pulumi.getter
    def abort(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault
        injection.
        Structure is documented below.
        """
        return pulumi.get(self, "abort")

    @property
    @pulumi.getter
    def delay(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault
        injection, before being sent to a backend service.
        Structure is documented below.
        """
        return pulumi.get(self, "delay")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort(dict):
    def __init__(__self__, *,
                 http_status: int,
                 percentage: float):
        """
        :param int http_status: The HTTP status code used to abort the request. The value must be between 200
               and 599 inclusive.
        :param float percentage: The percentage of traffic (connections/operations/requests) on which delay will
               be introduced as part of fault injection. The value must be between 0.0 and
               100.0 inclusive.
        """
        pulumi.set(__self__, "http_status", http_status)
        pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> int:
        """
        The HTTP status code used to abort the request. The value must be between 200
        and 599 inclusive.
        """
        return pulumi.get(self, "http_status")

    @property
    @pulumi.getter
    def percentage(self) -> float:
        """
        The percentage of traffic (connections/operations/requests) on which delay will
        be introduced as part of fault injection. The value must be between 0.0 and
        100.0 inclusive.
        """
        return pulumi.get(self, "percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay(dict):
    def __init__(__self__, *,
                 fixed_delay: 'outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
                 percentage: float):
        """
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs' fixed_delay: Specifies the value of the fixed delay interval.
               Structure is documented below.
        :param float percentage: The percentage of traffic (connections/operations/requests) on which delay will
               be introduced as part of fault injection. The value must be between 0.0 and
               100.0 inclusive.
        """
        pulumi.set(__self__, "fixed_delay", fixed_delay)
        pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> 'outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay':
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_delay")

    @property
    @pulumi.getter
    def percentage(self) -> float:
        """
        The percentage of traffic (connections/operations/requests) on which delay will
        be introduced as part of fault injection. The value must be between 0.0 and
        100.0 inclusive.
        """
        return pulumi.get(self, "percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    def __init__(__self__, *,
                 seconds: str,
                 nanos: Optional[int] = None):
        """
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy(dict):
    def __init__(__self__, *,
                 backend_service: str):
        """
        :param str backend_service: The default RegionBackendService resource. Before
               forwarding the request to backendService, the loadbalancer applies any relevant
               headerActions specified as part of this backendServiceWeight.
        """
        pulumi.set(__self__, "backend_service", backend_service)

    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The default RegionBackendService resource. Before
        forwarding the request to backendService, the loadbalancer applies any relevant
        headerActions specified as part of this backendServiceWeight.
        """
        return pulumi.get(self, "backend_service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy(dict):
    def __init__(__self__, *,
                 num_retries: Optional[int] = None,
                 per_try_timeout: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout'] = None,
                 retry_conditions: Optional[Sequence[str]] = None):
        """
        :param int num_retries: Specifies the allowed number retries. This number must be > 0.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutArgs' per_try_timeout: Specifies a non-zero timeout per retry attempt.
               Structure is documented below.
        :param Sequence[str] retry_conditions: Specifies one or more conditions when this retry rule applies. Valid values are:
               - 5xx: Loadbalancer will attempt a retry if the backend service responds with
               any 5xx response code, or if the backend service does not respond at all,
               example: disconnects, reset, read timeout, connection failure, and refused
               streams.
               - gateway-error: Similar to 5xx, but only applies to response codes
               502, 503 or 504.
               - connect-failure: Loadbalancer will retry on failures
               connecting to backend services, for example due to connection timeouts.
               - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
               REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
               - cancelled: Loadbalancer will retry if the gRPC status code in the response
               header is set to cancelled
               - deadline-exceeded: Loadbalancer will retry if the
               gRPC status code in the response header is set to deadline-exceeded
               - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
               header is set to resource-exhausted
               - unavailable: Loadbalancer will retry if
               the gRPC status code in the response header is set to unavailable
        """
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_conditions is not None:
            pulumi.set(__self__, "retry_conditions", retry_conditions)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        """
        Specifies the allowed number retries. This number must be > 0.
        """
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        Structure is documented below.
        """
        return pulumi.get(self, "per_try_timeout")

    @property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[Sequence[str]]:
        """
        Specifies one or more conditions when this retry rule applies. Valid values are:
        - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        any 5xx response code, or if the backend service does not respond at all,
        example: disconnects, reset, read timeout, connection failure, and refused
        streams.
        - gateway-error: Similar to 5xx, but only applies to response codes
        502, 503 or 504.
        - connect-failure: Loadbalancer will retry on failures
        connecting to backend services, for example due to connection timeouts.
        - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        - cancelled: Loadbalancer will retry if the gRPC status code in the response
        header is set to cancelled
        - deadline-exceeded: Loadbalancer will retry if the
        gRPC status code in the response header is set to deadline-exceeded
        - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        header is set to resource-exhausted
        - unavailable: Loadbalancer will retry if
        the gRPC status code in the response header is set to unavailable
        """
        return pulumi.get(self, "retry_conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout(dict):
    def __init__(__self__, *,
                 seconds: str,
                 nanos: Optional[int] = None):
        """
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionTimeout(dict):
    def __init__(__self__, *,
                 seconds: str,
                 nanos: Optional[int] = None):
        """
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite(dict):
    def __init__(__self__, *,
                 host_rewrite: Optional[str] = None,
                 path_prefix_rewrite: Optional[str] = None):
        """
        :param str host_rewrite: Prior to forwarding the request to the selected service, the request's host
               header is replaced with contents of hostRewrite. The value must be between 1 and
               255 characters.
        :param str path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching
               portion of the request's path is replaced by pathPrefixRewrite. The value must
               be between 1 and 1024 characters.
        """
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if path_prefix_rewrite is not None:
            pulumi.set(__self__, "path_prefix_rewrite", path_prefix_rewrite)

    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected service, the request's host
        header is replaced with contents of hostRewrite. The value must be between 1 and
        255 characters.
        """
        return pulumi.get(self, "host_rewrite")

    @property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected backend service, the matching
        portion of the request's path is replaced by pathPrefixRewrite. The value must
        be between 1 and 1024 characters.
        """
        return pulumi.get(self, "path_prefix_rewrite")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService(dict):
    def __init__(__self__, *,
                 backend_service: str,
                 weight: int,
                 header_action: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction'] = None):
        """
        :param str backend_service: The default RegionBackendService resource. Before
               forwarding the request to backendService, the loadbalancer applies any relevant
               headerActions specified as part of this backendServiceWeight.
        :param int weight: Specifies the fraction of traffic sent to backendService, computed as weight /
               (sum of all weightedBackendService weights in routeAction) . The selection of a
               backend service is determined only for new traffic. Once a user's request has
               been directed to a backendService, subsequent requests will be sent to the same
               backendService as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService. headerAction specified here take effect before
               headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
               Structure is documented below.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        pulumi.set(__self__, "weight", weight)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)

    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The default RegionBackendService resource. Before
        forwarding the request to backendService, the loadbalancer applies any relevant
        headerActions specified as part of this backendServiceWeight.
        """
        return pulumi.get(self, "backend_service")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Specifies the fraction of traffic sent to backendService, computed as weight /
        (sum of all weightedBackendService weights in routeAction) . The selection of a
        backend service is determined only for new traffic. Once a user's request has
        been directed to a backendService, subsequent requests will be sent to the same
        backendService as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService. headerAction specified here take effect before
        headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction(dict):
    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[str]] = None):
        """
        :param Sequence['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the
               backendService.
               Structure is documented below.
        :param Sequence[str] request_headers_to_removes: A list of header names for headers that need to be removed from the request
               prior to forwarding the request to the backendService.
        :param Sequence['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[str] response_headers_to_removes: A list of header names for headers that need to be removed from the response
               prior to sending the response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the
        backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the request
        prior to forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the response
        prior to sending the response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the
               header. If true, headerValue is set for the header, discarding any values that
               were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the
        header. If true, headerValue is set for the header, discarding any values that
        were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the
               header. If true, headerValue is set for the header, discarding any values that
               were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the
        header. If true, headerValue is set for the header, discarding any values that
        were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleUrlRedirect(dict):
    def __init__(__self__, *,
                 strip_query: bool,
                 host_redirect: Optional[str] = None,
                 https_redirect: Optional[bool] = None,
                 path_redirect: Optional[str] = None,
                 prefix_redirect: Optional[str] = None,
                 redirect_response_code: Optional[str] = None):
        """
        :param bool strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param str host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param bool https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param str path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param str prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        pulumi.set(__self__, "strip_query", strip_query)
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        return pulumi.get(self, "strip_query")

    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_redirect")

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        return pulumi.get(self, "https_redirect")

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        return pulumi.get(self, "path_redirect")

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "prefix_redirect")

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRule(dict):
    def __init__(__self__, *,
                 priority: int,
                 header_action: Optional['outputs.RegionUrlMapPathMatcherRouteRuleHeaderAction'] = None,
                 match_rules: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRule']] = None,
                 route_action: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteAction'] = None,
                 service: Optional[str] = None,
                 url_redirect: Optional['outputs.RegionUrlMapPathMatcherRouteRuleUrlRedirect'] = None):
        """
        :param int priority: For routeRules within a given pathMatcher, priority determines the order
               in which load balancer will interpret routeRules. RouteRules are evaluated
               in order of priority, from the lowest to highest number. The priority of
               a rule decreases as its number increases (1, 2, 3, N+1). The first rule
               that matches the request is applied.
               You cannot configure two or more routeRules with the same priority.
               Priority for each rule must be set to a number between 0 and
               2147483647 inclusive.
               Priority numbers can have gaps, which enable you to add or remove rules
               in the future without affecting the rest of the rules. For example,
               1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
               you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
               future without any impact on existing rules.
        :param 'RegionUrlMapPathMatcherRouteRuleHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService. headerAction specified here take effect before
               headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
               Structure is documented below.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleMatchRuleArgs'] match_rules: The rules for determining a match.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionArgs' route_action: In response to a matching path, the load balancer performs advanced routing
               actions like URL rewrites, header transformations, etc. prior to forwarding the
               request to the selected backend. If routeAction specifies any
               weightedBackendServices, service must not be set. Conversely if service is set,
               routeAction cannot contain any  weightedBackendServices. Only one of routeAction
               or urlRedirect must be set.
               Structure is documented below.
        :param str service: A reference to expected RegionBackendService resource the given URL should be mapped to.
        :param 'RegionUrlMapPathMatcherRouteRuleUrlRedirectArgs' url_redirect: When a path pattern is matched, the request is redirected to a URL specified
               by urlRedirect. If urlRedirect is specified, service or routeAction must not
               be set.
               Structure is documented below.
        """
        pulumi.set(__self__, "priority", priority)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)
        if match_rules is not None:
            pulumi.set(__self__, "match_rules", match_rules)
        if route_action is not None:
            pulumi.set(__self__, "route_action", route_action)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if url_redirect is not None:
            pulumi.set(__self__, "url_redirect", url_redirect)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        For routeRules within a given pathMatcher, priority determines the order
        in which load balancer will interpret routeRules. RouteRules are evaluated
        in order of priority, from the lowest to highest number. The priority of
        a rule decreases as its number increases (1, 2, 3, N+1). The first rule
        that matches the request is applied.
        You cannot configure two or more routeRules with the same priority.
        Priority for each rule must be set to a number between 0 and
        2147483647 inclusive.
        Priority numbers can have gaps, which enable you to add or remove rules
        in the future without affecting the rest of the rules. For example,
        1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
        you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
        future without any impact on existing rules.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService. headerAction specified here take effect before
        headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRule']]:
        """
        The rules for determining a match.
        Structure is documented below.
        """
        return pulumi.get(self, "match_rules")

    @property
    @pulumi.getter(name="routeAction")
    def route_action(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteAction']:
        """
        In response to a matching path, the load balancer performs advanced routing
        actions like URL rewrites, header transformations, etc. prior to forwarding the
        request to the selected backend. If routeAction specifies any
        weightedBackendServices, service must not be set. Conversely if service is set,
        routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        or urlRedirect must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "route_action")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        A reference to expected RegionBackendService resource the given URL should be mapped to.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="urlRedirect")
    def url_redirect(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleUrlRedirect']:
        """
        When a path pattern is matched, the request is redirected to a URL specified
        by urlRedirect. If urlRedirect is specified, service or routeAction must not
        be set.
        Structure is documented below.
        """
        return pulumi.get(self, "url_redirect")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleHeaderAction(dict):
    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[str]] = None):
        """
        :param Sequence['RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the
               backendService.
               Structure is documented below.
        :param Sequence[str] request_headers_to_removes: A list of header names for headers that need to be removed from the request
               prior to forwarding the request to the backendService.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[str] response_headers_to_removes: A list of header names for headers that need to be removed from the response
               prior to sending the response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the
        backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the request
        prior to forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the response
        prior to sending the response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the
               header. If true, headerValue is set for the header, discarding any values that
               were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the
        header. If true, headerValue is set for the header, discarding any values that
        were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the
               header. If true, headerValue is set for the header, discarding any values that
               were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the
        header. If true, headerValue is set for the header, discarding any values that
        were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRule(dict):
    def __init__(__self__, *,
                 full_path_match: Optional[str] = None,
                 header_matches: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch']] = None,
                 ignore_case: Optional[bool] = None,
                 metadata_filters: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter']] = None,
                 prefix_match: Optional[str] = None,
                 query_parameter_matches: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch']] = None,
                 regex_match: Optional[str] = None):
        """
        :param str full_path_match: For satisfying the matchRule condition, the path of the request must exactly
               match the value specified in fullPathMatch after removing any query parameters
               and anchor that may be part of the original URL. FullPathMatch must be between 1
               and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
               be specified.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs'] header_matches: Specifies a list of header match criteria, all of which must match corresponding
               headers in the request.
               Structure is documented below.
        :param bool ignore_case: Specifies that prefixMatch and fullPathMatch matches are case sensitive.
               Defaults to false.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterArgs'] metadata_filters: Opaque filter criteria used by Loadbalancer to restrict routing configuration to
               a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
               clients present node metadata. If a match takes place, the relevant routing
               configuration is made available to those proxies. For each metadataFilter in
               this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
               filterLabels must match the corresponding label provided in the metadata. If its
               filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
               with corresponding labels in the provided metadata. metadataFilters specified
               here can be overrides those specified in ForwardingRule that refers to this
               UrlMap. metadataFilters only applies to Loadbalancers that have their
               loadBalancingScheme set to INTERNAL_SELF_MANAGED.
               Structure is documented below.
        :param str prefix_match: The value of the header must start with the contents of prefixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs'] query_parameter_matches: Specifies a list of query parameter match criteria, all of which must match
               corresponding query parameters in the request.
               Structure is documented below.
        :param str regex_match: The queryParameterMatch matches if the value of the parameter matches the
               regular expression specified by regexMatch. For the regular expression grammar,
               please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
               exactMatch and regexMatch must be set.
        """
        if full_path_match is not None:
            pulumi.set(__self__, "full_path_match", full_path_match)
        if header_matches is not None:
            pulumi.set(__self__, "header_matches", header_matches)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if metadata_filters is not None:
            pulumi.set(__self__, "metadata_filters", metadata_filters)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if query_parameter_matches is not None:
            pulumi.set(__self__, "query_parameter_matches", query_parameter_matches)
        if regex_match is not None:
            pulumi.set(__self__, "regex_match", regex_match)

    @property
    @pulumi.getter(name="fullPathMatch")
    def full_path_match(self) -> Optional[str]:
        """
        For satisfying the matchRule condition, the path of the request must exactly
        match the value specified in fullPathMatch after removing any query parameters
        and anchor that may be part of the original URL. FullPathMatch must be between 1
        and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
        be specified.
        """
        return pulumi.get(self, "full_path_match")

    @property
    @pulumi.getter(name="headerMatches")
    def header_matches(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch']]:
        """
        Specifies a list of header match criteria, all of which must match corresponding
        headers in the request.
        Structure is documented below.
        """
        return pulumi.get(self, "header_matches")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Specifies that prefixMatch and fullPathMatch matches are case sensitive.
        Defaults to false.
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="metadataFilters")
    def metadata_filters(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter']]:
        """
        Opaque filter criteria used by Loadbalancer to restrict routing configuration to
        a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
        clients present node metadata. If a match takes place, the relevant routing
        configuration is made available to those proxies. For each metadataFilter in
        this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
        filterLabels must match the corresponding label provided in the metadata. If its
        filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
        with corresponding labels in the provided metadata. metadataFilters specified
        here can be overrides those specified in ForwardingRule that refers to this
        UrlMap. metadataFilters only applies to Loadbalancers that have their
        loadBalancingScheme set to INTERNAL_SELF_MANAGED.
        Structure is documented below.
        """
        return pulumi.get(self, "metadata_filters")

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[str]:
        """
        The value of the header must start with the contents of prefixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        return pulumi.get(self, "prefix_match")

    @property
    @pulumi.getter(name="queryParameterMatches")
    def query_parameter_matches(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch']]:
        """
        Specifies a list of query parameter match criteria, all of which must match
        corresponding query parameters in the request.
        Structure is documented below.
        """
        return pulumi.get(self, "query_parameter_matches")

    @property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter matches the
        regular expression specified by regexMatch. For the regular expression grammar,
        please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        exactMatch and regexMatch must be set.
        """
        return pulumi.get(self, "regex_match")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch(dict):
    def __init__(__self__, *,
                 header_name: str,
                 exact_match: Optional[str] = None,
                 invert_match: Optional[bool] = None,
                 prefix_match: Optional[str] = None,
                 present_match: Optional[bool] = None,
                 range_match: Optional['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch'] = None,
                 regex_match: Optional[str] = None,
                 suffix_match: Optional[str] = None):
        """
        :param str header_name: The name of the header.
        :param str exact_match: The queryParameterMatch matches if the value of the parameter exactly matches
               the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
               must be set.
        :param bool invert_match: If set to false, the headerMatch is considered a match if the match criteria
               above are met. If set to true, the headerMatch is considered a match if the
               match criteria above are NOT met. Defaults to false.
        :param str prefix_match: The value of the header must start with the contents of prefixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        :param bool present_match: Specifies that the queryParameterMatch matches if the request contains the query
               parameter, irrespective of whether the parameter has a value or not. Only one of
               presentMatch, exactMatch and regexMatch must be set.
        :param 'RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatchArgs' range_match: The header value must be an integer and its value must be in the range specified
               in rangeMatch. If the header does not contain an integer, number or is empty,
               the match fails. For example for a range [-5, 0]
               * -3 will match
               * 0 will not match
               * 0.25 will not match
               * -3someString will not match.
               Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
               rangeMatch must be set.
               Structure is documented below.
        :param str regex_match: The queryParameterMatch matches if the value of the parameter matches the
               regular expression specified by regexMatch. For the regular expression grammar,
               please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
               exactMatch and regexMatch must be set.
        :param str suffix_match: The value of the header must end with the contents of suffixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        """
        pulumi.set(__self__, "header_name", header_name)
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if invert_match is not None:
            pulumi.set(__self__, "invert_match", invert_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if present_match is not None:
            pulumi.set(__self__, "present_match", present_match)
        if range_match is not None:
            pulumi.set(__self__, "range_match", range_match)
        if regex_match is not None:
            pulumi.set(__self__, "regex_match", regex_match)
        if suffix_match is not None:
            pulumi.set(__self__, "suffix_match", suffix_match)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter exactly matches
        the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        must be set.
        """
        return pulumi.get(self, "exact_match")

    @property
    @pulumi.getter(name="invertMatch")
    def invert_match(self) -> Optional[bool]:
        """
        If set to false, the headerMatch is considered a match if the match criteria
        above are met. If set to true, the headerMatch is considered a match if the
        match criteria above are NOT met. Defaults to false.
        """
        return pulumi.get(self, "invert_match")

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[str]:
        """
        The value of the header must start with the contents of prefixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        return pulumi.get(self, "prefix_match")

    @property
    @pulumi.getter(name="presentMatch")
    def present_match(self) -> Optional[bool]:
        """
        Specifies that the queryParameterMatch matches if the request contains the query
        parameter, irrespective of whether the parameter has a value or not. Only one of
        presentMatch, exactMatch and regexMatch must be set.
        """
        return pulumi.get(self, "present_match")

    @property
    @pulumi.getter(name="rangeMatch")
    def range_match(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch']:
        """
        The header value must be an integer and its value must be in the range specified
        in rangeMatch. If the header does not contain an integer, number or is empty,
        the match fails. For example for a range [-5, 0]
        * -3 will match
        * 0 will not match
        * 0.25 will not match
        * -3someString will not match.
        Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
        rangeMatch must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "range_match")

    @property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter matches the
        regular expression specified by regexMatch. For the regular expression grammar,
        please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        exactMatch and regexMatch must be set.
        """
        return pulumi.get(self, "regex_match")

    @property
    @pulumi.getter(name="suffixMatch")
    def suffix_match(self) -> Optional[str]:
        """
        The value of the header must end with the contents of suffixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        return pulumi.get(self, "suffix_match")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch(dict):
    def __init__(__self__, *,
                 range_end: int,
                 range_start: int):
        """
        :param int range_end: The end of the range (exclusive).
        :param int range_start: The start of the range (inclusive).
        """
        pulumi.set(__self__, "range_end", range_end)
        pulumi.set(__self__, "range_start", range_start)

    @property
    @pulumi.getter(name="rangeEnd")
    def range_end(self) -> int:
        """
        The end of the range (exclusive).
        """
        return pulumi.get(self, "range_end")

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> int:
        """
        The start of the range (inclusive).
        """
        return pulumi.get(self, "range_start")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter(dict):
    def __init__(__self__, *,
                 filter_labels: Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel'],
                 filter_match_criteria: str):
        """
        :param Sequence['RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabelArgs'] filter_labels: The list of label value pairs that must match labels in the provided metadata
               based on filterMatchCriteria  This list must not be empty and can have at the
               most 64 entries.
               Structure is documented below.
        :param str filter_match_criteria: Specifies how individual filterLabel matches within the list of filterLabels
               contribute towards the overall metadataFilter match. Supported values are:
               * MATCH_ANY: At least one of the filterLabels must have a matching label in the
               provided metadata.
               * MATCH_ALL: All filterLabels must have matching labels in
               the provided metadata.
               Possible values are `MATCH_ALL` and `MATCH_ANY`.
        """
        pulumi.set(__self__, "filter_labels", filter_labels)
        pulumi.set(__self__, "filter_match_criteria", filter_match_criteria)

    @property
    @pulumi.getter(name="filterLabels")
    def filter_labels(self) -> Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel']:
        """
        The list of label value pairs that must match labels in the provided metadata
        based on filterMatchCriteria  This list must not be empty and can have at the
        most 64 entries.
        Structure is documented below.
        """
        return pulumi.get(self, "filter_labels")

    @property
    @pulumi.getter(name="filterMatchCriteria")
    def filter_match_criteria(self) -> str:
        """
        Specifies how individual filterLabel matches within the list of filterLabels
        contribute towards the overall metadataFilter match. Supported values are:
        * MATCH_ANY: At least one of the filterLabels must have a matching label in the
        provided metadata.
        * MATCH_ALL: All filterLabels must have matching labels in
        the provided metadata.
        Possible values are `MATCH_ALL` and `MATCH_ANY`.
        """
        return pulumi.get(self, "filter_match_criteria")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the query parameter to match. The query parameter must exist in the
               request, in the absence of which the request match fails.
        :param str value: The value of the label must match the specified value. value can have a maximum
               length of 1024 characters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query parameter to match. The query parameter must exist in the
        request, in the absence of which the request match fails.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the label must match the specified value. value can have a maximum
        length of 1024 characters.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch(dict):
    def __init__(__self__, *,
                 name: str,
                 exact_match: Optional[str] = None,
                 present_match: Optional[bool] = None,
                 regex_match: Optional[str] = None):
        """
        :param str name: The name of the query parameter to match. The query parameter must exist in the
               request, in the absence of which the request match fails.
        :param str exact_match: The queryParameterMatch matches if the value of the parameter exactly matches
               the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
               must be set.
        :param bool present_match: Specifies that the queryParameterMatch matches if the request contains the query
               parameter, irrespective of whether the parameter has a value or not. Only one of
               presentMatch, exactMatch and regexMatch must be set.
        :param str regex_match: The queryParameterMatch matches if the value of the parameter matches the
               regular expression specified by regexMatch. For the regular expression grammar,
               please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
               exactMatch and regexMatch must be set.
        """
        pulumi.set(__self__, "name", name)
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if present_match is not None:
            pulumi.set(__self__, "present_match", present_match)
        if regex_match is not None:
            pulumi.set(__self__, "regex_match", regex_match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query parameter to match. The query parameter must exist in the
        request, in the absence of which the request match fails.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter exactly matches
        the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        must be set.
        """
        return pulumi.get(self, "exact_match")

    @property
    @pulumi.getter(name="presentMatch")
    def present_match(self) -> Optional[bool]:
        """
        Specifies that the queryParameterMatch matches if the request contains the query
        parameter, irrespective of whether the parameter has a value or not. Only one of
        presentMatch, exactMatch and regexMatch must be set.
        """
        return pulumi.get(self, "present_match")

    @property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter matches the
        regular expression specified by regexMatch. For the regular expression grammar,
        please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        exactMatch and regexMatch must be set.
        """
        return pulumi.get(self, "regex_match")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteAction(dict):
    def __init__(__self__, *,
                 cors_policy: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy'] = None,
                 fault_injection_policy: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy'] = None,
                 request_mirror_policy: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy'] = None,
                 retry_policy: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy'] = None,
                 timeout: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionTimeout'] = None,
                 url_rewrite: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite'] = None,
                 weighted_backend_services: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService']] = None):
        """
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicyArgs' cors_policy: The specification for allowing client side cross-origin requests. Please see W3C
               Recommendation for Cross Origin Resource Sharing
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyArgs' fault_injection_policy: The specification for fault injection introduced into traffic to test the
               resiliency of clients to backend service failure. As part of fault injection,
               when clients send requests to a backend service, delays can be introduced by
               Loadbalancer on a percentage of requests before sending those request to the
               backend service. Similarly requests from clients can be aborted by the
               Loadbalancer for a percentage of requests. timeout and retry_policy will be
               ignored by clients that are configured with a fault_injection_policy.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicyArgs' request_mirror_policy: Specifies the policy on how requests intended for the route's backends are
               shadowed to a separate mirrored backend service. Loadbalancer does not wait for
               responses from the shadow service. Prior to sending traffic to the shadow
               service, the host / authority header is suffixed with -shadow.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyArgs' retry_policy: Specifies the retry policy associated with this route.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionTimeoutArgs' timeout: Specifies the timeout for the selected route. Timeout is computed from the time
               the request is has been fully processed (i.e. end-of-stream) up until the
               response has been completely processed. Timeout includes all retries. If not
               specified, the default value is 15 seconds.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewriteArgs' url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to
               the matched service
               Structure is documented below.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceArgs'] weighted_backend_services: A list of weighted backend services to send traffic to when a route match
               occurs. The weights determine the fraction of traffic that flows to their
               corresponding backend service. If all traffic needs to go to a single backend
               service, there must be one  weightedBackendService with weight set to a non 0
               number. Once a backendService is identified and before forwarding the request to
               the backend service, advanced routing actions like Url rewrites and header
               transformations are applied depending on additional settings specified in this
               HttpRouteAction.
               Structure is documented below.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if fault_injection_policy is not None:
            pulumi.set(__self__, "fault_injection_policy", fault_injection_policy)
        if request_mirror_policy is not None:
            pulumi.set(__self__, "request_mirror_policy", request_mirror_policy)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)
        if weighted_backend_services is not None:
            pulumi.set(__self__, "weighted_backend_services", weighted_backend_services)

    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see W3C
        Recommendation for Cross Origin Resource Sharing
        Structure is documented below.
        """
        return pulumi.get(self, "cors_policy")

    @property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the
        resiliency of clients to backend service failure. As part of fault injection,
        when clients send requests to a backend service, delays can be introduced by
        Loadbalancer on a percentage of requests before sending those request to the
        backend service. Similarly requests from clients can be aborted by the
        Loadbalancer for a percentage of requests. timeout and retry_policy will be
        ignored by clients that are configured with a fault_injection_policy.
        Structure is documented below.
        """
        return pulumi.get(self, "fault_injection_policy")

    @property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are
        shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        responses from the shadow service. Prior to sending traffic to the shadow
        service, the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        return pulumi.get(self, "request_mirror_policy")

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        return pulumi.get(self, "retry_policy")

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time
        the request is has been fully processed (i.e. end-of-stream) up until the
        response has been completely processed. Timeout includes all retries. If not
        specified, the default value is 15 seconds.
        Structure is documented below.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to
        the matched service
        Structure is documented below.
        """
        return pulumi.get(self, "url_rewrite")

    @property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match
        occurs. The weights determine the fraction of traffic that flows to their
        corresponding backend service. If all traffic needs to go to a single backend
        service, there must be one  weightedBackendService with weight set to a non 0
        number. Once a backendService is identified and before forwarding the request to
        the backend service, advanced routing actions like Url rewrites and header
        transformations are applied depending on additional settings specified in this
        HttpRouteAction.
        Structure is documented below.
        """
        return pulumi.get(self, "weighted_backend_services")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy(dict):
    def __init__(__self__, *,
                 allow_credentials: Optional[bool] = None,
                 allow_headers: Optional[Sequence[str]] = None,
                 allow_methods: Optional[Sequence[str]] = None,
                 allow_origin_regexes: Optional[Sequence[str]] = None,
                 allow_origins: Optional[Sequence[str]] = None,
                 disabled: Optional[bool] = None,
                 expose_headers: Optional[Sequence[str]] = None,
                 max_age: Optional[int] = None):
        """
        :param bool allow_credentials: In response to a preflight request, setting this to true indicates that the
               actual request can include user credentials. This translates to the Access-
               Control-Allow-Credentials header. Defaults to false.
        :param Sequence[str] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param Sequence[str] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param Sequence[str] allow_origin_regexes: Specifies the regular expression patterns that match allowed origins. For
               regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either allow_origins or allow_origin_regex.
        :param Sequence[str] allow_origins: Specifies the list of origins that will be allowed to do CORS requests. An
               origin is allowed if it matches either allow_origins or allow_origin_regex.
        :param bool disabled: If true, specifies the CORS policy is disabled.
        :param Sequence[str] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param int max_age: Specifies how long the results of a preflight request can be cached. This
               translates to the content for the Access-Control-Max-Age header.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin_regexes is not None:
            pulumi.set(__self__, "allow_origin_regexes", allow_origin_regexes)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        In response to a preflight request, setting this to true indicates that the
        actual request can include user credentials. This translates to the Access-
        Control-Allow-Credentials header. Defaults to false.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[Sequence[str]]:
        """
        Specifies the regular expression patterns that match allowed origins. For
        regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either allow_origins or allow_origin_regex.
        """
        return pulumi.get(self, "allow_origin_regexes")

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests. An
        origin is allowed if it matches either allow_origins or allow_origin_regex.
        """
        return pulumi.get(self, "allow_origins")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        If true, specifies the CORS policy is disabled.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        Specifies how long the results of a preflight request can be cached. This
        translates to the content for the Access-Control-Max-Age header.
        """
        return pulumi.get(self, "max_age")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy(dict):
    def __init__(__self__, *,
                 abort: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort'] = None,
                 delay: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay'] = None):
        """
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbortArgs' abort: The specification for how client requests are aborted as part of fault
               injection.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayArgs' delay: The specification for how client requests are delayed as part of fault
               injection, before being sent to a backend service.
               Structure is documented below.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @property
    @pulumi.getter
    def abort(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault
        injection.
        Structure is documented below.
        """
        return pulumi.get(self, "abort")

    @property
    @pulumi.getter
    def delay(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault
        injection, before being sent to a backend service.
        Structure is documented below.
        """
        return pulumi.get(self, "delay")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort(dict):
    def __init__(__self__, *,
                 http_status: Optional[int] = None,
                 percentage: Optional[float] = None):
        """
        :param int http_status: The HTTP status code used to abort the request. The value must be between 200
               and 599 inclusive.
        :param float percentage: The percentage of traffic (connections/operations/requests) on which delay will
               be introduced as part of fault injection. The value must be between 0.0 and
               100.0 inclusive.
        """
        if http_status is not None:
            pulumi.set(__self__, "http_status", http_status)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[int]:
        """
        The HTTP status code used to abort the request. The value must be between 200
        and 599 inclusive.
        """
        return pulumi.get(self, "http_status")

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) on which delay will
        be introduced as part of fault injection. The value must be between 0.0 and
        100.0 inclusive.
        """
        return pulumi.get(self, "percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay(dict):
    def __init__(__self__, *,
                 fixed_delay: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay'] = None,
                 percentage: Optional[float] = None):
        """
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs' fixed_delay: Specifies the value of the fixed delay interval.
               Structure is documented below.
        :param float percentage: The percentage of traffic (connections/operations/requests) on which delay will
               be introduced as part of fault injection. The value must be between 0.0 and
               100.0 inclusive.
        """
        if fixed_delay is not None:
            pulumi.set(__self__, "fixed_delay", fixed_delay)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay']:
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_delay")

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) on which delay will
        be introduced as part of fault injection. The value must be between 0.0 and
        100.0 inclusive.
        """
        return pulumi.get(self, "percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    def __init__(__self__, *,
                 seconds: str,
                 nanos: Optional[int] = None):
        """
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy(dict):
    def __init__(__self__, *,
                 backend_service: str):
        """
        :param str backend_service: The default RegionBackendService resource. Before
               forwarding the request to backendService, the loadbalancer applies any relevant
               headerActions specified as part of this backendServiceWeight.
        """
        pulumi.set(__self__, "backend_service", backend_service)

    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The default RegionBackendService resource. Before
        forwarding the request to backendService, the loadbalancer applies any relevant
        headerActions specified as part of this backendServiceWeight.
        """
        return pulumi.get(self, "backend_service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy(dict):
    def __init__(__self__, *,
                 num_retries: int,
                 per_try_timeout: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout'] = None,
                 retry_conditions: Optional[Sequence[str]] = None):
        """
        :param int num_retries: Specifies the allowed number retries. This number must be > 0.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeoutArgs' per_try_timeout: Specifies a non-zero timeout per retry attempt.
               Structure is documented below.
        :param Sequence[str] retry_conditions: Specifies one or more conditions when this retry rule applies. Valid values are:
               - 5xx: Loadbalancer will attempt a retry if the backend service responds with
               any 5xx response code, or if the backend service does not respond at all,
               example: disconnects, reset, read timeout, connection failure, and refused
               streams.
               - gateway-error: Similar to 5xx, but only applies to response codes
               502, 503 or 504.
               - connect-failure: Loadbalancer will retry on failures
               connecting to backend services, for example due to connection timeouts.
               - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
               REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
               - cancelled: Loadbalancer will retry if the gRPC status code in the response
               header is set to cancelled
               - deadline-exceeded: Loadbalancer will retry if the
               gRPC status code in the response header is set to deadline-exceeded
               - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
               header is set to resource-exhausted
               - unavailable: Loadbalancer will retry if
               the gRPC status code in the response header is set to unavailable
        """
        pulumi.set(__self__, "num_retries", num_retries)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_conditions is not None:
            pulumi.set(__self__, "retry_conditions", retry_conditions)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> int:
        """
        Specifies the allowed number retries. This number must be > 0.
        """
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        Structure is documented below.
        """
        return pulumi.get(self, "per_try_timeout")

    @property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[Sequence[str]]:
        """
        Specifies one or more conditions when this retry rule applies. Valid values are:
        - 5xx: Loadbalancer will attempt a retry if the backend service responds with
        any 5xx response code, or if the backend service does not respond at all,
        example: disconnects, reset, read timeout, connection failure, and refused
        streams.
        - gateway-error: Similar to 5xx, but only applies to response codes
        502, 503 or 504.
        - connect-failure: Loadbalancer will retry on failures
        connecting to backend services, for example due to connection timeouts.
        - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
        REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        - cancelled: Loadbalancer will retry if the gRPC status code in the response
        header is set to cancelled
        - deadline-exceeded: Loadbalancer will retry if the
        gRPC status code in the response header is set to deadline-exceeded
        - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
        header is set to resource-exhausted
        - unavailable: Loadbalancer will retry if
        the gRPC status code in the response header is set to unavailable
        """
        return pulumi.get(self, "retry_conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout(dict):
    def __init__(__self__, *,
                 seconds: str,
                 nanos: Optional[int] = None):
        """
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionTimeout(dict):
    def __init__(__self__, *,
                 seconds: str,
                 nanos: Optional[int] = None):
        """
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite(dict):
    def __init__(__self__, *,
                 host_rewrite: Optional[str] = None,
                 path_prefix_rewrite: Optional[str] = None):
        """
        :param str host_rewrite: Prior to forwarding the request to the selected service, the request's host
               header is replaced with contents of hostRewrite. The value must be between 1 and
               255 characters.
        :param str path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching
               portion of the request's path is replaced by pathPrefixRewrite. The value must
               be between 1 and 1024 characters.
        """
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if path_prefix_rewrite is not None:
            pulumi.set(__self__, "path_prefix_rewrite", path_prefix_rewrite)

    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected service, the request's host
        header is replaced with contents of hostRewrite. The value must be between 1 and
        255 characters.
        """
        return pulumi.get(self, "host_rewrite")

    @property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected backend service, the matching
        portion of the request's path is replaced by pathPrefixRewrite. The value must
        be between 1 and 1024 characters.
        """
        return pulumi.get(self, "path_prefix_rewrite")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService(dict):
    def __init__(__self__, *,
                 backend_service: str,
                 weight: int,
                 header_action: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction'] = None):
        """
        :param str backend_service: The default RegionBackendService resource. Before
               forwarding the request to backendService, the loadbalancer applies any relevant
               headerActions specified as part of this backendServiceWeight.
        :param int weight: Specifies the fraction of traffic sent to backendService, computed as weight /
               (sum of all weightedBackendService weights in routeAction) . The selection of a
               backend service is determined only for new traffic. Once a user's request has
               been directed to a backendService, subsequent requests will be sent to the same
               backendService as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService. headerAction specified here take effect before
               headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
               Structure is documented below.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        pulumi.set(__self__, "weight", weight)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)

    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The default RegionBackendService resource. Before
        forwarding the request to backendService, the loadbalancer applies any relevant
        headerActions specified as part of this backendServiceWeight.
        """
        return pulumi.get(self, "backend_service")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Specifies the fraction of traffic sent to backendService, computed as weight /
        (sum of all weightedBackendService weights in routeAction) . The selection of a
        backend service is determined only for new traffic. Once a user's request has
        been directed to a backendService, subsequent requests will be sent to the same
        backendService as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService. headerAction specified here take effect before
        headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction(dict):
    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[str]] = None):
        """
        :param Sequence['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the
               backendService.
               Structure is documented below.
        :param Sequence[str] request_headers_to_removes: A list of header names for headers that need to be removed from the request
               prior to forwarding the request to the backendService.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[str] response_headers_to_removes: A list of header names for headers that need to be removed from the response
               prior to sending the response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the
        backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the request
        prior to forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the response
        prior to sending the response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the
               header. If true, headerValue is set for the header, discarding any values that
               were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the
        header. If true, headerValue is set for the header, discarding any values that
        were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the
               header. If true, headerValue is set for the header, discarding any values that
               were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the
        header. If true, headerValue is set for the header, discarding any values that
        were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleUrlRedirect(dict):
    def __init__(__self__, *,
                 host_redirect: Optional[str] = None,
                 https_redirect: Optional[bool] = None,
                 path_redirect: Optional[str] = None,
                 prefix_redirect: Optional[str] = None,
                 redirect_response_code: Optional[str] = None,
                 strip_query: Optional[bool] = None):
        """
        :param str host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param bool https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param str path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param str prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        :param bool strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained.
               This field is required to ensure an empty block is not set. The normal default value is false.
        """
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)
        if strip_query is not None:
            pulumi.set(__self__, "strip_query", strip_query)

    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_redirect")

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        return pulumi.get(self, "https_redirect")

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        return pulumi.get(self, "path_redirect")

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "prefix_redirect")

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> Optional[bool]:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        return pulumi.get(self, "strip_query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegionUrlMapTest(dict):
    def __init__(__self__, *,
                 host: str,
                 path: str,
                 service: str,
                 description: Optional[str] = None):
        """
        :param str host: Host portion of the URL.
        :param str path: Path portion of the URL.
        :param str service: A reference to expected RegionBackendService resource the given URL should be mapped to.
        :param str description: Description of this test case.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "service", service)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Host portion of the URL.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path portion of the URL.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        A reference to expected RegionBackendService resource the given URL should be mapped to.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this test case.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ReservationSpecificReservation(dict):
    def __init__(__self__, *,
                 count: int,
                 instance_properties: 'outputs.ReservationSpecificReservationInstanceProperties',
                 in_use_count: Optional[int] = None):
        """
        :param int count: The number of resources that are allocated.
        :param 'ReservationSpecificReservationInstancePropertiesArgs' instance_properties: The instance properties for the reservation.
               Structure is documented below.
        :param int in_use_count: -
               How many instances are in use.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "instance_properties", instance_properties)
        if in_use_count is not None:
            pulumi.set(__self__, "in_use_count", in_use_count)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of resources that are allocated.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="instanceProperties")
    def instance_properties(self) -> 'outputs.ReservationSpecificReservationInstanceProperties':
        """
        The instance properties for the reservation.
        Structure is documented below.
        """
        return pulumi.get(self, "instance_properties")

    @property
    @pulumi.getter(name="inUseCount")
    def in_use_count(self) -> Optional[int]:
        """
        -
        How many instances are in use.
        """
        return pulumi.get(self, "in_use_count")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ReservationSpecificReservationInstanceProperties(dict):
    def __init__(__self__, *,
                 machine_type: str,
                 guest_accelerators: Optional[Sequence['outputs.ReservationSpecificReservationInstancePropertiesGuestAccelerator']] = None,
                 local_ssds: Optional[Sequence['outputs.ReservationSpecificReservationInstancePropertiesLocalSsd']] = None,
                 min_cpu_platform: Optional[str] = None):
        """
        :param str machine_type: The name of the machine type to reserve.
        :param Sequence['ReservationSpecificReservationInstancePropertiesGuestAcceleratorArgs'] guest_accelerators: Guest accelerator type and count.
               Structure is documented below.
        :param Sequence['ReservationSpecificReservationInstancePropertiesLocalSsdArgs'] local_ssds: The amount of local ssd to reserve with each instance. This
               reserves disks of type `local-ssd`.
               Structure is documented below.
        :param str min_cpu_platform: The minimum CPU platform for the reservation. For example,
               `"Intel Skylake"`. See
               the CPU platform availability reference](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform#availablezones)
               for information on available CPU platforms.
        """
        pulumi.set(__self__, "machine_type", machine_type)
        if guest_accelerators is not None:
            pulumi.set(__self__, "guest_accelerators", guest_accelerators)
        if local_ssds is not None:
            pulumi.set(__self__, "local_ssds", local_ssds)
        if min_cpu_platform is not None:
            pulumi.set(__self__, "min_cpu_platform", min_cpu_platform)

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> str:
        """
        The name of the machine type to reserve.
        """
        return pulumi.get(self, "machine_type")

    @property
    @pulumi.getter(name="guestAccelerators")
    def guest_accelerators(self) -> Optional[Sequence['outputs.ReservationSpecificReservationInstancePropertiesGuestAccelerator']]:
        """
        Guest accelerator type and count.
        Structure is documented below.
        """
        return pulumi.get(self, "guest_accelerators")

    @property
    @pulumi.getter(name="localSsds")
    def local_ssds(self) -> Optional[Sequence['outputs.ReservationSpecificReservationInstancePropertiesLocalSsd']]:
        """
        The amount of local ssd to reserve with each instance. This
        reserves disks of type `local-ssd`.
        Structure is documented below.
        """
        return pulumi.get(self, "local_ssds")

    @property
    @pulumi.getter(name="minCpuPlatform")
    def min_cpu_platform(self) -> Optional[str]:
        """
        The minimum CPU platform for the reservation. For example,
        `"Intel Skylake"`. See
        the CPU platform availability reference](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform#availablezones)
        for information on available CPU platforms.
        """
        return pulumi.get(self, "min_cpu_platform")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ReservationSpecificReservationInstancePropertiesGuestAccelerator(dict):
    def __init__(__self__, *,
                 accelerator_count: int,
                 accelerator_type: str):
        """
        :param int accelerator_count: The number of the guest accelerator cards exposed to
               this instance.
        :param str accelerator_type: The full or partial URL of the accelerator type to
               attach to this instance. For example:
               `projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100`
               If you are creating an instance template, specify only the accelerator name.
        """
        pulumi.set(__self__, "accelerator_count", accelerator_count)
        pulumi.set(__self__, "accelerator_type", accelerator_type)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> int:
        """
        The number of the guest accelerator cards exposed to
        this instance.
        """
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> str:
        """
        The full or partial URL of the accelerator type to
        attach to this instance. For example:
        `projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100`
        If you are creating an instance template, specify only the accelerator name.
        """
        return pulumi.get(self, "accelerator_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ReservationSpecificReservationInstancePropertiesLocalSsd(dict):
    def __init__(__self__, *,
                 disk_size_gb: int,
                 interface: Optional[str] = None):
        """
        :param int disk_size_gb: The size of the disk in base-2 GB.
        :param str interface: The disk interface to use for attaching this disk.
               Default value is `SCSI`.
               Possible values are `SCSI` and `NVME`.
        """
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> int:
        """
        The size of the disk in base-2 GB.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter
    def interface(self) -> Optional[str]:
        """
        The disk interface to use for attaching this disk.
        Default value is `SCSI`.
        Possible values are `SCSI` and `NVME`.
        """
        return pulumi.get(self, "interface")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicyGroupPlacementPolicy(dict):
    def __init__(__self__, *,
                 availability_domain_count: Optional[int] = None,
                 collocation: Optional[str] = None,
                 vm_count: Optional[int] = None):
        """
        :param int availability_domain_count: The number of availability domains instances will be spread across. If two instances are in different
               availability domain, they will not be put in the same low latency network
        :param str collocation: Collocation specifies whether to place VMs inside the same availability domain on the same low-latency network.
               Specify `COLLOCATED` to enable collocation. Can only be specified with `vm_count`. If compute instances are created
               with a COLLOCATED policy, then exactly `vm_count` instances must be created at the same time with the resource policy
               attached.
               Possible values are `COLLOCATED`.
        :param int vm_count: Number of vms in this placement group.
        """
        if availability_domain_count is not None:
            pulumi.set(__self__, "availability_domain_count", availability_domain_count)
        if collocation is not None:
            pulumi.set(__self__, "collocation", collocation)
        if vm_count is not None:
            pulumi.set(__self__, "vm_count", vm_count)

    @property
    @pulumi.getter(name="availabilityDomainCount")
    def availability_domain_count(self) -> Optional[int]:
        """
        The number of availability domains instances will be spread across. If two instances are in different
        availability domain, they will not be put in the same low latency network
        """
        return pulumi.get(self, "availability_domain_count")

    @property
    @pulumi.getter
    def collocation(self) -> Optional[str]:
        """
        Collocation specifies whether to place VMs inside the same availability domain on the same low-latency network.
        Specify `COLLOCATED` to enable collocation. Can only be specified with `vm_count`. If compute instances are created
        with a COLLOCATED policy, then exactly `vm_count` instances must be created at the same time with the resource policy
        attached.
        Possible values are `COLLOCATED`.
        """
        return pulumi.get(self, "collocation")

    @property
    @pulumi.getter(name="vmCount")
    def vm_count(self) -> Optional[int]:
        """
        Number of vms in this placement group.
        """
        return pulumi.get(self, "vm_count")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicy(dict):
    def __init__(__self__, *,
                 schedule: 'outputs.ResourcePolicySnapshotSchedulePolicySchedule',
                 retention_policy: Optional['outputs.ResourcePolicySnapshotSchedulePolicyRetentionPolicy'] = None,
                 snapshot_properties: Optional['outputs.ResourcePolicySnapshotSchedulePolicySnapshotProperties'] = None):
        """
        :param 'ResourcePolicySnapshotSchedulePolicyScheduleArgs' schedule: Contains one of an `hourlySchedule`, `dailySchedule`, or `weeklySchedule`.
               Structure is documented below.
        :param 'ResourcePolicySnapshotSchedulePolicyRetentionPolicyArgs' retention_policy: Retention policy applied to snapshots created by this resource policy.
               Structure is documented below.
        :param 'ResourcePolicySnapshotSchedulePolicySnapshotPropertiesArgs' snapshot_properties: Properties with which the snapshots are created, such as labels.
               Structure is documented below.
        """
        pulumi.set(__self__, "schedule", schedule)
        if retention_policy is not None:
            pulumi.set(__self__, "retention_policy", retention_policy)
        if snapshot_properties is not None:
            pulumi.set(__self__, "snapshot_properties", snapshot_properties)

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.ResourcePolicySnapshotSchedulePolicySchedule':
        """
        Contains one of an `hourlySchedule`, `dailySchedule`, or `weeklySchedule`.
        Structure is documented below.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicyRetentionPolicy']:
        """
        Retention policy applied to snapshots created by this resource policy.
        Structure is documented below.
        """
        return pulumi.get(self, "retention_policy")

    @property
    @pulumi.getter(name="snapshotProperties")
    def snapshot_properties(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicySnapshotProperties']:
        """
        Properties with which the snapshots are created, such as labels.
        Structure is documented below.
        """
        return pulumi.get(self, "snapshot_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyRetentionPolicy(dict):
    def __init__(__self__, *,
                 max_retention_days: int,
                 on_source_disk_delete: Optional[str] = None):
        """
        :param int max_retention_days: Maximum age of the snapshot that is allowed to be kept.
        :param str on_source_disk_delete: Specifies the behavior to apply to scheduled snapshots when
               the source disk is deleted.
               Default value is `KEEP_AUTO_SNAPSHOTS`.
               Possible values are `KEEP_AUTO_SNAPSHOTS` and `APPLY_RETENTION_POLICY`.
        """
        pulumi.set(__self__, "max_retention_days", max_retention_days)
        if on_source_disk_delete is not None:
            pulumi.set(__self__, "on_source_disk_delete", on_source_disk_delete)

    @property
    @pulumi.getter(name="maxRetentionDays")
    def max_retention_days(self) -> int:
        """
        Maximum age of the snapshot that is allowed to be kept.
        """
        return pulumi.get(self, "max_retention_days")

    @property
    @pulumi.getter(name="onSourceDiskDelete")
    def on_source_disk_delete(self) -> Optional[str]:
        """
        Specifies the behavior to apply to scheduled snapshots when
        the source disk is deleted.
        Default value is `KEEP_AUTO_SNAPSHOTS`.
        Possible values are `KEEP_AUTO_SNAPSHOTS` and `APPLY_RETENTION_POLICY`.
        """
        return pulumi.get(self, "on_source_disk_delete")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicySchedule(dict):
    def __init__(__self__, *,
                 daily_schedule: Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule'] = None,
                 hourly_schedule: Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule'] = None,
                 weekly_schedule: Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule'] = None):
        """
        :param 'ResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleArgs' daily_schedule: The policy will execute every nth day at the specified time.
               Structure is documented below.
        :param 'ResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleArgs' hourly_schedule: The policy will execute every nth hour starting at the specified time.
               Structure is documented below.
        :param 'ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleArgs' weekly_schedule: Allows specifying a snapshot time for each day of the week.
               Structure is documented below.
        """
        if daily_schedule is not None:
            pulumi.set(__self__, "daily_schedule", daily_schedule)
        if hourly_schedule is not None:
            pulumi.set(__self__, "hourly_schedule", hourly_schedule)
        if weekly_schedule is not None:
            pulumi.set(__self__, "weekly_schedule", weekly_schedule)

    @property
    @pulumi.getter(name="dailySchedule")
    def daily_schedule(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule']:
        """
        The policy will execute every nth day at the specified time.
        Structure is documented below.
        """
        return pulumi.get(self, "daily_schedule")

    @property
    @pulumi.getter(name="hourlySchedule")
    def hourly_schedule(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule']:
        """
        The policy will execute every nth hour starting at the specified time.
        Structure is documented below.
        """
        return pulumi.get(self, "hourly_schedule")

    @property
    @pulumi.getter(name="weeklySchedule")
    def weekly_schedule(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule']:
        """
        Allows specifying a snapshot time for each day of the week.
        Structure is documented below.
        """
        return pulumi.get(self, "weekly_schedule")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule(dict):
    def __init__(__self__, *,
                 days_in_cycle: int,
                 start_time: str):
        """
        :param int days_in_cycle: The number of days between snapshots.
        :param str start_time: Time within the window to start the operations.
               It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        pulumi.set(__self__, "days_in_cycle", days_in_cycle)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysInCycle")
    def days_in_cycle(self) -> int:
        """
        The number of days between snapshots.
        """
        return pulumi.get(self, "days_in_cycle")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Time within the window to start the operations.
        It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        return pulumi.get(self, "start_time")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule(dict):
    def __init__(__self__, *,
                 hours_in_cycle: int,
                 start_time: str):
        """
        :param int hours_in_cycle: The number of hours between snapshots.
        :param str start_time: Time within the window to start the operations.
               It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        pulumi.set(__self__, "hours_in_cycle", hours_in_cycle)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="hoursInCycle")
    def hours_in_cycle(self) -> int:
        """
        The number of hours between snapshots.
        """
        return pulumi.get(self, "hours_in_cycle")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Time within the window to start the operations.
        It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        return pulumi.get(self, "start_time")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule(dict):
    def __init__(__self__, *,
                 day_of_weeks: Sequence['outputs.ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek']):
        """
        :param Sequence['ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekArgs'] day_of_weeks: May contain up to seven (one for each day of the week) snapshot times.
               Structure is documented below.
        """
        pulumi.set(__self__, "day_of_weeks", day_of_weeks)

    @property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> Sequence['outputs.ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek']:
        """
        May contain up to seven (one for each day of the week) snapshot times.
        Structure is documented below.
        """
        return pulumi.get(self, "day_of_weeks")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek(dict):
    def __init__(__self__, *,
                 day: str,
                 start_time: str):
        """
        :param str day: The day of the week to create the snapshot. e.g. MONDAY
               Possible values are `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, and `SUNDAY`.
        :param str start_time: Time within the window to start the operations.
               It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def day(self) -> str:
        """
        The day of the week to create the snapshot. e.g. MONDAY
        Possible values are `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, and `SUNDAY`.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Time within the window to start the operations.
        It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        return pulumi.get(self, "start_time")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicySnapshotProperties(dict):
    def __init__(__self__, *,
                 guest_flush: Optional[bool] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 storage_locations: Optional[str] = None):
        """
        :param bool guest_flush: Whether to perform a 'guest aware' snapshot.
        :param Mapping[str, str] labels: A set of key-value pairs.
        :param str storage_locations: Cloud Storage bucket location to store the auto snapshot
               (regional or multi-regional)
        """
        if guest_flush is not None:
            pulumi.set(__self__, "guest_flush", guest_flush)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if storage_locations is not None:
            pulumi.set(__self__, "storage_locations", storage_locations)

    @property
    @pulumi.getter(name="guestFlush")
    def guest_flush(self) -> Optional[bool]:
        """
        Whether to perform a 'guest aware' snapshot.
        """
        return pulumi.get(self, "guest_flush")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        A set of key-value pairs.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="storageLocations")
    def storage_locations(self) -> Optional[str]:
        """
        Cloud Storage bucket location to store the auto snapshot
        (regional or multi-regional)
        """
        return pulumi.get(self, "storage_locations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RouterBgp(dict):
    def __init__(__self__, *,
                 asn: int,
                 advertise_mode: Optional[str] = None,
                 advertised_groups: Optional[Sequence[str]] = None,
                 advertised_ip_ranges: Optional[Sequence['outputs.RouterBgpAdvertisedIpRange']] = None):
        """
        :param int asn: Local BGP Autonomous System Number (ASN). Must be an RFC6996
               private ASN, either 16-bit or 32-bit. The value will be fixed for
               this router resource. All VPN tunnels that link to this router
               will have the same local ASN.
        :param str advertise_mode: User-specified flag to indicate which mode to use for advertisement.
               Default value is `DEFAULT`.
               Possible values are `DEFAULT` and `CUSTOM`.
        :param Sequence[str] advertised_groups: User-specified list of prefix groups to advertise in custom mode.
               This field can only be populated if advertiseMode is CUSTOM and
               is advertised to all peers of the router. These groups will be
               advertised in addition to any specified prefixes. Leave this field
               blank to advertise no custom groups.
               This enum field has the one valid value: ALL_SUBNETS
        :param Sequence['RouterBgpAdvertisedIpRangeArgs'] advertised_ip_ranges: User-specified list of individual IP ranges to advertise in
               custom mode. This field can only be populated if advertiseMode
               is CUSTOM and is advertised to all peers of the router. These IP
               ranges will be advertised in addition to any specified groups.
               Leave this field blank to advertise no custom IP ranges.
               Structure is documented below.
        """
        pulumi.set(__self__, "asn", asn)
        if advertise_mode is not None:
            pulumi.set(__self__, "advertise_mode", advertise_mode)
        if advertised_groups is not None:
            pulumi.set(__self__, "advertised_groups", advertised_groups)
        if advertised_ip_ranges is not None:
            pulumi.set(__self__, "advertised_ip_ranges", advertised_ip_ranges)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        Local BGP Autonomous System Number (ASN). Must be an RFC6996
        private ASN, either 16-bit or 32-bit. The value will be fixed for
        this router resource. All VPN tunnels that link to this router
        will have the same local ASN.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="advertiseMode")
    def advertise_mode(self) -> Optional[str]:
        """
        User-specified flag to indicate which mode to use for advertisement.
        Default value is `DEFAULT`.
        Possible values are `DEFAULT` and `CUSTOM`.
        """
        return pulumi.get(self, "advertise_mode")

    @property
    @pulumi.getter(name="advertisedGroups")
    def advertised_groups(self) -> Optional[Sequence[str]]:
        """
        User-specified list of prefix groups to advertise in custom mode.
        This field can only be populated if advertiseMode is CUSTOM and
        is advertised to all peers of the router. These groups will be
        advertised in addition to any specified prefixes. Leave this field
        blank to advertise no custom groups.
        This enum field has the one valid value: ALL_SUBNETS
        """
        return pulumi.get(self, "advertised_groups")

    @property
    @pulumi.getter(name="advertisedIpRanges")
    def advertised_ip_ranges(self) -> Optional[Sequence['outputs.RouterBgpAdvertisedIpRange']]:
        """
        User-specified list of individual IP ranges to advertise in
        custom mode. This field can only be populated if advertiseMode
        is CUSTOM and is advertised to all peers of the router. These IP
        ranges will be advertised in addition to any specified groups.
        Leave this field blank to advertise no custom IP ranges.
        Structure is documented below.
        """
        return pulumi.get(self, "advertised_ip_ranges")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RouterBgpAdvertisedIpRange(dict):
    def __init__(__self__, *,
                 range: str,
                 description: Optional[str] = None):
        """
        :param str range: The IP range to advertise. The value must be a
               CIDR-formatted string.
        :param str description: User-specified description for the IP range.
        """
        pulumi.set(__self__, "range", range)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def range(self) -> str:
        """
        The IP range to advertise. The value must be a
        CIDR-formatted string.
        """
        return pulumi.get(self, "range")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        User-specified description for the IP range.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RouterNatLogConfig(dict):
    def __init__(__self__, *,
                 enable: bool,
                 filter: str):
        """
        :param bool enable: Indicates whether or not to export logs.
        :param str filter: Specifies the desired filtering of logs on this NAT.
               Possible values are `ERRORS_ONLY`, `TRANSLATIONS_ONLY`, and `ALL`.
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Indicates whether or not to export logs.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def filter(self) -> str:
        """
        Specifies the desired filtering of logs on this NAT.
        Possible values are `ERRORS_ONLY`, `TRANSLATIONS_ONLY`, and `ALL`.
        """
        return pulumi.get(self, "filter")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RouterNatSubnetwork(dict):
    def __init__(__self__, *,
                 name: str,
                 source_ip_ranges_to_nats: Sequence[str],
                 secondary_ip_range_names: Optional[Sequence[str]] = None):
        """
        :param str name: Self-link of subnetwork to NAT
        :param Sequence[str] source_ip_ranges_to_nats: List of options for which source IPs in the subnetwork
               should have NAT enabled. Supported values include:
               `ALL_IP_RANGES`, `LIST_OF_SECONDARY_IP_RANGES`,
               `PRIMARY_IP_RANGE`.
        :param Sequence[str] secondary_ip_range_names: List of the secondary ranges of the subnetwork that are allowed
               to use NAT. This can be populated only if
               `LIST_OF_SECONDARY_IP_RANGES` is one of the values in
               sourceIpRangesToNat
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_ip_ranges_to_nats", source_ip_ranges_to_nats)
        if secondary_ip_range_names is not None:
            pulumi.set(__self__, "secondary_ip_range_names", secondary_ip_range_names)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Self-link of subnetwork to NAT
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceIpRangesToNats")
    def source_ip_ranges_to_nats(self) -> Sequence[str]:
        """
        List of options for which source IPs in the subnetwork
        should have NAT enabled. Supported values include:
        `ALL_IP_RANGES`, `LIST_OF_SECONDARY_IP_RANGES`,
        `PRIMARY_IP_RANGE`.
        """
        return pulumi.get(self, "source_ip_ranges_to_nats")

    @property
    @pulumi.getter(name="secondaryIpRangeNames")
    def secondary_ip_range_names(self) -> Optional[Sequence[str]]:
        """
        List of the secondary ranges of the subnetwork that are allowed
        to use NAT. This can be populated only if
        `LIST_OF_SECONDARY_IP_RANGES` is one of the values in
        sourceIpRangesToNat
        """
        return pulumi.get(self, "secondary_ip_range_names")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RouterPeerAdvertisedIpRange(dict):
    def __init__(__self__, *,
                 range: str,
                 description: Optional[str] = None):
        """
        :param str range: The IP range to advertise. The value must be a
               CIDR-formatted string.
        :param str description: User-specified description for the IP range.
        """
        pulumi.set(__self__, "range", range)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def range(self) -> str:
        """
        The IP range to advertise. The value must be a
        CIDR-formatted string.
        """
        return pulumi.get(self, "range")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        User-specified description for the IP range.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityPolicyRule(dict):
    def __init__(__self__, *,
                 action: str,
                 match: 'outputs.SecurityPolicyRuleMatch',
                 priority: int,
                 description: Optional[str] = None,
                 preview: Optional[bool] = None):
        """
        :param str action: Action to take when `match` matches the request. Valid values:
               * "allow" : allow access to target
               * "deny(status)" : deny access to target, returns the  HTTP response code specified (valid values are 403, 404 and 502)
        :param 'SecurityPolicyRuleMatchArgs' match: A match condition that incoming traffic is evaluated against.
               If it evaluates to true, the corresponding `action` is enforced. Structure is documented below.
        :param int priority: An unique positive integer indicating the priority of evaluation for a rule.
               Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
        :param str description: An optional description of this rule. Max size is 64.
        :param bool preview: When set to true, the `action` specified above is not enforced.
               Stackdriver logs for requests that trigger a preview action are annotated as such.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "priority", priority)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if preview is not None:
            pulumi.set(__self__, "preview", preview)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to take when `match` matches the request. Valid values:
        * "allow" : allow access to target
        * "deny(status)" : deny access to target, returns the  HTTP response code specified (valid values are 403, 404 and 502)
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def match(self) -> 'outputs.SecurityPolicyRuleMatch':
        """
        A match condition that incoming traffic is evaluated against.
        If it evaluates to true, the corresponding `action` is enforced. Structure is documented below.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        An unique positive integer indicating the priority of evaluation for a rule.
        Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of this rule. Max size is 64.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def preview(self) -> Optional[bool]:
        """
        When set to true, the `action` specified above is not enforced.
        Stackdriver logs for requests that trigger a preview action are annotated as such.
        """
        return pulumi.get(self, "preview")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityPolicyRuleMatch(dict):
    def __init__(__self__, *,
                 config: Optional['outputs.SecurityPolicyRuleMatchConfig'] = None,
                 expr: Optional['outputs.SecurityPolicyRuleMatchExpr'] = None,
                 versioned_expr: Optional[str] = None):
        """
        :param 'SecurityPolicyRuleMatchConfigArgs' config: The configuration options available when specifying `versioned_expr`.
               This field must be specified if `versioned_expr` is specified and cannot be specified if `versioned_expr` is not specified.
               Structure is documented below.
        :param 'SecurityPolicyRuleMatchExprArgs' expr: User defined CEVAL expression. A CEVAL expression is used to specify match criteria
               such as origin.ip, source.region_code and contents in the request header.
               Structure is documented below.
        :param str versioned_expr: Predefined rule expression. If this field is specified, `config` must also be specified.
               Available options:
               * SRC_IPS_V1: Must specify the corresponding `src_ip_ranges` field in `config`.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if versioned_expr is not None:
            pulumi.set(__self__, "versioned_expr", versioned_expr)

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.SecurityPolicyRuleMatchConfig']:
        """
        The configuration options available when specifying `versioned_expr`.
        This field must be specified if `versioned_expr` is specified and cannot be specified if `versioned_expr` is not specified.
        Structure is documented below.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def expr(self) -> Optional['outputs.SecurityPolicyRuleMatchExpr']:
        """
        User defined CEVAL expression. A CEVAL expression is used to specify match criteria
        such as origin.ip, source.region_code and contents in the request header.
        Structure is documented below.
        """
        return pulumi.get(self, "expr")

    @property
    @pulumi.getter(name="versionedExpr")
    def versioned_expr(self) -> Optional[str]:
        """
        Predefined rule expression. If this field is specified, `config` must also be specified.
        Available options:
        * SRC_IPS_V1: Must specify the corresponding `src_ip_ranges` field in `config`.
        """
        return pulumi.get(self, "versioned_expr")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityPolicyRuleMatchConfig(dict):
    def __init__(__self__, *,
                 src_ip_ranges: Sequence[str]):
        """
        :param Sequence[str] src_ip_ranges: Set of IP addresses or ranges (IPV4 or IPV6) in CIDR notation
               to match against inbound traffic. There is a limit of 10 IP ranges per rule. A value of '\*' matches all IPs
               (can be used to override the default behavior).
        """
        pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)

    @property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Sequence[str]:
        """
        Set of IP addresses or ranges (IPV4 or IPV6) in CIDR notation
        to match against inbound traffic. There is a limit of 10 IP ranges per rule. A value of '\*' matches all IPs
        (can be used to override the default behavior).
        """
        return pulumi.get(self, "src_ip_ranges")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityPolicyRuleMatchExpr(dict):
    def __init__(__self__, *,
                 expression: str):
        """
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
               The application context of the containing message determines which well-known feature set of CEL is supported.
        """
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        The application context of the containing message determines which well-known feature set of CEL is supported.
        """
        return pulumi.get(self, "expression")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityScanConfigAuthentication(dict):
    def __init__(__self__, *,
                 custom_account: Optional['outputs.SecurityScanConfigAuthenticationCustomAccount'] = None,
                 google_account: Optional['outputs.SecurityScanConfigAuthenticationGoogleAccount'] = None):
        """
        :param 'SecurityScanConfigAuthenticationCustomAccountArgs' custom_account: Describes authentication configuration that uses a custom account.
               Structure is documented below.
        :param 'SecurityScanConfigAuthenticationGoogleAccountArgs' google_account: Describes authentication configuration that uses a Google account.
               Structure is documented below.
        """
        if custom_account is not None:
            pulumi.set(__self__, "custom_account", custom_account)
        if google_account is not None:
            pulumi.set(__self__, "google_account", google_account)

    @property
    @pulumi.getter(name="customAccount")
    def custom_account(self) -> Optional['outputs.SecurityScanConfigAuthenticationCustomAccount']:
        """
        Describes authentication configuration that uses a custom account.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_account")

    @property
    @pulumi.getter(name="googleAccount")
    def google_account(self) -> Optional['outputs.SecurityScanConfigAuthenticationGoogleAccount']:
        """
        Describes authentication configuration that uses a Google account.
        Structure is documented below.
        """
        return pulumi.get(self, "google_account")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityScanConfigAuthenticationCustomAccount(dict):
    def __init__(__self__, *,
                 login_url: str,
                 password: str,
                 username: str):
        """
        :param str login_url: The login form URL of the website.
        :param str password: The password of the custom account. The credential is stored encrypted
               in GCP.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param str username: The user name of the custom account.
        """
        pulumi.set(__self__, "login_url", login_url)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="loginUrl")
    def login_url(self) -> str:
        """
        The login form URL of the website.
        """
        return pulumi.get(self, "login_url")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the custom account. The credential is stored encrypted
        in GCP.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The user name of the custom account.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityScanConfigAuthenticationGoogleAccount(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password of the custom account. The credential is stored encrypted
               in GCP.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param str username: The user name of the custom account.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the custom account. The credential is stored encrypted
        in GCP.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The user name of the custom account.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecurityScanConfigSchedule(dict):
    def __init__(__self__, *,
                 interval_duration_days: int,
                 schedule_time: Optional[str] = None):
        """
        :param int interval_duration_days: The duration of time between executions in days
        :param str schedule_time: A timestamp indicates when the next run will be scheduled. The value is refreshed
               by the server after each run. If unspecified, it will default to current server time,
               which means the scan will be scheduled to start immediately.
        """
        pulumi.set(__self__, "interval_duration_days", interval_duration_days)
        if schedule_time is not None:
            pulumi.set(__self__, "schedule_time", schedule_time)

    @property
    @pulumi.getter(name="intervalDurationDays")
    def interval_duration_days(self) -> int:
        """
        The duration of time between executions in days
        """
        return pulumi.get(self, "interval_duration_days")

    @property
    @pulumi.getter(name="scheduleTime")
    def schedule_time(self) -> Optional[str]:
        """
        A timestamp indicates when the next run will be scheduled. The value is refreshed
        by the server after each run. If unspecified, it will default to current server time,
        which means the scan will be scheduled to start immediately.
        """
        return pulumi.get(self, "schedule_time")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SnapshotSnapshotEncryptionKey(dict):
    def __init__(__self__, *,
                 kms_key_self_link: Optional[str] = None,
                 kms_key_service_account: Optional[str] = None,
                 raw_key: Optional[str] = None,
                 sha256: Optional[str] = None):
        """
        :param str kms_key_self_link: The name of the encryption key that is stored in Google Cloud KMS.
        :param str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param str sha256: -
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[str]:
        """
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_self_link")

    @property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[str]:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "raw_key")

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        """
        -
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SnapshotSourceDiskEncryptionKey(dict):
    def __init__(__self__, *,
                 kms_key_service_account: Optional[str] = None,
                 raw_key: Optional[str] = None):
        """
        :param str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)

    @property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[str]:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "raw_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubnetworkIAMBindingCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        """
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str title: A title for the expression, i.e. a short string describing its purpose.
        :param str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubnetworkIAMMemberCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        """
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str title: A title for the expression, i.e. a short string describing its purpose.
        :param str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubnetworkLogConfig(dict):
    def __init__(__self__, *,
                 aggregation_interval: Optional[str] = None,
                 filter_expr: Optional[str] = None,
                 flow_sampling: Optional[float] = None,
                 metadata: Optional[str] = None,
                 metadata_fields: Optional[Sequence[str]] = None):
        """
        :param str aggregation_interval: Can only be specified if VPC flow logging for this subnetwork is enabled.
               Toggles the aggregation interval for collecting flow logs. Increasing the
               interval time will reduce the amount of generated flow logs for long
               lasting connections. Default is an interval of 5 seconds per connection.
               Default value is `INTERVAL_5_SEC`.
               Possible values are `INTERVAL_5_SEC`, `INTERVAL_30_SEC`, `INTERVAL_1_MIN`, `INTERVAL_5_MIN`, `INTERVAL_10_MIN`, and `INTERVAL_15_MIN`.
        :param str filter_expr: Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
               https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
               The default value is 'true', which evaluates to include everything.
        :param float flow_sampling: Can only be specified if VPC flow logging for this subnetwork is enabled.
               The value of the field must be in [0, 1]. Set the sampling rate of VPC
               flow logs within the subnetwork where 1.0 means all collected logs are
               reported and 0.0 means no logs are reported. Default is 0.5 which means
               half of all collected logs are reported.
        :param str metadata: Can only be specified if VPC flow logging for this subnetwork is enabled.
               Configures whether metadata fields should be added to the reported VPC
               flow logs.
               Default value is `INCLUDE_ALL_METADATA`.
               Possible values are `EXCLUDE_ALL_METADATA`, `INCLUDE_ALL_METADATA`, and `CUSTOM_METADATA`.
        :param Sequence[str] metadata_fields: List of metadata fields that should be added to reported logs.
               Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.
        """
        if aggregation_interval is not None:
            pulumi.set(__self__, "aggregation_interval", aggregation_interval)
        if filter_expr is not None:
            pulumi.set(__self__, "filter_expr", filter_expr)
        if flow_sampling is not None:
            pulumi.set(__self__, "flow_sampling", flow_sampling)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)

    @property
    @pulumi.getter(name="aggregationInterval")
    def aggregation_interval(self) -> Optional[str]:
        """
        Can only be specified if VPC flow logging for this subnetwork is enabled.
        Toggles the aggregation interval for collecting flow logs. Increasing the
        interval time will reduce the amount of generated flow logs for long
        lasting connections. Default is an interval of 5 seconds per connection.
        Default value is `INTERVAL_5_SEC`.
        Possible values are `INTERVAL_5_SEC`, `INTERVAL_30_SEC`, `INTERVAL_1_MIN`, `INTERVAL_5_MIN`, `INTERVAL_10_MIN`, and `INTERVAL_15_MIN`.
        """
        return pulumi.get(self, "aggregation_interval")

    @property
    @pulumi.getter(name="filterExpr")
    def filter_expr(self) -> Optional[str]:
        """
        Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
        https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
        The default value is 'true', which evaluates to include everything.
        """
        return pulumi.get(self, "filter_expr")

    @property
    @pulumi.getter(name="flowSampling")
    def flow_sampling(self) -> Optional[float]:
        """
        Can only be specified if VPC flow logging for this subnetwork is enabled.
        The value of the field must be in [0, 1]. Set the sampling rate of VPC
        flow logs within the subnetwork where 1.0 means all collected logs are
        reported and 0.0 means no logs are reported. Default is 0.5 which means
        half of all collected logs are reported.
        """
        return pulumi.get(self, "flow_sampling")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Can only be specified if VPC flow logging for this subnetwork is enabled.
        Configures whether metadata fields should be added to the reported VPC
        flow logs.
        Default value is `INCLUDE_ALL_METADATA`.
        Possible values are `EXCLUDE_ALL_METADATA`, `INCLUDE_ALL_METADATA`, and `CUSTOM_METADATA`.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[Sequence[str]]:
        """
        List of metadata fields that should be added to reported logs.
        Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.
        """
        return pulumi.get(self, "metadata_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubnetworkSecondaryIpRange(dict):
    def __init__(__self__, *,
                 ip_cidr_range: str,
                 range_name: str):
        """
        :param str ip_cidr_range: The range of IP addresses belonging to this subnetwork secondary
               range. Provide this property when you create the subnetwork.
               Ranges must be unique and non-overlapping with all primary and
               secondary IP ranges within a network. Only IPv4 is supported.
        :param str range_name: The name associated with this subnetwork secondary range, used
               when adding an alias IP range to a VM instance. The name must
               be 1-63 characters long, and comply with RFC1035. The name
               must be unique within the subnetwork.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> str:
        """
        The range of IP addresses belonging to this subnetwork secondary
        range. Provide this property when you create the subnetwork.
        Ranges must be unique and non-overlapping with all primary and
        secondary IP ranges within a network. Only IPv4 is supported.
        """
        return pulumi.get(self, "ip_cidr_range")

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        """
        The name associated with this subnetwork secondary range, used
        when adding an alias IP range to a VM instance. The name must
        be 1-63 characters long, and comply with RFC1035. The name
        must be unique within the subnetwork.
        """
        return pulumi.get(self, "range_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteAction(dict):
    def __init__(__self__, *,
                 cors_policy: Optional['outputs.URLMapDefaultRouteActionCorsPolicy'] = None,
                 fault_injection_policy: Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicy'] = None,
                 request_mirror_policy: Optional['outputs.URLMapDefaultRouteActionRequestMirrorPolicy'] = None,
                 retry_policy: Optional['outputs.URLMapDefaultRouteActionRetryPolicy'] = None,
                 timeout: Optional['outputs.URLMapDefaultRouteActionTimeout'] = None,
                 url_rewrite: Optional['outputs.URLMapDefaultRouteActionUrlRewrite'] = None,
                 weighted_backend_services: Optional[Sequence['outputs.URLMapDefaultRouteActionWeightedBackendService']] = None):
        """
        :param 'URLMapDefaultRouteActionCorsPolicyArgs' cors_policy: The specification for allowing client side cross-origin requests. Please see
               [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
               Structure is documented below.
        :param 'URLMapDefaultRouteActionFaultInjectionPolicyArgs' fault_injection_policy: The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
               As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
               percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
               by the Loadbalancer for a percentage of requests.
               timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
               Structure is documented below.
        :param 'URLMapDefaultRouteActionRequestMirrorPolicyArgs' request_mirror_policy: Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
               Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
               the host / authority header is suffixed with -shadow.
               Structure is documented below.
        :param 'URLMapDefaultRouteActionRetryPolicyArgs' retry_policy: Specifies the retry policy associated with this route.
               Structure is documented below.
        :param 'URLMapDefaultRouteActionTimeoutArgs' timeout: Specifies the timeout for the selected route. Timeout is computed from the time the request has been
               fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
               If not specified, will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param 'URLMapDefaultRouteActionUrlRewriteArgs' url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to the matched service.
               Structure is documented below.
        :param Sequence['URLMapDefaultRouteActionWeightedBackendServiceArgs'] weighted_backend_services: A list of weighted backend services to send traffic to when a route match occurs.
               The weights determine the fraction of traffic that flows to their corresponding backend service.
               If all traffic needs to go to a single backend service, there must be one weightedBackendService
               with weight set to a non 0 number.
               Once a backendService is identified and before forwarding the request to the backend service,
               advanced routing actions like Url rewrites and header transformations are applied depending on
               additional settings specified in this HttpRouteAction.
               Structure is documented below.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if fault_injection_policy is not None:
            pulumi.set(__self__, "fault_injection_policy", fault_injection_policy)
        if request_mirror_policy is not None:
            pulumi.set(__self__, "request_mirror_policy", request_mirror_policy)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)
        if weighted_backend_services is not None:
            pulumi.set(__self__, "weighted_backend_services", weighted_backend_services)

    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.URLMapDefaultRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see
        [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
        Structure is documented below.
        """
        return pulumi.get(self, "cors_policy")

    @property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
        As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
        percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
        by the Loadbalancer for a percentage of requests.
        timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
        Structure is documented below.
        """
        return pulumi.get(self, "fault_injection_policy")

    @property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.URLMapDefaultRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
        Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
        the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        return pulumi.get(self, "request_mirror_policy")

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.URLMapDefaultRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        return pulumi.get(self, "retry_policy")

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.URLMapDefaultRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time the request has been
        fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
        If not specified, will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.URLMapDefaultRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to the matched service.
        Structure is documented below.
        """
        return pulumi.get(self, "url_rewrite")

    @property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[Sequence['outputs.URLMapDefaultRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match occurs.
        The weights determine the fraction of traffic that flows to their corresponding backend service.
        If all traffic needs to go to a single backend service, there must be one weightedBackendService
        with weight set to a non 0 number.
        Once a backendService is identified and before forwarding the request to the backend service,
        advanced routing actions like Url rewrites and header transformations are applied depending on
        additional settings specified in this HttpRouteAction.
        Structure is documented below.
        """
        return pulumi.get(self, "weighted_backend_services")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionCorsPolicy(dict):
    def __init__(__self__, *,
                 allow_credentials: Optional[bool] = None,
                 allow_headers: Optional[Sequence[str]] = None,
                 allow_methods: Optional[Sequence[str]] = None,
                 allow_origin_regexes: Optional[Sequence[str]] = None,
                 allow_origins: Optional[Sequence[str]] = None,
                 disabled: Optional[bool] = None,
                 expose_headers: Optional[Sequence[str]] = None,
                 max_age: Optional[int] = None):
        """
        :param bool allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
               This translates to the Access-Control-Allow-Credentials header.
        :param Sequence[str] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param Sequence[str] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param Sequence[str] allow_origin_regexes: Specifies the regular expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[str] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param bool disabled: If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        :param Sequence[str] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param int max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin_regexes is not None:
            pulumi.set(__self__, "allow_origin_regexes", allow_origin_regexes)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
        This translates to the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[Sequence[str]]:
        """
        Specifies the regular expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origin_regexes")

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origins")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        return pulumi.get(self, "max_age")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionFaultInjectionPolicy(dict):
    def __init__(__self__, *,
                 abort: Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyAbort'] = None,
                 delay: Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyDelay'] = None):
        """
        :param 'URLMapDefaultRouteActionFaultInjectionPolicyAbortArgs' abort: The specification for how client requests are aborted as part of fault injection.
               Structure is documented below.
        :param 'URLMapDefaultRouteActionFaultInjectionPolicyDelayArgs' delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
               Structure is documented below.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @property
    @pulumi.getter
    def abort(self) -> Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        return pulumi.get(self, "abort")

    @property
    @pulumi.getter
    def delay(self) -> Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        return pulumi.get(self, "delay")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionFaultInjectionPolicyAbort(dict):
    def __init__(__self__, *,
                 http_status: Optional[int] = None,
                 percentage: Optional[float] = None):
        """
        :param int http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if http_status is not None:
            pulumi.set(__self__, "http_status", http_status)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[int]:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        return pulumi.get(self, "http_status")

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionFaultInjectionPolicyDelay(dict):
    def __init__(__self__, *,
                 fixed_delay: Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay'] = None,
                 percentage: Optional[float] = None):
        """
        :param 'URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelayArgs' fixed_delay: Specifies the value of the fixed delay interval.
               Structure is documented below.
        :param float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if fixed_delay is not None:
            pulumi.set(__self__, "fixed_delay", fixed_delay)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay']:
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_delay")

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    def __init__(__self__, *,
                 nanos: Optional[int] = None,
                 seconds: Optional[str] = None):
        """
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionRequestMirrorPolicy(dict):
    def __init__(__self__, *,
                 backend_service: str):
        """
        :param str backend_service: The full or partial URL to the BackendService resource being mirrored to.
        """
        pulumi.set(__self__, "backend_service", backend_service)

    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        return pulumi.get(self, "backend_service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionRetryPolicy(dict):
    def __init__(__self__, *,
                 num_retries: Optional[int] = None,
                 per_try_timeout: Optional['outputs.URLMapDefaultRouteActionRetryPolicyPerTryTimeout'] = None,
                 retry_conditions: Optional[Sequence[str]] = None):
        """
        :param int num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param 'URLMapDefaultRouteActionRetryPolicyPerTryTimeoutArgs' per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param Sequence[str] retry_conditions: Specfies one or more conditions when this retry rule applies. Valid values are:
               * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
               or if the backend service does not respond at all, example: disconnects, reset, read timeout,
               * connection failure, and refused streams.
               * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
               * connect-failure: Loadbalancer will retry on failures connecting to backend services,
               for example due to connection timeouts.
               * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
               This reset type indicates that it is safe to retry.
               * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
               * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
               * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
               * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_conditions is not None:
            pulumi.set(__self__, "retry_conditions", retry_conditions)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.URLMapDefaultRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "per_try_timeout")

    @property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[Sequence[str]]:
        """
        Specfies one or more conditions when this retry rule applies. Valid values are:
        * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
        or if the backend service does not respond at all, example: disconnects, reset, read timeout,
        * connection failure, and refused streams.
        * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
        * connect-failure: Loadbalancer will retry on failures connecting to backend services,
        for example due to connection timeouts.
        * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
        This reset type indicates that it is safe to retry.
        * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
        * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
        * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
        * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        return pulumi.get(self, "retry_conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionRetryPolicyPerTryTimeout(dict):
    def __init__(__self__, *,
                 nanos: Optional[int] = None,
                 seconds: Optional[str] = None):
        """
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionTimeout(dict):
    def __init__(__self__, *,
                 nanos: Optional[int] = None,
                 seconds: Optional[str] = None):
        """
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionUrlRewrite(dict):
    def __init__(__self__, *,
                 host_rewrite: Optional[str] = None,
                 path_prefix_rewrite: Optional[str] = None):
        """
        :param str host_rewrite: Prior to forwarding the request to the selected service, the request's host header is replaced
               with contents of hostRewrite.
               The value must be between 1 and 255 characters.
        :param str path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching portion of the
               request's path is replaced by pathPrefixRewrite.
               The value must be between 1 and 1024 characters.
        """
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if path_prefix_rewrite is not None:
            pulumi.set(__self__, "path_prefix_rewrite", path_prefix_rewrite)

    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected service, the request's host header is replaced
        with contents of hostRewrite.
        The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_rewrite")

    @property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected backend service, the matching portion of the
        request's path is replaced by pathPrefixRewrite.
        The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "path_prefix_rewrite")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionWeightedBackendService(dict):
    def __init__(__self__, *,
                 backend_service: Optional[str] = None,
                 header_action: Optional['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderAction'] = None,
                 weight: Optional[int] = None):
        """
        :param str backend_service: The full or partial URL to the BackendService resource being mirrored to.
        :param 'URLMapDefaultRouteActionWeightedBackendServiceHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.
               Structure is documented below.
        :param int weight: Specifies the fraction of traffic sent to backendService, computed as
               weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request
               has been directed to a backendService, subsequent requests will be sent to the same backendService
               as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        """
        if backend_service is not None:
            pulumi.set(__self__, "backend_service", backend_service)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> Optional[str]:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        return pulumi.get(self, "backend_service")

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Specifies the fraction of traffic sent to backendService, computed as
        weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request
        has been directed to a backendService, subsequent requests will be sent to the same backendService
        as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionWeightedBackendServiceHeaderAction(dict):
    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[str]] = None):
        """
        :param Sequence['URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[str] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param Sequence['URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[str] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: Optional[str] = None,
                 header_value: Optional[str] = None,
                 replace: Optional[bool] = None):
        """
        :param str header_name: The name of the header to add.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> Optional[bool]:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: Optional[str] = None,
                 header_value: Optional[str] = None,
                 replace: Optional[bool] = None):
        """
        :param str header_name: The name of the header to add.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> Optional[bool]:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapDefaultUrlRedirect(dict):
    def __init__(__self__, *,
                 strip_query: bool,
                 host_redirect: Optional[str] = None,
                 https_redirect: Optional[bool] = None,
                 path_redirect: Optional[str] = None,
                 prefix_redirect: Optional[str] = None,
                 redirect_response_code: Optional[str] = None):
        """
        :param bool strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained. The default is set to false.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param str host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param bool https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param str path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param str prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        pulumi.set(__self__, "strip_query", strip_query)
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained. The default is set to false.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        return pulumi.get(self, "strip_query")

    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_redirect")

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        return pulumi.get(self, "https_redirect")

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        return pulumi.get(self, "path_redirect")

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "prefix_redirect")

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapHeaderAction(dict):
    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.URLMapHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.URLMapHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[str]] = None):
        """
        :param Sequence['URLMapHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[str] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param Sequence['URLMapHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[str] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapHeaderActionRequestHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header to add.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapHeaderActionResponseHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header to add.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapHostRule(dict):
    def __init__(__self__, *,
                 hosts: Sequence[str],
                 path_matcher: str,
                 description: Optional[str] = None):
        """
        :param Sequence[str] hosts: The list of host patterns to match. They must be valid hostnames, except * will
               match any string of ([a-z0-9-.]*). In that case, * must be the first character
               and must be followed in the pattern by either - or ..
        :param str path_matcher: The name of the PathMatcher to use to match the path portion of the URL if the
               hostRule matches the URL's host portion.
        :param str description: Description of this test case.
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "path_matcher", path_matcher)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def hosts(self) -> Sequence[str]:
        """
        The list of host patterns to match. They must be valid hostnames, except * will
        match any string of ([a-z0-9-.]*). In that case, * must be the first character
        and must be followed in the pattern by either - or ..
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter(name="pathMatcher")
    def path_matcher(self) -> str:
        """
        The name of the PathMatcher to use to match the path portion of the URL if the
        hostRule matches the URL's host portion.
        """
        return pulumi.get(self, "path_matcher")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this test case.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcher(dict):
    def __init__(__self__, *,
                 name: str,
                 default_route_action: Optional['outputs.URLMapPathMatcherDefaultRouteAction'] = None,
                 default_service: Optional[str] = None,
                 default_url_redirect: Optional['outputs.URLMapPathMatcherDefaultUrlRedirect'] = None,
                 description: Optional[str] = None,
                 header_action: Optional['outputs.URLMapPathMatcherHeaderAction'] = None,
                 path_rules: Optional[Sequence['outputs.URLMapPathMatcherPathRule']] = None,
                 route_rules: Optional[Sequence['outputs.URLMapPathMatcherRouteRule']] = None):
        """
        :param str name: The name of the query parameter to match. The query parameter must exist in the
               request, in the absence of which the request match fails.
        :param 'URLMapPathMatcherDefaultRouteActionArgs' default_route_action: defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
               advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
               to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
               Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
               Only one of defaultRouteAction or defaultUrlRedirect must be set.
               Structure is documented below.
        :param str default_service: The backend service or backend bucket to use when none of the given paths match.
        :param 'URLMapPathMatcherDefaultUrlRedirectArgs' default_url_redirect: When none of the specified hostRules match, the request is redirected to a URL specified
               by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
               defaultRouteAction must not be set.
               Structure is documented below.
        :param str description: Description of this test case.
        :param 'URLMapPathMatcherHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.
               Structure is documented below.
        :param Sequence['URLMapPathMatcherPathRuleArgs'] path_rules: The list of path rules. Use this list instead of routeRules when routing based
               on simple path matching is all that's required. The order by which path rules
               are specified does not matter. Matches are always done on the longest-path-first
               basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
               irrespective of the order in which those paths appear in this list. Within a
               given pathMatcher, only one of pathRules or routeRules must be set.
               Structure is documented below.
        :param Sequence['URLMapPathMatcherRouteRuleArgs'] route_rules: The list of ordered HTTP route rules. Use this list instead of pathRules when
               advanced route matching and routing actions are desired. The order of specifying
               routeRules matters: the first rule that matches will cause its specified routing
               action to take effect. Within a given pathMatcher, only one of pathRules or
               routeRules must be set. routeRules are not supported in UrlMaps intended for
               External load balancers.
               Structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        if default_route_action is not None:
            pulumi.set(__self__, "default_route_action", default_route_action)
        if default_service is not None:
            pulumi.set(__self__, "default_service", default_service)
        if default_url_redirect is not None:
            pulumi.set(__self__, "default_url_redirect", default_url_redirect)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)
        if path_rules is not None:
            pulumi.set(__self__, "path_rules", path_rules)
        if route_rules is not None:
            pulumi.set(__self__, "route_rules", route_rules)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query parameter to match. The query parameter must exist in the
        request, in the absence of which the request match fails.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="defaultRouteAction")
    def default_route_action(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteAction']:
        """
        defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
        advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
        to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
        Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
        Only one of defaultRouteAction or defaultUrlRedirect must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "default_route_action")

    @property
    @pulumi.getter(name="defaultService")
    def default_service(self) -> Optional[str]:
        """
        The backend service or backend bucket to use when none of the given paths match.
        """
        return pulumi.get(self, "default_service")

    @property
    @pulumi.getter(name="defaultUrlRedirect")
    def default_url_redirect(self) -> Optional['outputs.URLMapPathMatcherDefaultUrlRedirect']:
        """
        When none of the specified hostRules match, the request is redirected to a URL specified
        by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
        defaultRouteAction must not be set.
        Structure is documented below.
        """
        return pulumi.get(self, "default_url_redirect")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this test case.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    @property
    @pulumi.getter(name="pathRules")
    def path_rules(self) -> Optional[Sequence['outputs.URLMapPathMatcherPathRule']]:
        """
        The list of path rules. Use this list instead of routeRules when routing based
        on simple path matching is all that's required. The order by which path rules
        are specified does not matter. Matches are always done on the longest-path-first
        basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
        irrespective of the order in which those paths appear in this list. Within a
        given pathMatcher, only one of pathRules or routeRules must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "path_rules")

    @property
    @pulumi.getter(name="routeRules")
    def route_rules(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRule']]:
        """
        The list of ordered HTTP route rules. Use this list instead of pathRules when
        advanced route matching and routing actions are desired. The order of specifying
        routeRules matters: the first rule that matches will cause its specified routing
        action to take effect. Within a given pathMatcher, only one of pathRules or
        routeRules must be set. routeRules are not supported in UrlMaps intended for
        External load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "route_rules")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteAction(dict):
    def __init__(__self__, *,
                 cors_policy: Optional['outputs.URLMapPathMatcherDefaultRouteActionCorsPolicy'] = None,
                 fault_injection_policy: Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicy'] = None,
                 request_mirror_policy: Optional['outputs.URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy'] = None,
                 retry_policy: Optional['outputs.URLMapPathMatcherDefaultRouteActionRetryPolicy'] = None,
                 timeout: Optional['outputs.URLMapPathMatcherDefaultRouteActionTimeout'] = None,
                 url_rewrite: Optional['outputs.URLMapPathMatcherDefaultRouteActionUrlRewrite'] = None,
                 weighted_backend_services: Optional[Sequence['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendService']] = None):
        """
        :param 'URLMapPathMatcherDefaultRouteActionCorsPolicyArgs' cors_policy: The specification for allowing client side cross-origin requests. Please see
               [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
               Structure is documented below.
        :param 'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyArgs' fault_injection_policy: The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
               As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
               percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
               by the Loadbalancer for a percentage of requests.
               timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
               Structure is documented below.
        :param 'URLMapPathMatcherDefaultRouteActionRequestMirrorPolicyArgs' request_mirror_policy: Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
               Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
               the host / authority header is suffixed with -shadow.
               Structure is documented below.
        :param 'URLMapPathMatcherDefaultRouteActionRetryPolicyArgs' retry_policy: Specifies the retry policy associated with this route.
               Structure is documented below.
        :param 'URLMapPathMatcherDefaultRouteActionTimeoutArgs' timeout: Specifies the timeout for the selected route. Timeout is computed from the time the request has been
               fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
               If not specified, will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param 'URLMapPathMatcherDefaultRouteActionUrlRewriteArgs' url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to the matched service.
               Structure is documented below.
        :param Sequence['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceArgs'] weighted_backend_services: A list of weighted backend services to send traffic to when a route match occurs.
               The weights determine the fraction of traffic that flows to their corresponding backend service.
               If all traffic needs to go to a single backend service, there must be one weightedBackendService
               with weight set to a non 0 number.
               Once a backendService is identified and before forwarding the request to the backend service,
               advanced routing actions like Url rewrites and header transformations are applied depending on
               additional settings specified in this HttpRouteAction.
               Structure is documented below.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if fault_injection_policy is not None:
            pulumi.set(__self__, "fault_injection_policy", fault_injection_policy)
        if request_mirror_policy is not None:
            pulumi.set(__self__, "request_mirror_policy", request_mirror_policy)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)
        if weighted_backend_services is not None:
            pulumi.set(__self__, "weighted_backend_services", weighted_backend_services)

    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see
        [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
        Structure is documented below.
        """
        return pulumi.get(self, "cors_policy")

    @property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
        As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
        percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
        by the Loadbalancer for a percentage of requests.
        timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
        Structure is documented below.
        """
        return pulumi.get(self, "fault_injection_policy")

    @property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
        Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
        the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        return pulumi.get(self, "request_mirror_policy")

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        return pulumi.get(self, "retry_policy")

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time the request has been
        fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
        If not specified, will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to the matched service.
        Structure is documented below.
        """
        return pulumi.get(self, "url_rewrite")

    @property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[Sequence['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match occurs.
        The weights determine the fraction of traffic that flows to their corresponding backend service.
        If all traffic needs to go to a single backend service, there must be one weightedBackendService
        with weight set to a non 0 number.
        Once a backendService is identified and before forwarding the request to the backend service,
        advanced routing actions like Url rewrites and header transformations are applied depending on
        additional settings specified in this HttpRouteAction.
        Structure is documented below.
        """
        return pulumi.get(self, "weighted_backend_services")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionCorsPolicy(dict):
    def __init__(__self__, *,
                 allow_credentials: Optional[bool] = None,
                 allow_headers: Optional[Sequence[str]] = None,
                 allow_methods: Optional[Sequence[str]] = None,
                 allow_origin_regexes: Optional[Sequence[str]] = None,
                 allow_origins: Optional[Sequence[str]] = None,
                 disabled: Optional[bool] = None,
                 expose_headers: Optional[Sequence[str]] = None,
                 max_age: Optional[int] = None):
        """
        :param bool allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
               This translates to the Access-Control-Allow-Credentials header.
        :param Sequence[str] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param Sequence[str] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param Sequence[str] allow_origin_regexes: Specifies the regular expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[str] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param bool disabled: If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        :param Sequence[str] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param int max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin_regexes is not None:
            pulumi.set(__self__, "allow_origin_regexes", allow_origin_regexes)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
        This translates to the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[Sequence[str]]:
        """
        Specifies the regular expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origin_regexes")

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origins")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        return pulumi.get(self, "max_age")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicy(dict):
    def __init__(__self__, *,
                 abort: Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort'] = None,
                 delay: Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay'] = None):
        """
        :param 'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbortArgs' abort: The specification for how client requests are aborted as part of fault injection.
               Structure is documented below.
        :param 'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayArgs' delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
               Structure is documented below.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @property
    @pulumi.getter
    def abort(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        return pulumi.get(self, "abort")

    @property
    @pulumi.getter
    def delay(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        return pulumi.get(self, "delay")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort(dict):
    def __init__(__self__, *,
                 http_status: Optional[int] = None,
                 percentage: Optional[float] = None):
        """
        :param int http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if http_status is not None:
            pulumi.set(__self__, "http_status", http_status)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[int]:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        return pulumi.get(self, "http_status")

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay(dict):
    def __init__(__self__, *,
                 fixed_delay: Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay'] = None,
                 percentage: Optional[float] = None):
        """
        :param 'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayArgs' fixed_delay: Specifies the value of the fixed delay interval.
               Structure is documented below.
        :param float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if fixed_delay is not None:
            pulumi.set(__self__, "fixed_delay", fixed_delay)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay']:
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_delay")

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    def __init__(__self__, *,
                 nanos: Optional[int] = None,
                 seconds: Optional[str] = None):
        """
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy(dict):
    def __init__(__self__, *,
                 backend_service: str):
        """
        :param str backend_service: The full or partial URL to the BackendService resource being mirrored to.
        """
        pulumi.set(__self__, "backend_service", backend_service)

    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        return pulumi.get(self, "backend_service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionRetryPolicy(dict):
    def __init__(__self__, *,
                 num_retries: Optional[int] = None,
                 per_try_timeout: Optional['outputs.URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout'] = None,
                 retry_conditions: Optional[Sequence[str]] = None):
        """
        :param int num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param 'URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutArgs' per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param Sequence[str] retry_conditions: Specfies one or more conditions when this retry rule applies. Valid values are:
               * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
               or if the backend service does not respond at all, example: disconnects, reset, read timeout,
               * connection failure, and refused streams.
               * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
               * connect-failure: Loadbalancer will retry on failures connecting to backend services,
               for example due to connection timeouts.
               * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
               This reset type indicates that it is safe to retry.
               * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
               * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
               * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
               * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_conditions is not None:
            pulumi.set(__self__, "retry_conditions", retry_conditions)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "per_try_timeout")

    @property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[Sequence[str]]:
        """
        Specfies one or more conditions when this retry rule applies. Valid values are:
        * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
        or if the backend service does not respond at all, example: disconnects, reset, read timeout,
        * connection failure, and refused streams.
        * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
        * connect-failure: Loadbalancer will retry on failures connecting to backend services,
        for example due to connection timeouts.
        * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
        This reset type indicates that it is safe to retry.
        * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
        * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
        * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
        * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        return pulumi.get(self, "retry_conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout(dict):
    def __init__(__self__, *,
                 nanos: Optional[int] = None,
                 seconds: Optional[str] = None):
        """
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionTimeout(dict):
    def __init__(__self__, *,
                 nanos: Optional[int] = None,
                 seconds: Optional[str] = None):
        """
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionUrlRewrite(dict):
    def __init__(__self__, *,
                 host_rewrite: Optional[str] = None,
                 path_prefix_rewrite: Optional[str] = None):
        """
        :param str host_rewrite: Prior to forwarding the request to the selected service, the request's host header is replaced
               with contents of hostRewrite.
               The value must be between 1 and 255 characters.
        :param str path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching portion of the
               request's path is replaced by pathPrefixRewrite.
               The value must be between 1 and 1024 characters.
        """
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if path_prefix_rewrite is not None:
            pulumi.set(__self__, "path_prefix_rewrite", path_prefix_rewrite)

    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected service, the request's host header is replaced
        with contents of hostRewrite.
        The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_rewrite")

    @property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected backend service, the matching portion of the
        request's path is replaced by pathPrefixRewrite.
        The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "path_prefix_rewrite")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendService(dict):
    def __init__(__self__, *,
                 backend_service: Optional[str] = None,
                 header_action: Optional['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction'] = None,
                 weight: Optional[int] = None):
        """
        :param str backend_service: The full or partial URL to the BackendService resource being mirrored to.
        :param 'URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.
               Structure is documented below.
        :param int weight: Specifies the fraction of traffic sent to backendService, computed as
               weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request
               has been directed to a backendService, subsequent requests will be sent to the same backendService
               as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        """
        if backend_service is not None:
            pulumi.set(__self__, "backend_service", backend_service)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> Optional[str]:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        return pulumi.get(self, "backend_service")

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Specifies the fraction of traffic sent to backendService, computed as
        weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request
        has been directed to a backendService, subsequent requests will be sent to the same backendService
        as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction(dict):
    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[str]] = None):
        """
        :param Sequence['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[str] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param Sequence['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[str] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: Optional[str] = None,
                 header_value: Optional[str] = None,
                 replace: Optional[bool] = None):
        """
        :param str header_name: The name of the header to add.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> Optional[bool]:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: Optional[str] = None,
                 header_value: Optional[str] = None,
                 replace: Optional[bool] = None):
        """
        :param str header_name: The name of the header to add.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> Optional[bool]:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherDefaultUrlRedirect(dict):
    def __init__(__self__, *,
                 strip_query: bool,
                 host_redirect: Optional[str] = None,
                 https_redirect: Optional[bool] = None,
                 path_redirect: Optional[str] = None,
                 prefix_redirect: Optional[str] = None,
                 redirect_response_code: Optional[str] = None):
        """
        :param bool strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained. The default is set to false.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param str host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param bool https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param str path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param str prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        pulumi.set(__self__, "strip_query", strip_query)
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained. The default is set to false.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        return pulumi.get(self, "strip_query")

    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_redirect")

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        return pulumi.get(self, "https_redirect")

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        return pulumi.get(self, "path_redirect")

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "prefix_redirect")

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherHeaderAction(dict):
    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[str]] = None):
        """
        :param Sequence['URLMapPathMatcherHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[str] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param Sequence['URLMapPathMatcherHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[str] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherHeaderActionRequestHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header to add.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherHeaderActionResponseHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header to add.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRule(dict):
    def __init__(__self__, *,
                 paths: Sequence[str],
                 route_action: Optional['outputs.URLMapPathMatcherPathRuleRouteAction'] = None,
                 service: Optional[str] = None,
                 url_redirect: Optional['outputs.URLMapPathMatcherPathRuleUrlRedirect'] = None):
        """
        :param Sequence[str] paths: The list of path patterns to match. Each must start with / and the only place a
               * is allowed is at the end following a /. The string fed to the path matcher
               does not include any text after the first ? or #, and those chars are not
               allowed here.
        :param 'URLMapPathMatcherPathRuleRouteActionArgs' route_action: In response to a matching matchRule, the load balancer performs advanced routing
               actions like URL rewrites, header transformations, etc. prior to forwarding the
               request to the selected backend. If  routeAction specifies any
               weightedBackendServices, service must not be set. Conversely if service is set,
               routeAction cannot contain any  weightedBackendServices. Only one of routeAction
               or urlRedirect must be set.
               Structure is documented below.
        :param str service: The backend service or backend bucket link that should be matched by this test.
        :param 'URLMapPathMatcherPathRuleUrlRedirectArgs' url_redirect: When this rule is matched, the request is redirected to a URL specified by
               urlRedirect. If urlRedirect is specified, service or routeAction must not be
               set.
               Structure is documented below.
        """
        pulumi.set(__self__, "paths", paths)
        if route_action is not None:
            pulumi.set(__self__, "route_action", route_action)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if url_redirect is not None:
            pulumi.set(__self__, "url_redirect", url_redirect)

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        The list of path patterns to match. Each must start with / and the only place a
        * is allowed is at the end following a /. The string fed to the path matcher
        does not include any text after the first ? or #, and those chars are not
        allowed here.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="routeAction")
    def route_action(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteAction']:
        """
        In response to a matching matchRule, the load balancer performs advanced routing
        actions like URL rewrites, header transformations, etc. prior to forwarding the
        request to the selected backend. If  routeAction specifies any
        weightedBackendServices, service must not be set. Conversely if service is set,
        routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        or urlRedirect must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "route_action")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The backend service or backend bucket link that should be matched by this test.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="urlRedirect")
    def url_redirect(self) -> Optional['outputs.URLMapPathMatcherPathRuleUrlRedirect']:
        """
        When this rule is matched, the request is redirected to a URL specified by
        urlRedirect. If urlRedirect is specified, service or routeAction must not be
        set.
        Structure is documented below.
        """
        return pulumi.get(self, "url_redirect")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteAction(dict):
    def __init__(__self__, *,
                 cors_policy: Optional['outputs.URLMapPathMatcherPathRuleRouteActionCorsPolicy'] = None,
                 fault_injection_policy: Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy'] = None,
                 request_mirror_policy: Optional['outputs.URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy'] = None,
                 retry_policy: Optional['outputs.URLMapPathMatcherPathRuleRouteActionRetryPolicy'] = None,
                 timeout: Optional['outputs.URLMapPathMatcherPathRuleRouteActionTimeout'] = None,
                 url_rewrite: Optional['outputs.URLMapPathMatcherPathRuleRouteActionUrlRewrite'] = None,
                 weighted_backend_services: Optional[Sequence['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendService']] = None):
        """
        :param 'URLMapPathMatcherPathRuleRouteActionCorsPolicyArgs' cors_policy: The specification for allowing client side cross-origin requests. Please see
               [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
               Structure is documented below.
        :param 'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyArgs' fault_injection_policy: The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
               As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
               percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
               by the Loadbalancer for a percentage of requests.
               timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
               Structure is documented below.
        :param 'URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicyArgs' request_mirror_policy: Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
               Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
               the host / authority header is suffixed with -shadow.
               Structure is documented below.
        :param 'URLMapPathMatcherPathRuleRouteActionRetryPolicyArgs' retry_policy: Specifies the retry policy associated with this route.
               Structure is documented below.
        :param 'URLMapPathMatcherPathRuleRouteActionTimeoutArgs' timeout: Specifies the timeout for the selected route. Timeout is computed from the time the request has been
               fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
               If not specified, will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param 'URLMapPathMatcherPathRuleRouteActionUrlRewriteArgs' url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to the matched service.
               Structure is documented below.
        :param Sequence['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceArgs'] weighted_backend_services: A list of weighted backend services to send traffic to when a route match occurs.
               The weights determine the fraction of traffic that flows to their corresponding backend service.
               If all traffic needs to go to a single backend service, there must be one weightedBackendService
               with weight set to a non 0 number.
               Once a backendService is identified and before forwarding the request to the backend service,
               advanced routing actions like Url rewrites and header transformations are applied depending on
               additional settings specified in this HttpRouteAction.
               Structure is documented below.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if fault_injection_policy is not None:
            pulumi.set(__self__, "fault_injection_policy", fault_injection_policy)
        if request_mirror_policy is not None:
            pulumi.set(__self__, "request_mirror_policy", request_mirror_policy)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)
        if weighted_backend_services is not None:
            pulumi.set(__self__, "weighted_backend_services", weighted_backend_services)

    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see
        [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
        Structure is documented below.
        """
        return pulumi.get(self, "cors_policy")

    @property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
        As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
        percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
        by the Loadbalancer for a percentage of requests.
        timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
        Structure is documented below.
        """
        return pulumi.get(self, "fault_injection_policy")

    @property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
        Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
        the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        return pulumi.get(self, "request_mirror_policy")

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        return pulumi.get(self, "retry_policy")

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time the request has been
        fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
        If not specified, will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to the matched service.
        Structure is documented below.
        """
        return pulumi.get(self, "url_rewrite")

    @property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[Sequence['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match occurs.
        The weights determine the fraction of traffic that flows to their corresponding backend service.
        If all traffic needs to go to a single backend service, there must be one weightedBackendService
        with weight set to a non 0 number.
        Once a backendService is identified and before forwarding the request to the backend service,
        advanced routing actions like Url rewrites and header transformations are applied depending on
        additional settings specified in this HttpRouteAction.
        Structure is documented below.
        """
        return pulumi.get(self, "weighted_backend_services")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionCorsPolicy(dict):
    def __init__(__self__, *,
                 disabled: bool,
                 allow_credentials: Optional[bool] = None,
                 allow_headers: Optional[Sequence[str]] = None,
                 allow_methods: Optional[Sequence[str]] = None,
                 allow_origin_regexes: Optional[Sequence[str]] = None,
                 allow_origins: Optional[Sequence[str]] = None,
                 expose_headers: Optional[Sequence[str]] = None,
                 max_age: Optional[int] = None):
        """
        :param bool disabled: If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        :param bool allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
               This translates to the Access-Control-Allow-Credentials header.
        :param Sequence[str] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param Sequence[str] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param Sequence[str] allow_origin_regexes: Specifies the regular expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[str] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[str] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param int max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        pulumi.set(__self__, "disabled", disabled)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin_regexes is not None:
            pulumi.set(__self__, "allow_origin_regexes", allow_origin_regexes)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
        This translates to the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[Sequence[str]]:
        """
        Specifies the regular expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origin_regexes")

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origins")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        return pulumi.get(self, "max_age")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy(dict):
    def __init__(__self__, *,
                 abort: Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort'] = None,
                 delay: Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay'] = None):
        """
        :param 'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortArgs' abort: The specification for how client requests are aborted as part of fault injection.
               Structure is documented below.
        :param 'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayArgs' delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
               Structure is documented below.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @property
    @pulumi.getter
    def abort(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        return pulumi.get(self, "abort")

    @property
    @pulumi.getter
    def delay(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        return pulumi.get(self, "delay")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort(dict):
    def __init__(__self__, *,
                 http_status: int,
                 percentage: float):
        """
        :param int http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        pulumi.set(__self__, "http_status", http_status)
        pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> int:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        return pulumi.get(self, "http_status")

    @property
    @pulumi.getter
    def percentage(self) -> float:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay(dict):
    def __init__(__self__, *,
                 fixed_delay: 'outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
                 percentage: float):
        """
        :param 'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs' fixed_delay: Specifies the value of the fixed delay interval.
               Structure is documented below.
        :param float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        pulumi.set(__self__, "fixed_delay", fixed_delay)
        pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> 'outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay':
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_delay")

    @property
    @pulumi.getter
    def percentage(self) -> float:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    def __init__(__self__, *,
                 seconds: str,
                 nanos: Optional[int] = None):
        """
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy(dict):
    def __init__(__self__, *,
                 backend_service: str):
        """
        :param str backend_service: The full or partial URL to the BackendService resource being mirrored to.
        """
        pulumi.set(__self__, "backend_service", backend_service)

    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        return pulumi.get(self, "backend_service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionRetryPolicy(dict):
    def __init__(__self__, *,
                 num_retries: Optional[int] = None,
                 per_try_timeout: Optional['outputs.URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout'] = None,
                 retry_conditions: Optional[Sequence[str]] = None):
        """
        :param int num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param 'URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutArgs' per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param Sequence[str] retry_conditions: Specfies one or more conditions when this retry rule applies. Valid values are:
               * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
               or if the backend service does not respond at all, example: disconnects, reset, read timeout,
               * connection failure, and refused streams.
               * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
               * connect-failure: Loadbalancer will retry on failures connecting to backend services,
               for example due to connection timeouts.
               * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
               This reset type indicates that it is safe to retry.
               * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
               * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
               * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
               * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_conditions is not None:
            pulumi.set(__self__, "retry_conditions", retry_conditions)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "per_try_timeout")

    @property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[Sequence[str]]:
        """
        Specfies one or more conditions when this retry rule applies. Valid values are:
        * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
        or if the backend service does not respond at all, example: disconnects, reset, read timeout,
        * connection failure, and refused streams.
        * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
        * connect-failure: Loadbalancer will retry on failures connecting to backend services,
        for example due to connection timeouts.
        * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
        This reset type indicates that it is safe to retry.
        * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
        * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
        * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
        * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        return pulumi.get(self, "retry_conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout(dict):
    def __init__(__self__, *,
                 seconds: str,
                 nanos: Optional[int] = None):
        """
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionTimeout(dict):
    def __init__(__self__, *,
                 seconds: str,
                 nanos: Optional[int] = None):
        """
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionUrlRewrite(dict):
    def __init__(__self__, *,
                 host_rewrite: Optional[str] = None,
                 path_prefix_rewrite: Optional[str] = None):
        """
        :param str host_rewrite: Prior to forwarding the request to the selected service, the request's host header is replaced
               with contents of hostRewrite.
               The value must be between 1 and 255 characters.
        :param str path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching portion of the
               request's path is replaced by pathPrefixRewrite.
               The value must be between 1 and 1024 characters.
        """
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if path_prefix_rewrite is not None:
            pulumi.set(__self__, "path_prefix_rewrite", path_prefix_rewrite)

    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected service, the request's host header is replaced
        with contents of hostRewrite.
        The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_rewrite")

    @property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected backend service, the matching portion of the
        request's path is replaced by pathPrefixRewrite.
        The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "path_prefix_rewrite")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendService(dict):
    def __init__(__self__, *,
                 backend_service: str,
                 weight: int,
                 header_action: Optional['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction'] = None):
        """
        :param str backend_service: The full or partial URL to the BackendService resource being mirrored to.
        :param int weight: Specifies the fraction of traffic sent to backendService, computed as
               weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request
               has been directed to a backendService, subsequent requests will be sent to the same backendService
               as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        :param 'URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.
               Structure is documented below.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        pulumi.set(__self__, "weight", weight)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)

    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        return pulumi.get(self, "backend_service")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Specifies the fraction of traffic sent to backendService, computed as
        weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request
        has been directed to a backendService, subsequent requests will be sent to the same backendService
        as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction(dict):
    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[str]] = None):
        """
        :param Sequence['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[str] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param Sequence['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[str] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header to add.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header to add.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherPathRuleUrlRedirect(dict):
    def __init__(__self__, *,
                 strip_query: bool,
                 host_redirect: Optional[str] = None,
                 https_redirect: Optional[bool] = None,
                 path_redirect: Optional[str] = None,
                 prefix_redirect: Optional[str] = None,
                 redirect_response_code: Optional[str] = None):
        """
        :param bool strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained. The default is set to false.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param str host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param bool https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param str path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param str prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        pulumi.set(__self__, "strip_query", strip_query)
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained. The default is set to false.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        return pulumi.get(self, "strip_query")

    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_redirect")

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        return pulumi.get(self, "https_redirect")

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        return pulumi.get(self, "path_redirect")

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "prefix_redirect")

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRule(dict):
    def __init__(__self__, *,
                 priority: int,
                 header_action: Optional['outputs.URLMapPathMatcherRouteRuleHeaderAction'] = None,
                 match_rules: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRule']] = None,
                 route_action: Optional['outputs.URLMapPathMatcherRouteRuleRouteAction'] = None,
                 service: Optional[str] = None,
                 url_redirect: Optional['outputs.URLMapPathMatcherRouteRuleUrlRedirect'] = None):
        """
        :param int priority: For routeRules within a given pathMatcher, priority determines the order
               in which load balancer will interpret routeRules. RouteRules are evaluated
               in order of priority, from the lowest to highest number. The priority of
               a rule decreases as its number increases (1, 2, 3, N+1). The first rule
               that matches the request is applied.
               You cannot configure two or more routeRules with the same priority.
               Priority for each rule must be set to a number between 0 and
               2147483647 inclusive.
               Priority numbers can have gaps, which enable you to add or remove rules
               in the future without affecting the rest of the rules. For example,
               1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
               you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
               future without any impact on existing rules.
        :param 'URLMapPathMatcherRouteRuleHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.
               Structure is documented below.
        :param Sequence['URLMapPathMatcherRouteRuleMatchRuleArgs'] match_rules: The rules for determining a match.
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionArgs' route_action: In response to a matching matchRule, the load balancer performs advanced routing
               actions like URL rewrites, header transformations, etc. prior to forwarding the
               request to the selected backend. If  routeAction specifies any
               weightedBackendServices, service must not be set. Conversely if service is set,
               routeAction cannot contain any  weightedBackendServices. Only one of routeAction
               or urlRedirect must be set.
               Structure is documented below.
        :param str service: The backend service or backend bucket link that should be matched by this test.
        :param 'URLMapPathMatcherRouteRuleUrlRedirectArgs' url_redirect: When this rule is matched, the request is redirected to a URL specified by
               urlRedirect. If urlRedirect is specified, service or routeAction must not be
               set.
               Structure is documented below.
        """
        pulumi.set(__self__, "priority", priority)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)
        if match_rules is not None:
            pulumi.set(__self__, "match_rules", match_rules)
        if route_action is not None:
            pulumi.set(__self__, "route_action", route_action)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if url_redirect is not None:
            pulumi.set(__self__, "url_redirect", url_redirect)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        For routeRules within a given pathMatcher, priority determines the order
        in which load balancer will interpret routeRules. RouteRules are evaluated
        in order of priority, from the lowest to highest number. The priority of
        a rule decreases as its number increases (1, 2, 3, N+1). The first rule
        that matches the request is applied.
        You cannot configure two or more routeRules with the same priority.
        Priority for each rule must be set to a number between 0 and
        2147483647 inclusive.
        Priority numbers can have gaps, which enable you to add or remove rules
        in the future without affecting the rest of the rules. For example,
        1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
        you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
        future without any impact on existing rules.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherRouteRuleHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRule']]:
        """
        The rules for determining a match.
        Structure is documented below.
        """
        return pulumi.get(self, "match_rules")

    @property
    @pulumi.getter(name="routeAction")
    def route_action(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteAction']:
        """
        In response to a matching matchRule, the load balancer performs advanced routing
        actions like URL rewrites, header transformations, etc. prior to forwarding the
        request to the selected backend. If  routeAction specifies any
        weightedBackendServices, service must not be set. Conversely if service is set,
        routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        or urlRedirect must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "route_action")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The backend service or backend bucket link that should be matched by this test.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="urlRedirect")
    def url_redirect(self) -> Optional['outputs.URLMapPathMatcherRouteRuleUrlRedirect']:
        """
        When this rule is matched, the request is redirected to a URL specified by
        urlRedirect. If urlRedirect is specified, service or routeAction must not be
        set.
        Structure is documented below.
        """
        return pulumi.get(self, "url_redirect")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleHeaderAction(dict):
    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[str]] = None):
        """
        :param Sequence['URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[str] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param Sequence['URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[str] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header to add.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header to add.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRule(dict):
    def __init__(__self__, *,
                 full_path_match: Optional[str] = None,
                 header_matches: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleHeaderMatch']] = None,
                 ignore_case: Optional[bool] = None,
                 metadata_filters: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleMetadataFilter']] = None,
                 prefix_match: Optional[str] = None,
                 query_parameter_matches: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch']] = None,
                 regex_match: Optional[str] = None):
        """
        :param str full_path_match: For satisfying the matchRule condition, the path of the request must exactly
               match the value specified in fullPathMatch after removing any query parameters
               and anchor that may be part of the original URL. FullPathMatch must be between 1
               and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
               be specified.
        :param Sequence['URLMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs'] header_matches: Specifies a list of header match criteria, all of which must match corresponding
               headers in the request.
               Structure is documented below.
        :param bool ignore_case: Specifies that prefixMatch and fullPathMatch matches are case sensitive.
               Defaults to false.
        :param Sequence['URLMapPathMatcherRouteRuleMatchRuleMetadataFilterArgs'] metadata_filters: Opaque filter criteria used by Loadbalancer to restrict routing configuration to
               a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
               clients present node metadata. If a match takes place, the relevant routing
               configuration is made available to those proxies. For each metadataFilter in
               this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
               filterLabels must match the corresponding label provided in the metadata. If its
               filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
               with corresponding labels in the provided metadata. metadataFilters specified
               here can be overrides those specified in ForwardingRule that refers to this
               UrlMap. metadataFilters only applies to Loadbalancers that have their
               loadBalancingScheme set to INTERNAL_SELF_MANAGED.
               Structure is documented below.
        :param str prefix_match: The value of the header must start with the contents of prefixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        :param Sequence['URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs'] query_parameter_matches: Specifies a list of query parameter match criteria, all of which must match
               corresponding query parameters in the request.
               Structure is documented below.
        :param str regex_match: The queryParameterMatch matches if the value of the parameter matches the
               regular expression specified by regexMatch. For the regular expression grammar,
               please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
               exactMatch and regexMatch must be set.
        """
        if full_path_match is not None:
            pulumi.set(__self__, "full_path_match", full_path_match)
        if header_matches is not None:
            pulumi.set(__self__, "header_matches", header_matches)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if metadata_filters is not None:
            pulumi.set(__self__, "metadata_filters", metadata_filters)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if query_parameter_matches is not None:
            pulumi.set(__self__, "query_parameter_matches", query_parameter_matches)
        if regex_match is not None:
            pulumi.set(__self__, "regex_match", regex_match)

    @property
    @pulumi.getter(name="fullPathMatch")
    def full_path_match(self) -> Optional[str]:
        """
        For satisfying the matchRule condition, the path of the request must exactly
        match the value specified in fullPathMatch after removing any query parameters
        and anchor that may be part of the original URL. FullPathMatch must be between 1
        and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
        be specified.
        """
        return pulumi.get(self, "full_path_match")

    @property
    @pulumi.getter(name="headerMatches")
    def header_matches(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleHeaderMatch']]:
        """
        Specifies a list of header match criteria, all of which must match corresponding
        headers in the request.
        Structure is documented below.
        """
        return pulumi.get(self, "header_matches")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Specifies that prefixMatch and fullPathMatch matches are case sensitive.
        Defaults to false.
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="metadataFilters")
    def metadata_filters(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleMetadataFilter']]:
        """
        Opaque filter criteria used by Loadbalancer to restrict routing configuration to
        a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
        clients present node metadata. If a match takes place, the relevant routing
        configuration is made available to those proxies. For each metadataFilter in
        this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
        filterLabels must match the corresponding label provided in the metadata. If its
        filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
        with corresponding labels in the provided metadata. metadataFilters specified
        here can be overrides those specified in ForwardingRule that refers to this
        UrlMap. metadataFilters only applies to Loadbalancers that have their
        loadBalancingScheme set to INTERNAL_SELF_MANAGED.
        Structure is documented below.
        """
        return pulumi.get(self, "metadata_filters")

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[str]:
        """
        The value of the header must start with the contents of prefixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        return pulumi.get(self, "prefix_match")

    @property
    @pulumi.getter(name="queryParameterMatches")
    def query_parameter_matches(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch']]:
        """
        Specifies a list of query parameter match criteria, all of which must match
        corresponding query parameters in the request.
        Structure is documented below.
        """
        return pulumi.get(self, "query_parameter_matches")

    @property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter matches the
        regular expression specified by regexMatch. For the regular expression grammar,
        please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        exactMatch and regexMatch must be set.
        """
        return pulumi.get(self, "regex_match")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleHeaderMatch(dict):
    def __init__(__self__, *,
                 header_name: str,
                 exact_match: Optional[str] = None,
                 invert_match: Optional[bool] = None,
                 prefix_match: Optional[str] = None,
                 present_match: Optional[bool] = None,
                 range_match: Optional['outputs.URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch'] = None,
                 regex_match: Optional[str] = None,
                 suffix_match: Optional[str] = None):
        """
        :param str header_name: The name of the header to add.
        :param str exact_match: The queryParameterMatch matches if the value of the parameter exactly matches
               the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
               must be set.
        :param bool invert_match: If set to false, the headerMatch is considered a match if the match criteria
               above are met. If set to true, the headerMatch is considered a match if the
               match criteria above are NOT met. Defaults to false.
        :param str prefix_match: The value of the header must start with the contents of prefixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        :param bool present_match: Specifies that the queryParameterMatch matches if the request contains the query
               parameter, irrespective of whether the parameter has a value or not. Only one of
               presentMatch, exactMatch and regexMatch must be set.
        :param 'URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatchArgs' range_match: The header value must be an integer and its value must be in the range specified
               in rangeMatch. If the header does not contain an integer, number or is empty,
               the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
               not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
               Structure is documented below.
        :param str regex_match: The queryParameterMatch matches if the value of the parameter matches the
               regular expression specified by regexMatch. For the regular expression grammar,
               please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
               exactMatch and regexMatch must be set.
        :param str suffix_match: The value of the header must end with the contents of suffixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        """
        pulumi.set(__self__, "header_name", header_name)
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if invert_match is not None:
            pulumi.set(__self__, "invert_match", invert_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if present_match is not None:
            pulumi.set(__self__, "present_match", present_match)
        if range_match is not None:
            pulumi.set(__self__, "range_match", range_match)
        if regex_match is not None:
            pulumi.set(__self__, "regex_match", regex_match)
        if suffix_match is not None:
            pulumi.set(__self__, "suffix_match", suffix_match)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter exactly matches
        the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        must be set.
        """
        return pulumi.get(self, "exact_match")

    @property
    @pulumi.getter(name="invertMatch")
    def invert_match(self) -> Optional[bool]:
        """
        If set to false, the headerMatch is considered a match if the match criteria
        above are met. If set to true, the headerMatch is considered a match if the
        match criteria above are NOT met. Defaults to false.
        """
        return pulumi.get(self, "invert_match")

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[str]:
        """
        The value of the header must start with the contents of prefixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        return pulumi.get(self, "prefix_match")

    @property
    @pulumi.getter(name="presentMatch")
    def present_match(self) -> Optional[bool]:
        """
        Specifies that the queryParameterMatch matches if the request contains the query
        parameter, irrespective of whether the parameter has a value or not. Only one of
        presentMatch, exactMatch and regexMatch must be set.
        """
        return pulumi.get(self, "present_match")

    @property
    @pulumi.getter(name="rangeMatch")
    def range_match(self) -> Optional['outputs.URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch']:
        """
        The header value must be an integer and its value must be in the range specified
        in rangeMatch. If the header does not contain an integer, number or is empty,
        the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
        not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "range_match")

    @property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter matches the
        regular expression specified by regexMatch. For the regular expression grammar,
        please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        exactMatch and regexMatch must be set.
        """
        return pulumi.get(self, "regex_match")

    @property
    @pulumi.getter(name="suffixMatch")
    def suffix_match(self) -> Optional[str]:
        """
        The value of the header must end with the contents of suffixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        return pulumi.get(self, "suffix_match")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch(dict):
    def __init__(__self__, *,
                 range_end: int,
                 range_start: int):
        """
        :param int range_end: The end of the range (exclusive).
        :param int range_start: The start of the range (inclusive).
        """
        pulumi.set(__self__, "range_end", range_end)
        pulumi.set(__self__, "range_start", range_start)

    @property
    @pulumi.getter(name="rangeEnd")
    def range_end(self) -> int:
        """
        The end of the range (exclusive).
        """
        return pulumi.get(self, "range_end")

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> int:
        """
        The start of the range (inclusive).
        """
        return pulumi.get(self, "range_start")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleMetadataFilter(dict):
    def __init__(__self__, *,
                 filter_labels: Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel'],
                 filter_match_criteria: str):
        """
        :param Sequence['URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabelArgs'] filter_labels: The list of label value pairs that must match labels in the provided metadata
               based on filterMatchCriteria  This list must not be empty and can have at the
               most 64 entries.
               Structure is documented below.
        :param str filter_match_criteria: Specifies how individual filterLabel matches within the list of filterLabels
               contribute towards the overall metadataFilter match. Supported values are:
               - MATCH_ANY: At least one of the filterLabels must have a matching label in the
               provided metadata.
               - MATCH_ALL: All filterLabels must have matching labels in
               the provided metadata.
               Possible values are `MATCH_ALL` and `MATCH_ANY`.
        """
        pulumi.set(__self__, "filter_labels", filter_labels)
        pulumi.set(__self__, "filter_match_criteria", filter_match_criteria)

    @property
    @pulumi.getter(name="filterLabels")
    def filter_labels(self) -> Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel']:
        """
        The list of label value pairs that must match labels in the provided metadata
        based on filterMatchCriteria  This list must not be empty and can have at the
        most 64 entries.
        Structure is documented below.
        """
        return pulumi.get(self, "filter_labels")

    @property
    @pulumi.getter(name="filterMatchCriteria")
    def filter_match_criteria(self) -> str:
        """
        Specifies how individual filterLabel matches within the list of filterLabels
        contribute towards the overall metadataFilter match. Supported values are:
        - MATCH_ANY: At least one of the filterLabels must have a matching label in the
        provided metadata.
        - MATCH_ALL: All filterLabels must have matching labels in
        the provided metadata.
        Possible values are `MATCH_ALL` and `MATCH_ANY`.
        """
        return pulumi.get(self, "filter_match_criteria")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the query parameter to match. The query parameter must exist in the
               request, in the absence of which the request match fails.
        :param str value: The value of the label must match the specified value. value can have a maximum
               length of 1024 characters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query parameter to match. The query parameter must exist in the
        request, in the absence of which the request match fails.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the label must match the specified value. value can have a maximum
        length of 1024 characters.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch(dict):
    def __init__(__self__, *,
                 name: str,
                 exact_match: Optional[str] = None,
                 present_match: Optional[bool] = None,
                 regex_match: Optional[str] = None):
        """
        :param str name: The name of the query parameter to match. The query parameter must exist in the
               request, in the absence of which the request match fails.
        :param str exact_match: The queryParameterMatch matches if the value of the parameter exactly matches
               the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
               must be set.
        :param bool present_match: Specifies that the queryParameterMatch matches if the request contains the query
               parameter, irrespective of whether the parameter has a value or not. Only one of
               presentMatch, exactMatch and regexMatch must be set.
        :param str regex_match: The queryParameterMatch matches if the value of the parameter matches the
               regular expression specified by regexMatch. For the regular expression grammar,
               please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
               exactMatch and regexMatch must be set.
        """
        pulumi.set(__self__, "name", name)
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if present_match is not None:
            pulumi.set(__self__, "present_match", present_match)
        if regex_match is not None:
            pulumi.set(__self__, "regex_match", regex_match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query parameter to match. The query parameter must exist in the
        request, in the absence of which the request match fails.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter exactly matches
        the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        must be set.
        """
        return pulumi.get(self, "exact_match")

    @property
    @pulumi.getter(name="presentMatch")
    def present_match(self) -> Optional[bool]:
        """
        Specifies that the queryParameterMatch matches if the request contains the query
        parameter, irrespective of whether the parameter has a value or not. Only one of
        presentMatch, exactMatch and regexMatch must be set.
        """
        return pulumi.get(self, "present_match")

    @property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[str]:
        """
        The queryParameterMatch matches if the value of the parameter matches the
        regular expression specified by regexMatch. For the regular expression grammar,
        please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        exactMatch and regexMatch must be set.
        """
        return pulumi.get(self, "regex_match")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteAction(dict):
    def __init__(__self__, *,
                 cors_policy: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionCorsPolicy'] = None,
                 fault_injection_policy: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy'] = None,
                 request_mirror_policy: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy'] = None,
                 retry_policy: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRetryPolicy'] = None,
                 timeout: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionTimeout'] = None,
                 url_rewrite: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionUrlRewrite'] = None,
                 weighted_backend_services: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendService']] = None):
        """
        :param 'URLMapPathMatcherRouteRuleRouteActionCorsPolicyArgs' cors_policy: The specification for allowing client side cross-origin requests. Please see
               [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyArgs' fault_injection_policy: The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
               As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
               percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
               by the Loadbalancer for a percentage of requests.
               timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicyArgs' request_mirror_policy: Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
               Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
               the host / authority header is suffixed with -shadow.
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionRetryPolicyArgs' retry_policy: Specifies the retry policy associated with this route.
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionTimeoutArgs' timeout: Specifies the timeout for the selected route. Timeout is computed from the time the request has been
               fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
               If not specified, will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionUrlRewriteArgs' url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to the matched service.
               Structure is documented below.
        :param Sequence['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceArgs'] weighted_backend_services: A list of weighted backend services to send traffic to when a route match occurs.
               The weights determine the fraction of traffic that flows to their corresponding backend service.
               If all traffic needs to go to a single backend service, there must be one weightedBackendService
               with weight set to a non 0 number.
               Once a backendService is identified and before forwarding the request to the backend service,
               advanced routing actions like Url rewrites and header transformations are applied depending on
               additional settings specified in this HttpRouteAction.
               Structure is documented below.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if fault_injection_policy is not None:
            pulumi.set(__self__, "fault_injection_policy", fault_injection_policy)
        if request_mirror_policy is not None:
            pulumi.set(__self__, "request_mirror_policy", request_mirror_policy)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)
        if weighted_backend_services is not None:
            pulumi.set(__self__, "weighted_backend_services", weighted_backend_services)

    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see
        [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
        Structure is documented below.
        """
        return pulumi.get(self, "cors_policy")

    @property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
        As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
        percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
        by the Loadbalancer for a percentage of requests.
        timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
        Structure is documented below.
        """
        return pulumi.get(self, "fault_injection_policy")

    @property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
        Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
        the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        return pulumi.get(self, "request_mirror_policy")

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        return pulumi.get(self, "retry_policy")

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time the request has been
        fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
        If not specified, will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to the matched service.
        Structure is documented below.
        """
        return pulumi.get(self, "url_rewrite")

    @property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match occurs.
        The weights determine the fraction of traffic that flows to their corresponding backend service.
        If all traffic needs to go to a single backend service, there must be one weightedBackendService
        with weight set to a non 0 number.
        Once a backendService is identified and before forwarding the request to the backend service,
        advanced routing actions like Url rewrites and header transformations are applied depending on
        additional settings specified in this HttpRouteAction.
        Structure is documented below.
        """
        return pulumi.get(self, "weighted_backend_services")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionCorsPolicy(dict):
    def __init__(__self__, *,
                 allow_credentials: Optional[bool] = None,
                 allow_headers: Optional[Sequence[str]] = None,
                 allow_methods: Optional[Sequence[str]] = None,
                 allow_origin_regexes: Optional[Sequence[str]] = None,
                 allow_origins: Optional[Sequence[str]] = None,
                 disabled: Optional[bool] = None,
                 expose_headers: Optional[Sequence[str]] = None,
                 max_age: Optional[int] = None):
        """
        :param bool allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
               This translates to the Access-Control-Allow-Credentials header.
        :param Sequence[str] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param Sequence[str] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param Sequence[str] allow_origin_regexes: Specifies the regular expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[str] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param bool disabled: If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        :param Sequence[str] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param int max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin_regexes is not None:
            pulumi.set(__self__, "allow_origin_regexes", allow_origin_regexes)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
        This translates to the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[Sequence[str]]:
        """
        Specifies the regular expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origin_regexes")

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origins")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        return pulumi.get(self, "max_age")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy(dict):
    def __init__(__self__, *,
                 abort: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort'] = None,
                 delay: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay'] = None):
        """
        :param 'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbortArgs' abort: The specification for how client requests are aborted as part of fault injection.
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayArgs' delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
               Structure is documented below.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @property
    @pulumi.getter
    def abort(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        return pulumi.get(self, "abort")

    @property
    @pulumi.getter
    def delay(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        return pulumi.get(self, "delay")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort(dict):
    def __init__(__self__, *,
                 http_status: Optional[int] = None,
                 percentage: Optional[float] = None):
        """
        :param int http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if http_status is not None:
            pulumi.set(__self__, "http_status", http_status)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[int]:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        return pulumi.get(self, "http_status")

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay(dict):
    def __init__(__self__, *,
                 fixed_delay: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay'] = None,
                 percentage: Optional[float] = None):
        """
        :param 'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs' fixed_delay: Specifies the value of the fixed delay interval.
               Structure is documented below.
        :param float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if fixed_delay is not None:
            pulumi.set(__self__, "fixed_delay", fixed_delay)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay']:
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_delay")

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    def __init__(__self__, *,
                 seconds: str,
                 nanos: Optional[int] = None):
        """
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy(dict):
    def __init__(__self__, *,
                 backend_service: str):
        """
        :param str backend_service: The full or partial URL to the BackendService resource being mirrored to.
        """
        pulumi.set(__self__, "backend_service", backend_service)

    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        return pulumi.get(self, "backend_service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionRetryPolicy(dict):
    def __init__(__self__, *,
                 num_retries: int,
                 per_try_timeout: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout'] = None,
                 retry_conditions: Optional[Sequence[str]] = None):
        """
        :param int num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param 'URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeoutArgs' per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param Sequence[str] retry_conditions: Specfies one or more conditions when this retry rule applies. Valid values are:
               * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
               or if the backend service does not respond at all, example: disconnects, reset, read timeout,
               * connection failure, and refused streams.
               * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
               * connect-failure: Loadbalancer will retry on failures connecting to backend services,
               for example due to connection timeouts.
               * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
               This reset type indicates that it is safe to retry.
               * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
               * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
               * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
               * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        pulumi.set(__self__, "num_retries", num_retries)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_conditions is not None:
            pulumi.set(__self__, "retry_conditions", retry_conditions)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> int:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "per_try_timeout")

    @property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[Sequence[str]]:
        """
        Specfies one or more conditions when this retry rule applies. Valid values are:
        * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
        or if the backend service does not respond at all, example: disconnects, reset, read timeout,
        * connection failure, and refused streams.
        * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
        * connect-failure: Loadbalancer will retry on failures connecting to backend services,
        for example due to connection timeouts.
        * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
        This reset type indicates that it is safe to retry.
        * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
        * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
        * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
        * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        return pulumi.get(self, "retry_conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout(dict):
    def __init__(__self__, *,
                 seconds: str,
                 nanos: Optional[int] = None):
        """
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionTimeout(dict):
    def __init__(__self__, *,
                 seconds: str,
                 nanos: Optional[int] = None):
        """
        :param str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @property
    @pulumi.getter
    def seconds(self) -> str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionUrlRewrite(dict):
    def __init__(__self__, *,
                 host_rewrite: Optional[str] = None,
                 path_prefix_rewrite: Optional[str] = None):
        """
        :param str host_rewrite: Prior to forwarding the request to the selected service, the request's host header is replaced
               with contents of hostRewrite.
               The value must be between 1 and 255 characters.
        :param str path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching portion of the
               request's path is replaced by pathPrefixRewrite.
               The value must be between 1 and 1024 characters.
        """
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if path_prefix_rewrite is not None:
            pulumi.set(__self__, "path_prefix_rewrite", path_prefix_rewrite)

    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected service, the request's host header is replaced
        with contents of hostRewrite.
        The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_rewrite")

    @property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[str]:
        """
        Prior to forwarding the request to the selected backend service, the matching portion of the
        request's path is replaced by pathPrefixRewrite.
        The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "path_prefix_rewrite")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendService(dict):
    def __init__(__self__, *,
                 backend_service: str,
                 weight: int,
                 header_action: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction'] = None):
        """
        :param str backend_service: The full or partial URL to the BackendService resource being mirrored to.
        :param int weight: Specifies the fraction of traffic sent to backendService, computed as
               weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request
               has been directed to a backendService, subsequent requests will be sent to the same backendService
               as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        :param 'URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.
               Structure is documented below.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        pulumi.set(__self__, "weight", weight)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)

    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        return pulumi.get(self, "backend_service")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Specifies the fraction of traffic sent to backendService, computed as
        weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request
        has been directed to a backendService, subsequent requests will be sent to the same backendService
        as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction(dict):
    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[str]] = None):
        """
        :param Sequence['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[str] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param Sequence['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[str] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header to add.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    def __init__(__self__, *,
                 header_name: str,
                 header_value: str,
                 replace: bool):
        """
        :param str header_name: The name of the header to add.
        :param str header_value: The value of the header to add.
        :param bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter
    def replace(self) -> bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapPathMatcherRouteRuleUrlRedirect(dict):
    def __init__(__self__, *,
                 host_redirect: Optional[str] = None,
                 https_redirect: Optional[bool] = None,
                 path_redirect: Optional[str] = None,
                 prefix_redirect: Optional[str] = None,
                 redirect_response_code: Optional[str] = None,
                 strip_query: Optional[bool] = None):
        """
        :param str host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param bool https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param str path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param str prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        :param bool strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained. The default is set to false.
               This field is required to ensure an empty block is not set. The normal default value is false.
        """
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)
        if strip_query is not None:
            pulumi.set(__self__, "strip_query", strip_query)

    @property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_redirect")

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        return pulumi.get(self, "https_redirect")

    @property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        return pulumi.get(self, "path_redirect")

    @property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "prefix_redirect")

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")

    @property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> Optional[bool]:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained. The default is set to false.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        return pulumi.get(self, "strip_query")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class URLMapTest(dict):
    def __init__(__self__, *,
                 host: str,
                 path: str,
                 service: str,
                 description: Optional[str] = None):
        """
        :param str host: Host portion of the URL.
        :param str path: Path portion of the URL.
        :param str service: The backend service or backend bucket link that should be matched by this test.
        :param str description: Description of this test case.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "service", service)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Host portion of the URL.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path portion of the URL.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The backend service or backend bucket link that should be matched by this test.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this test case.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetBackendBucketCdnPolicyResult(dict):
    def __init__(__self__, *,
                 cache_mode: str,
                 client_ttl: int,
                 default_ttl: int,
                 max_ttl: int,
                 negative_caching: bool,
                 negative_caching_policies: Sequence['outputs.GetBackendBucketCdnPolicyNegativeCachingPolicyResult'],
                 serve_while_stale: int,
                 signed_url_cache_max_age_sec: int):
        pulumi.set(__self__, "cache_mode", cache_mode)
        pulumi.set(__self__, "client_ttl", client_ttl)
        pulumi.set(__self__, "default_ttl", default_ttl)
        pulumi.set(__self__, "max_ttl", max_ttl)
        pulumi.set(__self__, "negative_caching", negative_caching)
        pulumi.set(__self__, "negative_caching_policies", negative_caching_policies)
        pulumi.set(__self__, "serve_while_stale", serve_while_stale)
        pulumi.set(__self__, "signed_url_cache_max_age_sec", signed_url_cache_max_age_sec)

    @property
    @pulumi.getter(name="cacheMode")
    def cache_mode(self) -> str:
        return pulumi.get(self, "cache_mode")

    @property
    @pulumi.getter(name="clientTtl")
    def client_ttl(self) -> int:
        return pulumi.get(self, "client_ttl")

    @property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> int:
        return pulumi.get(self, "default_ttl")

    @property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> int:
        return pulumi.get(self, "max_ttl")

    @property
    @pulumi.getter(name="negativeCaching")
    def negative_caching(self) -> bool:
        return pulumi.get(self, "negative_caching")

    @property
    @pulumi.getter(name="negativeCachingPolicies")
    def negative_caching_policies(self) -> Sequence['outputs.GetBackendBucketCdnPolicyNegativeCachingPolicyResult']:
        return pulumi.get(self, "negative_caching_policies")

    @property
    @pulumi.getter(name="serveWhileStale")
    def serve_while_stale(self) -> int:
        return pulumi.get(self, "serve_while_stale")

    @property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> int:
        return pulumi.get(self, "signed_url_cache_max_age_sec")


@pulumi.output_type
class GetBackendBucketCdnPolicyNegativeCachingPolicyResult(dict):
    def __init__(__self__, *,
                 code: int,
                 ttl: int):
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def code(self) -> int:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetBackendServiceBackendResult(dict):
    def __init__(__self__, *,
                 balancing_mode: str,
                 capacity_scaler: float,
                 description: str,
                 group: str,
                 max_connections: int,
                 max_connections_per_endpoint: int,
                 max_connections_per_instance: int,
                 max_rate: int,
                 max_rate_per_endpoint: float,
                 max_rate_per_instance: float,
                 max_utilization: float):
        """
        :param str description: Textual description for the Backend Service.
        """
        pulumi.set(__self__, "balancing_mode", balancing_mode)
        pulumi.set(__self__, "capacity_scaler", capacity_scaler)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "max_connections", max_connections)
        pulumi.set(__self__, "max_connections_per_endpoint", max_connections_per_endpoint)
        pulumi.set(__self__, "max_connections_per_instance", max_connections_per_instance)
        pulumi.set(__self__, "max_rate", max_rate)
        pulumi.set(__self__, "max_rate_per_endpoint", max_rate_per_endpoint)
        pulumi.set(__self__, "max_rate_per_instance", max_rate_per_instance)
        pulumi.set(__self__, "max_utilization", max_utilization)

    @property
    @pulumi.getter(name="balancingMode")
    def balancing_mode(self) -> str:
        return pulumi.get(self, "balancing_mode")

    @property
    @pulumi.getter(name="capacityScaler")
    def capacity_scaler(self) -> float:
        return pulumi.get(self, "capacity_scaler")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Textual description for the Backend Service.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def group(self) -> str:
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> int:
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxConnectionsPerEndpoint")
    def max_connections_per_endpoint(self) -> int:
        return pulumi.get(self, "max_connections_per_endpoint")

    @property
    @pulumi.getter(name="maxConnectionsPerInstance")
    def max_connections_per_instance(self) -> int:
        return pulumi.get(self, "max_connections_per_instance")

    @property
    @pulumi.getter(name="maxRate")
    def max_rate(self) -> int:
        return pulumi.get(self, "max_rate")

    @property
    @pulumi.getter(name="maxRatePerEndpoint")
    def max_rate_per_endpoint(self) -> float:
        return pulumi.get(self, "max_rate_per_endpoint")

    @property
    @pulumi.getter(name="maxRatePerInstance")
    def max_rate_per_instance(self) -> float:
        return pulumi.get(self, "max_rate_per_instance")

    @property
    @pulumi.getter(name="maxUtilization")
    def max_utilization(self) -> float:
        return pulumi.get(self, "max_utilization")


@pulumi.output_type
class GetBackendServiceCdnPolicyResult(dict):
    def __init__(__self__, *,
                 cache_key_policies: Sequence['outputs.GetBackendServiceCdnPolicyCacheKeyPolicyResult'],
                 cache_mode: str,
                 client_ttl: int,
                 default_ttl: int,
                 max_ttl: int,
                 negative_caching: bool,
                 negative_caching_policies: Sequence['outputs.GetBackendServiceCdnPolicyNegativeCachingPolicyResult'],
                 serve_while_stale: int,
                 signed_url_cache_max_age_sec: int):
        pulumi.set(__self__, "cache_key_policies", cache_key_policies)
        pulumi.set(__self__, "cache_mode", cache_mode)
        pulumi.set(__self__, "client_ttl", client_ttl)
        pulumi.set(__self__, "default_ttl", default_ttl)
        pulumi.set(__self__, "max_ttl", max_ttl)
        pulumi.set(__self__, "negative_caching", negative_caching)
        pulumi.set(__self__, "negative_caching_policies", negative_caching_policies)
        pulumi.set(__self__, "serve_while_stale", serve_while_stale)
        pulumi.set(__self__, "signed_url_cache_max_age_sec", signed_url_cache_max_age_sec)

    @property
    @pulumi.getter(name="cacheKeyPolicies")
    def cache_key_policies(self) -> Sequence['outputs.GetBackendServiceCdnPolicyCacheKeyPolicyResult']:
        return pulumi.get(self, "cache_key_policies")

    @property
    @pulumi.getter(name="cacheMode")
    def cache_mode(self) -> str:
        return pulumi.get(self, "cache_mode")

    @property
    @pulumi.getter(name="clientTtl")
    def client_ttl(self) -> int:
        return pulumi.get(self, "client_ttl")

    @property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> int:
        return pulumi.get(self, "default_ttl")

    @property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> int:
        return pulumi.get(self, "max_ttl")

    @property
    @pulumi.getter(name="negativeCaching")
    def negative_caching(self) -> bool:
        return pulumi.get(self, "negative_caching")

    @property
    @pulumi.getter(name="negativeCachingPolicies")
    def negative_caching_policies(self) -> Sequence['outputs.GetBackendServiceCdnPolicyNegativeCachingPolicyResult']:
        return pulumi.get(self, "negative_caching_policies")

    @property
    @pulumi.getter(name="serveWhileStale")
    def serve_while_stale(self) -> int:
        return pulumi.get(self, "serve_while_stale")

    @property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> int:
        return pulumi.get(self, "signed_url_cache_max_age_sec")


@pulumi.output_type
class GetBackendServiceCdnPolicyCacheKeyPolicyResult(dict):
    def __init__(__self__, *,
                 include_host: bool,
                 include_protocol: bool,
                 include_query_string: bool,
                 query_string_blacklists: Sequence[str],
                 query_string_whitelists: Sequence[str]):
        pulumi.set(__self__, "include_host", include_host)
        pulumi.set(__self__, "include_protocol", include_protocol)
        pulumi.set(__self__, "include_query_string", include_query_string)
        pulumi.set(__self__, "query_string_blacklists", query_string_blacklists)
        pulumi.set(__self__, "query_string_whitelists", query_string_whitelists)

    @property
    @pulumi.getter(name="includeHost")
    def include_host(self) -> bool:
        return pulumi.get(self, "include_host")

    @property
    @pulumi.getter(name="includeProtocol")
    def include_protocol(self) -> bool:
        return pulumi.get(self, "include_protocol")

    @property
    @pulumi.getter(name="includeQueryString")
    def include_query_string(self) -> bool:
        return pulumi.get(self, "include_query_string")

    @property
    @pulumi.getter(name="queryStringBlacklists")
    def query_string_blacklists(self) -> Sequence[str]:
        return pulumi.get(self, "query_string_blacklists")

    @property
    @pulumi.getter(name="queryStringWhitelists")
    def query_string_whitelists(self) -> Sequence[str]:
        return pulumi.get(self, "query_string_whitelists")


@pulumi.output_type
class GetBackendServiceCdnPolicyNegativeCachingPolicyResult(dict):
    def __init__(__self__, *,
                 code: int,
                 ttl: int):
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def code(self) -> int:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetBackendServiceCircuitBreakerResult(dict):
    def __init__(__self__, *,
                 connect_timeouts: Sequence['outputs.GetBackendServiceCircuitBreakerConnectTimeoutResult'],
                 max_connections: int,
                 max_pending_requests: int,
                 max_requests: int,
                 max_requests_per_connection: int,
                 max_retries: int):
        pulumi.set(__self__, "connect_timeouts", connect_timeouts)
        pulumi.set(__self__, "max_connections", max_connections)
        pulumi.set(__self__, "max_pending_requests", max_pending_requests)
        pulumi.set(__self__, "max_requests", max_requests)
        pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        pulumi.set(__self__, "max_retries", max_retries)

    @property
    @pulumi.getter(name="connectTimeouts")
    def connect_timeouts(self) -> Sequence['outputs.GetBackendServiceCircuitBreakerConnectTimeoutResult']:
        return pulumi.get(self, "connect_timeouts")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> int:
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> int:
        return pulumi.get(self, "max_pending_requests")

    @property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> int:
        return pulumi.get(self, "max_requests")

    @property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> int:
        return pulumi.get(self, "max_requests_per_connection")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> int:
        return pulumi.get(self, "max_retries")


@pulumi.output_type
class GetBackendServiceCircuitBreakerConnectTimeoutResult(dict):
    def __init__(__self__, *,
                 nanos: int,
                 seconds: int):
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> int:
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> int:
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetBackendServiceConsistentHashResult(dict):
    def __init__(__self__, *,
                 http_cookies: Sequence['outputs.GetBackendServiceConsistentHashHttpCookyResult'],
                 http_header_name: str,
                 minimum_ring_size: int):
        pulumi.set(__self__, "http_cookies", http_cookies)
        pulumi.set(__self__, "http_header_name", http_header_name)
        pulumi.set(__self__, "minimum_ring_size", minimum_ring_size)

    @property
    @pulumi.getter(name="httpCookies")
    def http_cookies(self) -> Sequence['outputs.GetBackendServiceConsistentHashHttpCookyResult']:
        return pulumi.get(self, "http_cookies")

    @property
    @pulumi.getter(name="httpHeaderName")
    def http_header_name(self) -> str:
        return pulumi.get(self, "http_header_name")

    @property
    @pulumi.getter(name="minimumRingSize")
    def minimum_ring_size(self) -> int:
        return pulumi.get(self, "minimum_ring_size")


@pulumi.output_type
class GetBackendServiceConsistentHashHttpCookyResult(dict):
    def __init__(__self__, *,
                 name: str,
                 path: str,
                 ttls: Sequence['outputs.GetBackendServiceConsistentHashHttpCookyTtlResult']):
        """
        :param str name: The name of the Backend Service.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "ttls", ttls)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Backend Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def ttls(self) -> Sequence['outputs.GetBackendServiceConsistentHashHttpCookyTtlResult']:
        return pulumi.get(self, "ttls")


@pulumi.output_type
class GetBackendServiceConsistentHashHttpCookyTtlResult(dict):
    def __init__(__self__, *,
                 nanos: int,
                 seconds: int):
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> int:
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> int:
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetBackendServiceIapResult(dict):
    def __init__(__self__, *,
                 oauth2_client_id: str,
                 oauth2_client_secret: str,
                 oauth2_client_secret_sha256: str):
        pulumi.set(__self__, "oauth2_client_id", oauth2_client_id)
        pulumi.set(__self__, "oauth2_client_secret", oauth2_client_secret)
        pulumi.set(__self__, "oauth2_client_secret_sha256", oauth2_client_secret_sha256)

    @property
    @pulumi.getter(name="oauth2ClientId")
    def oauth2_client_id(self) -> str:
        return pulumi.get(self, "oauth2_client_id")

    @property
    @pulumi.getter(name="oauth2ClientSecret")
    def oauth2_client_secret(self) -> str:
        return pulumi.get(self, "oauth2_client_secret")

    @property
    @pulumi.getter(name="oauth2ClientSecretSha256")
    def oauth2_client_secret_sha256(self) -> str:
        return pulumi.get(self, "oauth2_client_secret_sha256")


@pulumi.output_type
class GetBackendServiceLogConfigResult(dict):
    def __init__(__self__, *,
                 enable: bool,
                 sample_rate: float):
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "sample_rate", sample_rate)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> float:
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class GetBackendServiceOutlierDetectionResult(dict):
    def __init__(__self__, *,
                 base_ejection_times: Sequence['outputs.GetBackendServiceOutlierDetectionBaseEjectionTimeResult'],
                 consecutive_errors: int,
                 consecutive_gateway_failure: int,
                 enforcing_consecutive_errors: int,
                 enforcing_consecutive_gateway_failure: int,
                 enforcing_success_rate: int,
                 intervals: Sequence['outputs.GetBackendServiceOutlierDetectionIntervalResult'],
                 max_ejection_percent: int,
                 success_rate_minimum_hosts: int,
                 success_rate_request_volume: int,
                 success_rate_stdev_factor: int):
        pulumi.set(__self__, "base_ejection_times", base_ejection_times)
        pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        pulumi.set(__self__, "consecutive_gateway_failure", consecutive_gateway_failure)
        pulumi.set(__self__, "enforcing_consecutive_errors", enforcing_consecutive_errors)
        pulumi.set(__self__, "enforcing_consecutive_gateway_failure", enforcing_consecutive_gateway_failure)
        pulumi.set(__self__, "enforcing_success_rate", enforcing_success_rate)
        pulumi.set(__self__, "intervals", intervals)
        pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        pulumi.set(__self__, "success_rate_minimum_hosts", success_rate_minimum_hosts)
        pulumi.set(__self__, "success_rate_request_volume", success_rate_request_volume)
        pulumi.set(__self__, "success_rate_stdev_factor", success_rate_stdev_factor)

    @property
    @pulumi.getter(name="baseEjectionTimes")
    def base_ejection_times(self) -> Sequence['outputs.GetBackendServiceOutlierDetectionBaseEjectionTimeResult']:
        return pulumi.get(self, "base_ejection_times")

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> int:
        return pulumi.get(self, "consecutive_errors")

    @property
    @pulumi.getter(name="consecutiveGatewayFailure")
    def consecutive_gateway_failure(self) -> int:
        return pulumi.get(self, "consecutive_gateway_failure")

    @property
    @pulumi.getter(name="enforcingConsecutiveErrors")
    def enforcing_consecutive_errors(self) -> int:
        return pulumi.get(self, "enforcing_consecutive_errors")

    @property
    @pulumi.getter(name="enforcingConsecutiveGatewayFailure")
    def enforcing_consecutive_gateway_failure(self) -> int:
        return pulumi.get(self, "enforcing_consecutive_gateway_failure")

    @property
    @pulumi.getter(name="enforcingSuccessRate")
    def enforcing_success_rate(self) -> int:
        return pulumi.get(self, "enforcing_success_rate")

    @property
    @pulumi.getter
    def intervals(self) -> Sequence['outputs.GetBackendServiceOutlierDetectionIntervalResult']:
        return pulumi.get(self, "intervals")

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> int:
        return pulumi.get(self, "max_ejection_percent")

    @property
    @pulumi.getter(name="successRateMinimumHosts")
    def success_rate_minimum_hosts(self) -> int:
        return pulumi.get(self, "success_rate_minimum_hosts")

    @property
    @pulumi.getter(name="successRateRequestVolume")
    def success_rate_request_volume(self) -> int:
        return pulumi.get(self, "success_rate_request_volume")

    @property
    @pulumi.getter(name="successRateStdevFactor")
    def success_rate_stdev_factor(self) -> int:
        return pulumi.get(self, "success_rate_stdev_factor")


@pulumi.output_type
class GetBackendServiceOutlierDetectionBaseEjectionTimeResult(dict):
    def __init__(__self__, *,
                 nanos: int,
                 seconds: int):
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> int:
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> int:
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetBackendServiceOutlierDetectionIntervalResult(dict):
    def __init__(__self__, *,
                 nanos: int,
                 seconds: int):
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> int:
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> int:
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetGlobalForwardingRuleMetadataFilterResult(dict):
    def __init__(__self__, *,
                 filter_labels: Sequence['outputs.GetGlobalForwardingRuleMetadataFilterFilterLabelResult'],
                 filter_match_criteria: str):
        pulumi.set(__self__, "filter_labels", filter_labels)
        pulumi.set(__self__, "filter_match_criteria", filter_match_criteria)

    @property
    @pulumi.getter(name="filterLabels")
    def filter_labels(self) -> Sequence['outputs.GetGlobalForwardingRuleMetadataFilterFilterLabelResult']:
        return pulumi.get(self, "filter_labels")

    @property
    @pulumi.getter(name="filterMatchCriteria")
    def filter_match_criteria(self) -> str:
        return pulumi.get(self, "filter_match_criteria")


@pulumi.output_type
class GetGlobalForwardingRuleMetadataFilterFilterLabelResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the global forwarding rule.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the global forwarding rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHealthCheckGrpcHealthCheckResult(dict):
    def __init__(__self__, *,
                 grpc_service_name: str,
                 port: int,
                 port_name: str,
                 port_specification: str):
        pulumi.set(__self__, "grpc_service_name", grpc_service_name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_name", port_name)
        pulumi.set(__self__, "port_specification", port_specification)

    @property
    @pulumi.getter(name="grpcServiceName")
    def grpc_service_name(self) -> str:
        return pulumi.get(self, "grpc_service_name")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> str:
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> str:
        return pulumi.get(self, "port_specification")


@pulumi.output_type
class GetHealthCheckHttp2HealthCheckResult(dict):
    def __init__(__self__, *,
                 host: str,
                 port: int,
                 port_name: str,
                 port_specification: str,
                 proxy_header: str,
                 request_path: str,
                 response: str):
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_name", port_name)
        pulumi.set(__self__, "port_specification", port_specification)
        pulumi.set(__self__, "proxy_header", proxy_header)
        pulumi.set(__self__, "request_path", request_path)
        pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> str:
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> str:
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> str:
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> str:
        return pulumi.get(self, "request_path")

    @property
    @pulumi.getter
    def response(self) -> str:
        return pulumi.get(self, "response")


@pulumi.output_type
class GetHealthCheckHttpHealthCheckResult(dict):
    def __init__(__self__, *,
                 host: str,
                 port: int,
                 port_name: str,
                 port_specification: str,
                 proxy_header: str,
                 request_path: str,
                 response: str):
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_name", port_name)
        pulumi.set(__self__, "port_specification", port_specification)
        pulumi.set(__self__, "proxy_header", proxy_header)
        pulumi.set(__self__, "request_path", request_path)
        pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> str:
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> str:
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> str:
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> str:
        return pulumi.get(self, "request_path")

    @property
    @pulumi.getter
    def response(self) -> str:
        return pulumi.get(self, "response")


@pulumi.output_type
class GetHealthCheckHttpsHealthCheckResult(dict):
    def __init__(__self__, *,
                 host: str,
                 port: int,
                 port_name: str,
                 port_specification: str,
                 proxy_header: str,
                 request_path: str,
                 response: str):
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_name", port_name)
        pulumi.set(__self__, "port_specification", port_specification)
        pulumi.set(__self__, "proxy_header", proxy_header)
        pulumi.set(__self__, "request_path", request_path)
        pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> str:
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> str:
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> str:
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> str:
        return pulumi.get(self, "request_path")

    @property
    @pulumi.getter
    def response(self) -> str:
        return pulumi.get(self, "response")


@pulumi.output_type
class GetHealthCheckLogConfigResult(dict):
    def __init__(__self__, *,
                 enable: bool):
        pulumi.set(__self__, "enable", enable)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        return pulumi.get(self, "enable")


@pulumi.output_type
class GetHealthCheckSslHealthCheckResult(dict):
    def __init__(__self__, *,
                 port: int,
                 port_name: str,
                 port_specification: str,
                 proxy_header: str,
                 request: str,
                 response: str):
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_name", port_name)
        pulumi.set(__self__, "port_specification", port_specification)
        pulumi.set(__self__, "proxy_header", proxy_header)
        pulumi.set(__self__, "request", request)
        pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> str:
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> str:
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> str:
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter
    def request(self) -> str:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> str:
        return pulumi.get(self, "response")


@pulumi.output_type
class GetHealthCheckTcpHealthCheckResult(dict):
    def __init__(__self__, *,
                 port: int,
                 port_name: str,
                 port_specification: str,
                 proxy_header: str,
                 request: str,
                 response: str):
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_name", port_name)
        pulumi.set(__self__, "port_specification", port_specification)
        pulumi.set(__self__, "proxy_header", proxy_header)
        pulumi.set(__self__, "request", request)
        pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> str:
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> str:
        return pulumi.get(self, "port_specification")

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> str:
        return pulumi.get(self, "proxy_header")

    @property
    @pulumi.getter
    def request(self) -> str:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> str:
        return pulumi.get(self, "response")


@pulumi.output_type
class GetInstanceAttachedDiskResult(dict):
    def __init__(__self__, *,
                 device_name: str,
                 disk_encryption_key_raw: str,
                 disk_encryption_key_sha256: str,
                 kms_key_self_link: str,
                 mode: str,
                 source: str):
        """
        :param str device_name: Name with which the attached disk is accessible
               under `/dev/disk/by-id/`
        :param str mode: Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
        :param str source: The name or self_link of the disk attached to this instance.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Name with which the attached disk is accessible
        under `/dev/disk/by-id/`
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> str:
        return pulumi.get(self, "disk_encryption_key_raw")

    @property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> str:
        return pulumi.get(self, "disk_encryption_key_sha256")

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> str:
        return pulumi.get(self, "kms_key_self_link")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The name or self_link of the disk attached to this instance.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class GetInstanceBootDiskResult(dict):
    def __init__(__self__, *,
                 auto_delete: bool,
                 device_name: str,
                 disk_encryption_key_raw: str,
                 disk_encryption_key_sha256: str,
                 initialize_params: Sequence['outputs.GetInstanceBootDiskInitializeParamResult'],
                 kms_key_self_link: str,
                 mode: str,
                 source: str):
        """
        :param bool auto_delete: Whether the disk will be auto-deleted when the instance is deleted.
        :param str device_name: Name with which the attached disk is accessible
               under `/dev/disk/by-id/`
        :param Sequence['GetInstanceBootDiskInitializeParamArgs'] initialize_params: Parameters with which a disk was created alongside the instance.
               Structure is documented below.
        :param str mode: Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
        :param str source: The name or self_link of the disk attached to this instance.
        """
        pulumi.set(__self__, "auto_delete", auto_delete)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        pulumi.set(__self__, "initialize_params", initialize_params)
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> bool:
        """
        Whether the disk will be auto-deleted when the instance is deleted.
        """
        return pulumi.get(self, "auto_delete")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Name with which the attached disk is accessible
        under `/dev/disk/by-id/`
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> str:
        return pulumi.get(self, "disk_encryption_key_raw")

    @property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> str:
        return pulumi.get(self, "disk_encryption_key_sha256")

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Sequence['outputs.GetInstanceBootDiskInitializeParamResult']:
        """
        Parameters with which a disk was created alongside the instance.
        Structure is documented below.
        """
        return pulumi.get(self, "initialize_params")

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> str:
        return pulumi.get(self, "kms_key_self_link")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The name or self_link of the disk attached to this instance.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class GetInstanceBootDiskInitializeParamResult(dict):
    def __init__(__self__, *,
                 image: str,
                 labels: Mapping[str, Any],
                 size: int,
                 type: str):
        """
        :param str image: The image from which this disk was initialised.
        :param Mapping[str, Any] labels: A set of key/value label pairs assigned to the instance.
        :param int size: The size of the image in gigabytes.
        :param str type: The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        The image from which this disk was initialised.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, Any]:
        """
        A set of key/value label pairs assigned to the instance.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the image in gigabytes.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceConfidentialInstanceConfigResult(dict):
    def __init__(__self__, *,
                 enable_confidential_compute: bool):
        pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> bool:
        return pulumi.get(self, "enable_confidential_compute")


@pulumi.output_type
class GetInstanceGroupNamedPortResult(dict):
    def __init__(__self__, *,
                 name: str,
                 port: int):
        """
        :param str name: The name of the instance group. Either `name` or `self_link` must be provided.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the instance group. Either `name` or `self_link` must be provided.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetInstanceGuestAcceleratorResult(dict):
    def __init__(__self__, *,
                 count: int,
                 type: str):
        """
        :param int count: The number of the guest accelerator cards exposed to this instance.
        :param str type: The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 access_configs: Sequence['outputs.GetInstanceNetworkInterfaceAccessConfigResult'],
                 alias_ip_ranges: Sequence['outputs.GetInstanceNetworkInterfaceAliasIpRangeResult'],
                 name: str,
                 network: str,
                 network_ip: str,
                 nic_type: str,
                 subnetwork: str,
                 subnetwork_project: str):
        """
        :param Sequence['GetInstanceNetworkInterfaceAccessConfigArgs'] access_configs: Access configurations, i.e. IPs via which this
               instance can be accessed via the Internet. Structure documented below.
        :param Sequence['GetInstanceNetworkInterfaceAliasIpRangeArgs'] alias_ip_ranges: An array of alias IP ranges for this network interface. Structure documented below.
        :param str name: The name of the instance. One of `name` or `self_link` must be provided.
        :param str network: The name or self_link of the network attached to this interface.
        :param str network_ip: The private IP address assigned to the instance.
        :param str subnetwork: The name or self_link of the subnetwork attached to this interface.
        :param str subnetwork_project: The project in which the subnetwork belongs.
        """
        pulumi.set(__self__, "access_configs", access_configs)
        pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "network_ip", network_ip)
        pulumi.set(__self__, "nic_type", nic_type)
        pulumi.set(__self__, "subnetwork", subnetwork)
        pulumi.set(__self__, "subnetwork_project", subnetwork_project)

    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Sequence['outputs.GetInstanceNetworkInterfaceAccessConfigResult']:
        """
        Access configurations, i.e. IPs via which this
        instance can be accessed via the Internet. Structure documented below.
        """
        return pulumi.get(self, "access_configs")

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Sequence['outputs.GetInstanceNetworkInterfaceAliasIpRangeResult']:
        """
        An array of alias IP ranges for this network interface. Structure documented below.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the instance. One of `name` or `self_link` must be provided.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The name or self_link of the network attached to this interface.
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> str:
        """
        The private IP address assigned to the instance.
        """
        return pulumi.get(self, "network_ip")

    @property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> str:
        return pulumi.get(self, "nic_type")

    @property
    @pulumi.getter
    def subnetwork(self) -> str:
        """
        The name or self_link of the subnetwork attached to this interface.
        """
        return pulumi.get(self, "subnetwork")

    @property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> str:
        """
        The project in which the subnetwork belongs.
        """
        return pulumi.get(self, "subnetwork_project")


@pulumi.output_type
class GetInstanceNetworkInterfaceAccessConfigResult(dict):
    def __init__(__self__, *,
                 nat_ip: str,
                 network_tier: str,
                 public_ptr_domain_name: str):
        """
        :param str nat_ip: The IP address that is be 1:1 mapped to the instance's
               network ip.
        :param str network_tier: The [networking tier][network-tier] used for configuring this instance. One of `PREMIUM` or `STANDARD`.
        :param str public_ptr_domain_name: The DNS domain name for the public PTR record.
        """
        pulumi.set(__self__, "nat_ip", nat_ip)
        pulumi.set(__self__, "network_tier", network_tier)
        pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)

    @property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> str:
        """
        The IP address that is be 1:1 mapped to the instance's
        network ip.
        """
        return pulumi.get(self, "nat_ip")

    @property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> str:
        """
        The [networking tier][network-tier] used for configuring this instance. One of `PREMIUM` or `STANDARD`.
        """
        return pulumi.get(self, "network_tier")

    @property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> str:
        """
        The DNS domain name for the public PTR record.
        """
        return pulumi.get(self, "public_ptr_domain_name")


@pulumi.output_type
class GetInstanceNetworkInterfaceAliasIpRangeResult(dict):
    def __init__(__self__, *,
                 ip_cidr_range: str,
                 subnetwork_range_name: str):
        """
        :param str ip_cidr_range: The IP CIDR range represented by this alias IP range.
        :param str subnetwork_range_name: The subnetwork secondary range name specifying
               the secondary range from which to allocate the IP CIDR range for this alias IP
               range.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> str:
        """
        The IP CIDR range represented by this alias IP range.
        """
        return pulumi.get(self, "ip_cidr_range")

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> str:
        """
        The subnetwork secondary range name specifying
        the secondary range from which to allocate the IP CIDR range for this alias IP
        range.
        """
        return pulumi.get(self, "subnetwork_range_name")


@pulumi.output_type
class GetInstanceSchedulingResult(dict):
    def __init__(__self__, *,
                 automatic_restart: bool,
                 min_node_cpus: int,
                 node_affinities: Sequence['outputs.GetInstanceSchedulingNodeAffinityResult'],
                 on_host_maintenance: str,
                 preemptible: bool):
        """
        :param bool automatic_restart: Specifies if the instance should be
               restarted if it was terminated by Compute Engine (not a user).
        :param str on_host_maintenance: Describes maintenance behavior for the
               instance. One of `MIGRATE` or `TERMINATE`, for more info, read
               [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options)
        :param bool preemptible: Whether the instance is preemptible.
        """
        pulumi.set(__self__, "automatic_restart", automatic_restart)
        pulumi.set(__self__, "min_node_cpus", min_node_cpus)
        pulumi.set(__self__, "node_affinities", node_affinities)
        pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> bool:
        """
        Specifies if the instance should be
        restarted if it was terminated by Compute Engine (not a user).
        """
        return pulumi.get(self, "automatic_restart")

    @property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> int:
        return pulumi.get(self, "min_node_cpus")

    @property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Sequence['outputs.GetInstanceSchedulingNodeAffinityResult']:
        return pulumi.get(self, "node_affinities")

    @property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> str:
        """
        Describes maintenance behavior for the
        instance. One of `MIGRATE` or `TERMINATE`, for more info, read
        [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options)
        """
        return pulumi.get(self, "on_host_maintenance")

    @property
    @pulumi.getter
    def preemptible(self) -> bool:
        """
        Whether the instance is preemptible.
        """
        return pulumi.get(self, "preemptible")


@pulumi.output_type
class GetInstanceSchedulingNodeAffinityResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceScratchDiskResult(dict):
    def __init__(__self__, *,
                 interface: str):
        """
        :param str interface: The disk interface used for attaching this disk. One of `SCSI` or `NVME`.
        """
        pulumi.set(__self__, "interface", interface)

    @property
    @pulumi.getter
    def interface(self) -> str:
        """
        The disk interface used for attaching this disk. One of `SCSI` or `NVME`.
        """
        return pulumi.get(self, "interface")


@pulumi.output_type
class GetInstanceServiceAccountResult(dict):
    def __init__(__self__, *,
                 email: str,
                 scopes: Sequence[str]):
        """
        :param str email: The service account e-mail address.
        :param Sequence[str] scopes: A list of service scopes.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The service account e-mail address.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        A list of service scopes.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class GetInstanceShieldedInstanceConfigResult(dict):
    def __init__(__self__, *,
                 enable_integrity_monitoring: bool,
                 enable_secure_boot: bool,
                 enable_vtpm: bool):
        pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> bool:
        return pulumi.get(self, "enable_integrity_monitoring")

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> bool:
        return pulumi.get(self, "enable_secure_boot")

    @property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> bool:
        return pulumi.get(self, "enable_vtpm")


@pulumi.output_type
class GetInstanceTemplateConfidentialInstanceConfigResult(dict):
    def __init__(__self__, *,
                 enable_confidential_compute: bool):
        pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> bool:
        return pulumi.get(self, "enable_confidential_compute")


@pulumi.output_type
class GetInstanceTemplateDiskResult(dict):
    def __init__(__self__, *,
                 auto_delete: bool,
                 boot: bool,
                 device_name: str,
                 disk_encryption_keys: Sequence['outputs.GetInstanceTemplateDiskDiskEncryptionKeyResult'],
                 disk_name: str,
                 disk_size_gb: int,
                 disk_type: str,
                 interface: str,
                 labels: Mapping[str, str],
                 mode: str,
                 resource_policies: Sequence[str],
                 source: str,
                 source_image: str,
                 type: str):
        """
        :param bool auto_delete: Whether or not the disk should be auto-deleted.
               This defaults to true.
        :param bool boot: Indicates that this is a boot disk.
        :param str device_name: A unique device name that is reflected into the
               /dev/  tree of a Linux operating system running within the instance. If not
               specified, the server chooses a default device name to apply to this disk.
        :param Sequence['GetInstanceTemplateDiskDiskEncryptionKeyArgs'] disk_encryption_keys: Encrypts or decrypts a disk using a customer-supplied encryption key.
        :param str disk_name: Name of the disk. When not provided, this defaults
               to the name of the instance.
        :param int disk_size_gb: The size of the image in gigabytes. If not
               specified, it will inherit the size of its base image. For SCRATCH disks,
               the size must be exactly 375GB.
        :param str disk_type: The GCE disk type. Can be either `"pd-ssd"`,
               `"local-ssd"`, `"pd-balanced"` or `"pd-standard"`.
        :param str interface: Specifies the disk interface to use for attaching this disk,
               which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
               and the request will fail if you attempt to attach a persistent disk in any other format
               than SCSI. Local SSDs can use either NVME or SCSI.
        :param Mapping[str, str] labels: A set of key/value label pairs to assign to instances
               created from this template,
        :param str mode: The mode in which to attach this disk, either READ_WRITE
               or READ_ONLY. If you are attaching or creating a boot disk, this must
               read-write mode.
        :param str source: The name (**not self_link**)
               of the disk (such as those managed by `compute.Disk`) to attach.
               > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param str source_image: The image from which to
               initialize this disk. This can be one of: the image's `self_link`,
               `projects/{project}/global/images/{image}`,
               `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
               `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
               `{project}/{image}`, `{family}`, or `{image}`.
               > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "auto_delete", auto_delete)
        pulumi.set(__self__, "boot", boot)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_encryption_keys", disk_encryption_keys)
        pulumi.set(__self__, "disk_name", disk_name)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "interface", interface)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "resource_policies", resource_policies)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_image", source_image)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> bool:
        """
        Whether or not the disk should be auto-deleted.
        This defaults to true.
        """
        return pulumi.get(self, "auto_delete")

    @property
    @pulumi.getter
    def boot(self) -> bool:
        """
        Indicates that this is a boot disk.
        """
        return pulumi.get(self, "boot")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        A unique device name that is reflected into the
        /dev/  tree of a Linux operating system running within the instance. If not
        specified, the server chooses a default device name to apply to this disk.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskEncryptionKeys")
    def disk_encryption_keys(self) -> Sequence['outputs.GetInstanceTemplateDiskDiskEncryptionKeyResult']:
        """
        Encrypts or decrypts a disk using a customer-supplied encryption key.
        """
        return pulumi.get(self, "disk_encryption_keys")

    @property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> str:
        """
        Name of the disk. When not provided, this defaults
        to the name of the instance.
        """
        return pulumi.get(self, "disk_name")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> int:
        """
        The size of the image in gigabytes. If not
        specified, it will inherit the size of its base image. For SCRATCH disks,
        the size must be exactly 375GB.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> str:
        """
        The GCE disk type. Can be either `"pd-ssd"`,
        `"local-ssd"`, `"pd-balanced"` or `"pd-standard"`.
        """
        return pulumi.get(self, "disk_type")

    @property
    @pulumi.getter
    def interface(self) -> str:
        """
        Specifies the disk interface to use for attaching this disk,
        which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
        and the request will fail if you attempt to attach a persistent disk in any other format
        than SCSI. Local SSDs can use either NVME or SCSI.
        """
        return pulumi.get(self, "interface")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        A set of key/value label pairs to assign to instances
        created from this template,
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The mode in which to attach this disk, either READ_WRITE
        or READ_ONLY. If you are attaching or creating a boot disk, this must
        read-write mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="resourcePolicies")
    def resource_policies(self) -> Sequence[str]:
        return pulumi.get(self, "resource_policies")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The name (**not self_link**)
        of the disk (such as those managed by `compute.Disk`) to attach.
        > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> str:
        """
        The image from which to
        initialize this disk. This can be one of: the image's `self_link`,
        `projects/{project}/global/images/{image}`,
        `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
        `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
        `{project}/{image}`, `{family}`, or `{image}`.
        > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        return pulumi.get(self, "source_image")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceTemplateDiskDiskEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: str):
        """
        :param str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)

    @property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS
        """
        return pulumi.get(self, "kms_key_self_link")


@pulumi.output_type
class GetInstanceTemplateGuestAcceleratorResult(dict):
    def __init__(__self__, *,
                 count: int,
                 type: str):
        """
        :param int count: The number of the guest accelerator cards exposed to this instance.
        :param str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceTemplateNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 access_configs: Sequence['outputs.GetInstanceTemplateNetworkInterfaceAccessConfigResult'],
                 alias_ip_ranges: Sequence['outputs.GetInstanceTemplateNetworkInterfaceAliasIpRangeResult'],
                 name: str,
                 network: str,
                 network_ip: str,
                 subnetwork: str,
                 subnetwork_project: str):
        """
        :param Sequence['GetInstanceTemplateNetworkInterfaceAccessConfigArgs'] access_configs: Access configurations, i.e. IPs via which this
               instance can be accessed via the Internet. Omit to ensure that the instance
               is not accessible from the Internet (this means that ssh provisioners will
               not work unless you are running the prvovider can send traffic to the instance's
               network (e.g. via tunnel or because it is running on another cloud instance
               on that network). This block can be repeated multiple times. Structure documented below.
        :param Sequence['GetInstanceTemplateNetworkInterfaceAliasIpRangeArgs'] alias_ip_ranges: An
               array of alias IP ranges for this network interface. Can only be specified for network
               interfaces on subnet-mode networks. Structure documented below.
        :param str name: The name of the instance template. One of `name` or `filter` must be provided.
        :param str network: The name or self_link of the network to attach this interface to.
               Use `network` attribute for Legacy or Auto subnetted networks and
               `subnetwork` for custom subnetted networks.
        :param str network_ip: The private IP address to assign to the instance. If
               empty, the address will be automatically assigned.
        :param str subnetwork: the name of the subnetwork to attach this interface
               to. The subnetwork must exist in the same `region` this instance will be
               created in. Either `network` or `subnetwork` must be provided.
        :param str subnetwork_project: The ID of the project in which the subnetwork belongs.
               If it is not provided, the provider project is used.
        """
        pulumi.set(__self__, "access_configs", access_configs)
        pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "network_ip", network_ip)
        pulumi.set(__self__, "subnetwork", subnetwork)
        pulumi.set(__self__, "subnetwork_project", subnetwork_project)

    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Sequence['outputs.GetInstanceTemplateNetworkInterfaceAccessConfigResult']:
        """
        Access configurations, i.e. IPs via which this
        instance can be accessed via the Internet. Omit to ensure that the instance
        is not accessible from the Internet (this means that ssh provisioners will
        not work unless you are running the prvovider can send traffic to the instance's
        network (e.g. via tunnel or because it is running on another cloud instance
        on that network). This block can be repeated multiple times. Structure documented below.
        """
        return pulumi.get(self, "access_configs")

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Sequence['outputs.GetInstanceTemplateNetworkInterfaceAliasIpRangeResult']:
        """
        An
        array of alias IP ranges for this network interface. Can only be specified for network
        interfaces on subnet-mode networks. Structure documented below.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the instance template. One of `name` or `filter` must be provided.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The name or self_link of the network to attach this interface to.
        Use `network` attribute for Legacy or Auto subnetted networks and
        `subnetwork` for custom subnetted networks.
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> str:
        """
        The private IP address to assign to the instance. If
        empty, the address will be automatically assigned.
        """
        return pulumi.get(self, "network_ip")

    @property
    @pulumi.getter
    def subnetwork(self) -> str:
        """
        the name of the subnetwork to attach this interface
        to. The subnetwork must exist in the same `region` this instance will be
        created in. Either `network` or `subnetwork` must be provided.
        """
        return pulumi.get(self, "subnetwork")

    @property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> str:
        """
        The ID of the project in which the subnetwork belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "subnetwork_project")


@pulumi.output_type
class GetInstanceTemplateNetworkInterfaceAccessConfigResult(dict):
    def __init__(__self__, *,
                 nat_ip: str,
                 network_tier: str,
                 public_ptr_domain_name: str):
        """
        :param str nat_ip: The IP address that will be 1:1 mapped to the instance's
               network ip. If not given, one will be generated.
        :param str network_tier: The [networking tier][network-tier] used for configuring
               this instance template. This field can take the following values: PREMIUM or
               STANDARD. If this field is not specified, it is assumed to be PREMIUM.
        """
        pulumi.set(__self__, "nat_ip", nat_ip)
        pulumi.set(__self__, "network_tier", network_tier)
        pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)

    @property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> str:
        """
        The IP address that will be 1:1 mapped to the instance's
        network ip. If not given, one will be generated.
        """
        return pulumi.get(self, "nat_ip")

    @property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> str:
        """
        The [networking tier][network-tier] used for configuring
        this instance template. This field can take the following values: PREMIUM or
        STANDARD. If this field is not specified, it is assumed to be PREMIUM.
        """
        return pulumi.get(self, "network_tier")

    @property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> str:
        return pulumi.get(self, "public_ptr_domain_name")


@pulumi.output_type
class GetInstanceTemplateNetworkInterfaceAliasIpRangeResult(dict):
    def __init__(__self__, *,
                 ip_cidr_range: str,
                 subnetwork_range_name: str):
        """
        :param str ip_cidr_range: The IP CIDR range represented by this alias IP range. This IP CIDR range
               must belong to the specified subnetwork and cannot contain IP addresses reserved by
               system or used by other network interfaces. At the time of writing only a
               netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
               error.
        :param str subnetwork_range_name: The subnetwork secondary range name specifying
               the secondary range from which to allocate the IP CIDR range for this alias IP
               range. If left unspecified, the primary range of the subnetwork will be used.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> str:
        """
        The IP CIDR range represented by this alias IP range. This IP CIDR range
        must belong to the specified subnetwork and cannot contain IP addresses reserved by
        system or used by other network interfaces. At the time of writing only a
        netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
        error.
        """
        return pulumi.get(self, "ip_cidr_range")

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> str:
        """
        The subnetwork secondary range name specifying
        the secondary range from which to allocate the IP CIDR range for this alias IP
        range. If left unspecified, the primary range of the subnetwork will be used.
        """
        return pulumi.get(self, "subnetwork_range_name")


@pulumi.output_type
class GetInstanceTemplateSchedulingResult(dict):
    def __init__(__self__, *,
                 automatic_restart: bool,
                 min_node_cpus: int,
                 node_affinities: Sequence['outputs.GetInstanceTemplateSchedulingNodeAffinityResult'],
                 on_host_maintenance: str,
                 preemptible: bool):
        """
        :param bool automatic_restart: Specifies whether the instance should be
               automatically restarted if it is terminated by Compute Engine (not
               terminated by a user). This defaults to true.
        :param Sequence['GetInstanceTemplateSchedulingNodeAffinityArgs'] node_affinities: Specifies node affinities or anti-affinities
               to determine which sole-tenant nodes your instances and managed instance
               groups will use as host systems. Read more on sole-tenant node creation
               [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
               Structure documented below.
        :param str on_host_maintenance: Defines the maintenance behavior for this
               instance.
        :param bool preemptible: Allows instance to be preempted. This defaults to
               false. Read more on this
               [here](https://cloud.google.com/compute/docs/instances/preemptible).
        """
        pulumi.set(__self__, "automatic_restart", automatic_restart)
        pulumi.set(__self__, "min_node_cpus", min_node_cpus)
        pulumi.set(__self__, "node_affinities", node_affinities)
        pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> bool:
        """
        Specifies whether the instance should be
        automatically restarted if it is terminated by Compute Engine (not
        terminated by a user). This defaults to true.
        """
        return pulumi.get(self, "automatic_restart")

    @property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> int:
        return pulumi.get(self, "min_node_cpus")

    @property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Sequence['outputs.GetInstanceTemplateSchedulingNodeAffinityResult']:
        """
        Specifies node affinities or anti-affinities
        to determine which sole-tenant nodes your instances and managed instance
        groups will use as host systems. Read more on sole-tenant node creation
        [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
        Structure documented below.
        """
        return pulumi.get(self, "node_affinities")

    @property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> str:
        """
        Defines the maintenance behavior for this
        instance.
        """
        return pulumi.get(self, "on_host_maintenance")

    @property
    @pulumi.getter
    def preemptible(self) -> bool:
        """
        Allows instance to be preempted. This defaults to
        false. Read more on this
        [here](https://cloud.google.com/compute/docs/instances/preemptible).
        """
        return pulumi.get(self, "preemptible")


@pulumi.output_type
class GetInstanceTemplateSchedulingNodeAffinityResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str key: The key for the node affinity label.
        :param str operator: The operator. Can be `IN` for node-affinities
               or `NOT_IN` for anti-affinities.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key for the node affinity label.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator. Can be `IN` for node-affinities
        or `NOT_IN` for anti-affinities.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceTemplateServiceAccountResult(dict):
    def __init__(__self__, *,
                 email: str,
                 scopes: Sequence[str]):
        """
        :param str email: The service account e-mail address. If not given, the
               default Google Compute Engine service account is used.
        :param Sequence[str] scopes: A list of service scopes. Both OAuth2 URLs and gcloud
               short names are supported. To allow full access to all Cloud APIs, use the
               `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The service account e-mail address. If not given, the
        default Google Compute Engine service account is used.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        A list of service scopes. Both OAuth2 URLs and gcloud
        short names are supported. To allow full access to all Cloud APIs, use the
        `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class GetInstanceTemplateShieldedInstanceConfigResult(dict):
    def __init__(__self__, *,
                 enable_integrity_monitoring: bool,
                 enable_secure_boot: bool,
                 enable_vtpm: bool):
        pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> bool:
        return pulumi.get(self, "enable_integrity_monitoring")

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> bool:
        return pulumi.get(self, "enable_secure_boot")

    @property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> bool:
        return pulumi.get(self, "enable_vtpm")


@pulumi.output_type
class GetRegionInstanceGroupInstanceResult(dict):
    def __init__(__self__, *,
                 instance: str,
                 named_ports: Sequence['outputs.GetRegionInstanceGroupInstanceNamedPortResult'],
                 status: str):
        """
        :param str instance: URL to the instance.
        :param Sequence['GetRegionInstanceGroupInstanceNamedPortArgs'] named_ports: List of named ports in the group, as a list of resources, each containing:
        :param str status: String description of current state of the instance.
        """
        pulumi.set(__self__, "instance", instance)
        pulumi.set(__self__, "named_ports", named_ports)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def instance(self) -> str:
        """
        URL to the instance.
        """
        return pulumi.get(self, "instance")

    @property
    @pulumi.getter(name="namedPorts")
    def named_ports(self) -> Sequence['outputs.GetRegionInstanceGroupInstanceNamedPortResult']:
        """
        List of named ports in the group, as a list of resources, each containing:
        """
        return pulumi.get(self, "named_ports")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        String description of current state of the instance.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRegionInstanceGroupInstanceNamedPortResult(dict):
    def __init__(__self__, *,
                 name: str,
                 port: int):
        """
        :param str name: The name of the instance group.  One of `name` or `self_link` must be provided.
        :param int port: Integer port number
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the instance group.  One of `name` or `self_link` must be provided.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Integer port number
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetResourcePolicyGroupPlacementPolicyResult(dict):
    def __init__(__self__, *,
                 availability_domain_count: int,
                 collocation: str,
                 vm_count: int):
        pulumi.set(__self__, "availability_domain_count", availability_domain_count)
        pulumi.set(__self__, "collocation", collocation)
        pulumi.set(__self__, "vm_count", vm_count)

    @property
    @pulumi.getter(name="availabilityDomainCount")
    def availability_domain_count(self) -> int:
        return pulumi.get(self, "availability_domain_count")

    @property
    @pulumi.getter
    def collocation(self) -> str:
        return pulumi.get(self, "collocation")

    @property
    @pulumi.getter(name="vmCount")
    def vm_count(self) -> int:
        return pulumi.get(self, "vm_count")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicyResult(dict):
    def __init__(__self__, *,
                 retention_policies: Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyRetentionPolicyResult'],
                 schedules: Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleResult'],
                 snapshot_properties: Sequence['outputs.GetResourcePolicySnapshotSchedulePolicySnapshotPropertyResult']):
        pulumi.set(__self__, "retention_policies", retention_policies)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "snapshot_properties", snapshot_properties)

    @property
    @pulumi.getter(name="retentionPolicies")
    def retention_policies(self) -> Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyRetentionPolicyResult']:
        return pulumi.get(self, "retention_policies")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleResult']:
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="snapshotProperties")
    def snapshot_properties(self) -> Sequence['outputs.GetResourcePolicySnapshotSchedulePolicySnapshotPropertyResult']:
        return pulumi.get(self, "snapshot_properties")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicyRetentionPolicyResult(dict):
    def __init__(__self__, *,
                 max_retention_days: int,
                 on_source_disk_delete: str):
        pulumi.set(__self__, "max_retention_days", max_retention_days)
        pulumi.set(__self__, "on_source_disk_delete", on_source_disk_delete)

    @property
    @pulumi.getter(name="maxRetentionDays")
    def max_retention_days(self) -> int:
        return pulumi.get(self, "max_retention_days")

    @property
    @pulumi.getter(name="onSourceDiskDelete")
    def on_source_disk_delete(self) -> str:
        return pulumi.get(self, "on_source_disk_delete")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicyScheduleResult(dict):
    def __init__(__self__, *,
                 daily_schedules: Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleResult'],
                 hourly_schedules: Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleResult'],
                 weekly_schedules: Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleResult']):
        pulumi.set(__self__, "daily_schedules", daily_schedules)
        pulumi.set(__self__, "hourly_schedules", hourly_schedules)
        pulumi.set(__self__, "weekly_schedules", weekly_schedules)

    @property
    @pulumi.getter(name="dailySchedules")
    def daily_schedules(self) -> Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleResult']:
        return pulumi.get(self, "daily_schedules")

    @property
    @pulumi.getter(name="hourlySchedules")
    def hourly_schedules(self) -> Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleResult']:
        return pulumi.get(self, "hourly_schedules")

    @property
    @pulumi.getter(name="weeklySchedules")
    def weekly_schedules(self) -> Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleResult']:
        return pulumi.get(self, "weekly_schedules")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleResult(dict):
    def __init__(__self__, *,
                 days_in_cycle: int,
                 start_time: str):
        pulumi.set(__self__, "days_in_cycle", days_in_cycle)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysInCycle")
    def days_in_cycle(self) -> int:
        return pulumi.get(self, "days_in_cycle")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleResult(dict):
    def __init__(__self__, *,
                 hours_in_cycle: int,
                 start_time: str):
        pulumi.set(__self__, "hours_in_cycle", hours_in_cycle)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="hoursInCycle")
    def hours_in_cycle(self) -> int:
        return pulumi.get(self, "hours_in_cycle")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleResult(dict):
    def __init__(__self__, *,
                 day_of_weeks: Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekResult']):
        pulumi.set(__self__, "day_of_weeks", day_of_weeks)

    @property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekResult']:
        return pulumi.get(self, "day_of_weeks")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekResult(dict):
    def __init__(__self__, *,
                 day: str,
                 start_time: str):
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def day(self) -> str:
        return pulumi.get(self, "day")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicySnapshotPropertyResult(dict):
    def __init__(__self__, *,
                 guest_flush: bool,
                 labels: Mapping[str, str],
                 storage_locations: Sequence[str]):
        pulumi.set(__self__, "guest_flush", guest_flush)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "storage_locations", storage_locations)

    @property
    @pulumi.getter(name="guestFlush")
    def guest_flush(self) -> bool:
        return pulumi.get(self, "guest_flush")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="storageLocations")
    def storage_locations(self) -> Sequence[str]:
        return pulumi.get(self, "storage_locations")


@pulumi.output_type
class GetRouterBgpResult(dict):
    def __init__(__self__, *,
                 advertise_mode: str,
                 advertised_groups: Sequence[str],
                 advertised_ip_ranges: Sequence['outputs.GetRouterBgpAdvertisedIpRangeResult'],
                 asn: int):
        pulumi.set(__self__, "advertise_mode", advertise_mode)
        pulumi.set(__self__, "advertised_groups", advertised_groups)
        pulumi.set(__self__, "advertised_ip_ranges", advertised_ip_ranges)
        pulumi.set(__self__, "asn", asn)

    @property
    @pulumi.getter(name="advertiseMode")
    def advertise_mode(self) -> str:
        return pulumi.get(self, "advertise_mode")

    @property
    @pulumi.getter(name="advertisedGroups")
    def advertised_groups(self) -> Sequence[str]:
        return pulumi.get(self, "advertised_groups")

    @property
    @pulumi.getter(name="advertisedIpRanges")
    def advertised_ip_ranges(self) -> Sequence['outputs.GetRouterBgpAdvertisedIpRangeResult']:
        return pulumi.get(self, "advertised_ip_ranges")

    @property
    @pulumi.getter
    def asn(self) -> int:
        return pulumi.get(self, "asn")


@pulumi.output_type
class GetRouterBgpAdvertisedIpRangeResult(dict):
    def __init__(__self__, *,
                 description: str,
                 range: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "range", range)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def range(self) -> str:
        return pulumi.get(self, "range")


@pulumi.output_type
class GetSubnetworkSecondaryIpRangeResult(dict):
    def __init__(__self__, *,
                 ip_cidr_range: str,
                 range_name: str):
        """
        :param str ip_cidr_range: The range of IP addresses belonging to this subnetwork
               secondary range.
        :param str range_name: The name associated with this subnetwork secondary range, used
               when adding an alias IP range to a VM instance.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> str:
        """
        The range of IP addresses belonging to this subnetwork
        secondary range.
        """
        return pulumi.get(self, "ip_cidr_range")

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        """
        The name associated with this subnetwork secondary range, used
        when adding an alias IP range to a VM instance.
        """
        return pulumi.get(self, "range_name")


