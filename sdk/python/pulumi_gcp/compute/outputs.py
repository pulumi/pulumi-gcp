# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AutoscalerAutoscalingPolicy',
    'AutoscalerAutoscalingPolicyCpuUtilization',
    'AutoscalerAutoscalingPolicyLoadBalancingUtilization',
    'AutoscalerAutoscalingPolicyMetric',
    'AutoscalerAutoscalingPolicyScaleDownControl',
    'AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas',
    'AutoscalerAutoscalingPolicyScaleInControl',
    'AutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas',
    'AutoscalerAutoscalingPolicyScalingSchedule',
    'BackendBucketCdnPolicy',
    'BackendBucketCdnPolicyBypassCacheOnRequestHeader',
    'BackendBucketCdnPolicyCacheKeyPolicy',
    'BackendBucketCdnPolicyNegativeCachingPolicy',
    'BackendBucketIamBindingCondition',
    'BackendBucketIamMemberCondition',
    'BackendBucketParams',
    'BackendServiceBackend',
    'BackendServiceBackendCustomMetric',
    'BackendServiceCdnPolicy',
    'BackendServiceCdnPolicyBypassCacheOnRequestHeader',
    'BackendServiceCdnPolicyCacheKeyPolicy',
    'BackendServiceCdnPolicyNegativeCachingPolicy',
    'BackendServiceCircuitBreakers',
    'BackendServiceCircuitBreakersConnectTimeout',
    'BackendServiceConsistentHash',
    'BackendServiceConsistentHashHttpCookie',
    'BackendServiceConsistentHashHttpCookieTtl',
    'BackendServiceCustomMetric',
    'BackendServiceDynamicForwarding',
    'BackendServiceDynamicForwardingIpPortSelection',
    'BackendServiceIamBindingCondition',
    'BackendServiceIamMemberCondition',
    'BackendServiceIap',
    'BackendServiceLocalityLbPolicy',
    'BackendServiceLocalityLbPolicyCustomPolicy',
    'BackendServiceLocalityLbPolicyPolicy',
    'BackendServiceLogConfig',
    'BackendServiceMaxStreamDuration',
    'BackendServiceNetworkPassThroughLbTrafficPolicy',
    'BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity',
    'BackendServiceOutlierDetection',
    'BackendServiceOutlierDetectionBaseEjectionTime',
    'BackendServiceOutlierDetectionInterval',
    'BackendServiceParams',
    'BackendServiceSecuritySettings',
    'BackendServiceSecuritySettingsAwsV4Authentication',
    'BackendServiceStrongSessionAffinityCookie',
    'BackendServiceStrongSessionAffinityCookieTtl',
    'BackendServiceTlsSettings',
    'BackendServiceTlsSettingsSubjectAltName',
    'DiskAsyncPrimaryDisk',
    'DiskAsyncReplicationSecondaryDisk',
    'DiskDiskEncryptionKey',
    'DiskGuestOsFeature',
    'DiskIamBindingCondition',
    'DiskIamMemberCondition',
    'DiskParams',
    'DiskSourceImageEncryptionKey',
    'DiskSourceSnapshotEncryptionKey',
    'ExternalVpnGatewayInterface',
    'FirewallAllow',
    'FirewallDeny',
    'FirewallLogConfig',
    'FirewallParams',
    'FirewallPolicyRuleMatch',
    'FirewallPolicyRuleMatchLayer4Config',
    'FirewallPolicyRuleMatchSrcSecureTag',
    'FirewallPolicyRuleTargetSecureTag',
    'FirewallPolicyWithRulesPredefinedRule',
    'FirewallPolicyWithRulesPredefinedRuleMatch',
    'FirewallPolicyWithRulesPredefinedRuleMatchLayer4Config',
    'FirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag',
    'FirewallPolicyWithRulesPredefinedRuleTargetSecureTag',
    'FirewallPolicyWithRulesRule',
    'FirewallPolicyWithRulesRuleMatch',
    'FirewallPolicyWithRulesRuleMatchLayer4Config',
    'FirewallPolicyWithRulesRuleMatchSrcSecureTag',
    'FirewallPolicyWithRulesRuleTargetSecureTag',
    'ForwardingRuleServiceDirectoryRegistrations',
    'FutureReservationAggregateReservation',
    'FutureReservationAggregateReservationReservedResource',
    'FutureReservationAggregateReservationReservedResourceAccelerator',
    'FutureReservationAutoCreatedReservationsDuration',
    'FutureReservationCommitmentInfo',
    'FutureReservationShareSettings',
    'FutureReservationShareSettingsProjectMap',
    'FutureReservationSpecificSkuProperties',
    'FutureReservationSpecificSkuPropertiesInstanceProperties',
    'FutureReservationSpecificSkuPropertiesInstancePropertiesGuestAccelerator',
    'FutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsd',
    'FutureReservationStatus',
    'FutureReservationStatusLastKnownGoodState',
    'FutureReservationStatusLastKnownGoodStateExistingMatchingUsageInfo',
    'FutureReservationStatusLastKnownGoodStateFutureReservationSpecs',
    'FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettings',
    'FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsProjectMap',
    'FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuProperties',
    'FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstanceProperties',
    'FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesGuestAccelerator',
    'FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocalSsd',
    'FutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindow',
    'FutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowDuration',
    'FutureReservationStatusSpecificSkuProperties',
    'FutureReservationTimeWindow',
    'FutureReservationTimeWindowDuration',
    'GlobalForwardingRuleMetadataFilter',
    'GlobalForwardingRuleMetadataFilterFilterLabel',
    'GlobalForwardingRuleServiceDirectoryRegistrations',
    'HaVpnGatewayVpnInterface',
    'HealthCheckGrpcHealthCheck',
    'HealthCheckGrpcTlsHealthCheck',
    'HealthCheckHttp2HealthCheck',
    'HealthCheckHttpHealthCheck',
    'HealthCheckHttpsHealthCheck',
    'HealthCheckLogConfig',
    'HealthCheckSslHealthCheck',
    'HealthCheckTcpHealthCheck',
    'ImageGuestOsFeature',
    'ImageIamBindingCondition',
    'ImageIamMemberCondition',
    'ImageImageEncryptionKey',
    'ImageRawDisk',
    'ImageShieldedInstanceInitialState',
    'ImageShieldedInstanceInitialStateDb',
    'ImageShieldedInstanceInitialStateDbx',
    'ImageShieldedInstanceInitialStateKek',
    'ImageShieldedInstanceInitialStatePk',
    'ImageSourceDiskEncryptionKey',
    'ImageSourceImageEncryptionKey',
    'ImageSourceSnapshotEncryptionKey',
    'InstanceAdvancedMachineFeatures',
    'InstanceAttachedDisk',
    'InstanceBootDisk',
    'InstanceBootDiskInitializeParams',
    'InstanceBootDiskInitializeParamsSourceImageEncryptionKey',
    'InstanceBootDiskInitializeParamsSourceSnapshotEncryptionKey',
    'InstanceConfidentialInstanceConfig',
    'InstanceFromMachineImageAdvancedMachineFeatures',
    'InstanceFromMachineImageAttachedDisk',
    'InstanceFromMachineImageBootDisk',
    'InstanceFromMachineImageBootDiskInitializeParams',
    'InstanceFromMachineImageBootDiskInitializeParamsSourceImageEncryptionKey',
    'InstanceFromMachineImageBootDiskInitializeParamsSourceSnapshotEncryptionKey',
    'InstanceFromMachineImageConfidentialInstanceConfig',
    'InstanceFromMachineImageGuestAccelerator',
    'InstanceFromMachineImageInstanceEncryptionKey',
    'InstanceFromMachineImageNetworkInterface',
    'InstanceFromMachineImageNetworkInterfaceAccessConfig',
    'InstanceFromMachineImageNetworkInterfaceAliasIpRange',
    'InstanceFromMachineImageNetworkInterfaceIpv6AccessConfig',
    'InstanceFromMachineImageNetworkPerformanceConfig',
    'InstanceFromMachineImageParams',
    'InstanceFromMachineImageReservationAffinity',
    'InstanceFromMachineImageReservationAffinitySpecificReservation',
    'InstanceFromMachineImageScheduling',
    'InstanceFromMachineImageSchedulingGracefulShutdown',
    'InstanceFromMachineImageSchedulingGracefulShutdownMaxDuration',
    'InstanceFromMachineImageSchedulingLocalSsdRecoveryTimeout',
    'InstanceFromMachineImageSchedulingMaxRunDuration',
    'InstanceFromMachineImageSchedulingNodeAffinity',
    'InstanceFromMachineImageSchedulingOnInstanceStopAction',
    'InstanceFromMachineImageScratchDisk',
    'InstanceFromMachineImageServiceAccount',
    'InstanceFromMachineImageShieldedInstanceConfig',
    'InstanceFromMachineImageSourceMachineImageEncryptionKey',
    'InstanceFromTemplateAdvancedMachineFeatures',
    'InstanceFromTemplateAttachedDisk',
    'InstanceFromTemplateBootDisk',
    'InstanceFromTemplateBootDiskInitializeParams',
    'InstanceFromTemplateBootDiskInitializeParamsSourceImageEncryptionKey',
    'InstanceFromTemplateBootDiskInitializeParamsSourceSnapshotEncryptionKey',
    'InstanceFromTemplateConfidentialInstanceConfig',
    'InstanceFromTemplateGuestAccelerator',
    'InstanceFromTemplateInstanceEncryptionKey',
    'InstanceFromTemplateNetworkInterface',
    'InstanceFromTemplateNetworkInterfaceAccessConfig',
    'InstanceFromTemplateNetworkInterfaceAliasIpRange',
    'InstanceFromTemplateNetworkInterfaceIpv6AccessConfig',
    'InstanceFromTemplateNetworkPerformanceConfig',
    'InstanceFromTemplateParams',
    'InstanceFromTemplateReservationAffinity',
    'InstanceFromTemplateReservationAffinitySpecificReservation',
    'InstanceFromTemplateScheduling',
    'InstanceFromTemplateSchedulingGracefulShutdown',
    'InstanceFromTemplateSchedulingGracefulShutdownMaxDuration',
    'InstanceFromTemplateSchedulingLocalSsdRecoveryTimeout',
    'InstanceFromTemplateSchedulingMaxRunDuration',
    'InstanceFromTemplateSchedulingNodeAffinity',
    'InstanceFromTemplateSchedulingOnInstanceStopAction',
    'InstanceFromTemplateScratchDisk',
    'InstanceFromTemplateServiceAccount',
    'InstanceFromTemplateShieldedInstanceConfig',
    'InstanceGroupManagerAllInstancesConfig',
    'InstanceGroupManagerAutoHealingPolicies',
    'InstanceGroupManagerInstanceLifecyclePolicy',
    'InstanceGroupManagerInstanceLifecyclePolicyOnRepair',
    'InstanceGroupManagerNamedPort',
    'InstanceGroupManagerParams',
    'InstanceGroupManagerResourcePolicies',
    'InstanceGroupManagerStandbyPolicy',
    'InstanceGroupManagerStatefulDisk',
    'InstanceGroupManagerStatefulExternalIp',
    'InstanceGroupManagerStatefulInternalIp',
    'InstanceGroupManagerStatus',
    'InstanceGroupManagerStatusAllInstancesConfig',
    'InstanceGroupManagerStatusStateful',
    'InstanceGroupManagerStatusStatefulPerInstanceConfig',
    'InstanceGroupManagerStatusVersionTarget',
    'InstanceGroupManagerUpdatePolicy',
    'InstanceGroupManagerVersion',
    'InstanceGroupManagerVersionTargetSize',
    'InstanceGroupNamedPort',
    'InstanceGuestAccelerator',
    'InstanceIAMBindingCondition',
    'InstanceIAMMemberCondition',
    'InstanceInstanceEncryptionKey',
    'InstanceNetworkInterface',
    'InstanceNetworkInterfaceAccessConfig',
    'InstanceNetworkInterfaceAliasIpRange',
    'InstanceNetworkInterfaceIpv6AccessConfig',
    'InstanceNetworkPerformanceConfig',
    'InstanceParams',
    'InstanceReservationAffinity',
    'InstanceReservationAffinitySpecificReservation',
    'InstanceScheduling',
    'InstanceSchedulingGracefulShutdown',
    'InstanceSchedulingGracefulShutdownMaxDuration',
    'InstanceSchedulingLocalSsdRecoveryTimeout',
    'InstanceSchedulingMaxRunDuration',
    'InstanceSchedulingNodeAffinity',
    'InstanceSchedulingOnInstanceStopAction',
    'InstanceScratchDisk',
    'InstanceServiceAccount',
    'InstanceSettingsMetadata',
    'InstanceShieldedInstanceConfig',
    'InstanceTemplateAdvancedMachineFeatures',
    'InstanceTemplateConfidentialInstanceConfig',
    'InstanceTemplateDisk',
    'InstanceTemplateDiskDiskEncryptionKey',
    'InstanceTemplateDiskSourceImageEncryptionKey',
    'InstanceTemplateDiskSourceSnapshotEncryptionKey',
    'InstanceTemplateGuestAccelerator',
    'InstanceTemplateIamBindingCondition',
    'InstanceTemplateIamMemberCondition',
    'InstanceTemplateNetworkInterface',
    'InstanceTemplateNetworkInterfaceAccessConfig',
    'InstanceTemplateNetworkInterfaceAliasIpRange',
    'InstanceTemplateNetworkInterfaceIpv6AccessConfig',
    'InstanceTemplateNetworkPerformanceConfig',
    'InstanceTemplateReservationAffinity',
    'InstanceTemplateReservationAffinitySpecificReservation',
    'InstanceTemplateScheduling',
    'InstanceTemplateSchedulingGracefulShutdown',
    'InstanceTemplateSchedulingGracefulShutdownMaxDuration',
    'InstanceTemplateSchedulingLocalSsdRecoveryTimeout',
    'InstanceTemplateSchedulingMaxRunDuration',
    'InstanceTemplateSchedulingNodeAffinity',
    'InstanceTemplateSchedulingOnInstanceStopAction',
    'InstanceTemplateServiceAccount',
    'InstanceTemplateShieldedInstanceConfig',
    'InstantSnapshotIamBindingCondition',
    'InstantSnapshotIamMemberCondition',
    'InterconnectApplicationAwareInterconnect',
    'InterconnectApplicationAwareInterconnectBandwidthPercentagePolicy',
    'InterconnectApplicationAwareInterconnectBandwidthPercentagePolicyBandwidthPercentage',
    'InterconnectApplicationAwareInterconnectShapeAveragePercentage',
    'InterconnectApplicationAwareInterconnectStrictPriorityPolicy',
    'InterconnectAttachmentGroupAttachment',
    'InterconnectAttachmentGroupConfigured',
    'InterconnectAttachmentGroupConfiguredAvailabilitySla',
    'InterconnectAttachmentGroupConfiguredAvailabilitySlaIntendedSlaBlocker',
    'InterconnectAttachmentGroupIntent',
    'InterconnectAttachmentGroupLogicalStructure',
    'InterconnectAttachmentGroupLogicalStructureRegion',
    'InterconnectAttachmentGroupLogicalStructureRegionMetro',
    'InterconnectAttachmentGroupLogicalStructureRegionMetroFacility',
    'InterconnectAttachmentGroupLogicalStructureRegionMetroFacilityZone',
    'InterconnectAttachmentPrivateInterconnectInfo',
    'InterconnectCircuitInfo',
    'InterconnectExpectedOutage',
    'InterconnectGroupConfigured',
    'InterconnectGroupConfiguredTopologyCapability',
    'InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlocker',
    'InterconnectGroupIntent',
    'InterconnectGroupInterconnect',
    'InterconnectGroupPhysicalStructure',
    'InterconnectGroupPhysicalStructureMetro',
    'InterconnectGroupPhysicalStructureMetroFacility',
    'InterconnectGroupPhysicalStructureMetroFacilityZone',
    'InterconnectMacsec',
    'InterconnectMacsecPreSharedKey',
    'InterconnectParams',
    'MachineImageIamBindingCondition',
    'MachineImageIamMemberCondition',
    'MachineImageMachineImageEncryptionKey',
    'ManagedSslCertificateManaged',
    'MangedSslCertificateManaged',
    'NetworkAttachmentConnectionEndpoint',
    'NetworkEndpointListNetworkEndpoint',
    'NetworkFirewallPolicyPacketMirroringRuleMatch',
    'NetworkFirewallPolicyPacketMirroringRuleMatchLayer4Config',
    'NetworkFirewallPolicyPacketMirroringRuleTargetSecureTag',
    'NetworkFirewallPolicyRuleMatch',
    'NetworkFirewallPolicyRuleMatchLayer4Config',
    'NetworkFirewallPolicyRuleMatchSrcSecureTag',
    'NetworkFirewallPolicyRuleTargetSecureTag',
    'NetworkFirewallPolicyWithRulesPredefinedRule',
    'NetworkFirewallPolicyWithRulesPredefinedRuleMatch',
    'NetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config',
    'NetworkFirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag',
    'NetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag',
    'NetworkFirewallPolicyWithRulesRule',
    'NetworkFirewallPolicyWithRulesRuleMatch',
    'NetworkFirewallPolicyWithRulesRuleMatchLayer4Config',
    'NetworkFirewallPolicyWithRulesRuleMatchSrcSecureTag',
    'NetworkFirewallPolicyWithRulesRuleTargetSecureTag',
    'NetworkParams',
    'NodeGroupAutoscalingPolicy',
    'NodeGroupMaintenanceWindow',
    'NodeGroupShareSettings',
    'NodeGroupShareSettingsProjectMap',
    'NodeTemplateAccelerator',
    'NodeTemplateDisk',
    'NodeTemplateNodeTypeFlexibility',
    'NodeTemplateServerBinding',
    'OrganizationSecurityPolicyRuleMatch',
    'OrganizationSecurityPolicyRuleMatchConfig',
    'OrganizationSecurityPolicyRuleMatchConfigLayer4Config',
    'PacketMirroringCollectorIlb',
    'PacketMirroringFilter',
    'PacketMirroringMirroredResources',
    'PacketMirroringMirroredResourcesInstance',
    'PacketMirroringMirroredResourcesSubnetwork',
    'PacketMirroringNetwork',
    'PerInstanceConfigPreservedState',
    'PerInstanceConfigPreservedStateDisk',
    'PerInstanceConfigPreservedStateExternalIp',
    'PerInstanceConfigPreservedStateExternalIpIpAddress',
    'PerInstanceConfigPreservedStateInternalIp',
    'PerInstanceConfigPreservedStateInternalIpIpAddress',
    'PreviewFeatureRolloutOperation',
    'PreviewFeatureRolloutOperationRolloutInput',
    'PublicDelegatedPrefixPublicDelegatedSubPrefix',
    'RegionAutoscalerAutoscalingPolicy',
    'RegionAutoscalerAutoscalingPolicyCpuUtilization',
    'RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization',
    'RegionAutoscalerAutoscalingPolicyMetric',
    'RegionAutoscalerAutoscalingPolicyScaleDownControl',
    'RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas',
    'RegionAutoscalerAutoscalingPolicyScaleInControl',
    'RegionAutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas',
    'RegionAutoscalerAutoscalingPolicyScalingSchedule',
    'RegionBackendServiceBackend',
    'RegionBackendServiceBackendCustomMetric',
    'RegionBackendServiceCdnPolicy',
    'RegionBackendServiceCdnPolicyCacheKeyPolicy',
    'RegionBackendServiceCdnPolicyNegativeCachingPolicy',
    'RegionBackendServiceCircuitBreakers',
    'RegionBackendServiceCircuitBreakersConnectTimeout',
    'RegionBackendServiceConnectionTrackingPolicy',
    'RegionBackendServiceConsistentHash',
    'RegionBackendServiceConsistentHashHttpCookie',
    'RegionBackendServiceConsistentHashHttpCookieTtl',
    'RegionBackendServiceCustomMetric',
    'RegionBackendServiceDynamicForwarding',
    'RegionBackendServiceDynamicForwardingIpPortSelection',
    'RegionBackendServiceFailoverPolicy',
    'RegionBackendServiceHaPolicy',
    'RegionBackendServiceHaPolicyLeader',
    'RegionBackendServiceHaPolicyLeaderNetworkEndpoint',
    'RegionBackendServiceIamBindingCondition',
    'RegionBackendServiceIamMemberCondition',
    'RegionBackendServiceIap',
    'RegionBackendServiceLogConfig',
    'RegionBackendServiceNetworkPassThroughLbTrafficPolicy',
    'RegionBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity',
    'RegionBackendServiceOutlierDetection',
    'RegionBackendServiceOutlierDetectionBaseEjectionTime',
    'RegionBackendServiceOutlierDetectionInterval',
    'RegionBackendServiceParams',
    'RegionBackendServiceStrongSessionAffinityCookie',
    'RegionBackendServiceStrongSessionAffinityCookieTtl',
    'RegionBackendServiceSubsetting',
    'RegionBackendServiceTlsSettings',
    'RegionBackendServiceTlsSettingsSubjectAltName',
    'RegionCommitmentLicenseResource',
    'RegionCommitmentResource',
    'RegionDiskAsyncPrimaryDisk',
    'RegionDiskDiskEncryptionKey',
    'RegionDiskGuestOsFeature',
    'RegionDiskIamBindingCondition',
    'RegionDiskIamMemberCondition',
    'RegionDiskSourceSnapshotEncryptionKey',
    'RegionHealthCheckGrpcHealthCheck',
    'RegionHealthCheckGrpcTlsHealthCheck',
    'RegionHealthCheckHttp2HealthCheck',
    'RegionHealthCheckHttpHealthCheck',
    'RegionHealthCheckHttpsHealthCheck',
    'RegionHealthCheckLogConfig',
    'RegionHealthCheckSslHealthCheck',
    'RegionHealthCheckTcpHealthCheck',
    'RegionInstanceGroupManagerAllInstancesConfig',
    'RegionInstanceGroupManagerAutoHealingPolicies',
    'RegionInstanceGroupManagerInstanceFlexibilityPolicy',
    'RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection',
    'RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk',
    'RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKey',
    'RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabel',
    'RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTag',
    'RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKey',
    'RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKey',
    'RegionInstanceGroupManagerInstanceLifecyclePolicy',
    'RegionInstanceGroupManagerInstanceLifecyclePolicyOnRepair',
    'RegionInstanceGroupManagerNamedPort',
    'RegionInstanceGroupManagerParams',
    'RegionInstanceGroupManagerStandbyPolicy',
    'RegionInstanceGroupManagerStatefulDisk',
    'RegionInstanceGroupManagerStatefulExternalIp',
    'RegionInstanceGroupManagerStatefulInternalIp',
    'RegionInstanceGroupManagerStatus',
    'RegionInstanceGroupManagerStatusAllInstancesConfig',
    'RegionInstanceGroupManagerStatusStateful',
    'RegionInstanceGroupManagerStatusStatefulPerInstanceConfig',
    'RegionInstanceGroupManagerStatusVersionTarget',
    'RegionInstanceGroupManagerUpdatePolicy',
    'RegionInstanceGroupManagerVersion',
    'RegionInstanceGroupManagerVersionTargetSize',
    'RegionInstanceTemplateAdvancedMachineFeatures',
    'RegionInstanceTemplateConfidentialInstanceConfig',
    'RegionInstanceTemplateDisk',
    'RegionInstanceTemplateDiskDiskEncryptionKey',
    'RegionInstanceTemplateDiskSourceImageEncryptionKey',
    'RegionInstanceTemplateDiskSourceSnapshotEncryptionKey',
    'RegionInstanceTemplateGuestAccelerator',
    'RegionInstanceTemplateNetworkInterface',
    'RegionInstanceTemplateNetworkInterfaceAccessConfig',
    'RegionInstanceTemplateNetworkInterfaceAliasIpRange',
    'RegionInstanceTemplateNetworkInterfaceIpv6AccessConfig',
    'RegionInstanceTemplateNetworkPerformanceConfig',
    'RegionInstanceTemplateReservationAffinity',
    'RegionInstanceTemplateReservationAffinitySpecificReservation',
    'RegionInstanceTemplateScheduling',
    'RegionInstanceTemplateSchedulingGracefulShutdown',
    'RegionInstanceTemplateSchedulingGracefulShutdownMaxDuration',
    'RegionInstanceTemplateSchedulingLocalSsdRecoveryTimeout',
    'RegionInstanceTemplateSchedulingMaxRunDuration',
    'RegionInstanceTemplateSchedulingNodeAffinity',
    'RegionInstanceTemplateSchedulingOnInstanceStopAction',
    'RegionInstanceTemplateServiceAccount',
    'RegionInstanceTemplateShieldedInstanceConfig',
    'RegionNetworkEndpointGroupAppEngine',
    'RegionNetworkEndpointGroupCloudFunction',
    'RegionNetworkEndpointGroupCloudRun',
    'RegionNetworkEndpointGroupPscData',
    'RegionNetworkEndpointGroupServerlessDeployment',
    'RegionNetworkFirewallPolicyRuleMatch',
    'RegionNetworkFirewallPolicyRuleMatchLayer4Config',
    'RegionNetworkFirewallPolicyRuleMatchSrcSecureTag',
    'RegionNetworkFirewallPolicyRuleTargetSecureTag',
    'RegionNetworkFirewallPolicyWithRulesPredefinedRule',
    'RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatch',
    'RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config',
    'RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag',
    'RegionNetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag',
    'RegionNetworkFirewallPolicyWithRulesRule',
    'RegionNetworkFirewallPolicyWithRulesRuleMatch',
    'RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4Config',
    'RegionNetworkFirewallPolicyWithRulesRuleMatchSrcSecureTag',
    'RegionNetworkFirewallPolicyWithRulesRuleTargetSecureTag',
    'RegionPerInstanceConfigPreservedState',
    'RegionPerInstanceConfigPreservedStateDisk',
    'RegionPerInstanceConfigPreservedStateExternalIp',
    'RegionPerInstanceConfigPreservedStateExternalIpIpAddress',
    'RegionPerInstanceConfigPreservedStateInternalIp',
    'RegionPerInstanceConfigPreservedStateInternalIpIpAddress',
    'RegionResizeRequestRequestedRunDuration',
    'RegionResizeRequestStatus',
    'RegionResizeRequestStatusError',
    'RegionResizeRequestStatusErrorError',
    'RegionResizeRequestStatusErrorErrorErrorDetail',
    'RegionResizeRequestStatusErrorErrorErrorDetailErrorInfo',
    'RegionResizeRequestStatusErrorErrorErrorDetailHelp',
    'RegionResizeRequestStatusErrorErrorErrorDetailHelpLink',
    'RegionResizeRequestStatusErrorErrorErrorDetailLocalizedMessage',
    'RegionResizeRequestStatusErrorErrorErrorDetailQuotaInfo',
    'RegionResizeRequestStatusLastAttempt',
    'RegionResizeRequestStatusLastAttemptError',
    'RegionResizeRequestStatusLastAttemptErrorError',
    'RegionResizeRequestStatusLastAttemptErrorErrorErrorDetail',
    'RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailErrorInfo',
    'RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailHelp',
    'RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpLink',
    'RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailLocalizedMessage',
    'RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo',
    'RegionSecurityPolicyAdvancedOptionsConfig',
    'RegionSecurityPolicyAdvancedOptionsConfigJsonCustomConfig',
    'RegionSecurityPolicyDdosProtectionConfig',
    'RegionSecurityPolicyRule',
    'RegionSecurityPolicyRuleMatch',
    'RegionSecurityPolicyRuleMatchConfig',
    'RegionSecurityPolicyRuleMatchExpr',
    'RegionSecurityPolicyRuleNetworkMatch',
    'RegionSecurityPolicyRuleNetworkMatchUserDefinedField',
    'RegionSecurityPolicyRulePreconfiguredWafConfig',
    'RegionSecurityPolicyRulePreconfiguredWafConfigExclusion',
    'RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCooky',
    'RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeader',
    'RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParam',
    'RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUri',
    'RegionSecurityPolicyRuleRateLimitOptions',
    'RegionSecurityPolicyRuleRateLimitOptionsBanThreshold',
    'RegionSecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig',
    'RegionSecurityPolicyRuleRateLimitOptionsRateLimitThreshold',
    'RegionSecurityPolicyUserDefinedField',
    'RegionUrlMapDefaultRouteAction',
    'RegionUrlMapDefaultRouteActionCorsPolicy',
    'RegionUrlMapDefaultRouteActionFaultInjectionPolicy',
    'RegionUrlMapDefaultRouteActionFaultInjectionPolicyAbort',
    'RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelay',
    'RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay',
    'RegionUrlMapDefaultRouteActionRequestMirrorPolicy',
    'RegionUrlMapDefaultRouteActionRetryPolicy',
    'RegionUrlMapDefaultRouteActionRetryPolicyPerTryTimeout',
    'RegionUrlMapDefaultRouteActionTimeout',
    'RegionUrlMapDefaultRouteActionUrlRewrite',
    'RegionUrlMapDefaultRouteActionWeightedBackendService',
    'RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderAction',
    'RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'RegionUrlMapDefaultUrlRedirect',
    'RegionUrlMapHeaderAction',
    'RegionUrlMapHeaderActionRequestHeadersToAdd',
    'RegionUrlMapHeaderActionResponseHeadersToAdd',
    'RegionUrlMapHostRule',
    'RegionUrlMapPathMatcher',
    'RegionUrlMapPathMatcherDefaultRouteAction',
    'RegionUrlMapPathMatcherDefaultRouteActionCorsPolicy',
    'RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicy',
    'RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort',
    'RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay',
    'RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay',
    'RegionUrlMapPathMatcherDefaultRouteActionMaxStreamDuration',
    'RegionUrlMapPathMatcherDefaultRouteActionRequestMirrorPolicy',
    'RegionUrlMapPathMatcherDefaultRouteActionRetryPolicy',
    'RegionUrlMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout',
    'RegionUrlMapPathMatcherDefaultRouteActionTimeout',
    'RegionUrlMapPathMatcherDefaultRouteActionUrlRewrite',
    'RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendService',
    'RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction',
    'RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'RegionUrlMapPathMatcherDefaultUrlRedirect',
    'RegionUrlMapPathMatcherHeaderAction',
    'RegionUrlMapPathMatcherHeaderActionRequestHeadersToAdd',
    'RegionUrlMapPathMatcherHeaderActionResponseHeadersToAdd',
    'RegionUrlMapPathMatcherPathRule',
    'RegionUrlMapPathMatcherPathRuleRouteAction',
    'RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy',
    'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy',
    'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort',
    'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay',
    'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
    'RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy',
    'RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy',
    'RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout',
    'RegionUrlMapPathMatcherPathRuleRouteActionTimeout',
    'RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite',
    'RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService',
    'RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction',
    'RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'RegionUrlMapPathMatcherPathRuleUrlRedirect',
    'RegionUrlMapPathMatcherRouteRule',
    'RegionUrlMapPathMatcherRouteRuleHeaderAction',
    'RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd',
    'RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd',
    'RegionUrlMapPathMatcherRouteRuleMatchRule',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel',
    'RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch',
    'RegionUrlMapPathMatcherRouteRuleRouteAction',
    'RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy',
    'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy',
    'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort',
    'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay',
    'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
    'RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy',
    'RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy',
    'RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout',
    'RegionUrlMapPathMatcherRouteRuleRouteActionTimeout',
    'RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite',
    'RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService',
    'RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction',
    'RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'RegionUrlMapPathMatcherRouteRuleUrlRedirect',
    'RegionUrlMapTest',
    'ReservationDeleteAfterDuration',
    'ReservationReservationSharingPolicy',
    'ReservationResourceStatus',
    'ReservationResourceStatusHealthInfo',
    'ReservationResourceStatusReservationMaintenance',
    'ReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenance',
    'ReservationResourceStatusSpecificSkuAllocation',
    'ReservationShareSettings',
    'ReservationShareSettingsProjectMap',
    'ReservationSpecificReservation',
    'ReservationSpecificReservationInstanceProperties',
    'ReservationSpecificReservationInstancePropertiesGuestAccelerator',
    'ReservationSpecificReservationInstancePropertiesLocalSsd',
    'ResizeRequestRequestedRunDuration',
    'ResizeRequestStatus',
    'ResizeRequestStatusError',
    'ResizeRequestStatusErrorError',
    'ResizeRequestStatusErrorErrorErrorDetail',
    'ResizeRequestStatusErrorErrorErrorDetailErrorInfo',
    'ResizeRequestStatusErrorErrorErrorDetailHelp',
    'ResizeRequestStatusErrorErrorErrorDetailHelpLink',
    'ResizeRequestStatusErrorErrorErrorDetailLocalizedMessage',
    'ResizeRequestStatusErrorErrorErrorDetailQuotaInfo',
    'ResizeRequestStatusLastAttempt',
    'ResizeRequestStatusLastAttemptError',
    'ResizeRequestStatusLastAttemptErrorError',
    'ResizeRequestStatusLastAttemptErrorErrorErrorDetail',
    'ResizeRequestStatusLastAttemptErrorErrorErrorDetailErrorInfo',
    'ResizeRequestStatusLastAttemptErrorErrorErrorDetailHelp',
    'ResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpLink',
    'ResizeRequestStatusLastAttemptErrorErrorErrorDetailLocalizedMessage',
    'ResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo',
    'ResourcePolicyDiskConsistencyGroupPolicy',
    'ResourcePolicyGroupPlacementPolicy',
    'ResourcePolicyInstanceSchedulePolicy',
    'ResourcePolicyInstanceSchedulePolicyVmStartSchedule',
    'ResourcePolicyInstanceSchedulePolicyVmStopSchedule',
    'ResourcePolicySnapshotSchedulePolicy',
    'ResourcePolicySnapshotSchedulePolicyRetentionPolicy',
    'ResourcePolicySnapshotSchedulePolicySchedule',
    'ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule',
    'ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule',
    'ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule',
    'ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek',
    'ResourcePolicySnapshotSchedulePolicySnapshotProperties',
    'ResourcePolicyWorkloadPolicy',
    'RouteAsPath',
    'RouteParams',
    'RouteWarning',
    'RouteWarningData',
    'RouterBgp',
    'RouterBgpAdvertisedIpRange',
    'RouterMd5AuthenticationKeys',
    'RouterNatLogConfig',
    'RouterNatNat64Subnetwork',
    'RouterNatRule',
    'RouterNatRuleAction',
    'RouterNatSubnetwork',
    'RouterParams',
    'RouterPeerAdvertisedIpRange',
    'RouterPeerBfd',
    'RouterPeerCustomLearnedIpRange',
    'RouterPeerMd5AuthenticationKey',
    'RouterRoutePolicyTerm',
    'RouterRoutePolicyTermAction',
    'RouterRoutePolicyTermMatch',
    'RouterStatusBestRouteResult',
    'RouterStatusBestRouteAsPathResult',
    'RouterStatusBestRouteParamResult',
    'RouterStatusBestRouteWarningResult',
    'RouterStatusBestRouteWarningDataResult',
    'RouterStatusBestRoutesForRouterResult',
    'RouterStatusBestRoutesForRouterAsPathResult',
    'RouterStatusBestRoutesForRouterParamResult',
    'RouterStatusBestRoutesForRouterWarningResult',
    'RouterStatusBestRoutesForRouterWarningDataResult',
    'SecurityPolicyAdaptiveProtectionConfig',
    'SecurityPolicyAdaptiveProtectionConfigAutoDeployConfig',
    'SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig',
    'SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig',
    'SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig',
    'SecurityPolicyAdvancedOptionsConfig',
    'SecurityPolicyAdvancedOptionsConfigJsonCustomConfig',
    'SecurityPolicyRecaptchaOptionsConfig',
    'SecurityPolicyRule',
    'SecurityPolicyRuleHeaderAction',
    'SecurityPolicyRuleHeaderActionRequestHeadersToAdd',
    'SecurityPolicyRuleMatch',
    'SecurityPolicyRuleMatchConfig',
    'SecurityPolicyRuleMatchExpr',
    'SecurityPolicyRuleMatchExprOptions',
    'SecurityPolicyRuleMatchExprOptionsRecaptchaOptions',
    'SecurityPolicyRulePreconfiguredWafConfig',
    'SecurityPolicyRulePreconfiguredWafConfigExclusion',
    'SecurityPolicyRulePreconfiguredWafConfigExclusionRequestCooky',
    'SecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeader',
    'SecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParam',
    'SecurityPolicyRulePreconfiguredWafConfigExclusionRequestUri',
    'SecurityPolicyRuleRateLimitOptions',
    'SecurityPolicyRuleRateLimitOptionsBanThreshold',
    'SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig',
    'SecurityPolicyRuleRateLimitOptionsExceedRedirectOptions',
    'SecurityPolicyRuleRateLimitOptionsRateLimitThreshold',
    'SecurityPolicyRuleRedirectOptions',
    'SecurityScanConfigAuthentication',
    'SecurityScanConfigAuthenticationCustomAccount',
    'SecurityScanConfigAuthenticationGoogleAccount',
    'SecurityScanConfigSchedule',
    'ServiceAttachmentConnectedEndpoint',
    'ServiceAttachmentConsumerAcceptList',
    'ServiceAttachmentPscServiceAttachmentId',
    'ServiceAttachmentTunnelingConfig',
    'SnapshotIamBindingCondition',
    'SnapshotIamMemberCondition',
    'SnapshotSettingsStorageLocation',
    'SnapshotSettingsStorageLocationLocation',
    'SnapshotSnapshotEncryptionKey',
    'SnapshotSourceDiskEncryptionKey',
    'StoragePoolIamBindingCondition',
    'StoragePoolIamMemberCondition',
    'StoragePoolResourceStatus',
    'StoragePoolStatus',
    'SubnetworkIAMBindingCondition',
    'SubnetworkIAMMemberCondition',
    'SubnetworkLogConfig',
    'SubnetworkParams',
    'SubnetworkSecondaryIpRange',
    'URLMapDefaultCustomErrorResponsePolicy',
    'URLMapDefaultCustomErrorResponsePolicyErrorResponseRule',
    'URLMapDefaultRouteAction',
    'URLMapDefaultRouteActionCorsPolicy',
    'URLMapDefaultRouteActionFaultInjectionPolicy',
    'URLMapDefaultRouteActionFaultInjectionPolicyAbort',
    'URLMapDefaultRouteActionFaultInjectionPolicyDelay',
    'URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay',
    'URLMapDefaultRouteActionMaxStreamDuration',
    'URLMapDefaultRouteActionRequestMirrorPolicy',
    'URLMapDefaultRouteActionRetryPolicy',
    'URLMapDefaultRouteActionRetryPolicyPerTryTimeout',
    'URLMapDefaultRouteActionTimeout',
    'URLMapDefaultRouteActionUrlRewrite',
    'URLMapDefaultRouteActionWeightedBackendService',
    'URLMapDefaultRouteActionWeightedBackendServiceHeaderAction',
    'URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'URLMapDefaultUrlRedirect',
    'URLMapHeaderAction',
    'URLMapHeaderActionRequestHeadersToAdd',
    'URLMapHeaderActionResponseHeadersToAdd',
    'URLMapHostRule',
    'URLMapPathMatcher',
    'URLMapPathMatcherDefaultCustomErrorResponsePolicy',
    'URLMapPathMatcherDefaultCustomErrorResponsePolicyErrorResponseRule',
    'URLMapPathMatcherDefaultRouteAction',
    'URLMapPathMatcherDefaultRouteActionCorsPolicy',
    'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicy',
    'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort',
    'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay',
    'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay',
    'URLMapPathMatcherDefaultRouteActionMaxStreamDuration',
    'URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy',
    'URLMapPathMatcherDefaultRouteActionRetryPolicy',
    'URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout',
    'URLMapPathMatcherDefaultRouteActionTimeout',
    'URLMapPathMatcherDefaultRouteActionUrlRewrite',
    'URLMapPathMatcherDefaultRouteActionWeightedBackendService',
    'URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction',
    'URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherDefaultUrlRedirect',
    'URLMapPathMatcherHeaderAction',
    'URLMapPathMatcherHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherPathRule',
    'URLMapPathMatcherPathRuleCustomErrorResponsePolicy',
    'URLMapPathMatcherPathRuleCustomErrorResponsePolicyErrorResponseRule',
    'URLMapPathMatcherPathRuleRouteAction',
    'URLMapPathMatcherPathRuleRouteActionCorsPolicy',
    'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy',
    'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort',
    'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay',
    'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
    'URLMapPathMatcherPathRuleRouteActionMaxStreamDuration',
    'URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy',
    'URLMapPathMatcherPathRuleRouteActionRetryPolicy',
    'URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout',
    'URLMapPathMatcherPathRuleRouteActionTimeout',
    'URLMapPathMatcherPathRuleRouteActionUrlRewrite',
    'URLMapPathMatcherPathRuleRouteActionWeightedBackendService',
    'URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction',
    'URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherPathRuleUrlRedirect',
    'URLMapPathMatcherRouteRule',
    'URLMapPathMatcherRouteRuleCustomErrorResponsePolicy',
    'URLMapPathMatcherRouteRuleCustomErrorResponsePolicyErrorResponseRule',
    'URLMapPathMatcherRouteRuleHeaderAction',
    'URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherRouteRuleHttpFilterConfig',
    'URLMapPathMatcherRouteRuleHttpFilterMetadata',
    'URLMapPathMatcherRouteRuleMatchRule',
    'URLMapPathMatcherRouteRuleMatchRuleHeaderMatch',
    'URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch',
    'URLMapPathMatcherRouteRuleMatchRuleMetadataFilter',
    'URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel',
    'URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch',
    'URLMapPathMatcherRouteRuleRouteAction',
    'URLMapPathMatcherRouteRuleRouteActionCorsPolicy',
    'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy',
    'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort',
    'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay',
    'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
    'URLMapPathMatcherRouteRuleRouteActionMaxStreamDuration',
    'URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy',
    'URLMapPathMatcherRouteRuleRouteActionRetryPolicy',
    'URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout',
    'URLMapPathMatcherRouteRuleRouteActionTimeout',
    'URLMapPathMatcherRouteRuleRouteActionUrlRewrite',
    'URLMapPathMatcherRouteRuleRouteActionWeightedBackendService',
    'URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction',
    'URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd',
    'URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd',
    'URLMapPathMatcherRouteRuleUrlRedirect',
    'URLMapTest',
    'URLMapTestHeader',
    'VPNTunnelCipherSuite',
    'VPNTunnelCipherSuitePhase1',
    'VPNTunnelCipherSuitePhase2',
    'WireGroupEndpoint',
    'WireGroupEndpointInterconnect',
    'WireGroupTopology',
    'WireGroupTopologyEndpoint',
    'WireGroupWire',
    'WireGroupWireEndpoint',
    'WireGroupWireGroupProperties',
    'WireGroupWireProperties',
    'WireGroupWireWireProperty',
    'GetAddressesAddressResult',
    'GetBackendBucketCdnPolicyResult',
    'GetBackendBucketCdnPolicyBypassCacheOnRequestHeaderResult',
    'GetBackendBucketCdnPolicyCacheKeyPolicyResult',
    'GetBackendBucketCdnPolicyNegativeCachingPolicyResult',
    'GetBackendBucketParamResult',
    'GetBackendServiceBackendResult',
    'GetBackendServiceBackendCustomMetricResult',
    'GetBackendServiceCdnPolicyResult',
    'GetBackendServiceCdnPolicyBypassCacheOnRequestHeaderResult',
    'GetBackendServiceCdnPolicyCacheKeyPolicyResult',
    'GetBackendServiceCdnPolicyNegativeCachingPolicyResult',
    'GetBackendServiceCircuitBreakerResult',
    'GetBackendServiceCircuitBreakerConnectTimeoutResult',
    'GetBackendServiceConsistentHashResult',
    'GetBackendServiceConsistentHashHttpCookyResult',
    'GetBackendServiceConsistentHashHttpCookyTtlResult',
    'GetBackendServiceCustomMetricResult',
    'GetBackendServiceDynamicForwardingResult',
    'GetBackendServiceDynamicForwardingIpPortSelectionResult',
    'GetBackendServiceIapResult',
    'GetBackendServiceLocalityLbPolicyResult',
    'GetBackendServiceLocalityLbPolicyCustomPolicyResult',
    'GetBackendServiceLocalityLbPolicyPolicyResult',
    'GetBackendServiceLogConfigResult',
    'GetBackendServiceMaxStreamDurationResult',
    'GetBackendServiceNetworkPassThroughLbTrafficPolicyResult',
    'GetBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinityResult',
    'GetBackendServiceOutlierDetectionResult',
    'GetBackendServiceOutlierDetectionBaseEjectionTimeResult',
    'GetBackendServiceOutlierDetectionIntervalResult',
    'GetBackendServiceParamResult',
    'GetBackendServiceSecuritySettingResult',
    'GetBackendServiceSecuritySettingAwsV4AuthenticationResult',
    'GetBackendServiceStrongSessionAffinityCookyResult',
    'GetBackendServiceStrongSessionAffinityCookyTtlResult',
    'GetBackendServiceTlsSettingResult',
    'GetBackendServiceTlsSettingSubjectAltNameResult',
    'GetDiskAsyncPrimaryDiskResult',
    'GetDiskDiskEncryptionKeyResult',
    'GetDiskGuestOsFeatureResult',
    'GetDiskParamResult',
    'GetDiskSourceImageEncryptionKeyResult',
    'GetDiskSourceSnapshotEncryptionKeyResult',
    'GetForwardingRuleServiceDirectoryRegistrationResult',
    'GetForwardingRulesRuleResult',
    'GetForwardingRulesRuleServiceDirectoryRegistrationResult',
    'GetGlobalForwardingRuleMetadataFilterResult',
    'GetGlobalForwardingRuleMetadataFilterFilterLabelResult',
    'GetGlobalForwardingRuleServiceDirectoryRegistrationResult',
    'GetHcVpnGatewayVpnInterfaceResult',
    'GetHealthCheckGrpcHealthCheckResult',
    'GetHealthCheckGrpcTlsHealthCheckResult',
    'GetHealthCheckHttp2HealthCheckResult',
    'GetHealthCheckHttpHealthCheckResult',
    'GetHealthCheckHttpsHealthCheckResult',
    'GetHealthCheckLogConfigResult',
    'GetHealthCheckSslHealthCheckResult',
    'GetHealthCheckTcpHealthCheckResult',
    'GetImagesImageResult',
    'GetInstanceAdvancedMachineFeatureResult',
    'GetInstanceAttachedDiskResult',
    'GetInstanceBootDiskResult',
    'GetInstanceBootDiskInitializeParamResult',
    'GetInstanceBootDiskInitializeParamSourceImageEncryptionKeyResult',
    'GetInstanceBootDiskInitializeParamSourceSnapshotEncryptionKeyResult',
    'GetInstanceConfidentialInstanceConfigResult',
    'GetInstanceGroupManagerAllInstancesConfigResult',
    'GetInstanceGroupManagerAutoHealingPolicyResult',
    'GetInstanceGroupManagerInstanceLifecyclePolicyResult',
    'GetInstanceGroupManagerInstanceLifecyclePolicyOnRepairResult',
    'GetInstanceGroupManagerNamedPortResult',
    'GetInstanceGroupManagerParamResult',
    'GetInstanceGroupManagerResourcePolicyResult',
    'GetInstanceGroupManagerStandbyPolicyResult',
    'GetInstanceGroupManagerStatefulDiskResult',
    'GetInstanceGroupManagerStatefulExternalIpResult',
    'GetInstanceGroupManagerStatefulInternalIpResult',
    'GetInstanceGroupManagerStatusResult',
    'GetInstanceGroupManagerStatusAllInstancesConfigResult',
    'GetInstanceGroupManagerStatusStatefulResult',
    'GetInstanceGroupManagerStatusStatefulPerInstanceConfigResult',
    'GetInstanceGroupManagerStatusVersionTargetResult',
    'GetInstanceGroupManagerUpdatePolicyResult',
    'GetInstanceGroupManagerVersionResult',
    'GetInstanceGroupManagerVersionTargetSizeResult',
    'GetInstanceGroupNamedPortResult',
    'GetInstanceGuestAcceleratorResult',
    'GetInstanceGuestAttributesQueryValueResult',
    'GetInstanceInstanceEncryptionKeyResult',
    'GetInstanceNetworkInterfaceResult',
    'GetInstanceNetworkInterfaceAccessConfigResult',
    'GetInstanceNetworkInterfaceAliasIpRangeResult',
    'GetInstanceNetworkInterfaceIpv6AccessConfigResult',
    'GetInstanceNetworkPerformanceConfigResult',
    'GetInstanceParamResult',
    'GetInstanceReservationAffinityResult',
    'GetInstanceReservationAffinitySpecificReservationResult',
    'GetInstanceSchedulingResult',
    'GetInstanceSchedulingGracefulShutdownResult',
    'GetInstanceSchedulingGracefulShutdownMaxDurationResult',
    'GetInstanceSchedulingLocalSsdRecoveryTimeoutResult',
    'GetInstanceSchedulingMaxRunDurationResult',
    'GetInstanceSchedulingNodeAffinityResult',
    'GetInstanceSchedulingOnInstanceStopActionResult',
    'GetInstanceScratchDiskResult',
    'GetInstanceServiceAccountResult',
    'GetInstanceShieldedInstanceConfigResult',
    'GetInstanceTemplateAdvancedMachineFeatureResult',
    'GetInstanceTemplateConfidentialInstanceConfigResult',
    'GetInstanceTemplateDiskResult',
    'GetInstanceTemplateDiskDiskEncryptionKeyResult',
    'GetInstanceTemplateDiskSourceImageEncryptionKeyResult',
    'GetInstanceTemplateDiskSourceSnapshotEncryptionKeyResult',
    'GetInstanceTemplateGuestAcceleratorResult',
    'GetInstanceTemplateNetworkInterfaceResult',
    'GetInstanceTemplateNetworkInterfaceAccessConfigResult',
    'GetInstanceTemplateNetworkInterfaceAliasIpRangeResult',
    'GetInstanceTemplateNetworkInterfaceIpv6AccessConfigResult',
    'GetInstanceTemplateNetworkPerformanceConfigResult',
    'GetInstanceTemplateReservationAffinityResult',
    'GetInstanceTemplateReservationAffinitySpecificReservationResult',
    'GetInstanceTemplateSchedulingResult',
    'GetInstanceTemplateSchedulingGracefulShutdownResult',
    'GetInstanceTemplateSchedulingGracefulShutdownMaxDurationResult',
    'GetInstanceTemplateSchedulingLocalSsdRecoveryTimeoutResult',
    'GetInstanceTemplateSchedulingMaxRunDurationResult',
    'GetInstanceTemplateSchedulingNodeAffinityResult',
    'GetInstanceTemplateSchedulingOnInstanceStopActionResult',
    'GetInstanceTemplateServiceAccountResult',
    'GetInstanceTemplateShieldedInstanceConfigResult',
    'GetInterconnectLocationsLocationResult',
    'GetMachineTypesMachineTypeResult',
    'GetMachineTypesMachineTypeAcceleratorResult',
    'GetMachineTypesMachineTypeBundledLocalSsdResult',
    'GetMachineTypesMachineTypeDeprecatedResult',
    'GetNetworkAttachmentConnectionEndpointResult',
    'GetRegionBackendServiceBackendResult',
    'GetRegionBackendServiceBackendCustomMetricResult',
    'GetRegionBackendServiceCdnPolicyResult',
    'GetRegionBackendServiceCdnPolicyCacheKeyPolicyResult',
    'GetRegionBackendServiceCdnPolicyNegativeCachingPolicyResult',
    'GetRegionBackendServiceCircuitBreakerResult',
    'GetRegionBackendServiceCircuitBreakerConnectTimeoutResult',
    'GetRegionBackendServiceConnectionTrackingPolicyResult',
    'GetRegionBackendServiceConsistentHashResult',
    'GetRegionBackendServiceConsistentHashHttpCookyResult',
    'GetRegionBackendServiceConsistentHashHttpCookyTtlResult',
    'GetRegionBackendServiceCustomMetricResult',
    'GetRegionBackendServiceDynamicForwardingResult',
    'GetRegionBackendServiceDynamicForwardingIpPortSelectionResult',
    'GetRegionBackendServiceFailoverPolicyResult',
    'GetRegionBackendServiceHaPolicyResult',
    'GetRegionBackendServiceHaPolicyLeaderResult',
    'GetRegionBackendServiceHaPolicyLeaderNetworkEndpointResult',
    'GetRegionBackendServiceIapResult',
    'GetRegionBackendServiceLogConfigResult',
    'GetRegionBackendServiceNetworkPassThroughLbTrafficPolicyResult',
    'GetRegionBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinityResult',
    'GetRegionBackendServiceOutlierDetectionResult',
    'GetRegionBackendServiceOutlierDetectionBaseEjectionTimeResult',
    'GetRegionBackendServiceOutlierDetectionIntervalResult',
    'GetRegionBackendServiceParamResult',
    'GetRegionBackendServiceStrongSessionAffinityCookyResult',
    'GetRegionBackendServiceStrongSessionAffinityCookyTtlResult',
    'GetRegionBackendServiceSubsettingResult',
    'GetRegionBackendServiceTlsSettingResult',
    'GetRegionBackendServiceTlsSettingSubjectAltNameResult',
    'GetRegionDiskAsyncPrimaryDiskResult',
    'GetRegionDiskDiskEncryptionKeyResult',
    'GetRegionDiskGuestOsFeatureResult',
    'GetRegionDiskSourceSnapshotEncryptionKeyResult',
    'GetRegionInstanceGroupInstanceResult',
    'GetRegionInstanceGroupInstanceNamedPortResult',
    'GetRegionInstanceGroupManagerAllInstancesConfigResult',
    'GetRegionInstanceGroupManagerAutoHealingPolicyResult',
    'GetRegionInstanceGroupManagerInstanceFlexibilityPolicyResult',
    'GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionResult',
    'GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResult',
    'GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKeyResult',
    'GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabelResult',
    'GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTagResult',
    'GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKeyResult',
    'GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKeyResult',
    'GetRegionInstanceGroupManagerInstanceLifecyclePolicyResult',
    'GetRegionInstanceGroupManagerInstanceLifecyclePolicyOnRepairResult',
    'GetRegionInstanceGroupManagerNamedPortResult',
    'GetRegionInstanceGroupManagerParamResult',
    'GetRegionInstanceGroupManagerStandbyPolicyResult',
    'GetRegionInstanceGroupManagerStatefulDiskResult',
    'GetRegionInstanceGroupManagerStatefulExternalIpResult',
    'GetRegionInstanceGroupManagerStatefulInternalIpResult',
    'GetRegionInstanceGroupManagerStatusResult',
    'GetRegionInstanceGroupManagerStatusAllInstancesConfigResult',
    'GetRegionInstanceGroupManagerStatusStatefulResult',
    'GetRegionInstanceGroupManagerStatusStatefulPerInstanceConfigResult',
    'GetRegionInstanceGroupManagerStatusVersionTargetResult',
    'GetRegionInstanceGroupManagerUpdatePolicyResult',
    'GetRegionInstanceGroupManagerVersionResult',
    'GetRegionInstanceGroupManagerVersionTargetSizeResult',
    'GetRegionInstanceTemplateAdvancedMachineFeatureResult',
    'GetRegionInstanceTemplateConfidentialInstanceConfigResult',
    'GetRegionInstanceTemplateDiskResult',
    'GetRegionInstanceTemplateDiskDiskEncryptionKeyResult',
    'GetRegionInstanceTemplateDiskSourceImageEncryptionKeyResult',
    'GetRegionInstanceTemplateDiskSourceSnapshotEncryptionKeyResult',
    'GetRegionInstanceTemplateGuestAcceleratorResult',
    'GetRegionInstanceTemplateNetworkInterfaceResult',
    'GetRegionInstanceTemplateNetworkInterfaceAccessConfigResult',
    'GetRegionInstanceTemplateNetworkInterfaceAliasIpRangeResult',
    'GetRegionInstanceTemplateNetworkInterfaceIpv6AccessConfigResult',
    'GetRegionInstanceTemplateNetworkPerformanceConfigResult',
    'GetRegionInstanceTemplateReservationAffinityResult',
    'GetRegionInstanceTemplateReservationAffinitySpecificReservationResult',
    'GetRegionInstanceTemplateSchedulingResult',
    'GetRegionInstanceTemplateSchedulingGracefulShutdownResult',
    'GetRegionInstanceTemplateSchedulingGracefulShutdownMaxDurationResult',
    'GetRegionInstanceTemplateSchedulingLocalSsdRecoveryTimeoutResult',
    'GetRegionInstanceTemplateSchedulingMaxRunDurationResult',
    'GetRegionInstanceTemplateSchedulingNodeAffinityResult',
    'GetRegionInstanceTemplateSchedulingOnInstanceStopActionResult',
    'GetRegionInstanceTemplateServiceAccountResult',
    'GetRegionInstanceTemplateShieldedInstanceConfigResult',
    'GetRegionNetworkEndpointGroupAppEngineResult',
    'GetRegionNetworkEndpointGroupCloudFunctionResult',
    'GetRegionNetworkEndpointGroupCloudRunResult',
    'GetRegionNetworkEndpointGroupPscDataResult',
    'GetRegionNetworkEndpointGroupServerlessDeploymentResult',
    'GetRegionSecurityPolicyAdvancedOptionsConfigResult',
    'GetRegionSecurityPolicyAdvancedOptionsConfigJsonCustomConfigResult',
    'GetRegionSecurityPolicyDdosProtectionConfigResult',
    'GetRegionSecurityPolicyRuleResult',
    'GetRegionSecurityPolicyRuleMatchResult',
    'GetRegionSecurityPolicyRuleMatchConfigResult',
    'GetRegionSecurityPolicyRuleMatchExprResult',
    'GetRegionSecurityPolicyRuleNetworkMatchResult',
    'GetRegionSecurityPolicyRuleNetworkMatchUserDefinedFieldResult',
    'GetRegionSecurityPolicyRulePreconfiguredWafConfigResult',
    'GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionResult',
    'GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCookyResult',
    'GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeaderResult',
    'GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParamResult',
    'GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUriResult',
    'GetRegionSecurityPolicyRuleRateLimitOptionResult',
    'GetRegionSecurityPolicyRuleRateLimitOptionBanThresholdResult',
    'GetRegionSecurityPolicyRuleRateLimitOptionEnforceOnKeyConfigResult',
    'GetRegionSecurityPolicyRuleRateLimitOptionRateLimitThresholdResult',
    'GetRegionSecurityPolicyUserDefinedFieldResult',
    'GetReservationBlockHealthInfoResult',
    'GetReservationBlockPhysicalTopologyResult',
    'GetReservationBlockReservationMaintenanceResult',
    'GetReservationDeleteAfterDurationResult',
    'GetReservationReservationSharingPolicyResult',
    'GetReservationResourceStatusResult',
    'GetReservationResourceStatusHealthInfoResult',
    'GetReservationResourceStatusReservationMaintenanceResult',
    'GetReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceResult',
    'GetReservationResourceStatusSpecificSkuAllocationResult',
    'GetReservationShareSettingResult',
    'GetReservationShareSettingProjectMapResult',
    'GetReservationSpecificReservationResult',
    'GetReservationSpecificReservationInstancePropertyResult',
    'GetReservationSpecificReservationInstancePropertyGuestAcceleratorResult',
    'GetReservationSpecificReservationInstancePropertyLocalSsdResult',
    'GetReservationSubBlockHealthInfoResult',
    'GetReservationSubBlockPhysicalTopologyResult',
    'GetReservationSubBlockReservationSubBlockMaintenanceResult',
    'GetResourcePolicyDiskConsistencyGroupPolicyResult',
    'GetResourcePolicyGroupPlacementPolicyResult',
    'GetResourcePolicyInstanceSchedulePolicyResult',
    'GetResourcePolicyInstanceSchedulePolicyVmStartScheduleResult',
    'GetResourcePolicyInstanceSchedulePolicyVmStopScheduleResult',
    'GetResourcePolicySnapshotSchedulePolicyResult',
    'GetResourcePolicySnapshotSchedulePolicyRetentionPolicyResult',
    'GetResourcePolicySnapshotSchedulePolicyScheduleResult',
    'GetResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleResult',
    'GetResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleResult',
    'GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleResult',
    'GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekResult',
    'GetResourcePolicySnapshotSchedulePolicySnapshotPropertyResult',
    'GetResourcePolicyWorkloadPolicyResult',
    'GetRouterBgpResult',
    'GetRouterBgpAdvertisedIpRangeResult',
    'GetRouterMd5AuthenticationKeyResult',
    'GetRouterNatLogConfigResult',
    'GetRouterNatNat64SubnetworkResult',
    'GetRouterNatRuleResult',
    'GetRouterNatRuleActionResult',
    'GetRouterNatSubnetworkResult',
    'GetRouterParamResult',
    'GetRouterStatusBestRouteResult',
    'GetRouterStatusBestRouteAsPathResult',
    'GetRouterStatusBestRouteParamResult',
    'GetRouterStatusBestRouteWarningResult',
    'GetRouterStatusBestRouteWarningDataResult',
    'GetRouterStatusBestRoutesForRouterResult',
    'GetRouterStatusBestRoutesForRouterAsPathResult',
    'GetRouterStatusBestRoutesForRouterParamResult',
    'GetRouterStatusBestRoutesForRouterWarningResult',
    'GetRouterStatusBestRoutesForRouterWarningDataResult',
    'GetSecurityPolicyAdaptiveProtectionConfigResult',
    'GetSecurityPolicyAdaptiveProtectionConfigAutoDeployConfigResult',
    'GetSecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigResult',
    'GetSecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigResult',
    'GetSecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfigResult',
    'GetSecurityPolicyAdvancedOptionsConfigResult',
    'GetSecurityPolicyAdvancedOptionsConfigJsonCustomConfigResult',
    'GetSecurityPolicyRecaptchaOptionsConfigResult',
    'GetSecurityPolicyRuleResult',
    'GetSecurityPolicyRuleHeaderActionResult',
    'GetSecurityPolicyRuleHeaderActionRequestHeadersToAddResult',
    'GetSecurityPolicyRuleMatchResult',
    'GetSecurityPolicyRuleMatchConfigResult',
    'GetSecurityPolicyRuleMatchExprResult',
    'GetSecurityPolicyRuleMatchExprOptionResult',
    'GetSecurityPolicyRuleMatchExprOptionRecaptchaOptionResult',
    'GetSecurityPolicyRulePreconfiguredWafConfigResult',
    'GetSecurityPolicyRulePreconfiguredWafConfigExclusionResult',
    'GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCookyResult',
    'GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeaderResult',
    'GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParamResult',
    'GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUriResult',
    'GetSecurityPolicyRuleRateLimitOptionResult',
    'GetSecurityPolicyRuleRateLimitOptionBanThresholdResult',
    'GetSecurityPolicyRuleRateLimitOptionEnforceOnKeyConfigResult',
    'GetSecurityPolicyRuleRateLimitOptionExceedRedirectOptionResult',
    'GetSecurityPolicyRuleRateLimitOptionRateLimitThresholdResult',
    'GetSecurityPolicyRuleRedirectOptionResult',
    'GetSnapshotSnapshotEncryptionKeyResult',
    'GetSnapshotSourceDiskEncryptionKeyResult',
    'GetStoragePoolResourceStatusResult',
    'GetStoragePoolStatusResult',
    'GetStoragePoolTypesDeprecatedResult',
    'GetSubnetworkSecondaryIpRangeResult',
    'GetSubnetworksSubnetworkResult',
]

@pulumi.output_type
class AutoscalerAutoscalingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"
        elif key == "cooldownPeriod":
            suggest = "cooldown_period"
        elif key == "cpuUtilization":
            suggest = "cpu_utilization"
        elif key == "loadBalancingUtilization":
            suggest = "load_balancing_utilization"
        elif key == "scaleDownControl":
            suggest = "scale_down_control"
        elif key == "scaleInControl":
            suggest = "scale_in_control"
        elif key == "scalingSchedules":
            suggest = "scaling_schedules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_replicas: _builtins.int,
                 min_replicas: _builtins.int,
                 cooldown_period: Optional[_builtins.int] = None,
                 cpu_utilization: Optional['outputs.AutoscalerAutoscalingPolicyCpuUtilization'] = None,
                 load_balancing_utilization: Optional['outputs.AutoscalerAutoscalingPolicyLoadBalancingUtilization'] = None,
                 metrics: Optional[Sequence['outputs.AutoscalerAutoscalingPolicyMetric']] = None,
                 mode: Optional[_builtins.str] = None,
                 scale_down_control: Optional['outputs.AutoscalerAutoscalingPolicyScaleDownControl'] = None,
                 scale_in_control: Optional['outputs.AutoscalerAutoscalingPolicyScaleInControl'] = None,
                 scaling_schedules: Optional[Sequence['outputs.AutoscalerAutoscalingPolicyScalingSchedule']] = None):
        """
        :param _builtins.int max_replicas: The maximum number of instances that the autoscaler can scale up
               to. This is required when creating or updating an autoscaler. The
               maximum number of replicas should not be lower than minimal number
               of replicas.
        :param _builtins.int min_replicas: The minimum number of replicas that the autoscaler can scale down
               to. This cannot be less than 0. If not provided, autoscaler will
               choose a default value depending on maximum number of instances
               allowed.
        :param _builtins.int cooldown_period: The number of seconds that the autoscaler should wait before it
               starts collecting information from a new instance. This prevents
               the autoscaler from collecting information when the instance is
               initializing, during which the collected usage would not be
               reliable. The default time autoscaler waits is 60 seconds.
               Virtual machine initialization times might vary because of
               numerous factors. We recommend that you test how long an
               instance may take to initialize. To do this, create an instance
               and time the startup process.
        :param 'AutoscalerAutoscalingPolicyCpuUtilizationArgs' cpu_utilization: Defines the CPU utilization policy that allows the autoscaler to
               scale based on the average CPU utilization of a managed instance
               group.
               Structure is documented below.
        :param 'AutoscalerAutoscalingPolicyLoadBalancingUtilizationArgs' load_balancing_utilization: Configuration parameters of autoscaling based on a load balancer.
               Structure is documented below.
        :param Sequence['AutoscalerAutoscalingPolicyMetricArgs'] metrics: Configuration parameters of autoscaling based on a custom metric.
               Structure is documented below.
        :param _builtins.str mode: Defines operating mode for this policy.
        :param 'AutoscalerAutoscalingPolicyScaleDownControlArgs' scale_down_control: Defines scale down controls to reduce the risk of response latency
               and outages due to abrupt scale-in events
               Structure is documented below.
        :param 'AutoscalerAutoscalingPolicyScaleInControlArgs' scale_in_control: Defines scale in controls to reduce the risk of response latency
               and outages due to abrupt scale-in events
               Structure is documented below.
        :param Sequence['AutoscalerAutoscalingPolicyScalingScheduleArgs'] scaling_schedules: Scaling schedules defined for an autoscaler. Multiple schedules can be set on an autoscaler and they can overlap.
               Structure is documented below.
        """
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "min_replicas", min_replicas)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if cpu_utilization is not None:
            pulumi.set(__self__, "cpu_utilization", cpu_utilization)
        if load_balancing_utilization is not None:
            pulumi.set(__self__, "load_balancing_utilization", load_balancing_utilization)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if scale_down_control is not None:
            pulumi.set(__self__, "scale_down_control", scale_down_control)
        if scale_in_control is not None:
            pulumi.set(__self__, "scale_in_control", scale_in_control)
        if scaling_schedules is not None:
            pulumi.set(__self__, "scaling_schedules", scaling_schedules)

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> _builtins.int:
        """
        The maximum number of instances that the autoscaler can scale up
        to. This is required when creating or updating an autoscaler. The
        maximum number of replicas should not be lower than minimal number
        of replicas.
        """
        return pulumi.get(self, "max_replicas")

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> _builtins.int:
        """
        The minimum number of replicas that the autoscaler can scale down
        to. This cannot be less than 0. If not provided, autoscaler will
        choose a default value depending on maximum number of instances
        allowed.
        """
        return pulumi.get(self, "min_replicas")

    @_builtins.property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[_builtins.int]:
        """
        The number of seconds that the autoscaler should wait before it
        starts collecting information from a new instance. This prevents
        the autoscaler from collecting information when the instance is
        initializing, during which the collected usage would not be
        reliable. The default time autoscaler waits is 60 seconds.
        Virtual machine initialization times might vary because of
        numerous factors. We recommend that you test how long an
        instance may take to initialize. To do this, create an instance
        and time the startup process.
        """
        return pulumi.get(self, "cooldown_period")

    @_builtins.property
    @pulumi.getter(name="cpuUtilization")
    def cpu_utilization(self) -> Optional['outputs.AutoscalerAutoscalingPolicyCpuUtilization']:
        """
        Defines the CPU utilization policy that allows the autoscaler to
        scale based on the average CPU utilization of a managed instance
        group.
        Structure is documented below.
        """
        return pulumi.get(self, "cpu_utilization")

    @_builtins.property
    @pulumi.getter(name="loadBalancingUtilization")
    def load_balancing_utilization(self) -> Optional['outputs.AutoscalerAutoscalingPolicyLoadBalancingUtilization']:
        """
        Configuration parameters of autoscaling based on a load balancer.
        Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_utilization")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['outputs.AutoscalerAutoscalingPolicyMetric']]:
        """
        Configuration parameters of autoscaling based on a custom metric.
        Structure is documented below.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Defines operating mode for this policy.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="scaleDownControl")
    def scale_down_control(self) -> Optional['outputs.AutoscalerAutoscalingPolicyScaleDownControl']:
        """
        Defines scale down controls to reduce the risk of response latency
        and outages due to abrupt scale-in events
        Structure is documented below.
        """
        return pulumi.get(self, "scale_down_control")

    @_builtins.property
    @pulumi.getter(name="scaleInControl")
    def scale_in_control(self) -> Optional['outputs.AutoscalerAutoscalingPolicyScaleInControl']:
        """
        Defines scale in controls to reduce the risk of response latency
        and outages due to abrupt scale-in events
        Structure is documented below.
        """
        return pulumi.get(self, "scale_in_control")

    @_builtins.property
    @pulumi.getter(name="scalingSchedules")
    def scaling_schedules(self) -> Optional[Sequence['outputs.AutoscalerAutoscalingPolicyScalingSchedule']]:
        """
        Scaling schedules defined for an autoscaler. Multiple schedules can be set on an autoscaler and they can overlap.
        Structure is documented below.
        """
        return pulumi.get(self, "scaling_schedules")


@pulumi.output_type
class AutoscalerAutoscalingPolicyCpuUtilization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predictiveMethod":
            suggest = "predictive_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalingPolicyCpuUtilization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalingPolicyCpuUtilization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalingPolicyCpuUtilization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: _builtins.float,
                 predictive_method: Optional[_builtins.str] = None):
        """
        :param _builtins.float target: The target CPU utilization that the autoscaler should maintain.
               Must be a float value in the range (0, 1]. If not specified, the
               default is 0.6.
               If the CPU level is below the target utilization, the autoscaler
               scales down the number of instances until it reaches the minimum
               number of instances you specified or until the average CPU of
               your instances reaches the target utilization.
               If the average CPU is above the target utilization, the autoscaler
               scales up until it reaches the maximum number of instances you
               specified or until the average utilization reaches the target
               utilization.
        :param _builtins.str predictive_method: Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are:
               - NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics.
               - OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
        """
        pulumi.set(__self__, "target", target)
        if predictive_method is not None:
            pulumi.set(__self__, "predictive_method", predictive_method)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        The target CPU utilization that the autoscaler should maintain.
        Must be a float value in the range (0, 1]. If not specified, the
        default is 0.6.
        If the CPU level is below the target utilization, the autoscaler
        scales down the number of instances until it reaches the minimum
        number of instances you specified or until the average CPU of
        your instances reaches the target utilization.
        If the average CPU is above the target utilization, the autoscaler
        scales up until it reaches the maximum number of instances you
        specified or until the average utilization reaches the target
        utilization.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter(name="predictiveMethod")
    def predictive_method(self) -> Optional[_builtins.str]:
        """
        Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are:
        - NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics.
        - OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
        """
        return pulumi.get(self, "predictive_method")


@pulumi.output_type
class AutoscalerAutoscalingPolicyLoadBalancingUtilization(dict):
    def __init__(__self__, *,
                 target: _builtins.float):
        """
        :param _builtins.float target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        """
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class AutoscalerAutoscalingPolicyMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "singleInstanceAssignment":
            suggest = "single_instance_assignment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalingPolicyMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalingPolicyMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalingPolicyMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 filter: Optional[_builtins.str] = None,
                 single_instance_assignment: Optional[_builtins.float] = None,
                 target: Optional[_builtins.float] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The identifier (type) of the Stackdriver Monitoring metric.
               The metric cannot have negative values.
               The metric must have a value type of INT64 or DOUBLE.
        :param _builtins.str filter: A filter string to be used as the filter string for
               a Stackdriver Monitoring TimeSeries.list API call.
               This filter is used to select a specific TimeSeries for
               the purpose of autoscaling and to determine whether the metric
               is exporting per-instance or per-group data.
               You can only use the AND operator for joining selectors.
               You can only use direct equality comparison operator (=) without
               any functions for each selector.
               You can specify the metric in both the filter string and in the
               metric field. However, if specified in both places, the metric must
               be identical.
               The monitored resource type determines what kind of values are
               expected for the metric. If it is a gce_instance, the autoscaler
               expects the metric to include a separate TimeSeries for each
               instance in a group. In such a case, you cannot filter on resource
               labels.
               If the resource type is any other value, the autoscaler expects
               this metric to contain values that apply to the entire autoscaled
               instance group and resource label filtering can be performed to
               point autoscaler at the correct TimeSeries to scale upon.
               This is called a per-group metric for the purpose of autoscaling.
               If not specified, the type defaults to gce_instance.
               You should provide a filter that is selective enough to pick just
               one TimeSeries for the autoscaled group or for each of the instances
               (if you are using gce_instance resource type). If multiple
               TimeSeries are returned upon the query execution, the autoscaler
               will sum their respective values to obtain its scaling value.
        :param _builtins.float single_instance_assignment: If scaling is based on a per-group metric value that represents the
               total amount of work to be done or resource usage, set this value to
               an amount assigned for a single instance of the scaled group.
               The autoscaler will keep the number of instances proportional to the
               value of this metric, the metric itself should not change value due
               to group resizing.
               For example, a good metric to use with the target is
               `pubsub.googleapis.com/subscription/num_undelivered_messages`
               or a custom metric exporting the total number of requests coming to
               your instances.
               A bad example would be a metric exporting an average or median
               latency, since this value can't include a chunk assignable to a
               single instance, it could be better used with utilization_target
               instead.
        :param _builtins.float target: The target value of the metric that autoscaler should
               maintain. This must be a positive value. A utilization
               metric scales number of virtual machines handling requests
               to increase or decrease proportionally to the metric.
               For example, a good metric to use as a utilizationTarget is
               www.googleapis.com/compute/instance/network/received_bytes_count.
               The autoscaler will work to keep this value constant for each
               of the instances.
        :param _builtins.str type: Defines how target utilization value is expressed for a
               Stackdriver Monitoring metric.
               Possible values are: `GAUGE`, `DELTA_PER_SECOND`, `DELTA_PER_MINUTE`.
        """
        pulumi.set(__self__, "name", name)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if single_instance_assignment is not None:
            pulumi.set(__self__, "single_instance_assignment", single_instance_assignment)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The identifier (type) of the Stackdriver Monitoring metric.
        The metric cannot have negative values.
        The metric must have a value type of INT64 or DOUBLE.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[_builtins.str]:
        """
        A filter string to be used as the filter string for
        a Stackdriver Monitoring TimeSeries.list API call.
        This filter is used to select a specific TimeSeries for
        the purpose of autoscaling and to determine whether the metric
        is exporting per-instance or per-group data.
        You can only use the AND operator for joining selectors.
        You can only use direct equality comparison operator (=) without
        any functions for each selector.
        You can specify the metric in both the filter string and in the
        metric field. However, if specified in both places, the metric must
        be identical.
        The monitored resource type determines what kind of values are
        expected for the metric. If it is a gce_instance, the autoscaler
        expects the metric to include a separate TimeSeries for each
        instance in a group. In such a case, you cannot filter on resource
        labels.
        If the resource type is any other value, the autoscaler expects
        this metric to contain values that apply to the entire autoscaled
        instance group and resource label filtering can be performed to
        point autoscaler at the correct TimeSeries to scale upon.
        This is called a per-group metric for the purpose of autoscaling.
        If not specified, the type defaults to gce_instance.
        You should provide a filter that is selective enough to pick just
        one TimeSeries for the autoscaled group or for each of the instances
        (if you are using gce_instance resource type). If multiple
        TimeSeries are returned upon the query execution, the autoscaler
        will sum their respective values to obtain its scaling value.
        """
        return pulumi.get(self, "filter")

    @_builtins.property
    @pulumi.getter(name="singleInstanceAssignment")
    def single_instance_assignment(self) -> Optional[_builtins.float]:
        """
        If scaling is based on a per-group metric value that represents the
        total amount of work to be done or resource usage, set this value to
        an amount assigned for a single instance of the scaled group.
        The autoscaler will keep the number of instances proportional to the
        value of this metric, the metric itself should not change value due
        to group resizing.
        For example, a good metric to use with the target is
        `pubsub.googleapis.com/subscription/num_undelivered_messages`
        or a custom metric exporting the total number of requests coming to
        your instances.
        A bad example would be a metric exporting an average or median
        latency, since this value can't include a chunk assignable to a
        single instance, it could be better used with utilization_target
        instead.
        """
        return pulumi.get(self, "single_instance_assignment")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.float]:
        """
        The target value of the metric that autoscaler should
        maintain. This must be a positive value. A utilization
        metric scales number of virtual machines handling requests
        to increase or decrease proportionally to the metric.
        For example, a good metric to use as a utilizationTarget is
        www.googleapis.com/compute/instance/network/received_bytes_count.
        The autoscaler will work to keep this value constant for each
        of the instances.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Defines how target utilization value is expressed for a
        Stackdriver Monitoring metric.
        Possible values are: `GAUGE`, `DELTA_PER_SECOND`, `DELTA_PER_MINUTE`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AutoscalerAutoscalingPolicyScaleDownControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxScaledDownReplicas":
            suggest = "max_scaled_down_replicas"
        elif key == "timeWindowSec":
            suggest = "time_window_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalingPolicyScaleDownControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalingPolicyScaleDownControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalingPolicyScaleDownControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_scaled_down_replicas: Optional['outputs.AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas'] = None,
                 time_window_sec: Optional[_builtins.int] = None):
        """
        :param 'AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs' max_scaled_down_replicas: A nested object resource.
               Structure is documented below.
        :param _builtins.int time_window_sec: How long back autoscaling should look when computing recommendations
               to include directives regarding slower scale down, as described above.
        """
        if max_scaled_down_replicas is not None:
            pulumi.set(__self__, "max_scaled_down_replicas", max_scaled_down_replicas)
        if time_window_sec is not None:
            pulumi.set(__self__, "time_window_sec", time_window_sec)

    @_builtins.property
    @pulumi.getter(name="maxScaledDownReplicas")
    def max_scaled_down_replicas(self) -> Optional['outputs.AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas']:
        """
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "max_scaled_down_replicas")

    @_builtins.property
    @pulumi.getter(name="timeWindowSec")
    def time_window_sec(self) -> Optional[_builtins.int]:
        """
        How long back autoscaling should look when computing recommendations
        to include directives regarding slower scale down, as described above.
        """
        return pulumi.get(self, "time_window_sec")


@pulumi.output_type
class AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas(dict):
    def __init__(__self__, *,
                 fixed: Optional[_builtins.int] = None,
                 percent: Optional[_builtins.int] = None):
        """
        :param _builtins.int fixed: Specifies a fixed number of VM instances. This must be a positive
               integer.
        :param _builtins.int percent: Specifies a percentage of instances between 0 to 100%, inclusive.
               For example, specify 80 for 80%.
        """
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter
    def fixed(self) -> Optional[_builtins.int]:
        """
        Specifies a fixed number of VM instances. This must be a positive
        integer.
        """
        return pulumi.get(self, "fixed")

    @_builtins.property
    @pulumi.getter
    def percent(self) -> Optional[_builtins.int]:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive.
        For example, specify 80 for 80%.
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class AutoscalerAutoscalingPolicyScaleInControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxScaledInReplicas":
            suggest = "max_scaled_in_replicas"
        elif key == "timeWindowSec":
            suggest = "time_window_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalingPolicyScaleInControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalingPolicyScaleInControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalingPolicyScaleInControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_scaled_in_replicas: Optional['outputs.AutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas'] = None,
                 time_window_sec: Optional[_builtins.int] = None):
        """
        :param 'AutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicasArgs' max_scaled_in_replicas: A nested object resource.
               Structure is documented below.
        :param _builtins.int time_window_sec: How long back autoscaling should look when computing recommendations
               to include directives regarding slower scale down, as described above.
        """
        if max_scaled_in_replicas is not None:
            pulumi.set(__self__, "max_scaled_in_replicas", max_scaled_in_replicas)
        if time_window_sec is not None:
            pulumi.set(__self__, "time_window_sec", time_window_sec)

    @_builtins.property
    @pulumi.getter(name="maxScaledInReplicas")
    def max_scaled_in_replicas(self) -> Optional['outputs.AutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas']:
        """
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "max_scaled_in_replicas")

    @_builtins.property
    @pulumi.getter(name="timeWindowSec")
    def time_window_sec(self) -> Optional[_builtins.int]:
        """
        How long back autoscaling should look when computing recommendations
        to include directives regarding slower scale down, as described above.
        """
        return pulumi.get(self, "time_window_sec")


@pulumi.output_type
class AutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas(dict):
    def __init__(__self__, *,
                 fixed: Optional[_builtins.int] = None,
                 percent: Optional[_builtins.int] = None):
        """
        :param _builtins.int fixed: Specifies a fixed number of VM instances. This must be a positive
               integer.
        :param _builtins.int percent: Specifies a percentage of instances between 0 to 100%, inclusive.
               For example, specify 80 for 80%.
        """
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter
    def fixed(self) -> Optional[_builtins.int]:
        """
        Specifies a fixed number of VM instances. This must be a positive
        integer.
        """
        return pulumi.get(self, "fixed")

    @_builtins.property
    @pulumi.getter
    def percent(self) -> Optional[_builtins.int]:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive.
        For example, specify 80 for 80%.
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class AutoscalerAutoscalingPolicyScalingSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationSec":
            suggest = "duration_sec"
        elif key == "minRequiredReplicas":
            suggest = "min_required_replicas"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalerAutoscalingPolicyScalingSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalerAutoscalingPolicyScalingSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalerAutoscalingPolicyScalingSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_sec: _builtins.int,
                 min_required_replicas: _builtins.int,
                 name: _builtins.str,
                 schedule: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 time_zone: Optional[_builtins.str] = None):
        """
        :param _builtins.int duration_sec: The duration of time intervals (in seconds) for which this scaling schedule will be running. The minimum allowed value is 300.
        :param _builtins.int min_required_replicas: Minimum number of VM instances that autoscaler will recommend in time intervals starting according to schedule.
        :param _builtins.str name: The identifier for this object. Format specified above.
        :param _builtins.str schedule: The start timestamps of time intervals when this scaling schedule should provide a scaling signal. This field uses the extended cron format (with an optional year field).
        :param _builtins.str description: A description of a scaling schedule.
        :param _builtins.bool disabled: A boolean value that specifies if a scaling schedule can influence autoscaler recommendations. If set to true, then a scaling schedule has no effect.
        :param _builtins.str time_zone: The time zone to be used when interpreting the schedule. The value of this field must be a time zone name from the tz database: http://en.wikipedia.org/wiki/Tz_database.
        """
        pulumi.set(__self__, "duration_sec", duration_sec)
        pulumi.set(__self__, "min_required_replicas", min_required_replicas)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="durationSec")
    def duration_sec(self) -> _builtins.int:
        """
        The duration of time intervals (in seconds) for which this scaling schedule will be running. The minimum allowed value is 300.
        """
        return pulumi.get(self, "duration_sec")

    @_builtins.property
    @pulumi.getter(name="minRequiredReplicas")
    def min_required_replicas(self) -> _builtins.int:
        """
        Minimum number of VM instances that autoscaler will recommend in time intervals starting according to schedule.
        """
        return pulumi.get(self, "min_required_replicas")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> _builtins.str:
        """
        The start timestamps of time intervals when this scaling schedule should provide a scaling signal. This field uses the extended cron format (with an optional year field).
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of a scaling schedule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        A boolean value that specifies if a scaling schedule can influence autoscaler recommendations. If set to true, then a scaling schedule has no effect.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        """
        The time zone to be used when interpreting the schedule. The value of this field must be a time zone name from the tz database: http://en.wikipedia.org/wiki/Tz_database.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class BackendBucketCdnPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bypassCacheOnRequestHeaders":
            suggest = "bypass_cache_on_request_headers"
        elif key == "cacheKeyPolicy":
            suggest = "cache_key_policy"
        elif key == "cacheMode":
            suggest = "cache_mode"
        elif key == "clientTtl":
            suggest = "client_ttl"
        elif key == "defaultTtl":
            suggest = "default_ttl"
        elif key == "maxTtl":
            suggest = "max_ttl"
        elif key == "negativeCaching":
            suggest = "negative_caching"
        elif key == "negativeCachingPolicies":
            suggest = "negative_caching_policies"
        elif key == "requestCoalescing":
            suggest = "request_coalescing"
        elif key == "serveWhileStale":
            suggest = "serve_while_stale"
        elif key == "signedUrlCacheMaxAgeSec":
            suggest = "signed_url_cache_max_age_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendBucketCdnPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendBucketCdnPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendBucketCdnPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bypass_cache_on_request_headers: Optional[Sequence['outputs.BackendBucketCdnPolicyBypassCacheOnRequestHeader']] = None,
                 cache_key_policy: Optional['outputs.BackendBucketCdnPolicyCacheKeyPolicy'] = None,
                 cache_mode: Optional[_builtins.str] = None,
                 client_ttl: Optional[_builtins.int] = None,
                 default_ttl: Optional[_builtins.int] = None,
                 max_ttl: Optional[_builtins.int] = None,
                 negative_caching: Optional[_builtins.bool] = None,
                 negative_caching_policies: Optional[Sequence['outputs.BackendBucketCdnPolicyNegativeCachingPolicy']] = None,
                 request_coalescing: Optional[_builtins.bool] = None,
                 serve_while_stale: Optional[_builtins.int] = None,
                 signed_url_cache_max_age_sec: Optional[_builtins.int] = None):
        """
        :param Sequence['BackendBucketCdnPolicyBypassCacheOnRequestHeaderArgs'] bypass_cache_on_request_headers: Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified. The cache is bypassed for all cdnPolicy.cacheMode settings.
               Structure is documented below.
        :param 'BackendBucketCdnPolicyCacheKeyPolicyArgs' cache_key_policy: The CacheKeyPolicy for this CdnPolicy.
               Structure is documented below.
        :param _builtins.str cache_mode: Specifies the cache setting for all responses from this backend.
               The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
               Possible values are: `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, `CACHE_ALL_STATIC`.
        :param _builtins.int client_ttl: Specifies the maximum allowed TTL for cached content served by this origin. When the
               `cache_mode` is set to "USE_ORIGIN_HEADERS", you must omit this field.
        :param _builtins.int default_ttl: Specifies the default TTL for cached content served by this origin for responses
               that do not have an existing valid TTL (max-age or s-max-age). When the `cache_mode`
               is set to "USE_ORIGIN_HEADERS", you must omit this field.
        :param _builtins.int max_ttl: Specifies the maximum allowed TTL for cached content served by this origin. When the
               `cache_mode` is set to "USE_ORIGIN_HEADERS", you must omit this field.
        :param _builtins.bool negative_caching: Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        :param Sequence['BackendBucketCdnPolicyNegativeCachingPolicyArgs'] negative_caching_policies: Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
               Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
               Structure is documented below.
        :param _builtins.bool request_coalescing: If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests to the origin.
        :param _builtins.int serve_while_stale: Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        :param _builtins.int signed_url_cache_max_age_sec: Maximum number of seconds the response to a signed URL request will
               be considered fresh. After this time period,
               the response will be revalidated before being served.
               When serving responses to signed URL requests,
               Cloud CDN will internally behave as though
               all responses from this backend had a "Cache-Control: public,
               max-age=[TTL]" header, regardless of any existing Cache-Control
               header. The actual headers served in responses will not be altered.
        """
        if bypass_cache_on_request_headers is not None:
            pulumi.set(__self__, "bypass_cache_on_request_headers", bypass_cache_on_request_headers)
        if cache_key_policy is not None:
            pulumi.set(__self__, "cache_key_policy", cache_key_policy)
        if cache_mode is not None:
            pulumi.set(__self__, "cache_mode", cache_mode)
        if client_ttl is not None:
            pulumi.set(__self__, "client_ttl", client_ttl)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if negative_caching is not None:
            pulumi.set(__self__, "negative_caching", negative_caching)
        if negative_caching_policies is not None:
            pulumi.set(__self__, "negative_caching_policies", negative_caching_policies)
        if request_coalescing is not None:
            pulumi.set(__self__, "request_coalescing", request_coalescing)
        if serve_while_stale is not None:
            pulumi.set(__self__, "serve_while_stale", serve_while_stale)
        if signed_url_cache_max_age_sec is not None:
            pulumi.set(__self__, "signed_url_cache_max_age_sec", signed_url_cache_max_age_sec)

    @_builtins.property
    @pulumi.getter(name="bypassCacheOnRequestHeaders")
    def bypass_cache_on_request_headers(self) -> Optional[Sequence['outputs.BackendBucketCdnPolicyBypassCacheOnRequestHeader']]:
        """
        Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified. The cache is bypassed for all cdnPolicy.cacheMode settings.
        Structure is documented below.
        """
        return pulumi.get(self, "bypass_cache_on_request_headers")

    @_builtins.property
    @pulumi.getter(name="cacheKeyPolicy")
    def cache_key_policy(self) -> Optional['outputs.BackendBucketCdnPolicyCacheKeyPolicy']:
        """
        The CacheKeyPolicy for this CdnPolicy.
        Structure is documented below.
        """
        return pulumi.get(self, "cache_key_policy")

    @_builtins.property
    @pulumi.getter(name="cacheMode")
    def cache_mode(self) -> Optional[_builtins.str]:
        """
        Specifies the cache setting for all responses from this backend.
        The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
        Possible values are: `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, `CACHE_ALL_STATIC`.
        """
        return pulumi.get(self, "cache_mode")

    @_builtins.property
    @pulumi.getter(name="clientTtl")
    def client_ttl(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum allowed TTL for cached content served by this origin. When the
        `cache_mode` is set to "USE_ORIGIN_HEADERS", you must omit this field.
        """
        return pulumi.get(self, "client_ttl")

    @_builtins.property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[_builtins.int]:
        """
        Specifies the default TTL for cached content served by this origin for responses
        that do not have an existing valid TTL (max-age or s-max-age). When the `cache_mode`
        is set to "USE_ORIGIN_HEADERS", you must omit this field.
        """
        return pulumi.get(self, "default_ttl")

    @_builtins.property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum allowed TTL for cached content served by this origin. When the
        `cache_mode` is set to "USE_ORIGIN_HEADERS", you must omit this field.
        """
        return pulumi.get(self, "max_ttl")

    @_builtins.property
    @pulumi.getter(name="negativeCaching")
    def negative_caching(self) -> Optional[_builtins.bool]:
        """
        Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        """
        return pulumi.get(self, "negative_caching")

    @_builtins.property
    @pulumi.getter(name="negativeCachingPolicies")
    def negative_caching_policies(self) -> Optional[Sequence['outputs.BackendBucketCdnPolicyNegativeCachingPolicy']]:
        """
        Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
        Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
        Structure is documented below.
        """
        return pulumi.get(self, "negative_caching_policies")

    @_builtins.property
    @pulumi.getter(name="requestCoalescing")
    def request_coalescing(self) -> Optional[_builtins.bool]:
        """
        If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests to the origin.
        """
        return pulumi.get(self, "request_coalescing")

    @_builtins.property
    @pulumi.getter(name="serveWhileStale")
    def serve_while_stale(self) -> Optional[_builtins.int]:
        """
        Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        """
        return pulumi.get(self, "serve_while_stale")

    @_builtins.property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> Optional[_builtins.int]:
        """
        Maximum number of seconds the response to a signed URL request will
        be considered fresh. After this time period,
        the response will be revalidated before being served.
        When serving responses to signed URL requests,
        Cloud CDN will internally behave as though
        all responses from this backend had a "Cache-Control: public,
        max-age=[TTL]" header, regardless of any existing Cache-Control
        header. The actual headers served in responses will not be altered.
        """
        return pulumi.get(self, "signed_url_cache_max_age_sec")


@pulumi.output_type
class BackendBucketCdnPolicyBypassCacheOnRequestHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendBucketCdnPolicyBypassCacheOnRequestHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendBucketCdnPolicyBypassCacheOnRequestHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendBucketCdnPolicyBypassCacheOnRequestHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str header_name: The header field name to match on when bypassing cache. Values are case-insensitive.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[_builtins.str]:
        """
        The header field name to match on when bypassing cache. Values are case-insensitive.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class BackendBucketCdnPolicyCacheKeyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeHttpHeaders":
            suggest = "include_http_headers"
        elif key == "queryStringWhitelists":
            suggest = "query_string_whitelists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendBucketCdnPolicyCacheKeyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendBucketCdnPolicyCacheKeyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendBucketCdnPolicyCacheKeyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_http_headers: Optional[Sequence[_builtins.str]] = None,
                 query_string_whitelists: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] include_http_headers: Allows HTTP request headers (by name) to be used in the
               cache key.
        :param Sequence[_builtins.str] query_string_whitelists: Names of query string parameters to include in cache keys.
               Default parameters are always included. '&' and '=' will
               be percent encoded and not treated as delimiters.
        """
        if include_http_headers is not None:
            pulumi.set(__self__, "include_http_headers", include_http_headers)
        if query_string_whitelists is not None:
            pulumi.set(__self__, "query_string_whitelists", query_string_whitelists)

    @_builtins.property
    @pulumi.getter(name="includeHttpHeaders")
    def include_http_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Allows HTTP request headers (by name) to be used in the
        cache key.
        """
        return pulumi.get(self, "include_http_headers")

    @_builtins.property
    @pulumi.getter(name="queryStringWhitelists")
    def query_string_whitelists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of query string parameters to include in cache keys.
        Default parameters are always included. '&' and '=' will
        be percent encoded and not treated as delimiters.
        """
        return pulumi.get(self, "query_string_whitelists")


@pulumi.output_type
class BackendBucketCdnPolicyNegativeCachingPolicy(dict):
    def __init__(__self__, *,
                 code: Optional[_builtins.int] = None,
                 ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.int code: The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
               can be specified as values, and you cannot specify a status code more than once.
        :param _builtins.int ttl: The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
               (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.int]:
        """
        The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
        can be specified as values, and you cannot specify a status code more than once.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
        (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class BackendBucketIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class BackendBucketIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class BackendBucketParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendBucketParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendBucketParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendBucketParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the backend bucket. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456.
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource manager tags to be bound to the backend bucket. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class BackendServiceBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "balancingMode":
            suggest = "balancing_mode"
        elif key == "capacityScaler":
            suggest = "capacity_scaler"
        elif key == "customMetrics":
            suggest = "custom_metrics"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "maxConnectionsPerEndpoint":
            suggest = "max_connections_per_endpoint"
        elif key == "maxConnectionsPerInstance":
            suggest = "max_connections_per_instance"
        elif key == "maxInFlightRequests":
            suggest = "max_in_flight_requests"
        elif key == "maxInFlightRequestsPerEndpoint":
            suggest = "max_in_flight_requests_per_endpoint"
        elif key == "maxInFlightRequestsPerInstance":
            suggest = "max_in_flight_requests_per_instance"
        elif key == "maxRate":
            suggest = "max_rate"
        elif key == "maxRatePerEndpoint":
            suggest = "max_rate_per_endpoint"
        elif key == "maxRatePerInstance":
            suggest = "max_rate_per_instance"
        elif key == "maxUtilization":
            suggest = "max_utilization"
        elif key == "trafficDuration":
            suggest = "traffic_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group: _builtins.str,
                 balancing_mode: Optional[_builtins.str] = None,
                 capacity_scaler: Optional[_builtins.float] = None,
                 custom_metrics: Optional[Sequence['outputs.BackendServiceBackendCustomMetric']] = None,
                 description: Optional[_builtins.str] = None,
                 max_connections: Optional[_builtins.int] = None,
                 max_connections_per_endpoint: Optional[_builtins.int] = None,
                 max_connections_per_instance: Optional[_builtins.int] = None,
                 max_in_flight_requests: Optional[_builtins.int] = None,
                 max_in_flight_requests_per_endpoint: Optional[_builtins.int] = None,
                 max_in_flight_requests_per_instance: Optional[_builtins.int] = None,
                 max_rate: Optional[_builtins.int] = None,
                 max_rate_per_endpoint: Optional[_builtins.float] = None,
                 max_rate_per_instance: Optional[_builtins.float] = None,
                 max_utilization: Optional[_builtins.float] = None,
                 preference: Optional[_builtins.str] = None,
                 traffic_duration: Optional[_builtins.str] = None):
        """
        :param _builtins.str group: The fully-qualified URL of an Instance Group or Network Endpoint
               Group resource. In case of instance group this defines the list
               of instances that serve traffic. Member virtual machine
               instances from each instance group must live in the same zone as
               the instance group itself. No two backends in a backend service
               are allowed to use same Instance Group resource.
               For Network Endpoint Groups this defines list of endpoints. All
               endpoints of Network Endpoint Group must be hosted on instances
               located in the same zone as the Network Endpoint Group.
               Backend services cannot mix Instance Group and
               Network Endpoint Group backends.
               Note that you must specify an Instance Group or Network Endpoint
               Group resource using the fully-qualified URL, rather than a
               partial URL.
        :param _builtins.str balancing_mode: Specifies the balancing mode for this backend.
               For global HTTP(S) or TCP/SSL load balancing, the default is
               UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S)),
               CUSTOM_METRICS (for HTTP(s)) and CONNECTION (for TCP/SSL).
               See the [Backend Services Overview](https://cloud.google.com/load-balancing/docs/backend-service#balancing-mode)
               for an explanation of load balancing modes.
               Default value is `UTILIZATION`.
               Possible values are: `UTILIZATION`, `RATE`, `CONNECTION`, `CUSTOM_METRICS`, `IN_FLIGHT`.
        :param _builtins.float capacity_scaler: A multiplier applied to the group's maximum servicing capacity
               (based on UTILIZATION, RATE or CONNECTION).
               Default value is 1, which means the group will serve up to 100%
               of its configured capacity (depending on balancingMode). A
               setting of 0 means the group is completely drained, offering
               0% of its available Capacity. Valid range is [0.0,1.0].
        :param Sequence['BackendServiceBackendCustomMetricArgs'] custom_metrics: The set of custom metrics that are used for <code>CUSTOM_METRICS</code> BalancingMode.
               Structure is documented below.
        :param _builtins.str description: An optional description of this resource.
               Provide this property when you create the resource.
        :param _builtins.int max_connections: The max number of simultaneous connections for the group. Can
               be used with either CONNECTION or UTILIZATION balancing modes.
               For CONNECTION mode, either maxConnections or one
               of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
               as appropriate for group type, must be set.
        :param _builtins.int max_connections_per_endpoint: The max number of simultaneous connections that a single backend
               network endpoint can handle. This is used to calculate the
               capacity of the group. Can be used in either CONNECTION or
               UTILIZATION balancing modes.
               For CONNECTION mode, either
               maxConnections or maxConnectionsPerEndpoint must be set.
        :param _builtins.int max_connections_per_instance: The max number of simultaneous connections that a single
               backend instance can handle. This is used to calculate the
               capacity of the group. Can be used in either CONNECTION or
               UTILIZATION balancing modes.
               For CONNECTION mode, either maxConnections or
               maxConnectionsPerInstance must be set.
        :param _builtins.int max_in_flight_requests: Defines a maximum number of in-flight requests for the whole NEG
               or instance group. Not available if backend's balancingMode is RATE
               or CONNECTION.
        :param _builtins.int max_in_flight_requests_per_endpoint: Defines a maximum number of in-flight requests for a single endpoint.
               Not available if backend's balancingMode is RATE or CONNECTION.
        :param _builtins.int max_in_flight_requests_per_instance: Defines a maximum number of in-flight requests for a single VM.
               Not available if backend's balancingMode is RATE or CONNECTION.
        :param _builtins.int max_rate: The max requests per second (RPS) of the group.
               Can be used with either RATE or UTILIZATION balancing modes,
               but required if RATE mode. For RATE mode, either maxRate or one
               of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
               group type, must be set.
        :param _builtins.float max_rate_per_endpoint: The max requests per second (RPS) that a single backend network
               endpoint can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerEndpoint must be set.
        :param _builtins.float max_rate_per_instance: The max requests per second (RPS) that a single backend
               instance can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerInstance must be set.
        :param _builtins.float max_utilization: Used when balancingMode is UTILIZATION. This ratio defines the
               CPU utilization target for the group. Valid range is [0.0, 1.0].
        :param _builtins.str preference: This field indicates whether this backend should be fully utilized before sending traffic to backends
               with default preference. This field cannot be set when loadBalancingScheme is set to 'EXTERNAL'. The possible values are:
               - PREFERRED: Backends with this preference level will be filled up to their capacity limits first,
               based on RTT.
               - DEFAULT: If preferred backends don't have enough capacity, backends in this layer would be used and
               traffic would be assigned based on the load balancing algorithm you use. This is the default
               Possible values are: `PREFERRED`, `DEFAULT`.
        :param _builtins.str traffic_duration: This field specifies how long a connection should be kept alive for:
               - LONG: Most of the requests are expected to take more than multiple
               seconds to finish.
               - SHORT: Most requests are expected to finish with a sub-second latency.
               Possible values are: `LONG`, `SHORT`.
        """
        pulumi.set(__self__, "group", group)
        if balancing_mode is not None:
            pulumi.set(__self__, "balancing_mode", balancing_mode)
        if capacity_scaler is not None:
            pulumi.set(__self__, "capacity_scaler", capacity_scaler)
        if custom_metrics is not None:
            pulumi.set(__self__, "custom_metrics", custom_metrics)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_connections_per_endpoint is not None:
            pulumi.set(__self__, "max_connections_per_endpoint", max_connections_per_endpoint)
        if max_connections_per_instance is not None:
            pulumi.set(__self__, "max_connections_per_instance", max_connections_per_instance)
        if max_in_flight_requests is not None:
            pulumi.set(__self__, "max_in_flight_requests", max_in_flight_requests)
        if max_in_flight_requests_per_endpoint is not None:
            pulumi.set(__self__, "max_in_flight_requests_per_endpoint", max_in_flight_requests_per_endpoint)
        if max_in_flight_requests_per_instance is not None:
            pulumi.set(__self__, "max_in_flight_requests_per_instance", max_in_flight_requests_per_instance)
        if max_rate is not None:
            pulumi.set(__self__, "max_rate", max_rate)
        if max_rate_per_endpoint is not None:
            pulumi.set(__self__, "max_rate_per_endpoint", max_rate_per_endpoint)
        if max_rate_per_instance is not None:
            pulumi.set(__self__, "max_rate_per_instance", max_rate_per_instance)
        if max_utilization is not None:
            pulumi.set(__self__, "max_utilization", max_utilization)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if traffic_duration is not None:
            pulumi.set(__self__, "traffic_duration", traffic_duration)

    @_builtins.property
    @pulumi.getter
    def group(self) -> _builtins.str:
        """
        The fully-qualified URL of an Instance Group or Network Endpoint
        Group resource. In case of instance group this defines the list
        of instances that serve traffic. Member virtual machine
        instances from each instance group must live in the same zone as
        the instance group itself. No two backends in a backend service
        are allowed to use same Instance Group resource.
        For Network Endpoint Groups this defines list of endpoints. All
        endpoints of Network Endpoint Group must be hosted on instances
        located in the same zone as the Network Endpoint Group.
        Backend services cannot mix Instance Group and
        Network Endpoint Group backends.
        Note that you must specify an Instance Group or Network Endpoint
        Group resource using the fully-qualified URL, rather than a
        partial URL.
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter(name="balancingMode")
    def balancing_mode(self) -> Optional[_builtins.str]:
        """
        Specifies the balancing mode for this backend.
        For global HTTP(S) or TCP/SSL load balancing, the default is
        UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S)),
        CUSTOM_METRICS (for HTTP(s)) and CONNECTION (for TCP/SSL).
        See the [Backend Services Overview](https://cloud.google.com/load-balancing/docs/backend-service#balancing-mode)
        for an explanation of load balancing modes.
        Default value is `UTILIZATION`.
        Possible values are: `UTILIZATION`, `RATE`, `CONNECTION`, `CUSTOM_METRICS`, `IN_FLIGHT`.
        """
        return pulumi.get(self, "balancing_mode")

    @_builtins.property
    @pulumi.getter(name="capacityScaler")
    def capacity_scaler(self) -> Optional[_builtins.float]:
        """
        A multiplier applied to the group's maximum servicing capacity
        (based on UTILIZATION, RATE or CONNECTION).
        Default value is 1, which means the group will serve up to 100%
        of its configured capacity (depending on balancingMode). A
        setting of 0 means the group is completely drained, offering
        0% of its available Capacity. Valid range is [0.0,1.0].
        """
        return pulumi.get(self, "capacity_scaler")

    @_builtins.property
    @pulumi.getter(name="customMetrics")
    def custom_metrics(self) -> Optional[Sequence['outputs.BackendServiceBackendCustomMetric']]:
        """
        The set of custom metrics that are used for <code>CUSTOM_METRICS</code> BalancingMode.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_metrics")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resource.
        Provide this property when you create the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[_builtins.int]:
        """
        The max number of simultaneous connections for the group. Can
        be used with either CONNECTION or UTILIZATION balancing modes.
        For CONNECTION mode, either maxConnections or one
        of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
        as appropriate for group type, must be set.
        """
        return pulumi.get(self, "max_connections")

    @_builtins.property
    @pulumi.getter(name="maxConnectionsPerEndpoint")
    def max_connections_per_endpoint(self) -> Optional[_builtins.int]:
        """
        The max number of simultaneous connections that a single backend
        network endpoint can handle. This is used to calculate the
        capacity of the group. Can be used in either CONNECTION or
        UTILIZATION balancing modes.
        For CONNECTION mode, either
        maxConnections or maxConnectionsPerEndpoint must be set.
        """
        return pulumi.get(self, "max_connections_per_endpoint")

    @_builtins.property
    @pulumi.getter(name="maxConnectionsPerInstance")
    def max_connections_per_instance(self) -> Optional[_builtins.int]:
        """
        The max number of simultaneous connections that a single
        backend instance can handle. This is used to calculate the
        capacity of the group. Can be used in either CONNECTION or
        UTILIZATION balancing modes.
        For CONNECTION mode, either maxConnections or
        maxConnectionsPerInstance must be set.
        """
        return pulumi.get(self, "max_connections_per_instance")

    @_builtins.property
    @pulumi.getter(name="maxInFlightRequests")
    def max_in_flight_requests(self) -> Optional[_builtins.int]:
        """
        Defines a maximum number of in-flight requests for the whole NEG
        or instance group. Not available if backend's balancingMode is RATE
        or CONNECTION.
        """
        return pulumi.get(self, "max_in_flight_requests")

    @_builtins.property
    @pulumi.getter(name="maxInFlightRequestsPerEndpoint")
    def max_in_flight_requests_per_endpoint(self) -> Optional[_builtins.int]:
        """
        Defines a maximum number of in-flight requests for a single endpoint.
        Not available if backend's balancingMode is RATE or CONNECTION.
        """
        return pulumi.get(self, "max_in_flight_requests_per_endpoint")

    @_builtins.property
    @pulumi.getter(name="maxInFlightRequestsPerInstance")
    def max_in_flight_requests_per_instance(self) -> Optional[_builtins.int]:
        """
        Defines a maximum number of in-flight requests for a single VM.
        Not available if backend's balancingMode is RATE or CONNECTION.
        """
        return pulumi.get(self, "max_in_flight_requests_per_instance")

    @_builtins.property
    @pulumi.getter(name="maxRate")
    def max_rate(self) -> Optional[_builtins.int]:
        """
        The max requests per second (RPS) of the group.
        Can be used with either RATE or UTILIZATION balancing modes,
        but required if RATE mode. For RATE mode, either maxRate or one
        of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
        group type, must be set.
        """
        return pulumi.get(self, "max_rate")

    @_builtins.property
    @pulumi.getter(name="maxRatePerEndpoint")
    def max_rate_per_endpoint(self) -> Optional[_builtins.float]:
        """
        The max requests per second (RPS) that a single backend network
        endpoint can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerEndpoint must be set.
        """
        return pulumi.get(self, "max_rate_per_endpoint")

    @_builtins.property
    @pulumi.getter(name="maxRatePerInstance")
    def max_rate_per_instance(self) -> Optional[_builtins.float]:
        """
        The max requests per second (RPS) that a single backend
        instance can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerInstance must be set.
        """
        return pulumi.get(self, "max_rate_per_instance")

    @_builtins.property
    @pulumi.getter(name="maxUtilization")
    def max_utilization(self) -> Optional[_builtins.float]:
        """
        Used when balancingMode is UTILIZATION. This ratio defines the
        CPU utilization target for the group. Valid range is [0.0, 1.0].
        """
        return pulumi.get(self, "max_utilization")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        This field indicates whether this backend should be fully utilized before sending traffic to backends
        with default preference. This field cannot be set when loadBalancingScheme is set to 'EXTERNAL'. The possible values are:
        - PREFERRED: Backends with this preference level will be filled up to their capacity limits first,
        based on RTT.
        - DEFAULT: If preferred backends don't have enough capacity, backends in this layer would be used and
        traffic would be assigned based on the load balancing algorithm you use. This is the default
        Possible values are: `PREFERRED`, `DEFAULT`.
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="trafficDuration")
    def traffic_duration(self) -> Optional[_builtins.str]:
        """
        This field specifies how long a connection should be kept alive for:
        - LONG: Most of the requests are expected to take more than multiple
        seconds to finish.
        - SHORT: Most requests are expected to finish with a sub-second latency.
        Possible values are: `LONG`, `SHORT`.
        """
        return pulumi.get(self, "traffic_duration")


@pulumi.output_type
class BackendServiceBackendCustomMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dryRun":
            suggest = "dry_run"
        elif key == "maxUtilization":
            suggest = "max_utilization"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceBackendCustomMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceBackendCustomMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceBackendCustomMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dry_run: _builtins.bool,
                 name: _builtins.str,
                 max_utilization: Optional[_builtins.float] = None):
        """
        :param _builtins.bool dry_run: If true, the metric data is not used for load balancing.
        :param _builtins.str name: Name of a custom utilization signal. The name must be 1-64 characters
               long and match the regular expression a-z? which
               means the first character must be a lowercase letter, and all following
               characters must be a dash, period, underscore, lowercase letter, or
               digit, except the last character, which cannot be a dash, period, or
               underscore. For usage guidelines, see Custom Metrics balancing mode. This
               field can only be used for a global or regional backend service with the
               loadBalancingScheme set to <code>EXTERNAL_MANAGED</code>,
               <code>INTERNAL_MANAGED</code> <code>INTERNAL_SELF_MANAGED</code>.
        :param _builtins.float max_utilization: Optional parameter to define a target utilization for the Custom Metrics
               balancing mode. The valid range is <code>[0.0, 1.0]</code>.
        """
        pulumi.set(__self__, "dry_run", dry_run)
        pulumi.set(__self__, "name", name)
        if max_utilization is not None:
            pulumi.set(__self__, "max_utilization", max_utilization)

    @_builtins.property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> _builtins.bool:
        """
        If true, the metric data is not used for load balancing.
        """
        return pulumi.get(self, "dry_run")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a custom utilization signal. The name must be 1-64 characters
        long and match the regular expression a-z? which
        means the first character must be a lowercase letter, and all following
        characters must be a dash, period, underscore, lowercase letter, or
        digit, except the last character, which cannot be a dash, period, or
        underscore. For usage guidelines, see Custom Metrics balancing mode. This
        field can only be used for a global or regional backend service with the
        loadBalancingScheme set to <code>EXTERNAL_MANAGED</code>,
        <code>INTERNAL_MANAGED</code> <code>INTERNAL_SELF_MANAGED</code>.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="maxUtilization")
    def max_utilization(self) -> Optional[_builtins.float]:
        """
        Optional parameter to define a target utilization for the Custom Metrics
        balancing mode. The valid range is <code>[0.0, 1.0]</code>.
        """
        return pulumi.get(self, "max_utilization")


@pulumi.output_type
class BackendServiceCdnPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bypassCacheOnRequestHeaders":
            suggest = "bypass_cache_on_request_headers"
        elif key == "cacheKeyPolicy":
            suggest = "cache_key_policy"
        elif key == "cacheMode":
            suggest = "cache_mode"
        elif key == "clientTtl":
            suggest = "client_ttl"
        elif key == "defaultTtl":
            suggest = "default_ttl"
        elif key == "maxTtl":
            suggest = "max_ttl"
        elif key == "negativeCaching":
            suggest = "negative_caching"
        elif key == "negativeCachingPolicies":
            suggest = "negative_caching_policies"
        elif key == "requestCoalescing":
            suggest = "request_coalescing"
        elif key == "serveWhileStale":
            suggest = "serve_while_stale"
        elif key == "signedUrlCacheMaxAgeSec":
            suggest = "signed_url_cache_max_age_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceCdnPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceCdnPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceCdnPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bypass_cache_on_request_headers: Optional[Sequence['outputs.BackendServiceCdnPolicyBypassCacheOnRequestHeader']] = None,
                 cache_key_policy: Optional['outputs.BackendServiceCdnPolicyCacheKeyPolicy'] = None,
                 cache_mode: Optional[_builtins.str] = None,
                 client_ttl: Optional[_builtins.int] = None,
                 default_ttl: Optional[_builtins.int] = None,
                 max_ttl: Optional[_builtins.int] = None,
                 negative_caching: Optional[_builtins.bool] = None,
                 negative_caching_policies: Optional[Sequence['outputs.BackendServiceCdnPolicyNegativeCachingPolicy']] = None,
                 request_coalescing: Optional[_builtins.bool] = None,
                 serve_while_stale: Optional[_builtins.int] = None,
                 signed_url_cache_max_age_sec: Optional[_builtins.int] = None):
        """
        :param Sequence['BackendServiceCdnPolicyBypassCacheOnRequestHeaderArgs'] bypass_cache_on_request_headers: Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
               The cache is bypassed for all cdnPolicy.cacheMode settings.
               Structure is documented below.
        :param 'BackendServiceCdnPolicyCacheKeyPolicyArgs' cache_key_policy: The CacheKeyPolicy for this CdnPolicy.
               Structure is documented below.
        :param _builtins.str cache_mode: Specifies the cache setting for all responses from this backend.
               The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
               Possible values are: `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, `CACHE_ALL_STATIC`.
        :param _builtins.int client_ttl: Specifies the maximum allowed TTL for cached content served by this origin.
        :param _builtins.int default_ttl: Specifies the default TTL for cached content served by this origin for responses
               that do not have an existing valid TTL (max-age or s-max-age).
        :param _builtins.int max_ttl: Specifies the maximum allowed TTL for cached content served by this origin.
        :param _builtins.bool negative_caching: Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        :param Sequence['BackendServiceCdnPolicyNegativeCachingPolicyArgs'] negative_caching_policies: Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
               Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
               Structure is documented below.
        :param _builtins.bool request_coalescing: If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests
               to the origin.
        :param _builtins.int serve_while_stale: Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        :param _builtins.int signed_url_cache_max_age_sec: Maximum number of seconds the response to a signed URL request
               will be considered fresh, defaults to 1hr (3600s). After this
               time period, the response will be revalidated before
               being served.
               When serving responses to signed URL requests, Cloud CDN will
               internally behave as though all responses from this backend had a
               "Cache-Control: public, max-age=[TTL]" header, regardless of any
               existing Cache-Control header. The actual headers served in
               responses will not be altered.
        """
        if bypass_cache_on_request_headers is not None:
            pulumi.set(__self__, "bypass_cache_on_request_headers", bypass_cache_on_request_headers)
        if cache_key_policy is not None:
            pulumi.set(__self__, "cache_key_policy", cache_key_policy)
        if cache_mode is not None:
            pulumi.set(__self__, "cache_mode", cache_mode)
        if client_ttl is not None:
            pulumi.set(__self__, "client_ttl", client_ttl)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if negative_caching is not None:
            pulumi.set(__self__, "negative_caching", negative_caching)
        if negative_caching_policies is not None:
            pulumi.set(__self__, "negative_caching_policies", negative_caching_policies)
        if request_coalescing is not None:
            pulumi.set(__self__, "request_coalescing", request_coalescing)
        if serve_while_stale is not None:
            pulumi.set(__self__, "serve_while_stale", serve_while_stale)
        if signed_url_cache_max_age_sec is not None:
            pulumi.set(__self__, "signed_url_cache_max_age_sec", signed_url_cache_max_age_sec)

    @_builtins.property
    @pulumi.getter(name="bypassCacheOnRequestHeaders")
    def bypass_cache_on_request_headers(self) -> Optional[Sequence['outputs.BackendServiceCdnPolicyBypassCacheOnRequestHeader']]:
        """
        Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
        The cache is bypassed for all cdnPolicy.cacheMode settings.
        Structure is documented below.
        """
        return pulumi.get(self, "bypass_cache_on_request_headers")

    @_builtins.property
    @pulumi.getter(name="cacheKeyPolicy")
    def cache_key_policy(self) -> Optional['outputs.BackendServiceCdnPolicyCacheKeyPolicy']:
        """
        The CacheKeyPolicy for this CdnPolicy.
        Structure is documented below.
        """
        return pulumi.get(self, "cache_key_policy")

    @_builtins.property
    @pulumi.getter(name="cacheMode")
    def cache_mode(self) -> Optional[_builtins.str]:
        """
        Specifies the cache setting for all responses from this backend.
        The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
        Possible values are: `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, `CACHE_ALL_STATIC`.
        """
        return pulumi.get(self, "cache_mode")

    @_builtins.property
    @pulumi.getter(name="clientTtl")
    def client_ttl(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum allowed TTL for cached content served by this origin.
        """
        return pulumi.get(self, "client_ttl")

    @_builtins.property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[_builtins.int]:
        """
        Specifies the default TTL for cached content served by this origin for responses
        that do not have an existing valid TTL (max-age or s-max-age).
        """
        return pulumi.get(self, "default_ttl")

    @_builtins.property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum allowed TTL for cached content served by this origin.
        """
        return pulumi.get(self, "max_ttl")

    @_builtins.property
    @pulumi.getter(name="negativeCaching")
    def negative_caching(self) -> Optional[_builtins.bool]:
        """
        Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        """
        return pulumi.get(self, "negative_caching")

    @_builtins.property
    @pulumi.getter(name="negativeCachingPolicies")
    def negative_caching_policies(self) -> Optional[Sequence['outputs.BackendServiceCdnPolicyNegativeCachingPolicy']]:
        """
        Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
        Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
        Structure is documented below.
        """
        return pulumi.get(self, "negative_caching_policies")

    @_builtins.property
    @pulumi.getter(name="requestCoalescing")
    def request_coalescing(self) -> Optional[_builtins.bool]:
        """
        If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests
        to the origin.
        """
        return pulumi.get(self, "request_coalescing")

    @_builtins.property
    @pulumi.getter(name="serveWhileStale")
    def serve_while_stale(self) -> Optional[_builtins.int]:
        """
        Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        """
        return pulumi.get(self, "serve_while_stale")

    @_builtins.property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> Optional[_builtins.int]:
        """
        Maximum number of seconds the response to a signed URL request
        will be considered fresh, defaults to 1hr (3600s). After this
        time period, the response will be revalidated before
        being served.
        When serving responses to signed URL requests, Cloud CDN will
        internally behave as though all responses from this backend had a
        "Cache-Control: public, max-age=[TTL]" header, regardless of any
        existing Cache-Control header. The actual headers served in
        responses will not be altered.
        """
        return pulumi.get(self, "signed_url_cache_max_age_sec")


@pulumi.output_type
class BackendServiceCdnPolicyBypassCacheOnRequestHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceCdnPolicyBypassCacheOnRequestHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceCdnPolicyBypassCacheOnRequestHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceCdnPolicyBypassCacheOnRequestHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str):
        """
        :param _builtins.str header_name: The header field name to match on when bypassing cache. Values are case-insensitive.
        """
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The header field name to match on when bypassing cache. Values are case-insensitive.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class BackendServiceCdnPolicyCacheKeyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeHost":
            suggest = "include_host"
        elif key == "includeHttpHeaders":
            suggest = "include_http_headers"
        elif key == "includeNamedCookies":
            suggest = "include_named_cookies"
        elif key == "includeProtocol":
            suggest = "include_protocol"
        elif key == "includeQueryString":
            suggest = "include_query_string"
        elif key == "queryStringBlacklists":
            suggest = "query_string_blacklists"
        elif key == "queryStringWhitelists":
            suggest = "query_string_whitelists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceCdnPolicyCacheKeyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceCdnPolicyCacheKeyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceCdnPolicyCacheKeyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_host: Optional[_builtins.bool] = None,
                 include_http_headers: Optional[Sequence[_builtins.str]] = None,
                 include_named_cookies: Optional[Sequence[_builtins.str]] = None,
                 include_protocol: Optional[_builtins.bool] = None,
                 include_query_string: Optional[_builtins.bool] = None,
                 query_string_blacklists: Optional[Sequence[_builtins.str]] = None,
                 query_string_whitelists: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool include_host: If true requests to different hosts will be cached separately.
        :param Sequence[_builtins.str] include_http_headers: Allows HTTP request headers (by name) to be used in the
               cache key.
        :param Sequence[_builtins.str] include_named_cookies: Names of cookies to include in cache keys.
        :param _builtins.bool include_protocol: If true, http and https requests will be cached separately.
        :param _builtins.bool include_query_string: If true, include query string parameters in the cache key
               according to query_string_whitelist and
               query_string_blacklist. If neither is set, the entire query
               string will be included.
               If false, the query string will be excluded from the cache
               key entirely.
        :param Sequence[_builtins.str] query_string_blacklists: Names of query string parameters to exclude in cache keys.
               All other parameters will be included. Either specify
               query_string_whitelist or query_string_blacklist, not both.
               '&' and '=' will be percent encoded and not treated as
               delimiters.
        :param Sequence[_builtins.str] query_string_whitelists: Names of query string parameters to include in cache keys.
               All other parameters will be excluded. Either specify
               query_string_whitelist or query_string_blacklist, not both.
               '&' and '=' will be percent encoded and not treated as
               delimiters.
        """
        if include_host is not None:
            pulumi.set(__self__, "include_host", include_host)
        if include_http_headers is not None:
            pulumi.set(__self__, "include_http_headers", include_http_headers)
        if include_named_cookies is not None:
            pulumi.set(__self__, "include_named_cookies", include_named_cookies)
        if include_protocol is not None:
            pulumi.set(__self__, "include_protocol", include_protocol)
        if include_query_string is not None:
            pulumi.set(__self__, "include_query_string", include_query_string)
        if query_string_blacklists is not None:
            pulumi.set(__self__, "query_string_blacklists", query_string_blacklists)
        if query_string_whitelists is not None:
            pulumi.set(__self__, "query_string_whitelists", query_string_whitelists)

    @_builtins.property
    @pulumi.getter(name="includeHost")
    def include_host(self) -> Optional[_builtins.bool]:
        """
        If true requests to different hosts will be cached separately.
        """
        return pulumi.get(self, "include_host")

    @_builtins.property
    @pulumi.getter(name="includeHttpHeaders")
    def include_http_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Allows HTTP request headers (by name) to be used in the
        cache key.
        """
        return pulumi.get(self, "include_http_headers")

    @_builtins.property
    @pulumi.getter(name="includeNamedCookies")
    def include_named_cookies(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of cookies to include in cache keys.
        """
        return pulumi.get(self, "include_named_cookies")

    @_builtins.property
    @pulumi.getter(name="includeProtocol")
    def include_protocol(self) -> Optional[_builtins.bool]:
        """
        If true, http and https requests will be cached separately.
        """
        return pulumi.get(self, "include_protocol")

    @_builtins.property
    @pulumi.getter(name="includeQueryString")
    def include_query_string(self) -> Optional[_builtins.bool]:
        """
        If true, include query string parameters in the cache key
        according to query_string_whitelist and
        query_string_blacklist. If neither is set, the entire query
        string will be included.
        If false, the query string will be excluded from the cache
        key entirely.
        """
        return pulumi.get(self, "include_query_string")

    @_builtins.property
    @pulumi.getter(name="queryStringBlacklists")
    def query_string_blacklists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of query string parameters to exclude in cache keys.
        All other parameters will be included. Either specify
        query_string_whitelist or query_string_blacklist, not both.
        '&' and '=' will be percent encoded and not treated as
        delimiters.
        """
        return pulumi.get(self, "query_string_blacklists")

    @_builtins.property
    @pulumi.getter(name="queryStringWhitelists")
    def query_string_whitelists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of query string parameters to include in cache keys.
        All other parameters will be excluded. Either specify
        query_string_whitelist or query_string_blacklist, not both.
        '&' and '=' will be percent encoded and not treated as
        delimiters.
        """
        return pulumi.get(self, "query_string_whitelists")


@pulumi.output_type
class BackendServiceCdnPolicyNegativeCachingPolicy(dict):
    def __init__(__self__, *,
                 code: Optional[_builtins.int] = None,
                 ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.int code: The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
               can be specified as values, and you cannot specify a status code more than once.
        :param _builtins.int ttl: The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
               (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.int]:
        """
        The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
        can be specified as values, and you cannot specify a status code more than once.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
        (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class BackendServiceCircuitBreakers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "maxPendingRequests":
            suggest = "max_pending_requests"
        elif key == "maxRequests":
            suggest = "max_requests"
        elif key == "maxRequestsPerConnection":
            suggest = "max_requests_per_connection"
        elif key == "maxRetries":
            suggest = "max_retries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceCircuitBreakers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceCircuitBreakers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceCircuitBreakers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connect_timeout: Optional['outputs.BackendServiceCircuitBreakersConnectTimeout'] = None,
                 max_connections: Optional[_builtins.int] = None,
                 max_pending_requests: Optional[_builtins.int] = None,
                 max_requests: Optional[_builtins.int] = None,
                 max_requests_per_connection: Optional[_builtins.int] = None,
                 max_retries: Optional[_builtins.int] = None):
        """
        :param 'BackendServiceCircuitBreakersConnectTimeoutArgs' connect_timeout: The timeout for new network connections to hosts.
               Structure is documented below.
        :param _builtins.int max_connections: The maximum number of connections to the backend cluster.
               Defaults to 1024.
        :param _builtins.int max_pending_requests: The maximum number of pending requests to the backend cluster.
               Defaults to 1024.
        :param _builtins.int max_requests: The maximum number of parallel requests to the backend cluster.
               Defaults to 1024.
        :param _builtins.int max_requests_per_connection: Maximum requests for a single backend connection. This parameter
               is respected by both the HTTP/1.1 and HTTP/2 implementations. If
               not specified, there is no limit. Setting this parameter to 1
               will effectively disable keep alive.
        :param _builtins.int max_retries: The maximum number of parallel retries to the backend cluster.
               Defaults to 3.
        """
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_pending_requests is not None:
            pulumi.set(__self__, "max_pending_requests", max_pending_requests)
        if max_requests is not None:
            pulumi.set(__self__, "max_requests", max_requests)
        if max_requests_per_connection is not None:
            pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)

    @_builtins.property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional['outputs.BackendServiceCircuitBreakersConnectTimeout']:
        """
        The timeout for new network connections to hosts.
        Structure is documented below.
        """
        return pulumi.get(self, "connect_timeout")

    @_builtins.property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[_builtins.int]:
        """
        The maximum number of connections to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_connections")

    @_builtins.property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> Optional[_builtins.int]:
        """
        The maximum number of pending requests to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_pending_requests")

    @_builtins.property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> Optional[_builtins.int]:
        """
        The maximum number of parallel requests to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_requests")

    @_builtins.property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> Optional[_builtins.int]:
        """
        Maximum requests for a single backend connection. This parameter
        is respected by both the HTTP/1.1 and HTTP/2 implementations. If
        not specified, there is no limit. Setting this parameter to 1
        will effectively disable keep alive.
        """
        return pulumi.get(self, "max_requests_per_connection")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        """
        The maximum number of parallel retries to the backend cluster.
        Defaults to 3.
        """
        return pulumi.get(self, "max_retries")


@pulumi.output_type
class BackendServiceCircuitBreakersConnectTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class BackendServiceConsistentHash(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpCookie":
            suggest = "http_cookie"
        elif key == "httpHeaderName":
            suggest = "http_header_name"
        elif key == "minimumRingSize":
            suggest = "minimum_ring_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceConsistentHash. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceConsistentHash.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceConsistentHash.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_cookie: Optional['outputs.BackendServiceConsistentHashHttpCookie'] = None,
                 http_header_name: Optional[_builtins.str] = None,
                 minimum_ring_size: Optional[_builtins.int] = None):
        """
        :param 'BackendServiceConsistentHashHttpCookieArgs' http_cookie: Hash is based on HTTP Cookie. This field describes a HTTP cookie
               that will be used as the hash key for the consistent hash load
               balancer. If the cookie is not present, it will be generated.
               This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
               Structure is documented below.
        :param _builtins.str http_header_name: The hash based on the value of the specified header field.
               This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        :param _builtins.int minimum_ring_size: The minimum number of virtual nodes to use for the hash ring.
               Larger ring sizes result in more granular load
               distributions. If the number of hosts in the load balancing pool
               is larger than the ring size, each host will be assigned a single
               virtual node.
               Defaults to 1024.
        """
        if http_cookie is not None:
            pulumi.set(__self__, "http_cookie", http_cookie)
        if http_header_name is not None:
            pulumi.set(__self__, "http_header_name", http_header_name)
        if minimum_ring_size is not None:
            pulumi.set(__self__, "minimum_ring_size", minimum_ring_size)

    @_builtins.property
    @pulumi.getter(name="httpCookie")
    def http_cookie(self) -> Optional['outputs.BackendServiceConsistentHashHttpCookie']:
        """
        Hash is based on HTTP Cookie. This field describes a HTTP cookie
        that will be used as the hash key for the consistent hash load
        balancer. If the cookie is not present, it will be generated.
        This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
        Structure is documented below.
        """
        return pulumi.get(self, "http_cookie")

    @_builtins.property
    @pulumi.getter(name="httpHeaderName")
    def http_header_name(self) -> Optional[_builtins.str]:
        """
        The hash based on the value of the specified header field.
        This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        """
        return pulumi.get(self, "http_header_name")

    @_builtins.property
    @pulumi.getter(name="minimumRingSize")
    def minimum_ring_size(self) -> Optional[_builtins.int]:
        """
        The minimum number of virtual nodes to use for the hash ring.
        Larger ring sizes result in more granular load
        distributions. If the number of hosts in the load balancing pool
        is larger than the ring size, each host will be assigned a single
        virtual node.
        Defaults to 1024.
        """
        return pulumi.get(self, "minimum_ring_size")


@pulumi.output_type
class BackendServiceConsistentHashHttpCookie(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 ttl: Optional['outputs.BackendServiceConsistentHashHttpCookieTtl'] = None):
        """
        :param _builtins.str name: Name of the cookie.
        :param _builtins.str path: Path to set for the cookie.
        :param 'BackendServiceConsistentHashHttpCookieTtlArgs' ttl: Lifetime of the cookie.
               Structure is documented below.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the cookie.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to set for the cookie.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional['outputs.BackendServiceConsistentHashHttpCookieTtl']:
        """
        Lifetime of the cookie.
        Structure is documented below.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class BackendServiceConsistentHashHttpCookieTtl(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class BackendServiceCustomMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dryRun":
            suggest = "dry_run"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceCustomMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceCustomMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceCustomMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dry_run: _builtins.bool,
                 name: _builtins.str):
        """
        :param _builtins.bool dry_run: If true, the metric data is not used for load balancing.
        :param _builtins.str name: Name of a custom utilization signal. The name must be 1-64 characters
               long and match the regular expression a-z? which
               means the first character must be a lowercase letter, and all following
               characters must be a dash, period, underscore, lowercase letter, or
               digit, except the last character, which cannot be a dash, period, or
               underscore. For usage guidelines, see Custom Metrics balancing mode. This
               field can only be used for a global or regional backend service with the
               loadBalancingScheme set to <code>EXTERNAL_MANAGED</code>,
               <code>INTERNAL_MANAGED</code> <code>INTERNAL_SELF_MANAGED</code>.
        """
        pulumi.set(__self__, "dry_run", dry_run)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> _builtins.bool:
        """
        If true, the metric data is not used for load balancing.
        """
        return pulumi.get(self, "dry_run")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a custom utilization signal. The name must be 1-64 characters
        long and match the regular expression a-z? which
        means the first character must be a lowercase letter, and all following
        characters must be a dash, period, underscore, lowercase letter, or
        digit, except the last character, which cannot be a dash, period, or
        underscore. For usage guidelines, see Custom Metrics balancing mode. This
        field can only be used for a global or regional backend service with the
        loadBalancingScheme set to <code>EXTERNAL_MANAGED</code>,
        <code>INTERNAL_MANAGED</code> <code>INTERNAL_SELF_MANAGED</code>.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class BackendServiceDynamicForwarding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipPortSelection":
            suggest = "ip_port_selection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceDynamicForwarding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceDynamicForwarding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceDynamicForwarding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_port_selection: Optional['outputs.BackendServiceDynamicForwardingIpPortSelection'] = None):
        """
        :param 'BackendServiceDynamicForwardingIpPortSelectionArgs' ip_port_selection: IP:PORT based dynamic forwarding configuration.
               Structure is documented below.
        """
        if ip_port_selection is not None:
            pulumi.set(__self__, "ip_port_selection", ip_port_selection)

    @_builtins.property
    @pulumi.getter(name="ipPortSelection")
    def ip_port_selection(self) -> Optional['outputs.BackendServiceDynamicForwardingIpPortSelection']:
        """
        IP:PORT based dynamic forwarding configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "ip_port_selection")


@pulumi.output_type
class BackendServiceDynamicForwardingIpPortSelection(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: A boolean flag enabling IP:PORT based dynamic forwarding.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        A boolean flag enabling IP:PORT based dynamic forwarding.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class BackendServiceIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class BackendServiceIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class BackendServiceIap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oauth2ClientId":
            suggest = "oauth2_client_id"
        elif key == "oauth2ClientSecret":
            suggest = "oauth2_client_secret"
        elif key == "oauth2ClientSecretSha256":
            suggest = "oauth2_client_secret_sha256"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceIap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceIap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceIap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 oauth2_client_id: Optional[_builtins.str] = None,
                 oauth2_client_secret: Optional[_builtins.str] = None,
                 oauth2_client_secret_sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Whether the serving infrastructure will authenticate and authorize all incoming requests.
        :param _builtins.str oauth2_client_id: OAuth2 Client ID for IAP
        :param _builtins.str oauth2_client_secret: OAuth2 Client Secret for IAP
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str oauth2_client_secret_sha256: (Output)
               OAuth2 Client Secret SHA-256 for IAP
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "enabled", enabled)
        if oauth2_client_id is not None:
            pulumi.set(__self__, "oauth2_client_id", oauth2_client_id)
        if oauth2_client_secret is not None:
            pulumi.set(__self__, "oauth2_client_secret", oauth2_client_secret)
        if oauth2_client_secret_sha256 is not None:
            pulumi.set(__self__, "oauth2_client_secret_sha256", oauth2_client_secret_sha256)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether the serving infrastructure will authenticate and authorize all incoming requests.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientId")
    def oauth2_client_id(self) -> Optional[_builtins.str]:
        """
        OAuth2 Client ID for IAP
        """
        return pulumi.get(self, "oauth2_client_id")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientSecret")
    def oauth2_client_secret(self) -> Optional[_builtins.str]:
        """
        OAuth2 Client Secret for IAP
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "oauth2_client_secret")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientSecretSha256")
    def oauth2_client_secret_sha256(self) -> Optional[_builtins.str]:
        """
        (Output)
        OAuth2 Client Secret SHA-256 for IAP
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "oauth2_client_secret_sha256")


@pulumi.output_type
class BackendServiceLocalityLbPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customPolicy":
            suggest = "custom_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceLocalityLbPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceLocalityLbPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceLocalityLbPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_policy: Optional['outputs.BackendServiceLocalityLbPolicyCustomPolicy'] = None,
                 policy: Optional['outputs.BackendServiceLocalityLbPolicyPolicy'] = None):
        """
        :param 'BackendServiceLocalityLbPolicyCustomPolicyArgs' custom_policy: The configuration for a custom policy implemented by the user and
               deployed with the client.
               Structure is documented below.
        :param 'BackendServiceLocalityLbPolicyPolicyArgs' policy: The configuration for a built-in load balancing policy.
               Structure is documented below.
        """
        if custom_policy is not None:
            pulumi.set(__self__, "custom_policy", custom_policy)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @_builtins.property
    @pulumi.getter(name="customPolicy")
    def custom_policy(self) -> Optional['outputs.BackendServiceLocalityLbPolicyCustomPolicy']:
        """
        The configuration for a custom policy implemented by the user and
        deployed with the client.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_policy")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional['outputs.BackendServiceLocalityLbPolicyPolicy']:
        """
        The configuration for a built-in load balancing policy.
        Structure is documented below.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class BackendServiceLocalityLbPolicyCustomPolicy(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 data: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Identifies the custom policy.
               The value should match the type the custom implementation is registered
               with on the gRPC clients. It should follow protocol buffer
               message naming conventions and include the full path (e.g.
               myorg.CustomLbPolicy). The maximum length is 256 characters.
               Note that specifying the same custom policy more than once for a
               backend is not a valid configuration and will be rejected.
        :param _builtins.str data: An optional, arbitrary JSON object with configuration data, understood
               by a locally installed custom policy implementation.
        """
        pulumi.set(__self__, "name", name)
        if data is not None:
            pulumi.set(__self__, "data", data)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Identifies the custom policy.
        The value should match the type the custom implementation is registered
        with on the gRPC clients. It should follow protocol buffer
        message naming conventions and include the full path (e.g.
        myorg.CustomLbPolicy). The maximum length is 256 characters.
        Note that specifying the same custom policy more than once for a
        backend is not a valid configuration and will be rejected.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def data(self) -> Optional[_builtins.str]:
        """
        An optional, arbitrary JSON object with configuration data, understood
        by a locally installed custom policy implementation.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class BackendServiceLocalityLbPolicyPolicy(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of a locality load balancer policy to be used. The value
               should be one of the predefined ones as supported by localityLbPolicy,
               although at the moment only ROUND_ROBIN is supported.
               This field should only be populated when the customPolicy field is not
               used.
               Note that specifying the same policy more than once for a backend is
               not a valid configuration and will be rejected.
               The possible values are:
               * `ROUND_ROBIN`: This is a simple policy in which each healthy backend
               is selected in round robin order.
               * `LEAST_REQUEST`: An O(1) algorithm which selects two random healthy
               hosts and picks the host which has fewer active requests.
               * `RING_HASH`: The ring/modulo hash load balancer implements consistent
               hashing to backends. The algorithm has the property that the
               addition/removal of a host from a set of N hosts only affects
               1/N of the requests.
               * `RANDOM`: The load balancer selects a random healthy host.
               * `ORIGINAL_DESTINATION`: Backend host is selected based on the client
               connection metadata, i.e., connections are opened
               to the same address as the destination address of
               the incoming connection before the connection
               was redirected to the load balancer.
               * `MAGLEV`: used as a drop in replacement for the ring hash load balancer.
               Maglev is not as stable as ring hash but has faster table lookup
               build times and host selection times. For more information about
               Maglev, refer to https://ai.google/research/pubs/pub44824
               Possible values are: `ROUND_ROBIN`, `LEAST_REQUEST`, `RING_HASH`, `RANDOM`, `ORIGINAL_DESTINATION`, `MAGLEV`.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of a locality load balancer policy to be used. The value
        should be one of the predefined ones as supported by localityLbPolicy,
        although at the moment only ROUND_ROBIN is supported.
        This field should only be populated when the customPolicy field is not
        used.
        Note that specifying the same policy more than once for a backend is
        not a valid configuration and will be rejected.
        The possible values are:
        * `ROUND_ROBIN`: This is a simple policy in which each healthy backend
        is selected in round robin order.
        * `LEAST_REQUEST`: An O(1) algorithm which selects two random healthy
        hosts and picks the host which has fewer active requests.
        * `RING_HASH`: The ring/modulo hash load balancer implements consistent
        hashing to backends. The algorithm has the property that the
        addition/removal of a host from a set of N hosts only affects
        1/N of the requests.
        * `RANDOM`: The load balancer selects a random healthy host.
        * `ORIGINAL_DESTINATION`: Backend host is selected based on the client
        connection metadata, i.e., connections are opened
        to the same address as the destination address of
        the incoming connection before the connection
        was redirected to the load balancer.
        * `MAGLEV`: used as a drop in replacement for the ring hash load balancer.
        Maglev is not as stable as ring hash but has faster table lookup
        build times and host selection times. For more information about
        Maglev, refer to https://ai.google/research/pubs/pub44824
        Possible values are: `ROUND_ROBIN`, `LEAST_REQUEST`, `RING_HASH`, `RANDOM`, `ORIGINAL_DESTINATION`, `MAGLEV`.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class BackendServiceLogConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optionalFields":
            suggest = "optional_fields"
        elif key == "optionalMode":
            suggest = "optional_mode"
        elif key == "sampleRate":
            suggest = "sample_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceLogConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceLogConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceLogConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None,
                 optional_fields: Optional[Sequence[_builtins.str]] = None,
                 optional_mode: Optional[_builtins.str] = None,
                 sample_rate: Optional[_builtins.float] = None):
        """
        :param _builtins.bool enable: Whether to enable logging for the load balancer traffic served by this backend service.
        :param Sequence[_builtins.str] optional_fields: This field can only be specified if logging is enabled for this backend service and "logConfig.optionalMode"
               was set to CUSTOM. Contains a list of optional fields you want to include in the logs.
               For example: serverInstance, serverGkeDetails.cluster, serverGkeDetails.pod.podNamespace
               For example: orca_load_report, tls.protocol
        :param _builtins.str optional_mode: Specifies the optional logging mode for the load balancer traffic.
               Supported values: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM.
               Possible values are: `INCLUDE_ALL_OPTIONAL`, `EXCLUDE_ALL_OPTIONAL`, `CUSTOM`.
        :param _builtins.float sample_rate: This field can only be specified if logging is enabled for this backend service. The value of
               the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
               where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
               The default value is 1.0.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if optional_fields is not None:
            pulumi.set(__self__, "optional_fields", optional_fields)
        if optional_mode is not None:
            pulumi.set(__self__, "optional_mode", optional_mode)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        Whether to enable logging for the load balancer traffic served by this backend service.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="optionalFields")
    def optional_fields(self) -> Optional[Sequence[_builtins.str]]:
        """
        This field can only be specified if logging is enabled for this backend service and "logConfig.optionalMode"
        was set to CUSTOM. Contains a list of optional fields you want to include in the logs.
        For example: serverInstance, serverGkeDetails.cluster, serverGkeDetails.pod.podNamespace
        For example: orca_load_report, tls.protocol
        """
        return pulumi.get(self, "optional_fields")

    @_builtins.property
    @pulumi.getter(name="optionalMode")
    def optional_mode(self) -> Optional[_builtins.str]:
        """
        Specifies the optional logging mode for the load balancer traffic.
        Supported values: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM.
        Possible values are: `INCLUDE_ALL_OPTIONAL`, `EXCLUDE_ALL_OPTIONAL`, `CUSTOM`.
        """
        return pulumi.get(self, "optional_mode")

    @_builtins.property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[_builtins.float]:
        """
        This field can only be specified if logging is enabled for this backend service. The value of
        the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
        where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
        The default value is 1.0.
        """
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class BackendServiceMaxStreamDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. (int64 format)
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution.
               Durations less than one second are represented with a 0 seconds field and a positive nanos field.
               Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. (int64 format)
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution.
        Durations less than one second are represented with a 0 seconds field and a positive nanos field.
        Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class BackendServiceNetworkPassThroughLbTrafficPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "zonalAffinity":
            suggest = "zonal_affinity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceNetworkPassThroughLbTrafficPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceNetworkPassThroughLbTrafficPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceNetworkPassThroughLbTrafficPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 zonal_affinity: Optional['outputs.BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity'] = None):
        """
        :param 'BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinityArgs' zonal_affinity: When configured, new connections are load balanced across healthy backend endpoints in the local zone.
               Structure is documented below.
        """
        if zonal_affinity is not None:
            pulumi.set(__self__, "zonal_affinity", zonal_affinity)

    @_builtins.property
    @pulumi.getter(name="zonalAffinity")
    def zonal_affinity(self) -> Optional['outputs.BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity']:
        """
        When configured, new connections are load balanced across healthy backend endpoints in the local zone.
        Structure is documented below.
        """
        return pulumi.get(self, "zonal_affinity")


@pulumi.output_type
class BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spilloverRatio":
            suggest = "spillover_ratio"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spillover: Optional[_builtins.str] = None,
                 spillover_ratio: Optional[_builtins.float] = None):
        """
        :param _builtins.str spillover: This field indicates whether zonal affinity is enabled or not.
               Default value is `ZONAL_AFFINITY_DISABLED`.
               Possible values are: `ZONAL_AFFINITY_DISABLED`, `ZONAL_AFFINITY_SPILL_CROSS_ZONE`, `ZONAL_AFFINITY_STAY_WITHIN_ZONE`.
        :param _builtins.float spillover_ratio: The value of the field must be in [0, 1]. When the ratio of the count of healthy backend endpoints in a zone
               to the count of backend endpoints in that same zone is equal to or above this threshold, the load balancer
               distributes new connections to all healthy endpoints in the local zone only. When the ratio of the count
               of healthy backend endpoints in a zone to the count of backend endpoints in that same zone is below this
               threshold, the load balancer distributes all new connections to all healthy endpoints across all zones.
        """
        if spillover is not None:
            pulumi.set(__self__, "spillover", spillover)
        if spillover_ratio is not None:
            pulumi.set(__self__, "spillover_ratio", spillover_ratio)

    @_builtins.property
    @pulumi.getter
    def spillover(self) -> Optional[_builtins.str]:
        """
        This field indicates whether zonal affinity is enabled or not.
        Default value is `ZONAL_AFFINITY_DISABLED`.
        Possible values are: `ZONAL_AFFINITY_DISABLED`, `ZONAL_AFFINITY_SPILL_CROSS_ZONE`, `ZONAL_AFFINITY_STAY_WITHIN_ZONE`.
        """
        return pulumi.get(self, "spillover")

    @_builtins.property
    @pulumi.getter(name="spilloverRatio")
    def spillover_ratio(self) -> Optional[_builtins.float]:
        """
        The value of the field must be in [0, 1]. When the ratio of the count of healthy backend endpoints in a zone
        to the count of backend endpoints in that same zone is equal to or above this threshold, the load balancer
        distributes new connections to all healthy endpoints in the local zone only. When the ratio of the count
        of healthy backend endpoints in a zone to the count of backend endpoints in that same zone is below this
        threshold, the load balancer distributes all new connections to all healthy endpoints across all zones.
        """
        return pulumi.get(self, "spillover_ratio")


@pulumi.output_type
class BackendServiceOutlierDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseEjectionTime":
            suggest = "base_ejection_time"
        elif key == "consecutiveErrors":
            suggest = "consecutive_errors"
        elif key == "consecutiveGatewayFailure":
            suggest = "consecutive_gateway_failure"
        elif key == "enforcingConsecutiveErrors":
            suggest = "enforcing_consecutive_errors"
        elif key == "enforcingConsecutiveGatewayFailure":
            suggest = "enforcing_consecutive_gateway_failure"
        elif key == "enforcingSuccessRate":
            suggest = "enforcing_success_rate"
        elif key == "maxEjectionPercent":
            suggest = "max_ejection_percent"
        elif key == "successRateMinimumHosts":
            suggest = "success_rate_minimum_hosts"
        elif key == "successRateRequestVolume":
            suggest = "success_rate_request_volume"
        elif key == "successRateStdevFactor":
            suggest = "success_rate_stdev_factor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceOutlierDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceOutlierDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceOutlierDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_ejection_time: Optional['outputs.BackendServiceOutlierDetectionBaseEjectionTime'] = None,
                 consecutive_errors: Optional[_builtins.int] = None,
                 consecutive_gateway_failure: Optional[_builtins.int] = None,
                 enforcing_consecutive_errors: Optional[_builtins.int] = None,
                 enforcing_consecutive_gateway_failure: Optional[_builtins.int] = None,
                 enforcing_success_rate: Optional[_builtins.int] = None,
                 interval: Optional['outputs.BackendServiceOutlierDetectionInterval'] = None,
                 max_ejection_percent: Optional[_builtins.int] = None,
                 success_rate_minimum_hosts: Optional[_builtins.int] = None,
                 success_rate_request_volume: Optional[_builtins.int] = None,
                 success_rate_stdev_factor: Optional[_builtins.int] = None):
        """
        :param 'BackendServiceOutlierDetectionBaseEjectionTimeArgs' base_ejection_time: The base time that a host is ejected for. The real time is equal to the base
               time multiplied by the number of times the host has been ejected. Defaults to
               30000ms or 30s.
               Structure is documented below.
        :param _builtins.int consecutive_errors: Number of errors before a host is ejected from the connection pool. When the
               backend host is accessed over HTTP, a 5xx return code qualifies as an error.
               Defaults to 5.
        :param _builtins.int consecutive_gateway_failure: The number of consecutive gateway failures (502, 503, 504 status or connection
               errors that are mapped to one of those status codes) before a consecutive
               gateway failure ejection occurs. Defaults to 5.
        :param _builtins.int enforcing_consecutive_errors: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive 5xx. This setting can be used to disable
               ejection or to ramp it up slowly. Defaults to 100.
        :param _builtins.int enforcing_consecutive_gateway_failure: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive gateway failures. This setting can be
               used to disable ejection or to ramp it up slowly. Defaults to 0.
        :param _builtins.int enforcing_success_rate: The percentage chance that a host will be actually ejected when an outlier
               status is detected through success rate statistics. This setting can be used to
               disable ejection or to ramp it up slowly. Defaults to 100.
        :param 'BackendServiceOutlierDetectionIntervalArgs' interval: Time interval between ejection sweep analysis. This can result in both new
               ejections as well as hosts being returned to service. Defaults to 10 seconds.
               Structure is documented below.
        :param _builtins.int max_ejection_percent: Maximum percentage of hosts in the load balancing pool for the backend service
               that can be ejected. Defaults to 10%.
        :param _builtins.int success_rate_minimum_hosts: The number of hosts in a cluster that must have enough request volume to detect
               success rate outliers. If the number of hosts is less than this setting, outlier
               detection via success rate statistics is not performed for any host in the
               cluster. Defaults to 5.
        :param _builtins.int success_rate_request_volume: The minimum number of total requests that must be collected in one interval (as
               defined by the interval duration above) to include this host in success rate
               based outlier detection. If the volume is lower than this setting, outlier
               detection via success rate statistics is not performed for that host. Defaults
               to 100.
        :param _builtins.int success_rate_stdev_factor: This factor is used to determine the ejection threshold for success rate outlier
               ejection. The ejection threshold is the difference between the mean success
               rate, and the product of this factor and the standard deviation of the mean
               success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
               by a thousand to get a double. That is, if the desired factor is 1.9, the
               runtime value should be 1900. Defaults to 1900.
        """
        if base_ejection_time is not None:
            pulumi.set(__self__, "base_ejection_time", base_ejection_time)
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if consecutive_gateway_failure is not None:
            pulumi.set(__self__, "consecutive_gateway_failure", consecutive_gateway_failure)
        if enforcing_consecutive_errors is not None:
            pulumi.set(__self__, "enforcing_consecutive_errors", enforcing_consecutive_errors)
        if enforcing_consecutive_gateway_failure is not None:
            pulumi.set(__self__, "enforcing_consecutive_gateway_failure", enforcing_consecutive_gateway_failure)
        if enforcing_success_rate is not None:
            pulumi.set(__self__, "enforcing_success_rate", enforcing_success_rate)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        if success_rate_minimum_hosts is not None:
            pulumi.set(__self__, "success_rate_minimum_hosts", success_rate_minimum_hosts)
        if success_rate_request_volume is not None:
            pulumi.set(__self__, "success_rate_request_volume", success_rate_request_volume)
        if success_rate_stdev_factor is not None:
            pulumi.set(__self__, "success_rate_stdev_factor", success_rate_stdev_factor)

    @_builtins.property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional['outputs.BackendServiceOutlierDetectionBaseEjectionTime']:
        """
        The base time that a host is ejected for. The real time is equal to the base
        time multiplied by the number of times the host has been ejected. Defaults to
        30000ms or 30s.
        Structure is documented below.
        """
        return pulumi.get(self, "base_ejection_time")

    @_builtins.property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[_builtins.int]:
        """
        Number of errors before a host is ejected from the connection pool. When the
        backend host is accessed over HTTP, a 5xx return code qualifies as an error.
        Defaults to 5.
        """
        return pulumi.get(self, "consecutive_errors")

    @_builtins.property
    @pulumi.getter(name="consecutiveGatewayFailure")
    def consecutive_gateway_failure(self) -> Optional[_builtins.int]:
        """
        The number of consecutive gateway failures (502, 503, 504 status or connection
        errors that are mapped to one of those status codes) before a consecutive
        gateway failure ejection occurs. Defaults to 5.
        """
        return pulumi.get(self, "consecutive_gateway_failure")

    @_builtins.property
    @pulumi.getter(name="enforcingConsecutiveErrors")
    def enforcing_consecutive_errors(self) -> Optional[_builtins.int]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive 5xx. This setting can be used to disable
        ejection or to ramp it up slowly. Defaults to 100.
        """
        return pulumi.get(self, "enforcing_consecutive_errors")

    @_builtins.property
    @pulumi.getter(name="enforcingConsecutiveGatewayFailure")
    def enforcing_consecutive_gateway_failure(self) -> Optional[_builtins.int]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive gateway failures. This setting can be
        used to disable ejection or to ramp it up slowly. Defaults to 0.
        """
        return pulumi.get(self, "enforcing_consecutive_gateway_failure")

    @_builtins.property
    @pulumi.getter(name="enforcingSuccessRate")
    def enforcing_success_rate(self) -> Optional[_builtins.int]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through success rate statistics. This setting can be used to
        disable ejection or to ramp it up slowly. Defaults to 100.
        """
        return pulumi.get(self, "enforcing_success_rate")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional['outputs.BackendServiceOutlierDetectionInterval']:
        """
        Time interval between ejection sweep analysis. This can result in both new
        ejections as well as hosts being returned to service. Defaults to 10 seconds.
        Structure is documented below.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[_builtins.int]:
        """
        Maximum percentage of hosts in the load balancing pool for the backend service
        that can be ejected. Defaults to 10%.
        """
        return pulumi.get(self, "max_ejection_percent")

    @_builtins.property
    @pulumi.getter(name="successRateMinimumHosts")
    def success_rate_minimum_hosts(self) -> Optional[_builtins.int]:
        """
        The number of hosts in a cluster that must have enough request volume to detect
        success rate outliers. If the number of hosts is less than this setting, outlier
        detection via success rate statistics is not performed for any host in the
        cluster. Defaults to 5.
        """
        return pulumi.get(self, "success_rate_minimum_hosts")

    @_builtins.property
    @pulumi.getter(name="successRateRequestVolume")
    def success_rate_request_volume(self) -> Optional[_builtins.int]:
        """
        The minimum number of total requests that must be collected in one interval (as
        defined by the interval duration above) to include this host in success rate
        based outlier detection. If the volume is lower than this setting, outlier
        detection via success rate statistics is not performed for that host. Defaults
        to 100.
        """
        return pulumi.get(self, "success_rate_request_volume")

    @_builtins.property
    @pulumi.getter(name="successRateStdevFactor")
    def success_rate_stdev_factor(self) -> Optional[_builtins.int]:
        """
        This factor is used to determine the ejection threshold for success rate outlier
        ejection. The ejection threshold is the difference between the mean success
        rate, and the product of this factor and the standard deviation of the mean
        success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
        by a thousand to get a double. That is, if the desired factor is 1.9, the
        runtime value should be 1900. Defaults to 1900.
        """
        return pulumi.get(self, "success_rate_stdev_factor")


@pulumi.output_type
class BackendServiceOutlierDetectionBaseEjectionTime(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class BackendServiceOutlierDetectionInterval(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class BackendServiceParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the backend service. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456.
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource manager tags to be bound to the backend service. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class BackendServiceSecuritySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsV4Authentication":
            suggest = "aws_v4_authentication"
        elif key == "clientTlsPolicy":
            suggest = "client_tls_policy"
        elif key == "subjectAltNames":
            suggest = "subject_alt_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceSecuritySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceSecuritySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceSecuritySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_v4_authentication: Optional['outputs.BackendServiceSecuritySettingsAwsV4Authentication'] = None,
                 client_tls_policy: Optional[_builtins.str] = None,
                 subject_alt_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param 'BackendServiceSecuritySettingsAwsV4AuthenticationArgs' aws_v4_authentication: The configuration needed to generate a signature for access to private storage buckets that support AWS's Signature Version 4 for authentication.
               Allowed only for INTERNET_IP_PORT and INTERNET_FQDN_PORT NEG backends.
               Structure is documented below.
               
               
               <a name="nested_security_settings_aws_v4_authentication"></a>The `aws_v4_authentication` block supports:
        :param _builtins.str client_tls_policy: ClientTlsPolicy is a resource that specifies how a client should authenticate
               connections to backends of a service. This resource itself does not affect
               configuration unless it is attached to a backend service resource.
        :param Sequence[_builtins.str] subject_alt_names: A list of alternate names to verify the subject identity in the certificate.
               If specified, the client will verify that the server certificate's subject
               alt name matches one of the specified values.
        """
        if aws_v4_authentication is not None:
            pulumi.set(__self__, "aws_v4_authentication", aws_v4_authentication)
        if client_tls_policy is not None:
            pulumi.set(__self__, "client_tls_policy", client_tls_policy)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @_builtins.property
    @pulumi.getter(name="awsV4Authentication")
    def aws_v4_authentication(self) -> Optional['outputs.BackendServiceSecuritySettingsAwsV4Authentication']:
        """
        The configuration needed to generate a signature for access to private storage buckets that support AWS's Signature Version 4 for authentication.
        Allowed only for INTERNET_IP_PORT and INTERNET_FQDN_PORT NEG backends.
        Structure is documented below.


        <a name="nested_security_settings_aws_v4_authentication"></a>The `aws_v4_authentication` block supports:
        """
        return pulumi.get(self, "aws_v4_authentication")

    @_builtins.property
    @pulumi.getter(name="clientTlsPolicy")
    def client_tls_policy(self) -> Optional[_builtins.str]:
        """
        ClientTlsPolicy is a resource that specifies how a client should authenticate
        connections to backends of a service. This resource itself does not affect
        configuration unless it is attached to a backend service resource.
        """
        return pulumi.get(self, "client_tls_policy")

    @_builtins.property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of alternate names to verify the subject identity in the certificate.
        If specified, the client will verify that the server certificate's subject
        alt name matches one of the specified values.
        """
        return pulumi.get(self, "subject_alt_names")


@pulumi.output_type
class BackendServiceSecuritySettingsAwsV4Authentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "accessKeyVersion":
            suggest = "access_key_version"
        elif key == "originRegion":
            suggest = "origin_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceSecuritySettingsAwsV4Authentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceSecuritySettingsAwsV4Authentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceSecuritySettingsAwsV4Authentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[_builtins.str] = None,
                 access_key_id: Optional[_builtins.str] = None,
                 access_key_version: Optional[_builtins.str] = None,
                 origin_region: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_key: The access key used for s3 bucket authentication.
               Required for updating or creating a backend that uses AWS v4 signature authentication, but will not be returned as part of the configuration when queried with a REST API GET request.
        :param _builtins.str access_key_id: The identifier of an access key used for s3 bucket authentication.
        :param _builtins.str access_key_version: The optional version identifier for the access key. You can use this to keep track of different iterations of your access key.
        :param _builtins.str origin_region: The name of the cloud region of your origin. This is a free-form field with the name of the region your cloud uses to host your origin.
               For example, "us-east-1" for AWS or "us-ashburn-1" for OCI.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if access_key_version is not None:
            pulumi.set(__self__, "access_key_version", access_key_version)
        if origin_region is not None:
            pulumi.set(__self__, "origin_region", origin_region)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The access key used for s3 bucket authentication.
        Required for updating or creating a backend that uses AWS v4 signature authentication, but will not be returned as part of the configuration when queried with a REST API GET request.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[_builtins.str]:
        """
        The identifier of an access key used for s3 bucket authentication.
        """
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter(name="accessKeyVersion")
    def access_key_version(self) -> Optional[_builtins.str]:
        """
        The optional version identifier for the access key. You can use this to keep track of different iterations of your access key.
        """
        return pulumi.get(self, "access_key_version")

    @_builtins.property
    @pulumi.getter(name="originRegion")
    def origin_region(self) -> Optional[_builtins.str]:
        """
        The name of the cloud region of your origin. This is a free-form field with the name of the region your cloud uses to host your origin.
        For example, "us-east-1" for AWS or "us-ashburn-1" for OCI.
        """
        return pulumi.get(self, "origin_region")


@pulumi.output_type
class BackendServiceStrongSessionAffinityCookie(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 ttl: Optional['outputs.BackendServiceStrongSessionAffinityCookieTtl'] = None):
        """
        :param _builtins.str name: Name of the cookie.
        :param _builtins.str path: Path to set for the cookie.
        :param 'BackendServiceStrongSessionAffinityCookieTtlArgs' ttl: Lifetime of the cookie.
               Structure is documented below.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the cookie.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to set for the cookie.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional['outputs.BackendServiceStrongSessionAffinityCookieTtl']:
        """
        Lifetime of the cookie.
        Structure is documented below.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class BackendServiceStrongSessionAffinityCookieTtl(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class BackendServiceTlsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationConfig":
            suggest = "authentication_config"
        elif key == "subjectAltNames":
            suggest = "subject_alt_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceTlsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceTlsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceTlsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_config: Optional[_builtins.str] = None,
                 sni: Optional[_builtins.str] = None,
                 subject_alt_names: Optional[Sequence['outputs.BackendServiceTlsSettingsSubjectAltName']] = None):
        """
        :param _builtins.str authentication_config: Reference to the BackendAuthenticationConfig resource from the networksecurity.googleapis.com namespace.
               Can be used in authenticating TLS connections to the backend, as specified by the authenticationMode field.
               Can only be specified if authenticationMode is not NONE.
        :param _builtins.str sni: Server Name Indication - see RFC3546 section 3.1. If set, the load balancer sends this string as the SNI hostname in the
               TLS connection to the backend, and requires that this string match a Subject Alternative Name (SAN) in the backend's
               server certificate. With a Regional Internet NEG backend, if the SNI is specified here, the load balancer uses it
               regardless of whether the Regional Internet NEG is specified with FQDN or IP address and port.
        :param Sequence['BackendServiceTlsSettingsSubjectAltNameArgs'] subject_alt_names: A list of Subject Alternative Names (SANs) that the Load Balancer verifies during a TLS handshake with the backend.
               When the server presents its X.509 certificate to the Load Balancer, the Load Balancer inspects the certificate's SAN field,
               and requires that at least one SAN match one of the subjectAltNames in the list. This field is limited to 5 entries.
               When both sni and subjectAltNames are specified, the load balancer matches the backend certificate's SAN only to
               subjectAltNames.
               Structure is documented below.
        """
        if authentication_config is not None:
            pulumi.set(__self__, "authentication_config", authentication_config)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @_builtins.property
    @pulumi.getter(name="authenticationConfig")
    def authentication_config(self) -> Optional[_builtins.str]:
        """
        Reference to the BackendAuthenticationConfig resource from the networksecurity.googleapis.com namespace.
        Can be used in authenticating TLS connections to the backend, as specified by the authenticationMode field.
        Can only be specified if authenticationMode is not NONE.
        """
        return pulumi.get(self, "authentication_config")

    @_builtins.property
    @pulumi.getter
    def sni(self) -> Optional[_builtins.str]:
        """
        Server Name Indication - see RFC3546 section 3.1. If set, the load balancer sends this string as the SNI hostname in the
        TLS connection to the backend, and requires that this string match a Subject Alternative Name (SAN) in the backend's
        server certificate. With a Regional Internet NEG backend, if the SNI is specified here, the load balancer uses it
        regardless of whether the Regional Internet NEG is specified with FQDN or IP address and port.
        """
        return pulumi.get(self, "sni")

    @_builtins.property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[Sequence['outputs.BackendServiceTlsSettingsSubjectAltName']]:
        """
        A list of Subject Alternative Names (SANs) that the Load Balancer verifies during a TLS handshake with the backend.
        When the server presents its X.509 certificate to the Load Balancer, the Load Balancer inspects the certificate's SAN field,
        and requires that at least one SAN match one of the subjectAltNames in the list. This field is limited to 5 entries.
        When both sni and subjectAltNames are specified, the load balancer matches the backend certificate's SAN only to
        subjectAltNames.
        Structure is documented below.
        """
        return pulumi.get(self, "subject_alt_names")


@pulumi.output_type
class BackendServiceTlsSettingsSubjectAltName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "uniformResourceIdentifier":
            suggest = "uniform_resource_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceTlsSettingsSubjectAltName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceTlsSettingsSubjectAltName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceTlsSettingsSubjectAltName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[_builtins.str] = None,
                 uniform_resource_identifier: Optional[_builtins.str] = None):
        """
        :param _builtins.str dns_name: The SAN specified as a DNS Name.
        :param _builtins.str uniform_resource_identifier: The SAN specified as a URI.
        """
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if uniform_resource_identifier is not None:
            pulumi.set(__self__, "uniform_resource_identifier", uniform_resource_identifier)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[_builtins.str]:
        """
        The SAN specified as a DNS Name.
        """
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="uniformResourceIdentifier")
    def uniform_resource_identifier(self) -> Optional[_builtins.str]:
        """
        The SAN specified as a URI.
        """
        return pulumi.get(self, "uniform_resource_identifier")


@pulumi.output_type
class DiskAsyncPrimaryDisk(dict):
    def __init__(__self__, *,
                 disk: _builtins.str):
        """
        :param _builtins.str disk: Primary disk for asynchronous disk replication.
        """
        pulumi.set(__self__, "disk", disk)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> _builtins.str:
        """
        Primary disk for asynchronous disk replication.
        """
        return pulumi.get(self, "disk")


@pulumi.output_type
class DiskAsyncReplicationSecondaryDisk(dict):
    def __init__(__self__, *,
                 disk: _builtins.str,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str disk: The secondary disk.
        :param _builtins.str state: Output-only. Status of replication on the secondary disk.
               
               - - -
        """
        pulumi.set(__self__, "disk", disk)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> _builtins.str:
        """
        The secondary disk.
        """
        return pulumi.get(self, "disk")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Output-only. Status of replication on the secondary disk.

        - - -
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DiskDiskEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskDiskEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskDiskEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskDiskEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
               `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param _builtins.str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
               customer-supplied encryption key to either encrypt or decrypt
               this resource. You can provide either the rawKey or the rsaEncryptedKey.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str sha256: (Output)
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
        `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
        customer-supplied encryption key to either encrypt or decrypt
        this resource. You can provide either the rawKey or the rsaEncryptedKey.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        (Output)
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class DiskGuestOsFeature(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DiskIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class DiskIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class DiskParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the disk. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456.
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource manager tags to be bound to the disk. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class DiskSourceImageEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskSourceImageEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskSourceImageEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskSourceImageEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
               `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param _builtins.str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param _builtins.str sha256: (Output)
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
        `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        (Output)
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class DiskSourceSnapshotEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskSourceSnapshotEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskSourceSnapshotEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskSourceSnapshotEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
               `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param _builtins.str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param _builtins.str sha256: (Output)
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
        `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        (Output)
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class ExternalVpnGatewayInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipv6Address":
            suggest = "ipv6_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalVpnGatewayInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalVpnGatewayInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalVpnGatewayInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.int] = None,
                 ip_address: Optional[_builtins.str] = None,
                 ipv6_address: Optional[_builtins.str] = None):
        """
        :param _builtins.int id: The numeric ID for this interface. Allowed values are based on the redundancy type
               of this external VPN gateway
               * `0 - SINGLE_IP_INTERNALLY_REDUNDANT`
               * `0, 1 - TWO_IPS_REDUNDANCY`
               * `0, 1, 2, 3 - FOUR_IPS_REDUNDANCY`
        :param _builtins.str ip_address: IP address of the interface in the external VPN gateway.
               Only IPv4 is supported. This IP address can be either from
               your on-premise gateway or another Cloud provider's VPN gateway,
               it cannot be an IP address from Google Compute Engine.
        :param _builtins.str ipv6_address: IPv6 address of the interface in the external VPN gateway. This IPv6
               address can be either from your on-premise gateway or another Cloud
               provider's VPN gateway, it cannot be an IP address from Google Compute
               Engine. Must specify an IPv6 address (not IPV4-mapped) using any format
               described in RFC 4291 (e.g. 2001:db8:0:0:2d9:51:0:0). The output format
               is RFC 5952 format (e.g. 2001:db8::2d9:51:0:0).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        The numeric ID for this interface. Allowed values are based on the redundancy type
        of this external VPN gateway
        * `0 - SINGLE_IP_INTERNALLY_REDUNDANT`
        * `0, 1 - TWO_IPS_REDUNDANCY`
        * `0, 1, 2, 3 - FOUR_IPS_REDUNDANCY`
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        """
        IP address of the interface in the external VPN gateway.
        Only IPv4 is supported. This IP address can be either from
        your on-premise gateway or another Cloud provider's VPN gateway,
        it cannot be an IP address from Google Compute Engine.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[_builtins.str]:
        """
        IPv6 address of the interface in the external VPN gateway. This IPv6
        address can be either from your on-premise gateway or another Cloud
        provider's VPN gateway, it cannot be an IP address from Google Compute
        Engine. Must specify an IPv6 address (not IPV4-mapped) using any format
        described in RFC 4291 (e.g. 2001:db8:0:0:2d9:51:0:0). The output format
        is RFC 5952 format (e.g. 2001:db8::2d9:51:0:0).
        """
        return pulumi.get(self, "ipv6_address")


@pulumi.output_type
class FirewallAllow(dict):
    def __init__(__self__, *,
                 protocol: _builtins.str,
                 ports: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str protocol: The IP protocol to which this rule applies. The protocol type is
               required when creating a firewall rule. This value can either be
               one of the following well known protocol strings (tcp, udp,
               icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
        :param Sequence[_builtins.str] ports: An optional list of ports to which this rule applies. This field
               is only applicable for UDP or TCP protocol. Each entry must be
               either an integer or a range. If not specified, this rule
               applies to connections through any port.
               Example inputs include: [22], [80, 443], and
               ["12345-12349"].
        """
        pulumi.set(__self__, "protocol", protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The IP protocol to which this rule applies. The protocol type is
        required when creating a firewall rule. This value can either be
        one of the following well known protocol strings (tcp, udp,
        icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.
        Example inputs include: [22], [80, 443], and
        ["12345-12349"].
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class FirewallDeny(dict):
    def __init__(__self__, *,
                 protocol: _builtins.str,
                 ports: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str protocol: The IP protocol to which this rule applies. The protocol type is
               required when creating a firewall rule. This value can either be
               one of the following well known protocol strings (tcp, udp,
               icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
        :param Sequence[_builtins.str] ports: An optional list of ports to which this rule applies. This field
               is only applicable for UDP or TCP protocol. Each entry must be
               either an integer or a range. If not specified, this rule
               applies to connections through any port.
               Example inputs include: [22], [80, 443], and
               ["12345-12349"].
        """
        pulumi.set(__self__, "protocol", protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The IP protocol to which this rule applies. The protocol type is
        required when creating a firewall rule. This value can either be
        one of the following well known protocol strings (tcp, udp,
        icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.
        Example inputs include: [22], [80, 443], and
        ["12345-12349"].
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class FirewallLogConfig(dict):
    def __init__(__self__, *,
                 metadata: _builtins.str):
        """
        :param _builtins.str metadata: This field denotes whether to include or exclude metadata for firewall logs.
               Possible values are: `EXCLUDE_ALL_METADATA`, `INCLUDE_ALL_METADATA`.
        """
        pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> _builtins.str:
        """
        This field denotes whether to include or exclude metadata for firewall logs.
        Possible values are: `EXCLUDE_ALL_METADATA`, `INCLUDE_ALL_METADATA`.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class FirewallParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the firewall. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456. The field is ignored when empty.
               The field is immutable and causes resource replacement when mutated. This field is only
               set at create time and modifying this field after creation will trigger recreation.
               To apply tags to an existing resource, see the tags.TagBinding resource.
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource manager tags to be bound to the firewall. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456. The field is ignored when empty.
        The field is immutable and causes resource replacement when mutated. This field is only
        set at create time and modifying this field after creation will trigger recreation.
        To apply tags to an existing resource, see the tags.TagBinding resource.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class FirewallPolicyRuleMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layer4Configs":
            suggest = "layer4_configs"
        elif key == "destAddressGroups":
            suggest = "dest_address_groups"
        elif key == "destFqdns":
            suggest = "dest_fqdns"
        elif key == "destIpRanges":
            suggest = "dest_ip_ranges"
        elif key == "destNetworkScope":
            suggest = "dest_network_scope"
        elif key == "destRegionCodes":
            suggest = "dest_region_codes"
        elif key == "destThreatIntelligences":
            suggest = "dest_threat_intelligences"
        elif key == "srcAddressGroups":
            suggest = "src_address_groups"
        elif key == "srcFqdns":
            suggest = "src_fqdns"
        elif key == "srcIpRanges":
            suggest = "src_ip_ranges"
        elif key == "srcNetworkScope":
            suggest = "src_network_scope"
        elif key == "srcNetworks":
            suggest = "src_networks"
        elif key == "srcRegionCodes":
            suggest = "src_region_codes"
        elif key == "srcSecureTags":
            suggest = "src_secure_tags"
        elif key == "srcThreatIntelligences":
            suggest = "src_threat_intelligences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyRuleMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyRuleMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyRuleMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layer4_configs: Sequence['outputs.FirewallPolicyRuleMatchLayer4Config'],
                 dest_address_groups: Optional[Sequence[_builtins.str]] = None,
                 dest_fqdns: Optional[Sequence[_builtins.str]] = None,
                 dest_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 dest_network_scope: Optional[_builtins.str] = None,
                 dest_region_codes: Optional[Sequence[_builtins.str]] = None,
                 dest_threat_intelligences: Optional[Sequence[_builtins.str]] = None,
                 src_address_groups: Optional[Sequence[_builtins.str]] = None,
                 src_fqdns: Optional[Sequence[_builtins.str]] = None,
                 src_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 src_network_scope: Optional[_builtins.str] = None,
                 src_networks: Optional[Sequence[_builtins.str]] = None,
                 src_region_codes: Optional[Sequence[_builtins.str]] = None,
                 src_secure_tags: Optional[Sequence['outputs.FirewallPolicyRuleMatchSrcSecureTag']] = None,
                 src_threat_intelligences: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['FirewallPolicyRuleMatchLayer4ConfigArgs'] layer4_configs: Pairs of IP protocols and ports that the rule should match.
               Structure is documented below.
        :param Sequence[_builtins.str] dest_address_groups: Address groups which should be matched against the traffic destination. Maximum number of destination address groups is 10.
        :param Sequence[_builtins.str] dest_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against traffic destination. Maximum number of destination fqdn allowed is 100.
        :param Sequence[_builtins.str] dest_ip_ranges: CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
        :param _builtins.str dest_network_scope: Network scope of the traffic destination.
               Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        :param Sequence[_builtins.str] dest_region_codes: Region codes whose IP addresses will be used to match for destination of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of dest region codes allowed is 5000.
        :param Sequence[_builtins.str] dest_threat_intelligences: Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic destination.
        :param Sequence[_builtins.str] src_address_groups: Address groups which should be matched against the traffic source. Maximum number of source address groups is 10.
        :param Sequence[_builtins.str] src_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against traffic source. Maximum number of source fqdn allowed is 100.
        :param Sequence[_builtins.str] src_ip_ranges: CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
        :param _builtins.str src_network_scope: Network scope of the traffic source.
               Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        :param Sequence[_builtins.str] src_networks: Networks of the traffic source. It can be either a full or partial url.
        :param Sequence[_builtins.str] src_region_codes: Region codes whose IP addresses will be used to match for source of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of source region codes allowed is 5000.
        :param Sequence['FirewallPolicyRuleMatchSrcSecureTagArgs'] src_secure_tags: List of secure tag values, which should be matched at the source of the traffic. For INGRESS rule, if all the srcSecureTag are INEFFECTIVE, and there is no srcIpRange, this rule will be ignored. Maximum number of source tag values allowed is 256.
               Structure is documented below.
               
               
               <a name="nested_match_layer4_configs"></a>The `layer4_configs` block supports:
        :param Sequence[_builtins.str] src_threat_intelligences: Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic source.
        """
        pulumi.set(__self__, "layer4_configs", layer4_configs)
        if dest_address_groups is not None:
            pulumi.set(__self__, "dest_address_groups", dest_address_groups)
        if dest_fqdns is not None:
            pulumi.set(__self__, "dest_fqdns", dest_fqdns)
        if dest_ip_ranges is not None:
            pulumi.set(__self__, "dest_ip_ranges", dest_ip_ranges)
        if dest_network_scope is not None:
            pulumi.set(__self__, "dest_network_scope", dest_network_scope)
        if dest_region_codes is not None:
            pulumi.set(__self__, "dest_region_codes", dest_region_codes)
        if dest_threat_intelligences is not None:
            pulumi.set(__self__, "dest_threat_intelligences", dest_threat_intelligences)
        if src_address_groups is not None:
            pulumi.set(__self__, "src_address_groups", src_address_groups)
        if src_fqdns is not None:
            pulumi.set(__self__, "src_fqdns", src_fqdns)
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)
        if src_network_scope is not None:
            pulumi.set(__self__, "src_network_scope", src_network_scope)
        if src_networks is not None:
            pulumi.set(__self__, "src_networks", src_networks)
        if src_region_codes is not None:
            pulumi.set(__self__, "src_region_codes", src_region_codes)
        if src_secure_tags is not None:
            pulumi.set(__self__, "src_secure_tags", src_secure_tags)
        if src_threat_intelligences is not None:
            pulumi.set(__self__, "src_threat_intelligences", src_threat_intelligences)

    @_builtins.property
    @pulumi.getter(name="layer4Configs")
    def layer4_configs(self) -> Sequence['outputs.FirewallPolicyRuleMatchLayer4Config']:
        """
        Pairs of IP protocols and ports that the rule should match.
        Structure is documented below.
        """
        return pulumi.get(self, "layer4_configs")

    @_builtins.property
    @pulumi.getter(name="destAddressGroups")
    def dest_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic destination. Maximum number of destination address groups is 10.
        """
        return pulumi.get(self, "dest_address_groups")

    @_builtins.property
    @pulumi.getter(name="destFqdns")
    def dest_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against traffic destination. Maximum number of destination fqdn allowed is 100.
        """
        return pulumi.get(self, "dest_fqdns")

    @_builtins.property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
        """
        return pulumi.get(self, "dest_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="destNetworkScope")
    def dest_network_scope(self) -> Optional[_builtins.str]:
        """
        Network scope of the traffic destination.
        Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        """
        return pulumi.get(self, "dest_network_scope")

    @_builtins.property
    @pulumi.getter(name="destRegionCodes")
    def dest_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for destination of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of dest region codes allowed is 5000.
        """
        return pulumi.get(self, "dest_region_codes")

    @_builtins.property
    @pulumi.getter(name="destThreatIntelligences")
    def dest_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic destination.
        """
        return pulumi.get(self, "dest_threat_intelligences")

    @_builtins.property
    @pulumi.getter(name="srcAddressGroups")
    def src_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic source. Maximum number of source address groups is 10.
        """
        return pulumi.get(self, "src_address_groups")

    @_builtins.property
    @pulumi.getter(name="srcFqdns")
    def src_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against traffic source. Maximum number of source fqdn allowed is 100.
        """
        return pulumi.get(self, "src_fqdns")

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
        """
        return pulumi.get(self, "src_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="srcNetworkScope")
    def src_network_scope(self) -> Optional[_builtins.str]:
        """
        Network scope of the traffic source.
        Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        """
        return pulumi.get(self, "src_network_scope")

    @_builtins.property
    @pulumi.getter(name="srcNetworks")
    def src_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Networks of the traffic source. It can be either a full or partial url.
        """
        return pulumi.get(self, "src_networks")

    @_builtins.property
    @pulumi.getter(name="srcRegionCodes")
    def src_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for source of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of source region codes allowed is 5000.
        """
        return pulumi.get(self, "src_region_codes")

    @_builtins.property
    @pulumi.getter(name="srcSecureTags")
    def src_secure_tags(self) -> Optional[Sequence['outputs.FirewallPolicyRuleMatchSrcSecureTag']]:
        """
        List of secure tag values, which should be matched at the source of the traffic. For INGRESS rule, if all the srcSecureTag are INEFFECTIVE, and there is no srcIpRange, this rule will be ignored. Maximum number of source tag values allowed is 256.
        Structure is documented below.


        <a name="nested_match_layer4_configs"></a>The `layer4_configs` block supports:
        """
        return pulumi.get(self, "src_secure_tags")

    @_builtins.property
    @pulumi.getter(name="srcThreatIntelligences")
    def src_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic source.
        """
        return pulumi.get(self, "src_threat_intelligences")


@pulumi.output_type
class FirewallPolicyRuleMatchLayer4Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyRuleMatchLayer4Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyRuleMatchLayer4Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyRuleMatchLayer4Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: _builtins.str,
                 ports: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str ip_protocol: The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule.
               This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
        :param Sequence[_builtins.str] ports: An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> _builtins.str:
        """
        The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule.
        This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
        """
        return pulumi.get(self, "ip_protocol")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class FirewallPolicyRuleMatchSrcSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
        :param _builtins.str state: (Output)
               State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class FirewallPolicyRuleTargetSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
        :param _builtins.str state: (Output)
               State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class FirewallPolicyWithRulesPredefinedRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableLogging":
            suggest = "enable_logging"
        elif key == "ruleName":
            suggest = "rule_name"
        elif key == "securityProfileGroup":
            suggest = "security_profile_group"
        elif key == "targetResources":
            suggest = "target_resources"
        elif key == "targetSecureTags":
            suggest = "target_secure_tags"
        elif key == "targetServiceAccounts":
            suggest = "target_service_accounts"
        elif key == "tlsInspect":
            suggest = "tls_inspect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyWithRulesPredefinedRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyWithRulesPredefinedRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyWithRulesPredefinedRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 enable_logging: Optional[_builtins.bool] = None,
                 matches: Optional[Sequence['outputs.FirewallPolicyWithRulesPredefinedRuleMatch']] = None,
                 priority: Optional[_builtins.int] = None,
                 rule_name: Optional[_builtins.str] = None,
                 security_profile_group: Optional[_builtins.str] = None,
                 target_resources: Optional[Sequence[_builtins.str]] = None,
                 target_secure_tags: Optional[Sequence['outputs.FirewallPolicyWithRulesPredefinedRuleTargetSecureTag']] = None,
                 target_service_accounts: Optional[Sequence[_builtins.str]] = None,
                 tls_inspect: Optional[_builtins.bool] = None):
        """
        :param _builtins.str action: (Output)
               The Action to perform when the client connection triggers the rule. Can currently be either
               "allow", "deny", "apply_security_profile_group" or "goto_next".
        :param _builtins.str description: An optional description of this resource.
        :param _builtins.str direction: (Output)
               The direction in which this rule applies. If unspecified an INGRESS rule is created.
        :param _builtins.bool disabled: (Output)
               Denotes whether the firewall policy rule is disabled. When set to true,
               the firewall policy rule is not enforced and traffic behaves as if it did
               not exist. If this is unspecified, the firewall policy rule will be
               enabled.
        :param _builtins.bool enable_logging: (Output)
               Denotes whether to enable logging for a particular rule.
               If logging is enabled, logs will be exported to the
               configured export destination in Stackdriver.
        :param Sequence['FirewallPolicyWithRulesPredefinedRuleMatchArgs'] matches: (Output)
               A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
               Structure is documented below.
        :param _builtins.int priority: (Output)
               An integer indicating the priority of a rule in the list. The priority must be a value
               between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
               highest priority and 2147483647 is the lowest priority.
        :param _builtins.str rule_name: (Output)
               An optional name for the rule. This field is not a unique identifier
               and can be updated.
        :param _builtins.str security_profile_group: (Output)
               A fully-qualified URL of a SecurityProfile resource instance.
               Example:
               https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
               Must be specified if action is 'apply_security_profile_group'.
        :param Sequence[_builtins.str] target_resources: (Output)
               A list of network resource URLs to which this rule applies.
               This field allows you to control which network's VMs get
               this rule. If this field is left blank, all VMs
               within the organization will receive the rule.
        :param Sequence['FirewallPolicyWithRulesPredefinedRuleTargetSecureTagArgs'] target_secure_tags: (Output)
               A list of secure tags that controls which instances the firewall rule
               applies to. If <code>targetSecureTag</code> are specified, then the
               firewall rule applies only to instances in the VPC network that have one
               of those EFFECTIVE secure tags, if all the target_secure_tag are in
               INEFFECTIVE state, then this rule will be ignored.
               <code>targetSecureTag</code> may not be set at the same time as
               <code>targetServiceAccounts</code>.
               If neither <code>targetServiceAccounts</code> nor
               <code>targetSecureTag</code> are specified, the firewall rule applies
               to all instances on the specified network.
               Maximum number of target secure tags allowed is 256.
               Structure is documented below.
        :param Sequence[_builtins.str] target_service_accounts: (Output)
               A list of service accounts indicating the sets of
               instances that are applied with this rule.
        :param _builtins.bool tls_inspect: (Output)
               Boolean flag indicating if the traffic should be TLS decrypted.
               It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)
        if security_profile_group is not None:
            pulumi.set(__self__, "security_profile_group", security_profile_group)
        if target_resources is not None:
            pulumi.set(__self__, "target_resources", target_resources)
        if target_secure_tags is not None:
            pulumi.set(__self__, "target_secure_tags", target_secure_tags)
        if target_service_accounts is not None:
            pulumi.set(__self__, "target_service_accounts", target_service_accounts)
        if tls_inspect is not None:
            pulumi.set(__self__, "tls_inspect", tls_inspect)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Action to perform when the client connection triggers the rule. Can currently be either
        "allow", "deny", "apply_security_profile_group" or "goto_next".
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        (Output)
        The direction in which this rule applies. If unspecified an INGRESS rule is created.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Denotes whether the firewall policy rule is disabled. When set to true,
        the firewall policy rule is not enforced and traffic behaves as if it did
        not exist. If this is unspecified, the firewall policy rule will be
        enabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Denotes whether to enable logging for a particular rule.
        If logging is enabled, logs will be exported to the
        configured export destination in Stackdriver.
        """
        return pulumi.get(self, "enable_logging")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.FirewallPolicyWithRulesPredefinedRuleMatch']]:
        """
        (Output)
        A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
        Structure is documented below.
        """
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        (Output)
        An integer indicating the priority of a rule in the list. The priority must be a value
        between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
        highest priority and 2147483647 is the lowest priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        An optional name for the rule. This field is not a unique identifier
        and can be updated.
        """
        return pulumi.get(self, "rule_name")

    @_builtins.property
    @pulumi.getter(name="securityProfileGroup")
    def security_profile_group(self) -> Optional[_builtins.str]:
        """
        (Output)
        A fully-qualified URL of a SecurityProfile resource instance.
        Example:
        https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
        Must be specified if action is 'apply_security_profile_group'.
        """
        return pulumi.get(self, "security_profile_group")

    @_builtins.property
    @pulumi.getter(name="targetResources")
    def target_resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        A list of network resource URLs to which this rule applies.
        This field allows you to control which network's VMs get
        this rule. If this field is left blank, all VMs
        within the organization will receive the rule.
        """
        return pulumi.get(self, "target_resources")

    @_builtins.property
    @pulumi.getter(name="targetSecureTags")
    def target_secure_tags(self) -> Optional[Sequence['outputs.FirewallPolicyWithRulesPredefinedRuleTargetSecureTag']]:
        """
        (Output)
        A list of secure tags that controls which instances the firewall rule
        applies to. If <code>targetSecureTag</code> are specified, then the
        firewall rule applies only to instances in the VPC network that have one
        of those EFFECTIVE secure tags, if all the target_secure_tag are in
        INEFFECTIVE state, then this rule will be ignored.
        <code>targetSecureTag</code> may not be set at the same time as
        <code>targetServiceAccounts</code>.
        If neither <code>targetServiceAccounts</code> nor
        <code>targetSecureTag</code> are specified, the firewall rule applies
        to all instances on the specified network.
        Maximum number of target secure tags allowed is 256.
        Structure is documented below.
        """
        return pulumi.get(self, "target_secure_tags")

    @_builtins.property
    @pulumi.getter(name="targetServiceAccounts")
    def target_service_accounts(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        A list of service accounts indicating the sets of
        instances that are applied with this rule.
        """
        return pulumi.get(self, "target_service_accounts")

    @_builtins.property
    @pulumi.getter(name="tlsInspect")
    def tls_inspect(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Boolean flag indicating if the traffic should be TLS decrypted.
        It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
        """
        return pulumi.get(self, "tls_inspect")


@pulumi.output_type
class FirewallPolicyWithRulesPredefinedRuleMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destAddressGroups":
            suggest = "dest_address_groups"
        elif key == "destFqdns":
            suggest = "dest_fqdns"
        elif key == "destIpRanges":
            suggest = "dest_ip_ranges"
        elif key == "destRegionCodes":
            suggest = "dest_region_codes"
        elif key == "destThreatIntelligences":
            suggest = "dest_threat_intelligences"
        elif key == "layer4Configs":
            suggest = "layer4_configs"
        elif key == "srcAddressGroups":
            suggest = "src_address_groups"
        elif key == "srcFqdns":
            suggest = "src_fqdns"
        elif key == "srcIpRanges":
            suggest = "src_ip_ranges"
        elif key == "srcRegionCodes":
            suggest = "src_region_codes"
        elif key == "srcSecureTags":
            suggest = "src_secure_tags"
        elif key == "srcThreatIntelligences":
            suggest = "src_threat_intelligences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyWithRulesPredefinedRuleMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyWithRulesPredefinedRuleMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyWithRulesPredefinedRuleMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dest_address_groups: Optional[Sequence[_builtins.str]] = None,
                 dest_fqdns: Optional[Sequence[_builtins.str]] = None,
                 dest_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 dest_region_codes: Optional[Sequence[_builtins.str]] = None,
                 dest_threat_intelligences: Optional[Sequence[_builtins.str]] = None,
                 layer4_configs: Optional[Sequence['outputs.FirewallPolicyWithRulesPredefinedRuleMatchLayer4Config']] = None,
                 src_address_groups: Optional[Sequence[_builtins.str]] = None,
                 src_fqdns: Optional[Sequence[_builtins.str]] = None,
                 src_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 src_region_codes: Optional[Sequence[_builtins.str]] = None,
                 src_secure_tags: Optional[Sequence['outputs.FirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag']] = None,
                 src_threat_intelligences: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] dest_address_groups: Address groups which should be matched against the traffic destination.
               Maximum number of destination address groups is 10.
        :param Sequence[_builtins.str] dest_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against
               traffic destination. Maximum number of destination fqdn allowed is 100.
        :param Sequence[_builtins.str] dest_ip_ranges: Destination IP address range in CIDR format. Required for
               EGRESS rules.
        :param Sequence[_builtins.str] dest_region_codes: Region codes whose IP addresses will be used to match for destination
               of traffic. Should be specified as 2 letter country code defined as per
               ISO 3166 alpha-2 country codes. ex."US"
               Maximum number of destination region codes allowed is 5000.
        :param Sequence[_builtins.str] dest_threat_intelligences: Names of Network Threat Intelligence lists.
               The IPs in these lists will be matched against traffic destination.
        :param Sequence['FirewallPolicyWithRulesPredefinedRuleMatchLayer4ConfigArgs'] layer4_configs: Pairs of IP protocols and ports that the rule should match.
               Structure is documented below.
        :param Sequence[_builtins.str] src_address_groups: Address groups which should be matched against the traffic source.
               Maximum number of source address groups is 10.
        :param Sequence[_builtins.str] src_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against
               traffic source. Maximum number of source fqdn allowed is 100.
        :param Sequence[_builtins.str] src_ip_ranges: Source IP address range in CIDR format. Required for
               INGRESS rules.
        :param Sequence[_builtins.str] src_region_codes: Region codes whose IP addresses will be used to match for source
               of traffic. Should be specified as 2 letter country code defined as per
               ISO 3166 alpha-2 country codes. ex."US"
               Maximum number of source region codes allowed is 5000.
        :param Sequence['FirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTagArgs'] src_secure_tags: List of secure tag values, which should be matched at the source
               of the traffic.
               For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
               and there is no <code>srcIpRange</code>, this rule will be ignored.
               Maximum number of source tag values allowed is 256.
               Structure is documented below.
        :param Sequence[_builtins.str] src_threat_intelligences: Names of Network Threat Intelligence lists.
               The IPs in these lists will be matched against traffic source.
        """
        if dest_address_groups is not None:
            pulumi.set(__self__, "dest_address_groups", dest_address_groups)
        if dest_fqdns is not None:
            pulumi.set(__self__, "dest_fqdns", dest_fqdns)
        if dest_ip_ranges is not None:
            pulumi.set(__self__, "dest_ip_ranges", dest_ip_ranges)
        if dest_region_codes is not None:
            pulumi.set(__self__, "dest_region_codes", dest_region_codes)
        if dest_threat_intelligences is not None:
            pulumi.set(__self__, "dest_threat_intelligences", dest_threat_intelligences)
        if layer4_configs is not None:
            pulumi.set(__self__, "layer4_configs", layer4_configs)
        if src_address_groups is not None:
            pulumi.set(__self__, "src_address_groups", src_address_groups)
        if src_fqdns is not None:
            pulumi.set(__self__, "src_fqdns", src_fqdns)
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)
        if src_region_codes is not None:
            pulumi.set(__self__, "src_region_codes", src_region_codes)
        if src_secure_tags is not None:
            pulumi.set(__self__, "src_secure_tags", src_secure_tags)
        if src_threat_intelligences is not None:
            pulumi.set(__self__, "src_threat_intelligences", src_threat_intelligences)

    @_builtins.property
    @pulumi.getter(name="destAddressGroups")
    def dest_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic destination.
        Maximum number of destination address groups is 10.
        """
        return pulumi.get(self, "dest_address_groups")

    @_builtins.property
    @pulumi.getter(name="destFqdns")
    def dest_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against
        traffic destination. Maximum number of destination fqdn allowed is 100.
        """
        return pulumi.get(self, "dest_fqdns")

    @_builtins.property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Destination IP address range in CIDR format. Required for
        EGRESS rules.
        """
        return pulumi.get(self, "dest_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="destRegionCodes")
    def dest_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for destination
        of traffic. Should be specified as 2 letter country code defined as per
        ISO 3166 alpha-2 country codes. ex."US"
        Maximum number of destination region codes allowed is 5000.
        """
        return pulumi.get(self, "dest_region_codes")

    @_builtins.property
    @pulumi.getter(name="destThreatIntelligences")
    def dest_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists.
        The IPs in these lists will be matched against traffic destination.
        """
        return pulumi.get(self, "dest_threat_intelligences")

    @_builtins.property
    @pulumi.getter(name="layer4Configs")
    def layer4_configs(self) -> Optional[Sequence['outputs.FirewallPolicyWithRulesPredefinedRuleMatchLayer4Config']]:
        """
        Pairs of IP protocols and ports that the rule should match.
        Structure is documented below.
        """
        return pulumi.get(self, "layer4_configs")

    @_builtins.property
    @pulumi.getter(name="srcAddressGroups")
    def src_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic source.
        Maximum number of source address groups is 10.
        """
        return pulumi.get(self, "src_address_groups")

    @_builtins.property
    @pulumi.getter(name="srcFqdns")
    def src_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against
        traffic source. Maximum number of source fqdn allowed is 100.
        """
        return pulumi.get(self, "src_fqdns")

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Source IP address range in CIDR format. Required for
        INGRESS rules.
        """
        return pulumi.get(self, "src_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="srcRegionCodes")
    def src_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for source
        of traffic. Should be specified as 2 letter country code defined as per
        ISO 3166 alpha-2 country codes. ex."US"
        Maximum number of source region codes allowed is 5000.
        """
        return pulumi.get(self, "src_region_codes")

    @_builtins.property
    @pulumi.getter(name="srcSecureTags")
    def src_secure_tags(self) -> Optional[Sequence['outputs.FirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag']]:
        """
        List of secure tag values, which should be matched at the source
        of the traffic.
        For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
        and there is no <code>srcIpRange</code>, this rule will be ignored.
        Maximum number of source tag values allowed is 256.
        Structure is documented below.
        """
        return pulumi.get(self, "src_secure_tags")

    @_builtins.property
    @pulumi.getter(name="srcThreatIntelligences")
    def src_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists.
        The IPs in these lists will be matched against traffic source.
        """
        return pulumi.get(self, "src_threat_intelligences")


@pulumi.output_type
class FirewallPolicyWithRulesPredefinedRuleMatchLayer4Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyWithRulesPredefinedRuleMatchLayer4Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyWithRulesPredefinedRuleMatchLayer4Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyWithRulesPredefinedRuleMatchLayer4Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: Optional[_builtins.str] = None,
                 ports: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str ip_protocol: (Output)
               The IP protocol to which this rule applies. The protocol
               type is required when creating a firewall rule.
               This value can either be one of the following well
               known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
               or the IP protocol number.
        :param Sequence[_builtins.str] ports: (Output)
               An optional list of ports to which this rule applies. This field
               is only applicable for UDP or TCP protocol. Each entry must be
               either an integer or a range. If not specified, this rule
               applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and
               ["12345-12349"].
        """
        if ip_protocol is not None:
            pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> Optional[_builtins.str]:
        """
        (Output)
        The IP protocol to which this rule applies. The protocol
        type is required when creating a firewall rule.
        This value can either be one of the following well
        known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
        or the IP protocol number.
        """
        return pulumi.get(self, "ip_protocol")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and
        ["12345-12349"].
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class FirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
               @pattern tagValues/[0-9]+
        :param _builtins.str state: (Output)
               [Output Only] State of the secure tag, either `EFFECTIVE` or
               `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
               or its network is deleted.
               
               <a name="nested_rule_rule_match_layer4_config"></a>The `layer4_config` block supports:
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        @pattern tagValues/[0-9]+
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        [Output Only] State of the secure tag, either `EFFECTIVE` or
        `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
        or its network is deleted.

        <a name="nested_rule_rule_match_layer4_config"></a>The `layer4_config` block supports:
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class FirewallPolicyWithRulesPredefinedRuleTargetSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
               @pattern tagValues/[0-9]+
        :param _builtins.str state: (Output)
               [Output Only] State of the secure tag, either `EFFECTIVE` or
               `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
               or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        @pattern tagValues/[0-9]+
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        [Output Only] State of the secure tag, either `EFFECTIVE` or
        `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
        or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class FirewallPolicyWithRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableLogging":
            suggest = "enable_logging"
        elif key == "ruleName":
            suggest = "rule_name"
        elif key == "securityProfileGroup":
            suggest = "security_profile_group"
        elif key == "targetResources":
            suggest = "target_resources"
        elif key == "targetSecureTags":
            suggest = "target_secure_tags"
        elif key == "targetServiceAccounts":
            suggest = "target_service_accounts"
        elif key == "tlsInspect":
            suggest = "tls_inspect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyWithRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyWithRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyWithRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 match: 'outputs.FirewallPolicyWithRulesRuleMatch',
                 priority: _builtins.int,
                 description: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 enable_logging: Optional[_builtins.bool] = None,
                 rule_name: Optional[_builtins.str] = None,
                 security_profile_group: Optional[_builtins.str] = None,
                 target_resources: Optional[Sequence[_builtins.str]] = None,
                 target_secure_tags: Optional[Sequence['outputs.FirewallPolicyWithRulesRuleTargetSecureTag']] = None,
                 target_service_accounts: Optional[Sequence[_builtins.str]] = None,
                 tls_inspect: Optional[_builtins.bool] = None):
        """
        :param _builtins.str action: The Action to perform when the client connection triggers the rule. Can currently be either
               "allow", "deny", "apply_security_profile_group" or "goto_next".
        :param 'FirewallPolicyWithRulesRuleMatchArgs' match: A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
               Structure is documented below.
        :param _builtins.int priority: An integer indicating the priority of a rule in the list. The priority must be a value
               between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
               highest priority and 2147483647 is the lowest priority.
        :param _builtins.str description: A description of the rule.
        :param _builtins.str direction: The direction in which this rule applies. If unspecified an INGRESS rule is created.
               Possible values are: `INGRESS`, `EGRESS`.
        :param _builtins.bool disabled: Denotes whether the firewall policy rule is disabled. When set to true,
               the firewall policy rule is not enforced and traffic behaves as if it did
               not exist. If this is unspecified, the firewall policy rule will be
               enabled.
        :param _builtins.bool enable_logging: Denotes whether to enable logging for a particular rule.
               If logging is enabled, logs will be exported to the
               configured export destination in Stackdriver.
        :param _builtins.str rule_name: An optional name for the rule. This field is not a unique identifier
               and can be updated.
        :param _builtins.str security_profile_group: A fully-qualified URL of a SecurityProfile resource instance.
               Example:
               https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
               Must be specified if action is 'apply_security_profile_group'.
        :param Sequence[_builtins.str] target_resources: A list of network resource URLs to which this rule applies.
               This field allows you to control which network's VMs get
               this rule. If this field is left blank, all VMs
               within the organization will receive the rule.
        :param Sequence['FirewallPolicyWithRulesRuleTargetSecureTagArgs'] target_secure_tags: A list of secure tags that controls which instances the firewall rule
               applies to. If <code>targetSecureTag</code> are specified, then the
               firewall rule applies only to instances in the VPC network that have one
               of those EFFECTIVE secure tags, if all the target_secure_tag are in
               INEFFECTIVE state, then this rule will be ignored.
               <code>targetSecureTag</code> may not be set at the same time as
               <code>targetServiceAccounts</code>.
               If neither <code>targetServiceAccounts</code> nor
               <code>targetSecureTag</code> are specified, the firewall rule applies
               to all instances on the specified network.
               Maximum number of target secure tags allowed is 256.
               Structure is documented below.
        :param Sequence[_builtins.str] target_service_accounts: A list of service accounts indicating the sets of
               instances that are applied with this rule.
        :param _builtins.bool tls_inspect: Boolean flag indicating if the traffic should be TLS decrypted.
               It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "priority", priority)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)
        if security_profile_group is not None:
            pulumi.set(__self__, "security_profile_group", security_profile_group)
        if target_resources is not None:
            pulumi.set(__self__, "target_resources", target_resources)
        if target_secure_tags is not None:
            pulumi.set(__self__, "target_secure_tags", target_secure_tags)
        if target_service_accounts is not None:
            pulumi.set(__self__, "target_service_accounts", target_service_accounts)
        if tls_inspect is not None:
            pulumi.set(__self__, "tls_inspect", tls_inspect)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The Action to perform when the client connection triggers the rule. Can currently be either
        "allow", "deny", "apply_security_profile_group" or "goto_next".
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def match(self) -> 'outputs.FirewallPolicyWithRulesRuleMatch':
        """
        A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
        Structure is documented below.
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        An integer indicating the priority of a rule in the list. The priority must be a value
        between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
        highest priority and 2147483647 is the lowest priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of the rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The direction in which this rule applies. If unspecified an INGRESS rule is created.
        Possible values are: `INGRESS`, `EGRESS`.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Denotes whether the firewall policy rule is disabled. When set to true,
        the firewall policy rule is not enforced and traffic behaves as if it did
        not exist. If this is unspecified, the firewall policy rule will be
        enabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[_builtins.bool]:
        """
        Denotes whether to enable logging for a particular rule.
        If logging is enabled, logs will be exported to the
        configured export destination in Stackdriver.
        """
        return pulumi.get(self, "enable_logging")

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[_builtins.str]:
        """
        An optional name for the rule. This field is not a unique identifier
        and can be updated.
        """
        return pulumi.get(self, "rule_name")

    @_builtins.property
    @pulumi.getter(name="securityProfileGroup")
    def security_profile_group(self) -> Optional[_builtins.str]:
        """
        A fully-qualified URL of a SecurityProfile resource instance.
        Example:
        https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
        Must be specified if action is 'apply_security_profile_group'.
        """
        return pulumi.get(self, "security_profile_group")

    @_builtins.property
    @pulumi.getter(name="targetResources")
    def target_resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of network resource URLs to which this rule applies.
        This field allows you to control which network's VMs get
        this rule. If this field is left blank, all VMs
        within the organization will receive the rule.
        """
        return pulumi.get(self, "target_resources")

    @_builtins.property
    @pulumi.getter(name="targetSecureTags")
    def target_secure_tags(self) -> Optional[Sequence['outputs.FirewallPolicyWithRulesRuleTargetSecureTag']]:
        """
        A list of secure tags that controls which instances the firewall rule
        applies to. If <code>targetSecureTag</code> are specified, then the
        firewall rule applies only to instances in the VPC network that have one
        of those EFFECTIVE secure tags, if all the target_secure_tag are in
        INEFFECTIVE state, then this rule will be ignored.
        <code>targetSecureTag</code> may not be set at the same time as
        <code>targetServiceAccounts</code>.
        If neither <code>targetServiceAccounts</code> nor
        <code>targetSecureTag</code> are specified, the firewall rule applies
        to all instances on the specified network.
        Maximum number of target secure tags allowed is 256.
        Structure is documented below.
        """
        return pulumi.get(self, "target_secure_tags")

    @_builtins.property
    @pulumi.getter(name="targetServiceAccounts")
    def target_service_accounts(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of service accounts indicating the sets of
        instances that are applied with this rule.
        """
        return pulumi.get(self, "target_service_accounts")

    @_builtins.property
    @pulumi.getter(name="tlsInspect")
    def tls_inspect(self) -> Optional[_builtins.bool]:
        """
        Boolean flag indicating if the traffic should be TLS decrypted.
        It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
        """
        return pulumi.get(self, "tls_inspect")


@pulumi.output_type
class FirewallPolicyWithRulesRuleMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layer4Configs":
            suggest = "layer4_configs"
        elif key == "destAddressGroups":
            suggest = "dest_address_groups"
        elif key == "destFqdns":
            suggest = "dest_fqdns"
        elif key == "destIpRanges":
            suggest = "dest_ip_ranges"
        elif key == "destNetworkScope":
            suggest = "dest_network_scope"
        elif key == "destRegionCodes":
            suggest = "dest_region_codes"
        elif key == "destThreatIntelligences":
            suggest = "dest_threat_intelligences"
        elif key == "srcAddressGroups":
            suggest = "src_address_groups"
        elif key == "srcFqdns":
            suggest = "src_fqdns"
        elif key == "srcIpRanges":
            suggest = "src_ip_ranges"
        elif key == "srcNetworkScope":
            suggest = "src_network_scope"
        elif key == "srcNetworks":
            suggest = "src_networks"
        elif key == "srcRegionCodes":
            suggest = "src_region_codes"
        elif key == "srcSecureTags":
            suggest = "src_secure_tags"
        elif key == "srcThreatIntelligences":
            suggest = "src_threat_intelligences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyWithRulesRuleMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyWithRulesRuleMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyWithRulesRuleMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layer4_configs: Sequence['outputs.FirewallPolicyWithRulesRuleMatchLayer4Config'],
                 dest_address_groups: Optional[Sequence[_builtins.str]] = None,
                 dest_fqdns: Optional[Sequence[_builtins.str]] = None,
                 dest_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 dest_network_scope: Optional[_builtins.str] = None,
                 dest_region_codes: Optional[Sequence[_builtins.str]] = None,
                 dest_threat_intelligences: Optional[Sequence[_builtins.str]] = None,
                 src_address_groups: Optional[Sequence[_builtins.str]] = None,
                 src_fqdns: Optional[Sequence[_builtins.str]] = None,
                 src_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 src_network_scope: Optional[_builtins.str] = None,
                 src_networks: Optional[Sequence[_builtins.str]] = None,
                 src_region_codes: Optional[Sequence[_builtins.str]] = None,
                 src_secure_tags: Optional[Sequence['outputs.FirewallPolicyWithRulesRuleMatchSrcSecureTag']] = None,
                 src_threat_intelligences: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['FirewallPolicyWithRulesRuleMatchLayer4ConfigArgs'] layer4_configs: Pairs of IP protocols and ports that the rule should match.
               Structure is documented below.
        :param Sequence[_builtins.str] dest_address_groups: Address groups which should be matched against the traffic destination.
               Maximum number of destination address groups is 10.
        :param Sequence[_builtins.str] dest_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against
               traffic destination. Maximum number of destination fqdn allowed is 100.
        :param Sequence[_builtins.str] dest_ip_ranges: Destination IP address range in CIDR format. Required for
               EGRESS rules.
        :param _builtins.str dest_network_scope: Network scope of the traffic destination.
               Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        :param Sequence[_builtins.str] dest_region_codes: Region codes whose IP addresses will be used to match for destination
               of traffic. Should be specified as 2 letter country code defined as per
               ISO 3166 alpha-2 country codes. ex."US"
               Maximum number of destination region codes allowed is 5000.
        :param Sequence[_builtins.str] dest_threat_intelligences: Names of Network Threat Intelligence lists.
               The IPs in these lists will be matched against traffic destination.
        :param Sequence[_builtins.str] src_address_groups: Address groups which should be matched against the traffic source.
               Maximum number of source address groups is 10.
        :param Sequence[_builtins.str] src_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against
               traffic source. Maximum number of source fqdn allowed is 100.
        :param Sequence[_builtins.str] src_ip_ranges: Source IP address range in CIDR format. Required for
               INGRESS rules.
        :param _builtins.str src_network_scope: Network scope of the traffic source.
               Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        :param Sequence[_builtins.str] src_networks: Networks of the traffic source. It can be either a full or partial url.
        :param Sequence[_builtins.str] src_region_codes: Region codes whose IP addresses will be used to match for source
               of traffic. Should be specified as 2 letter country code defined as per
               ISO 3166 alpha-2 country codes. ex."US"
               Maximum number of source region codes allowed is 5000.
        :param Sequence['FirewallPolicyWithRulesRuleMatchSrcSecureTagArgs'] src_secure_tags: List of secure tag values, which should be matched at the source
               of the traffic.
               For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
               and there is no <code>srcIpRange</code>, this rule will be ignored.
               Maximum number of source tag values allowed is 256.
               Structure is documented below.
        :param Sequence[_builtins.str] src_threat_intelligences: Names of Network Threat Intelligence lists.
               The IPs in these lists will be matched against traffic source.
        """
        pulumi.set(__self__, "layer4_configs", layer4_configs)
        if dest_address_groups is not None:
            pulumi.set(__self__, "dest_address_groups", dest_address_groups)
        if dest_fqdns is not None:
            pulumi.set(__self__, "dest_fqdns", dest_fqdns)
        if dest_ip_ranges is not None:
            pulumi.set(__self__, "dest_ip_ranges", dest_ip_ranges)
        if dest_network_scope is not None:
            pulumi.set(__self__, "dest_network_scope", dest_network_scope)
        if dest_region_codes is not None:
            pulumi.set(__self__, "dest_region_codes", dest_region_codes)
        if dest_threat_intelligences is not None:
            pulumi.set(__self__, "dest_threat_intelligences", dest_threat_intelligences)
        if src_address_groups is not None:
            pulumi.set(__self__, "src_address_groups", src_address_groups)
        if src_fqdns is not None:
            pulumi.set(__self__, "src_fqdns", src_fqdns)
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)
        if src_network_scope is not None:
            pulumi.set(__self__, "src_network_scope", src_network_scope)
        if src_networks is not None:
            pulumi.set(__self__, "src_networks", src_networks)
        if src_region_codes is not None:
            pulumi.set(__self__, "src_region_codes", src_region_codes)
        if src_secure_tags is not None:
            pulumi.set(__self__, "src_secure_tags", src_secure_tags)
        if src_threat_intelligences is not None:
            pulumi.set(__self__, "src_threat_intelligences", src_threat_intelligences)

    @_builtins.property
    @pulumi.getter(name="layer4Configs")
    def layer4_configs(self) -> Sequence['outputs.FirewallPolicyWithRulesRuleMatchLayer4Config']:
        """
        Pairs of IP protocols and ports that the rule should match.
        Structure is documented below.
        """
        return pulumi.get(self, "layer4_configs")

    @_builtins.property
    @pulumi.getter(name="destAddressGroups")
    def dest_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic destination.
        Maximum number of destination address groups is 10.
        """
        return pulumi.get(self, "dest_address_groups")

    @_builtins.property
    @pulumi.getter(name="destFqdns")
    def dest_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against
        traffic destination. Maximum number of destination fqdn allowed is 100.
        """
        return pulumi.get(self, "dest_fqdns")

    @_builtins.property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Destination IP address range in CIDR format. Required for
        EGRESS rules.
        """
        return pulumi.get(self, "dest_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="destNetworkScope")
    def dest_network_scope(self) -> Optional[_builtins.str]:
        """
        Network scope of the traffic destination.
        Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        """
        return pulumi.get(self, "dest_network_scope")

    @_builtins.property
    @pulumi.getter(name="destRegionCodes")
    def dest_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for destination
        of traffic. Should be specified as 2 letter country code defined as per
        ISO 3166 alpha-2 country codes. ex."US"
        Maximum number of destination region codes allowed is 5000.
        """
        return pulumi.get(self, "dest_region_codes")

    @_builtins.property
    @pulumi.getter(name="destThreatIntelligences")
    def dest_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists.
        The IPs in these lists will be matched against traffic destination.
        """
        return pulumi.get(self, "dest_threat_intelligences")

    @_builtins.property
    @pulumi.getter(name="srcAddressGroups")
    def src_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic source.
        Maximum number of source address groups is 10.
        """
        return pulumi.get(self, "src_address_groups")

    @_builtins.property
    @pulumi.getter(name="srcFqdns")
    def src_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against
        traffic source. Maximum number of source fqdn allowed is 100.
        """
        return pulumi.get(self, "src_fqdns")

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Source IP address range in CIDR format. Required for
        INGRESS rules.
        """
        return pulumi.get(self, "src_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="srcNetworkScope")
    def src_network_scope(self) -> Optional[_builtins.str]:
        """
        Network scope of the traffic source.
        Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        """
        return pulumi.get(self, "src_network_scope")

    @_builtins.property
    @pulumi.getter(name="srcNetworks")
    def src_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Networks of the traffic source. It can be either a full or partial url.
        """
        return pulumi.get(self, "src_networks")

    @_builtins.property
    @pulumi.getter(name="srcRegionCodes")
    def src_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for source
        of traffic. Should be specified as 2 letter country code defined as per
        ISO 3166 alpha-2 country codes. ex."US"
        Maximum number of source region codes allowed is 5000.
        """
        return pulumi.get(self, "src_region_codes")

    @_builtins.property
    @pulumi.getter(name="srcSecureTags")
    def src_secure_tags(self) -> Optional[Sequence['outputs.FirewallPolicyWithRulesRuleMatchSrcSecureTag']]:
        """
        List of secure tag values, which should be matched at the source
        of the traffic.
        For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
        and there is no <code>srcIpRange</code>, this rule will be ignored.
        Maximum number of source tag values allowed is 256.
        Structure is documented below.
        """
        return pulumi.get(self, "src_secure_tags")

    @_builtins.property
    @pulumi.getter(name="srcThreatIntelligences")
    def src_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists.
        The IPs in these lists will be matched against traffic source.
        """
        return pulumi.get(self, "src_threat_intelligences")


@pulumi.output_type
class FirewallPolicyWithRulesRuleMatchLayer4Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyWithRulesRuleMatchLayer4Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyWithRulesRuleMatchLayer4Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyWithRulesRuleMatchLayer4Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: _builtins.str,
                 ports: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str ip_protocol: (Output)
               The IP protocol to which this rule applies. The protocol
               type is required when creating a firewall rule.
               This value can either be one of the following well
               known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
               or the IP protocol number.
        :param Sequence[_builtins.str] ports: (Output)
               An optional list of ports to which this rule applies. This field
               is only applicable for UDP or TCP protocol. Each entry must be
               either an integer or a range. If not specified, this rule
               applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and
               ["12345-12349"].
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> _builtins.str:
        """
        (Output)
        The IP protocol to which this rule applies. The protocol
        type is required when creating a firewall rule.
        This value can either be one of the following well
        known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
        or the IP protocol number.
        """
        return pulumi.get(self, "ip_protocol")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and
        ["12345-12349"].
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class FirewallPolicyWithRulesRuleMatchSrcSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
               @pattern tagValues/[0-9]+
        :param _builtins.str state: (Output)
               [Output Only] State of the secure tag, either `EFFECTIVE` or
               `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
               or its network is deleted.
               
               <a name="nested_rule_rule_match_layer4_config"></a>The `layer4_config` block supports:
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        @pattern tagValues/[0-9]+
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        [Output Only] State of the secure tag, either `EFFECTIVE` or
        `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
        or its network is deleted.

        <a name="nested_rule_rule_match_layer4_config"></a>The `layer4_config` block supports:
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class FirewallPolicyWithRulesRuleTargetSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
               @pattern tagValues/[0-9]+
        :param _builtins.str state: (Output)
               [Output Only] State of the secure tag, either `EFFECTIVE` or
               `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
               or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        @pattern tagValues/[0-9]+
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        [Output Only] State of the secure tag, either `EFFECTIVE` or
        `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
        or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ForwardingRuleServiceDirectoryRegistrations(dict):
    def __init__(__self__, *,
                 namespace: Optional[_builtins.str] = None,
                 service: Optional[_builtins.str] = None):
        """
        :param _builtins.str namespace: Service Directory namespace to register the forwarding rule under.
        :param _builtins.str service: Service Directory service to register the forwarding rule under.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Service Directory namespace to register the forwarding rule under.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Service Directory service to register the forwarding rule under.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class FutureReservationAggregateReservation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reservedResources":
            suggest = "reserved_resources"
        elif key == "vmFamily":
            suggest = "vm_family"
        elif key == "workloadType":
            suggest = "workload_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationAggregateReservation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationAggregateReservation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationAggregateReservation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reserved_resources: Sequence['outputs.FutureReservationAggregateReservationReservedResource'],
                 vm_family: Optional[_builtins.str] = None,
                 workload_type: Optional[_builtins.str] = None):
        """
        :param Sequence['FutureReservationAggregateReservationReservedResourceArgs'] reserved_resources: futureReservations.list of reserved resources (CPUs, memory, accelerators).
               Structure is documented below.
        :param _builtins.str vm_family: The VM family that all instances scheduled against this reservation must belong to.
               Possible values are: `VM_FAMILY_CLOUD_TPU_DEVICE_CT3`, `VM_FAMILY_CLOUD_TPU_LITE_DEVICE_CT5L`, `VM_FAMILY_CLOUD_TPU_LITE_POD_SLICE_CT5LP`, `VM_FAMILY_CLOUD_TPU_LITE_POD_SLICE_CT6E`, `VM_FAMILY_CLOUD_TPU_POD_SLICE_CT3P`, `VM_FAMILY_CLOUD_TPU_POD_SLICE_CT4P`, `VM_FAMILY_CLOUD_TPU_POD_SLICE_CT5P`.
        :param _builtins.str workload_type: The workload type of the instances that will target this reservation.
               Possible values are: `BATCH`, `SERVING`, `UNSPECIFIED`.
        """
        pulumi.set(__self__, "reserved_resources", reserved_resources)
        if vm_family is not None:
            pulumi.set(__self__, "vm_family", vm_family)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @_builtins.property
    @pulumi.getter(name="reservedResources")
    def reserved_resources(self) -> Sequence['outputs.FutureReservationAggregateReservationReservedResource']:
        """
        futureReservations.list of reserved resources (CPUs, memory, accelerators).
        Structure is documented below.
        """
        return pulumi.get(self, "reserved_resources")

    @_builtins.property
    @pulumi.getter(name="vmFamily")
    def vm_family(self) -> Optional[_builtins.str]:
        """
        The VM family that all instances scheduled against this reservation must belong to.
        Possible values are: `VM_FAMILY_CLOUD_TPU_DEVICE_CT3`, `VM_FAMILY_CLOUD_TPU_LITE_DEVICE_CT5L`, `VM_FAMILY_CLOUD_TPU_LITE_POD_SLICE_CT5LP`, `VM_FAMILY_CLOUD_TPU_LITE_POD_SLICE_CT6E`, `VM_FAMILY_CLOUD_TPU_POD_SLICE_CT3P`, `VM_FAMILY_CLOUD_TPU_POD_SLICE_CT4P`, `VM_FAMILY_CLOUD_TPU_POD_SLICE_CT5P`.
        """
        return pulumi.get(self, "vm_family")

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional[_builtins.str]:
        """
        The workload type of the instances that will target this reservation.
        Possible values are: `BATCH`, `SERVING`, `UNSPECIFIED`.
        """
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class FutureReservationAggregateReservationReservedResource(dict):
    def __init__(__self__, *,
                 accelerator: Optional['outputs.FutureReservationAggregateReservationReservedResourceAccelerator'] = None):
        """
        :param 'FutureReservationAggregateReservationReservedResourceAcceleratorArgs' accelerator: Properties of accelerator resources in this reservation.
               Structure is documented below.
        """
        if accelerator is not None:
            pulumi.set(__self__, "accelerator", accelerator)

    @_builtins.property
    @pulumi.getter
    def accelerator(self) -> Optional['outputs.FutureReservationAggregateReservationReservedResourceAccelerator']:
        """
        Properties of accelerator resources in this reservation.
        Structure is documented below.
        """
        return pulumi.get(self, "accelerator")


@pulumi.output_type
class FutureReservationAggregateReservationReservedResourceAccelerator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorType":
            suggest = "accelerator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationAggregateReservationReservedResourceAccelerator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationAggregateReservationReservedResourceAccelerator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationAggregateReservationReservedResourceAccelerator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional[_builtins.int] = None,
                 accelerator_type: Optional[_builtins.str] = None):
        """
        :param _builtins.int accelerator_count: Number of accelerators of specified type.
        :param _builtins.str accelerator_type: Full or partial URL to accelerator type. e.g. "projects/{PROJECT}/zones/{ZONE}/acceleratorTypes/ct4l"
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_type is not None:
            pulumi.set(__self__, "accelerator_type", accelerator_type)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional[_builtins.int]:
        """
        Number of accelerators of specified type.
        """
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> Optional[_builtins.str]:
        """
        Full or partial URL to accelerator type. e.g. "projects/{PROJECT}/zones/{ZONE}/acceleratorTypes/ct4l"
        """
        return pulumi.get(self, "accelerator_type")


@pulumi.output_type
class FutureReservationAutoCreatedReservationsDuration(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class FutureReservationCommitmentInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commitmentName":
            suggest = "commitment_name"
        elif key == "commitmentPlan":
            suggest = "commitment_plan"
        elif key == "previousCommitmentTerms":
            suggest = "previous_commitment_terms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationCommitmentInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationCommitmentInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationCommitmentInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commitment_name: Optional[_builtins.str] = None,
                 commitment_plan: Optional[_builtins.str] = None,
                 previous_commitment_terms: Optional[_builtins.str] = None):
        """
        :param _builtins.str commitment_name: name of the commitment where capacity is being delivered to.
        :param _builtins.str commitment_plan: Indicates if a Commitment needs to be created as part of FR delivery. If this field is not present, then no commitment needs to be created.
               Possible values are: `INVALID`, `THIRTY_SIX_MONTH`, `TWELVE_MONTH`.
        :param _builtins.str previous_commitment_terms: Only applicable if FR is delivering to the same reservation. If set, all parent commitments will be extended to match the end date of the plan for this commitment.
               Possible values are: `EXTEND`.
        """
        if commitment_name is not None:
            pulumi.set(__self__, "commitment_name", commitment_name)
        if commitment_plan is not None:
            pulumi.set(__self__, "commitment_plan", commitment_plan)
        if previous_commitment_terms is not None:
            pulumi.set(__self__, "previous_commitment_terms", previous_commitment_terms)

    @_builtins.property
    @pulumi.getter(name="commitmentName")
    def commitment_name(self) -> Optional[_builtins.str]:
        """
        name of the commitment where capacity is being delivered to.
        """
        return pulumi.get(self, "commitment_name")

    @_builtins.property
    @pulumi.getter(name="commitmentPlan")
    def commitment_plan(self) -> Optional[_builtins.str]:
        """
        Indicates if a Commitment needs to be created as part of FR delivery. If this field is not present, then no commitment needs to be created.
        Possible values are: `INVALID`, `THIRTY_SIX_MONTH`, `TWELVE_MONTH`.
        """
        return pulumi.get(self, "commitment_plan")

    @_builtins.property
    @pulumi.getter(name="previousCommitmentTerms")
    def previous_commitment_terms(self) -> Optional[_builtins.str]:
        """
        Only applicable if FR is delivering to the same reservation. If set, all parent commitments will be extended to match the end date of the plan for this commitment.
        Possible values are: `EXTEND`.
        """
        return pulumi.get(self, "previous_commitment_terms")


@pulumi.output_type
class FutureReservationShareSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectMaps":
            suggest = "project_maps"
        elif key == "shareType":
            suggest = "share_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationShareSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationShareSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationShareSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_maps: Optional[Sequence['outputs.FutureReservationShareSettingsProjectMap']] = None,
                 projects: Optional[Sequence[_builtins.str]] = None,
                 share_type: Optional[_builtins.str] = None):
        """
        :param Sequence['FutureReservationShareSettingsProjectMapArgs'] project_maps: A map of project id and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.
               Structure is documented below.
        :param Sequence[_builtins.str] projects: list of Project names to specify consumer projects for this shared-reservation. This is only valid when shareType's value is SPECIFIC_PROJECTS.
        :param _builtins.str share_type: Type of sharing for this future reservation.
               Possible values are: `LOCAL`, `SPECIFIC_PROJECTS`.
        """
        if project_maps is not None:
            pulumi.set(__self__, "project_maps", project_maps)
        if projects is not None:
            pulumi.set(__self__, "projects", projects)
        if share_type is not None:
            pulumi.set(__self__, "share_type", share_type)

    @_builtins.property
    @pulumi.getter(name="projectMaps")
    def project_maps(self) -> Optional[Sequence['outputs.FutureReservationShareSettingsProjectMap']]:
        """
        A map of project id and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.
        Structure is documented below.
        """
        return pulumi.get(self, "project_maps")

    @_builtins.property
    @pulumi.getter
    def projects(self) -> Optional[Sequence[_builtins.str]]:
        """
        list of Project names to specify consumer projects for this shared-reservation. This is only valid when shareType's value is SPECIFIC_PROJECTS.
        """
        return pulumi.get(self, "projects")

    @_builtins.property
    @pulumi.getter(name="shareType")
    def share_type(self) -> Optional[_builtins.str]:
        """
        Type of sharing for this future reservation.
        Possible values are: `LOCAL`, `SPECIFIC_PROJECTS`.
        """
        return pulumi.get(self, "share_type")


@pulumi.output_type
class FutureReservationShareSettingsProjectMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationShareSettingsProjectMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationShareSettingsProjectMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationShareSettingsProjectMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 project_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The identifier for this object. Format specified above.
        :param _builtins.str project_id: The project ID, should be same as the key of this project config in the parent map.
        """
        pulumi.set(__self__, "id", id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        The project ID, should be same as the key of this project config in the parent map.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class FutureReservationSpecificSkuProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceProperties":
            suggest = "instance_properties"
        elif key == "sourceInstanceTemplate":
            suggest = "source_instance_template"
        elif key == "totalCount":
            suggest = "total_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationSpecificSkuProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationSpecificSkuProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationSpecificSkuProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_properties: Optional['outputs.FutureReservationSpecificSkuPropertiesInstanceProperties'] = None,
                 source_instance_template: Optional[_builtins.str] = None,
                 total_count: Optional[_builtins.str] = None):
        """
        :param 'FutureReservationSpecificSkuPropertiesInstancePropertiesArgs' instance_properties: Properties of the SKU instances being reserved.
               Structure is documented below.
        :param _builtins.str source_instance_template: The instance template that will be used to populate the ReservedInstanceProperties of the future reservation
        :param _builtins.str total_count: Total number of instances for which capacity assurance is requested at a future time period.
        """
        if instance_properties is not None:
            pulumi.set(__self__, "instance_properties", instance_properties)
        if source_instance_template is not None:
            pulumi.set(__self__, "source_instance_template", source_instance_template)
        if total_count is not None:
            pulumi.set(__self__, "total_count", total_count)

    @_builtins.property
    @pulumi.getter(name="instanceProperties")
    def instance_properties(self) -> Optional['outputs.FutureReservationSpecificSkuPropertiesInstanceProperties']:
        """
        Properties of the SKU instances being reserved.
        Structure is documented below.
        """
        return pulumi.get(self, "instance_properties")

    @_builtins.property
    @pulumi.getter(name="sourceInstanceTemplate")
    def source_instance_template(self) -> Optional[_builtins.str]:
        """
        The instance template that will be used to populate the ReservedInstanceProperties of the future reservation
        """
        return pulumi.get(self, "source_instance_template")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> Optional[_builtins.str]:
        """
        Total number of instances for which capacity assurance is requested at a future time period.
        """
        return pulumi.get(self, "total_count")


@pulumi.output_type
class FutureReservationSpecificSkuPropertiesInstanceProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "guestAccelerators":
            suggest = "guest_accelerators"
        elif key == "localSsds":
            suggest = "local_ssds"
        elif key == "locationHint":
            suggest = "location_hint"
        elif key == "machineType":
            suggest = "machine_type"
        elif key == "maintenanceFreezeDurationHours":
            suggest = "maintenance_freeze_duration_hours"
        elif key == "maintenanceInterval":
            suggest = "maintenance_interval"
        elif key == "minCpuPlatform":
            suggest = "min_cpu_platform"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationSpecificSkuPropertiesInstanceProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationSpecificSkuPropertiesInstanceProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationSpecificSkuPropertiesInstanceProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 guest_accelerators: Optional[Sequence['outputs.FutureReservationSpecificSkuPropertiesInstancePropertiesGuestAccelerator']] = None,
                 local_ssds: Optional[Sequence['outputs.FutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsd']] = None,
                 location_hint: Optional[_builtins.str] = None,
                 machine_type: Optional[_builtins.str] = None,
                 maintenance_freeze_duration_hours: Optional[_builtins.int] = None,
                 maintenance_interval: Optional[_builtins.str] = None,
                 min_cpu_platform: Optional[_builtins.str] = None):
        """
        :param Sequence['FutureReservationSpecificSkuPropertiesInstancePropertiesGuestAcceleratorArgs'] guest_accelerators: Specifies accelerator type and count.
               Structure is documented below.
        :param Sequence['FutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsdArgs'] local_ssds: Specifies amount of local ssd to reserve with each instance. The type of disk is local-ssd.
               Structure is documented below.
        :param _builtins.str location_hint: An opaque location hint used to place the allocation close to other resources. This field is for use by internal tools that use the public API.
        :param _builtins.str machine_type: Specifies type of machine (name only) which has fixed number of vCPUs and fixed amount of memory. This also includes specifying custom machine type following custom-NUMBER_OF_CPUS-AMOUNT_OF_MEMORY pattern.
        :param _builtins.int maintenance_freeze_duration_hours: Specifies the number of hours after reservation creation where instances using the reservation won't be scheduled for maintenance.
        :param _builtins.str maintenance_interval: Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
               Possible values are: `PERIODIC`.
        :param _builtins.str min_cpu_platform: Minimum cpu platform the reservation.
        """
        if guest_accelerators is not None:
            pulumi.set(__self__, "guest_accelerators", guest_accelerators)
        if local_ssds is not None:
            pulumi.set(__self__, "local_ssds", local_ssds)
        if location_hint is not None:
            pulumi.set(__self__, "location_hint", location_hint)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if maintenance_freeze_duration_hours is not None:
            pulumi.set(__self__, "maintenance_freeze_duration_hours", maintenance_freeze_duration_hours)
        if maintenance_interval is not None:
            pulumi.set(__self__, "maintenance_interval", maintenance_interval)
        if min_cpu_platform is not None:
            pulumi.set(__self__, "min_cpu_platform", min_cpu_platform)

    @_builtins.property
    @pulumi.getter(name="guestAccelerators")
    def guest_accelerators(self) -> Optional[Sequence['outputs.FutureReservationSpecificSkuPropertiesInstancePropertiesGuestAccelerator']]:
        """
        Specifies accelerator type and count.
        Structure is documented below.
        """
        return pulumi.get(self, "guest_accelerators")

    @_builtins.property
    @pulumi.getter(name="localSsds")
    def local_ssds(self) -> Optional[Sequence['outputs.FutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsd']]:
        """
        Specifies amount of local ssd to reserve with each instance. The type of disk is local-ssd.
        Structure is documented below.
        """
        return pulumi.get(self, "local_ssds")

    @_builtins.property
    @pulumi.getter(name="locationHint")
    def location_hint(self) -> Optional[_builtins.str]:
        """
        An opaque location hint used to place the allocation close to other resources. This field is for use by internal tools that use the public API.
        """
        return pulumi.get(self, "location_hint")

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[_builtins.str]:
        """
        Specifies type of machine (name only) which has fixed number of vCPUs and fixed amount of memory. This also includes specifying custom machine type following custom-NUMBER_OF_CPUS-AMOUNT_OF_MEMORY pattern.
        """
        return pulumi.get(self, "machine_type")

    @_builtins.property
    @pulumi.getter(name="maintenanceFreezeDurationHours")
    def maintenance_freeze_duration_hours(self) -> Optional[_builtins.int]:
        """
        Specifies the number of hours after reservation creation where instances using the reservation won't be scheduled for maintenance.
        """
        return pulumi.get(self, "maintenance_freeze_duration_hours")

    @_builtins.property
    @pulumi.getter(name="maintenanceInterval")
    def maintenance_interval(self) -> Optional[_builtins.str]:
        """
        Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
        Possible values are: `PERIODIC`.
        """
        return pulumi.get(self, "maintenance_interval")

    @_builtins.property
    @pulumi.getter(name="minCpuPlatform")
    def min_cpu_platform(self) -> Optional[_builtins.str]:
        """
        Minimum cpu platform the reservation.
        """
        return pulumi.get(self, "min_cpu_platform")


@pulumi.output_type
class FutureReservationSpecificSkuPropertiesInstancePropertiesGuestAccelerator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorType":
            suggest = "accelerator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationSpecificSkuPropertiesInstancePropertiesGuestAccelerator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationSpecificSkuPropertiesInstancePropertiesGuestAccelerator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationSpecificSkuPropertiesInstancePropertiesGuestAccelerator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional[_builtins.int] = None,
                 accelerator_type: Optional[_builtins.str] = None):
        """
        :param _builtins.int accelerator_count: The number of the guest accelerator cards exposed to this instance.
        :param _builtins.str accelerator_type: Full or partial URL of the accelerator type resource to attach to this instance.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_type is not None:
            pulumi.set(__self__, "accelerator_type", accelerator_type)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional[_builtins.int]:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> Optional[_builtins.str]:
        """
        Full or partial URL of the accelerator type resource to attach to this instance.
        """
        return pulumi.get(self, "accelerator_type")


@pulumi.output_type
class FutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeGb":
            suggest = "disk_size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationSpecificSkuPropertiesInstancePropertiesLocalSsd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_gb: Optional[_builtins.str] = None,
                 interface: Optional[_builtins.str] = None):
        """
        :param _builtins.str disk_size_gb: Specifies the size of the disk in base-2 GB.
        :param _builtins.str interface: Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI.
               Possible values are: `SCSI`, `NVME`.
        """
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[_builtins.str]:
        """
        Specifies the size of the disk in base-2 GB.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[_builtins.str]:
        """
        Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI.
        Possible values are: `SCSI`, `NVME`.
        """
        return pulumi.get(self, "interface")


@pulumi.output_type
class FutureReservationStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amendmentStatus":
            suggest = "amendment_status"
        elif key == "autoCreatedReservations":
            suggest = "auto_created_reservations"
        elif key == "fulfilledCount":
            suggest = "fulfilled_count"
        elif key == "lastKnownGoodState":
            suggest = "last_known_good_state"
        elif key == "lockTime":
            suggest = "lock_time"
        elif key == "procurementStatus":
            suggest = "procurement_status"
        elif key == "specificSkuProperties":
            suggest = "specific_sku_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amendment_status: Optional[_builtins.str] = None,
                 auto_created_reservations: Optional[Sequence[_builtins.str]] = None,
                 fulfilled_count: Optional[_builtins.str] = None,
                 last_known_good_state: Optional['outputs.FutureReservationStatusLastKnownGoodState'] = None,
                 lock_time: Optional[_builtins.str] = None,
                 procurement_status: Optional[_builtins.str] = None,
                 specific_sku_properties: Optional['outputs.FutureReservationStatusSpecificSkuProperties'] = None):
        """
        :param _builtins.str amendment_status: The current status of the requested amendment.
               Possible values are: .
        :param Sequence[_builtins.str] auto_created_reservations: Fully qualified urls of the automatically created reservations at startTime.
        :param _builtins.str fulfilled_count: This count indicates the fulfilled capacity so far. This is set during "PROVISIONING" state. This count also includes capacity delivered as part of existing matching reservations.
        :param 'FutureReservationStatusLastKnownGoodStateArgs' last_known_good_state: This field represents the future reservation before an amendment was requested. If the amendment is declined, the Future Reservation will be reverted to the last known good state. The last known good state is not set when updating a future reservation whose Procurement Status is DRAFTING.
               Structure is documented below.
        :param _builtins.str lock_time: The lock time of the FutureReservation before an amendment was requested.
        :param _builtins.str procurement_status: The status of the last known good state for the Future Reservation
               Possible values are: .
        :param 'FutureReservationStatusSpecificSkuPropertiesArgs' specific_sku_properties: Future Reservation configuration to indicate instance properties and total count.
               Structure is documented below.
        """
        if amendment_status is not None:
            pulumi.set(__self__, "amendment_status", amendment_status)
        if auto_created_reservations is not None:
            pulumi.set(__self__, "auto_created_reservations", auto_created_reservations)
        if fulfilled_count is not None:
            pulumi.set(__self__, "fulfilled_count", fulfilled_count)
        if last_known_good_state is not None:
            pulumi.set(__self__, "last_known_good_state", last_known_good_state)
        if lock_time is not None:
            pulumi.set(__self__, "lock_time", lock_time)
        if procurement_status is not None:
            pulumi.set(__self__, "procurement_status", procurement_status)
        if specific_sku_properties is not None:
            pulumi.set(__self__, "specific_sku_properties", specific_sku_properties)

    @_builtins.property
    @pulumi.getter(name="amendmentStatus")
    def amendment_status(self) -> Optional[_builtins.str]:
        """
        The current status of the requested amendment.
        Possible values are: .
        """
        return pulumi.get(self, "amendment_status")

    @_builtins.property
    @pulumi.getter(name="autoCreatedReservations")
    def auto_created_reservations(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully qualified urls of the automatically created reservations at startTime.
        """
        return pulumi.get(self, "auto_created_reservations")

    @_builtins.property
    @pulumi.getter(name="fulfilledCount")
    def fulfilled_count(self) -> Optional[_builtins.str]:
        """
        This count indicates the fulfilled capacity so far. This is set during "PROVISIONING" state. This count also includes capacity delivered as part of existing matching reservations.
        """
        return pulumi.get(self, "fulfilled_count")

    @_builtins.property
    @pulumi.getter(name="lastKnownGoodState")
    def last_known_good_state(self) -> Optional['outputs.FutureReservationStatusLastKnownGoodState']:
        """
        This field represents the future reservation before an amendment was requested. If the amendment is declined, the Future Reservation will be reverted to the last known good state. The last known good state is not set when updating a future reservation whose Procurement Status is DRAFTING.
        Structure is documented below.
        """
        return pulumi.get(self, "last_known_good_state")

    @_builtins.property
    @pulumi.getter(name="lockTime")
    def lock_time(self) -> Optional[_builtins.str]:
        """
        The lock time of the FutureReservation before an amendment was requested.
        """
        return pulumi.get(self, "lock_time")

    @_builtins.property
    @pulumi.getter(name="procurementStatus")
    def procurement_status(self) -> Optional[_builtins.str]:
        """
        The status of the last known good state for the Future Reservation
        Possible values are: .
        """
        return pulumi.get(self, "procurement_status")

    @_builtins.property
    @pulumi.getter(name="specificSkuProperties")
    def specific_sku_properties(self) -> Optional['outputs.FutureReservationStatusSpecificSkuProperties']:
        """
        Future Reservation configuration to indicate instance properties and total count.
        Structure is documented below.
        """
        return pulumi.get(self, "specific_sku_properties")


@pulumi.output_type
class FutureReservationStatusLastKnownGoodState(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "existingMatchingUsageInfo":
            suggest = "existing_matching_usage_info"
        elif key == "futureReservationSpecs":
            suggest = "future_reservation_specs"
        elif key == "lockTime":
            suggest = "lock_time"
        elif key == "namePrefix":
            suggest = "name_prefix"
        elif key == "procurementStatus":
            suggest = "procurement_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationStatusLastKnownGoodState. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationStatusLastKnownGoodState.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationStatusLastKnownGoodState.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 existing_matching_usage_info: Optional['outputs.FutureReservationStatusLastKnownGoodStateExistingMatchingUsageInfo'] = None,
                 future_reservation_specs: Optional['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecs'] = None,
                 lock_time: Optional[_builtins.str] = None,
                 name_prefix: Optional[_builtins.str] = None,
                 procurement_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: An optional description of this resource.
        :param 'FutureReservationStatusLastKnownGoodStateExistingMatchingUsageInfoArgs' existing_matching_usage_info: Represents the matching usage for the future reservation before an amendment was requested.
               Structure is documented below.
        :param 'FutureReservationStatusLastKnownGoodStateFutureReservationSpecsArgs' future_reservation_specs: The previous instance-related properties of the Future Reservation.
               Structure is documented below.
        :param _builtins.str lock_time: The lock time of the FutureReservation before an amendment was requested.
        :param _builtins.str name_prefix: Name prefix for the reservations to be created at the time of delivery. The name prefix must comply with RFC1035. Maximum allowed length for name prefix is 20. Automatically created reservations name format will be -date-####.
        :param _builtins.str procurement_status: The status of the last known good state for the Future Reservation
               Possible values are: .
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if existing_matching_usage_info is not None:
            pulumi.set(__self__, "existing_matching_usage_info", existing_matching_usage_info)
        if future_reservation_specs is not None:
            pulumi.set(__self__, "future_reservation_specs", future_reservation_specs)
        if lock_time is not None:
            pulumi.set(__self__, "lock_time", lock_time)
        if name_prefix is not None:
            pulumi.set(__self__, "name_prefix", name_prefix)
        if procurement_status is not None:
            pulumi.set(__self__, "procurement_status", procurement_status)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="existingMatchingUsageInfo")
    def existing_matching_usage_info(self) -> Optional['outputs.FutureReservationStatusLastKnownGoodStateExistingMatchingUsageInfo']:
        """
        Represents the matching usage for the future reservation before an amendment was requested.
        Structure is documented below.
        """
        return pulumi.get(self, "existing_matching_usage_info")

    @_builtins.property
    @pulumi.getter(name="futureReservationSpecs")
    def future_reservation_specs(self) -> Optional['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecs']:
        """
        The previous instance-related properties of the Future Reservation.
        Structure is documented below.
        """
        return pulumi.get(self, "future_reservation_specs")

    @_builtins.property
    @pulumi.getter(name="lockTime")
    def lock_time(self) -> Optional[_builtins.str]:
        """
        The lock time of the FutureReservation before an amendment was requested.
        """
        return pulumi.get(self, "lock_time")

    @_builtins.property
    @pulumi.getter(name="namePrefix")
    def name_prefix(self) -> Optional[_builtins.str]:
        """
        Name prefix for the reservations to be created at the time of delivery. The name prefix must comply with RFC1035. Maximum allowed length for name prefix is 20. Automatically created reservations name format will be -date-####.
        """
        return pulumi.get(self, "name_prefix")

    @_builtins.property
    @pulumi.getter(name="procurementStatus")
    def procurement_status(self) -> Optional[_builtins.str]:
        """
        The status of the last known good state for the Future Reservation
        Possible values are: .
        """
        return pulumi.get(self, "procurement_status")


@pulumi.output_type
class FutureReservationStatusLastKnownGoodStateExistingMatchingUsageInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeStamp":
            suggest = "time_stamp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationStatusLastKnownGoodStateExistingMatchingUsageInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationStatusLastKnownGoodStateExistingMatchingUsageInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationStatusLastKnownGoodStateExistingMatchingUsageInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[_builtins.str] = None,
                 time_stamp: Optional[_builtins.str] = None):
        """
        :param _builtins.str count: Count representing minimum(FR totalCount, matching_reserved_capacity+matching_unreserved_instances).
        :param _builtins.str time_stamp: Timestamp when the matching usage was calculated.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if time_stamp is not None:
            pulumi.set(__self__, "time_stamp", time_stamp)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.str]:
        """
        Count representing minimum(FR totalCount, matching_reserved_capacity+matching_unreserved_instances).
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="timeStamp")
    def time_stamp(self) -> Optional[_builtins.str]:
        """
        Timestamp when the matching usage was calculated.
        """
        return pulumi.get(self, "time_stamp")


@pulumi.output_type
class FutureReservationStatusLastKnownGoodStateFutureReservationSpecs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shareSettings":
            suggest = "share_settings"
        elif key == "specificSkuProperties":
            suggest = "specific_sku_properties"
        elif key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationStatusLastKnownGoodStateFutureReservationSpecs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 share_settings: Optional['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettings'] = None,
                 specific_sku_properties: Optional['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuProperties'] = None,
                 time_window: Optional['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindow'] = None):
        """
        :param 'FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsArgs' share_settings: Settings for sharing the future reservation
               Structure is documented below.
        :param 'FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesArgs' specific_sku_properties: Future Reservation configuration to indicate instance properties and total count.
               Structure is documented below.
        :param 'FutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowArgs' time_window: Time window for this Future Reservation.
               Structure is documented below.
        """
        if share_settings is not None:
            pulumi.set(__self__, "share_settings", share_settings)
        if specific_sku_properties is not None:
            pulumi.set(__self__, "specific_sku_properties", specific_sku_properties)
        if time_window is not None:
            pulumi.set(__self__, "time_window", time_window)

    @_builtins.property
    @pulumi.getter(name="shareSettings")
    def share_settings(self) -> Optional['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettings']:
        """
        Settings for sharing the future reservation
        Structure is documented below.
        """
        return pulumi.get(self, "share_settings")

    @_builtins.property
    @pulumi.getter(name="specificSkuProperties")
    def specific_sku_properties(self) -> Optional['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuProperties']:
        """
        Future Reservation configuration to indicate instance properties and total count.
        Structure is documented below.
        """
        return pulumi.get(self, "specific_sku_properties")

    @_builtins.property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> Optional['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindow']:
        """
        Time window for this Future Reservation.
        Structure is documented below.
        """
        return pulumi.get(self, "time_window")


@pulumi.output_type
class FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectMaps":
            suggest = "project_maps"
        elif key == "shareType":
            suggest = "share_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_maps: Optional[Sequence['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsProjectMap']] = None,
                 projects: Optional[Sequence[_builtins.str]] = None,
                 share_type: Optional[_builtins.str] = None):
        """
        :param Sequence['FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsProjectMapArgs'] project_maps: A map of project id and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.
               Structure is documented below.
        :param Sequence[_builtins.str] projects: list of Project names to specify consumer projects for this shared-reservation. This is only valid when shareType's value is SPECIFIC_PROJECTS.
        :param _builtins.str share_type: Type of sharing for this future reservation.
               Possible values are: `LOCAL`, `SPECIFIC_PROJECTS`.
        """
        if project_maps is not None:
            pulumi.set(__self__, "project_maps", project_maps)
        if projects is not None:
            pulumi.set(__self__, "projects", projects)
        if share_type is not None:
            pulumi.set(__self__, "share_type", share_type)

    @_builtins.property
    @pulumi.getter(name="projectMaps")
    def project_maps(self) -> Optional[Sequence['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsProjectMap']]:
        """
        A map of project id and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.
        Structure is documented below.
        """
        return pulumi.get(self, "project_maps")

    @_builtins.property
    @pulumi.getter
    def projects(self) -> Optional[Sequence[_builtins.str]]:
        """
        list of Project names to specify consumer projects for this shared-reservation. This is only valid when shareType's value is SPECIFIC_PROJECTS.
        """
        return pulumi.get(self, "projects")

    @_builtins.property
    @pulumi.getter(name="shareType")
    def share_type(self) -> Optional[_builtins.str]:
        """
        Type of sharing for this future reservation.
        Possible values are: `LOCAL`, `SPECIFIC_PROJECTS`.
        """
        return pulumi.get(self, "share_type")


@pulumi.output_type
class FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsProjectMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsProjectMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsProjectMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecsShareSettingsProjectMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project: _builtins.str,
                 project_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str project: The ID of the project in which the resource belongs.
               If it is not provided, the provider project is used.
        :param _builtins.str project_id: The project ID, should be same as the key of this project config in the parent map.
        """
        pulumi.set(__self__, "project", project)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        The ID of the project in which the resource belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        The project ID, should be same as the key of this project config in the parent map.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceProperties":
            suggest = "instance_properties"
        elif key == "sourceInstanceTemplate":
            suggest = "source_instance_template"
        elif key == "totalCount":
            suggest = "total_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_properties: Optional['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstanceProperties'] = None,
                 source_instance_template: Optional[_builtins.str] = None,
                 total_count: Optional[_builtins.str] = None):
        """
        :param 'FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesArgs' instance_properties: Properties of the SKU instances being reserved.
               Structure is documented below.
        :param _builtins.str source_instance_template: The instance template that will be used to populate the ReservedInstanceProperties of the future reservation
        :param _builtins.str total_count: Total number of instances for which capacity assurance is requested at a future time period.
        """
        if instance_properties is not None:
            pulumi.set(__self__, "instance_properties", instance_properties)
        if source_instance_template is not None:
            pulumi.set(__self__, "source_instance_template", source_instance_template)
        if total_count is not None:
            pulumi.set(__self__, "total_count", total_count)

    @_builtins.property
    @pulumi.getter(name="instanceProperties")
    def instance_properties(self) -> Optional['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstanceProperties']:
        """
        Properties of the SKU instances being reserved.
        Structure is documented below.
        """
        return pulumi.get(self, "instance_properties")

    @_builtins.property
    @pulumi.getter(name="sourceInstanceTemplate")
    def source_instance_template(self) -> Optional[_builtins.str]:
        """
        The instance template that will be used to populate the ReservedInstanceProperties of the future reservation
        """
        return pulumi.get(self, "source_instance_template")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> Optional[_builtins.str]:
        """
        Total number of instances for which capacity assurance is requested at a future time period.
        """
        return pulumi.get(self, "total_count")


@pulumi.output_type
class FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstanceProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "guestAccelerators":
            suggest = "guest_accelerators"
        elif key == "localSsds":
            suggest = "local_ssds"
        elif key == "locationHint":
            suggest = "location_hint"
        elif key == "machineType":
            suggest = "machine_type"
        elif key == "maintenanceFreezeDurationHours":
            suggest = "maintenance_freeze_duration_hours"
        elif key == "maintenanceInterval":
            suggest = "maintenance_interval"
        elif key == "minCpuPlatform":
            suggest = "min_cpu_platform"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstanceProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstanceProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstanceProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 guest_accelerators: Optional[Sequence['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesGuestAccelerator']] = None,
                 local_ssds: Optional[Sequence['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocalSsd']] = None,
                 location_hint: Optional[_builtins.str] = None,
                 machine_type: Optional[_builtins.str] = None,
                 maintenance_freeze_duration_hours: Optional[_builtins.int] = None,
                 maintenance_interval: Optional[_builtins.str] = None,
                 min_cpu_platform: Optional[_builtins.str] = None):
        """
        :param Sequence['FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesGuestAcceleratorArgs'] guest_accelerators: Specifies accelerator type and count.
               Structure is documented below.
        :param Sequence['FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocalSsdArgs'] local_ssds: Specifies amount of local ssd to reserve with each instance. The type of disk is local-ssd.
               Structure is documented below.
        :param _builtins.str location_hint: An opaque location hint used to place the allocation close to other resources. This field is for use by internal tools that use the public API.
        :param _builtins.str machine_type: Specifies type of machine (name only) which has fixed number of vCPUs and fixed amount of memory. This also includes specifying custom machine type following custom-NUMBER_OF_CPUS-AMOUNT_OF_MEMORY pattern.
        :param _builtins.int maintenance_freeze_duration_hours: Specifies the number of hours after reservation creation where instances using the reservation won't be scheduled for maintenance.
        :param _builtins.str maintenance_interval: Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
               Possible values are: `PERIODIC`.
        :param _builtins.str min_cpu_platform: Minimum cpu platform the reservation.
        """
        if guest_accelerators is not None:
            pulumi.set(__self__, "guest_accelerators", guest_accelerators)
        if local_ssds is not None:
            pulumi.set(__self__, "local_ssds", local_ssds)
        if location_hint is not None:
            pulumi.set(__self__, "location_hint", location_hint)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if maintenance_freeze_duration_hours is not None:
            pulumi.set(__self__, "maintenance_freeze_duration_hours", maintenance_freeze_duration_hours)
        if maintenance_interval is not None:
            pulumi.set(__self__, "maintenance_interval", maintenance_interval)
        if min_cpu_platform is not None:
            pulumi.set(__self__, "min_cpu_platform", min_cpu_platform)

    @_builtins.property
    @pulumi.getter(name="guestAccelerators")
    def guest_accelerators(self) -> Optional[Sequence['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesGuestAccelerator']]:
        """
        Specifies accelerator type and count.
        Structure is documented below.
        """
        return pulumi.get(self, "guest_accelerators")

    @_builtins.property
    @pulumi.getter(name="localSsds")
    def local_ssds(self) -> Optional[Sequence['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocalSsd']]:
        """
        Specifies amount of local ssd to reserve with each instance. The type of disk is local-ssd.
        Structure is documented below.
        """
        return pulumi.get(self, "local_ssds")

    @_builtins.property
    @pulumi.getter(name="locationHint")
    def location_hint(self) -> Optional[_builtins.str]:
        """
        An opaque location hint used to place the allocation close to other resources. This field is for use by internal tools that use the public API.
        """
        return pulumi.get(self, "location_hint")

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[_builtins.str]:
        """
        Specifies type of machine (name only) which has fixed number of vCPUs and fixed amount of memory. This also includes specifying custom machine type following custom-NUMBER_OF_CPUS-AMOUNT_OF_MEMORY pattern.
        """
        return pulumi.get(self, "machine_type")

    @_builtins.property
    @pulumi.getter(name="maintenanceFreezeDurationHours")
    def maintenance_freeze_duration_hours(self) -> Optional[_builtins.int]:
        """
        Specifies the number of hours after reservation creation where instances using the reservation won't be scheduled for maintenance.
        """
        return pulumi.get(self, "maintenance_freeze_duration_hours")

    @_builtins.property
    @pulumi.getter(name="maintenanceInterval")
    def maintenance_interval(self) -> Optional[_builtins.str]:
        """
        Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
        Possible values are: `PERIODIC`.
        """
        return pulumi.get(self, "maintenance_interval")

    @_builtins.property
    @pulumi.getter(name="minCpuPlatform")
    def min_cpu_platform(self) -> Optional[_builtins.str]:
        """
        Minimum cpu platform the reservation.
        """
        return pulumi.get(self, "min_cpu_platform")


@pulumi.output_type
class FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesGuestAccelerator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorType":
            suggest = "accelerator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesGuestAccelerator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesGuestAccelerator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesGuestAccelerator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional[_builtins.int] = None,
                 accelerator_type: Optional[_builtins.str] = None):
        """
        :param _builtins.int accelerator_count: The number of the guest accelerator cards exposed to this instance.
        :param _builtins.str accelerator_type: Full or partial URL of the accelerator type resource to attach to this instance.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_type is not None:
            pulumi.set(__self__, "accelerator_type", accelerator_type)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional[_builtins.int]:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> Optional[_builtins.str]:
        """
        Full or partial URL of the accelerator type resource to attach to this instance.
        """
        return pulumi.get(self, "accelerator_type")


@pulumi.output_type
class FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocalSsd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeGb":
            suggest = "disk_size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocalSsd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocalSsd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecsSpecificSkuPropertiesInstancePropertiesLocalSsd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_gb: Optional[_builtins.str] = None,
                 interface: Optional[_builtins.str] = None):
        """
        :param _builtins.str disk_size_gb: Specifies the size of the disk in base-2 GB.
        :param _builtins.str interface: Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI.
               Possible values are: `SCSI`, `NVME`.
        """
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[_builtins.str]:
        """
        Specifies the size of the disk in base-2 GB.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[_builtins.str]:
        """
        Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI.
        Possible values are: `SCSI`, `NVME`.
        """
        return pulumi.get(self, "interface")


@pulumi.output_type
class FutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowDuration'] = None,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param 'FutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowDurationArgs' duration: Duration of the future reservation
               Structure is documented below.
        :param _builtins.str end_time: End time of the future reservation in RFC3339 format.
        :param _builtins.str start_time: Start time of the future reservation in RFC3339 format.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional['outputs.FutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowDuration']:
        """
        Duration of the future reservation
        Structure is documented below.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End time of the future reservation in RFC3339 format.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Start time of the future reservation in RFC3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class FutureReservationStatusLastKnownGoodStateFutureReservationSpecsTimeWindowDuration(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class FutureReservationStatusSpecificSkuProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceInstanceTemplateId":
            suggest = "source_instance_template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationStatusSpecificSkuProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationStatusSpecificSkuProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationStatusSpecificSkuProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_instance_template_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str source_instance_template_id: ID of the instance template used to populate the Future Reservation properties.
        """
        if source_instance_template_id is not None:
            pulumi.set(__self__, "source_instance_template_id", source_instance_template_id)

    @_builtins.property
    @pulumi.getter(name="sourceInstanceTemplateId")
    def source_instance_template_id(self) -> Optional[_builtins.str]:
        """
        ID of the instance template used to populate the Future Reservation properties.
        """
        return pulumi.get(self, "source_instance_template_id")


@pulumi.output_type
class FutureReservationTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "endTime":
            suggest = "end_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FutureReservationTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FutureReservationTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FutureReservationTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_time: _builtins.str,
                 duration: Optional['outputs.FutureReservationTimeWindowDuration'] = None,
                 end_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str start_time: Start time of the future reservation in RFC3339 format.
        :param 'FutureReservationTimeWindowDurationArgs' duration: Duration of the future reservation
               Structure is documented below.
        :param _builtins.str end_time: End time of the future reservation in RFC3339 format.
        """
        pulumi.set(__self__, "start_time", start_time)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Start time of the future reservation in RFC3339 format.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional['outputs.FutureReservationTimeWindowDuration']:
        """
        Duration of the future reservation
        Structure is documented below.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End time of the future reservation in RFC3339 format.
        """
        return pulumi.get(self, "end_time")


@pulumi.output_type
class FutureReservationTimeWindowDuration(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GlobalForwardingRuleMetadataFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterLabels":
            suggest = "filter_labels"
        elif key == "filterMatchCriteria":
            suggest = "filter_match_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalForwardingRuleMetadataFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalForwardingRuleMetadataFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalForwardingRuleMetadataFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_labels: Sequence['outputs.GlobalForwardingRuleMetadataFilterFilterLabel'],
                 filter_match_criteria: _builtins.str):
        """
        :param Sequence['GlobalForwardingRuleMetadataFilterFilterLabelArgs'] filter_labels: The list of label value pairs that must match labels in the
               provided metadata based on filterMatchCriteria
               This list must not be empty and can have at the most 64 entries.
               Structure is documented below.
        :param _builtins.str filter_match_criteria: Specifies how individual filterLabel matches within the list of
               filterLabels contribute towards the overall metadataFilter match.
               MATCH_ANY - At least one of the filterLabels must have a matching
               label in the provided metadata.
               MATCH_ALL - All filterLabels must have matching labels in the
               provided metadata.
               Possible values are: `MATCH_ANY`, `MATCH_ALL`.
        """
        pulumi.set(__self__, "filter_labels", filter_labels)
        pulumi.set(__self__, "filter_match_criteria", filter_match_criteria)

    @_builtins.property
    @pulumi.getter(name="filterLabels")
    def filter_labels(self) -> Sequence['outputs.GlobalForwardingRuleMetadataFilterFilterLabel']:
        """
        The list of label value pairs that must match labels in the
        provided metadata based on filterMatchCriteria
        This list must not be empty and can have at the most 64 entries.
        Structure is documented below.
        """
        return pulumi.get(self, "filter_labels")

    @_builtins.property
    @pulumi.getter(name="filterMatchCriteria")
    def filter_match_criteria(self) -> _builtins.str:
        """
        Specifies how individual filterLabel matches within the list of
        filterLabels contribute towards the overall metadataFilter match.
        MATCH_ANY - At least one of the filterLabels must have a matching
        label in the provided metadata.
        MATCH_ALL - All filterLabels must have matching labels in the
        provided metadata.
        Possible values are: `MATCH_ANY`, `MATCH_ALL`.
        """
        return pulumi.get(self, "filter_match_criteria")


@pulumi.output_type
class GlobalForwardingRuleMetadataFilterFilterLabel(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Name of the metadata label. The length must be between
               1 and 1024 characters, inclusive.
        :param _builtins.str value: The value that the label must match. The value has a maximum
               length of 1024 characters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the metadata label. The length must be between
        1 and 1024 characters, inclusive.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value that the label must match. The value has a maximum
        length of 1024 characters.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GlobalForwardingRuleServiceDirectoryRegistrations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceDirectoryRegion":
            suggest = "service_directory_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalForwardingRuleServiceDirectoryRegistrations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalForwardingRuleServiceDirectoryRegistrations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalForwardingRuleServiceDirectoryRegistrations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace: Optional[_builtins.str] = None,
                 service_directory_region: Optional[_builtins.str] = None):
        """
        :param _builtins.str namespace: Service Directory namespace to register the forwarding rule under.
        :param _builtins.str service_directory_region: [Optional] Service Directory region to register this global forwarding rule under.
               Default to "us-central1". Only used for PSC for Google APIs. All PSC for
               Google APIs Forwarding Rules on the same network should use the same Service
               Directory region.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if service_directory_region is not None:
            pulumi.set(__self__, "service_directory_region", service_directory_region)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Service Directory namespace to register the forwarding rule under.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryRegion")
    def service_directory_region(self) -> Optional[_builtins.str]:
        """
        [Optional] Service Directory region to register this global forwarding rule under.
        Default to "us-central1". Only used for PSC for Google APIs. All PSC for
        Google APIs Forwarding Rules on the same network should use the same Service
        Directory region.
        """
        return pulumi.get(self, "service_directory_region")


@pulumi.output_type
class HaVpnGatewayVpnInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interconnectAttachment":
            suggest = "interconnect_attachment"
        elif key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HaVpnGatewayVpnInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HaVpnGatewayVpnInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HaVpnGatewayVpnInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.int] = None,
                 interconnect_attachment: Optional[_builtins.str] = None,
                 ip_address: Optional[_builtins.str] = None):
        """
        :param _builtins.int id: The numeric ID of this VPN gateway interface.
        :param _builtins.str interconnect_attachment: URL of the interconnect attachment resource. When the value
               of this field is present, the VPN Gateway will be used for
               IPsec-encrypted Cloud Interconnect; all Egress or Ingress
               traffic for this VPN Gateway interface will go through the
               specified interconnect attachment resource.
               Not currently available publicly.
        :param _builtins.str ip_address: (Output)
               The external IP address for this VPN gateway interface.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interconnect_attachment is not None:
            pulumi.set(__self__, "interconnect_attachment", interconnect_attachment)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        The numeric ID of this VPN gateway interface.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="interconnectAttachment")
    def interconnect_attachment(self) -> Optional[_builtins.str]:
        """
        URL of the interconnect attachment resource. When the value
        of this field is present, the VPN Gateway will be used for
        IPsec-encrypted Cloud Interconnect; all Egress or Ingress
        traffic for this VPN Gateway interface will go through the
        specified interconnect attachment resource.
        Not currently available publicly.
        """
        return pulumi.get(self, "interconnect_attachment")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        """
        (Output)
        The external IP address for this VPN gateway interface.
        """
        return pulumi.get(self, "ip_address")


@pulumi.output_type
class HealthCheckGrpcHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcServiceName":
            suggest = "grpc_service_name"
        elif key == "portName":
            suggest = "port_name"
        elif key == "portSpecification":
            suggest = "port_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthCheckGrpcHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthCheckGrpcHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthCheckGrpcHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grpc_service_name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_name: Optional[_builtins.str] = None,
                 port_specification: Optional[_builtins.str] = None):
        """
        :param _builtins.str grpc_service_name: The gRPC service name for the health check.
               The value of grpcServiceName has the following meanings by convention:
               - Empty serviceName means the overall status of all services at the backend.
               - Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
               The grpcServiceName can only be ASCII.
        :param _builtins.int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        if grpc_service_name is not None:
            pulumi.set(__self__, "grpc_service_name", grpc_service_name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)

    @_builtins.property
    @pulumi.getter(name="grpcServiceName")
    def grpc_service_name(self) -> Optional[_builtins.str]:
        """
        The gRPC service name for the health check.
        The value of grpcServiceName has the following meanings by convention:
        - Empty serviceName means the overall status of all services at the backend.
        - Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
        The grpcServiceName can only be ASCII.
        """
        return pulumi.get(self, "grpc_service_name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[_builtins.str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[_builtins.str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")


@pulumi.output_type
class HealthCheckGrpcTlsHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcServiceName":
            suggest = "grpc_service_name"
        elif key == "portSpecification":
            suggest = "port_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthCheckGrpcTlsHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthCheckGrpcTlsHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthCheckGrpcTlsHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grpc_service_name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_specification: Optional[_builtins.str] = None):
        """
        :param _builtins.str grpc_service_name: The gRPC service name for the health check.
               The value of grpcServiceName has the following meanings by convention:
               - Empty serviceName means the overall status of all services at the backend.
               - Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
               The grpcServiceName can only be ASCII.
        :param _builtins.int port: The port number for the health check request.
               Must be specified if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: Not supported for GRPC with TLS health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC with TLS health check follows behavior specified in the `port` field.
               Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        if grpc_service_name is not None:
            pulumi.set(__self__, "grpc_service_name", grpc_service_name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)

    @_builtins.property
    @pulumi.getter(name="grpcServiceName")
    def grpc_service_name(self) -> Optional[_builtins.str]:
        """
        The gRPC service name for the health check.
        The value of grpcServiceName has the following meanings by convention:
        - Empty serviceName means the overall status of all services at the backend.
        - Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
        The grpcServiceName can only be ASCII.
        """
        return pulumi.get(self, "grpc_service_name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port number for the health check request.
        Must be specified if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[_builtins.str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: Not supported for GRPC with TLS health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC with TLS health check follows behavior specified in the `port` field.
        Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")


@pulumi.output_type
class HealthCheckHttp2HealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portName":
            suggest = "port_name"
        elif key == "portSpecification":
            suggest = "port_specification"
        elif key == "proxyHeader":
            suggest = "proxy_header"
        elif key == "requestPath":
            suggest = "request_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthCheckHttp2HealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthCheckHttp2HealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthCheckHttp2HealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_name: Optional[_builtins.str] = None,
                 port_specification: Optional[_builtins.str] = None,
                 proxy_header: Optional[_builtins.str] = None,
                 request_path: Optional[_builtins.str] = None,
                 response: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param _builtins.int port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               
                 * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
               
                 * 'USE_NAMED_PORT': The 'portName' is used for health checking.
               
                 * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
                 network endpoint is used for health checking. For other backends, the
                 port or named port specified in the Backend Service is used for health
                 checking.
               
               If not specified, HTTP2 health check follows behavior specified in 'port' and
               'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
        :param _builtins.str request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request_path is not None:
            pulumi.set(__self__, "request_path", request_path)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[_builtins.str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[_builtins.str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:

          * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.

          * 'USE_NAMED_PORT': The 'portName' is used for health checking.

          * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
          network endpoint is used for health checking. For other backends, the
          port or named port specified in the Backend Service is used for health
          checking.

        If not specified, HTTP2 health check follows behavior specified in 'port' and
        'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[_builtins.str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[_builtins.str]:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[_builtins.str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class HealthCheckHttpHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portName":
            suggest = "port_name"
        elif key == "portSpecification":
            suggest = "port_specification"
        elif key == "proxyHeader":
            suggest = "proxy_header"
        elif key == "requestPath":
            suggest = "request_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthCheckHttpHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthCheckHttpHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthCheckHttpHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_name: Optional[_builtins.str] = None,
                 port_specification: Optional[_builtins.str] = None,
                 proxy_header: Optional[_builtins.str] = None,
                 request_path: Optional[_builtins.str] = None,
                 response: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: The value of the host header in the HTTP health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param _builtins.int port: The TCP port number for the HTTP health check request.
               The default value is 80.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTP health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are: `NONE`, `PROXY_V1`.
        :param _builtins.str request_path: The request path of the HTTP health check request.
               The default value is /.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request_path is not None:
            pulumi.set(__self__, "request_path", request_path)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The value of the host header in the HTTP health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The TCP port number for the HTTP health check request.
        The default value is 80.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[_builtins.str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[_builtins.str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTP health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[_builtins.str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are: `NONE`, `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[_builtins.str]:
        """
        The request path of the HTTP health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[_builtins.str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class HealthCheckHttpsHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portName":
            suggest = "port_name"
        elif key == "portSpecification":
            suggest = "port_specification"
        elif key == "proxyHeader":
            suggest = "proxy_header"
        elif key == "requestPath":
            suggest = "request_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthCheckHttpsHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthCheckHttpsHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthCheckHttpsHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_name: Optional[_builtins.str] = None,
                 port_specification: Optional[_builtins.str] = None,
                 proxy_header: Optional[_builtins.str] = None,
                 request_path: Optional[_builtins.str] = None,
                 response: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: The value of the host header in the HTTPS health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param _builtins.int port: The TCP port number for the HTTPS health check request.
               The default value is 443.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTPS health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are: `NONE`, `PROXY_V1`.
        :param _builtins.str request_path: The request path of the HTTPS health check request.
               The default value is /.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request_path is not None:
            pulumi.set(__self__, "request_path", request_path)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The value of the host header in the HTTPS health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The TCP port number for the HTTPS health check request.
        The default value is 443.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[_builtins.str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[_builtins.str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTPS health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[_builtins.str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are: `NONE`, `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[_builtins.str]:
        """
        The request path of the HTTPS health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[_builtins.str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class HealthCheckLogConfig(dict):
    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable: Indicates whether or not to export logs. This is false by default,
               which means no health check logging will be done.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        Indicates whether or not to export logs. This is false by default,
        which means no health check logging will be done.
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class HealthCheckSslHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portName":
            suggest = "port_name"
        elif key == "portSpecification":
            suggest = "port_specification"
        elif key == "proxyHeader":
            suggest = "proxy_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthCheckSslHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthCheckSslHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthCheckSslHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: Optional[_builtins.int] = None,
                 port_name: Optional[_builtins.str] = None,
                 port_specification: Optional[_builtins.str] = None,
                 proxy_header: Optional[_builtins.str] = None,
                 request: Optional[_builtins.str] = None,
                 response: Optional[_builtins.str] = None):
        """
        :param _builtins.int port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTP2 health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are: `NONE`, `PROXY_V1`.
        :param _builtins.str request: The application data to send once the SSL connection has been
               established (default value is empty). If both request and response are
               empty, the connection establishment alone will indicate health. The request
               data can only be ASCII.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[_builtins.str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[_builtins.str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTP2 health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[_builtins.str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are: `NONE`, `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[_builtins.str]:
        """
        The application data to send once the SSL connection has been
        established (default value is empty). If both request and response are
        empty, the connection establishment alone will indicate health. The request
        data can only be ASCII.
        """
        return pulumi.get(self, "request")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[_builtins.str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class HealthCheckTcpHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portName":
            suggest = "port_name"
        elif key == "portSpecification":
            suggest = "port_specification"
        elif key == "proxyHeader":
            suggest = "proxy_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthCheckTcpHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthCheckTcpHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthCheckTcpHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: Optional[_builtins.int] = None,
                 port_name: Optional[_builtins.str] = None,
                 port_specification: Optional[_builtins.str] = None,
                 proxy_header: Optional[_builtins.str] = None,
                 request: Optional[_builtins.str] = None,
                 response: Optional[_builtins.str] = None):
        """
        :param _builtins.int port: The TCP port number for the TCP health check request.
               The default value is 443.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, TCP health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are: `NONE`, `PROXY_V1`.
        :param _builtins.str request: The application data to send once the TCP connection has been
               established (default value is empty). If both request and response are
               empty, the connection establishment alone will indicate health. The request
               data can only be ASCII.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The TCP port number for the TCP health check request.
        The default value is 443.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[_builtins.str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[_builtins.str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, TCP health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[_builtins.str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are: `NONE`, `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[_builtins.str]:
        """
        The application data to send once the TCP connection has been
        established (default value is empty). If both request and response are
        empty, the connection establishment alone will indicate health. The request
        data can only be ASCII.
        """
        return pulumi.get(self, "request")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[_builtins.str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class ImageGuestOsFeature(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
               Possible values are: `MULTI_IP_SUBNET`, `SECURE_BOOT`, `SEV_CAPABLE`, `UEFI_COMPATIBLE`, `VIRTIO_SCSI_MULTIQUEUE`, `WINDOWS`, `GVNIC`, `IDPF`, `SEV_LIVE_MIGRATABLE`, `SEV_SNP_CAPABLE`, `SUSPEND_RESUME_COMPATIBLE`, `TDX_CAPABLE`, `SEV_LIVE_MIGRATABLE_V2`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
        Possible values are: `MULTI_IP_SUBNET`, `SECURE_BOOT`, `SEV_CAPABLE`, `UEFI_COMPATIBLE`, `VIRTIO_SCSI_MULTIQUEUE`, `WINDOWS`, `GVNIC`, `IDPF`, `SEV_LIVE_MIGRATABLE`, `SEV_SNP_CAPABLE`, `SUSPEND_RESUME_COMPATIBLE`, `TDX_CAPABLE`, `SEV_LIVE_MIGRATABLE_V2`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ImageIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        :param _builtins.str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
               
               > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
               identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
               consider it to be an entirely different resource and will treat it as such.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
        identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
        consider it to be an entirely different resource and will treat it as such.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class ImageIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        :param _builtins.str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
               
               > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
               identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
               consider it to be an entirely different resource and will treat it as such.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
        identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
        consider it to be an entirely different resource and will treat it as such.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class ImageImageEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageImageEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageImageEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageImageEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud
               KMS.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the
               given KMS key. If absent, the Compute Engine default service
               account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str rsa_encrypted_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key that is stored in Google Cloud
        KMS.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the
        given KMS key. If absent, the Compute Engine default service
        account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class ImageRawDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerType":
            suggest = "container_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageRawDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageRawDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageRawDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: _builtins.str,
                 container_type: Optional[_builtins.str] = None,
                 sha1: Optional[_builtins.str] = None):
        """
        :param _builtins.str source: The full Google Cloud Storage URL where disk storage is stored
               You must provide either this property or the sourceDisk property
               but not both.
        :param _builtins.str container_type: The format used to encode and transmit the block device, which
               should be TAR. This is just a container and transmission format
               and not a runtime format. Provided by the client when the disk
               image is created.
               Default value is `TAR`.
               Possible values are: `TAR`.
        :param _builtins.str sha1: An optional SHA1 checksum of the disk image before unpackaging.
               This is provided by the client when the disk image is created.
        """
        pulumi.set(__self__, "source", source)
        if container_type is not None:
            pulumi.set(__self__, "container_type", container_type)
        if sha1 is not None:
            pulumi.set(__self__, "sha1", sha1)

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The full Google Cloud Storage URL where disk storage is stored
        You must provide either this property or the sourceDisk property
        but not both.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="containerType")
    def container_type(self) -> Optional[_builtins.str]:
        """
        The format used to encode and transmit the block device, which
        should be TAR. This is just a container and transmission format
        and not a runtime format. Provided by the client when the disk
        image is created.
        Default value is `TAR`.
        Possible values are: `TAR`.
        """
        return pulumi.get(self, "container_type")

    @_builtins.property
    @pulumi.getter
    def sha1(self) -> Optional[_builtins.str]:
        """
        An optional SHA1 checksum of the disk image before unpackaging.
        This is provided by the client when the disk image is created.
        """
        return pulumi.get(self, "sha1")


@pulumi.output_type
class ImageShieldedInstanceInitialState(dict):
    def __init__(__self__, *,
                 dbs: Optional[Sequence['outputs.ImageShieldedInstanceInitialStateDb']] = None,
                 dbxs: Optional[Sequence['outputs.ImageShieldedInstanceInitialStateDbx']] = None,
                 keks: Optional[Sequence['outputs.ImageShieldedInstanceInitialStateKek']] = None,
                 pk: Optional['outputs.ImageShieldedInstanceInitialStatePk'] = None):
        """
        :param Sequence['ImageShieldedInstanceInitialStateDbArgs'] dbs: The Key Database (db).
               Structure is documented below.
        :param Sequence['ImageShieldedInstanceInitialStateDbxArgs'] dbxs: The forbidden key database (dbx).
               Structure is documented below.
        :param Sequence['ImageShieldedInstanceInitialStateKekArgs'] keks: The Key Exchange Key (KEK).
               Structure is documented below.
        :param 'ImageShieldedInstanceInitialStatePkArgs' pk: The Platform Key (PK).
               Structure is documented below.
        """
        if dbs is not None:
            pulumi.set(__self__, "dbs", dbs)
        if dbxs is not None:
            pulumi.set(__self__, "dbxs", dbxs)
        if keks is not None:
            pulumi.set(__self__, "keks", keks)
        if pk is not None:
            pulumi.set(__self__, "pk", pk)

    @_builtins.property
    @pulumi.getter
    def dbs(self) -> Optional[Sequence['outputs.ImageShieldedInstanceInitialStateDb']]:
        """
        The Key Database (db).
        Structure is documented below.
        """
        return pulumi.get(self, "dbs")

    @_builtins.property
    @pulumi.getter
    def dbxs(self) -> Optional[Sequence['outputs.ImageShieldedInstanceInitialStateDbx']]:
        """
        The forbidden key database (dbx).
        Structure is documented below.
        """
        return pulumi.get(self, "dbxs")

    @_builtins.property
    @pulumi.getter
    def keks(self) -> Optional[Sequence['outputs.ImageShieldedInstanceInitialStateKek']]:
        """
        The Key Exchange Key (KEK).
        Structure is documented below.
        """
        return pulumi.get(self, "keks")

    @_builtins.property
    @pulumi.getter
    def pk(self) -> Optional['outputs.ImageShieldedInstanceInitialStatePk']:
        """
        The Platform Key (PK).
        Structure is documented below.
        """
        return pulumi.get(self, "pk")


@pulumi.output_type
class ImageShieldedInstanceInitialStateDb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileType":
            suggest = "file_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageShieldedInstanceInitialStateDb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageShieldedInstanceInitialStateDb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageShieldedInstanceInitialStateDb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: _builtins.str,
                 file_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str content: The raw content in the secure keys file.
               A base64-encoded string.
        :param _builtins.str file_type: The file type of source file.
        """
        pulumi.set(__self__, "content", content)
        if file_type is not None:
            pulumi.set(__self__, "file_type", file_type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        The raw content in the secure keys file.
        A base64-encoded string.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[_builtins.str]:
        """
        The file type of source file.
        """
        return pulumi.get(self, "file_type")


@pulumi.output_type
class ImageShieldedInstanceInitialStateDbx(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileType":
            suggest = "file_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageShieldedInstanceInitialStateDbx. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageShieldedInstanceInitialStateDbx.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageShieldedInstanceInitialStateDbx.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: _builtins.str,
                 file_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str content: The raw content in the secure keys file.
               A base64-encoded string.
        :param _builtins.str file_type: The file type of source file.
        """
        pulumi.set(__self__, "content", content)
        if file_type is not None:
            pulumi.set(__self__, "file_type", file_type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        The raw content in the secure keys file.
        A base64-encoded string.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[_builtins.str]:
        """
        The file type of source file.
        """
        return pulumi.get(self, "file_type")


@pulumi.output_type
class ImageShieldedInstanceInitialStateKek(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileType":
            suggest = "file_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageShieldedInstanceInitialStateKek. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageShieldedInstanceInitialStateKek.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageShieldedInstanceInitialStateKek.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: _builtins.str,
                 file_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str content: The raw content in the secure keys file.
               A base64-encoded string.
        :param _builtins.str file_type: The file type of source file.
        """
        pulumi.set(__self__, "content", content)
        if file_type is not None:
            pulumi.set(__self__, "file_type", file_type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        The raw content in the secure keys file.
        A base64-encoded string.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[_builtins.str]:
        """
        The file type of source file.
        """
        return pulumi.get(self, "file_type")


@pulumi.output_type
class ImageShieldedInstanceInitialStatePk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileType":
            suggest = "file_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageShieldedInstanceInitialStatePk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageShieldedInstanceInitialStatePk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageShieldedInstanceInitialStatePk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: _builtins.str,
                 file_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str content: The raw content in the secure keys file.
               A base64-encoded string.
        :param _builtins.str file_type: The file type of source file.
        """
        pulumi.set(__self__, "content", content)
        if file_type is not None:
            pulumi.set(__self__, "file_type", file_type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        The raw content in the secure keys file.
        A base64-encoded string.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[_builtins.str]:
        """
        The file type of source file.
        """
        return pulumi.get(self, "file_type")


@pulumi.output_type
class ImageSourceDiskEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageSourceDiskEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageSourceDiskEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageSourceDiskEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key used to decrypt this resource. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
               `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the
               given KMS key. If absent, the Compute Engine default service
               account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
               customer-supplied encryption key to either encrypt or decrypt
               this resource. You can provide either the rawKey or the rsaEncryptedKey.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key used to decrypt this resource. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
        `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the
        given KMS key. If absent, the Compute Engine default service
        account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
        customer-supplied encryption key to either encrypt or decrypt
        this resource. You can provide either the rawKey or the rsaEncryptedKey.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class ImageSourceImageEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageSourceImageEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageSourceImageEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageSourceImageEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key used to decrypt this resource. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
               `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the
               given KMS key. If absent, the Compute Engine default service
               account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
               customer-supplied encryption key to either encrypt or decrypt
               this resource. You can provide either the rawKey or the rsaEncryptedKey.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key used to decrypt this resource. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
        `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the
        given KMS key. If absent, the Compute Engine default service
        account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
        customer-supplied encryption key to either encrypt or decrypt
        this resource. You can provide either the rawKey or the rsaEncryptedKey.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class ImageSourceSnapshotEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageSourceSnapshotEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageSourceSnapshotEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageSourceSnapshotEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key used to decrypt this resource. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
               `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the
               given KMS key. If absent, the Compute Engine default service
               account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
               customer-supplied encryption key to either encrypt or decrypt
               this resource. You can provide either the rawKey or the rsaEncryptedKey.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key used to decrypt this resource. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
        `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the
        given KMS key. If absent, the Compute Engine default service
        account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
        customer-supplied encryption key to either encrypt or decrypt
        this resource. You can provide either the rawKey or the rsaEncryptedKey.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class InstanceAdvancedMachineFeatures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableNestedVirtualization":
            suggest = "enable_nested_virtualization"
        elif key == "enableUefiNetworking":
            suggest = "enable_uefi_networking"
        elif key == "performanceMonitoringUnit":
            suggest = "performance_monitoring_unit"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"
        elif key == "turboMode":
            suggest = "turbo_mode"
        elif key == "visibleCoreCount":
            suggest = "visible_core_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceAdvancedMachineFeatures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceAdvancedMachineFeatures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceAdvancedMachineFeatures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_nested_virtualization: Optional[_builtins.bool] = None,
                 enable_uefi_networking: Optional[_builtins.bool] = None,
                 performance_monitoring_unit: Optional[_builtins.str] = None,
                 threads_per_core: Optional[_builtins.int] = None,
                 turbo_mode: Optional[_builtins.str] = None,
                 visible_core_count: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enable_nested_virtualization: Defines whether the instance should have nested virtualization  enabled. Defaults to false.
        :param _builtins.bool enable_uefi_networking: Whether to enable UEFI networking for instance creation.
        :param _builtins.str performance_monitoring_unit: [The PMU](https://cloud.google.com/compute/docs/pmu-overview) is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are `STANDARD`, `ENHANCED`, and `ARCHITECTURAL`.
        :param _builtins.int threads_per_core: The number of threads per physical core. To disable [simultaneous multithreading (SMT)](https://cloud.google.com/compute/docs/instances/disabling-smt) set this to 1.
        :param _builtins.str turbo_mode: Turbo frequency mode to use for the instance. Supported modes are currently either `ALL_CORE_MAX` or unset (default).
        :param _builtins.int visible_core_count: The number of physical cores to expose to an instance. [visible cores info (VC)](https://cloud.google.com/compute/docs/instances/customize-visible-cores).
        """
        if enable_nested_virtualization is not None:
            pulumi.set(__self__, "enable_nested_virtualization", enable_nested_virtualization)
        if enable_uefi_networking is not None:
            pulumi.set(__self__, "enable_uefi_networking", enable_uefi_networking)
        if performance_monitoring_unit is not None:
            pulumi.set(__self__, "performance_monitoring_unit", performance_monitoring_unit)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)
        if turbo_mode is not None:
            pulumi.set(__self__, "turbo_mode", turbo_mode)
        if visible_core_count is not None:
            pulumi.set(__self__, "visible_core_count", visible_core_count)

    @_builtins.property
    @pulumi.getter(name="enableNestedVirtualization")
    def enable_nested_virtualization(self) -> Optional[_builtins.bool]:
        """
        Defines whether the instance should have nested virtualization  enabled. Defaults to false.
        """
        return pulumi.get(self, "enable_nested_virtualization")

    @_builtins.property
    @pulumi.getter(name="enableUefiNetworking")
    def enable_uefi_networking(self) -> Optional[_builtins.bool]:
        """
        Whether to enable UEFI networking for instance creation.
        """
        return pulumi.get(self, "enable_uefi_networking")

    @_builtins.property
    @pulumi.getter(name="performanceMonitoringUnit")
    def performance_monitoring_unit(self) -> Optional[_builtins.str]:
        """
        [The PMU](https://cloud.google.com/compute/docs/pmu-overview) is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are `STANDARD`, `ENHANCED`, and `ARCHITECTURAL`.
        """
        return pulumi.get(self, "performance_monitoring_unit")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[_builtins.int]:
        """
        The number of threads per physical core. To disable [simultaneous multithreading (SMT)](https://cloud.google.com/compute/docs/instances/disabling-smt) set this to 1.
        """
        return pulumi.get(self, "threads_per_core")

    @_builtins.property
    @pulumi.getter(name="turboMode")
    def turbo_mode(self) -> Optional[_builtins.str]:
        """
        Turbo frequency mode to use for the instance. Supported modes are currently either `ALL_CORE_MAX` or unset (default).
        """
        return pulumi.get(self, "turbo_mode")

    @_builtins.property
    @pulumi.getter(name="visibleCoreCount")
    def visible_core_count(self) -> Optional[_builtins.int]:
        """
        The number of physical cores to expose to an instance. [visible cores info (VC)](https://cloud.google.com/compute/docs/instances/customize-visible-cores).
        """
        return pulumi.get(self, "visible_core_count")


@pulumi.output_type
class InstanceAttachedDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "diskEncryptionKeyRaw":
            suggest = "disk_encryption_key_raw"
        elif key == "diskEncryptionKeyRsa":
            suggest = "disk_encryption_key_rsa"
        elif key == "diskEncryptionKeySha256":
            suggest = "disk_encryption_key_sha256"
        elif key == "diskEncryptionServiceAccount":
            suggest = "disk_encryption_service_account"
        elif key == "forceAttach":
            suggest = "force_attach"
        elif key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceAttachedDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceAttachedDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceAttachedDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: _builtins.str,
                 device_name: Optional[_builtins.str] = None,
                 disk_encryption_key_raw: Optional[_builtins.str] = None,
                 disk_encryption_key_rsa: Optional[_builtins.str] = None,
                 disk_encryption_key_sha256: Optional[_builtins.str] = None,
                 disk_encryption_service_account: Optional[_builtins.str] = None,
                 force_attach: Optional[_builtins.bool] = None,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str source: The name or self_link of the disk to attach to this instance.
        :param _builtins.str device_name: Name with which the attached disk will be accessible
               under `/dev/disk/by-id/google-*`
        :param _builtins.str disk_encryption_key_raw: A 256-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
               encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               to encrypt this disk. Only one of `kms_key_self_link`, `disk_encryption_key_rsa` and `disk_encryption_key_raw`
               may be set.
        :param _builtins.str disk_encryption_key_rsa: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to encrypt this disk. Only one of `kms_key_self_link`, `disk_encryption_key_rsa` and `disk_encryption_key_raw`
               may be set.
        :param _builtins.str disk_encryption_key_sha256: The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               encoded SHA-256 hash of the [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) that protects this resource.
        :param _builtins.str disk_encryption_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.bool force_attach: Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        :param _builtins.str kms_key_self_link: The self_link of the encryption key that is
               stored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`, `disk_encryption_key_rsa` and `disk_encryption_key_raw`
               may be set.
        :param _builtins.str mode: Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
               If you have a persistent disk with data that you want to share
               between multiple instances, detach it from any read-write instances and
               attach it to one or more instances in read-only mode.
        """
        pulumi.set(__self__, "source", source)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key_raw is not None:
            pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        if disk_encryption_key_rsa is not None:
            pulumi.set(__self__, "disk_encryption_key_rsa", disk_encryption_key_rsa)
        if disk_encryption_key_sha256 is not None:
            pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        if disk_encryption_service_account is not None:
            pulumi.set(__self__, "disk_encryption_service_account", disk_encryption_service_account)
        if force_attach is not None:
            pulumi.set(__self__, "force_attach", force_attach)
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The name or self_link of the disk to attach to this instance.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Name with which the attached disk will be accessible
        under `/dev/disk/by-id/google-*`
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[_builtins.str]:
        """
        A 256-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
        encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        to encrypt this disk. Only one of `kms_key_self_link`, `disk_encryption_key_rsa` and `disk_encryption_key_raw`
        may be set.
        """
        return pulumi.get(self, "disk_encryption_key_raw")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRsa")
    def disk_encryption_key_rsa(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to encrypt this disk. Only one of `kms_key_self_link`, `disk_encryption_key_rsa` and `disk_encryption_key_raw`
        may be set.
        """
        return pulumi.get(self, "disk_encryption_key_rsa")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[_builtins.str]:
        """
        The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        encoded SHA-256 hash of the [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) that protects this resource.
        """
        return pulumi.get(self, "disk_encryption_key_sha256")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionServiceAccount")
    def disk_encryption_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "disk_encryption_service_account")

    @_builtins.property
    @pulumi.getter(name="forceAttach")
    def force_attach(self) -> Optional[_builtins.bool]:
        """
        Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        """
        return pulumi.get(self, "force_attach")

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self_link of the encryption key that is
        stored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`, `disk_encryption_key_rsa` and `disk_encryption_key_raw`
        may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
        If you have a persistent disk with data that you want to share
        between multiple instances, detach it from any read-write instances and
        attach it to one or more instances in read-only mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class InstanceBootDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDelete":
            suggest = "auto_delete"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "diskEncryptionKeyRaw":
            suggest = "disk_encryption_key_raw"
        elif key == "diskEncryptionKeyRsa":
            suggest = "disk_encryption_key_rsa"
        elif key == "diskEncryptionKeySha256":
            suggest = "disk_encryption_key_sha256"
        elif key == "diskEncryptionServiceAccount":
            suggest = "disk_encryption_service_account"
        elif key == "forceAttach":
            suggest = "force_attach"
        elif key == "guestOsFeatures":
            suggest = "guest_os_features"
        elif key == "initializeParams":
            suggest = "initialize_params"
        elif key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceBootDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceBootDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceBootDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_delete: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 disk_encryption_key_raw: Optional[_builtins.str] = None,
                 disk_encryption_key_rsa: Optional[_builtins.str] = None,
                 disk_encryption_key_sha256: Optional[_builtins.str] = None,
                 disk_encryption_service_account: Optional[_builtins.str] = None,
                 force_attach: Optional[_builtins.bool] = None,
                 guest_os_features: Optional[Sequence[_builtins.str]] = None,
                 initialize_params: Optional['outputs.InstanceBootDiskInitializeParams'] = None,
                 interface: Optional[_builtins.str] = None,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_delete: Whether the disk will be auto-deleted when the instance
               is deleted. Defaults to true.
        :param _builtins.str device_name: Name with which attached disk will be accessible.
               On the instance, this device will be `/dev/disk/by-id/google-{{device_name}}`.
        :param _builtins.str disk_encryption_key_raw: A 256-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
               encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               to encrypt this disk. Only one of `kms_key_self_link`, `disk_encryption_key_rsa` and `disk_encryption_key_raw`
               may be set.
        :param _builtins.str disk_encryption_key_rsa: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to encrypt this disk. Only one of `kms_key_self_link`, `disk_encryption_key_rsa` and `disk_encryption_key_raw`
        :param _builtins.str disk_encryption_key_sha256: The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               encoded SHA-256 hash of the [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) that protects this resource.
        :param _builtins.str disk_encryption_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.bool force_attach: boolean field that determines whether to force attach the regional
               disk even if it's currently attached to another instance. If you try to force attach a zonal
               disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        :param Sequence[_builtins.str] guest_os_features: A list of features to enable on the guest operating system. Applicable only for bootable images. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
        :param 'InstanceBootDiskInitializeParamsArgs' initialize_params: Parameters for a new disk that will be created
               alongside the new instance. Either `initialize_params` or `source` must be set.
               Structure is documented below.
        :param _builtins.str interface: The disk interface used for attaching this disk. One of SCSI or NVME. (This field is shared with attached_disk and only used for specific cases, please don't specify this field without advice from Google.)
        :param _builtins.str kms_key_self_link: The self_link of the encryption key that is
               stored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`,
               `disk_encryption_key_rsa` and `disk_encryption_key_raw`
               may be set.
        :param _builtins.str mode: The mode in which to attach this disk, either `READ_WRITE`
               or `READ_ONLY`. If not specified, the default is to attach the disk in `READ_WRITE` mode.
        :param _builtins.str source: The name or self_link of the existing disk (such as those managed by
               `compute.Disk`) or disk image. To create an instance from a snapshot, first create a
               `compute.Disk` from a snapshot and reference it here.
        """
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key_raw is not None:
            pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        if disk_encryption_key_rsa is not None:
            pulumi.set(__self__, "disk_encryption_key_rsa", disk_encryption_key_rsa)
        if disk_encryption_key_sha256 is not None:
            pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        if disk_encryption_service_account is not None:
            pulumi.set(__self__, "disk_encryption_service_account", disk_encryption_service_account)
        if force_attach is not None:
            pulumi.set(__self__, "force_attach", force_attach)
        if guest_os_features is not None:
            pulumi.set(__self__, "guest_os_features", guest_os_features)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[_builtins.bool]:
        """
        Whether the disk will be auto-deleted when the instance
        is deleted. Defaults to true.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Name with which attached disk will be accessible.
        On the instance, this device will be `/dev/disk/by-id/google-{{device_name}}`.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[_builtins.str]:
        """
        A 256-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
        encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        to encrypt this disk. Only one of `kms_key_self_link`, `disk_encryption_key_rsa` and `disk_encryption_key_raw`
        may be set.
        """
        return pulumi.get(self, "disk_encryption_key_raw")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRsa")
    def disk_encryption_key_rsa(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to encrypt this disk. Only one of `kms_key_self_link`, `disk_encryption_key_rsa` and `disk_encryption_key_raw`
        """
        return pulumi.get(self, "disk_encryption_key_rsa")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[_builtins.str]:
        """
        The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        encoded SHA-256 hash of the [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) that protects this resource.
        """
        return pulumi.get(self, "disk_encryption_key_sha256")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionServiceAccount")
    def disk_encryption_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "disk_encryption_service_account")

    @_builtins.property
    @pulumi.getter(name="forceAttach")
    def force_attach(self) -> Optional[_builtins.bool]:
        """
        boolean field that determines whether to force attach the regional
        disk even if it's currently attached to another instance. If you try to force attach a zonal
        disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        """
        return pulumi.get(self, "force_attach")

    @_builtins.property
    @pulumi.getter(name="guestOsFeatures")
    def guest_os_features(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of features to enable on the guest operating system. Applicable only for bootable images. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
        """
        return pulumi.get(self, "guest_os_features")

    @_builtins.property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional['outputs.InstanceBootDiskInitializeParams']:
        """
        Parameters for a new disk that will be created
        alongside the new instance. Either `initialize_params` or `source` must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "initialize_params")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[_builtins.str]:
        """
        The disk interface used for attaching this disk. One of SCSI or NVME. (This field is shared with attached_disk and only used for specific cases, please don't specify this field without advice from Google.)
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self_link of the encryption key that is
        stored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`,
        `disk_encryption_key_rsa` and `disk_encryption_key_raw`
        may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The mode in which to attach this disk, either `READ_WRITE`
        or `READ_ONLY`. If not specified, the default is to attach the disk in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The name or self_link of the existing disk (such as those managed by
        `compute.Disk`) or disk image. To create an instance from a snapshot, first create a
        `compute.Disk` from a snapshot and reference it here.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class InstanceBootDiskInitializeParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableConfidentialCompute":
            suggest = "enable_confidential_compute"
        elif key == "provisionedIops":
            suggest = "provisioned_iops"
        elif key == "provisionedThroughput":
            suggest = "provisioned_throughput"
        elif key == "resourceManagerTags":
            suggest = "resource_manager_tags"
        elif key == "resourcePolicies":
            suggest = "resource_policies"
        elif key == "sourceImageEncryptionKey":
            suggest = "source_image_encryption_key"
        elif key == "sourceSnapshotEncryptionKey":
            suggest = "source_snapshot_encryption_key"
        elif key == "storagePool":
            suggest = "storage_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceBootDiskInitializeParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceBootDiskInitializeParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceBootDiskInitializeParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 architecture: Optional[_builtins.str] = None,
                 enable_confidential_compute: Optional[_builtins.bool] = None,
                 image: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 provisioned_iops: Optional[_builtins.int] = None,
                 provisioned_throughput: Optional[_builtins.int] = None,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None,
                 resource_policies: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None,
                 snapshot: Optional[_builtins.str] = None,
                 source_image_encryption_key: Optional['outputs.InstanceBootDiskInitializeParamsSourceImageEncryptionKey'] = None,
                 source_snapshot_encryption_key: Optional['outputs.InstanceBootDiskInitializeParamsSourceSnapshotEncryptionKey'] = None,
                 storage_pool: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str architecture: The architecture of the attached disk. Valid values are `ARM64` or `x86_64`.
        :param _builtins.bool enable_confidential_compute: Whether this disk is using confidential compute mode.
               Note: Only supported on hyperdisk skus, disk_encryption_key is required when setting to true.
        :param _builtins.str image: The image from which to initialize this disk. This can be
               one of: the image's `self_link`, `projects/{project}/global/images/{image}`,
               `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
               `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
               `{project}/{image}`, `{family}`, or `{image}`. If referred by family, the
               images names must include the family name. If they don't, use the
               [compute.Image data source](https://www.terraform.io/docs/providers/google/d/compute_image.html).
               For instance, the image `centos-6-v20180104` includes its family name `centos-6`.
               These images can be referred by family name here.
        :param Mapping[str, _builtins.str] labels: A set of key/value label pairs assigned to the disk. This
               field is only applicable for persistent disks.
        :param _builtins.int provisioned_iops: Indicates how many IOPS to provision for the disk.
               This sets the number of I/O operations per second that the disk can handle.
               For more details,see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
               Note: Updating currently is only supported for hyperdisk skus via disk update
               api/gcloud without the need to delete and recreate the disk, hyperdisk allows
               for an update of IOPS every 4 hours. To update your hyperdisk more frequently,
               you'll need to manually delete and recreate it.
        :param _builtins.int provisioned_throughput: Indicates how much throughput to provision for the disk.
               This sets the number of throughput mb per second that the disk can handle.
               For more details,see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
               Note: Updating currently is only supported for hyperdisk skus via disk update
               api/gcloud without the need to delete and recreate the disk, hyperdisk allows
               for an update of throughput every 4 hours. To update your hyperdisk more
               frequently, you'll need to manually delete and recreate it.
        :param Mapping[str, _builtins.str] resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        :param _builtins.str resource_policies: A list of self_links of resource policies to attach to the instance's boot disk. Modifying this list will cause the instance to recreate, so any external values are not set until the user specifies this field. Currently a max of 1 resource policy is supported.
        :param _builtins.int size: The size of the image in gigabytes. If not specified, it
               will inherit the size of its base image.
        :param _builtins.str snapshot: The snapshot from which to initialize this disk. To create a disk with a snapshot that you created, specify the snapshot name in the following format: `global/snapshots/my-backup`
        :param 'InstanceBootDiskInitializeParamsSourceImageEncryptionKeyArgs' source_image_encryption_key: Encryption key used to decrypt the given image. Structure is documented below.
        :param 'InstanceBootDiskInitializeParamsSourceSnapshotEncryptionKeyArgs' source_snapshot_encryption_key: Encryption key used to decrypt the given snapshot. Structure is documented below.
        :param _builtins.str storage_pool: The URL or the name of the storage pool in which the new disk is created.
               For example:
               * https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/storagePools/{storagePool}
               * /projects/{project}/zones/{zone}/storagePools/{storagePool}
               * /zones/{zone}/storagePools/{storagePool}
               * /{storagePool}
        :param _builtins.str type: The GCE disk type. Such as pd-standard, pd-balanced or pd-ssd.
        """
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if enable_confidential_compute is not None:
            pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if provisioned_iops is not None:
            pulumi.set(__self__, "provisioned_iops", provisioned_iops)
        if provisioned_throughput is not None:
            pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)
        if resource_policies is not None:
            pulumi.set(__self__, "resource_policies", resource_policies)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if source_image_encryption_key is not None:
            pulumi.set(__self__, "source_image_encryption_key", source_image_encryption_key)
        if source_snapshot_encryption_key is not None:
            pulumi.set(__self__, "source_snapshot_encryption_key", source_snapshot_encryption_key)
        if storage_pool is not None:
            pulumi.set(__self__, "storage_pool", storage_pool)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def architecture(self) -> Optional[_builtins.str]:
        """
        The architecture of the attached disk. Valid values are `ARM64` or `x86_64`.
        """
        return pulumi.get(self, "architecture")

    @_builtins.property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> Optional[_builtins.bool]:
        """
        Whether this disk is using confidential compute mode.
        Note: Only supported on hyperdisk skus, disk_encryption_key is required when setting to true.
        """
        return pulumi.get(self, "enable_confidential_compute")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        The image from which to initialize this disk. This can be
        one of: the image's `self_link`, `projects/{project}/global/images/{image}`,
        `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
        `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
        `{project}/{image}`, `{family}`, or `{image}`. If referred by family, the
        images names must include the family name. If they don't, use the
        [compute.Image data source](https://www.terraform.io/docs/providers/google/d/compute_image.html).
        For instance, the image `centos-6-v20180104` includes its family name `centos-6`.
        These images can be referred by family name here.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key/value label pairs assigned to the disk. This
        field is only applicable for persistent disks.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="provisionedIops")
    def provisioned_iops(self) -> Optional[_builtins.int]:
        """
        Indicates how many IOPS to provision for the disk.
        This sets the number of I/O operations per second that the disk can handle.
        For more details,see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
        Note: Updating currently is only supported for hyperdisk skus via disk update
        api/gcloud without the need to delete and recreate the disk, hyperdisk allows
        for an update of IOPS every 4 hours. To update your hyperdisk more frequently,
        you'll need to manually delete and recreate it.
        """
        return pulumi.get(self, "provisioned_iops")

    @_builtins.property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> Optional[_builtins.int]:
        """
        Indicates how much throughput to provision for the disk.
        This sets the number of throughput mb per second that the disk can handle.
        For more details,see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
        Note: Updating currently is only supported for hyperdisk skus via disk update
        api/gcloud without the need to delete and recreate the disk, hyperdisk allows
        for an update of throughput every 4 hours. To update your hyperdisk more
        frequently, you'll need to manually delete and recreate it.
        """
        return pulumi.get(self, "provisioned_throughput")

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        return pulumi.get(self, "resource_manager_tags")

    @_builtins.property
    @pulumi.getter(name="resourcePolicies")
    def resource_policies(self) -> Optional[_builtins.str]:
        """
        A list of self_links of resource policies to attach to the instance's boot disk. Modifying this list will cause the instance to recreate, so any external values are not set until the user specifies this field. Currently a max of 1 resource policy is supported.
        """
        return pulumi.get(self, "resource_policies")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        The size of the image in gigabytes. If not specified, it
        will inherit the size of its base image.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional[_builtins.str]:
        """
        The snapshot from which to initialize this disk. To create a disk with a snapshot that you created, specify the snapshot name in the following format: `global/snapshots/my-backup`
        """
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter(name="sourceImageEncryptionKey")
    def source_image_encryption_key(self) -> Optional['outputs.InstanceBootDiskInitializeParamsSourceImageEncryptionKey']:
        """
        Encryption key used to decrypt the given image. Structure is documented below.
        """
        return pulumi.get(self, "source_image_encryption_key")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshotEncryptionKey")
    def source_snapshot_encryption_key(self) -> Optional['outputs.InstanceBootDiskInitializeParamsSourceSnapshotEncryptionKey']:
        """
        Encryption key used to decrypt the given snapshot. Structure is documented below.
        """
        return pulumi.get(self, "source_snapshot_encryption_key")

    @_builtins.property
    @pulumi.getter(name="storagePool")
    def storage_pool(self) -> Optional[_builtins.str]:
        """
        The URL or the name of the storage pool in which the new disk is created.
        For example:
        * https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/storagePools/{storagePool}
        * /projects/{project}/zones/{zone}/storagePools/{storagePool}
        * /zones/{zone}/storagePools/{storagePool}
        * /{storagePool}
        """
        return pulumi.get(self, "storage_pool")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The GCE disk type. Such as pd-standard, pd-balanced or pd-ssd.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InstanceBootDiskInitializeParamsSourceImageEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceBootDiskInitializeParamsSourceImageEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceBootDiskInitializeParamsSourceImageEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceBootDiskInitializeParamsSourceImageEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str sha256: The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               encoded SHA-256 hash of the [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) that protects this resource.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        encoded SHA-256 hash of the [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class InstanceBootDiskInitializeParamsSourceSnapshotEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceBootDiskInitializeParamsSourceSnapshotEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceBootDiskInitializeParamsSourceSnapshotEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceBootDiskInitializeParamsSourceSnapshotEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self_link of the encryption key that is
               stored in Google Cloud KMS to decrypt the given image. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str raw_key: A 256-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
               encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               to decrypt the given snapshot. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt the given snapshot. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        :param _builtins.str sha256: The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               encoded SHA-256 hash of the [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) that protects this resource.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self_link of the encryption key that is
        stored in Google Cloud KMS to decrypt the given image. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        A 256-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
        encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        to decrypt the given snapshot. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt the given snapshot. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        encoded SHA-256 hash of the [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class InstanceConfidentialInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confidentialInstanceType":
            suggest = "confidential_instance_type"
        elif key == "enableConfidentialCompute":
            suggest = "enable_confidential_compute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceConfidentialInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceConfidentialInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceConfidentialInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 confidential_instance_type: Optional[_builtins.str] = None,
                 enable_confidential_compute: Optional[_builtins.bool] = None):
        """
        :param _builtins.str confidential_instance_type: Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: `SEV`, `SEV_SNP`, `TDX`. `on_host_maintenance` can be set to MIGRATE if `confidential_instance_type` is set to `SEV` and `min_cpu_platform` is set to `"AMD Milan"`. Otherwise, `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM. If `SEV_SNP`, currently `min_cpu_platform` has to be set to `"AMD Milan"` or this will fail to create the VM.
        :param _builtins.bool enable_confidential_compute: Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, `on_host_maintenance` can be set to MIGRATE if `min_cpu_platform` is set to `"AMD Milan"`. Otherwise, `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.
        """
        if confidential_instance_type is not None:
            pulumi.set(__self__, "confidential_instance_type", confidential_instance_type)
        if enable_confidential_compute is not None:
            pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @_builtins.property
    @pulumi.getter(name="confidentialInstanceType")
    def confidential_instance_type(self) -> Optional[_builtins.str]:
        """
        Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: `SEV`, `SEV_SNP`, `TDX`. `on_host_maintenance` can be set to MIGRATE if `confidential_instance_type` is set to `SEV` and `min_cpu_platform` is set to `"AMD Milan"`. Otherwise, `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM. If `SEV_SNP`, currently `min_cpu_platform` has to be set to `"AMD Milan"` or this will fail to create the VM.
        """
        return pulumi.get(self, "confidential_instance_type")

    @_builtins.property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> Optional[_builtins.bool]:
        """
        Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, `on_host_maintenance` can be set to MIGRATE if `min_cpu_platform` is set to `"AMD Milan"`. Otherwise, `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.
        """
        return pulumi.get(self, "enable_confidential_compute")


@pulumi.output_type
class InstanceFromMachineImageAdvancedMachineFeatures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableNestedVirtualization":
            suggest = "enable_nested_virtualization"
        elif key == "enableUefiNetworking":
            suggest = "enable_uefi_networking"
        elif key == "performanceMonitoringUnit":
            suggest = "performance_monitoring_unit"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"
        elif key == "turboMode":
            suggest = "turbo_mode"
        elif key == "visibleCoreCount":
            suggest = "visible_core_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageAdvancedMachineFeatures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageAdvancedMachineFeatures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageAdvancedMachineFeatures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_nested_virtualization: Optional[_builtins.bool] = None,
                 enable_uefi_networking: Optional[_builtins.bool] = None,
                 performance_monitoring_unit: Optional[_builtins.str] = None,
                 threads_per_core: Optional[_builtins.int] = None,
                 turbo_mode: Optional[_builtins.str] = None,
                 visible_core_count: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enable_nested_virtualization: Whether to enable nested virtualization or not.
        :param _builtins.bool enable_uefi_networking: Whether to enable UEFI networking for the instance.
        :param _builtins.str performance_monitoring_unit: The PMU is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are "STANDARD", "ENHANCED", and "ARCHITECTURAL".
        :param _builtins.int threads_per_core: The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
        :param _builtins.str turbo_mode: Turbo frequency mode to use for the instance. Currently supported modes is "ALL_CORE_MAX".
        :param _builtins.int visible_core_count: The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance\\'s nominal CPU count and the underlying platform\\'s SMT width.
        """
        if enable_nested_virtualization is not None:
            pulumi.set(__self__, "enable_nested_virtualization", enable_nested_virtualization)
        if enable_uefi_networking is not None:
            pulumi.set(__self__, "enable_uefi_networking", enable_uefi_networking)
        if performance_monitoring_unit is not None:
            pulumi.set(__self__, "performance_monitoring_unit", performance_monitoring_unit)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)
        if turbo_mode is not None:
            pulumi.set(__self__, "turbo_mode", turbo_mode)
        if visible_core_count is not None:
            pulumi.set(__self__, "visible_core_count", visible_core_count)

    @_builtins.property
    @pulumi.getter(name="enableNestedVirtualization")
    def enable_nested_virtualization(self) -> Optional[_builtins.bool]:
        """
        Whether to enable nested virtualization or not.
        """
        return pulumi.get(self, "enable_nested_virtualization")

    @_builtins.property
    @pulumi.getter(name="enableUefiNetworking")
    def enable_uefi_networking(self) -> Optional[_builtins.bool]:
        """
        Whether to enable UEFI networking for the instance.
        """
        return pulumi.get(self, "enable_uefi_networking")

    @_builtins.property
    @pulumi.getter(name="performanceMonitoringUnit")
    def performance_monitoring_unit(self) -> Optional[_builtins.str]:
        """
        The PMU is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are "STANDARD", "ENHANCED", and "ARCHITECTURAL".
        """
        return pulumi.get(self, "performance_monitoring_unit")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[_builtins.int]:
        """
        The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
        """
        return pulumi.get(self, "threads_per_core")

    @_builtins.property
    @pulumi.getter(name="turboMode")
    def turbo_mode(self) -> Optional[_builtins.str]:
        """
        Turbo frequency mode to use for the instance. Currently supported modes is "ALL_CORE_MAX".
        """
        return pulumi.get(self, "turbo_mode")

    @_builtins.property
    @pulumi.getter(name="visibleCoreCount")
    def visible_core_count(self) -> Optional[_builtins.int]:
        """
        The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance\\'s nominal CPU count and the underlying platform\\'s SMT width.
        """
        return pulumi.get(self, "visible_core_count")


@pulumi.output_type
class InstanceFromMachineImageAttachedDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "diskEncryptionKeyRaw":
            suggest = "disk_encryption_key_raw"
        elif key == "diskEncryptionKeyRsa":
            suggest = "disk_encryption_key_rsa"
        elif key == "diskEncryptionKeySha256":
            suggest = "disk_encryption_key_sha256"
        elif key == "diskEncryptionServiceAccount":
            suggest = "disk_encryption_service_account"
        elif key == "forceAttach":
            suggest = "force_attach"
        elif key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageAttachedDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageAttachedDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageAttachedDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: _builtins.str,
                 device_name: Optional[_builtins.str] = None,
                 disk_encryption_key_raw: Optional[_builtins.str] = None,
                 disk_encryption_key_rsa: Optional[_builtins.str] = None,
                 disk_encryption_key_sha256: Optional[_builtins.str] = None,
                 disk_encryption_service_account: Optional[_builtins.str] = None,
                 force_attach: Optional[_builtins.bool] = None,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str source: The name or self_link of the disk attached to this instance.
        :param _builtins.str device_name: Name with which the attached disk is accessible under /dev/disk/by-id/
        :param _builtins.str disk_encryption_key_raw: A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        :param _builtins.str disk_encryption_key_rsa: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        :param _builtins.str disk_encryption_key_sha256: The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
        :param _builtins.str disk_encryption_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
        :param _builtins.bool force_attach: Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        :param _builtins.str kms_key_self_link: The self_link of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        :param _builtins.str mode: Read/write mode for the disk. One of "READ_ONLY" or "READ_WRITE".
        """
        pulumi.set(__self__, "source", source)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key_raw is not None:
            pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        if disk_encryption_key_rsa is not None:
            pulumi.set(__self__, "disk_encryption_key_rsa", disk_encryption_key_rsa)
        if disk_encryption_key_sha256 is not None:
            pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        if disk_encryption_service_account is not None:
            pulumi.set(__self__, "disk_encryption_service_account", disk_encryption_service_account)
        if force_attach is not None:
            pulumi.set(__self__, "force_attach", force_attach)
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The name or self_link of the disk attached to this instance.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Name with which the attached disk is accessible under /dev/disk/by-id/
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[_builtins.str]:
        """
        A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        """
        return pulumi.get(self, "disk_encryption_key_raw")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRsa")
    def disk_encryption_key_rsa(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        """
        return pulumi.get(self, "disk_encryption_key_rsa")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[_builtins.str]:
        """
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
        """
        return pulumi.get(self, "disk_encryption_key_sha256")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionServiceAccount")
    def disk_encryption_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
        """
        return pulumi.get(self, "disk_encryption_service_account")

    @_builtins.property
    @pulumi.getter(name="forceAttach")
    def force_attach(self) -> Optional[_builtins.bool]:
        """
        Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        """
        return pulumi.get(self, "force_attach")

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self_link of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Read/write mode for the disk. One of "READ_ONLY" or "READ_WRITE".
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class InstanceFromMachineImageBootDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDelete":
            suggest = "auto_delete"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "diskEncryptionKeyRaw":
            suggest = "disk_encryption_key_raw"
        elif key == "diskEncryptionKeyRsa":
            suggest = "disk_encryption_key_rsa"
        elif key == "diskEncryptionKeySha256":
            suggest = "disk_encryption_key_sha256"
        elif key == "diskEncryptionServiceAccount":
            suggest = "disk_encryption_service_account"
        elif key == "forceAttach":
            suggest = "force_attach"
        elif key == "guestOsFeatures":
            suggest = "guest_os_features"
        elif key == "initializeParams":
            suggest = "initialize_params"
        elif key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageBootDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageBootDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageBootDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_delete: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 disk_encryption_key_raw: Optional[_builtins.str] = None,
                 disk_encryption_key_rsa: Optional[_builtins.str] = None,
                 disk_encryption_key_sha256: Optional[_builtins.str] = None,
                 disk_encryption_service_account: Optional[_builtins.str] = None,
                 force_attach: Optional[_builtins.bool] = None,
                 guest_os_features: Optional[Sequence[_builtins.str]] = None,
                 initialize_params: Optional['outputs.InstanceFromMachineImageBootDiskInitializeParams'] = None,
                 interface: Optional[_builtins.str] = None,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_delete: Whether the disk will be auto-deleted when the instance is deleted.
        :param _builtins.str device_name: Name with which attached disk will be accessible under /dev/disk/by-id/
        :param _builtins.str disk_encryption_key_raw: A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        :param _builtins.str disk_encryption_key_rsa: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        :param _builtins.str disk_encryption_key_sha256: The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
        :param _builtins.str disk_encryption_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
        :param _builtins.bool force_attach: Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        :param Sequence[_builtins.str] guest_os_features: A list of features to enable on the guest operating system. Applicable only for bootable images.
        :param 'InstanceFromMachineImageBootDiskInitializeParamsArgs' initialize_params: Parameters with which a disk was created alongside the instance.
        :param _builtins.str interface: The disk interface used for attaching this disk. One of SCSI or NVME. (This field is shared with attached_disk and only used for specific cases, please don't specify this field without advice from Google.)
        :param _builtins.str kms_key_self_link: The self_link of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        :param _builtins.str mode: Read/write mode for the disk. One of "READ_ONLY" or "READ_WRITE".
        :param _builtins.str source: The name or self_link of the disk attached to this instance.
        """
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key_raw is not None:
            pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        if disk_encryption_key_rsa is not None:
            pulumi.set(__self__, "disk_encryption_key_rsa", disk_encryption_key_rsa)
        if disk_encryption_key_sha256 is not None:
            pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        if disk_encryption_service_account is not None:
            pulumi.set(__self__, "disk_encryption_service_account", disk_encryption_service_account)
        if force_attach is not None:
            pulumi.set(__self__, "force_attach", force_attach)
        if guest_os_features is not None:
            pulumi.set(__self__, "guest_os_features", guest_os_features)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[_builtins.bool]:
        """
        Whether the disk will be auto-deleted when the instance is deleted.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Name with which attached disk will be accessible under /dev/disk/by-id/
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[_builtins.str]:
        """
        A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        """
        return pulumi.get(self, "disk_encryption_key_raw")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRsa")
    def disk_encryption_key_rsa(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        """
        return pulumi.get(self, "disk_encryption_key_rsa")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[_builtins.str]:
        """
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
        """
        return pulumi.get(self, "disk_encryption_key_sha256")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionServiceAccount")
    def disk_encryption_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
        """
        return pulumi.get(self, "disk_encryption_service_account")

    @_builtins.property
    @pulumi.getter(name="forceAttach")
    def force_attach(self) -> Optional[_builtins.bool]:
        """
        Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        """
        return pulumi.get(self, "force_attach")

    @_builtins.property
    @pulumi.getter(name="guestOsFeatures")
    def guest_os_features(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of features to enable on the guest operating system. Applicable only for bootable images.
        """
        return pulumi.get(self, "guest_os_features")

    @_builtins.property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional['outputs.InstanceFromMachineImageBootDiskInitializeParams']:
        """
        Parameters with which a disk was created alongside the instance.
        """
        return pulumi.get(self, "initialize_params")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[_builtins.str]:
        """
        The disk interface used for attaching this disk. One of SCSI or NVME. (This field is shared with attached_disk and only used for specific cases, please don't specify this field without advice from Google.)
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self_link of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Read/write mode for the disk. One of "READ_ONLY" or "READ_WRITE".
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The name or self_link of the disk attached to this instance.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class InstanceFromMachineImageBootDiskInitializeParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableConfidentialCompute":
            suggest = "enable_confidential_compute"
        elif key == "provisionedIops":
            suggest = "provisioned_iops"
        elif key == "provisionedThroughput":
            suggest = "provisioned_throughput"
        elif key == "resourceManagerTags":
            suggest = "resource_manager_tags"
        elif key == "resourcePolicies":
            suggest = "resource_policies"
        elif key == "sourceImageEncryptionKey":
            suggest = "source_image_encryption_key"
        elif key == "sourceSnapshotEncryptionKey":
            suggest = "source_snapshot_encryption_key"
        elif key == "storagePool":
            suggest = "storage_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageBootDiskInitializeParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageBootDiskInitializeParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageBootDiskInitializeParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 architecture: Optional[_builtins.str] = None,
                 enable_confidential_compute: Optional[_builtins.bool] = None,
                 image: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 provisioned_iops: Optional[_builtins.int] = None,
                 provisioned_throughput: Optional[_builtins.int] = None,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None,
                 resource_policies: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None,
                 snapshot: Optional[_builtins.str] = None,
                 source_image_encryption_key: Optional['outputs.InstanceFromMachineImageBootDiskInitializeParamsSourceImageEncryptionKey'] = None,
                 source_snapshot_encryption_key: Optional['outputs.InstanceFromMachineImageBootDiskInitializeParamsSourceSnapshotEncryptionKey'] = None,
                 storage_pool: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str architecture: The architecture of the disk. One of "X86_64" or "ARM64".
        :param _builtins.bool enable_confidential_compute: A flag to enable confidential compute mode on boot disk
        :param _builtins.str image: The image from which this disk was initialised.
        :param Mapping[str, _builtins.str] labels: A set of key/value label pairs assigned to the disk.
        :param _builtins.int provisioned_iops: Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle.
        :param _builtins.int provisioned_throughput: Indicates how much throughput to provision for the disk. This sets the number of throughput mb per second that the disk can handle.
        :param Mapping[str, _builtins.str] resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        :param _builtins.str resource_policies: A list of self_links of resource policies to attach to the instance's boot disk. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.
        :param _builtins.int size: The size of the image in gigabytes.
        :param _builtins.str snapshot: The snapshot from which this disk was initialised.
        :param 'InstanceFromMachineImageBootDiskInitializeParamsSourceImageEncryptionKeyArgs' source_image_encryption_key: The encryption key used to decrypt the source image.
        :param 'InstanceFromMachineImageBootDiskInitializeParamsSourceSnapshotEncryptionKeyArgs' source_snapshot_encryption_key: The encryption key used to decrypt the source snapshot.
        :param _builtins.str storage_pool: The URL of the storage pool in which the new disk is created
        :param _builtins.str type: The Google Compute Engine disk type. Such as pd-standard, pd-ssd or pd-balanced.
        """
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if enable_confidential_compute is not None:
            pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if provisioned_iops is not None:
            pulumi.set(__self__, "provisioned_iops", provisioned_iops)
        if provisioned_throughput is not None:
            pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)
        if resource_policies is not None:
            pulumi.set(__self__, "resource_policies", resource_policies)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if source_image_encryption_key is not None:
            pulumi.set(__self__, "source_image_encryption_key", source_image_encryption_key)
        if source_snapshot_encryption_key is not None:
            pulumi.set(__self__, "source_snapshot_encryption_key", source_snapshot_encryption_key)
        if storage_pool is not None:
            pulumi.set(__self__, "storage_pool", storage_pool)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def architecture(self) -> Optional[_builtins.str]:
        """
        The architecture of the disk. One of "X86_64" or "ARM64".
        """
        return pulumi.get(self, "architecture")

    @_builtins.property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> Optional[_builtins.bool]:
        """
        A flag to enable confidential compute mode on boot disk
        """
        return pulumi.get(self, "enable_confidential_compute")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        The image from which this disk was initialised.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key/value label pairs assigned to the disk.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="provisionedIops")
    def provisioned_iops(self) -> Optional[_builtins.int]:
        """
        Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle.
        """
        return pulumi.get(self, "provisioned_iops")

    @_builtins.property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> Optional[_builtins.int]:
        """
        Indicates how much throughput to provision for the disk. This sets the number of throughput mb per second that the disk can handle.
        """
        return pulumi.get(self, "provisioned_throughput")

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        return pulumi.get(self, "resource_manager_tags")

    @_builtins.property
    @pulumi.getter(name="resourcePolicies")
    def resource_policies(self) -> Optional[_builtins.str]:
        """
        A list of self_links of resource policies to attach to the instance's boot disk. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.
        """
        return pulumi.get(self, "resource_policies")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        The size of the image in gigabytes.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional[_builtins.str]:
        """
        The snapshot from which this disk was initialised.
        """
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter(name="sourceImageEncryptionKey")
    def source_image_encryption_key(self) -> Optional['outputs.InstanceFromMachineImageBootDiskInitializeParamsSourceImageEncryptionKey']:
        """
        The encryption key used to decrypt the source image.
        """
        return pulumi.get(self, "source_image_encryption_key")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshotEncryptionKey")
    def source_snapshot_encryption_key(self) -> Optional['outputs.InstanceFromMachineImageBootDiskInitializeParamsSourceSnapshotEncryptionKey']:
        """
        The encryption key used to decrypt the source snapshot.
        """
        return pulumi.get(self, "source_snapshot_encryption_key")

    @_builtins.property
    @pulumi.getter(name="storagePool")
    def storage_pool(self) -> Optional[_builtins.str]:
        """
        The URL of the storage pool in which the new disk is created
        """
        return pulumi.get(self, "storage_pool")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The Google Compute Engine disk type. Such as pd-standard, pd-ssd or pd-balanced.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InstanceFromMachineImageBootDiskInitializeParamsSourceImageEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageBootDiskInitializeParamsSourceImageEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageBootDiskInitializeParamsSourceImageEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageBootDiskInitializeParamsSourceImageEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str sha256: The SHA256 hash of the encryption key used to encrypt this disk.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        The SHA256 hash of the encryption key used to encrypt this disk.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class InstanceFromMachineImageBootDiskInitializeParamsSourceSnapshotEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageBootDiskInitializeParamsSourceSnapshotEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageBootDiskInitializeParamsSourceSnapshotEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageBootDiskInitializeParamsSourceSnapshotEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str sha256: The SHA256 hash of the encryption key used to encrypt this disk.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        The SHA256 hash of the encryption key used to encrypt this disk.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class InstanceFromMachineImageConfidentialInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confidentialInstanceType":
            suggest = "confidential_instance_type"
        elif key == "enableConfidentialCompute":
            suggest = "enable_confidential_compute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageConfidentialInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageConfidentialInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageConfidentialInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 confidential_instance_type: Optional[_builtins.str] = None,
                 enable_confidential_compute: Optional[_builtins.bool] = None):
        """
        :param _builtins.str confidential_instance_type: The confidential computing technology the instance uses.
               								SEV is an AMD feature. TDX is an Intel feature. One of the following
               								values is required: SEV, SEV_SNP, TDX. If SEV_SNP, min_cpu_platform =
               								"AMD Milan" is currently required.
        :param _builtins.bool enable_confidential_compute: Defines whether the instance should have confidential compute enabled. Field will be deprecated in a future release
        """
        if confidential_instance_type is not None:
            pulumi.set(__self__, "confidential_instance_type", confidential_instance_type)
        if enable_confidential_compute is not None:
            pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @_builtins.property
    @pulumi.getter(name="confidentialInstanceType")
    def confidential_instance_type(self) -> Optional[_builtins.str]:
        """
        The confidential computing technology the instance uses.
        								SEV is an AMD feature. TDX is an Intel feature. One of the following
        								values is required: SEV, SEV_SNP, TDX. If SEV_SNP, min_cpu_platform =
        								"AMD Milan" is currently required.
        """
        return pulumi.get(self, "confidential_instance_type")

    @_builtins.property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> Optional[_builtins.bool]:
        """
        Defines whether the instance should have confidential compute enabled. Field will be deprecated in a future release
        """
        return pulumi.get(self, "enable_confidential_compute")


@pulumi.output_type
class InstanceFromMachineImageGuestAccelerator(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int count: The number of the guest accelerator cards exposed to this instance.
        :param _builtins.str type: The accelerator type resource exposed to this instance. E.g. nvidia-tesla-k80.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The accelerator type resource exposed to this instance. E.g. nvidia-tesla-k80.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InstanceFromMachineImageInstanceEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageInstanceEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageInstanceEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageInstanceEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str sha256: The SHA256 hash of the customer's encryption key.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        The SHA256 hash of the customer's encryption key.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class InstanceFromMachineImageNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConfigs":
            suggest = "access_configs"
        elif key == "aliasIpRanges":
            suggest = "alias_ip_ranges"
        elif key == "internalIpv6PrefixLength":
            suggest = "internal_ipv6_prefix_length"
        elif key == "ipv6AccessConfigs":
            suggest = "ipv6_access_configs"
        elif key == "ipv6AccessType":
            suggest = "ipv6_access_type"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "networkAttachment":
            suggest = "network_attachment"
        elif key == "networkIp":
            suggest = "network_ip"
        elif key == "nicType":
            suggest = "nic_type"
        elif key == "queueCount":
            suggest = "queue_count"
        elif key == "securityPolicy":
            suggest = "security_policy"
        elif key == "stackType":
            suggest = "stack_type"
        elif key == "subnetworkProject":
            suggest = "subnetwork_project"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_configs: Optional[Sequence['outputs.InstanceFromMachineImageNetworkInterfaceAccessConfig']] = None,
                 alias_ip_ranges: Optional[Sequence['outputs.InstanceFromMachineImageNetworkInterfaceAliasIpRange']] = None,
                 internal_ipv6_prefix_length: Optional[_builtins.int] = None,
                 ipv6_access_configs: Optional[Sequence['outputs.InstanceFromMachineImageNetworkInterfaceIpv6AccessConfig']] = None,
                 ipv6_access_type: Optional[_builtins.str] = None,
                 ipv6_address: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None,
                 network_attachment: Optional[_builtins.str] = None,
                 network_ip: Optional[_builtins.str] = None,
                 nic_type: Optional[_builtins.str] = None,
                 queue_count: Optional[_builtins.int] = None,
                 security_policy: Optional[_builtins.str] = None,
                 stack_type: Optional[_builtins.str] = None,
                 subnetwork: Optional[_builtins.str] = None,
                 subnetwork_project: Optional[_builtins.str] = None):
        """
        :param Sequence['InstanceFromMachineImageNetworkInterfaceAccessConfigArgs'] access_configs: Access configurations, i.e. IPs via which this instance can be accessed via the Internet.
        :param Sequence['InstanceFromMachineImageNetworkInterfaceAliasIpRangeArgs'] alias_ip_ranges: An array of alias IP ranges for this network interface.
        :param _builtins.int internal_ipv6_prefix_length: The prefix length of the primary internal IPv6 range.
        :param Sequence['InstanceFromMachineImageNetworkInterfaceIpv6AccessConfigArgs'] ipv6_access_configs: An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
        :param _builtins.str ipv6_access_type: One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
        :param _builtins.str ipv6_address: An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        :param _builtins.str name: A unique name for the resource, required by GCE.
               Changing this forces a new resource to be created.
        :param _builtins.str network: The name or self_link of the network attached to this interface.
        :param _builtins.str network_attachment: The URL of the network attachment that this interface should connect to in the following format: projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}.
        :param _builtins.str network_ip: The private IP address assigned to the instance.
        :param _builtins.str nic_type: The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET, IDPF, MRDMA, and IRDMA
        :param _builtins.int queue_count: The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        :param _builtins.str security_policy: A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        :param _builtins.str stack_type: The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
        :param _builtins.str subnetwork: The name or self_link of the subnetwork attached to this interface.
        :param _builtins.str subnetwork_project: The project in which the subnetwork belongs.
        """
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if alias_ip_ranges is not None:
            pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        if internal_ipv6_prefix_length is not None:
            pulumi.set(__self__, "internal_ipv6_prefix_length", internal_ipv6_prefix_length)
        if ipv6_access_configs is not None:
            pulumi.set(__self__, "ipv6_access_configs", ipv6_access_configs)
        if ipv6_access_type is not None:
            pulumi.set(__self__, "ipv6_access_type", ipv6_access_type)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_attachment is not None:
            pulumi.set(__self__, "network_attachment", network_attachment)
        if network_ip is not None:
            pulumi.set(__self__, "network_ip", network_ip)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if queue_count is not None:
            pulumi.set(__self__, "queue_count", queue_count)
        if security_policy is not None:
            pulumi.set(__self__, "security_policy", security_policy)
        if stack_type is not None:
            pulumi.set(__self__, "stack_type", stack_type)
        if subnetwork is not None:
            pulumi.set(__self__, "subnetwork", subnetwork)
        if subnetwork_project is not None:
            pulumi.set(__self__, "subnetwork_project", subnetwork_project)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.InstanceFromMachineImageNetworkInterfaceAccessConfig']]:
        """
        Access configurations, i.e. IPs via which this instance can be accessed via the Internet.
        """
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[Sequence['outputs.InstanceFromMachineImageNetworkInterfaceAliasIpRange']]:
        """
        An array of alias IP ranges for this network interface.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="internalIpv6PrefixLength")
    def internal_ipv6_prefix_length(self) -> Optional[_builtins.int]:
        """
        The prefix length of the primary internal IPv6 range.
        """
        return pulumi.get(self, "internal_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessConfigs")
    def ipv6_access_configs(self) -> Optional[Sequence['outputs.InstanceFromMachineImageNetworkInterfaceIpv6AccessConfig']]:
        """
        An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
        """
        return pulumi.get(self, "ipv6_access_configs")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessType")
    def ipv6_access_type(self) -> Optional[_builtins.str]:
        """
        One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
        """
        return pulumi.get(self, "ipv6_access_type")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[_builtins.str]:
        """
        An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A unique name for the resource, required by GCE.
        Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        The name or self_link of the network attached to this interface.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="networkAttachment")
    def network_attachment(self) -> Optional[_builtins.str]:
        """
        The URL of the network attachment that this interface should connect to in the following format: projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}.
        """
        return pulumi.get(self, "network_attachment")

    @_builtins.property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> Optional[_builtins.str]:
        """
        The private IP address assigned to the instance.
        """
        return pulumi.get(self, "network_ip")

    @_builtins.property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[_builtins.str]:
        """
        The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET, IDPF, MRDMA, and IRDMA
        """
        return pulumi.get(self, "nic_type")

    @_builtins.property
    @pulumi.getter(name="queueCount")
    def queue_count(self) -> Optional[_builtins.int]:
        """
        The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        """
        return pulumi.get(self, "queue_count")

    @_builtins.property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> Optional[_builtins.str]:
        """
        A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        return pulumi.get(self, "security_policy")

    @_builtins.property
    @pulumi.getter(name="stackType")
    def stack_type(self) -> Optional[_builtins.str]:
        """
        The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
        """
        return pulumi.get(self, "stack_type")

    @_builtins.property
    @pulumi.getter
    def subnetwork(self) -> Optional[_builtins.str]:
        """
        The name or self_link of the subnetwork attached to this interface.
        """
        return pulumi.get(self, "subnetwork")

    @_builtins.property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> Optional[_builtins.str]:
        """
        The project in which the subnetwork belongs.
        """
        return pulumi.get(self, "subnetwork_project")


@pulumi.output_type
class InstanceFromMachineImageNetworkInterfaceAccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "natIp":
            suggest = "nat_ip"
        elif key == "networkTier":
            suggest = "network_tier"
        elif key == "publicPtrDomainName":
            suggest = "public_ptr_domain_name"
        elif key == "securityPolicy":
            suggest = "security_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageNetworkInterfaceAccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageNetworkInterfaceAccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageNetworkInterfaceAccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nat_ip: Optional[_builtins.str] = None,
                 network_tier: Optional[_builtins.str] = None,
                 public_ptr_domain_name: Optional[_builtins.str] = None,
                 security_policy: Optional[_builtins.str] = None):
        """
        :param _builtins.str nat_ip: The IP address that is be 1:1 mapped to the instance's network ip.
        :param _builtins.str network_tier: The networking tier used for configuring this instance. One of PREMIUM or STANDARD.
        :param _builtins.str public_ptr_domain_name: The DNS domain name for the public PTR record.
        :param _builtins.str security_policy: A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        if nat_ip is not None:
            pulumi.set(__self__, "nat_ip", nat_ip)
        if network_tier is not None:
            pulumi.set(__self__, "network_tier", network_tier)
        if public_ptr_domain_name is not None:
            pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)
        if security_policy is not None:
            pulumi.set(__self__, "security_policy", security_policy)

    @_builtins.property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> Optional[_builtins.str]:
        """
        The IP address that is be 1:1 mapped to the instance's network ip.
        """
        return pulumi.get(self, "nat_ip")

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> Optional[_builtins.str]:
        """
        The networking tier used for configuring this instance. One of PREMIUM or STANDARD.
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[_builtins.str]:
        """
        The DNS domain name for the public PTR record.
        """
        return pulumi.get(self, "public_ptr_domain_name")

    @_builtins.property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> Optional[_builtins.str]:
        """
        A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        return pulumi.get(self, "security_policy")


@pulumi.output_type
class InstanceFromMachineImageNetworkInterfaceAliasIpRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipCidrRange":
            suggest = "ip_cidr_range"
        elif key == "subnetworkRangeName":
            suggest = "subnetwork_range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageNetworkInterfaceAliasIpRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageNetworkInterfaceAliasIpRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageNetworkInterfaceAliasIpRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_cidr_range: _builtins.str,
                 subnetwork_range_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip_cidr_range: The IP CIDR range represented by this alias IP range.
        :param _builtins.str subnetwork_range_name: The subnetwork secondary range name specifying the secondary range from which to allocate the IP CIDR range for this alias IP range.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        if subnetwork_range_name is not None:
            pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @_builtins.property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> _builtins.str:
        """
        The IP CIDR range represented by this alias IP range.
        """
        return pulumi.get(self, "ip_cidr_range")

    @_builtins.property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> Optional[_builtins.str]:
        """
        The subnetwork secondary range name specifying the secondary range from which to allocate the IP CIDR range for this alias IP range.
        """
        return pulumi.get(self, "subnetwork_range_name")


@pulumi.output_type
class InstanceFromMachineImageNetworkInterfaceIpv6AccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkTier":
            suggest = "network_tier"
        elif key == "externalIpv6":
            suggest = "external_ipv6"
        elif key == "externalIpv6PrefixLength":
            suggest = "external_ipv6_prefix_length"
        elif key == "publicPtrDomainName":
            suggest = "public_ptr_domain_name"
        elif key == "securityPolicy":
            suggest = "security_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageNetworkInterfaceIpv6AccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageNetworkInterfaceIpv6AccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageNetworkInterfaceIpv6AccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_tier: _builtins.str,
                 external_ipv6: Optional[_builtins.str] = None,
                 external_ipv6_prefix_length: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 public_ptr_domain_name: Optional[_builtins.str] = None,
                 security_policy: Optional[_builtins.str] = None):
        """
        :param _builtins.str network_tier: The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
        :param _builtins.str external_ipv6: The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. To use a static external IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
        :param _builtins.str external_ipv6_prefix_length: The prefix length of the external IPv6 range.
        :param _builtins.str name: A unique name for the resource, required by GCE.
               Changing this forces a new resource to be created.
        :param _builtins.str public_ptr_domain_name: The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
        :param _builtins.str security_policy: A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        pulumi.set(__self__, "network_tier", network_tier)
        if external_ipv6 is not None:
            pulumi.set(__self__, "external_ipv6", external_ipv6)
        if external_ipv6_prefix_length is not None:
            pulumi.set(__self__, "external_ipv6_prefix_length", external_ipv6_prefix_length)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ptr_domain_name is not None:
            pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)
        if security_policy is not None:
            pulumi.set(__self__, "security_policy", security_policy)

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> _builtins.str:
        """
        The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="externalIpv6")
    def external_ipv6(self) -> Optional[_builtins.str]:
        """
        The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. To use a static external IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
        """
        return pulumi.get(self, "external_ipv6")

    @_builtins.property
    @pulumi.getter(name="externalIpv6PrefixLength")
    def external_ipv6_prefix_length(self) -> Optional[_builtins.str]:
        """
        The prefix length of the external IPv6 range.
        """
        return pulumi.get(self, "external_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A unique name for the resource, required by GCE.
        Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[_builtins.str]:
        """
        The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
        """
        return pulumi.get(self, "public_ptr_domain_name")

    @_builtins.property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> Optional[_builtins.str]:
        """
        A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        return pulumi.get(self, "security_policy")


@pulumi.output_type
class InstanceFromMachineImageNetworkPerformanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalEgressBandwidthTier":
            suggest = "total_egress_bandwidth_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageNetworkPerformanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageNetworkPerformanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageNetworkPerformanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_egress_bandwidth_tier: _builtins.str):
        """
        :param _builtins.str total_egress_bandwidth_tier: The egress bandwidth tier to enable. Possible values:TIER_1, DEFAULT
        """
        pulumi.set(__self__, "total_egress_bandwidth_tier", total_egress_bandwidth_tier)

    @_builtins.property
    @pulumi.getter(name="totalEgressBandwidthTier")
    def total_egress_bandwidth_tier(self) -> _builtins.str:
        """
        The egress bandwidth tier to enable. Possible values:TIER_1, DEFAULT
        """
        return pulumi.get(self, "total_egress_bandwidth_tier")


@pulumi.output_type
class InstanceFromMachineImageParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class InstanceFromMachineImageReservationAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "specificReservation":
            suggest = "specific_reservation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageReservationAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageReservationAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageReservationAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 specific_reservation: Optional['outputs.InstanceFromMachineImageReservationAffinitySpecificReservation'] = None):
        """
        :param _builtins.str type: The type of reservation from which this instance can consume resources.
        :param 'InstanceFromMachineImageReservationAffinitySpecificReservationArgs' specific_reservation: Specifies the label selector for the reservation to use.
        """
        pulumi.set(__self__, "type", type)
        if specific_reservation is not None:
            pulumi.set(__self__, "specific_reservation", specific_reservation)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of reservation from which this instance can consume resources.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="specificReservation")
    def specific_reservation(self) -> Optional['outputs.InstanceFromMachineImageReservationAffinitySpecificReservation']:
        """
        Specifies the label selector for the reservation to use.
        """
        return pulumi.get(self, "specific_reservation")


@pulumi.output_type
class InstanceFromMachineImageReservationAffinitySpecificReservation(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
        :param Sequence[_builtins.str] values: Corresponds to the label values of a reservation resource.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Corresponds to the label values of a reservation resource.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class InstanceFromMachineImageScheduling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automaticRestart":
            suggest = "automatic_restart"
        elif key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "gracefulShutdown":
            suggest = "graceful_shutdown"
        elif key == "hostErrorTimeoutSeconds":
            suggest = "host_error_timeout_seconds"
        elif key == "instanceTerminationAction":
            suggest = "instance_termination_action"
        elif key == "localSsdRecoveryTimeout":
            suggest = "local_ssd_recovery_timeout"
        elif key == "maintenanceInterval":
            suggest = "maintenance_interval"
        elif key == "maxRunDuration":
            suggest = "max_run_duration"
        elif key == "minNodeCpus":
            suggest = "min_node_cpus"
        elif key == "nodeAffinities":
            suggest = "node_affinities"
        elif key == "onHostMaintenance":
            suggest = "on_host_maintenance"
        elif key == "onInstanceStopAction":
            suggest = "on_instance_stop_action"
        elif key == "provisioningModel":
            suggest = "provisioning_model"
        elif key == "skipGuestOsShutdown":
            suggest = "skip_guest_os_shutdown"
        elif key == "terminationTime":
            suggest = "termination_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageScheduling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageScheduling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageScheduling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automatic_restart: Optional[_builtins.bool] = None,
                 availability_domain: Optional[_builtins.int] = None,
                 graceful_shutdown: Optional['outputs.InstanceFromMachineImageSchedulingGracefulShutdown'] = None,
                 host_error_timeout_seconds: Optional[_builtins.int] = None,
                 instance_termination_action: Optional[_builtins.str] = None,
                 local_ssd_recovery_timeout: Optional['outputs.InstanceFromMachineImageSchedulingLocalSsdRecoveryTimeout'] = None,
                 maintenance_interval: Optional[_builtins.str] = None,
                 max_run_duration: Optional['outputs.InstanceFromMachineImageSchedulingMaxRunDuration'] = None,
                 min_node_cpus: Optional[_builtins.int] = None,
                 node_affinities: Optional[Sequence['outputs.InstanceFromMachineImageSchedulingNodeAffinity']] = None,
                 on_host_maintenance: Optional[_builtins.str] = None,
                 on_instance_stop_action: Optional['outputs.InstanceFromMachineImageSchedulingOnInstanceStopAction'] = None,
                 preemptible: Optional[_builtins.bool] = None,
                 provisioning_model: Optional[_builtins.str] = None,
                 skip_guest_os_shutdown: Optional[_builtins.bool] = None,
                 termination_time: Optional[_builtins.str] = None):
        """
        :param _builtins.bool automatic_restart: Specifies if the instance should be restarted if it was terminated by Compute Engine (not a user).
        :param _builtins.int availability_domain: Specifies the availability domain, which this instance should be scheduled on.
        :param 'InstanceFromMachineImageSchedulingGracefulShutdownArgs' graceful_shutdown: Settings for the instance to perform a graceful shutdown.
        :param _builtins.int host_error_timeout_seconds: Specify the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
        :param _builtins.str instance_termination_action: Specifies the action GCE should take when SPOT VM is preempted.
        :param 'InstanceFromMachineImageSchedulingLocalSsdRecoveryTimeoutArgs' local_ssd_recovery_timeout: Specifies the maximum amount of time a Local Ssd Vm should wait while
                 recovery of the Local Ssd state is attempted. Its value should be in
                 between 0 and 168 hours with hour granularity and the default value being 1
                 hour.
        :param _builtins.str maintenance_interval: Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
        :param 'InstanceFromMachineImageSchedulingMaxRunDurationArgs' max_run_duration: The timeout for new network connections to hosts.
        :param Sequence['InstanceFromMachineImageSchedulingNodeAffinityArgs'] node_affinities: Specifies node affinities or anti-affinities to determine which sole-tenant nodes your instances and managed instance groups will use as host systems.
        :param _builtins.str on_host_maintenance: Describes maintenance behavior for the instance. One of MIGRATE or TERMINATE,
        :param 'InstanceFromMachineImageSchedulingOnInstanceStopActionArgs' on_instance_stop_action: Defines the behaviour for instances with the instance_termination_action.
        :param _builtins.bool preemptible: Whether the instance is preemptible.
        :param _builtins.str provisioning_model: Whether the instance is spot. If this is set as SPOT.
        :param _builtins.bool skip_guest_os_shutdown: Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        :param _builtins.str termination_time: Specifies the timestamp, when the instance will be terminated,
               in RFC3339 text format. If specified, the instance termination action
               will be performed at the termination time.
        """
        if automatic_restart is not None:
            pulumi.set(__self__, "automatic_restart", automatic_restart)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if graceful_shutdown is not None:
            pulumi.set(__self__, "graceful_shutdown", graceful_shutdown)
        if host_error_timeout_seconds is not None:
            pulumi.set(__self__, "host_error_timeout_seconds", host_error_timeout_seconds)
        if instance_termination_action is not None:
            pulumi.set(__self__, "instance_termination_action", instance_termination_action)
        if local_ssd_recovery_timeout is not None:
            pulumi.set(__self__, "local_ssd_recovery_timeout", local_ssd_recovery_timeout)
        if maintenance_interval is not None:
            pulumi.set(__self__, "maintenance_interval", maintenance_interval)
        if max_run_duration is not None:
            pulumi.set(__self__, "max_run_duration", max_run_duration)
        if min_node_cpus is not None:
            pulumi.set(__self__, "min_node_cpus", min_node_cpus)
        if node_affinities is not None:
            pulumi.set(__self__, "node_affinities", node_affinities)
        if on_host_maintenance is not None:
            pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        if on_instance_stop_action is not None:
            pulumi.set(__self__, "on_instance_stop_action", on_instance_stop_action)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)
        if provisioning_model is not None:
            pulumi.set(__self__, "provisioning_model", provisioning_model)
        if skip_guest_os_shutdown is not None:
            pulumi.set(__self__, "skip_guest_os_shutdown", skip_guest_os_shutdown)
        if termination_time is not None:
            pulumi.set(__self__, "termination_time", termination_time)

    @_builtins.property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> Optional[_builtins.bool]:
        """
        Specifies if the instance should be restarted if it was terminated by Compute Engine (not a user).
        """
        return pulumi.get(self, "automatic_restart")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[_builtins.int]:
        """
        Specifies the availability domain, which this instance should be scheduled on.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="gracefulShutdown")
    def graceful_shutdown(self) -> Optional['outputs.InstanceFromMachineImageSchedulingGracefulShutdown']:
        """
        Settings for the instance to perform a graceful shutdown.
        """
        return pulumi.get(self, "graceful_shutdown")

    @_builtins.property
    @pulumi.getter(name="hostErrorTimeoutSeconds")
    def host_error_timeout_seconds(self) -> Optional[_builtins.int]:
        """
        Specify the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
        """
        return pulumi.get(self, "host_error_timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="instanceTerminationAction")
    def instance_termination_action(self) -> Optional[_builtins.str]:
        """
        Specifies the action GCE should take when SPOT VM is preempted.
        """
        return pulumi.get(self, "instance_termination_action")

    @_builtins.property
    @pulumi.getter(name="localSsdRecoveryTimeout")
    def local_ssd_recovery_timeout(self) -> Optional['outputs.InstanceFromMachineImageSchedulingLocalSsdRecoveryTimeout']:
        """
        Specifies the maximum amount of time a Local Ssd Vm should wait while
          recovery of the Local Ssd state is attempted. Its value should be in
          between 0 and 168 hours with hour granularity and the default value being 1
          hour.
        """
        return pulumi.get(self, "local_ssd_recovery_timeout")

    @_builtins.property
    @pulumi.getter(name="maintenanceInterval")
    def maintenance_interval(self) -> Optional[_builtins.str]:
        """
        Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
        """
        return pulumi.get(self, "maintenance_interval")

    @_builtins.property
    @pulumi.getter(name="maxRunDuration")
    def max_run_duration(self) -> Optional['outputs.InstanceFromMachineImageSchedulingMaxRunDuration']:
        """
        The timeout for new network connections to hosts.
        """
        return pulumi.get(self, "max_run_duration")

    @_builtins.property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_node_cpus")

    @_builtins.property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Optional[Sequence['outputs.InstanceFromMachineImageSchedulingNodeAffinity']]:
        """
        Specifies node affinities or anti-affinities to determine which sole-tenant nodes your instances and managed instance groups will use as host systems.
        """
        return pulumi.get(self, "node_affinities")

    @_builtins.property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> Optional[_builtins.str]:
        """
        Describes maintenance behavior for the instance. One of MIGRATE or TERMINATE,
        """
        return pulumi.get(self, "on_host_maintenance")

    @_builtins.property
    @pulumi.getter(name="onInstanceStopAction")
    def on_instance_stop_action(self) -> Optional['outputs.InstanceFromMachineImageSchedulingOnInstanceStopAction']:
        """
        Defines the behaviour for instances with the instance_termination_action.
        """
        return pulumi.get(self, "on_instance_stop_action")

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> Optional[_builtins.bool]:
        """
        Whether the instance is preemptible.
        """
        return pulumi.get(self, "preemptible")

    @_builtins.property
    @pulumi.getter(name="provisioningModel")
    def provisioning_model(self) -> Optional[_builtins.str]:
        """
        Whether the instance is spot. If this is set as SPOT.
        """
        return pulumi.get(self, "provisioning_model")

    @_builtins.property
    @pulumi.getter(name="skipGuestOsShutdown")
    def skip_guest_os_shutdown(self) -> Optional[_builtins.bool]:
        """
        Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        """
        return pulumi.get(self, "skip_guest_os_shutdown")

    @_builtins.property
    @pulumi.getter(name="terminationTime")
    def termination_time(self) -> Optional[_builtins.str]:
        """
        Specifies the timestamp, when the instance will be terminated,
        in RFC3339 text format. If specified, the instance termination action
        will be performed at the termination time.
        """
        return pulumi.get(self, "termination_time")


@pulumi.output_type
class InstanceFromMachineImageSchedulingGracefulShutdown(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxDuration":
            suggest = "max_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageSchedulingGracefulShutdown. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageSchedulingGracefulShutdown.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageSchedulingGracefulShutdown.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 max_duration: Optional['outputs.InstanceFromMachineImageSchedulingGracefulShutdownMaxDuration'] = None):
        """
        :param _builtins.bool enabled: Opts-in for graceful shutdown.
        :param 'InstanceFromMachineImageSchedulingGracefulShutdownMaxDurationArgs' max_duration: The time allotted for the instance to gracefully shut down.
               										If the graceful shutdown isn't complete after this time, then the instance
               										transitions to the STOPPING state.
        """
        pulumi.set(__self__, "enabled", enabled)
        if max_duration is not None:
            pulumi.set(__self__, "max_duration", max_duration)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Opts-in for graceful shutdown.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxDuration")
    def max_duration(self) -> Optional['outputs.InstanceFromMachineImageSchedulingGracefulShutdownMaxDuration']:
        """
        The time allotted for the instance to gracefully shut down.
        										If the graceful shutdown isn't complete after this time, then the instance
        										transitions to the STOPPING state.
        """
        return pulumi.get(self, "max_duration")


@pulumi.output_type
class InstanceFromMachineImageSchedulingGracefulShutdownMaxDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               													The value must be between 1 and 3600, which is 3,600 seconds (one hour).
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               													resolution. Durations less than one second are represented
               													with a 0 seconds field and a positive nanos field. Must
               													be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        													The value must be between 1 and 3600, which is 3,600 seconds (one hour).
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        													resolution. Durations less than one second are represented
        													with a 0 seconds field and a positive nanos field. Must
        													be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class InstanceFromMachineImageSchedulingLocalSsdRecoveryTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class InstanceFromMachineImageSchedulingMaxRunDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class InstanceFromMachineImageSchedulingNodeAffinity(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class InstanceFromMachineImageSchedulingOnInstanceStopAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discardLocalSsd":
            suggest = "discard_local_ssd"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageSchedulingOnInstanceStopAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageSchedulingOnInstanceStopAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageSchedulingOnInstanceStopAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 discard_local_ssd: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool discard_local_ssd: If true, the contents of any attached Local SSD disks will be discarded.
        """
        if discard_local_ssd is not None:
            pulumi.set(__self__, "discard_local_ssd", discard_local_ssd)

    @_builtins.property
    @pulumi.getter(name="discardLocalSsd")
    def discard_local_ssd(self) -> Optional[_builtins.bool]:
        """
        If true, the contents of any attached Local SSD disks will be discarded.
        """
        return pulumi.get(self, "discard_local_ssd")


@pulumi.output_type
class InstanceFromMachineImageScratchDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageScratchDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageScratchDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageScratchDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface: _builtins.str,
                 device_name: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None):
        """
        :param _builtins.str interface: The disk interface used for attaching this disk. One of SCSI or NVME.
        :param _builtins.str device_name: Name with which the attached disk is accessible under /dev/disk/by-id/
        :param _builtins.int size: The size of the disk in gigabytes. One of 375 or 3000.
        """
        pulumi.set(__self__, "interface", interface)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> _builtins.str:
        """
        The disk interface used for attaching this disk. One of SCSI or NVME.
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Name with which the attached disk is accessible under /dev/disk/by-id/
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        The size of the disk in gigabytes. One of 375 or 3000.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class InstanceFromMachineImageServiceAccount(dict):
    def __init__(__self__, *,
                 scopes: Sequence[_builtins.str],
                 email: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] scopes: A list of service scopes.
        :param _builtins.str email: The service account e-mail address.
        """
        pulumi.set(__self__, "scopes", scopes)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        """
        A list of service scopes.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The service account e-mail address.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class InstanceFromMachineImageShieldedInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIntegrityMonitoring":
            suggest = "enable_integrity_monitoring"
        elif key == "enableSecureBoot":
            suggest = "enable_secure_boot"
        elif key == "enableVtpm":
            suggest = "enable_vtpm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageShieldedInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageShieldedInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageShieldedInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[_builtins.bool] = None,
                 enable_secure_boot: Optional[_builtins.bool] = None,
                 enable_vtpm: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable_integrity_monitoring: Whether integrity monitoring is enabled for the instance.
        :param _builtins.bool enable_secure_boot: Whether secure boot is enabled for the instance.
        :param _builtins.bool enable_vtpm: Whether the instance uses vTPM.
        """
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        if enable_vtpm is not None:
            pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @_builtins.property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[_builtins.bool]:
        """
        Whether integrity monitoring is enabled for the instance.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @_builtins.property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[_builtins.bool]:
        """
        Whether secure boot is enabled for the instance.
        """
        return pulumi.get(self, "enable_secure_boot")

    @_builtins.property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> Optional[_builtins.bool]:
        """
        Whether the instance uses vTPM.
        """
        return pulumi.get(self, "enable_vtpm")


@pulumi.output_type
class InstanceFromMachineImageSourceMachineImageEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyName":
            suggest = "kms_key_name"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromMachineImageSourceMachineImageEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromMachineImageSourceMachineImageEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromMachineImageSourceMachineImageEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_name: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sha256")


@pulumi.output_type
class InstanceFromTemplateAdvancedMachineFeatures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableNestedVirtualization":
            suggest = "enable_nested_virtualization"
        elif key == "enableUefiNetworking":
            suggest = "enable_uefi_networking"
        elif key == "performanceMonitoringUnit":
            suggest = "performance_monitoring_unit"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"
        elif key == "turboMode":
            suggest = "turbo_mode"
        elif key == "visibleCoreCount":
            suggest = "visible_core_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateAdvancedMachineFeatures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateAdvancedMachineFeatures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateAdvancedMachineFeatures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_nested_virtualization: Optional[_builtins.bool] = None,
                 enable_uefi_networking: Optional[_builtins.bool] = None,
                 performance_monitoring_unit: Optional[_builtins.str] = None,
                 threads_per_core: Optional[_builtins.int] = None,
                 turbo_mode: Optional[_builtins.str] = None,
                 visible_core_count: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enable_nested_virtualization: Whether to enable nested virtualization or not.
        :param _builtins.bool enable_uefi_networking: Whether to enable UEFI networking for the instance.
        :param _builtins.str performance_monitoring_unit: The PMU is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are "STANDARD", "ENHANCED", and "ARCHITECTURAL".
        :param _builtins.int threads_per_core: The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
        :param _builtins.str turbo_mode: Turbo frequency mode to use for the instance. Currently supported modes is "ALL_CORE_MAX".
        :param _builtins.int visible_core_count: The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance\\'s nominal CPU count and the underlying platform\\'s SMT width.
        """
        if enable_nested_virtualization is not None:
            pulumi.set(__self__, "enable_nested_virtualization", enable_nested_virtualization)
        if enable_uefi_networking is not None:
            pulumi.set(__self__, "enable_uefi_networking", enable_uefi_networking)
        if performance_monitoring_unit is not None:
            pulumi.set(__self__, "performance_monitoring_unit", performance_monitoring_unit)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)
        if turbo_mode is not None:
            pulumi.set(__self__, "turbo_mode", turbo_mode)
        if visible_core_count is not None:
            pulumi.set(__self__, "visible_core_count", visible_core_count)

    @_builtins.property
    @pulumi.getter(name="enableNestedVirtualization")
    def enable_nested_virtualization(self) -> Optional[_builtins.bool]:
        """
        Whether to enable nested virtualization or not.
        """
        return pulumi.get(self, "enable_nested_virtualization")

    @_builtins.property
    @pulumi.getter(name="enableUefiNetworking")
    def enable_uefi_networking(self) -> Optional[_builtins.bool]:
        """
        Whether to enable UEFI networking for the instance.
        """
        return pulumi.get(self, "enable_uefi_networking")

    @_builtins.property
    @pulumi.getter(name="performanceMonitoringUnit")
    def performance_monitoring_unit(self) -> Optional[_builtins.str]:
        """
        The PMU is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are "STANDARD", "ENHANCED", and "ARCHITECTURAL".
        """
        return pulumi.get(self, "performance_monitoring_unit")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[_builtins.int]:
        """
        The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
        """
        return pulumi.get(self, "threads_per_core")

    @_builtins.property
    @pulumi.getter(name="turboMode")
    def turbo_mode(self) -> Optional[_builtins.str]:
        """
        Turbo frequency mode to use for the instance. Currently supported modes is "ALL_CORE_MAX".
        """
        return pulumi.get(self, "turbo_mode")

    @_builtins.property
    @pulumi.getter(name="visibleCoreCount")
    def visible_core_count(self) -> Optional[_builtins.int]:
        """
        The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance\\'s nominal CPU count and the underlying platform\\'s SMT width.
        """
        return pulumi.get(self, "visible_core_count")


@pulumi.output_type
class InstanceFromTemplateAttachedDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "diskEncryptionKeyRaw":
            suggest = "disk_encryption_key_raw"
        elif key == "diskEncryptionKeyRsa":
            suggest = "disk_encryption_key_rsa"
        elif key == "diskEncryptionKeySha256":
            suggest = "disk_encryption_key_sha256"
        elif key == "diskEncryptionServiceAccount":
            suggest = "disk_encryption_service_account"
        elif key == "forceAttach":
            suggest = "force_attach"
        elif key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateAttachedDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateAttachedDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateAttachedDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: _builtins.str,
                 device_name: Optional[_builtins.str] = None,
                 disk_encryption_key_raw: Optional[_builtins.str] = None,
                 disk_encryption_key_rsa: Optional[_builtins.str] = None,
                 disk_encryption_key_sha256: Optional[_builtins.str] = None,
                 disk_encryption_service_account: Optional[_builtins.str] = None,
                 force_attach: Optional[_builtins.bool] = None,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str source: The name or self_link of the disk attached to this instance.
        :param _builtins.str device_name: Name with which the attached disk is accessible under /dev/disk/by-id/
        :param _builtins.str disk_encryption_key_raw: A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        :param _builtins.str disk_encryption_key_rsa: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        :param _builtins.str disk_encryption_key_sha256: The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
        :param _builtins.str disk_encryption_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
        :param _builtins.bool force_attach: Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        :param _builtins.str kms_key_self_link: The self_link of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        :param _builtins.str mode: Read/write mode for the disk. One of "READ_ONLY" or "READ_WRITE".
        """
        pulumi.set(__self__, "source", source)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key_raw is not None:
            pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        if disk_encryption_key_rsa is not None:
            pulumi.set(__self__, "disk_encryption_key_rsa", disk_encryption_key_rsa)
        if disk_encryption_key_sha256 is not None:
            pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        if disk_encryption_service_account is not None:
            pulumi.set(__self__, "disk_encryption_service_account", disk_encryption_service_account)
        if force_attach is not None:
            pulumi.set(__self__, "force_attach", force_attach)
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The name or self_link of the disk attached to this instance.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Name with which the attached disk is accessible under /dev/disk/by-id/
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[_builtins.str]:
        """
        A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        """
        return pulumi.get(self, "disk_encryption_key_raw")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRsa")
    def disk_encryption_key_rsa(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        """
        return pulumi.get(self, "disk_encryption_key_rsa")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[_builtins.str]:
        """
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
        """
        return pulumi.get(self, "disk_encryption_key_sha256")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionServiceAccount")
    def disk_encryption_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
        """
        return pulumi.get(self, "disk_encryption_service_account")

    @_builtins.property
    @pulumi.getter(name="forceAttach")
    def force_attach(self) -> Optional[_builtins.bool]:
        """
        Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        """
        return pulumi.get(self, "force_attach")

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self_link of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Read/write mode for the disk. One of "READ_ONLY" or "READ_WRITE".
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class InstanceFromTemplateBootDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDelete":
            suggest = "auto_delete"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "diskEncryptionKeyRaw":
            suggest = "disk_encryption_key_raw"
        elif key == "diskEncryptionKeyRsa":
            suggest = "disk_encryption_key_rsa"
        elif key == "diskEncryptionKeySha256":
            suggest = "disk_encryption_key_sha256"
        elif key == "diskEncryptionServiceAccount":
            suggest = "disk_encryption_service_account"
        elif key == "forceAttach":
            suggest = "force_attach"
        elif key == "guestOsFeatures":
            suggest = "guest_os_features"
        elif key == "initializeParams":
            suggest = "initialize_params"
        elif key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateBootDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateBootDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateBootDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_delete: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 disk_encryption_key_raw: Optional[_builtins.str] = None,
                 disk_encryption_key_rsa: Optional[_builtins.str] = None,
                 disk_encryption_key_sha256: Optional[_builtins.str] = None,
                 disk_encryption_service_account: Optional[_builtins.str] = None,
                 force_attach: Optional[_builtins.bool] = None,
                 guest_os_features: Optional[Sequence[_builtins.str]] = None,
                 initialize_params: Optional['outputs.InstanceFromTemplateBootDiskInitializeParams'] = None,
                 interface: Optional[_builtins.str] = None,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_delete: Whether the disk will be auto-deleted when the instance is deleted.
        :param _builtins.str device_name: Name with which attached disk will be accessible under /dev/disk/by-id/
        :param _builtins.str disk_encryption_key_raw: A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        :param _builtins.str disk_encryption_key_rsa: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        :param _builtins.str disk_encryption_key_sha256: The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
        :param _builtins.str disk_encryption_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
        :param _builtins.bool force_attach: Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        :param Sequence[_builtins.str] guest_os_features: A list of features to enable on the guest operating system. Applicable only for bootable images.
        :param 'InstanceFromTemplateBootDiskInitializeParamsArgs' initialize_params: Parameters with which a disk was created alongside the instance.
        :param _builtins.str interface: The disk interface used for attaching this disk. One of SCSI or NVME. (This field is shared with attached_disk and only used for specific cases, please don't specify this field without advice from Google.)
        :param _builtins.str kms_key_self_link: The self_link of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        :param _builtins.str mode: Read/write mode for the disk. One of "READ_ONLY" or "READ_WRITE".
        :param _builtins.str source: The name or self_link of the disk attached to this instance.
        """
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key_raw is not None:
            pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        if disk_encryption_key_rsa is not None:
            pulumi.set(__self__, "disk_encryption_key_rsa", disk_encryption_key_rsa)
        if disk_encryption_key_sha256 is not None:
            pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        if disk_encryption_service_account is not None:
            pulumi.set(__self__, "disk_encryption_service_account", disk_encryption_service_account)
        if force_attach is not None:
            pulumi.set(__self__, "force_attach", force_attach)
        if guest_os_features is not None:
            pulumi.set(__self__, "guest_os_features", guest_os_features)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[_builtins.bool]:
        """
        Whether the disk will be auto-deleted when the instance is deleted.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Name with which attached disk will be accessible under /dev/disk/by-id/
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> Optional[_builtins.str]:
        """
        A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        """
        return pulumi.get(self, "disk_encryption_key_raw")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRsa")
    def disk_encryption_key_rsa(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        """
        return pulumi.get(self, "disk_encryption_key_rsa")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> Optional[_builtins.str]:
        """
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
        """
        return pulumi.get(self, "disk_encryption_key_sha256")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionServiceAccount")
    def disk_encryption_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
        """
        return pulumi.get(self, "disk_encryption_service_account")

    @_builtins.property
    @pulumi.getter(name="forceAttach")
    def force_attach(self) -> Optional[_builtins.bool]:
        """
        Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        """
        return pulumi.get(self, "force_attach")

    @_builtins.property
    @pulumi.getter(name="guestOsFeatures")
    def guest_os_features(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of features to enable on the guest operating system. Applicable only for bootable images.
        """
        return pulumi.get(self, "guest_os_features")

    @_builtins.property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional['outputs.InstanceFromTemplateBootDiskInitializeParams']:
        """
        Parameters with which a disk was created alongside the instance.
        """
        return pulumi.get(self, "initialize_params")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[_builtins.str]:
        """
        The disk interface used for attaching this disk. One of SCSI or NVME. (This field is shared with attached_disk and only used for specific cases, please don't specify this field without advice from Google.)
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self_link of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Read/write mode for the disk. One of "READ_ONLY" or "READ_WRITE".
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The name or self_link of the disk attached to this instance.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class InstanceFromTemplateBootDiskInitializeParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableConfidentialCompute":
            suggest = "enable_confidential_compute"
        elif key == "provisionedIops":
            suggest = "provisioned_iops"
        elif key == "provisionedThroughput":
            suggest = "provisioned_throughput"
        elif key == "resourceManagerTags":
            suggest = "resource_manager_tags"
        elif key == "resourcePolicies":
            suggest = "resource_policies"
        elif key == "sourceImageEncryptionKey":
            suggest = "source_image_encryption_key"
        elif key == "sourceSnapshotEncryptionKey":
            suggest = "source_snapshot_encryption_key"
        elif key == "storagePool":
            suggest = "storage_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateBootDiskInitializeParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateBootDiskInitializeParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateBootDiskInitializeParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 architecture: Optional[_builtins.str] = None,
                 enable_confidential_compute: Optional[_builtins.bool] = None,
                 image: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 provisioned_iops: Optional[_builtins.int] = None,
                 provisioned_throughput: Optional[_builtins.int] = None,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None,
                 resource_policies: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None,
                 snapshot: Optional[_builtins.str] = None,
                 source_image_encryption_key: Optional['outputs.InstanceFromTemplateBootDiskInitializeParamsSourceImageEncryptionKey'] = None,
                 source_snapshot_encryption_key: Optional['outputs.InstanceFromTemplateBootDiskInitializeParamsSourceSnapshotEncryptionKey'] = None,
                 storage_pool: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str architecture: The architecture of the disk. One of "X86_64" or "ARM64".
        :param _builtins.bool enable_confidential_compute: A flag to enable confidential compute mode on boot disk
        :param _builtins.str image: The image from which this disk was initialised.
        :param Mapping[str, _builtins.str] labels: A set of key/value label pairs assigned to the disk.
        :param _builtins.int provisioned_iops: Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle.
        :param _builtins.int provisioned_throughput: Indicates how much throughput to provision for the disk. This sets the number of throughput mb per second that the disk can handle.
        :param Mapping[str, _builtins.str] resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        :param _builtins.str resource_policies: A list of self_links of resource policies to attach to the instance's boot disk. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.
        :param _builtins.int size: The size of the image in gigabytes.
        :param _builtins.str snapshot: The snapshot from which this disk was initialised.
        :param 'InstanceFromTemplateBootDiskInitializeParamsSourceImageEncryptionKeyArgs' source_image_encryption_key: The encryption key used to decrypt the source image.
        :param 'InstanceFromTemplateBootDiskInitializeParamsSourceSnapshotEncryptionKeyArgs' source_snapshot_encryption_key: The encryption key used to decrypt the source snapshot.
        :param _builtins.str storage_pool: The URL of the storage pool in which the new disk is created
        :param _builtins.str type: The Google Compute Engine disk type. Such as pd-standard, pd-ssd or pd-balanced.
        """
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if enable_confidential_compute is not None:
            pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if provisioned_iops is not None:
            pulumi.set(__self__, "provisioned_iops", provisioned_iops)
        if provisioned_throughput is not None:
            pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)
        if resource_policies is not None:
            pulumi.set(__self__, "resource_policies", resource_policies)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if source_image_encryption_key is not None:
            pulumi.set(__self__, "source_image_encryption_key", source_image_encryption_key)
        if source_snapshot_encryption_key is not None:
            pulumi.set(__self__, "source_snapshot_encryption_key", source_snapshot_encryption_key)
        if storage_pool is not None:
            pulumi.set(__self__, "storage_pool", storage_pool)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def architecture(self) -> Optional[_builtins.str]:
        """
        The architecture of the disk. One of "X86_64" or "ARM64".
        """
        return pulumi.get(self, "architecture")

    @_builtins.property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> Optional[_builtins.bool]:
        """
        A flag to enable confidential compute mode on boot disk
        """
        return pulumi.get(self, "enable_confidential_compute")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        The image from which this disk was initialised.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key/value label pairs assigned to the disk.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="provisionedIops")
    def provisioned_iops(self) -> Optional[_builtins.int]:
        """
        Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle.
        """
        return pulumi.get(self, "provisioned_iops")

    @_builtins.property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> Optional[_builtins.int]:
        """
        Indicates how much throughput to provision for the disk. This sets the number of throughput mb per second that the disk can handle.
        """
        return pulumi.get(self, "provisioned_throughput")

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        return pulumi.get(self, "resource_manager_tags")

    @_builtins.property
    @pulumi.getter(name="resourcePolicies")
    def resource_policies(self) -> Optional[_builtins.str]:
        """
        A list of self_links of resource policies to attach to the instance's boot disk. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.
        """
        return pulumi.get(self, "resource_policies")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        The size of the image in gigabytes.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional[_builtins.str]:
        """
        The snapshot from which this disk was initialised.
        """
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter(name="sourceImageEncryptionKey")
    def source_image_encryption_key(self) -> Optional['outputs.InstanceFromTemplateBootDiskInitializeParamsSourceImageEncryptionKey']:
        """
        The encryption key used to decrypt the source image.
        """
        return pulumi.get(self, "source_image_encryption_key")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshotEncryptionKey")
    def source_snapshot_encryption_key(self) -> Optional['outputs.InstanceFromTemplateBootDiskInitializeParamsSourceSnapshotEncryptionKey']:
        """
        The encryption key used to decrypt the source snapshot.
        """
        return pulumi.get(self, "source_snapshot_encryption_key")

    @_builtins.property
    @pulumi.getter(name="storagePool")
    def storage_pool(self) -> Optional[_builtins.str]:
        """
        The URL of the storage pool in which the new disk is created
        """
        return pulumi.get(self, "storage_pool")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The Google Compute Engine disk type. Such as pd-standard, pd-ssd or pd-balanced.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InstanceFromTemplateBootDiskInitializeParamsSourceImageEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateBootDiskInitializeParamsSourceImageEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateBootDiskInitializeParamsSourceImageEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateBootDiskInitializeParamsSourceImageEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str sha256: The SHA256 hash of the encryption key used to encrypt this disk.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        The SHA256 hash of the encryption key used to encrypt this disk.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class InstanceFromTemplateBootDiskInitializeParamsSourceSnapshotEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateBootDiskInitializeParamsSourceSnapshotEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateBootDiskInitializeParamsSourceSnapshotEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateBootDiskInitializeParamsSourceSnapshotEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str sha256: The SHA256 hash of the encryption key used to encrypt this disk.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        The SHA256 hash of the encryption key used to encrypt this disk.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class InstanceFromTemplateConfidentialInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confidentialInstanceType":
            suggest = "confidential_instance_type"
        elif key == "enableConfidentialCompute":
            suggest = "enable_confidential_compute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateConfidentialInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateConfidentialInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateConfidentialInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 confidential_instance_type: Optional[_builtins.str] = None,
                 enable_confidential_compute: Optional[_builtins.bool] = None):
        """
        :param _builtins.str confidential_instance_type: The confidential computing technology the instance uses.
               								SEV is an AMD feature. TDX is an Intel feature. One of the following
               								values is required: SEV, SEV_SNP, TDX. If SEV_SNP, min_cpu_platform =
               								"AMD Milan" is currently required.
        :param _builtins.bool enable_confidential_compute: Defines whether the instance should have confidential compute enabled. Field will be deprecated in a future release
        """
        if confidential_instance_type is not None:
            pulumi.set(__self__, "confidential_instance_type", confidential_instance_type)
        if enable_confidential_compute is not None:
            pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @_builtins.property
    @pulumi.getter(name="confidentialInstanceType")
    def confidential_instance_type(self) -> Optional[_builtins.str]:
        """
        The confidential computing technology the instance uses.
        								SEV is an AMD feature. TDX is an Intel feature. One of the following
        								values is required: SEV, SEV_SNP, TDX. If SEV_SNP, min_cpu_platform =
        								"AMD Milan" is currently required.
        """
        return pulumi.get(self, "confidential_instance_type")

    @_builtins.property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> Optional[_builtins.bool]:
        """
        Defines whether the instance should have confidential compute enabled. Field will be deprecated in a future release
        """
        return pulumi.get(self, "enable_confidential_compute")


@pulumi.output_type
class InstanceFromTemplateGuestAccelerator(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int count: The number of the guest accelerator cards exposed to this instance.
        :param _builtins.str type: The accelerator type resource exposed to this instance. E.g. nvidia-tesla-k80.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The accelerator type resource exposed to this instance. E.g. nvidia-tesla-k80.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InstanceFromTemplateInstanceEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateInstanceEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateInstanceEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateInstanceEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str sha256: The SHA256 hash of the customer's encryption key.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        The SHA256 hash of the customer's encryption key.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class InstanceFromTemplateNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConfigs":
            suggest = "access_configs"
        elif key == "aliasIpRanges":
            suggest = "alias_ip_ranges"
        elif key == "internalIpv6PrefixLength":
            suggest = "internal_ipv6_prefix_length"
        elif key == "ipv6AccessConfigs":
            suggest = "ipv6_access_configs"
        elif key == "ipv6AccessType":
            suggest = "ipv6_access_type"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "networkAttachment":
            suggest = "network_attachment"
        elif key == "networkIp":
            suggest = "network_ip"
        elif key == "nicType":
            suggest = "nic_type"
        elif key == "queueCount":
            suggest = "queue_count"
        elif key == "securityPolicy":
            suggest = "security_policy"
        elif key == "stackType":
            suggest = "stack_type"
        elif key == "subnetworkProject":
            suggest = "subnetwork_project"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_configs: Optional[Sequence['outputs.InstanceFromTemplateNetworkInterfaceAccessConfig']] = None,
                 alias_ip_ranges: Optional[Sequence['outputs.InstanceFromTemplateNetworkInterfaceAliasIpRange']] = None,
                 internal_ipv6_prefix_length: Optional[_builtins.int] = None,
                 ipv6_access_configs: Optional[Sequence['outputs.InstanceFromTemplateNetworkInterfaceIpv6AccessConfig']] = None,
                 ipv6_access_type: Optional[_builtins.str] = None,
                 ipv6_address: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None,
                 network_attachment: Optional[_builtins.str] = None,
                 network_ip: Optional[_builtins.str] = None,
                 nic_type: Optional[_builtins.str] = None,
                 queue_count: Optional[_builtins.int] = None,
                 security_policy: Optional[_builtins.str] = None,
                 stack_type: Optional[_builtins.str] = None,
                 subnetwork: Optional[_builtins.str] = None,
                 subnetwork_project: Optional[_builtins.str] = None):
        """
        :param Sequence['InstanceFromTemplateNetworkInterfaceAccessConfigArgs'] access_configs: Access configurations, i.e. IPs via which this instance can be accessed via the Internet.
        :param Sequence['InstanceFromTemplateNetworkInterfaceAliasIpRangeArgs'] alias_ip_ranges: An array of alias IP ranges for this network interface.
        :param _builtins.int internal_ipv6_prefix_length: The prefix length of the primary internal IPv6 range.
        :param Sequence['InstanceFromTemplateNetworkInterfaceIpv6AccessConfigArgs'] ipv6_access_configs: An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
        :param _builtins.str ipv6_access_type: One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
        :param _builtins.str ipv6_address: An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        :param _builtins.str name: A unique name for the resource, required by GCE.
               Changing this forces a new resource to be created.
        :param _builtins.str network: The name or self_link of the network attached to this interface.
        :param _builtins.str network_attachment: The URL of the network attachment that this interface should connect to in the following format: projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}.
        :param _builtins.str network_ip: The private IP address assigned to the instance.
        :param _builtins.str nic_type: The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET, IDPF, MRDMA, and IRDMA
        :param _builtins.int queue_count: The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        :param _builtins.str security_policy: A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        :param _builtins.str stack_type: The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
        :param _builtins.str subnetwork: The name or self_link of the subnetwork attached to this interface.
        :param _builtins.str subnetwork_project: The project in which the subnetwork belongs.
        """
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if alias_ip_ranges is not None:
            pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        if internal_ipv6_prefix_length is not None:
            pulumi.set(__self__, "internal_ipv6_prefix_length", internal_ipv6_prefix_length)
        if ipv6_access_configs is not None:
            pulumi.set(__self__, "ipv6_access_configs", ipv6_access_configs)
        if ipv6_access_type is not None:
            pulumi.set(__self__, "ipv6_access_type", ipv6_access_type)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_attachment is not None:
            pulumi.set(__self__, "network_attachment", network_attachment)
        if network_ip is not None:
            pulumi.set(__self__, "network_ip", network_ip)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if queue_count is not None:
            pulumi.set(__self__, "queue_count", queue_count)
        if security_policy is not None:
            pulumi.set(__self__, "security_policy", security_policy)
        if stack_type is not None:
            pulumi.set(__self__, "stack_type", stack_type)
        if subnetwork is not None:
            pulumi.set(__self__, "subnetwork", subnetwork)
        if subnetwork_project is not None:
            pulumi.set(__self__, "subnetwork_project", subnetwork_project)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.InstanceFromTemplateNetworkInterfaceAccessConfig']]:
        """
        Access configurations, i.e. IPs via which this instance can be accessed via the Internet.
        """
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[Sequence['outputs.InstanceFromTemplateNetworkInterfaceAliasIpRange']]:
        """
        An array of alias IP ranges for this network interface.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="internalIpv6PrefixLength")
    def internal_ipv6_prefix_length(self) -> Optional[_builtins.int]:
        """
        The prefix length of the primary internal IPv6 range.
        """
        return pulumi.get(self, "internal_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessConfigs")
    def ipv6_access_configs(self) -> Optional[Sequence['outputs.InstanceFromTemplateNetworkInterfaceIpv6AccessConfig']]:
        """
        An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
        """
        return pulumi.get(self, "ipv6_access_configs")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessType")
    def ipv6_access_type(self) -> Optional[_builtins.str]:
        """
        One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
        """
        return pulumi.get(self, "ipv6_access_type")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[_builtins.str]:
        """
        An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A unique name for the resource, required by GCE.
        Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        The name or self_link of the network attached to this interface.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="networkAttachment")
    def network_attachment(self) -> Optional[_builtins.str]:
        """
        The URL of the network attachment that this interface should connect to in the following format: projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}.
        """
        return pulumi.get(self, "network_attachment")

    @_builtins.property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> Optional[_builtins.str]:
        """
        The private IP address assigned to the instance.
        """
        return pulumi.get(self, "network_ip")

    @_builtins.property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[_builtins.str]:
        """
        The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET, IDPF, MRDMA, and IRDMA
        """
        return pulumi.get(self, "nic_type")

    @_builtins.property
    @pulumi.getter(name="queueCount")
    def queue_count(self) -> Optional[_builtins.int]:
        """
        The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        """
        return pulumi.get(self, "queue_count")

    @_builtins.property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> Optional[_builtins.str]:
        """
        A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        return pulumi.get(self, "security_policy")

    @_builtins.property
    @pulumi.getter(name="stackType")
    def stack_type(self) -> Optional[_builtins.str]:
        """
        The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
        """
        return pulumi.get(self, "stack_type")

    @_builtins.property
    @pulumi.getter
    def subnetwork(self) -> Optional[_builtins.str]:
        """
        The name or self_link of the subnetwork attached to this interface.
        """
        return pulumi.get(self, "subnetwork")

    @_builtins.property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> Optional[_builtins.str]:
        """
        The project in which the subnetwork belongs.
        """
        return pulumi.get(self, "subnetwork_project")


@pulumi.output_type
class InstanceFromTemplateNetworkInterfaceAccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "natIp":
            suggest = "nat_ip"
        elif key == "networkTier":
            suggest = "network_tier"
        elif key == "publicPtrDomainName":
            suggest = "public_ptr_domain_name"
        elif key == "securityPolicy":
            suggest = "security_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateNetworkInterfaceAccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateNetworkInterfaceAccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateNetworkInterfaceAccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nat_ip: Optional[_builtins.str] = None,
                 network_tier: Optional[_builtins.str] = None,
                 public_ptr_domain_name: Optional[_builtins.str] = None,
                 security_policy: Optional[_builtins.str] = None):
        """
        :param _builtins.str nat_ip: The IP address that is be 1:1 mapped to the instance's network ip.
        :param _builtins.str network_tier: The networking tier used for configuring this instance. One of PREMIUM or STANDARD.
        :param _builtins.str public_ptr_domain_name: The DNS domain name for the public PTR record.
        :param _builtins.str security_policy: A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        if nat_ip is not None:
            pulumi.set(__self__, "nat_ip", nat_ip)
        if network_tier is not None:
            pulumi.set(__self__, "network_tier", network_tier)
        if public_ptr_domain_name is not None:
            pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)
        if security_policy is not None:
            pulumi.set(__self__, "security_policy", security_policy)

    @_builtins.property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> Optional[_builtins.str]:
        """
        The IP address that is be 1:1 mapped to the instance's network ip.
        """
        return pulumi.get(self, "nat_ip")

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> Optional[_builtins.str]:
        """
        The networking tier used for configuring this instance. One of PREMIUM or STANDARD.
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[_builtins.str]:
        """
        The DNS domain name for the public PTR record.
        """
        return pulumi.get(self, "public_ptr_domain_name")

    @_builtins.property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> Optional[_builtins.str]:
        """
        A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        return pulumi.get(self, "security_policy")


@pulumi.output_type
class InstanceFromTemplateNetworkInterfaceAliasIpRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipCidrRange":
            suggest = "ip_cidr_range"
        elif key == "subnetworkRangeName":
            suggest = "subnetwork_range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateNetworkInterfaceAliasIpRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateNetworkInterfaceAliasIpRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateNetworkInterfaceAliasIpRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_cidr_range: _builtins.str,
                 subnetwork_range_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip_cidr_range: The IP CIDR range represented by this alias IP range.
        :param _builtins.str subnetwork_range_name: The subnetwork secondary range name specifying the secondary range from which to allocate the IP CIDR range for this alias IP range.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        if subnetwork_range_name is not None:
            pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @_builtins.property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> _builtins.str:
        """
        The IP CIDR range represented by this alias IP range.
        """
        return pulumi.get(self, "ip_cidr_range")

    @_builtins.property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> Optional[_builtins.str]:
        """
        The subnetwork secondary range name specifying the secondary range from which to allocate the IP CIDR range for this alias IP range.
        """
        return pulumi.get(self, "subnetwork_range_name")


@pulumi.output_type
class InstanceFromTemplateNetworkInterfaceIpv6AccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkTier":
            suggest = "network_tier"
        elif key == "externalIpv6":
            suggest = "external_ipv6"
        elif key == "externalIpv6PrefixLength":
            suggest = "external_ipv6_prefix_length"
        elif key == "publicPtrDomainName":
            suggest = "public_ptr_domain_name"
        elif key == "securityPolicy":
            suggest = "security_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateNetworkInterfaceIpv6AccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateNetworkInterfaceIpv6AccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateNetworkInterfaceIpv6AccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_tier: _builtins.str,
                 external_ipv6: Optional[_builtins.str] = None,
                 external_ipv6_prefix_length: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 public_ptr_domain_name: Optional[_builtins.str] = None,
                 security_policy: Optional[_builtins.str] = None):
        """
        :param _builtins.str network_tier: The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
        :param _builtins.str external_ipv6: The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. To use a static external IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
        :param _builtins.str external_ipv6_prefix_length: The prefix length of the external IPv6 range.
        :param _builtins.str name: A unique name for the resource, required by GCE.
               Changing this forces a new resource to be created.
        :param _builtins.str public_ptr_domain_name: The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
        :param _builtins.str security_policy: A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        pulumi.set(__self__, "network_tier", network_tier)
        if external_ipv6 is not None:
            pulumi.set(__self__, "external_ipv6", external_ipv6)
        if external_ipv6_prefix_length is not None:
            pulumi.set(__self__, "external_ipv6_prefix_length", external_ipv6_prefix_length)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ptr_domain_name is not None:
            pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)
        if security_policy is not None:
            pulumi.set(__self__, "security_policy", security_policy)

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> _builtins.str:
        """
        The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="externalIpv6")
    def external_ipv6(self) -> Optional[_builtins.str]:
        """
        The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. To use a static external IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
        """
        return pulumi.get(self, "external_ipv6")

    @_builtins.property
    @pulumi.getter(name="externalIpv6PrefixLength")
    def external_ipv6_prefix_length(self) -> Optional[_builtins.str]:
        """
        The prefix length of the external IPv6 range.
        """
        return pulumi.get(self, "external_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A unique name for the resource, required by GCE.
        Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[_builtins.str]:
        """
        The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
        """
        return pulumi.get(self, "public_ptr_domain_name")

    @_builtins.property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> Optional[_builtins.str]:
        """
        A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        return pulumi.get(self, "security_policy")


@pulumi.output_type
class InstanceFromTemplateNetworkPerformanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalEgressBandwidthTier":
            suggest = "total_egress_bandwidth_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateNetworkPerformanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateNetworkPerformanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateNetworkPerformanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_egress_bandwidth_tier: _builtins.str):
        """
        :param _builtins.str total_egress_bandwidth_tier: The egress bandwidth tier to enable. Possible values:TIER_1, DEFAULT
        """
        pulumi.set(__self__, "total_egress_bandwidth_tier", total_egress_bandwidth_tier)

    @_builtins.property
    @pulumi.getter(name="totalEgressBandwidthTier")
    def total_egress_bandwidth_tier(self) -> _builtins.str:
        """
        The egress bandwidth tier to enable. Possible values:TIER_1, DEFAULT
        """
        return pulumi.get(self, "total_egress_bandwidth_tier")


@pulumi.output_type
class InstanceFromTemplateParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class InstanceFromTemplateReservationAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "specificReservation":
            suggest = "specific_reservation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateReservationAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateReservationAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateReservationAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 specific_reservation: Optional['outputs.InstanceFromTemplateReservationAffinitySpecificReservation'] = None):
        """
        :param _builtins.str type: The type of reservation from which this instance can consume resources.
        :param 'InstanceFromTemplateReservationAffinitySpecificReservationArgs' specific_reservation: Specifies the label selector for the reservation to use.
        """
        pulumi.set(__self__, "type", type)
        if specific_reservation is not None:
            pulumi.set(__self__, "specific_reservation", specific_reservation)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of reservation from which this instance can consume resources.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="specificReservation")
    def specific_reservation(self) -> Optional['outputs.InstanceFromTemplateReservationAffinitySpecificReservation']:
        """
        Specifies the label selector for the reservation to use.
        """
        return pulumi.get(self, "specific_reservation")


@pulumi.output_type
class InstanceFromTemplateReservationAffinitySpecificReservation(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
        :param Sequence[_builtins.str] values: Corresponds to the label values of a reservation resource.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Corresponds to the label values of a reservation resource.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class InstanceFromTemplateScheduling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automaticRestart":
            suggest = "automatic_restart"
        elif key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "gracefulShutdown":
            suggest = "graceful_shutdown"
        elif key == "hostErrorTimeoutSeconds":
            suggest = "host_error_timeout_seconds"
        elif key == "instanceTerminationAction":
            suggest = "instance_termination_action"
        elif key == "localSsdRecoveryTimeout":
            suggest = "local_ssd_recovery_timeout"
        elif key == "maintenanceInterval":
            suggest = "maintenance_interval"
        elif key == "maxRunDuration":
            suggest = "max_run_duration"
        elif key == "minNodeCpus":
            suggest = "min_node_cpus"
        elif key == "nodeAffinities":
            suggest = "node_affinities"
        elif key == "onHostMaintenance":
            suggest = "on_host_maintenance"
        elif key == "onInstanceStopAction":
            suggest = "on_instance_stop_action"
        elif key == "provisioningModel":
            suggest = "provisioning_model"
        elif key == "skipGuestOsShutdown":
            suggest = "skip_guest_os_shutdown"
        elif key == "terminationTime":
            suggest = "termination_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateScheduling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateScheduling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateScheduling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automatic_restart: Optional[_builtins.bool] = None,
                 availability_domain: Optional[_builtins.int] = None,
                 graceful_shutdown: Optional['outputs.InstanceFromTemplateSchedulingGracefulShutdown'] = None,
                 host_error_timeout_seconds: Optional[_builtins.int] = None,
                 instance_termination_action: Optional[_builtins.str] = None,
                 local_ssd_recovery_timeout: Optional['outputs.InstanceFromTemplateSchedulingLocalSsdRecoveryTimeout'] = None,
                 maintenance_interval: Optional[_builtins.str] = None,
                 max_run_duration: Optional['outputs.InstanceFromTemplateSchedulingMaxRunDuration'] = None,
                 min_node_cpus: Optional[_builtins.int] = None,
                 node_affinities: Optional[Sequence['outputs.InstanceFromTemplateSchedulingNodeAffinity']] = None,
                 on_host_maintenance: Optional[_builtins.str] = None,
                 on_instance_stop_action: Optional['outputs.InstanceFromTemplateSchedulingOnInstanceStopAction'] = None,
                 preemptible: Optional[_builtins.bool] = None,
                 provisioning_model: Optional[_builtins.str] = None,
                 skip_guest_os_shutdown: Optional[_builtins.bool] = None,
                 termination_time: Optional[_builtins.str] = None):
        """
        :param _builtins.bool automatic_restart: Specifies if the instance should be restarted if it was terminated by Compute Engine (not a user).
        :param _builtins.int availability_domain: Specifies the availability domain, which this instance should be scheduled on.
        :param 'InstanceFromTemplateSchedulingGracefulShutdownArgs' graceful_shutdown: Settings for the instance to perform a graceful shutdown.
        :param _builtins.int host_error_timeout_seconds: Specify the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
        :param _builtins.str instance_termination_action: Specifies the action GCE should take when SPOT VM is preempted.
        :param 'InstanceFromTemplateSchedulingLocalSsdRecoveryTimeoutArgs' local_ssd_recovery_timeout: Specifies the maximum amount of time a Local Ssd Vm should wait while
                 recovery of the Local Ssd state is attempted. Its value should be in
                 between 0 and 168 hours with hour granularity and the default value being 1
                 hour.
        :param _builtins.str maintenance_interval: Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
        :param 'InstanceFromTemplateSchedulingMaxRunDurationArgs' max_run_duration: The timeout for new network connections to hosts.
        :param Sequence['InstanceFromTemplateSchedulingNodeAffinityArgs'] node_affinities: Specifies node affinities or anti-affinities to determine which sole-tenant nodes your instances and managed instance groups will use as host systems.
        :param _builtins.str on_host_maintenance: Describes maintenance behavior for the instance. One of MIGRATE or TERMINATE,
        :param 'InstanceFromTemplateSchedulingOnInstanceStopActionArgs' on_instance_stop_action: Defines the behaviour for instances with the instance_termination_action.
        :param _builtins.bool preemptible: Whether the instance is preemptible.
        :param _builtins.str provisioning_model: Whether the instance is spot. If this is set as SPOT.
        :param _builtins.bool skip_guest_os_shutdown: Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        :param _builtins.str termination_time: Specifies the timestamp, when the instance will be terminated,
               in RFC3339 text format. If specified, the instance termination action
               will be performed at the termination time.
        """
        if automatic_restart is not None:
            pulumi.set(__self__, "automatic_restart", automatic_restart)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if graceful_shutdown is not None:
            pulumi.set(__self__, "graceful_shutdown", graceful_shutdown)
        if host_error_timeout_seconds is not None:
            pulumi.set(__self__, "host_error_timeout_seconds", host_error_timeout_seconds)
        if instance_termination_action is not None:
            pulumi.set(__self__, "instance_termination_action", instance_termination_action)
        if local_ssd_recovery_timeout is not None:
            pulumi.set(__self__, "local_ssd_recovery_timeout", local_ssd_recovery_timeout)
        if maintenance_interval is not None:
            pulumi.set(__self__, "maintenance_interval", maintenance_interval)
        if max_run_duration is not None:
            pulumi.set(__self__, "max_run_duration", max_run_duration)
        if min_node_cpus is not None:
            pulumi.set(__self__, "min_node_cpus", min_node_cpus)
        if node_affinities is not None:
            pulumi.set(__self__, "node_affinities", node_affinities)
        if on_host_maintenance is not None:
            pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        if on_instance_stop_action is not None:
            pulumi.set(__self__, "on_instance_stop_action", on_instance_stop_action)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)
        if provisioning_model is not None:
            pulumi.set(__self__, "provisioning_model", provisioning_model)
        if skip_guest_os_shutdown is not None:
            pulumi.set(__self__, "skip_guest_os_shutdown", skip_guest_os_shutdown)
        if termination_time is not None:
            pulumi.set(__self__, "termination_time", termination_time)

    @_builtins.property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> Optional[_builtins.bool]:
        """
        Specifies if the instance should be restarted if it was terminated by Compute Engine (not a user).
        """
        return pulumi.get(self, "automatic_restart")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[_builtins.int]:
        """
        Specifies the availability domain, which this instance should be scheduled on.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="gracefulShutdown")
    def graceful_shutdown(self) -> Optional['outputs.InstanceFromTemplateSchedulingGracefulShutdown']:
        """
        Settings for the instance to perform a graceful shutdown.
        """
        return pulumi.get(self, "graceful_shutdown")

    @_builtins.property
    @pulumi.getter(name="hostErrorTimeoutSeconds")
    def host_error_timeout_seconds(self) -> Optional[_builtins.int]:
        """
        Specify the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
        """
        return pulumi.get(self, "host_error_timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="instanceTerminationAction")
    def instance_termination_action(self) -> Optional[_builtins.str]:
        """
        Specifies the action GCE should take when SPOT VM is preempted.
        """
        return pulumi.get(self, "instance_termination_action")

    @_builtins.property
    @pulumi.getter(name="localSsdRecoveryTimeout")
    def local_ssd_recovery_timeout(self) -> Optional['outputs.InstanceFromTemplateSchedulingLocalSsdRecoveryTimeout']:
        """
        Specifies the maximum amount of time a Local Ssd Vm should wait while
          recovery of the Local Ssd state is attempted. Its value should be in
          between 0 and 168 hours with hour granularity and the default value being 1
          hour.
        """
        return pulumi.get(self, "local_ssd_recovery_timeout")

    @_builtins.property
    @pulumi.getter(name="maintenanceInterval")
    def maintenance_interval(self) -> Optional[_builtins.str]:
        """
        Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
        """
        return pulumi.get(self, "maintenance_interval")

    @_builtins.property
    @pulumi.getter(name="maxRunDuration")
    def max_run_duration(self) -> Optional['outputs.InstanceFromTemplateSchedulingMaxRunDuration']:
        """
        The timeout for new network connections to hosts.
        """
        return pulumi.get(self, "max_run_duration")

    @_builtins.property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_node_cpus")

    @_builtins.property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Optional[Sequence['outputs.InstanceFromTemplateSchedulingNodeAffinity']]:
        """
        Specifies node affinities or anti-affinities to determine which sole-tenant nodes your instances and managed instance groups will use as host systems.
        """
        return pulumi.get(self, "node_affinities")

    @_builtins.property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> Optional[_builtins.str]:
        """
        Describes maintenance behavior for the instance. One of MIGRATE or TERMINATE,
        """
        return pulumi.get(self, "on_host_maintenance")

    @_builtins.property
    @pulumi.getter(name="onInstanceStopAction")
    def on_instance_stop_action(self) -> Optional['outputs.InstanceFromTemplateSchedulingOnInstanceStopAction']:
        """
        Defines the behaviour for instances with the instance_termination_action.
        """
        return pulumi.get(self, "on_instance_stop_action")

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> Optional[_builtins.bool]:
        """
        Whether the instance is preemptible.
        """
        return pulumi.get(self, "preemptible")

    @_builtins.property
    @pulumi.getter(name="provisioningModel")
    def provisioning_model(self) -> Optional[_builtins.str]:
        """
        Whether the instance is spot. If this is set as SPOT.
        """
        return pulumi.get(self, "provisioning_model")

    @_builtins.property
    @pulumi.getter(name="skipGuestOsShutdown")
    def skip_guest_os_shutdown(self) -> Optional[_builtins.bool]:
        """
        Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        """
        return pulumi.get(self, "skip_guest_os_shutdown")

    @_builtins.property
    @pulumi.getter(name="terminationTime")
    def termination_time(self) -> Optional[_builtins.str]:
        """
        Specifies the timestamp, when the instance will be terminated,
        in RFC3339 text format. If specified, the instance termination action
        will be performed at the termination time.
        """
        return pulumi.get(self, "termination_time")


@pulumi.output_type
class InstanceFromTemplateSchedulingGracefulShutdown(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxDuration":
            suggest = "max_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateSchedulingGracefulShutdown. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateSchedulingGracefulShutdown.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateSchedulingGracefulShutdown.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 max_duration: Optional['outputs.InstanceFromTemplateSchedulingGracefulShutdownMaxDuration'] = None):
        """
        :param _builtins.bool enabled: Opts-in for graceful shutdown.
        :param 'InstanceFromTemplateSchedulingGracefulShutdownMaxDurationArgs' max_duration: The time allotted for the instance to gracefully shut down.
               										If the graceful shutdown isn't complete after this time, then the instance
               										transitions to the STOPPING state.
        """
        pulumi.set(__self__, "enabled", enabled)
        if max_duration is not None:
            pulumi.set(__self__, "max_duration", max_duration)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Opts-in for graceful shutdown.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxDuration")
    def max_duration(self) -> Optional['outputs.InstanceFromTemplateSchedulingGracefulShutdownMaxDuration']:
        """
        The time allotted for the instance to gracefully shut down.
        										If the graceful shutdown isn't complete after this time, then the instance
        										transitions to the STOPPING state.
        """
        return pulumi.get(self, "max_duration")


@pulumi.output_type
class InstanceFromTemplateSchedulingGracefulShutdownMaxDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               													The value must be between 1 and 3600, which is 3,600 seconds (one hour).
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               													resolution. Durations less than one second are represented
               													with a 0 seconds field and a positive nanos field. Must
               													be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        													The value must be between 1 and 3600, which is 3,600 seconds (one hour).
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        													resolution. Durations less than one second are represented
        													with a 0 seconds field and a positive nanos field. Must
        													be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class InstanceFromTemplateSchedulingLocalSsdRecoveryTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class InstanceFromTemplateSchedulingMaxRunDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class InstanceFromTemplateSchedulingNodeAffinity(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class InstanceFromTemplateSchedulingOnInstanceStopAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discardLocalSsd":
            suggest = "discard_local_ssd"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateSchedulingOnInstanceStopAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateSchedulingOnInstanceStopAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateSchedulingOnInstanceStopAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 discard_local_ssd: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool discard_local_ssd: If true, the contents of any attached Local SSD disks will be discarded.
        """
        if discard_local_ssd is not None:
            pulumi.set(__self__, "discard_local_ssd", discard_local_ssd)

    @_builtins.property
    @pulumi.getter(name="discardLocalSsd")
    def discard_local_ssd(self) -> Optional[_builtins.bool]:
        """
        If true, the contents of any attached Local SSD disks will be discarded.
        """
        return pulumi.get(self, "discard_local_ssd")


@pulumi.output_type
class InstanceFromTemplateScratchDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateScratchDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateScratchDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateScratchDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface: _builtins.str,
                 device_name: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None):
        """
        :param _builtins.str interface: The disk interface used for attaching this disk. One of SCSI or NVME.
        :param _builtins.str device_name: Name with which the attached disk is accessible under /dev/disk/by-id/
        :param _builtins.int size: The size of the disk in gigabytes. One of 375 or 3000.
        """
        pulumi.set(__self__, "interface", interface)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> _builtins.str:
        """
        The disk interface used for attaching this disk. One of SCSI or NVME.
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Name with which the attached disk is accessible under /dev/disk/by-id/
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        The size of the disk in gigabytes. One of 375 or 3000.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class InstanceFromTemplateServiceAccount(dict):
    def __init__(__self__, *,
                 scopes: Sequence[_builtins.str],
                 email: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] scopes: A list of service scopes.
        :param _builtins.str email: The service account e-mail address.
        """
        pulumi.set(__self__, "scopes", scopes)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        """
        A list of service scopes.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The service account e-mail address.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class InstanceFromTemplateShieldedInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIntegrityMonitoring":
            suggest = "enable_integrity_monitoring"
        elif key == "enableSecureBoot":
            suggest = "enable_secure_boot"
        elif key == "enableVtpm":
            suggest = "enable_vtpm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFromTemplateShieldedInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFromTemplateShieldedInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFromTemplateShieldedInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[_builtins.bool] = None,
                 enable_secure_boot: Optional[_builtins.bool] = None,
                 enable_vtpm: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable_integrity_monitoring: Whether integrity monitoring is enabled for the instance.
        :param _builtins.bool enable_secure_boot: Whether secure boot is enabled for the instance.
        :param _builtins.bool enable_vtpm: Whether the instance uses vTPM.
        """
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        if enable_vtpm is not None:
            pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @_builtins.property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[_builtins.bool]:
        """
        Whether integrity monitoring is enabled for the instance.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @_builtins.property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[_builtins.bool]:
        """
        Whether secure boot is enabled for the instance.
        """
        return pulumi.get(self, "enable_secure_boot")

    @_builtins.property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> Optional[_builtins.bool]:
        """
        Whether the instance uses vTPM.
        """
        return pulumi.get(self, "enable_vtpm")


@pulumi.output_type
class InstanceGroupManagerAllInstancesConfig(dict):
    def __init__(__self__, *,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] labels: , The label key-value pairs that you want to patch onto the instance.
               
               - - -
        :param Mapping[str, _builtins.str] metadata: , The metadata key-value pairs that you want to patch onto the instance. For more information, see [Project and instance metadata](https://cloud.google.com/compute/docs/metadata#project_and_instance_metadata).
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        , The label key-value pairs that you want to patch onto the instance.

        - - -
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        , The metadata key-value pairs that you want to patch onto the instance. For more information, see [Project and instance metadata](https://cloud.google.com/compute/docs/metadata#project_and_instance_metadata).
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class InstanceGroupManagerAutoHealingPolicies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheck":
            suggest = "health_check"
        elif key == "initialDelaySec":
            suggest = "initial_delay_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerAutoHealingPolicies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerAutoHealingPolicies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerAutoHealingPolicies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 health_check: _builtins.str,
                 initial_delay_sec: _builtins.int):
        """
        :param _builtins.str health_check: The health check resource that signals autohealing.
        :param _builtins.int initial_delay_sec: The number of seconds that the managed instance group waits before
               it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        pulumi.set(__self__, "health_check", health_check)
        pulumi.set(__self__, "initial_delay_sec", initial_delay_sec)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> _builtins.str:
        """
        The health check resource that signals autohealing.
        """
        return pulumi.get(self, "health_check")

    @_builtins.property
    @pulumi.getter(name="initialDelaySec")
    def initial_delay_sec(self) -> _builtins.int:
        """
        The number of seconds that the managed instance group waits before
        it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        return pulumi.get(self, "initial_delay_sec")


@pulumi.output_type
class InstanceGroupManagerInstanceLifecyclePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultActionOnFailure":
            suggest = "default_action_on_failure"
        elif key == "forceUpdateOnRepair":
            suggest = "force_update_on_repair"
        elif key == "onFailedHealthCheck":
            suggest = "on_failed_health_check"
        elif key == "onRepair":
            suggest = "on_repair"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerInstanceLifecyclePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerInstanceLifecyclePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerInstanceLifecyclePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_action_on_failure: Optional[_builtins.str] = None,
                 force_update_on_repair: Optional[_builtins.str] = None,
                 on_failed_health_check: Optional[_builtins.str] = None,
                 on_repair: Optional['outputs.InstanceGroupManagerInstanceLifecyclePolicyOnRepair'] = None):
        """
        :param _builtins.str default_action_on_failure: , Specifies the action that a MIG performs on a failed VM. If the value of the `on_failed_health_check` field is `DEFAULT_ACTION`, then the same action also applies to the VMs on which your application fails a health check. Valid options are: `DO_NOTHING`, `REPAIR`. If `DO_NOTHING`, then MIG does not repair a failed VM. If `REPAIR` (default), then MIG automatically repairs a failed VM by recreating it. For more information, see about repairing VMs in a MIG.
        :param _builtins.str force_update_on_repair: , Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: `YES`, `NO`. If `YES` and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If `NO` (default), then updates are applied in accordance with the group's update policy type.
        :param _builtins.str on_failed_health_check: , Specifies the action that a MIG performs on an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid options are: `DEFAULT_ACTION`, `DO_NOTHING`, `REPAIR`. If `DEFAULT_ACTION` (default), then MIG uses the same action configured for the  `default_action_on_failure` field. If `DO_NOTHING`, then MIG does not repair unhealthy VM. If `REPAIR`, then MIG automatically repairs an unhealthy VM by recreating it. For more information, see about repairing VMs in a MIG.
        :param 'InstanceGroupManagerInstanceLifecyclePolicyOnRepairArgs' on_repair: , Configuration for VM repairs in the MIG. Structure is documented below.
               - - -
        """
        if default_action_on_failure is not None:
            pulumi.set(__self__, "default_action_on_failure", default_action_on_failure)
        if force_update_on_repair is not None:
            pulumi.set(__self__, "force_update_on_repair", force_update_on_repair)
        if on_failed_health_check is not None:
            pulumi.set(__self__, "on_failed_health_check", on_failed_health_check)
        if on_repair is not None:
            pulumi.set(__self__, "on_repair", on_repair)

    @_builtins.property
    @pulumi.getter(name="defaultActionOnFailure")
    def default_action_on_failure(self) -> Optional[_builtins.str]:
        """
        , Specifies the action that a MIG performs on a failed VM. If the value of the `on_failed_health_check` field is `DEFAULT_ACTION`, then the same action also applies to the VMs on which your application fails a health check. Valid options are: `DO_NOTHING`, `REPAIR`. If `DO_NOTHING`, then MIG does not repair a failed VM. If `REPAIR` (default), then MIG automatically repairs a failed VM by recreating it. For more information, see about repairing VMs in a MIG.
        """
        return pulumi.get(self, "default_action_on_failure")

    @_builtins.property
    @pulumi.getter(name="forceUpdateOnRepair")
    def force_update_on_repair(self) -> Optional[_builtins.str]:
        """
        , Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: `YES`, `NO`. If `YES` and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If `NO` (default), then updates are applied in accordance with the group's update policy type.
        """
        return pulumi.get(self, "force_update_on_repair")

    @_builtins.property
    @pulumi.getter(name="onFailedHealthCheck")
    def on_failed_health_check(self) -> Optional[_builtins.str]:
        """
        , Specifies the action that a MIG performs on an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid options are: `DEFAULT_ACTION`, `DO_NOTHING`, `REPAIR`. If `DEFAULT_ACTION` (default), then MIG uses the same action configured for the  `default_action_on_failure` field. If `DO_NOTHING`, then MIG does not repair unhealthy VM. If `REPAIR`, then MIG automatically repairs an unhealthy VM by recreating it. For more information, see about repairing VMs in a MIG.
        """
        return pulumi.get(self, "on_failed_health_check")

    @_builtins.property
    @pulumi.getter(name="onRepair")
    def on_repair(self) -> Optional['outputs.InstanceGroupManagerInstanceLifecyclePolicyOnRepair']:
        """
        , Configuration for VM repairs in the MIG. Structure is documented below.
        - - -
        """
        return pulumi.get(self, "on_repair")


@pulumi.output_type
class InstanceGroupManagerInstanceLifecyclePolicyOnRepair(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowChangingZone":
            suggest = "allow_changing_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerInstanceLifecyclePolicyOnRepair. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerInstanceLifecyclePolicyOnRepair.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerInstanceLifecyclePolicyOnRepair.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_changing_zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str allow_changing_zone: , Specifies whether the MIG can change a VM's zone during a repair. If "YES", MIG can select a different zone for the VM during a repair. Else if "NO", MIG cannot change a VM's zone during a repair. The default value of allow_changing_zone is "NO".
               
               - - -
        """
        if allow_changing_zone is not None:
            pulumi.set(__self__, "allow_changing_zone", allow_changing_zone)

    @_builtins.property
    @pulumi.getter(name="allowChangingZone")
    def allow_changing_zone(self) -> Optional[_builtins.str]:
        """
        , Specifies whether the MIG can change a VM's zone during a repair. If "YES", MIG can select a different zone for the VM during a repair. Else if "NO", MIG cannot change a VM's zone during a repair. The default value of allow_changing_zone is "NO".

        - - -
        """
        return pulumi.get(self, "allow_changing_zone")


@pulumi.output_type
class InstanceGroupManagerNamedPort(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str name: The name of the port.
        :param _builtins.int port: The port number.
               - - -
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the port.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port number.
        - - -
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class InstanceGroupManagerParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to bind to the managed instance group. The tags are key-value pairs. Keys must be in the format tagKeys/123 and values in the format tagValues/456. For more information, see [Manage tags for resources](https://cloud.google.com/compute/docs/tag-resources)
               
               - - -
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource manager tags to bind to the managed instance group. The tags are key-value pairs. Keys must be in the format tagKeys/123 and values in the format tagValues/456. For more information, see [Manage tags for resources](https://cloud.google.com/compute/docs/tag-resources)

        - - -
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class InstanceGroupManagerResourcePolicies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workloadPolicy":
            suggest = "workload_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerResourcePolicies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerResourcePolicies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerResourcePolicies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workload_policy: Optional[_builtins.str] = None):
        """
        :param _builtins.str workload_policy: The URL of the workload policy that is specified for this managed instance group. It can be a full or partial URL.
        """
        if workload_policy is not None:
            pulumi.set(__self__, "workload_policy", workload_policy)

    @_builtins.property
    @pulumi.getter(name="workloadPolicy")
    def workload_policy(self) -> Optional[_builtins.str]:
        """
        The URL of the workload policy that is specified for this managed instance group. It can be a full or partial URL.
        """
        return pulumi.get(self, "workload_policy")


@pulumi.output_type
class InstanceGroupManagerStandbyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialDelaySec":
            suggest = "initial_delay_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerStandbyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerStandbyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerStandbyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_delay_sec: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.int initial_delay_sec: Specifies the number of seconds that the MIG should wait to suspend or stop a VM after that VM was created. The initial delay gives the initialization script the time to prepare your VM for a quick scale out. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
        :param _builtins.str mode: Defines how a MIG resumes or starts VMs from a standby pool when the group scales out. Valid options are: `MANUAL`, `SCALE_OUT_POOL`. If `MANUAL`(default), you have full control over which VMs are stopped and suspended in the MIG. If `SCALE_OUT_POOL`, the MIG uses the VMs from the standby pools to accelerate the scale out by resuming or starting them and then automatically replenishes the standby pool with new VMs to maintain the target sizes.
               - - -
        """
        if initial_delay_sec is not None:
            pulumi.set(__self__, "initial_delay_sec", initial_delay_sec)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="initialDelaySec")
    def initial_delay_sec(self) -> Optional[_builtins.int]:
        """
        Specifies the number of seconds that the MIG should wait to suspend or stop a VM after that VM was created. The initial delay gives the initialization script the time to prepare your VM for a quick scale out. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
        """
        return pulumi.get(self, "initial_delay_sec")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Defines how a MIG resumes or starts VMs from a standby pool when the group scales out. Valid options are: `MANUAL`, `SCALE_OUT_POOL`. If `MANUAL`(default), you have full control over which VMs are stopped and suspended in the MIG. If `SCALE_OUT_POOL`, the MIG uses the VMs from the standby pools to accelerate the scale out by resuming or starting them and then automatically replenishes the standby pool with new VMs to maintain the target sizes.
        - - -
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class InstanceGroupManagerStatefulDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteRule":
            suggest = "delete_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerStatefulDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerStatefulDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerStatefulDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 delete_rule: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: , The device name of the disk to be attached.
        :param _builtins.str delete_rule: , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the disk when the VM is deleted, but do not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
        """
        pulumi.set(__self__, "device_name", device_name)
        if delete_rule is not None:
            pulumi.set(__self__, "delete_rule", delete_rule)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        , The device name of the disk to be attached.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[_builtins.str]:
        """
        , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the disk when the VM is deleted, but do not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
        """
        return pulumi.get(self, "delete_rule")


@pulumi.output_type
class InstanceGroupManagerStatefulExternalIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteRule":
            suggest = "delete_rule"
        elif key == "interfaceName":
            suggest = "interface_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerStatefulExternalIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerStatefulExternalIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerStatefulExternalIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_rule: Optional[_builtins.str] = None,
                 interface_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str delete_rule: , A value that prescribes what should happen to the external ip when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the ip when the VM is deleted, but do not delete the ip. `ON_PERMANENT_INSTANCE_DELETION` will delete the external ip when the VM is permanently deleted from the instance group.
        :param _builtins.str interface_name: , The network interface name of the external Ip. Possible value: `nic0`
        """
        if delete_rule is not None:
            pulumi.set(__self__, "delete_rule", delete_rule)
        if interface_name is not None:
            pulumi.set(__self__, "interface_name", interface_name)

    @_builtins.property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[_builtins.str]:
        """
        , A value that prescribes what should happen to the external ip when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the ip when the VM is deleted, but do not delete the ip. `ON_PERMANENT_INSTANCE_DELETION` will delete the external ip when the VM is permanently deleted from the instance group.
        """
        return pulumi.get(self, "delete_rule")

    @_builtins.property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> Optional[_builtins.str]:
        """
        , The network interface name of the external Ip. Possible value: `nic0`
        """
        return pulumi.get(self, "interface_name")


@pulumi.output_type
class InstanceGroupManagerStatefulInternalIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteRule":
            suggest = "delete_rule"
        elif key == "interfaceName":
            suggest = "interface_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerStatefulInternalIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerStatefulInternalIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerStatefulInternalIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_rule: Optional[_builtins.str] = None,
                 interface_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str delete_rule: , A value that prescribes what should happen to the internal ip when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the ip when the VM is deleted, but do not delete the ip. `ON_PERMANENT_INSTANCE_DELETION` will delete the internal ip when the VM is permanently deleted from the instance group.
        :param _builtins.str interface_name: , The network interface name of the internal Ip. Possible value: `nic0`
        """
        if delete_rule is not None:
            pulumi.set(__self__, "delete_rule", delete_rule)
        if interface_name is not None:
            pulumi.set(__self__, "interface_name", interface_name)

    @_builtins.property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[_builtins.str]:
        """
        , A value that prescribes what should happen to the internal ip when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the ip when the VM is deleted, but do not delete the ip. `ON_PERMANENT_INSTANCE_DELETION` will delete the internal ip when the VM is permanently deleted from the instance group.
        """
        return pulumi.get(self, "delete_rule")

    @_builtins.property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> Optional[_builtins.str]:
        """
        , The network interface name of the internal Ip. Possible value: `nic0`
        """
        return pulumi.get(self, "interface_name")


@pulumi.output_type
class InstanceGroupManagerStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allInstancesConfigs":
            suggest = "all_instances_configs"
        elif key == "isStable":
            suggest = "is_stable"
        elif key == "versionTargets":
            suggest = "version_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_instances_configs: Optional[Sequence['outputs.InstanceGroupManagerStatusAllInstancesConfig']] = None,
                 is_stable: Optional[_builtins.bool] = None,
                 statefuls: Optional[Sequence['outputs.InstanceGroupManagerStatusStateful']] = None,
                 version_targets: Optional[Sequence['outputs.InstanceGroupManagerStatusVersionTarget']] = None):
        """
        :param Sequence['InstanceGroupManagerStatusAllInstancesConfigArgs'] all_instances_configs: Properties to set on all instances in the group. After setting
               allInstancesConfig on the group, you must update the group's instances to
               apply the configuration.
        :param _builtins.bool is_stable: A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
        :param Sequence['InstanceGroupManagerStatusStatefulArgs'] statefuls: Stateful status of the given Instance Group Manager.
        :param Sequence['InstanceGroupManagerStatusVersionTargetArgs'] version_targets: A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
        """
        if all_instances_configs is not None:
            pulumi.set(__self__, "all_instances_configs", all_instances_configs)
        if is_stable is not None:
            pulumi.set(__self__, "is_stable", is_stable)
        if statefuls is not None:
            pulumi.set(__self__, "statefuls", statefuls)
        if version_targets is not None:
            pulumi.set(__self__, "version_targets", version_targets)

    @_builtins.property
    @pulumi.getter(name="allInstancesConfigs")
    def all_instances_configs(self) -> Optional[Sequence['outputs.InstanceGroupManagerStatusAllInstancesConfig']]:
        """
        Properties to set on all instances in the group. After setting
        allInstancesConfig on the group, you must update the group's instances to
        apply the configuration.
        """
        return pulumi.get(self, "all_instances_configs")

    @_builtins.property
    @pulumi.getter(name="isStable")
    def is_stable(self) -> Optional[_builtins.bool]:
        """
        A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
        """
        return pulumi.get(self, "is_stable")

    @_builtins.property
    @pulumi.getter
    def statefuls(self) -> Optional[Sequence['outputs.InstanceGroupManagerStatusStateful']]:
        """
        Stateful status of the given Instance Group Manager.
        """
        return pulumi.get(self, "statefuls")

    @_builtins.property
    @pulumi.getter(name="versionTargets")
    def version_targets(self) -> Optional[Sequence['outputs.InstanceGroupManagerStatusVersionTarget']]:
        """
        A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
        """
        return pulumi.get(self, "version_targets")


@pulumi.output_type
class InstanceGroupManagerStatusAllInstancesConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentRevision":
            suggest = "current_revision"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerStatusAllInstancesConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerStatusAllInstancesConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerStatusAllInstancesConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_revision: Optional[_builtins.str] = None,
                 effective: Optional[_builtins.bool] = None):
        """
        :param _builtins.str current_revision: Current all-instances configuration revision. This value is in RFC3339 text format.
        :param _builtins.bool effective: A bit indicating whether this configuration has been applied to all managed instances in the group.
        """
        if current_revision is not None:
            pulumi.set(__self__, "current_revision", current_revision)
        if effective is not None:
            pulumi.set(__self__, "effective", effective)

    @_builtins.property
    @pulumi.getter(name="currentRevision")
    def current_revision(self) -> Optional[_builtins.str]:
        """
        Current all-instances configuration revision. This value is in RFC3339 text format.
        """
        return pulumi.get(self, "current_revision")

    @_builtins.property
    @pulumi.getter
    def effective(self) -> Optional[_builtins.bool]:
        """
        A bit indicating whether this configuration has been applied to all managed instances in the group.
        """
        return pulumi.get(self, "effective")


@pulumi.output_type
class InstanceGroupManagerStatusStateful(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hasStatefulConfig":
            suggest = "has_stateful_config"
        elif key == "perInstanceConfigs":
            suggest = "per_instance_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerStatusStateful. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerStatusStateful.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerStatusStateful.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 has_stateful_config: Optional[_builtins.bool] = None,
                 per_instance_configs: Optional[Sequence['outputs.InstanceGroupManagerStatusStatefulPerInstanceConfig']] = None):
        """
        :param _builtins.bool has_stateful_config: A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
        :param Sequence['InstanceGroupManagerStatusStatefulPerInstanceConfigArgs'] per_instance_configs: Status of per-instance configs on the instances.
        """
        if has_stateful_config is not None:
            pulumi.set(__self__, "has_stateful_config", has_stateful_config)
        if per_instance_configs is not None:
            pulumi.set(__self__, "per_instance_configs", per_instance_configs)

    @_builtins.property
    @pulumi.getter(name="hasStatefulConfig")
    def has_stateful_config(self) -> Optional[_builtins.bool]:
        """
        A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
        """
        return pulumi.get(self, "has_stateful_config")

    @_builtins.property
    @pulumi.getter(name="perInstanceConfigs")
    def per_instance_configs(self) -> Optional[Sequence['outputs.InstanceGroupManagerStatusStatefulPerInstanceConfig']]:
        """
        Status of per-instance configs on the instances.
        """
        return pulumi.get(self, "per_instance_configs")


@pulumi.output_type
class InstanceGroupManagerStatusStatefulPerInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allEffective":
            suggest = "all_effective"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerStatusStatefulPerInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerStatusStatefulPerInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerStatusStatefulPerInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_effective: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool all_effective: A bit indicating if all of the group's per-instance configs (listed in the output of a listPerInstanceConfigs API call) have status `EFFECTIVE` or there are no per-instance-configs.
        """
        if all_effective is not None:
            pulumi.set(__self__, "all_effective", all_effective)

    @_builtins.property
    @pulumi.getter(name="allEffective")
    def all_effective(self) -> Optional[_builtins.bool]:
        """
        A bit indicating if all of the group's per-instance configs (listed in the output of a listPerInstanceConfigs API call) have status `EFFECTIVE` or there are no per-instance-configs.
        """
        return pulumi.get(self, "all_effective")


@pulumi.output_type
class InstanceGroupManagerStatusVersionTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isReached":
            suggest = "is_reached"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerStatusVersionTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerStatusVersionTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerStatusVersionTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_reached: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_reached: A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
        """
        if is_reached is not None:
            pulumi.set(__self__, "is_reached", is_reached)

    @_builtins.property
    @pulumi.getter(name="isReached")
    def is_reached(self) -> Optional[_builtins.bool]:
        """
        A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
        """
        return pulumi.get(self, "is_reached")


@pulumi.output_type
class InstanceGroupManagerUpdatePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimalAction":
            suggest = "minimal_action"
        elif key == "maxSurgeFixed":
            suggest = "max_surge_fixed"
        elif key == "maxSurgePercent":
            suggest = "max_surge_percent"
        elif key == "maxUnavailableFixed":
            suggest = "max_unavailable_fixed"
        elif key == "maxUnavailablePercent":
            suggest = "max_unavailable_percent"
        elif key == "minReadySec":
            suggest = "min_ready_sec"
        elif key == "mostDisruptiveAllowedAction":
            suggest = "most_disruptive_allowed_action"
        elif key == "replacementMethod":
            suggest = "replacement_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerUpdatePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerUpdatePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerUpdatePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimal_action: _builtins.str,
                 type: _builtins.str,
                 max_surge_fixed: Optional[_builtins.int] = None,
                 max_surge_percent: Optional[_builtins.int] = None,
                 max_unavailable_fixed: Optional[_builtins.int] = None,
                 max_unavailable_percent: Optional[_builtins.int] = None,
                 min_ready_sec: Optional[_builtins.int] = None,
                 most_disruptive_allowed_action: Optional[_builtins.str] = None,
                 replacement_method: Optional[_builtins.str] = None):
        """
        :param _builtins.str minimal_action: Minimal action to be taken on an instance. You can specify either `NONE` to forbid any actions, `REFRESH` to update without stopping instances, `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `REFRESH`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        :param _builtins.str type: The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        :param _builtins.int max_surge_fixed: , Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with `max_surge_percent`. Both cannot be 0.
        :param _builtins.int max_surge_percent: , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with `max_surge_fixed`.
        :param _builtins.int max_unavailable_fixed: , Specifies a fixed number of VM instances. This must be a positive integer.
        :param _builtins.int max_unavailable_percent: , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%..
        :param _builtins.int min_ready_sec: , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
        :param _builtins.str most_disruptive_allowed_action: Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
        :param _builtins.str replacement_method: , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
               - - -
        """
        pulumi.set(__self__, "minimal_action", minimal_action)
        pulumi.set(__self__, "type", type)
        if max_surge_fixed is not None:
            pulumi.set(__self__, "max_surge_fixed", max_surge_fixed)
        if max_surge_percent is not None:
            pulumi.set(__self__, "max_surge_percent", max_surge_percent)
        if max_unavailable_fixed is not None:
            pulumi.set(__self__, "max_unavailable_fixed", max_unavailable_fixed)
        if max_unavailable_percent is not None:
            pulumi.set(__self__, "max_unavailable_percent", max_unavailable_percent)
        if min_ready_sec is not None:
            pulumi.set(__self__, "min_ready_sec", min_ready_sec)
        if most_disruptive_allowed_action is not None:
            pulumi.set(__self__, "most_disruptive_allowed_action", most_disruptive_allowed_action)
        if replacement_method is not None:
            pulumi.set(__self__, "replacement_method", replacement_method)

    @_builtins.property
    @pulumi.getter(name="minimalAction")
    def minimal_action(self) -> _builtins.str:
        """
        Minimal action to be taken on an instance. You can specify either `NONE` to forbid any actions, `REFRESH` to update without stopping instances, `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `REFRESH`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        """
        return pulumi.get(self, "minimal_action")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="maxSurgeFixed")
    def max_surge_fixed(self) -> Optional[_builtins.int]:
        """
        , Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with `max_surge_percent`. Both cannot be 0.
        """
        return pulumi.get(self, "max_surge_fixed")

    @_builtins.property
    @pulumi.getter(name="maxSurgePercent")
    def max_surge_percent(self) -> Optional[_builtins.int]:
        """
        , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with `max_surge_fixed`.
        """
        return pulumi.get(self, "max_surge_percent")

    @_builtins.property
    @pulumi.getter(name="maxUnavailableFixed")
    def max_unavailable_fixed(self) -> Optional[_builtins.int]:
        """
        , Specifies a fixed number of VM instances. This must be a positive integer.
        """
        return pulumi.get(self, "max_unavailable_fixed")

    @_builtins.property
    @pulumi.getter(name="maxUnavailablePercent")
    def max_unavailable_percent(self) -> Optional[_builtins.int]:
        """
        , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%..
        """
        return pulumi.get(self, "max_unavailable_percent")

    @_builtins.property
    @pulumi.getter(name="minReadySec")
    def min_ready_sec(self) -> Optional[_builtins.int]:
        """
        , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
        """
        return pulumi.get(self, "min_ready_sec")

    @_builtins.property
    @pulumi.getter(name="mostDisruptiveAllowedAction")
    def most_disruptive_allowed_action(self) -> Optional[_builtins.str]:
        """
        Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
        """
        return pulumi.get(self, "most_disruptive_allowed_action")

    @_builtins.property
    @pulumi.getter(name="replacementMethod")
    def replacement_method(self) -> Optional[_builtins.str]:
        """
        , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
        - - -
        """
        return pulumi.get(self, "replacement_method")


@pulumi.output_type
class InstanceGroupManagerVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceTemplate":
            suggest = "instance_template"
        elif key == "targetSize":
            suggest = "target_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupManagerVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupManagerVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupManagerVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_template: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 target_size: Optional['outputs.InstanceGroupManagerVersionTargetSize'] = None):
        """
        :param _builtins.str instance_template: The full URL to an instance template from which all new instances of this version will be created. It is recommended to reference instance templates through their unique id (`self_link_unique` attribute).
        :param _builtins.str name: Version name.
        :param 'InstanceGroupManagerVersionTargetSizeArgs' target_size: The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
               
               > Exactly one `version` you specify must not have a `target_size` specified. During a rolling update, the instance group manager will fulfill the `target_size`
               constraints of every other `version`, and any remaining instances will be provisioned with the version where `target_size` is unset.
        """
        pulumi.set(__self__, "instance_template", instance_template)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_size is not None:
            pulumi.set(__self__, "target_size", target_size)

    @_builtins.property
    @pulumi.getter(name="instanceTemplate")
    def instance_template(self) -> _builtins.str:
        """
        The full URL to an instance template from which all new instances of this version will be created. It is recommended to reference instance templates through their unique id (`self_link_unique` attribute).
        """
        return pulumi.get(self, "instance_template")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Version name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="targetSize")
    def target_size(self) -> Optional['outputs.InstanceGroupManagerVersionTargetSize']:
        """
        The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.

        > Exactly one `version` you specify must not have a `target_size` specified. During a rolling update, the instance group manager will fulfill the `target_size`
        constraints of every other `version`, and any remaining instances will be provisioned with the version where `target_size` is unset.
        """
        return pulumi.get(self, "target_size")


@pulumi.output_type
class InstanceGroupManagerVersionTargetSize(dict):
    def __init__(__self__, *,
                 fixed: Optional[_builtins.int] = None,
                 percent: Optional[_builtins.int] = None):
        """
        :param _builtins.int fixed: , The number of instances which are managed for this version. Conflicts with `percent`.
        :param _builtins.int percent: , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
               Note that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,
               one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
        """
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter
    def fixed(self) -> Optional[_builtins.int]:
        """
        , The number of instances which are managed for this version. Conflicts with `percent`.
        """
        return pulumi.get(self, "fixed")

    @_builtins.property
    @pulumi.getter
    def percent(self) -> Optional[_builtins.int]:
        """
        , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
        Note that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,
        one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class InstanceGroupNamedPort(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str name: The name which the port will be mapped to.
        :param _builtins.int port: The port number to map the name to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name which the port will be mapped to.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port number to map the name to.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class InstanceGuestAccelerator(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int count: The number of the guest accelerator cards exposed to this instance.
        :param _builtins.str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InstanceIAMBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        :param _builtins.str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
               
               > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
               identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
               consider it to be an entirely different resource and will treat it as such.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
        identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
        consider it to be an entirely different resource and will treat it as such.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class InstanceIAMMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        :param _builtins.str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
               
               > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
               identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
               consider it to be an entirely different resource and will treat it as such.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
        identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
        consider it to be an entirely different resource and will treat it as such.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class InstanceInstanceEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceInstanceEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceInstanceEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceInstanceEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self_link of the encryption key that is
               stored in Google Cloud KMS to encrypt the data on this instance.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str sha256: The SHA256 hash of the customer's encryption key.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self_link of the encryption key that is
        stored in Google Cloud KMS to encrypt the data on this instance.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        The SHA256 hash of the customer's encryption key.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class InstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConfigs":
            suggest = "access_configs"
        elif key == "aliasIpRanges":
            suggest = "alias_ip_ranges"
        elif key == "internalIpv6PrefixLength":
            suggest = "internal_ipv6_prefix_length"
        elif key == "ipv6AccessConfigs":
            suggest = "ipv6_access_configs"
        elif key == "ipv6AccessType":
            suggest = "ipv6_access_type"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "networkAttachment":
            suggest = "network_attachment"
        elif key == "networkIp":
            suggest = "network_ip"
        elif key == "nicType":
            suggest = "nic_type"
        elif key == "queueCount":
            suggest = "queue_count"
        elif key == "securityPolicy":
            suggest = "security_policy"
        elif key == "stackType":
            suggest = "stack_type"
        elif key == "subnetworkProject":
            suggest = "subnetwork_project"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_configs: Optional[Sequence['outputs.InstanceNetworkInterfaceAccessConfig']] = None,
                 alias_ip_ranges: Optional[Sequence['outputs.InstanceNetworkInterfaceAliasIpRange']] = None,
                 internal_ipv6_prefix_length: Optional[_builtins.int] = None,
                 ipv6_access_configs: Optional[Sequence['outputs.InstanceNetworkInterfaceIpv6AccessConfig']] = None,
                 ipv6_access_type: Optional[_builtins.str] = None,
                 ipv6_address: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None,
                 network_attachment: Optional[_builtins.str] = None,
                 network_ip: Optional[_builtins.str] = None,
                 nic_type: Optional[_builtins.str] = None,
                 queue_count: Optional[_builtins.int] = None,
                 security_policy: Optional[_builtins.str] = None,
                 stack_type: Optional[_builtins.str] = None,
                 subnetwork: Optional[_builtins.str] = None,
                 subnetwork_project: Optional[_builtins.str] = None):
        """
        :param Sequence['InstanceNetworkInterfaceAccessConfigArgs'] access_configs: Access configurations, i.e. IPs via which this instance can be accessed via the Internet.
        :param Sequence['InstanceNetworkInterfaceAliasIpRangeArgs'] alias_ip_ranges: An
               array of alias IP ranges for this network interface. Can only be specified for network
               interfaces on subnet-mode networks. Structure documented below.
        :param _builtins.int internal_ipv6_prefix_length: The prefix length of the primary internal IPv6 range.
        :param Sequence['InstanceNetworkInterfaceIpv6AccessConfigArgs'] ipv6_access_configs: An array of IPv6 access configurations for this interface.
               Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
               specified, then this instance will have no external IPv6 Internet access. Structure documented below.
        :param _builtins.str ipv6_access_type: One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet.
               This field is always inherited from its subnetwork.
        :param _builtins.str ipv6_address: An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        :param _builtins.str name: A unique name for the resource, required by GCE.
               Changing this forces a new resource to be created.
        :param _builtins.str network: The name or self_link of the network to attach this interface to.
               Either `network` or `subnetwork` must be provided. If network isn't provided it will
               be inferred from the subnetwork.
        :param _builtins.str network_attachment: The URL of the network attachment that this interface should connect to in the following format: `projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}`.
        :param _builtins.str network_ip: The private IP address to assign to the instance. If
               empty, the address will be automatically assigned.
        :param _builtins.str nic_type: The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET, IDPF, MRDMA, IRDMA.
        :param _builtins.int queue_count: The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        :param _builtins.str security_policy: A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        :param _builtins.str stack_type: The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6, IPV6_ONLY or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
        :param _builtins.str subnetwork: The name or self_link of the subnetwork to attach this
               interface to. Either `network` or `subnetwork` must be provided. If network isn't provided
               it will be inferred from the subnetwork. The subnetwork must exist in the same region this
               instance will be created in. If the network resource is in
               [legacy](https://cloud.google.com/vpc/docs/legacy) mode, do not specify this field. If the
               network is in auto subnet mode, specifying the subnetwork is optional. If the network is
               in custom subnet mode, specifying the subnetwork is required.
        :param _builtins.str subnetwork_project: The project in which the subnetwork belongs.
               If the `subnetwork` is a self_link, this field is set to the project
               defined in the subnetwork self_link. If the `subnetwork` is a name and this
               field is not provided, the provider project is used.
        """
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if alias_ip_ranges is not None:
            pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        if internal_ipv6_prefix_length is not None:
            pulumi.set(__self__, "internal_ipv6_prefix_length", internal_ipv6_prefix_length)
        if ipv6_access_configs is not None:
            pulumi.set(__self__, "ipv6_access_configs", ipv6_access_configs)
        if ipv6_access_type is not None:
            pulumi.set(__self__, "ipv6_access_type", ipv6_access_type)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_attachment is not None:
            pulumi.set(__self__, "network_attachment", network_attachment)
        if network_ip is not None:
            pulumi.set(__self__, "network_ip", network_ip)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if queue_count is not None:
            pulumi.set(__self__, "queue_count", queue_count)
        if security_policy is not None:
            pulumi.set(__self__, "security_policy", security_policy)
        if stack_type is not None:
            pulumi.set(__self__, "stack_type", stack_type)
        if subnetwork is not None:
            pulumi.set(__self__, "subnetwork", subnetwork)
        if subnetwork_project is not None:
            pulumi.set(__self__, "subnetwork_project", subnetwork_project)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.InstanceNetworkInterfaceAccessConfig']]:
        """
        Access configurations, i.e. IPs via which this instance can be accessed via the Internet.
        """
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[Sequence['outputs.InstanceNetworkInterfaceAliasIpRange']]:
        """
        An
        array of alias IP ranges for this network interface. Can only be specified for network
        interfaces on subnet-mode networks. Structure documented below.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="internalIpv6PrefixLength")
    def internal_ipv6_prefix_length(self) -> Optional[_builtins.int]:
        """
        The prefix length of the primary internal IPv6 range.
        """
        return pulumi.get(self, "internal_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessConfigs")
    def ipv6_access_configs(self) -> Optional[Sequence['outputs.InstanceNetworkInterfaceIpv6AccessConfig']]:
        """
        An array of IPv6 access configurations for this interface.
        Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
        specified, then this instance will have no external IPv6 Internet access. Structure documented below.
        """
        return pulumi.get(self, "ipv6_access_configs")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessType")
    def ipv6_access_type(self) -> Optional[_builtins.str]:
        """
        One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet.
        This field is always inherited from its subnetwork.
        """
        return pulumi.get(self, "ipv6_access_type")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[_builtins.str]:
        """
        An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A unique name for the resource, required by GCE.
        Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        The name or self_link of the network to attach this interface to.
        Either `network` or `subnetwork` must be provided. If network isn't provided it will
        be inferred from the subnetwork.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="networkAttachment")
    def network_attachment(self) -> Optional[_builtins.str]:
        """
        The URL of the network attachment that this interface should connect to in the following format: `projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}`.
        """
        return pulumi.get(self, "network_attachment")

    @_builtins.property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> Optional[_builtins.str]:
        """
        The private IP address to assign to the instance. If
        empty, the address will be automatically assigned.
        """
        return pulumi.get(self, "network_ip")

    @_builtins.property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[_builtins.str]:
        """
        The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET, IDPF, MRDMA, IRDMA.
        """
        return pulumi.get(self, "nic_type")

    @_builtins.property
    @pulumi.getter(name="queueCount")
    def queue_count(self) -> Optional[_builtins.int]:
        """
        The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        """
        return pulumi.get(self, "queue_count")

    @_builtins.property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> Optional[_builtins.str]:
        """
        A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        return pulumi.get(self, "security_policy")

    @_builtins.property
    @pulumi.getter(name="stackType")
    def stack_type(self) -> Optional[_builtins.str]:
        """
        The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6, IPV6_ONLY or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
        """
        return pulumi.get(self, "stack_type")

    @_builtins.property
    @pulumi.getter
    def subnetwork(self) -> Optional[_builtins.str]:
        """
        The name or self_link of the subnetwork to attach this
        interface to. Either `network` or `subnetwork` must be provided. If network isn't provided
        it will be inferred from the subnetwork. The subnetwork must exist in the same region this
        instance will be created in. If the network resource is in
        [legacy](https://cloud.google.com/vpc/docs/legacy) mode, do not specify this field. If the
        network is in auto subnet mode, specifying the subnetwork is optional. If the network is
        in custom subnet mode, specifying the subnetwork is required.
        """
        return pulumi.get(self, "subnetwork")

    @_builtins.property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> Optional[_builtins.str]:
        """
        The project in which the subnetwork belongs.
        If the `subnetwork` is a self_link, this field is set to the project
        defined in the subnetwork self_link. If the `subnetwork` is a name and this
        field is not provided, the provider project is used.
        """
        return pulumi.get(self, "subnetwork_project")


@pulumi.output_type
class InstanceNetworkInterfaceAccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "natIp":
            suggest = "nat_ip"
        elif key == "networkTier":
            suggest = "network_tier"
        elif key == "publicPtrDomainName":
            suggest = "public_ptr_domain_name"
        elif key == "securityPolicy":
            suggest = "security_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkInterfaceAccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkInterfaceAccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkInterfaceAccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nat_ip: Optional[_builtins.str] = None,
                 network_tier: Optional[_builtins.str] = None,
                 public_ptr_domain_name: Optional[_builtins.str] = None,
                 security_policy: Optional[_builtins.str] = None):
        """
        :param _builtins.str nat_ip: The IP address that will be 1:1 mapped to the instance's
               network ip. If not given, one will be generated.
        :param _builtins.str network_tier: The service-level to be provided for IPv6 traffic when the
               subnet has an external subnet. Only PREMIUM or STANDARD tier is valid for IPv6.
        :param _builtins.str public_ptr_domain_name: The domain name to be used when creating DNSv6
               records for the external IPv6 ranges..
        :param _builtins.str security_policy: A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        if nat_ip is not None:
            pulumi.set(__self__, "nat_ip", nat_ip)
        if network_tier is not None:
            pulumi.set(__self__, "network_tier", network_tier)
        if public_ptr_domain_name is not None:
            pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)
        if security_policy is not None:
            pulumi.set(__self__, "security_policy", security_policy)

    @_builtins.property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> Optional[_builtins.str]:
        """
        The IP address that will be 1:1 mapped to the instance's
        network ip. If not given, one will be generated.
        """
        return pulumi.get(self, "nat_ip")

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> Optional[_builtins.str]:
        """
        The service-level to be provided for IPv6 traffic when the
        subnet has an external subnet. Only PREMIUM or STANDARD tier is valid for IPv6.
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[_builtins.str]:
        """
        The domain name to be used when creating DNSv6
        records for the external IPv6 ranges..
        """
        return pulumi.get(self, "public_ptr_domain_name")

    @_builtins.property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> Optional[_builtins.str]:
        """
        A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        return pulumi.get(self, "security_policy")


@pulumi.output_type
class InstanceNetworkInterfaceAliasIpRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipCidrRange":
            suggest = "ip_cidr_range"
        elif key == "subnetworkRangeName":
            suggest = "subnetwork_range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkInterfaceAliasIpRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkInterfaceAliasIpRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkInterfaceAliasIpRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_cidr_range: _builtins.str,
                 subnetwork_range_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip_cidr_range: The IP CIDR range represented by this alias IP range. This IP CIDR range
               must belong to the specified subnetwork and cannot contain IP addresses reserved by
               system or used by other network interfaces. This range may be a single IP address
               (e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).
        :param _builtins.str subnetwork_range_name: The subnetwork secondary range name specifying
               the secondary range from which to allocate the IP CIDR range for this alias IP
               range. If left unspecified, the primary range of the subnetwork will be used.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        if subnetwork_range_name is not None:
            pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @_builtins.property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> _builtins.str:
        """
        The IP CIDR range represented by this alias IP range. This IP CIDR range
        must belong to the specified subnetwork and cannot contain IP addresses reserved by
        system or used by other network interfaces. This range may be a single IP address
        (e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).
        """
        return pulumi.get(self, "ip_cidr_range")

    @_builtins.property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> Optional[_builtins.str]:
        """
        The subnetwork secondary range name specifying
        the secondary range from which to allocate the IP CIDR range for this alias IP
        range. If left unspecified, the primary range of the subnetwork will be used.
        """
        return pulumi.get(self, "subnetwork_range_name")


@pulumi.output_type
class InstanceNetworkInterfaceIpv6AccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkTier":
            suggest = "network_tier"
        elif key == "externalIpv6":
            suggest = "external_ipv6"
        elif key == "externalIpv6PrefixLength":
            suggest = "external_ipv6_prefix_length"
        elif key == "publicPtrDomainName":
            suggest = "public_ptr_domain_name"
        elif key == "securityPolicy":
            suggest = "security_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkInterfaceIpv6AccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkInterfaceIpv6AccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkInterfaceIpv6AccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_tier: _builtins.str,
                 external_ipv6: Optional[_builtins.str] = None,
                 external_ipv6_prefix_length: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 public_ptr_domain_name: Optional[_builtins.str] = None,
                 security_policy: Optional[_builtins.str] = None):
        """
        :param _builtins.str network_tier: The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
        :param _builtins.str external_ipv6: The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. To use a static external IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
        :param _builtins.str external_ipv6_prefix_length: The prefix length of the external IPv6 range.
        :param _builtins.str name: A unique name for the resource, required by GCE.
               Changing this forces a new resource to be created.
        :param _builtins.str public_ptr_domain_name: The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
        :param _builtins.str security_policy: A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        pulumi.set(__self__, "network_tier", network_tier)
        if external_ipv6 is not None:
            pulumi.set(__self__, "external_ipv6", external_ipv6)
        if external_ipv6_prefix_length is not None:
            pulumi.set(__self__, "external_ipv6_prefix_length", external_ipv6_prefix_length)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ptr_domain_name is not None:
            pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)
        if security_policy is not None:
            pulumi.set(__self__, "security_policy", security_policy)

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> _builtins.str:
        """
        The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="externalIpv6")
    def external_ipv6(self) -> Optional[_builtins.str]:
        """
        The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. To use a static external IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
        """
        return pulumi.get(self, "external_ipv6")

    @_builtins.property
    @pulumi.getter(name="externalIpv6PrefixLength")
    def external_ipv6_prefix_length(self) -> Optional[_builtins.str]:
        """
        The prefix length of the external IPv6 range.
        """
        return pulumi.get(self, "external_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A unique name for the resource, required by GCE.
        Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[_builtins.str]:
        """
        The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
        """
        return pulumi.get(self, "public_ptr_domain_name")

    @_builtins.property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> Optional[_builtins.str]:
        """
        A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        return pulumi.get(self, "security_policy")


@pulumi.output_type
class InstanceNetworkPerformanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalEgressBandwidthTier":
            suggest = "total_egress_bandwidth_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkPerformanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkPerformanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkPerformanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_egress_bandwidth_tier: _builtins.str):
        """
        :param _builtins.str total_egress_bandwidth_tier: The egress bandwidth tier to enable.
               Possible values: TIER_1, DEFAULT
        """
        pulumi.set(__self__, "total_egress_bandwidth_tier", total_egress_bandwidth_tier)

    @_builtins.property
    @pulumi.getter(name="totalEgressBandwidthTier")
    def total_egress_bandwidth_tier(self) -> _builtins.str:
        """
        The egress bandwidth tier to enable.
        Possible values: TIER_1, DEFAULT
        """
        return pulumi.get(self, "total_egress_bandwidth_tier")


@pulumi.output_type
class InstanceParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class InstanceReservationAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "specificReservation":
            suggest = "specific_reservation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceReservationAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceReservationAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceReservationAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 specific_reservation: Optional['outputs.InstanceReservationAffinitySpecificReservation'] = None):
        """
        :param _builtins.str type: The type of reservation from which this instance can consume resources.
        :param 'InstanceReservationAffinitySpecificReservationArgs' specific_reservation: Specifies the label selector for the reservation to use..
               Structure is documented below.
        """
        pulumi.set(__self__, "type", type)
        if specific_reservation is not None:
            pulumi.set(__self__, "specific_reservation", specific_reservation)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of reservation from which this instance can consume resources.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="specificReservation")
    def specific_reservation(self) -> Optional['outputs.InstanceReservationAffinitySpecificReservation']:
        """
        Specifies the label selector for the reservation to use..
        Structure is documented below.
        """
        return pulumi.get(self, "specific_reservation")


@pulumi.output_type
class InstanceReservationAffinitySpecificReservation(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
        :param Sequence[_builtins.str] values: Corresponds to the label values of a reservation resource.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Corresponds to the label values of a reservation resource.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class InstanceScheduling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automaticRestart":
            suggest = "automatic_restart"
        elif key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "gracefulShutdown":
            suggest = "graceful_shutdown"
        elif key == "hostErrorTimeoutSeconds":
            suggest = "host_error_timeout_seconds"
        elif key == "instanceTerminationAction":
            suggest = "instance_termination_action"
        elif key == "localSsdRecoveryTimeout":
            suggest = "local_ssd_recovery_timeout"
        elif key == "maintenanceInterval":
            suggest = "maintenance_interval"
        elif key == "maxRunDuration":
            suggest = "max_run_duration"
        elif key == "minNodeCpus":
            suggest = "min_node_cpus"
        elif key == "nodeAffinities":
            suggest = "node_affinities"
        elif key == "onHostMaintenance":
            suggest = "on_host_maintenance"
        elif key == "onInstanceStopAction":
            suggest = "on_instance_stop_action"
        elif key == "provisioningModel":
            suggest = "provisioning_model"
        elif key == "skipGuestOsShutdown":
            suggest = "skip_guest_os_shutdown"
        elif key == "terminationTime":
            suggest = "termination_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceScheduling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceScheduling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceScheduling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automatic_restart: Optional[_builtins.bool] = None,
                 availability_domain: Optional[_builtins.int] = None,
                 graceful_shutdown: Optional['outputs.InstanceSchedulingGracefulShutdown'] = None,
                 host_error_timeout_seconds: Optional[_builtins.int] = None,
                 instance_termination_action: Optional[_builtins.str] = None,
                 local_ssd_recovery_timeout: Optional['outputs.InstanceSchedulingLocalSsdRecoveryTimeout'] = None,
                 maintenance_interval: Optional[_builtins.str] = None,
                 max_run_duration: Optional['outputs.InstanceSchedulingMaxRunDuration'] = None,
                 min_node_cpus: Optional[_builtins.int] = None,
                 node_affinities: Optional[Sequence['outputs.InstanceSchedulingNodeAffinity']] = None,
                 on_host_maintenance: Optional[_builtins.str] = None,
                 on_instance_stop_action: Optional['outputs.InstanceSchedulingOnInstanceStopAction'] = None,
                 preemptible: Optional[_builtins.bool] = None,
                 provisioning_model: Optional[_builtins.str] = None,
                 skip_guest_os_shutdown: Optional[_builtins.bool] = None,
                 termination_time: Optional[_builtins.str] = None):
        """
        :param _builtins.bool automatic_restart: Specifies if the instance should be
               restarted if it was terminated by Compute Engine (not a user).
               Defaults to true.
        :param _builtins.int availability_domain: Specifies the availability domain to place the instance in. The value must be a number between 1 and the number of availability domains specified in the spread placement policy attached to the instance.
        :param 'InstanceSchedulingGracefulShutdownArgs' graceful_shutdown: Settings for the instance to perform a graceful shutdown. Structure is documented below.
        :param _builtins.int host_error_timeout_seconds: Specifies the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
        :param _builtins.str instance_termination_action: Describe the type of termination action for VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
        :param 'InstanceSchedulingLocalSsdRecoveryTimeoutArgs' local_ssd_recovery_timeout: Specifies the maximum amount of time a Local Ssd Vm should wait while
                 recovery of the Local Ssd state is attempted. Its value should be in
                 between 0 and 168 hours with hour granularity and the default value being 1
                 hour.
        :param _builtins.str maintenance_interval: Specifies the frequency of planned maintenance events. The accepted values are: `PERIODIC`.
        :param 'InstanceSchedulingMaxRunDurationArgs' max_run_duration: The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in `instance_termination_action`. Structure is documented below.
        :param _builtins.int min_node_cpus: The minimum number of virtual CPUs this instance will consume when running on a sole-tenant node.
        :param Sequence['InstanceSchedulingNodeAffinityArgs'] node_affinities: Specifies node affinities or anti-affinities
               to determine which sole-tenant nodes your instances and managed instance
               groups will use as host systems. Read more on sole-tenant node creation
               [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
               Structure documented below.
        :param _builtins.str on_host_maintenance: Describes maintenance behavior for the
               instance. Can be MIGRATE or TERMINATE, for more info, read
               [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options).
        :param 'InstanceSchedulingOnInstanceStopActionArgs' on_instance_stop_action: Specifies the action to be performed when the instance is terminated using `max_run_duration` and `STOP` `instance_termination_action`. Only support `true` `discard_local_ssd` at this point. Structure is documented below.
        :param _builtins.bool preemptible: Specifies if the instance is preemptible.
               If this field is set to true, then `automatic_restart` must be
               set to false.  Defaults to false.
        :param _builtins.str provisioning_model: Describe the type of preemptible VM. This field accepts the value `STANDARD` or `SPOT`. If the value is `STANDARD`, there will be no discount. If this   is set to `SPOT`,
               `preemptible` should be `true` and `automatic_restart` should be
               `false`. For more info about
               `SPOT`, read [here](https://cloud.google.com/compute/docs/instances/spot)
        :param _builtins.bool skip_guest_os_shutdown: Boolean parameter. Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        :param _builtins.str termination_time: Specifies the timestamp, when the instance will be terminated, in RFC3339 text format. If specified, the instance termination action will be performed at the termination time.
        """
        if automatic_restart is not None:
            pulumi.set(__self__, "automatic_restart", automatic_restart)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if graceful_shutdown is not None:
            pulumi.set(__self__, "graceful_shutdown", graceful_shutdown)
        if host_error_timeout_seconds is not None:
            pulumi.set(__self__, "host_error_timeout_seconds", host_error_timeout_seconds)
        if instance_termination_action is not None:
            pulumi.set(__self__, "instance_termination_action", instance_termination_action)
        if local_ssd_recovery_timeout is not None:
            pulumi.set(__self__, "local_ssd_recovery_timeout", local_ssd_recovery_timeout)
        if maintenance_interval is not None:
            pulumi.set(__self__, "maintenance_interval", maintenance_interval)
        if max_run_duration is not None:
            pulumi.set(__self__, "max_run_duration", max_run_duration)
        if min_node_cpus is not None:
            pulumi.set(__self__, "min_node_cpus", min_node_cpus)
        if node_affinities is not None:
            pulumi.set(__self__, "node_affinities", node_affinities)
        if on_host_maintenance is not None:
            pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        if on_instance_stop_action is not None:
            pulumi.set(__self__, "on_instance_stop_action", on_instance_stop_action)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)
        if provisioning_model is not None:
            pulumi.set(__self__, "provisioning_model", provisioning_model)
        if skip_guest_os_shutdown is not None:
            pulumi.set(__self__, "skip_guest_os_shutdown", skip_guest_os_shutdown)
        if termination_time is not None:
            pulumi.set(__self__, "termination_time", termination_time)

    @_builtins.property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> Optional[_builtins.bool]:
        """
        Specifies if the instance should be
        restarted if it was terminated by Compute Engine (not a user).
        Defaults to true.
        """
        return pulumi.get(self, "automatic_restart")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[_builtins.int]:
        """
        Specifies the availability domain to place the instance in. The value must be a number between 1 and the number of availability domains specified in the spread placement policy attached to the instance.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="gracefulShutdown")
    def graceful_shutdown(self) -> Optional['outputs.InstanceSchedulingGracefulShutdown']:
        """
        Settings for the instance to perform a graceful shutdown. Structure is documented below.
        """
        return pulumi.get(self, "graceful_shutdown")

    @_builtins.property
    @pulumi.getter(name="hostErrorTimeoutSeconds")
    def host_error_timeout_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
        """
        return pulumi.get(self, "host_error_timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="instanceTerminationAction")
    def instance_termination_action(self) -> Optional[_builtins.str]:
        """
        Describe the type of termination action for VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
        """
        return pulumi.get(self, "instance_termination_action")

    @_builtins.property
    @pulumi.getter(name="localSsdRecoveryTimeout")
    def local_ssd_recovery_timeout(self) -> Optional['outputs.InstanceSchedulingLocalSsdRecoveryTimeout']:
        """
        Specifies the maximum amount of time a Local Ssd Vm should wait while
          recovery of the Local Ssd state is attempted. Its value should be in
          between 0 and 168 hours with hour granularity and the default value being 1
          hour.
        """
        return pulumi.get(self, "local_ssd_recovery_timeout")

    @_builtins.property
    @pulumi.getter(name="maintenanceInterval")
    def maintenance_interval(self) -> Optional[_builtins.str]:
        """
        Specifies the frequency of planned maintenance events. The accepted values are: `PERIODIC`.
        """
        return pulumi.get(self, "maintenance_interval")

    @_builtins.property
    @pulumi.getter(name="maxRunDuration")
    def max_run_duration(self) -> Optional['outputs.InstanceSchedulingMaxRunDuration']:
        """
        The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in `instance_termination_action`. Structure is documented below.
        """
        return pulumi.get(self, "max_run_duration")

    @_builtins.property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> Optional[_builtins.int]:
        """
        The minimum number of virtual CPUs this instance will consume when running on a sole-tenant node.
        """
        return pulumi.get(self, "min_node_cpus")

    @_builtins.property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Optional[Sequence['outputs.InstanceSchedulingNodeAffinity']]:
        """
        Specifies node affinities or anti-affinities
        to determine which sole-tenant nodes your instances and managed instance
        groups will use as host systems. Read more on sole-tenant node creation
        [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
        Structure documented below.
        """
        return pulumi.get(self, "node_affinities")

    @_builtins.property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> Optional[_builtins.str]:
        """
        Describes maintenance behavior for the
        instance. Can be MIGRATE or TERMINATE, for more info, read
        [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options).
        """
        return pulumi.get(self, "on_host_maintenance")

    @_builtins.property
    @pulumi.getter(name="onInstanceStopAction")
    def on_instance_stop_action(self) -> Optional['outputs.InstanceSchedulingOnInstanceStopAction']:
        """
        Specifies the action to be performed when the instance is terminated using `max_run_duration` and `STOP` `instance_termination_action`. Only support `true` `discard_local_ssd` at this point. Structure is documented below.
        """
        return pulumi.get(self, "on_instance_stop_action")

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> Optional[_builtins.bool]:
        """
        Specifies if the instance is preemptible.
        If this field is set to true, then `automatic_restart` must be
        set to false.  Defaults to false.
        """
        return pulumi.get(self, "preemptible")

    @_builtins.property
    @pulumi.getter(name="provisioningModel")
    def provisioning_model(self) -> Optional[_builtins.str]:
        """
        Describe the type of preemptible VM. This field accepts the value `STANDARD` or `SPOT`. If the value is `STANDARD`, there will be no discount. If this   is set to `SPOT`,
        `preemptible` should be `true` and `automatic_restart` should be
        `false`. For more info about
        `SPOT`, read [here](https://cloud.google.com/compute/docs/instances/spot)
        """
        return pulumi.get(self, "provisioning_model")

    @_builtins.property
    @pulumi.getter(name="skipGuestOsShutdown")
    def skip_guest_os_shutdown(self) -> Optional[_builtins.bool]:
        """
        Boolean parameter. Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        """
        return pulumi.get(self, "skip_guest_os_shutdown")

    @_builtins.property
    @pulumi.getter(name="terminationTime")
    def termination_time(self) -> Optional[_builtins.str]:
        """
        Specifies the timestamp, when the instance will be terminated, in RFC3339 text format. If specified, the instance termination action will be performed at the termination time.
        """
        return pulumi.get(self, "termination_time")


@pulumi.output_type
class InstanceSchedulingGracefulShutdown(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxDuration":
            suggest = "max_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceSchedulingGracefulShutdown. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceSchedulingGracefulShutdown.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceSchedulingGracefulShutdown.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 max_duration: Optional['outputs.InstanceSchedulingGracefulShutdownMaxDuration'] = None):
        """
        :param _builtins.bool enabled: Opts-in for graceful shutdown.
        :param 'InstanceSchedulingGracefulShutdownMaxDurationArgs' max_duration: The time allotted for the instance to gracefully shut down.
               If the graceful shutdown isn't complete after this time, then the instance
               transitions to the STOPPING state. Structure is documented below:
        """
        pulumi.set(__self__, "enabled", enabled)
        if max_duration is not None:
            pulumi.set(__self__, "max_duration", max_duration)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Opts-in for graceful shutdown.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxDuration")
    def max_duration(self) -> Optional['outputs.InstanceSchedulingGracefulShutdownMaxDuration']:
        """
        The time allotted for the instance to gracefully shut down.
        If the graceful shutdown isn't complete after this time, then the instance
        transitions to the STOPPING state. Structure is documented below:
        """
        return pulumi.get(self, "max_duration")


@pulumi.output_type
class InstanceSchedulingGracefulShutdownMaxDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               The value must be between 1 and 3600, which is 3,600 seconds (one hour).`
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented with a 0
               `seconds` field and a positive `nanos` field. Must be from 0 to
               999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        The value must be between 1 and 3600, which is 3,600 seconds (one hour).`
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented with a 0
        `seconds` field and a positive `nanos` field. Must be from 0 to
        999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class InstanceSchedulingLocalSsdRecoveryTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second. Must be from 0 to
               315,576,000,000 inclusive. Note: these bounds are computed from: 60
               sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented with a 0
               `seconds` field and a positive `nanos` field. Must be from 0 to
               999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second. Must be from 0 to
        315,576,000,000 inclusive. Note: these bounds are computed from: 60
        sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented with a 0
        `seconds` field and a positive `nanos` field. Must be from 0 to
        999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class InstanceSchedulingMaxRunDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second. Must be from 0 to
               315,576,000,000 inclusive. Note: these bounds are computed from: 60
               sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented with a 0
               `seconds` field and a positive `nanos` field. Must be from 0 to
               999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second. Must be from 0 to
        315,576,000,000 inclusive. Note: these bounds are computed from: 60
        sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented with a 0
        `seconds` field and a positive `nanos` field. Must be from 0 to
        999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class InstanceSchedulingNodeAffinity(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key for the node affinity label.
        :param _builtins.str operator: The operator. Can be `IN` for node-affinities
               or `NOT_IN` for anti-affinities.
        :param Sequence[_builtins.str] values: The values for the node affinity label.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key for the node affinity label.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator. Can be `IN` for node-affinities
        or `NOT_IN` for anti-affinities.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The values for the node affinity label.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class InstanceSchedulingOnInstanceStopAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discardLocalSsd":
            suggest = "discard_local_ssd"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceSchedulingOnInstanceStopAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceSchedulingOnInstanceStopAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceSchedulingOnInstanceStopAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 discard_local_ssd: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool discard_local_ssd: Whether to discard local SSDs attached to the VM while terminating using `max_run_duration`. Only supports `true` at this point.
        """
        if discard_local_ssd is not None:
            pulumi.set(__self__, "discard_local_ssd", discard_local_ssd)

    @_builtins.property
    @pulumi.getter(name="discardLocalSsd")
    def discard_local_ssd(self) -> Optional[_builtins.bool]:
        """
        Whether to discard local SSDs attached to the VM while terminating using `max_run_duration`. Only supports `true` at this point.
        """
        return pulumi.get(self, "discard_local_ssd")


@pulumi.output_type
class InstanceScratchDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceScratchDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceScratchDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceScratchDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface: _builtins.str,
                 device_name: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None):
        """
        :param _builtins.str interface: The disk interface to use for attaching this disk; either SCSI or NVME.
        :param _builtins.str device_name: Name with which the attached disk is accessible under /dev/disk/by-id/
        :param _builtins.int size: The size of the disk in gigabytes. One of 375 or 3000.
        """
        pulumi.set(__self__, "interface", interface)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> _builtins.str:
        """
        The disk interface to use for attaching this disk; either SCSI or NVME.
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Name with which the attached disk is accessible under /dev/disk/by-id/
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        The size of the disk in gigabytes. One of 375 or 3000.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class InstanceServiceAccount(dict):
    def __init__(__self__, *,
                 scopes: Sequence[_builtins.str],
                 email: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] scopes: A list of service scopes. Both OAuth2 URLs and gcloud
               short names are supported. To allow full access to all Cloud APIs, use the
               `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
               **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        :param _builtins.str email: The service account e-mail address.
               **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        pulumi.set(__self__, "scopes", scopes)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        """
        A list of service scopes. Both OAuth2 URLs and gcloud
        short names are supported. To allow full access to all Cloud APIs, use the
        `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
        **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The service account e-mail address.
        **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class InstanceSettingsMetadata(dict):
    def __init__(__self__, *,
                 items: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] items: A metadata key/value items map. The total size of all keys and values must be less than 512KB
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A metadata key/value items map. The total size of all keys and values must be less than 512KB
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class InstanceShieldedInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIntegrityMonitoring":
            suggest = "enable_integrity_monitoring"
        elif key == "enableSecureBoot":
            suggest = "enable_secure_boot"
        elif key == "enableVtpm":
            suggest = "enable_vtpm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceShieldedInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceShieldedInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceShieldedInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[_builtins.bool] = None,
                 enable_secure_boot: Optional[_builtins.bool] = None,
                 enable_vtpm: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable_integrity_monitoring: - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
               **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        :param _builtins.bool enable_secure_boot: - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
               **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        :param _builtins.bool enable_vtpm: - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
               **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        if enable_vtpm is not None:
            pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @_builtins.property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[_builtins.bool]:
        """
        - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @_builtins.property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[_builtins.bool]:
        """
        - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        return pulumi.get(self, "enable_secure_boot")

    @_builtins.property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> Optional[_builtins.bool]:
        """
        - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        **Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.
        """
        return pulumi.get(self, "enable_vtpm")


@pulumi.output_type
class InstanceTemplateAdvancedMachineFeatures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableNestedVirtualization":
            suggest = "enable_nested_virtualization"
        elif key == "enableUefiNetworking":
            suggest = "enable_uefi_networking"
        elif key == "performanceMonitoringUnit":
            suggest = "performance_monitoring_unit"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"
        elif key == "turboMode":
            suggest = "turbo_mode"
        elif key == "visibleCoreCount":
            suggest = "visible_core_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateAdvancedMachineFeatures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateAdvancedMachineFeatures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateAdvancedMachineFeatures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_nested_virtualization: Optional[_builtins.bool] = None,
                 enable_uefi_networking: Optional[_builtins.bool] = None,
                 performance_monitoring_unit: Optional[_builtins.str] = None,
                 threads_per_core: Optional[_builtins.int] = None,
                 turbo_mode: Optional[_builtins.str] = None,
                 visible_core_count: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enable_nested_virtualization: Defines whether the instance should have nested virtualization enabled. Defaults to false.
        :param _builtins.bool enable_uefi_networking: Whether to enable UEFI networking for instance creation.
        :param _builtins.str performance_monitoring_unit: [The PMU](https://cloud.google.com/compute/docs/pmu-overview) is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are `STANDARD`, `ENHANCED`, and `ARCHITECTURAL`.
        :param _builtins.int threads_per_core: The number of threads per physical core. To disable [simultaneous multithreading (SMT)](https://cloud.google.com/compute/docs/instances/disabling-smt) set this to 1.
        :param _builtins.str turbo_mode: Turbo frequency mode to use for the instance. Supported modes are currently either `ALL_CORE_MAX` or unset (default).
        :param _builtins.int visible_core_count: The number of physical cores to expose to an instance. [visible cores info (VC)](https://cloud.google.com/compute/docs/instances/customize-visible-cores).
        """
        if enable_nested_virtualization is not None:
            pulumi.set(__self__, "enable_nested_virtualization", enable_nested_virtualization)
        if enable_uefi_networking is not None:
            pulumi.set(__self__, "enable_uefi_networking", enable_uefi_networking)
        if performance_monitoring_unit is not None:
            pulumi.set(__self__, "performance_monitoring_unit", performance_monitoring_unit)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)
        if turbo_mode is not None:
            pulumi.set(__self__, "turbo_mode", turbo_mode)
        if visible_core_count is not None:
            pulumi.set(__self__, "visible_core_count", visible_core_count)

    @_builtins.property
    @pulumi.getter(name="enableNestedVirtualization")
    def enable_nested_virtualization(self) -> Optional[_builtins.bool]:
        """
        Defines whether the instance should have nested virtualization enabled. Defaults to false.
        """
        return pulumi.get(self, "enable_nested_virtualization")

    @_builtins.property
    @pulumi.getter(name="enableUefiNetworking")
    def enable_uefi_networking(self) -> Optional[_builtins.bool]:
        """
        Whether to enable UEFI networking for instance creation.
        """
        return pulumi.get(self, "enable_uefi_networking")

    @_builtins.property
    @pulumi.getter(name="performanceMonitoringUnit")
    def performance_monitoring_unit(self) -> Optional[_builtins.str]:
        """
        [The PMU](https://cloud.google.com/compute/docs/pmu-overview) is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are `STANDARD`, `ENHANCED`, and `ARCHITECTURAL`.
        """
        return pulumi.get(self, "performance_monitoring_unit")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[_builtins.int]:
        """
        The number of threads per physical core. To disable [simultaneous multithreading (SMT)](https://cloud.google.com/compute/docs/instances/disabling-smt) set this to 1.
        """
        return pulumi.get(self, "threads_per_core")

    @_builtins.property
    @pulumi.getter(name="turboMode")
    def turbo_mode(self) -> Optional[_builtins.str]:
        """
        Turbo frequency mode to use for the instance. Supported modes are currently either `ALL_CORE_MAX` or unset (default).
        """
        return pulumi.get(self, "turbo_mode")

    @_builtins.property
    @pulumi.getter(name="visibleCoreCount")
    def visible_core_count(self) -> Optional[_builtins.int]:
        """
        The number of physical cores to expose to an instance. [visible cores info (VC)](https://cloud.google.com/compute/docs/instances/customize-visible-cores).
        """
        return pulumi.get(self, "visible_core_count")


@pulumi.output_type
class InstanceTemplateConfidentialInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confidentialInstanceType":
            suggest = "confidential_instance_type"
        elif key == "enableConfidentialCompute":
            suggest = "enable_confidential_compute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateConfidentialInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateConfidentialInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateConfidentialInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 confidential_instance_type: Optional[_builtins.str] = None,
                 enable_confidential_compute: Optional[_builtins.bool] = None):
        """
        :param _builtins.str confidential_instance_type: Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: `SEV`, `SEV_SNP`, `TDX`. `on_host_maintenance` can be set to MIGRATE if `confidential_instance_type` is set to `SEV` and `min_cpu_platform` is set to `"AMD Milan"`. Otherwise, `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM. If `SEV_SNP`, currently `min_cpu_platform` has to be set to `"AMD Milan"` or this will fail to create the VM.
        :param _builtins.bool enable_confidential_compute: Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, `on_host_maintenance` can be set to MIGRATE if `min_cpu_platform` is set to `"AMD Milan"`. Otherwise, `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.
        """
        if confidential_instance_type is not None:
            pulumi.set(__self__, "confidential_instance_type", confidential_instance_type)
        if enable_confidential_compute is not None:
            pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @_builtins.property
    @pulumi.getter(name="confidentialInstanceType")
    def confidential_instance_type(self) -> Optional[_builtins.str]:
        """
        Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: `SEV`, `SEV_SNP`, `TDX`. `on_host_maintenance` can be set to MIGRATE if `confidential_instance_type` is set to `SEV` and `min_cpu_platform` is set to `"AMD Milan"`. Otherwise, `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM. If `SEV_SNP`, currently `min_cpu_platform` has to be set to `"AMD Milan"` or this will fail to create the VM.
        """
        return pulumi.get(self, "confidential_instance_type")

    @_builtins.property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> Optional[_builtins.bool]:
        """
        Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, `on_host_maintenance` can be set to MIGRATE if `min_cpu_platform` is set to `"AMD Milan"`. Otherwise, `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.
        """
        return pulumi.get(self, "enable_confidential_compute")


@pulumi.output_type
class InstanceTemplateDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDelete":
            suggest = "auto_delete"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "diskEncryptionKey":
            suggest = "disk_encryption_key"
        elif key == "diskName":
            suggest = "disk_name"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "guestOsFeatures":
            suggest = "guest_os_features"
        elif key == "provisionedIops":
            suggest = "provisioned_iops"
        elif key == "provisionedThroughput":
            suggest = "provisioned_throughput"
        elif key == "resourceManagerTags":
            suggest = "resource_manager_tags"
        elif key == "resourcePolicies":
            suggest = "resource_policies"
        elif key == "sourceImage":
            suggest = "source_image"
        elif key == "sourceImageEncryptionKey":
            suggest = "source_image_encryption_key"
        elif key == "sourceSnapshot":
            suggest = "source_snapshot"
        elif key == "sourceSnapshotEncryptionKey":
            suggest = "source_snapshot_encryption_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 architecture: Optional[_builtins.str] = None,
                 auto_delete: Optional[_builtins.bool] = None,
                 boot: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 disk_encryption_key: Optional['outputs.InstanceTemplateDiskDiskEncryptionKey'] = None,
                 disk_name: Optional[_builtins.str] = None,
                 disk_size_gb: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 guest_os_features: Optional[Sequence[_builtins.str]] = None,
                 interface: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 mode: Optional[_builtins.str] = None,
                 provisioned_iops: Optional[_builtins.int] = None,
                 provisioned_throughput: Optional[_builtins.int] = None,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None,
                 resource_policies: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 source_image: Optional[_builtins.str] = None,
                 source_image_encryption_key: Optional['outputs.InstanceTemplateDiskSourceImageEncryptionKey'] = None,
                 source_snapshot: Optional[_builtins.str] = None,
                 source_snapshot_encryption_key: Optional['outputs.InstanceTemplateDiskSourceSnapshotEncryptionKey'] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str architecture: The architecture of the attached disk. Valid values are `ARM64` or `x86_64`.
        :param _builtins.bool auto_delete: Whether or not the disk should be auto-deleted.
               This defaults to true.
        :param _builtins.bool boot: Indicates that this is a boot disk.
        :param _builtins.str device_name: A unique device name that is reflected into the
               /dev/  tree of a Linux operating system running within the instance. If not
               specified, the server chooses a default device name to apply to this disk.
        :param 'InstanceTemplateDiskDiskEncryptionKeyArgs' disk_encryption_key: Encrypts or decrypts a disk using a customer-supplied encryption key.
               
               If you are creating a new disk, this field encrypts the new disk using an encryption key that you provide. If you are attaching an existing disk that is already encrypted, this field decrypts the disk using the customer-supplied encryption key.
               
               If you encrypt a disk using a customer-supplied key, you must provide the same key again when you attempt to use this resource at a later time. For example, you must provide the key when you create a snapshot or an image from the disk or when you attach the disk to a virtual machine instance.
               
               If you do not provide an encryption key, then the disk will be encrypted using an automatically generated key and you do not need to provide a key to use the disk later.
               
               Instance templates do not store customer-supplied encryption keys, so you cannot use your own keys to encrypt disks in a managed instance group. Structure documented below.
        :param _builtins.str disk_name: Name of the disk. When not provided, this defaults
               to the name of the instance.
        :param _builtins.int disk_size_gb: The size of the image in gigabytes. If not
               specified, it will inherit the size of its base image. For SCRATCH disks,
               the size must be exactly 375GB.
        :param _builtins.str disk_type: The GCE disk type. Such as `"pd-ssd"`, `"local-ssd"`,
               `"pd-balanced"` or `"pd-standard"`, `"hyperdisk-balanced"`, `"hyperdisk-throughput"` or `"hyperdisk-extreme"`.
        :param Sequence[_builtins.str] guest_os_features: A list of features to enable on the guest operating system. Applicable only for bootable images. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
        :param _builtins.str interface: Specifies the disk interface to use for attaching this disk,
               which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
               and the request will fail if you attempt to attach a persistent disk in any other format
               than SCSI. Local SSDs can use either NVME or SCSI.
        :param Mapping[str, _builtins.str] labels: A set of ket/value label pairs to assign to disk created from
               this template
        :param _builtins.str mode: The mode in which to attach this disk, either READ_WRITE
               or READ_ONLY. If you are attaching or creating a boot disk, this must
               read-write mode.
        :param _builtins.int provisioned_iops: Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle. For more details, see the [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk) or the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks) depending on the selected disk_type.
        :param _builtins.int provisioned_throughput: Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
        :param Mapping[str, _builtins.str] resource_manager_tags: A set of key/value resource manager tag pairs to bind to this disk. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456.
        :param _builtins.str resource_policies: - A list (short name or id) of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
        :param _builtins.str source: The name (**not self_link**)
               of the disk (such as those managed by `compute.Disk`) to attach.
               > **Note:** Either `source`, `source_image`, or `source_snapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param _builtins.str source_image: The image from which to
               initialize this disk. This can be one of: the image's `self_link`,
               `projects/{project}/global/images/{image}`,
               `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
               `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
               `{project}/{image}`, `{family}`, or `{image}`.
               > **Note:** Either `source`, `source_image`, or `source_snapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param 'InstanceTemplateDiskSourceImageEncryptionKeyArgs' source_image_encryption_key: The customer-supplied encryption
               key of the source image. Required if the source image is protected by a
               customer-supplied encryption key.
               
               Instance templates do not store customer-supplied encryption keys, so you
               cannot create disks for instances in a managed instance group if the source
               images are encrypted with your own keys. Structure
               documented below.
        :param _builtins.str source_snapshot: The source snapshot to create this disk.
               > **Note:** Either `source`, `source_image`, or `source_snapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param 'InstanceTemplateDiskSourceSnapshotEncryptionKeyArgs' source_snapshot_encryption_key: The customer-supplied encryption
               key of the source snapshot. Structure
               documented below.
        :param _builtins.str type: The type of GCE disk, can be either `"SCRATCH"` or
               `"PERSISTENT"`.
        """
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if boot is not None:
            pulumi.set(__self__, "boot", boot)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key is not None:
            pulumi.set(__self__, "disk_encryption_key", disk_encryption_key)
        if disk_name is not None:
            pulumi.set(__self__, "disk_name", disk_name)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if guest_os_features is not None:
            pulumi.set(__self__, "guest_os_features", guest_os_features)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if provisioned_iops is not None:
            pulumi.set(__self__, "provisioned_iops", provisioned_iops)
        if provisioned_throughput is not None:
            pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)
        if resource_policies is not None:
            pulumi.set(__self__, "resource_policies", resource_policies)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if source_image is not None:
            pulumi.set(__self__, "source_image", source_image)
        if source_image_encryption_key is not None:
            pulumi.set(__self__, "source_image_encryption_key", source_image_encryption_key)
        if source_snapshot is not None:
            pulumi.set(__self__, "source_snapshot", source_snapshot)
        if source_snapshot_encryption_key is not None:
            pulumi.set(__self__, "source_snapshot_encryption_key", source_snapshot_encryption_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def architecture(self) -> Optional[_builtins.str]:
        """
        The architecture of the attached disk. Valid values are `ARM64` or `x86_64`.
        """
        return pulumi.get(self, "architecture")

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[_builtins.bool]:
        """
        Whether or not the disk should be auto-deleted.
        This defaults to true.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter
    def boot(self) -> Optional[_builtins.bool]:
        """
        Indicates that this is a boot disk.
        """
        return pulumi.get(self, "boot")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        A unique device name that is reflected into the
        /dev/  tree of a Linux operating system running within the instance. If not
        specified, the server chooses a default device name to apply to this disk.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKey")
    def disk_encryption_key(self) -> Optional['outputs.InstanceTemplateDiskDiskEncryptionKey']:
        """
        Encrypts or decrypts a disk using a customer-supplied encryption key.

        If you are creating a new disk, this field encrypts the new disk using an encryption key that you provide. If you are attaching an existing disk that is already encrypted, this field decrypts the disk using the customer-supplied encryption key.

        If you encrypt a disk using a customer-supplied key, you must provide the same key again when you attempt to use this resource at a later time. For example, you must provide the key when you create a snapshot or an image from the disk or when you attach the disk to a virtual machine instance.

        If you do not provide an encryption key, then the disk will be encrypted using an automatically generated key and you do not need to provide a key to use the disk later.

        Instance templates do not store customer-supplied encryption keys, so you cannot use your own keys to encrypt disks in a managed instance group. Structure documented below.
        """
        return pulumi.get(self, "disk_encryption_key")

    @_builtins.property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> Optional[_builtins.str]:
        """
        Name of the disk. When not provided, this defaults
        to the name of the instance.
        """
        return pulumi.get(self, "disk_name")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[_builtins.int]:
        """
        The size of the image in gigabytes. If not
        specified, it will inherit the size of its base image. For SCRATCH disks,
        the size must be exactly 375GB.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        The GCE disk type. Such as `"pd-ssd"`, `"local-ssd"`,
        `"pd-balanced"` or `"pd-standard"`, `"hyperdisk-balanced"`, `"hyperdisk-throughput"` or `"hyperdisk-extreme"`.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="guestOsFeatures")
    def guest_os_features(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of features to enable on the guest operating system. Applicable only for bootable images. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
        """
        return pulumi.get(self, "guest_os_features")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[_builtins.str]:
        """
        Specifies the disk interface to use for attaching this disk,
        which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
        and the request will fail if you attempt to attach a persistent disk in any other format
        than SCSI. Local SSDs can use either NVME or SCSI.
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of ket/value label pairs to assign to disk created from
        this template
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The mode in which to attach this disk, either READ_WRITE
        or READ_ONLY. If you are attaching or creating a boot disk, this must
        read-write mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="provisionedIops")
    def provisioned_iops(self) -> Optional[_builtins.int]:
        """
        Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle. For more details, see the [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk) or the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks) depending on the selected disk_type.
        """
        return pulumi.get(self, "provisioned_iops")

    @_builtins.property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> Optional[_builtins.int]:
        """
        Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
        """
        return pulumi.get(self, "provisioned_throughput")

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key/value resource manager tag pairs to bind to this disk. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")

    @_builtins.property
    @pulumi.getter(name="resourcePolicies")
    def resource_policies(self) -> Optional[_builtins.str]:
        """
        - A list (short name or id) of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
        """
        return pulumi.get(self, "resource_policies")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The name (**not self_link**)
        of the disk (such as those managed by `compute.Disk`) to attach.
        > **Note:** Either `source`, `source_image`, or `source_snapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> Optional[_builtins.str]:
        """
        The image from which to
        initialize this disk. This can be one of: the image's `self_link`,
        `projects/{project}/global/images/{image}`,
        `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
        `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
        `{project}/{image}`, `{family}`, or `{image}`.
        > **Note:** Either `source`, `source_image`, or `source_snapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        return pulumi.get(self, "source_image")

    @_builtins.property
    @pulumi.getter(name="sourceImageEncryptionKey")
    def source_image_encryption_key(self) -> Optional['outputs.InstanceTemplateDiskSourceImageEncryptionKey']:
        """
        The customer-supplied encryption
        key of the source image. Required if the source image is protected by a
        customer-supplied encryption key.

        Instance templates do not store customer-supplied encryption keys, so you
        cannot create disks for instances in a managed instance group if the source
        images are encrypted with your own keys. Structure
        documented below.
        """
        return pulumi.get(self, "source_image_encryption_key")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshot")
    def source_snapshot(self) -> Optional[_builtins.str]:
        """
        The source snapshot to create this disk.
        > **Note:** Either `source`, `source_image`, or `source_snapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        return pulumi.get(self, "source_snapshot")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshotEncryptionKey")
    def source_snapshot_encryption_key(self) -> Optional['outputs.InstanceTemplateDiskSourceSnapshotEncryptionKey']:
        """
        The customer-supplied encryption
        key of the source snapshot. Structure
        documented below.
        """
        return pulumi.get(self, "source_snapshot_encryption_key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of GCE disk, can be either `"SCRATCH"` or
        `"PERSISTENT"`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InstanceTemplateDiskDiskEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateDiskDiskEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateDiskDiskEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateDiskDiskEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS
        :param _builtins.str kms_key_service_account: The service account being used for the
               encryption request for the given KMS key. If absent, the Compute Engine
               default service account is used.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key that is stored in Google Cloud KMS
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the
        encryption request for the given KMS key. If absent, the Compute Engine
        default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")


@pulumi.output_type
class InstanceTemplateDiskSourceImageEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateDiskSourceImageEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateDiskSourceImageEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateDiskSourceImageEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is
               stored in Google Cloud KMS. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        :param _builtins.str kms_key_service_account: The service account being used for the
               encryption request for the given KMS key. If absent, the Compute Engine
               default service account is used.
        :param _builtins.str raw_key: A 256-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
               encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               to decrypt the given image. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt the given image. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key that is
        stored in Google Cloud KMS. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the
        encryption request for the given KMS key. If absent, the Compute Engine
        default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        A 256-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
        encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        to decrypt the given image. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt the given image. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class InstanceTemplateDiskSourceSnapshotEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateDiskSourceSnapshotEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateDiskSourceSnapshotEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateDiskSourceSnapshotEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is
               stored in Google Cloud KMS. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        :param _builtins.str kms_key_service_account: The service account being used for the
               encryption request for the given KMS key. If absent, the Compute Engine
               default service account is used.
        :param _builtins.str raw_key: A 256-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
               encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               to decrypt this snapshot. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt this snapshot. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key that is
        stored in Google Cloud KMS. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the
        encryption request for the given KMS key. If absent, the Compute Engine
        default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        A 256-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
        encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        to decrypt this snapshot. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt this snapshot. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class InstanceTemplateGuestAccelerator(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int count: The number of the guest accelerator cards exposed to this instance.
        :param _builtins.str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InstanceTemplateIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class InstanceTemplateIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class InstanceTemplateNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConfigs":
            suggest = "access_configs"
        elif key == "aliasIpRanges":
            suggest = "alias_ip_ranges"
        elif key == "internalIpv6PrefixLength":
            suggest = "internal_ipv6_prefix_length"
        elif key == "ipv6AccessConfigs":
            suggest = "ipv6_access_configs"
        elif key == "ipv6AccessType":
            suggest = "ipv6_access_type"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "networkAttachment":
            suggest = "network_attachment"
        elif key == "networkIp":
            suggest = "network_ip"
        elif key == "nicType":
            suggest = "nic_type"
        elif key == "queueCount":
            suggest = "queue_count"
        elif key == "stackType":
            suggest = "stack_type"
        elif key == "subnetworkProject":
            suggest = "subnetwork_project"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_configs: Optional[Sequence['outputs.InstanceTemplateNetworkInterfaceAccessConfig']] = None,
                 alias_ip_ranges: Optional[Sequence['outputs.InstanceTemplateNetworkInterfaceAliasIpRange']] = None,
                 internal_ipv6_prefix_length: Optional[_builtins.int] = None,
                 ipv6_access_configs: Optional[Sequence['outputs.InstanceTemplateNetworkInterfaceIpv6AccessConfig']] = None,
                 ipv6_access_type: Optional[_builtins.str] = None,
                 ipv6_address: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None,
                 network_attachment: Optional[_builtins.str] = None,
                 network_ip: Optional[_builtins.str] = None,
                 nic_type: Optional[_builtins.str] = None,
                 queue_count: Optional[_builtins.int] = None,
                 stack_type: Optional[_builtins.str] = None,
                 subnetwork: Optional[_builtins.str] = None,
                 subnetwork_project: Optional[_builtins.str] = None):
        """
        :param Sequence['InstanceTemplateNetworkInterfaceAccessConfigArgs'] access_configs: Access configurations, i.e. IPs via which this
               instance can be accessed via the Internet. Omit to ensure that the instance
               is not accessible from the Internet (this means that ssh provisioners will
               not work unless you can send traffic to the instance's
               network (e.g. via tunnel or because it is running on another cloud instance
               on that network). This block can be specified once per `network_interface`. Structure documented below.
        :param Sequence['InstanceTemplateNetworkInterfaceAliasIpRangeArgs'] alias_ip_ranges: An
               array of alias IP ranges for this network interface. Can only be specified for network
               interfaces on subnet-mode networks. Structure documented below.
        :param _builtins.int internal_ipv6_prefix_length: The prefix length of the primary internal IPv6 range.
        :param Sequence['InstanceTemplateNetworkInterfaceIpv6AccessConfigArgs'] ipv6_access_configs: An array of IPv6 access configurations for this interface.
               Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
               specified, then this instance will have no external IPv6 Internet access. Structure documented below.
        :param _builtins.str ipv6_access_type: One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
        :param _builtins.str ipv6_address: An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        :param _builtins.str name: The name of the instance template. If you leave
               this blank, the provider will auto-generate a unique name.
        :param _builtins.str network: The name or self_link of the network to attach this interface to.
               Use `network` attribute for Legacy or Auto subnetted networks and
               `subnetwork` for custom subnetted networks.
        :param _builtins.str network_attachment: The URL of the network attachment that this interface should connect to in the following format: projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}.
        :param _builtins.str network_ip: The private IP address to assign to the instance. If
               empty, the address will be automatically assigned.
        :param _builtins.str nic_type: The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET, MRDMA, IRDMA.
        :param _builtins.int queue_count: The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        :param _builtins.str stack_type: The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6, IPV6_ONLY or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
        :param _builtins.str subnetwork: the name of the subnetwork to attach this interface
               to. The subnetwork must exist in the same `region` this instance will be
               created in. Either `network` or `subnetwork` must be provided.
        :param _builtins.str subnetwork_project: The ID of the project in which the subnetwork belongs.
               If it is not provided, the provider project is used.
        """
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if alias_ip_ranges is not None:
            pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        if internal_ipv6_prefix_length is not None:
            pulumi.set(__self__, "internal_ipv6_prefix_length", internal_ipv6_prefix_length)
        if ipv6_access_configs is not None:
            pulumi.set(__self__, "ipv6_access_configs", ipv6_access_configs)
        if ipv6_access_type is not None:
            pulumi.set(__self__, "ipv6_access_type", ipv6_access_type)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_attachment is not None:
            pulumi.set(__self__, "network_attachment", network_attachment)
        if network_ip is not None:
            pulumi.set(__self__, "network_ip", network_ip)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if queue_count is not None:
            pulumi.set(__self__, "queue_count", queue_count)
        if stack_type is not None:
            pulumi.set(__self__, "stack_type", stack_type)
        if subnetwork is not None:
            pulumi.set(__self__, "subnetwork", subnetwork)
        if subnetwork_project is not None:
            pulumi.set(__self__, "subnetwork_project", subnetwork_project)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.InstanceTemplateNetworkInterfaceAccessConfig']]:
        """
        Access configurations, i.e. IPs via which this
        instance can be accessed via the Internet. Omit to ensure that the instance
        is not accessible from the Internet (this means that ssh provisioners will
        not work unless you can send traffic to the instance's
        network (e.g. via tunnel or because it is running on another cloud instance
        on that network). This block can be specified once per `network_interface`. Structure documented below.
        """
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[Sequence['outputs.InstanceTemplateNetworkInterfaceAliasIpRange']]:
        """
        An
        array of alias IP ranges for this network interface. Can only be specified for network
        interfaces on subnet-mode networks. Structure documented below.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="internalIpv6PrefixLength")
    def internal_ipv6_prefix_length(self) -> Optional[_builtins.int]:
        """
        The prefix length of the primary internal IPv6 range.
        """
        return pulumi.get(self, "internal_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessConfigs")
    def ipv6_access_configs(self) -> Optional[Sequence['outputs.InstanceTemplateNetworkInterfaceIpv6AccessConfig']]:
        """
        An array of IPv6 access configurations for this interface.
        Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
        specified, then this instance will have no external IPv6 Internet access. Structure documented below.
        """
        return pulumi.get(self, "ipv6_access_configs")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessType")
    def ipv6_access_type(self) -> Optional[_builtins.str]:
        """
        One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
        """
        return pulumi.get(self, "ipv6_access_type")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[_builtins.str]:
        """
        An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the instance template. If you leave
        this blank, the provider will auto-generate a unique name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        The name or self_link of the network to attach this interface to.
        Use `network` attribute for Legacy or Auto subnetted networks and
        `subnetwork` for custom subnetted networks.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="networkAttachment")
    def network_attachment(self) -> Optional[_builtins.str]:
        """
        The URL of the network attachment that this interface should connect to in the following format: projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}.
        """
        return pulumi.get(self, "network_attachment")

    @_builtins.property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> Optional[_builtins.str]:
        """
        The private IP address to assign to the instance. If
        empty, the address will be automatically assigned.
        """
        return pulumi.get(self, "network_ip")

    @_builtins.property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[_builtins.str]:
        """
        The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET, MRDMA, IRDMA.
        """
        return pulumi.get(self, "nic_type")

    @_builtins.property
    @pulumi.getter(name="queueCount")
    def queue_count(self) -> Optional[_builtins.int]:
        """
        The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        """
        return pulumi.get(self, "queue_count")

    @_builtins.property
    @pulumi.getter(name="stackType")
    def stack_type(self) -> Optional[_builtins.str]:
        """
        The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6, IPV6_ONLY or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
        """
        return pulumi.get(self, "stack_type")

    @_builtins.property
    @pulumi.getter
    def subnetwork(self) -> Optional[_builtins.str]:
        """
        the name of the subnetwork to attach this interface
        to. The subnetwork must exist in the same `region` this instance will be
        created in. Either `network` or `subnetwork` must be provided.
        """
        return pulumi.get(self, "subnetwork")

    @_builtins.property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> Optional[_builtins.str]:
        """
        The ID of the project in which the subnetwork belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "subnetwork_project")


@pulumi.output_type
class InstanceTemplateNetworkInterfaceAccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "natIp":
            suggest = "nat_ip"
        elif key == "networkTier":
            suggest = "network_tier"
        elif key == "publicPtrDomainName":
            suggest = "public_ptr_domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateNetworkInterfaceAccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateNetworkInterfaceAccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateNetworkInterfaceAccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nat_ip: Optional[_builtins.str] = None,
                 network_tier: Optional[_builtins.str] = None,
                 public_ptr_domain_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str nat_ip: The IP address that will be 1:1 mapped to the instance's
               network ip. If not given, one will be generated.
        :param _builtins.str network_tier: The service-level to be provided for IPv6 traffic when the
               subnet has an external subnet. Only PREMIUM and STANDARD tier is valid for IPv6.
        :param _builtins.str public_ptr_domain_name: The DNS domain name for the public PTR record.The DNS domain name for the public PTR record.
        """
        if nat_ip is not None:
            pulumi.set(__self__, "nat_ip", nat_ip)
        if network_tier is not None:
            pulumi.set(__self__, "network_tier", network_tier)
        if public_ptr_domain_name is not None:
            pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)

    @_builtins.property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> Optional[_builtins.str]:
        """
        The IP address that will be 1:1 mapped to the instance's
        network ip. If not given, one will be generated.
        """
        return pulumi.get(self, "nat_ip")

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> Optional[_builtins.str]:
        """
        The service-level to be provided for IPv6 traffic when the
        subnet has an external subnet. Only PREMIUM and STANDARD tier is valid for IPv6.
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[_builtins.str]:
        """
        The DNS domain name for the public PTR record.The DNS domain name for the public PTR record.
        """
        return pulumi.get(self, "public_ptr_domain_name")


@pulumi.output_type
class InstanceTemplateNetworkInterfaceAliasIpRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipCidrRange":
            suggest = "ip_cidr_range"
        elif key == "subnetworkRangeName":
            suggest = "subnetwork_range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateNetworkInterfaceAliasIpRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateNetworkInterfaceAliasIpRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateNetworkInterfaceAliasIpRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_cidr_range: _builtins.str,
                 subnetwork_range_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip_cidr_range: The IP CIDR range represented by this alias IP range. This IP CIDR range
               must belong to the specified subnetwork and cannot contain IP addresses reserved by
               system or used by other network interfaces. At the time of writing only a
               netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
               error.
        :param _builtins.str subnetwork_range_name: The subnetwork secondary range name specifying
               the secondary range from which to allocate the IP CIDR range for this alias IP
               range. If left unspecified, the primary range of the subnetwork will be used.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        if subnetwork_range_name is not None:
            pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @_builtins.property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> _builtins.str:
        """
        The IP CIDR range represented by this alias IP range. This IP CIDR range
        must belong to the specified subnetwork and cannot contain IP addresses reserved by
        system or used by other network interfaces. At the time of writing only a
        netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
        error.
        """
        return pulumi.get(self, "ip_cidr_range")

    @_builtins.property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> Optional[_builtins.str]:
        """
        The subnetwork secondary range name specifying
        the secondary range from which to allocate the IP CIDR range for this alias IP
        range. If left unspecified, the primary range of the subnetwork will be used.
        """
        return pulumi.get(self, "subnetwork_range_name")


@pulumi.output_type
class InstanceTemplateNetworkInterfaceIpv6AccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkTier":
            suggest = "network_tier"
        elif key == "externalIpv6":
            suggest = "external_ipv6"
        elif key == "externalIpv6PrefixLength":
            suggest = "external_ipv6_prefix_length"
        elif key == "publicPtrDomainName":
            suggest = "public_ptr_domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateNetworkInterfaceIpv6AccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateNetworkInterfaceIpv6AccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateNetworkInterfaceIpv6AccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_tier: _builtins.str,
                 external_ipv6: Optional[_builtins.str] = None,
                 external_ipv6_prefix_length: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 public_ptr_domain_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str network_tier: The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
        :param _builtins.str external_ipv6: The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. The field is output only, an IPv6 address from a subnetwork associated with the instance will be allocated dynamically.
        :param _builtins.str external_ipv6_prefix_length: The prefix length of the external IPv6 range.
        :param _builtins.str name: The name of the instance template. If you leave
               this blank, the provider will auto-generate a unique name.
        :param _builtins.str public_ptr_domain_name: The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
        """
        pulumi.set(__self__, "network_tier", network_tier)
        if external_ipv6 is not None:
            pulumi.set(__self__, "external_ipv6", external_ipv6)
        if external_ipv6_prefix_length is not None:
            pulumi.set(__self__, "external_ipv6_prefix_length", external_ipv6_prefix_length)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ptr_domain_name is not None:
            pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> _builtins.str:
        """
        The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="externalIpv6")
    def external_ipv6(self) -> Optional[_builtins.str]:
        """
        The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. The field is output only, an IPv6 address from a subnetwork associated with the instance will be allocated dynamically.
        """
        return pulumi.get(self, "external_ipv6")

    @_builtins.property
    @pulumi.getter(name="externalIpv6PrefixLength")
    def external_ipv6_prefix_length(self) -> Optional[_builtins.str]:
        """
        The prefix length of the external IPv6 range.
        """
        return pulumi.get(self, "external_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the instance template. If you leave
        this blank, the provider will auto-generate a unique name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[_builtins.str]:
        """
        The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
        """
        return pulumi.get(self, "public_ptr_domain_name")


@pulumi.output_type
class InstanceTemplateNetworkPerformanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalEgressBandwidthTier":
            suggest = "total_egress_bandwidth_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateNetworkPerformanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateNetworkPerformanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateNetworkPerformanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_egress_bandwidth_tier: _builtins.str):
        """
        :param _builtins.str total_egress_bandwidth_tier: The egress bandwidth tier to enable. Possible values: TIER_1, DEFAULT
        """
        pulumi.set(__self__, "total_egress_bandwidth_tier", total_egress_bandwidth_tier)

    @_builtins.property
    @pulumi.getter(name="totalEgressBandwidthTier")
    def total_egress_bandwidth_tier(self) -> _builtins.str:
        """
        The egress bandwidth tier to enable. Possible values: TIER_1, DEFAULT
        """
        return pulumi.get(self, "total_egress_bandwidth_tier")


@pulumi.output_type
class InstanceTemplateReservationAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "specificReservation":
            suggest = "specific_reservation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateReservationAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateReservationAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateReservationAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 specific_reservation: Optional['outputs.InstanceTemplateReservationAffinitySpecificReservation'] = None):
        """
        :param _builtins.str type: The type of reservation from which this instance can consume resources.
        :param 'InstanceTemplateReservationAffinitySpecificReservationArgs' specific_reservation: Specifies the label selector for the reservation to use..
               Structure is documented below.
        """
        pulumi.set(__self__, "type", type)
        if specific_reservation is not None:
            pulumi.set(__self__, "specific_reservation", specific_reservation)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of reservation from which this instance can consume resources.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="specificReservation")
    def specific_reservation(self) -> Optional['outputs.InstanceTemplateReservationAffinitySpecificReservation']:
        """
        Specifies the label selector for the reservation to use..
        Structure is documented below.
        """
        return pulumi.get(self, "specific_reservation")


@pulumi.output_type
class InstanceTemplateReservationAffinitySpecificReservation(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
        :param Sequence[_builtins.str] values: Corresponds to the label values of a reservation resource.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Corresponds to the label values of a reservation resource.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class InstanceTemplateScheduling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automaticRestart":
            suggest = "automatic_restart"
        elif key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "gracefulShutdown":
            suggest = "graceful_shutdown"
        elif key == "hostErrorTimeoutSeconds":
            suggest = "host_error_timeout_seconds"
        elif key == "instanceTerminationAction":
            suggest = "instance_termination_action"
        elif key == "localSsdRecoveryTimeouts":
            suggest = "local_ssd_recovery_timeouts"
        elif key == "maintenanceInterval":
            suggest = "maintenance_interval"
        elif key == "maxRunDuration":
            suggest = "max_run_duration"
        elif key == "minNodeCpus":
            suggest = "min_node_cpus"
        elif key == "nodeAffinities":
            suggest = "node_affinities"
        elif key == "onHostMaintenance":
            suggest = "on_host_maintenance"
        elif key == "onInstanceStopAction":
            suggest = "on_instance_stop_action"
        elif key == "provisioningModel":
            suggest = "provisioning_model"
        elif key == "skipGuestOsShutdown":
            suggest = "skip_guest_os_shutdown"
        elif key == "terminationTime":
            suggest = "termination_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateScheduling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateScheduling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateScheduling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automatic_restart: Optional[_builtins.bool] = None,
                 availability_domain: Optional[_builtins.int] = None,
                 graceful_shutdown: Optional['outputs.InstanceTemplateSchedulingGracefulShutdown'] = None,
                 host_error_timeout_seconds: Optional[_builtins.int] = None,
                 instance_termination_action: Optional[_builtins.str] = None,
                 local_ssd_recovery_timeouts: Optional[Sequence['outputs.InstanceTemplateSchedulingLocalSsdRecoveryTimeout']] = None,
                 maintenance_interval: Optional[_builtins.str] = None,
                 max_run_duration: Optional['outputs.InstanceTemplateSchedulingMaxRunDuration'] = None,
                 min_node_cpus: Optional[_builtins.int] = None,
                 node_affinities: Optional[Sequence['outputs.InstanceTemplateSchedulingNodeAffinity']] = None,
                 on_host_maintenance: Optional[_builtins.str] = None,
                 on_instance_stop_action: Optional['outputs.InstanceTemplateSchedulingOnInstanceStopAction'] = None,
                 preemptible: Optional[_builtins.bool] = None,
                 provisioning_model: Optional[_builtins.str] = None,
                 skip_guest_os_shutdown: Optional[_builtins.bool] = None,
                 termination_time: Optional[_builtins.str] = None):
        """
        :param _builtins.bool automatic_restart: Specifies whether the instance should be
               automatically restarted if it is terminated by Compute Engine (not
               terminated by a user). This defaults to true.
        :param _builtins.int availability_domain: Specifies the availability domain to place the instance in. The value must be a number between 1 and the number of availability domains specified in the spread placement policy attached to the instance.
        :param 'InstanceTemplateSchedulingGracefulShutdownArgs' graceful_shutdown: Settings for the instance to perform a graceful shutdown. Structure is documented below.
        :param _builtins.int host_error_timeout_seconds: Specifies the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
        :param _builtins.str instance_termination_action: Describe the type of termination action for `SPOT` VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
        :param Sequence['InstanceTemplateSchedulingLocalSsdRecoveryTimeoutArgs'] local_ssd_recovery_timeouts: Specifies the maximum amount of time a Local Ssd Vm should wait while
                 recovery of the Local Ssd state is attempted. Its value should be in
                 between 0 and 168 hours with hour granularity and the default value being 1
                 hour.
        :param _builtins.str maintenance_interval: Specifies the frequency of planned maintenance events. The accepted values are: `PERIODIC`.
        :param 'InstanceTemplateSchedulingMaxRunDurationArgs' max_run_duration: The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in `instance_termination_action`. Structure is documented below.
        :param _builtins.int min_node_cpus: Minimum number of cpus for the instance.
        :param Sequence['InstanceTemplateSchedulingNodeAffinityArgs'] node_affinities: Specifies node affinities or anti-affinities
               to determine which sole-tenant nodes your instances and managed instance
               groups will use as host systems. Read more on sole-tenant node creation
               [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
               Structure documented below.
        :param _builtins.str on_host_maintenance: Defines the maintenance behavior for this
               instance.
        :param 'InstanceTemplateSchedulingOnInstanceStopActionArgs' on_instance_stop_action: Specifies the action to be performed when the instance is terminated using `max_run_duration` and `STOP` `instance_termination_action`. Only support `true` `discard_local_ssd` at this point. Structure is documented below.
        :param _builtins.bool preemptible: Allows instance to be preempted. This defaults to
               false. Read more on this
               [here](https://cloud.google.com/compute/docs/instances/preemptible).
        :param _builtins.str provisioning_model: Describe the type of preemptible VM. This field accepts the value `STANDARD` or `SPOT`. If the value is `STANDARD`, there will be no discount. If this   is set to `SPOT`,
               `preemptible` should be `true` and `automatic_restart` should be
               `false`. For more info about
               `SPOT`, read [here](https://cloud.google.com/compute/docs/instances/spot)
        :param _builtins.bool skip_guest_os_shutdown: Boolean parameter. Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        :param _builtins.str termination_time: Specifies the timestamp, when the instance will be terminated, in RFC3339 text format. If specified, the instance termination action will be performed at the termination time.
        """
        if automatic_restart is not None:
            pulumi.set(__self__, "automatic_restart", automatic_restart)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if graceful_shutdown is not None:
            pulumi.set(__self__, "graceful_shutdown", graceful_shutdown)
        if host_error_timeout_seconds is not None:
            pulumi.set(__self__, "host_error_timeout_seconds", host_error_timeout_seconds)
        if instance_termination_action is not None:
            pulumi.set(__self__, "instance_termination_action", instance_termination_action)
        if local_ssd_recovery_timeouts is not None:
            pulumi.set(__self__, "local_ssd_recovery_timeouts", local_ssd_recovery_timeouts)
        if maintenance_interval is not None:
            pulumi.set(__self__, "maintenance_interval", maintenance_interval)
        if max_run_duration is not None:
            pulumi.set(__self__, "max_run_duration", max_run_duration)
        if min_node_cpus is not None:
            pulumi.set(__self__, "min_node_cpus", min_node_cpus)
        if node_affinities is not None:
            pulumi.set(__self__, "node_affinities", node_affinities)
        if on_host_maintenance is not None:
            pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        if on_instance_stop_action is not None:
            pulumi.set(__self__, "on_instance_stop_action", on_instance_stop_action)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)
        if provisioning_model is not None:
            pulumi.set(__self__, "provisioning_model", provisioning_model)
        if skip_guest_os_shutdown is not None:
            pulumi.set(__self__, "skip_guest_os_shutdown", skip_guest_os_shutdown)
        if termination_time is not None:
            pulumi.set(__self__, "termination_time", termination_time)

    @_builtins.property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the instance should be
        automatically restarted if it is terminated by Compute Engine (not
        terminated by a user). This defaults to true.
        """
        return pulumi.get(self, "automatic_restart")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[_builtins.int]:
        """
        Specifies the availability domain to place the instance in. The value must be a number between 1 and the number of availability domains specified in the spread placement policy attached to the instance.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="gracefulShutdown")
    def graceful_shutdown(self) -> Optional['outputs.InstanceTemplateSchedulingGracefulShutdown']:
        """
        Settings for the instance to perform a graceful shutdown. Structure is documented below.
        """
        return pulumi.get(self, "graceful_shutdown")

    @_builtins.property
    @pulumi.getter(name="hostErrorTimeoutSeconds")
    def host_error_timeout_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
        """
        return pulumi.get(self, "host_error_timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="instanceTerminationAction")
    def instance_termination_action(self) -> Optional[_builtins.str]:
        """
        Describe the type of termination action for `SPOT` VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
        """
        return pulumi.get(self, "instance_termination_action")

    @_builtins.property
    @pulumi.getter(name="localSsdRecoveryTimeouts")
    def local_ssd_recovery_timeouts(self) -> Optional[Sequence['outputs.InstanceTemplateSchedulingLocalSsdRecoveryTimeout']]:
        """
        Specifies the maximum amount of time a Local Ssd Vm should wait while
          recovery of the Local Ssd state is attempted. Its value should be in
          between 0 and 168 hours with hour granularity and the default value being 1
          hour.
        """
        return pulumi.get(self, "local_ssd_recovery_timeouts")

    @_builtins.property
    @pulumi.getter(name="maintenanceInterval")
    def maintenance_interval(self) -> Optional[_builtins.str]:
        """
        Specifies the frequency of planned maintenance events. The accepted values are: `PERIODIC`.
        """
        return pulumi.get(self, "maintenance_interval")

    @_builtins.property
    @pulumi.getter(name="maxRunDuration")
    def max_run_duration(self) -> Optional['outputs.InstanceTemplateSchedulingMaxRunDuration']:
        """
        The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in `instance_termination_action`. Structure is documented below.
        """
        return pulumi.get(self, "max_run_duration")

    @_builtins.property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> Optional[_builtins.int]:
        """
        Minimum number of cpus for the instance.
        """
        return pulumi.get(self, "min_node_cpus")

    @_builtins.property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Optional[Sequence['outputs.InstanceTemplateSchedulingNodeAffinity']]:
        """
        Specifies node affinities or anti-affinities
        to determine which sole-tenant nodes your instances and managed instance
        groups will use as host systems. Read more on sole-tenant node creation
        [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
        Structure documented below.
        """
        return pulumi.get(self, "node_affinities")

    @_builtins.property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> Optional[_builtins.str]:
        """
        Defines the maintenance behavior for this
        instance.
        """
        return pulumi.get(self, "on_host_maintenance")

    @_builtins.property
    @pulumi.getter(name="onInstanceStopAction")
    def on_instance_stop_action(self) -> Optional['outputs.InstanceTemplateSchedulingOnInstanceStopAction']:
        """
        Specifies the action to be performed when the instance is terminated using `max_run_duration` and `STOP` `instance_termination_action`. Only support `true` `discard_local_ssd` at this point. Structure is documented below.
        """
        return pulumi.get(self, "on_instance_stop_action")

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> Optional[_builtins.bool]:
        """
        Allows instance to be preempted. This defaults to
        false. Read more on this
        [here](https://cloud.google.com/compute/docs/instances/preemptible).
        """
        return pulumi.get(self, "preemptible")

    @_builtins.property
    @pulumi.getter(name="provisioningModel")
    def provisioning_model(self) -> Optional[_builtins.str]:
        """
        Describe the type of preemptible VM. This field accepts the value `STANDARD` or `SPOT`. If the value is `STANDARD`, there will be no discount. If this   is set to `SPOT`,
        `preemptible` should be `true` and `automatic_restart` should be
        `false`. For more info about
        `SPOT`, read [here](https://cloud.google.com/compute/docs/instances/spot)
        """
        return pulumi.get(self, "provisioning_model")

    @_builtins.property
    @pulumi.getter(name="skipGuestOsShutdown")
    def skip_guest_os_shutdown(self) -> Optional[_builtins.bool]:
        """
        Boolean parameter. Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        """
        return pulumi.get(self, "skip_guest_os_shutdown")

    @_builtins.property
    @pulumi.getter(name="terminationTime")
    def termination_time(self) -> Optional[_builtins.str]:
        """
        Specifies the timestamp, when the instance will be terminated, in RFC3339 text format. If specified, the instance termination action will be performed at the termination time.
        """
        return pulumi.get(self, "termination_time")


@pulumi.output_type
class InstanceTemplateSchedulingGracefulShutdown(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxDuration":
            suggest = "max_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateSchedulingGracefulShutdown. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateSchedulingGracefulShutdown.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateSchedulingGracefulShutdown.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 max_duration: Optional['outputs.InstanceTemplateSchedulingGracefulShutdownMaxDuration'] = None):
        """
        :param _builtins.bool enabled: Opts-in for graceful shutdown.
        :param 'InstanceTemplateSchedulingGracefulShutdownMaxDurationArgs' max_duration: The time allotted for the instance to gracefully shut down.
               If the graceful shutdown isn't complete after this time, then the instance
               transitions to the STOPPING state. Structure is documented below:
        """
        pulumi.set(__self__, "enabled", enabled)
        if max_duration is not None:
            pulumi.set(__self__, "max_duration", max_duration)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Opts-in for graceful shutdown.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxDuration")
    def max_duration(self) -> Optional['outputs.InstanceTemplateSchedulingGracefulShutdownMaxDuration']:
        """
        The time allotted for the instance to gracefully shut down.
        If the graceful shutdown isn't complete after this time, then the instance
        transitions to the STOPPING state. Structure is documented below:
        """
        return pulumi.get(self, "max_duration")


@pulumi.output_type
class InstanceTemplateSchedulingGracefulShutdownMaxDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               The value must be between 1 and 3600, which is 3,600 seconds (one hour).`
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented with a 0
               `seconds` field and a positive `nanos` field. Must be from 0 to
               999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        The value must be between 1 and 3600, which is 3,600 seconds (one hour).`
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented with a 0
        `seconds` field and a positive `nanos` field. Must be from 0 to
        999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class InstanceTemplateSchedulingLocalSsdRecoveryTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second. Must be from 0 to
               315,576,000,000 inclusive. Note: these bounds are computed from: 60
               sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented with a 0
               `seconds` field and a positive `nanos` field. Must be from 0 to
               999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second. Must be from 0 to
        315,576,000,000 inclusive. Note: these bounds are computed from: 60
        sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented with a 0
        `seconds` field and a positive `nanos` field. Must be from 0 to
        999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class InstanceTemplateSchedulingMaxRunDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second. Must be from 0 to
               315,576,000,000 inclusive. Note: these bounds are computed from: 60
               sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented with a 0
               `seconds` field and a positive `nanos` field. Must be from 0 to
               999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second. Must be from 0 to
        315,576,000,000 inclusive. Note: these bounds are computed from: 60
        sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented with a 0
        `seconds` field and a positive `nanos` field. Must be from 0 to
        999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class InstanceTemplateSchedulingNodeAffinity(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key for the node affinity label.
        :param _builtins.str operator: The operator. Can be `IN` for node-affinities
               or `NOT_IN` for anti-affinities.
        :param Sequence[_builtins.str] values: Corresponds to the label values of a reservation resource.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key for the node affinity label.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator. Can be `IN` for node-affinities
        or `NOT_IN` for anti-affinities.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Corresponds to the label values of a reservation resource.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class InstanceTemplateSchedulingOnInstanceStopAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discardLocalSsd":
            suggest = "discard_local_ssd"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateSchedulingOnInstanceStopAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateSchedulingOnInstanceStopAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateSchedulingOnInstanceStopAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 discard_local_ssd: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool discard_local_ssd: Whether to discard local SSDs attached to the VM while terminating using `max_run_duration`. Only supports `true` at this point.
        """
        if discard_local_ssd is not None:
            pulumi.set(__self__, "discard_local_ssd", discard_local_ssd)

    @_builtins.property
    @pulumi.getter(name="discardLocalSsd")
    def discard_local_ssd(self) -> Optional[_builtins.bool]:
        """
        Whether to discard local SSDs attached to the VM while terminating using `max_run_duration`. Only supports `true` at this point.
        """
        return pulumi.get(self, "discard_local_ssd")


@pulumi.output_type
class InstanceTemplateServiceAccount(dict):
    def __init__(__self__, *,
                 scopes: Sequence[_builtins.str],
                 email: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] scopes: A list of service scopes. Both OAuth2 URLs and gcloud
               short names are supported. To allow full access to all Cloud APIs, use the
               `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
               
               The [service accounts documentation](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)
               explains that access scopes are the legacy method of specifying permissions for your instance.
               To follow best practices you should create a dedicated service account with the minimum permissions the VM requires.
               To use a dedicated service account this field should be configured as a list containing the `cloud-platform` scope.
               See [Authenticate workloads using service accounts best practices](https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances#best_practices)
               and [Best practices for using service accounts](https://cloud.google.com/iam/docs/best-practices-service-accounts#single-purpose).
        :param _builtins.str email: The service account e-mail address. If not given, the
               default Google Compute Engine service account is used.
        """
        pulumi.set(__self__, "scopes", scopes)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        """
        A list of service scopes. Both OAuth2 URLs and gcloud
        short names are supported. To allow full access to all Cloud APIs, use the
        `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).

        The [service accounts documentation](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)
        explains that access scopes are the legacy method of specifying permissions for your instance.
        To follow best practices you should create a dedicated service account with the minimum permissions the VM requires.
        To use a dedicated service account this field should be configured as a list containing the `cloud-platform` scope.
        See [Authenticate workloads using service accounts best practices](https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances#best_practices)
        and [Best practices for using service accounts](https://cloud.google.com/iam/docs/best-practices-service-accounts#single-purpose).
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The service account e-mail address. If not given, the
        default Google Compute Engine service account is used.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class InstanceTemplateShieldedInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIntegrityMonitoring":
            suggest = "enable_integrity_monitoring"
        elif key == "enableSecureBoot":
            suggest = "enable_secure_boot"
        elif key == "enableVtpm":
            suggest = "enable_vtpm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTemplateShieldedInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTemplateShieldedInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTemplateShieldedInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[_builtins.bool] = None,
                 enable_secure_boot: Optional[_builtins.bool] = None,
                 enable_vtpm: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable_integrity_monitoring: - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        :param _builtins.bool enable_secure_boot: - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        :param _builtins.bool enable_vtpm: - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        """
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        if enable_vtpm is not None:
            pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @_builtins.property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[_builtins.bool]:
        """
        - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @_builtins.property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[_builtins.bool]:
        """
        - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        """
        return pulumi.get(self, "enable_secure_boot")

    @_builtins.property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> Optional[_builtins.bool]:
        """
        - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        """
        return pulumi.get(self, "enable_vtpm")


@pulumi.output_type
class InstantSnapshotIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class InstantSnapshotIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class InterconnectApplicationAwareInterconnect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandwidthPercentagePolicy":
            suggest = "bandwidth_percentage_policy"
        elif key == "profileDescription":
            suggest = "profile_description"
        elif key == "shapeAveragePercentages":
            suggest = "shape_average_percentages"
        elif key == "strictPriorityPolicy":
            suggest = "strict_priority_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectApplicationAwareInterconnect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectApplicationAwareInterconnect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectApplicationAwareInterconnect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth_percentage_policy: Optional['outputs.InterconnectApplicationAwareInterconnectBandwidthPercentagePolicy'] = None,
                 profile_description: Optional[_builtins.str] = None,
                 shape_average_percentages: Optional[Sequence['outputs.InterconnectApplicationAwareInterconnectShapeAveragePercentage']] = None,
                 strict_priority_policy: Optional['outputs.InterconnectApplicationAwareInterconnectStrictPriorityPolicy'] = None):
        """
        :param 'InterconnectApplicationAwareInterconnectBandwidthPercentagePolicyArgs' bandwidth_percentage_policy: Bandwidth Percentage policy allows you to have granular control over how your Interconnect
               bandwidth is utilized among your workloads mapping to different traffic classes.
               Structure is documented below.
        :param _builtins.str profile_description: A description for the AAI profile on this interconnect.
        :param Sequence['InterconnectApplicationAwareInterconnectShapeAveragePercentageArgs'] shape_average_percentages: Optional field to specify a list of shape average percentages to be
               applied in conjunction with StrictPriorityPolicy or BandwidthPercentagePolicy
               Structure is documented below.
        :param 'InterconnectApplicationAwareInterconnectStrictPriorityPolicyArgs' strict_priority_policy: Specify configuration for StrictPriorityPolicy.
        """
        if bandwidth_percentage_policy is not None:
            pulumi.set(__self__, "bandwidth_percentage_policy", bandwidth_percentage_policy)
        if profile_description is not None:
            pulumi.set(__self__, "profile_description", profile_description)
        if shape_average_percentages is not None:
            pulumi.set(__self__, "shape_average_percentages", shape_average_percentages)
        if strict_priority_policy is not None:
            pulumi.set(__self__, "strict_priority_policy", strict_priority_policy)

    @_builtins.property
    @pulumi.getter(name="bandwidthPercentagePolicy")
    def bandwidth_percentage_policy(self) -> Optional['outputs.InterconnectApplicationAwareInterconnectBandwidthPercentagePolicy']:
        """
        Bandwidth Percentage policy allows you to have granular control over how your Interconnect
        bandwidth is utilized among your workloads mapping to different traffic classes.
        Structure is documented below.
        """
        return pulumi.get(self, "bandwidth_percentage_policy")

    @_builtins.property
    @pulumi.getter(name="profileDescription")
    def profile_description(self) -> Optional[_builtins.str]:
        """
        A description for the AAI profile on this interconnect.
        """
        return pulumi.get(self, "profile_description")

    @_builtins.property
    @pulumi.getter(name="shapeAveragePercentages")
    def shape_average_percentages(self) -> Optional[Sequence['outputs.InterconnectApplicationAwareInterconnectShapeAveragePercentage']]:
        """
        Optional field to specify a list of shape average percentages to be
        applied in conjunction with StrictPriorityPolicy or BandwidthPercentagePolicy
        Structure is documented below.
        """
        return pulumi.get(self, "shape_average_percentages")

    @_builtins.property
    @pulumi.getter(name="strictPriorityPolicy")
    def strict_priority_policy(self) -> Optional['outputs.InterconnectApplicationAwareInterconnectStrictPriorityPolicy']:
        """
        Specify configuration for StrictPriorityPolicy.
        """
        return pulumi.get(self, "strict_priority_policy")


@pulumi.output_type
class InterconnectApplicationAwareInterconnectBandwidthPercentagePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandwidthPercentages":
            suggest = "bandwidth_percentages"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectApplicationAwareInterconnectBandwidthPercentagePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectApplicationAwareInterconnectBandwidthPercentagePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectApplicationAwareInterconnectBandwidthPercentagePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth_percentages: Optional[Sequence['outputs.InterconnectApplicationAwareInterconnectBandwidthPercentagePolicyBandwidthPercentage']] = None):
        """
        :param Sequence['InterconnectApplicationAwareInterconnectBandwidthPercentagePolicyBandwidthPercentageArgs'] bandwidth_percentages: Specify bandwidth percentages for various traffic classes for queuing
               type Bandwidth Percent.
               Structure is documented below.
        """
        if bandwidth_percentages is not None:
            pulumi.set(__self__, "bandwidth_percentages", bandwidth_percentages)

    @_builtins.property
    @pulumi.getter(name="bandwidthPercentages")
    def bandwidth_percentages(self) -> Optional[Sequence['outputs.InterconnectApplicationAwareInterconnectBandwidthPercentagePolicyBandwidthPercentage']]:
        """
        Specify bandwidth percentages for various traffic classes for queuing
        type Bandwidth Percent.
        Structure is documented below.
        """
        return pulumi.get(self, "bandwidth_percentages")


@pulumi.output_type
class InterconnectApplicationAwareInterconnectBandwidthPercentagePolicyBandwidthPercentage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trafficClass":
            suggest = "traffic_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectApplicationAwareInterconnectBandwidthPercentagePolicyBandwidthPercentage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectApplicationAwareInterconnectBandwidthPercentagePolicyBandwidthPercentage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectApplicationAwareInterconnectBandwidthPercentagePolicyBandwidthPercentage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentage: Optional[_builtins.int] = None,
                 traffic_class: Optional[_builtins.str] = None):
        """
        :param _builtins.int percentage: Bandwidth percentage for a specific traffic class.
        :param _builtins.str traffic_class: Enum representing the various traffic classes offered by AAI.
               Default value is `TC_UNSPECIFIED`.
               Possible values are: `TC_UNSPECIFIED`, `TC1`, `TC2`, `TC3`, `TC4`, `TC5`, `TC6`.
        """
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)
        if traffic_class is not None:
            pulumi.set(__self__, "traffic_class", traffic_class)

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.int]:
        """
        Bandwidth percentage for a specific traffic class.
        """
        return pulumi.get(self, "percentage")

    @_builtins.property
    @pulumi.getter(name="trafficClass")
    def traffic_class(self) -> Optional[_builtins.str]:
        """
        Enum representing the various traffic classes offered by AAI.
        Default value is `TC_UNSPECIFIED`.
        Possible values are: `TC_UNSPECIFIED`, `TC1`, `TC2`, `TC3`, `TC4`, `TC5`, `TC6`.
        """
        return pulumi.get(self, "traffic_class")


@pulumi.output_type
class InterconnectApplicationAwareInterconnectShapeAveragePercentage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trafficClass":
            suggest = "traffic_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectApplicationAwareInterconnectShapeAveragePercentage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectApplicationAwareInterconnectShapeAveragePercentage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectApplicationAwareInterconnectShapeAveragePercentage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentage: Optional[_builtins.int] = None,
                 traffic_class: Optional[_builtins.str] = None):
        """
        :param _builtins.int percentage: Bandwidth percentage for a specific traffic class.
        :param _builtins.str traffic_class: Enum representing the various traffic classes offered by AAI.
               Default value is `TC_UNSPECIFIED`.
               Possible values are: `TC_UNSPECIFIED`, `TC1`, `TC2`, `TC3`, `TC4`, `TC5`, `TC6`.
        """
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)
        if traffic_class is not None:
            pulumi.set(__self__, "traffic_class", traffic_class)

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.int]:
        """
        Bandwidth percentage for a specific traffic class.
        """
        return pulumi.get(self, "percentage")

    @_builtins.property
    @pulumi.getter(name="trafficClass")
    def traffic_class(self) -> Optional[_builtins.str]:
        """
        Enum representing the various traffic classes offered by AAI.
        Default value is `TC_UNSPECIFIED`.
        Possible values are: `TC_UNSPECIFIED`, `TC1`, `TC2`, `TC3`, `TC4`, `TC5`, `TC6`.
        """
        return pulumi.get(self, "traffic_class")


@pulumi.output_type
class InterconnectApplicationAwareInterconnectStrictPriorityPolicy(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class InterconnectAttachmentGroupAttachment(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 attachment: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The identifier for this object. Format specified above.
        :param _builtins.str attachment: (Optional)
        """
        pulumi.set(__self__, "name", name)
        if attachment is not None:
            pulumi.set(__self__, "attachment", attachment)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def attachment(self) -> Optional[_builtins.str]:
        """
        (Optional)
        """
        return pulumi.get(self, "attachment")


@pulumi.output_type
class InterconnectAttachmentGroupConfigured(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilitySlas":
            suggest = "availability_slas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectAttachmentGroupConfigured. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectAttachmentGroupConfigured.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectAttachmentGroupConfigured.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_slas: Optional[Sequence['outputs.InterconnectAttachmentGroupConfiguredAvailabilitySla']] = None):
        """
        :param Sequence['InterconnectAttachmentGroupConfiguredAvailabilitySlaArgs'] availability_slas: (Output)
               Which SLA this group is configured to support, and why this
               group does or does not meet that SLA's requirements.
               Structure is documented below.
        """
        if availability_slas is not None:
            pulumi.set(__self__, "availability_slas", availability_slas)

    @_builtins.property
    @pulumi.getter(name="availabilitySlas")
    def availability_slas(self) -> Optional[Sequence['outputs.InterconnectAttachmentGroupConfiguredAvailabilitySla']]:
        """
        (Output)
        Which SLA this group is configured to support, and why this
        group does or does not meet that SLA's requirements.
        Structure is documented below.
        """
        return pulumi.get(self, "availability_slas")


@pulumi.output_type
class InterconnectAttachmentGroupConfiguredAvailabilitySla(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "effectiveSla":
            suggest = "effective_sla"
        elif key == "intendedSlaBlockers":
            suggest = "intended_sla_blockers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectAttachmentGroupConfiguredAvailabilitySla. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectAttachmentGroupConfiguredAvailabilitySla.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectAttachmentGroupConfiguredAvailabilitySla.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effective_sla: Optional[_builtins.str] = None,
                 intended_sla_blockers: Optional[Sequence['outputs.InterconnectAttachmentGroupConfiguredAvailabilitySlaIntendedSlaBlocker']] = None):
        """
        :param _builtins.str effective_sla: (Output)
               Which SLA this group supports. Options are the same as the
               intent.
        :param Sequence['InterconnectAttachmentGroupConfiguredAvailabilitySlaIntendedSlaBlockerArgs'] intended_sla_blockers: (Output)
               Reasons why configuration.availabilitySLA.sla differs from
               intent.availabilitySLA. This list is empty if and only if those are the
               same.
               Structure is documented below.
        """
        if effective_sla is not None:
            pulumi.set(__self__, "effective_sla", effective_sla)
        if intended_sla_blockers is not None:
            pulumi.set(__self__, "intended_sla_blockers", intended_sla_blockers)

    @_builtins.property
    @pulumi.getter(name="effectiveSla")
    def effective_sla(self) -> Optional[_builtins.str]:
        """
        (Output)
        Which SLA this group supports. Options are the same as the
        intent.
        """
        return pulumi.get(self, "effective_sla")

    @_builtins.property
    @pulumi.getter(name="intendedSlaBlockers")
    def intended_sla_blockers(self) -> Optional[Sequence['outputs.InterconnectAttachmentGroupConfiguredAvailabilitySlaIntendedSlaBlocker']]:
        """
        (Output)
        Reasons why configuration.availabilitySLA.sla differs from
        intent.availabilitySLA. This list is empty if and only if those are the
        same.
        Structure is documented below.
        """
        return pulumi.get(self, "intended_sla_blockers")


@pulumi.output_type
class InterconnectAttachmentGroupConfiguredAvailabilitySlaIntendedSlaBlocker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockerType":
            suggest = "blocker_type"
        elif key == "documentationLink":
            suggest = "documentation_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectAttachmentGroupConfiguredAvailabilitySlaIntendedSlaBlocker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectAttachmentGroupConfiguredAvailabilitySlaIntendedSlaBlocker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectAttachmentGroupConfiguredAvailabilitySlaIntendedSlaBlocker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachments: Optional[Sequence[_builtins.str]] = None,
                 blocker_type: Optional[_builtins.str] = None,
                 documentation_link: Optional[_builtins.str] = None,
                 explanation: Optional[_builtins.str] = None,
                 metros: Optional[Sequence[_builtins.str]] = None,
                 regions: Optional[Sequence[_builtins.str]] = None,
                 zones: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] attachments: Attachments in the AttachmentGroup. Keys are arbitrary user-specified
               strings. Users are encouraged, but not required, to use their preferred
               format for resource links as keys.
               Note that there are add-members and remove-members methods in gcloud.
               The size of this map is limited by an "Attachments per group" quota.
               Structure is documented below.
        :param _builtins.str blocker_type: (Output)
               The category of an unmet SLA requirement.
        :param _builtins.str documentation_link: (Output)
               The url of Google Cloud public documentation explaining
               this requirement. This is set for every type of requirement.
        :param _builtins.str explanation: (Output)
               A human-readable explanation of this requirement and
               why it's not met. This is set for every type of requirement.
        :param Sequence[_builtins.str] metros: (Output)
               Metros used to explain this blocker in more detail.
               These are three-letter lowercase strings like "iad". This will be set
               for some blockers (like NO_ATTACHMENTS_IN_METRO_AND_ZONE) but does
               not apply to others.
        :param Sequence[_builtins.str] regions: (Output)
               Regions used to explain this blocker in more
               detail. These are region names formatted like "us-central1". This
               will be set for some blockers (like INCOMPATIBLE_REGIONS) but does
               not apply to others.
        :param Sequence[_builtins.str] zones: (Output)
               Zones used to explain this blocker in more detail.
               Format is "zone1" and/or "zone2". This will be set for some blockers
               (like  MISSING_ZONE) but does not apply to others.
        """
        if attachments is not None:
            pulumi.set(__self__, "attachments", attachments)
        if blocker_type is not None:
            pulumi.set(__self__, "blocker_type", blocker_type)
        if documentation_link is not None:
            pulumi.set(__self__, "documentation_link", documentation_link)
        if explanation is not None:
            pulumi.set(__self__, "explanation", explanation)
        if metros is not None:
            pulumi.set(__self__, "metros", metros)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter
    def attachments(self) -> Optional[Sequence[_builtins.str]]:
        """
        Attachments in the AttachmentGroup. Keys are arbitrary user-specified
        strings. Users are encouraged, but not required, to use their preferred
        format for resource links as keys.
        Note that there are add-members and remove-members methods in gcloud.
        The size of this map is limited by an "Attachments per group" quota.
        Structure is documented below.
        """
        return pulumi.get(self, "attachments")

    @_builtins.property
    @pulumi.getter(name="blockerType")
    def blocker_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The category of an unmet SLA requirement.
        """
        return pulumi.get(self, "blocker_type")

    @_builtins.property
    @pulumi.getter(name="documentationLink")
    def documentation_link(self) -> Optional[_builtins.str]:
        """
        (Output)
        The url of Google Cloud public documentation explaining
        this requirement. This is set for every type of requirement.
        """
        return pulumi.get(self, "documentation_link")

    @_builtins.property
    @pulumi.getter
    def explanation(self) -> Optional[_builtins.str]:
        """
        (Output)
        A human-readable explanation of this requirement and
        why it's not met. This is set for every type of requirement.
        """
        return pulumi.get(self, "explanation")

    @_builtins.property
    @pulumi.getter
    def metros(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        Metros used to explain this blocker in more detail.
        These are three-letter lowercase strings like "iad". This will be set
        for some blockers (like NO_ATTACHMENTS_IN_METRO_AND_ZONE) but does
        not apply to others.
        """
        return pulumi.get(self, "metros")

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        Regions used to explain this blocker in more
        detail. These are region names formatted like "us-central1". This
        will be set for some blockers (like INCOMPATIBLE_REGIONS) but does
        not apply to others.
        """
        return pulumi.get(self, "regions")

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        Zones used to explain this blocker in more detail.
        Format is "zone1" and/or "zone2". This will be set for some blockers
        (like  MISSING_ZONE) but does not apply to others.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class InterconnectAttachmentGroupIntent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilitySla":
            suggest = "availability_sla"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectAttachmentGroupIntent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectAttachmentGroupIntent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectAttachmentGroupIntent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_sla: Optional[_builtins.str] = None):
        """
        :param _builtins.str availability_sla: Which SLA the user intends this group to support.
               Possible values are: `PRODUCTION_NON_CRITICAL`, `PRODUCTION_CRITICAL`, `NO_SLA`, `AVAILABILITY_SLA_UNSPECIFIED`.
        """
        if availability_sla is not None:
            pulumi.set(__self__, "availability_sla", availability_sla)

    @_builtins.property
    @pulumi.getter(name="availabilitySla")
    def availability_sla(self) -> Optional[_builtins.str]:
        """
        Which SLA the user intends this group to support.
        Possible values are: `PRODUCTION_NON_CRITICAL`, `PRODUCTION_CRITICAL`, `NO_SLA`, `AVAILABILITY_SLA_UNSPECIFIED`.
        """
        return pulumi.get(self, "availability_sla")


@pulumi.output_type
class InterconnectAttachmentGroupLogicalStructure(dict):
    def __init__(__self__, *,
                 regions: Optional[Sequence['outputs.InterconnectAttachmentGroupLogicalStructureRegion']] = None):
        """
        :param Sequence['InterconnectAttachmentGroupLogicalStructureRegionArgs'] regions: (Output)
               Regions used to explain this blocker in more
               detail. These are region names formatted like "us-central1". This
               will be set for some blockers (like INCOMPATIBLE_REGIONS) but does
               not apply to others.
        """
        if regions is not None:
            pulumi.set(__self__, "regions", regions)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[Sequence['outputs.InterconnectAttachmentGroupLogicalStructureRegion']]:
        """
        (Output)
        Regions used to explain this blocker in more
        detail. These are region names formatted like "us-central1". This
        will be set for some blockers (like INCOMPATIBLE_REGIONS) but does
        not apply to others.
        """
        return pulumi.get(self, "regions")


@pulumi.output_type
class InterconnectAttachmentGroupLogicalStructureRegion(dict):
    def __init__(__self__, *,
                 metros: Optional[Sequence['outputs.InterconnectAttachmentGroupLogicalStructureRegionMetro']] = None,
                 region: Optional[_builtins.str] = None):
        """
        :param Sequence['InterconnectAttachmentGroupLogicalStructureRegionMetroArgs'] metros: (Output)
               Metros used to explain this blocker in more detail.
               These are three-letter lowercase strings like "iad". This will be set
               for some blockers (like NO_ATTACHMENTS_IN_METRO_AND_ZONE) but does
               not apply to others.
        :param _builtins.str region: (Output)
               The name of a region, like "us-central1".
        """
        if metros is not None:
            pulumi.set(__self__, "metros", metros)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def metros(self) -> Optional[Sequence['outputs.InterconnectAttachmentGroupLogicalStructureRegionMetro']]:
        """
        (Output)
        Metros used to explain this blocker in more detail.
        These are three-letter lowercase strings like "iad". This will be set
        for some blockers (like NO_ATTACHMENTS_IN_METRO_AND_ZONE) but does
        not apply to others.
        """
        return pulumi.get(self, "metros")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of a region, like "us-central1".
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class InterconnectAttachmentGroupLogicalStructureRegionMetro(dict):
    def __init__(__self__, *,
                 facilities: Optional[Sequence['outputs.InterconnectAttachmentGroupLogicalStructureRegionMetroFacility']] = None,
                 metro: Optional[_builtins.str] = None):
        """
        :param Sequence['InterconnectAttachmentGroupLogicalStructureRegionMetroFacilityArgs'] facilities: (Output)
               The facilities used for this group's Attachments'
               Interconnects.
               Structure is documented below.
        :param _builtins.str metro: (Output)
               The name of the metro, as a three-letter lowercase
               string like "iad". This is the first component of the location of an
               Interconnect.
        """
        if facilities is not None:
            pulumi.set(__self__, "facilities", facilities)
        if metro is not None:
            pulumi.set(__self__, "metro", metro)

    @_builtins.property
    @pulumi.getter
    def facilities(self) -> Optional[Sequence['outputs.InterconnectAttachmentGroupLogicalStructureRegionMetroFacility']]:
        """
        (Output)
        The facilities used for this group's Attachments'
        Interconnects.
        Structure is documented below.
        """
        return pulumi.get(self, "facilities")

    @_builtins.property
    @pulumi.getter
    def metro(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the metro, as a three-letter lowercase
        string like "iad". This is the first component of the location of an
        Interconnect.
        """
        return pulumi.get(self, "metro")


@pulumi.output_type
class InterconnectAttachmentGroupLogicalStructureRegionMetroFacility(dict):
    def __init__(__self__, *,
                 facility: Optional[_builtins.str] = None,
                 zones: Optional[Sequence['outputs.InterconnectAttachmentGroupLogicalStructureRegionMetroFacilityZone']] = None):
        """
        :param _builtins.str facility: (Output)
               The name of a facility, like "iad-1234".
        :param Sequence['InterconnectAttachmentGroupLogicalStructureRegionMetroFacilityZoneArgs'] zones: (Output)
               Zones used to explain this blocker in more detail.
               Format is "zone1" and/or "zone2". This will be set for some blockers
               (like  MISSING_ZONE) but does not apply to others.
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter
    def facility(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of a facility, like "iad-1234".
        """
        return pulumi.get(self, "facility")

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Optional[Sequence['outputs.InterconnectAttachmentGroupLogicalStructureRegionMetroFacilityZone']]:
        """
        (Output)
        Zones used to explain this blocker in more detail.
        Format is "zone1" and/or "zone2". This will be set for some blockers
        (like  MISSING_ZONE) but does not apply to others.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class InterconnectAttachmentGroupLogicalStructureRegionMetroFacilityZone(dict):
    def __init__(__self__, *,
                 attachments: Optional[Sequence[_builtins.str]] = None,
                 zone: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] attachments: (Output)
               URLs of Attachments in the given zone, to the given
               region, on Interconnects in the given facility and metro. Every
               Attachment in the AG has such an entry.
        :param _builtins.str zone: (Output)
               The zones that Attachments in this group are present
               in, in the given facilities.  This is inherited from their
               Interconnects.
        """
        if attachments is not None:
            pulumi.set(__self__, "attachments", attachments)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def attachments(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        URLs of Attachments in the given zone, to the given
        region, on Interconnects in the given facility and metro. Every
        Attachment in the AG has such an entry.
        """
        return pulumi.get(self, "attachments")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        (Output)
        The zones that Attachments in this group are present
        in, in the given facilities.  This is inherited from their
        Interconnects.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class InterconnectAttachmentPrivateInterconnectInfo(dict):
    def __init__(__self__, *,
                 tag8021q: Optional[_builtins.int] = None):
        """
        :param _builtins.int tag8021q: (Output)
               802.1q encapsulation tag to be used for traffic between
               Google and the customer, going to and from this network and region.
        """
        if tag8021q is not None:
            pulumi.set(__self__, "tag8021q", tag8021q)

    @_builtins.property
    @pulumi.getter
    def tag8021q(self) -> Optional[_builtins.int]:
        """
        (Output)
        802.1q encapsulation tag to be used for traffic between
        Google and the customer, going to and from this network and region.
        """
        return pulumi.get(self, "tag8021q")


@pulumi.output_type
class InterconnectCircuitInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerDemarcId":
            suggest = "customer_demarc_id"
        elif key == "googleCircuitId":
            suggest = "google_circuit_id"
        elif key == "googleDemarcId":
            suggest = "google_demarc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectCircuitInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectCircuitInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectCircuitInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_demarc_id: Optional[_builtins.str] = None,
                 google_circuit_id: Optional[_builtins.str] = None,
                 google_demarc_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str customer_demarc_id: (Output)
               Customer-side demarc ID for this circuit.
        :param _builtins.str google_circuit_id: (Output)
               Google-assigned unique ID for this circuit. Assigned at circuit turn-up.
        :param _builtins.str google_demarc_id: (Output)
               Google-side demarc ID for this circuit. Assigned at circuit turn-up and provided by
               Google to the customer in the LOA.
        """
        if customer_demarc_id is not None:
            pulumi.set(__self__, "customer_demarc_id", customer_demarc_id)
        if google_circuit_id is not None:
            pulumi.set(__self__, "google_circuit_id", google_circuit_id)
        if google_demarc_id is not None:
            pulumi.set(__self__, "google_demarc_id", google_demarc_id)

    @_builtins.property
    @pulumi.getter(name="customerDemarcId")
    def customer_demarc_id(self) -> Optional[_builtins.str]:
        """
        (Output)
        Customer-side demarc ID for this circuit.
        """
        return pulumi.get(self, "customer_demarc_id")

    @_builtins.property
    @pulumi.getter(name="googleCircuitId")
    def google_circuit_id(self) -> Optional[_builtins.str]:
        """
        (Output)
        Google-assigned unique ID for this circuit. Assigned at circuit turn-up.
        """
        return pulumi.get(self, "google_circuit_id")

    @_builtins.property
    @pulumi.getter(name="googleDemarcId")
    def google_demarc_id(self) -> Optional[_builtins.str]:
        """
        (Output)
        Google-side demarc ID for this circuit. Assigned at circuit turn-up and provided by
        Google to the customer in the LOA.
        """
        return pulumi.get(self, "google_demarc_id")


@pulumi.output_type
class InterconnectExpectedOutage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "affectedCircuits":
            suggest = "affected_circuits"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "issueType":
            suggest = "issue_type"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectExpectedOutage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectExpectedOutage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectExpectedOutage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affected_circuits: Optional[Sequence[_builtins.str]] = None,
                 description: Optional[_builtins.str] = None,
                 end_time: Optional[_builtins.str] = None,
                 issue_type: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] affected_circuits: (Output)
               If issueType is IT_PARTIAL_OUTAGE, a list of the Google-side circuit IDs that will be
               affected.
        :param _builtins.str description: An optional description of this resource. Provide this property when you create the resource.
        :param _builtins.str end_time: (Output)
               Scheduled end time for the outage (milliseconds since Unix epoch).
        :param _builtins.str issue_type: (Output)
               Form this outage is expected to take. Note that the versions of this enum prefixed with
               "IT_" have been deprecated in favor of the unprefixed values. Can take one of the
               following values:
               - OUTAGE: The Interconnect may be completely out of service for some or all of the
               specified window.
               - PARTIAL_OUTAGE: Some circuits comprising the Interconnect as a whole should remain
               up, but with reduced bandwidth.
        :param _builtins.str name: Name of the resource. Provided by the client when the resource is created. The name must be
               1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters
               long and match the regular expression `a-z?` which means the first
               character must be a lowercase letter, and all following characters must be a dash,
               lowercase letter, or digit, except the last character, which cannot be a dash.
        :param _builtins.str source: (Output)
               The party that generated this notification. Note that the value of NSRC_GOOGLE has been
               deprecated in favor of GOOGLE. Can take the following value:
               - GOOGLE: this notification as generated by Google.
        :param _builtins.str start_time: (Output)
               Scheduled start time for the outage (milliseconds since Unix epoch).
        :param _builtins.str state: (Output)
               State of this notification. Note that the versions of this enum prefixed with "NS_" have
               been deprecated in favor of the unprefixed values. Can take one of the following values:
               - ACTIVE: This outage notification is active. The event could be in the past, present,
               or future. See startTime and endTime for scheduling.
               - CANCELLED: The outage associated with this notification was cancelled before the
               outage was due to start.
               - COMPLETED: The outage associated with this notification is complete.
        """
        if affected_circuits is not None:
            pulumi.set(__self__, "affected_circuits", affected_circuits)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if issue_type is not None:
            pulumi.set(__self__, "issue_type", issue_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="affectedCircuits")
    def affected_circuits(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        If issueType is IT_PARTIAL_OUTAGE, a list of the Google-side circuit IDs that will be
        affected.
        """
        return pulumi.get(self, "affected_circuits")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resource. Provide this property when you create the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Scheduled end time for the outage (milliseconds since Unix epoch).
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="issueType")
    def issue_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        Form this outage is expected to take. Note that the versions of this enum prefixed with
        "IT_" have been deprecated in favor of the unprefixed values. Can take one of the
        following values:
        - OUTAGE: The Interconnect may be completely out of service for some or all of the
        specified window.
        - PARTIAL_OUTAGE: Some circuits comprising the Interconnect as a whole should remain
        up, but with reduced bandwidth.
        """
        return pulumi.get(self, "issue_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the resource. Provided by the client when the resource is created. The name must be
        1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters
        long and match the regular expression `a-z?` which means the first
        character must be a lowercase letter, and all following characters must be a dash,
        lowercase letter, or digit, except the last character, which cannot be a dash.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        (Output)
        The party that generated this notification. Note that the value of NSRC_GOOGLE has been
        deprecated in favor of GOOGLE. Can take the following value:
        - GOOGLE: this notification as generated by Google.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Scheduled start time for the outage (milliseconds since Unix epoch).
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        State of this notification. Note that the versions of this enum prefixed with "NS_" have
        been deprecated in favor of the unprefixed values. Can take one of the following values:
        - ACTIVE: This outage notification is active. The event could be in the past, present,
        or future. See startTime and endTime for scheduling.
        - CANCELLED: The outage associated with this notification was cancelled before the
        outage was due to start.
        - COMPLETED: The outage associated with this notification is complete.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class InterconnectGroupConfigured(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topologyCapabilities":
            suggest = "topology_capabilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectGroupConfigured. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectGroupConfigured.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectGroupConfigured.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topology_capabilities: Optional[Sequence['outputs.InterconnectGroupConfiguredTopologyCapability']] = None):
        """
        :param Sequence['InterconnectGroupConfiguredTopologyCapabilityArgs'] topology_capabilities: (Output)
               How reliable this topology is configured to be, and why
               this group does or does not meet the requirements for the intended
               capability.
               Structure is documented below.
        """
        if topology_capabilities is not None:
            pulumi.set(__self__, "topology_capabilities", topology_capabilities)

    @_builtins.property
    @pulumi.getter(name="topologyCapabilities")
    def topology_capabilities(self) -> Optional[Sequence['outputs.InterconnectGroupConfiguredTopologyCapability']]:
        """
        (Output)
        How reliable this topology is configured to be, and why
        this group does or does not meet the requirements for the intended
        capability.
        Structure is documented below.
        """
        return pulumi.get(self, "topology_capabilities")


@pulumi.output_type
class InterconnectGroupConfiguredTopologyCapability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intendedCapabilityBlockers":
            suggest = "intended_capability_blockers"
        elif key == "supportedSla":
            suggest = "supported_sla"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectGroupConfiguredTopologyCapability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectGroupConfiguredTopologyCapability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectGroupConfiguredTopologyCapability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 intended_capability_blockers: Optional[Sequence['outputs.InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlocker']] = None,
                 supported_sla: Optional[_builtins.str] = None):
        """
        :param Sequence['InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockerArgs'] intended_capability_blockers: (Output)
               Reasons why configuration.topologyCapability.sla differs
               from intent.topologyCapability. This list is empty if and only if those
               are the same.
               Structure is documented below.
        :param _builtins.str supported_sla: (Output)
               Which level of reliability this group is configured to
               support.
        """
        if intended_capability_blockers is not None:
            pulumi.set(__self__, "intended_capability_blockers", intended_capability_blockers)
        if supported_sla is not None:
            pulumi.set(__self__, "supported_sla", supported_sla)

    @_builtins.property
    @pulumi.getter(name="intendedCapabilityBlockers")
    def intended_capability_blockers(self) -> Optional[Sequence['outputs.InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlocker']]:
        """
        (Output)
        Reasons why configuration.topologyCapability.sla differs
        from intent.topologyCapability. This list is empty if and only if those
        are the same.
        Structure is documented below.
        """
        return pulumi.get(self, "intended_capability_blockers")

    @_builtins.property
    @pulumi.getter(name="supportedSla")
    def supported_sla(self) -> Optional[_builtins.str]:
        """
        (Output)
        Which level of reliability this group is configured to
        support.
        """
        return pulumi.get(self, "supported_sla")


@pulumi.output_type
class InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlocker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockerType":
            suggest = "blocker_type"
        elif key == "documentationLink":
            suggest = "documentation_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlocker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlocker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlocker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blocker_type: Optional[_builtins.str] = None,
                 documentation_link: Optional[_builtins.str] = None,
                 explanation: Optional[_builtins.str] = None,
                 facilities: Optional[Sequence[_builtins.str]] = None,
                 interconnects: Optional[Sequence[_builtins.str]] = None,
                 metros: Optional[Sequence[_builtins.str]] = None,
                 zones: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str blocker_type: (Output)
               The category of an unmet SLA requirement. The Intended
               SLA Blockers section below explains this field and how it relates to
               other fields in intendedCapabilityBlockers.
        :param _builtins.str documentation_link: (Output)
               The url of Google Cloud public documentation explaining
               this requirement. This is set for every type of requirement.
        :param _builtins.str explanation: (Output)
               A human-readable explanation of this requirement and
               why it's not met. This is set for every type of requirement.
        :param Sequence[_builtins.str] facilities: (Output)
               Facilities used to explain this blocker in more detail.
               Like physicalStructure.metros.facilities.facility, this is a numeric
               string like "5467".
        :param Sequence[_builtins.str] interconnects: Interconnects in the InterconnectGroup. Keys are arbitrary user-specified
               strings. Users are encouraged, but not required, to use their preferred
               format for resource links as keys.
               Note that there are add-members and remove-members methods in gcloud.
               The size of this map is limited by an "Interconnects per group" quota.
               Structure is documented below.
        :param Sequence[_builtins.str] metros: (Output)
               Metros used to explain this blocker in more detail.
               These are three-letter lowercase strings like "iad". A blocker like
               INCOMPATIBLE_METROS will specify the problematic metros in this
               field.
        :param Sequence[_builtins.str] zones: (Output)
               Zones used to explain this blocker in more detail.
               Zone names are "zone1" and/or "zone2".
        """
        if blocker_type is not None:
            pulumi.set(__self__, "blocker_type", blocker_type)
        if documentation_link is not None:
            pulumi.set(__self__, "documentation_link", documentation_link)
        if explanation is not None:
            pulumi.set(__self__, "explanation", explanation)
        if facilities is not None:
            pulumi.set(__self__, "facilities", facilities)
        if interconnects is not None:
            pulumi.set(__self__, "interconnects", interconnects)
        if metros is not None:
            pulumi.set(__self__, "metros", metros)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter(name="blockerType")
    def blocker_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The category of an unmet SLA requirement. The Intended
        SLA Blockers section below explains this field and how it relates to
        other fields in intendedCapabilityBlockers.
        """
        return pulumi.get(self, "blocker_type")

    @_builtins.property
    @pulumi.getter(name="documentationLink")
    def documentation_link(self) -> Optional[_builtins.str]:
        """
        (Output)
        The url of Google Cloud public documentation explaining
        this requirement. This is set for every type of requirement.
        """
        return pulumi.get(self, "documentation_link")

    @_builtins.property
    @pulumi.getter
    def explanation(self) -> Optional[_builtins.str]:
        """
        (Output)
        A human-readable explanation of this requirement and
        why it's not met. This is set for every type of requirement.
        """
        return pulumi.get(self, "explanation")

    @_builtins.property
    @pulumi.getter
    def facilities(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        Facilities used to explain this blocker in more detail.
        Like physicalStructure.metros.facilities.facility, this is a numeric
        string like "5467".
        """
        return pulumi.get(self, "facilities")

    @_builtins.property
    @pulumi.getter
    def interconnects(self) -> Optional[Sequence[_builtins.str]]:
        """
        Interconnects in the InterconnectGroup. Keys are arbitrary user-specified
        strings. Users are encouraged, but not required, to use their preferred
        format for resource links as keys.
        Note that there are add-members and remove-members methods in gcloud.
        The size of this map is limited by an "Interconnects per group" quota.
        Structure is documented below.
        """
        return pulumi.get(self, "interconnects")

    @_builtins.property
    @pulumi.getter
    def metros(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        Metros used to explain this blocker in more detail.
        These are three-letter lowercase strings like "iad". A blocker like
        INCOMPATIBLE_METROS will specify the problematic metros in this
        field.
        """
        return pulumi.get(self, "metros")

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        Zones used to explain this blocker in more detail.
        Zone names are "zone1" and/or "zone2".
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class InterconnectGroupIntent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topologyCapability":
            suggest = "topology_capability"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectGroupIntent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectGroupIntent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectGroupIntent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topology_capability: Optional[_builtins.str] = None):
        """
        :param _builtins.str topology_capability: The reliability the user intends this group to be capable of, in terms
               of the Interconnect product SLAs.
               Possible values are: `PRODUCTION_NON_CRITICAL`, `PRODUCTION_CRITICAL`, `NO_SLA`, `AVAILABILITY_SLA_UNSPECIFIED`.
        """
        if topology_capability is not None:
            pulumi.set(__self__, "topology_capability", topology_capability)

    @_builtins.property
    @pulumi.getter(name="topologyCapability")
    def topology_capability(self) -> Optional[_builtins.str]:
        """
        The reliability the user intends this group to be capable of, in terms
        of the Interconnect product SLAs.
        Possible values are: `PRODUCTION_NON_CRITICAL`, `PRODUCTION_CRITICAL`, `NO_SLA`, `AVAILABILITY_SLA_UNSPECIFIED`.
        """
        return pulumi.get(self, "topology_capability")


@pulumi.output_type
class InterconnectGroupInterconnect(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 interconnect: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The identifier for this object. Format specified above.
        :param _builtins.str interconnect: The URL of an Interconnect in this group. All Interconnects in the group are unique.
        """
        pulumi.set(__self__, "name", name)
        if interconnect is not None:
            pulumi.set(__self__, "interconnect", interconnect)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def interconnect(self) -> Optional[_builtins.str]:
        """
        The URL of an Interconnect in this group. All Interconnects in the group are unique.
        """
        return pulumi.get(self, "interconnect")


@pulumi.output_type
class InterconnectGroupPhysicalStructure(dict):
    def __init__(__self__, *,
                 metros: Optional[Sequence['outputs.InterconnectGroupPhysicalStructureMetro']] = None):
        """
        :param Sequence['InterconnectGroupPhysicalStructureMetroArgs'] metros: (Output)
               Metros used to explain this blocker in more detail.
               These are three-letter lowercase strings like "iad". A blocker like
               INCOMPATIBLE_METROS will specify the problematic metros in this
               field.
        """
        if metros is not None:
            pulumi.set(__self__, "metros", metros)

    @_builtins.property
    @pulumi.getter
    def metros(self) -> Optional[Sequence['outputs.InterconnectGroupPhysicalStructureMetro']]:
        """
        (Output)
        Metros used to explain this blocker in more detail.
        These are three-letter lowercase strings like "iad". A blocker like
        INCOMPATIBLE_METROS will specify the problematic metros in this
        field.
        """
        return pulumi.get(self, "metros")


@pulumi.output_type
class InterconnectGroupPhysicalStructureMetro(dict):
    def __init__(__self__, *,
                 facilities: Optional[Sequence['outputs.InterconnectGroupPhysicalStructureMetroFacility']] = None,
                 metro: Optional[_builtins.str] = None):
        """
        :param Sequence['InterconnectGroupPhysicalStructureMetroFacilityArgs'] facilities: (Output)
               Facilities used to explain this blocker in more detail.
               Like physicalStructure.metros.facilities.facility, this is a numeric
               string like "5467".
        :param _builtins.str metro: (Output)
               The name of the metro, as a three-letter lowercase string
               like "iad". This is the first component of the location of
               Interconnects underneath this.
        """
        if facilities is not None:
            pulumi.set(__self__, "facilities", facilities)
        if metro is not None:
            pulumi.set(__self__, "metro", metro)

    @_builtins.property
    @pulumi.getter
    def facilities(self) -> Optional[Sequence['outputs.InterconnectGroupPhysicalStructureMetroFacility']]:
        """
        (Output)
        Facilities used to explain this blocker in more detail.
        Like physicalStructure.metros.facilities.facility, this is a numeric
        string like "5467".
        """
        return pulumi.get(self, "facilities")

    @_builtins.property
    @pulumi.getter
    def metro(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the metro, as a three-letter lowercase string
        like "iad". This is the first component of the location of
        Interconnects underneath this.
        """
        return pulumi.get(self, "metro")


@pulumi.output_type
class InterconnectGroupPhysicalStructureMetroFacility(dict):
    def __init__(__self__, *,
                 facility: Optional[_builtins.str] = None,
                 zones: Optional[Sequence['outputs.InterconnectGroupPhysicalStructureMetroFacilityZone']] = None):
        """
        :param _builtins.str facility: (Output)
               The ID of this facility, as a numeric string like
               "5467". This is the third component of the location of Interconnects
               in this facility.
        :param Sequence['InterconnectGroupPhysicalStructureMetroFacilityZoneArgs'] zones: (Output)
               Zones used to explain this blocker in more detail.
               Zone names are "zone1" and/or "zone2".
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter
    def facility(self) -> Optional[_builtins.str]:
        """
        (Output)
        The ID of this facility, as a numeric string like
        "5467". This is the third component of the location of Interconnects
        in this facility.
        """
        return pulumi.get(self, "facility")

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Optional[Sequence['outputs.InterconnectGroupPhysicalStructureMetroFacilityZone']]:
        """
        (Output)
        Zones used to explain this blocker in more detail.
        Zone names are "zone1" and/or "zone2".
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class InterconnectGroupPhysicalStructureMetroFacilityZone(dict):
    def __init__(__self__, *,
                 interconnects: Optional[Sequence[_builtins.str]] = None,
                 zone: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] interconnects: Interconnects in the InterconnectGroup. Keys are arbitrary user-specified
               strings. Users are encouraged, but not required, to use their preferred
               format for resource links as keys.
               Note that there are add-members and remove-members methods in gcloud.
               The size of this map is limited by an "Interconnects per group" quota.
               Structure is documented below.
        :param _builtins.str zone: (Output)
               The name of the zone, either "zone1" or "zone2".
               This is the second component of the location of Interconnects in
               this facility.
        """
        if interconnects is not None:
            pulumi.set(__self__, "interconnects", interconnects)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def interconnects(self) -> Optional[Sequence[_builtins.str]]:
        """
        Interconnects in the InterconnectGroup. Keys are arbitrary user-specified
        strings. Users are encouraged, but not required, to use their preferred
        format for resource links as keys.
        Note that there are add-members and remove-members methods in gcloud.
        The size of this map is limited by an "Interconnects per group" quota.
        Structure is documented below.
        """
        return pulumi.get(self, "interconnects")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the zone, either "zone1" or "zone2".
        This is the second component of the location of Interconnects in
        this facility.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class InterconnectMacsec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preSharedKeys":
            suggest = "pre_shared_keys"
        elif key == "failOpen":
            suggest = "fail_open"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectMacsec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectMacsec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectMacsec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pre_shared_keys: Sequence['outputs.InterconnectMacsecPreSharedKey'],
                 fail_open: Optional[_builtins.bool] = None):
        """
        :param Sequence['InterconnectMacsecPreSharedKeyArgs'] pre_shared_keys: A keychain placeholder describing a set of named key objects along with their
               start times. A MACsec CKN/CAK is generated for each key in the key chain.
               Google router automatically picks the key with the most recent startTime when establishing
               or re-establishing a MACsec secure link.
               Structure is documented below.
        :param _builtins.bool fail_open: If set to true, the Interconnect connection is configured with a should-secure
               MACsec security policy, that allows the Google router to fallback to cleartext
               traffic if the MKA session cannot be established. By default, the Interconnect
               connection is configured with a must-secure security policy that drops all traffic
               if the MKA session cannot be established with your router.
        """
        pulumi.set(__self__, "pre_shared_keys", pre_shared_keys)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)

    @_builtins.property
    @pulumi.getter(name="preSharedKeys")
    def pre_shared_keys(self) -> Sequence['outputs.InterconnectMacsecPreSharedKey']:
        """
        A keychain placeholder describing a set of named key objects along with their
        start times. A MACsec CKN/CAK is generated for each key in the key chain.
        Google router automatically picks the key with the most recent startTime when establishing
        or re-establishing a MACsec secure link.
        Structure is documented below.
        """
        return pulumi.get(self, "pre_shared_keys")

    @_builtins.property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[_builtins.bool]:
        """
        If set to true, the Interconnect connection is configured with a should-secure
        MACsec security policy, that allows the Google router to fallback to cleartext
        traffic if the MKA session cannot be established. By default, the Interconnect
        connection is configured with a must-secure security policy that drops all traffic
        if the MKA session cannot be established with your router.
        """
        return pulumi.get(self, "fail_open")


@pulumi.output_type
class InterconnectMacsecPreSharedKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failOpen":
            suggest = "fail_open"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectMacsecPreSharedKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectMacsecPreSharedKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectMacsecPreSharedKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 fail_open: Optional[_builtins.bool] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A name for this pre-shared key. The name must be 1-63 characters long, and
               comply with RFC1035. Specifically, the name must be 1-63 characters long and match
               the regular expression `a-z?` which means the first character
               must be a lowercase letter, and all following characters must be a dash, lowercase
               letter, or digit, except the last character, which cannot be a dash.
        :param _builtins.bool fail_open: (Optional, Deprecated)
               If set to true, the Interconnect connection is configured with a should-secure
               MACsec security policy, that allows the Google router to fallback to cleartext
               traffic if the MKA session cannot be established. By default, the Interconnect
               connection is configured with a must-secure security policy that drops all traffic
               if the MKA session cannot be established with your router.
               
               > **Warning:** `failOpen` is deprecated and will be removed in a future major release. Use other `failOpen` instead.
        :param _builtins.str start_time: A RFC3339 timestamp on or after which the key is valid. startTime can be in the
               future. If the keychain has a single key, startTime can be omitted. If the keychain
               has multiple keys, startTime is mandatory for each key. The start times of keys must
               be in increasing order. The start times of two consecutive keys must be at least 6
               hours apart.
        """
        pulumi.set(__self__, "name", name)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A name for this pre-shared key. The name must be 1-63 characters long, and
        comply with RFC1035. Specifically, the name must be 1-63 characters long and match
        the regular expression `a-z?` which means the first character
        must be a lowercase letter, and all following characters must be a dash, lowercase
        letter, or digit, except the last character, which cannot be a dash.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="failOpen")
    @_utilities.deprecated("""`failOpen` is deprecated and will be removed in a future major release. Use other `failOpen` instead.""")
    def fail_open(self) -> Optional[_builtins.bool]:
        """
        (Optional, Deprecated)
        If set to true, the Interconnect connection is configured with a should-secure
        MACsec security policy, that allows the Google router to fallback to cleartext
        traffic if the MKA session cannot be established. By default, the Interconnect
        connection is configured with a must-secure security policy that drops all traffic
        if the MKA session cannot be established with your router.

        > **Warning:** `failOpen` is deprecated and will be removed in a future major release. Use other `failOpen` instead.
        """
        return pulumi.get(self, "fail_open")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        A RFC3339 timestamp on or after which the key is valid. startTime can be in the
        future. If the keychain has a single key, startTime can be omitted. If the keychain
        has multiple keys, startTime is mandatory for each key. The start times of keys must
        be in increasing order. The start times of two consecutive keys must be at least 6
        hours apart.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class InterconnectParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterconnectParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterconnectParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterconnectParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the interconnect. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456.
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource manager tags to be bound to the interconnect. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class MachineImageIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        :param _builtins.str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class MachineImageIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        :param _builtins.str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class MachineImageMachineImageEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyName":
            suggest = "kms_key_name"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineImageMachineImageEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineImageMachineImageEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineImageMachineImageEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_name: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_name: The name of the encryption key that is stored in Google Cloud KMS.
        :param _builtins.str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param _builtins.str sha256: (Output)
               The RFC 4648 base64 encoded SHA-256 hash of the
               customer-supplied encryption key that protects this resource.
        """
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[_builtins.str]:
        """
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        (Output)
        The RFC 4648 base64 encoded SHA-256 hash of the
        customer-supplied encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class ManagedSslCertificateManaged(dict):
    def __init__(__self__, *,
                 domains: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] domains: Domains for which a managed SSL certificate will be valid.  Currently,
               there can be up to 100 domains in this list.
        """
        pulumi.set(__self__, "domains", domains)

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Sequence[_builtins.str]:
        """
        Domains for which a managed SSL certificate will be valid.  Currently,
        there can be up to 100 domains in this list.
        """
        return pulumi.get(self, "domains")


@pulumi.output_type
class MangedSslCertificateManaged(dict):
    def __init__(__self__, *,
                 domains: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] domains: Domains for which a managed SSL certificate will be valid.  Currently,
               there can be up to 100 domains in this list.
        """
        pulumi.set(__self__, "domains", domains)

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Sequence[_builtins.str]:
        """
        Domains for which a managed SSL certificate will be valid.  Currently,
        there can be up to 100 domains in this list.
        """
        return pulumi.get(self, "domains")


@pulumi.output_type
class NetworkAttachmentConnectionEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "projectIdOrNum":
            suggest = "project_id_or_num"
        elif key == "secondaryIpCidrRanges":
            suggest = "secondary_ip_cidr_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAttachmentConnectionEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAttachmentConnectionEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAttachmentConnectionEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: Optional[_builtins.str] = None,
                 project_id_or_num: Optional[_builtins.str] = None,
                 secondary_ip_cidr_ranges: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 subnetwork: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip_address: (Output)
               The IPv4 address assigned to the producer instance network interface. This value will be a range in case of Serverless.
        :param _builtins.str project_id_or_num: (Output)
               The project id or number of the interface to which the IP was assigned.
        :param _builtins.str secondary_ip_cidr_ranges: (Output)
               Alias IP ranges from the same subnetwork.
        :param _builtins.str status: (Output)
               The status of a connected endpoint to this network attachment.
        :param _builtins.str subnetwork: (Output)
               The subnetwork used to assign the IP to the producer instance network interface.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if project_id_or_num is not None:
            pulumi.set(__self__, "project_id_or_num", project_id_or_num)
        if secondary_ip_cidr_ranges is not None:
            pulumi.set(__self__, "secondary_ip_cidr_ranges", secondary_ip_cidr_ranges)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if subnetwork is not None:
            pulumi.set(__self__, "subnetwork", subnetwork)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        """
        (Output)
        The IPv4 address assigned to the producer instance network interface. This value will be a range in case of Serverless.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="projectIdOrNum")
    def project_id_or_num(self) -> Optional[_builtins.str]:
        """
        (Output)
        The project id or number of the interface to which the IP was assigned.
        """
        return pulumi.get(self, "project_id_or_num")

    @_builtins.property
    @pulumi.getter(name="secondaryIpCidrRanges")
    def secondary_ip_cidr_ranges(self) -> Optional[_builtins.str]:
        """
        (Output)
        Alias IP ranges from the same subnetwork.
        """
        return pulumi.get(self, "secondary_ip_cidr_ranges")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        (Output)
        The status of a connected endpoint to this network attachment.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def subnetwork(self) -> Optional[_builtins.str]:
        """
        (Output)
        The subnetwork used to assign the IP to the producer instance network interface.
        """
        return pulumi.get(self, "subnetwork")


@pulumi.output_type
class NetworkEndpointListNetworkEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkEndpointListNetworkEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkEndpointListNetworkEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkEndpointListNetworkEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: _builtins.str,
                 instance: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.str ip_address: IPv4 address of network endpoint. The IP address must belong
               to a VM in GCE (either the primary IP or as part of an aliased IP
               range).
        :param _builtins.str instance: The name for a specific VM instance that the IP address belongs to.
               This is required for network endpoints of type GCE_VM_IP_PORT.
               The instance must be in the same zone as the network endpoint group.
        :param _builtins.int port: Port number of network endpoint.
               **Note** `port` is required unless the Network Endpoint Group is created
               with the type of `GCE_VM_IP`
        """
        pulumi.set(__self__, "ip_address", ip_address)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        IPv4 address of network endpoint. The IP address must belong
        to a VM in GCE (either the primary IP or as part of an aliased IP
        range).
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def instance(self) -> Optional[_builtins.str]:
        """
        The name for a specific VM instance that the IP address belongs to.
        This is required for network endpoints of type GCE_VM_IP_PORT.
        The instance must be in the same zone as the network endpoint group.
        """
        return pulumi.get(self, "instance")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port number of network endpoint.
        **Note** `port` is required unless the Network Endpoint Group is created
        with the type of `GCE_VM_IP`
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class NetworkFirewallPolicyPacketMirroringRuleMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layer4Configs":
            suggest = "layer4_configs"
        elif key == "destIpRanges":
            suggest = "dest_ip_ranges"
        elif key == "srcIpRanges":
            suggest = "src_ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyPacketMirroringRuleMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyPacketMirroringRuleMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyPacketMirroringRuleMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layer4_configs: Sequence['outputs.NetworkFirewallPolicyPacketMirroringRuleMatchLayer4Config'],
                 dest_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 src_ip_ranges: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['NetworkFirewallPolicyPacketMirroringRuleMatchLayer4ConfigArgs'] layer4_configs: Pairs of IP protocols and ports that the rule should match.
               Structure is documented below.
               
               
               <a name="nested_match_layer4_configs"></a>The `layer4_configs` block supports:
        :param Sequence[_builtins.str] dest_ip_ranges: CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
        :param Sequence[_builtins.str] src_ip_ranges: CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
        """
        pulumi.set(__self__, "layer4_configs", layer4_configs)
        if dest_ip_ranges is not None:
            pulumi.set(__self__, "dest_ip_ranges", dest_ip_ranges)
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)

    @_builtins.property
    @pulumi.getter(name="layer4Configs")
    def layer4_configs(self) -> Sequence['outputs.NetworkFirewallPolicyPacketMirroringRuleMatchLayer4Config']:
        """
        Pairs of IP protocols and ports that the rule should match.
        Structure is documented below.


        <a name="nested_match_layer4_configs"></a>The `layer4_configs` block supports:
        """
        return pulumi.get(self, "layer4_configs")

    @_builtins.property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
        """
        return pulumi.get(self, "dest_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
        """
        return pulumi.get(self, "src_ip_ranges")


@pulumi.output_type
class NetworkFirewallPolicyPacketMirroringRuleMatchLayer4Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyPacketMirroringRuleMatchLayer4Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyPacketMirroringRuleMatchLayer4Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyPacketMirroringRuleMatchLayer4Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: _builtins.str,
                 ports: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str ip_protocol: The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule.
               This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
        :param Sequence[_builtins.str] ports: An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> _builtins.str:
        """
        The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule.
        This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
        """
        return pulumi.get(self, "ip_protocol")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class NetworkFirewallPolicyPacketMirroringRuleTargetSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
               diff_suppress_func: 'tpgresource.CompareSelfLinkOrResourceName'
        :param _builtins.str state: (Output)
               State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        diff_suppress_func: 'tpgresource.CompareSelfLinkOrResourceName'
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkFirewallPolicyRuleMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layer4Configs":
            suggest = "layer4_configs"
        elif key == "destAddressGroups":
            suggest = "dest_address_groups"
        elif key == "destFqdns":
            suggest = "dest_fqdns"
        elif key == "destIpRanges":
            suggest = "dest_ip_ranges"
        elif key == "destNetworkScope":
            suggest = "dest_network_scope"
        elif key == "destRegionCodes":
            suggest = "dest_region_codes"
        elif key == "destThreatIntelligences":
            suggest = "dest_threat_intelligences"
        elif key == "srcAddressGroups":
            suggest = "src_address_groups"
        elif key == "srcFqdns":
            suggest = "src_fqdns"
        elif key == "srcIpRanges":
            suggest = "src_ip_ranges"
        elif key == "srcNetworkScope":
            suggest = "src_network_scope"
        elif key == "srcNetworks":
            suggest = "src_networks"
        elif key == "srcRegionCodes":
            suggest = "src_region_codes"
        elif key == "srcSecureTags":
            suggest = "src_secure_tags"
        elif key == "srcThreatIntelligences":
            suggest = "src_threat_intelligences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyRuleMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyRuleMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyRuleMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layer4_configs: Sequence['outputs.NetworkFirewallPolicyRuleMatchLayer4Config'],
                 dest_address_groups: Optional[Sequence[_builtins.str]] = None,
                 dest_fqdns: Optional[Sequence[_builtins.str]] = None,
                 dest_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 dest_network_scope: Optional[_builtins.str] = None,
                 dest_region_codes: Optional[Sequence[_builtins.str]] = None,
                 dest_threat_intelligences: Optional[Sequence[_builtins.str]] = None,
                 src_address_groups: Optional[Sequence[_builtins.str]] = None,
                 src_fqdns: Optional[Sequence[_builtins.str]] = None,
                 src_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 src_network_scope: Optional[_builtins.str] = None,
                 src_networks: Optional[Sequence[_builtins.str]] = None,
                 src_region_codes: Optional[Sequence[_builtins.str]] = None,
                 src_secure_tags: Optional[Sequence['outputs.NetworkFirewallPolicyRuleMatchSrcSecureTag']] = None,
                 src_threat_intelligences: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['NetworkFirewallPolicyRuleMatchLayer4ConfigArgs'] layer4_configs: Pairs of IP protocols and ports that the rule should match.
               Structure is documented below.
        :param Sequence[_builtins.str] dest_address_groups: Address groups which should be matched against the traffic destination. Maximum number of destination address groups is 10.
        :param Sequence[_builtins.str] dest_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against traffic destination. Maximum number of destination fqdn allowed is 100.
        :param Sequence[_builtins.str] dest_ip_ranges: CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
        :param _builtins.str dest_network_scope: Network scope of the traffic destination.
               Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        :param Sequence[_builtins.str] dest_region_codes: Region codes whose IP addresses will be used to match for destination of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of dest region codes allowed is 5000.
        :param Sequence[_builtins.str] dest_threat_intelligences: Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic destination.
        :param Sequence[_builtins.str] src_address_groups: Address groups which should be matched against the traffic source. Maximum number of source address groups is 10.
        :param Sequence[_builtins.str] src_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against traffic source. Maximum number of source fqdn allowed is 100.
        :param Sequence[_builtins.str] src_ip_ranges: CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
        :param _builtins.str src_network_scope: Network scope of the traffic source.
               Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        :param Sequence[_builtins.str] src_networks: Networks of the traffic source. It can be either a full or partial url.
        :param Sequence[_builtins.str] src_region_codes: Region codes whose IP addresses will be used to match for source of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of source region codes allowed is 5000.
        :param Sequence['NetworkFirewallPolicyRuleMatchSrcSecureTagArgs'] src_secure_tags: List of secure tag values, which should be matched at the source of the traffic. For INGRESS rule, if all the srcSecureTag are INEFFECTIVE, and there is no srcIpRange, this rule will be ignored. Maximum number of source tag values allowed is 256.
               Structure is documented below.
        :param Sequence[_builtins.str] src_threat_intelligences: Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic source.
               
               
               <a name="nested_match_layer4_configs"></a>The `layer4_configs` block supports:
        """
        pulumi.set(__self__, "layer4_configs", layer4_configs)
        if dest_address_groups is not None:
            pulumi.set(__self__, "dest_address_groups", dest_address_groups)
        if dest_fqdns is not None:
            pulumi.set(__self__, "dest_fqdns", dest_fqdns)
        if dest_ip_ranges is not None:
            pulumi.set(__self__, "dest_ip_ranges", dest_ip_ranges)
        if dest_network_scope is not None:
            pulumi.set(__self__, "dest_network_scope", dest_network_scope)
        if dest_region_codes is not None:
            pulumi.set(__self__, "dest_region_codes", dest_region_codes)
        if dest_threat_intelligences is not None:
            pulumi.set(__self__, "dest_threat_intelligences", dest_threat_intelligences)
        if src_address_groups is not None:
            pulumi.set(__self__, "src_address_groups", src_address_groups)
        if src_fqdns is not None:
            pulumi.set(__self__, "src_fqdns", src_fqdns)
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)
        if src_network_scope is not None:
            pulumi.set(__self__, "src_network_scope", src_network_scope)
        if src_networks is not None:
            pulumi.set(__self__, "src_networks", src_networks)
        if src_region_codes is not None:
            pulumi.set(__self__, "src_region_codes", src_region_codes)
        if src_secure_tags is not None:
            pulumi.set(__self__, "src_secure_tags", src_secure_tags)
        if src_threat_intelligences is not None:
            pulumi.set(__self__, "src_threat_intelligences", src_threat_intelligences)

    @_builtins.property
    @pulumi.getter(name="layer4Configs")
    def layer4_configs(self) -> Sequence['outputs.NetworkFirewallPolicyRuleMatchLayer4Config']:
        """
        Pairs of IP protocols and ports that the rule should match.
        Structure is documented below.
        """
        return pulumi.get(self, "layer4_configs")

    @_builtins.property
    @pulumi.getter(name="destAddressGroups")
    def dest_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic destination. Maximum number of destination address groups is 10.
        """
        return pulumi.get(self, "dest_address_groups")

    @_builtins.property
    @pulumi.getter(name="destFqdns")
    def dest_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against traffic destination. Maximum number of destination fqdn allowed is 100.
        """
        return pulumi.get(self, "dest_fqdns")

    @_builtins.property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
        """
        return pulumi.get(self, "dest_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="destNetworkScope")
    def dest_network_scope(self) -> Optional[_builtins.str]:
        """
        Network scope of the traffic destination.
        Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        """
        return pulumi.get(self, "dest_network_scope")

    @_builtins.property
    @pulumi.getter(name="destRegionCodes")
    def dest_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for destination of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of dest region codes allowed is 5000.
        """
        return pulumi.get(self, "dest_region_codes")

    @_builtins.property
    @pulumi.getter(name="destThreatIntelligences")
    def dest_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic destination.
        """
        return pulumi.get(self, "dest_threat_intelligences")

    @_builtins.property
    @pulumi.getter(name="srcAddressGroups")
    def src_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic source. Maximum number of source address groups is 10.
        """
        return pulumi.get(self, "src_address_groups")

    @_builtins.property
    @pulumi.getter(name="srcFqdns")
    def src_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against traffic source. Maximum number of source fqdn allowed is 100.
        """
        return pulumi.get(self, "src_fqdns")

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
        """
        return pulumi.get(self, "src_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="srcNetworkScope")
    def src_network_scope(self) -> Optional[_builtins.str]:
        """
        Network scope of the traffic source.
        Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        """
        return pulumi.get(self, "src_network_scope")

    @_builtins.property
    @pulumi.getter(name="srcNetworks")
    def src_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Networks of the traffic source. It can be either a full or partial url.
        """
        return pulumi.get(self, "src_networks")

    @_builtins.property
    @pulumi.getter(name="srcRegionCodes")
    def src_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for source of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of source region codes allowed is 5000.
        """
        return pulumi.get(self, "src_region_codes")

    @_builtins.property
    @pulumi.getter(name="srcSecureTags")
    def src_secure_tags(self) -> Optional[Sequence['outputs.NetworkFirewallPolicyRuleMatchSrcSecureTag']]:
        """
        List of secure tag values, which should be matched at the source of the traffic. For INGRESS rule, if all the srcSecureTag are INEFFECTIVE, and there is no srcIpRange, this rule will be ignored. Maximum number of source tag values allowed is 256.
        Structure is documented below.
        """
        return pulumi.get(self, "src_secure_tags")

    @_builtins.property
    @pulumi.getter(name="srcThreatIntelligences")
    def src_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic source.


        <a name="nested_match_layer4_configs"></a>The `layer4_configs` block supports:
        """
        return pulumi.get(self, "src_threat_intelligences")


@pulumi.output_type
class NetworkFirewallPolicyRuleMatchLayer4Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyRuleMatchLayer4Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyRuleMatchLayer4Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyRuleMatchLayer4Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: _builtins.str,
                 ports: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str ip_protocol: The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule.
               This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
        :param Sequence[_builtins.str] ports: An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> _builtins.str:
        """
        The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule.
        This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
        """
        return pulumi.get(self, "ip_protocol")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class NetworkFirewallPolicyRuleMatchSrcSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
        :param _builtins.str state: (Output)
               State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkFirewallPolicyRuleTargetSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
        :param _builtins.str state: (Output)
               State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkFirewallPolicyWithRulesPredefinedRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableLogging":
            suggest = "enable_logging"
        elif key == "ruleName":
            suggest = "rule_name"
        elif key == "securityProfileGroup":
            suggest = "security_profile_group"
        elif key == "targetSecureTags":
            suggest = "target_secure_tags"
        elif key == "targetServiceAccounts":
            suggest = "target_service_accounts"
        elif key == "tlsInspect":
            suggest = "tls_inspect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyWithRulesPredefinedRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyWithRulesPredefinedRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyWithRulesPredefinedRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 enable_logging: Optional[_builtins.bool] = None,
                 matches: Optional[Sequence['outputs.NetworkFirewallPolicyWithRulesPredefinedRuleMatch']] = None,
                 priority: Optional[_builtins.int] = None,
                 rule_name: Optional[_builtins.str] = None,
                 security_profile_group: Optional[_builtins.str] = None,
                 target_secure_tags: Optional[Sequence['outputs.NetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag']] = None,
                 target_service_accounts: Optional[Sequence[_builtins.str]] = None,
                 tls_inspect: Optional[_builtins.bool] = None):
        """
        :param _builtins.str action: (Output)
               The Action to perform when the client connection triggers the rule. Can currently be either
               "allow", "deny", "apply_security_profile_group" or "goto_next".
        :param _builtins.str description: An optional description of this resource.
        :param _builtins.str direction: (Output)
               The direction in which this rule applies. If unspecified an INGRESS rule is created.
        :param _builtins.bool disabled: (Output)
               Denotes whether the firewall policy rule is disabled. When set to true,
               the firewall policy rule is not enforced and traffic behaves as if it did
               not exist. If this is unspecified, the firewall policy rule will be
               enabled.
        :param _builtins.bool enable_logging: (Output)
               Denotes whether to enable logging for a particular rule.
               If logging is enabled, logs will be exported to the
               configured export destination in Stackdriver.
        :param Sequence['NetworkFirewallPolicyWithRulesPredefinedRuleMatchArgs'] matches: (Output)
               A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
               Structure is documented below.
        :param _builtins.int priority: (Output)
               An integer indicating the priority of a rule in the list. The priority must be a value
               between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
               highest priority and 2147483647 is the lowest priority.
        :param _builtins.str rule_name: (Output)
               An optional name for the rule. This field is not a unique identifier
               and can be updated.
        :param _builtins.str security_profile_group: (Output)
               A fully-qualified URL of a SecurityProfile resource instance.
               Example:
               https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
               Must be specified if action is 'apply_security_profile_group'.
        :param Sequence['NetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTagArgs'] target_secure_tags: (Output)
               A list of secure tags that controls which instances the firewall rule
               applies to. If <code>targetSecureTag</code> are specified, then the
               firewall rule applies only to instances in the VPC network that have one
               of those EFFECTIVE secure tags, if all the target_secure_tag are in
               INEFFECTIVE state, then this rule will be ignored.
               <code>targetSecureTag</code> may not be set at the same time as
               <code>targetServiceAccounts</code>.
               If neither <code>targetServiceAccounts</code> nor
               <code>targetSecureTag</code> are specified, the firewall rule applies
               to all instances on the specified network.
               Maximum number of target label tags allowed is 256.
               Structure is documented below.
        :param Sequence[_builtins.str] target_service_accounts: (Output)
               A list of service accounts indicating the sets of
               instances that are applied with this rule.
        :param _builtins.bool tls_inspect: (Output)
               Boolean flag indicating if the traffic should be TLS decrypted.
               It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)
        if security_profile_group is not None:
            pulumi.set(__self__, "security_profile_group", security_profile_group)
        if target_secure_tags is not None:
            pulumi.set(__self__, "target_secure_tags", target_secure_tags)
        if target_service_accounts is not None:
            pulumi.set(__self__, "target_service_accounts", target_service_accounts)
        if tls_inspect is not None:
            pulumi.set(__self__, "tls_inspect", tls_inspect)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Action to perform when the client connection triggers the rule. Can currently be either
        "allow", "deny", "apply_security_profile_group" or "goto_next".
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        (Output)
        The direction in which this rule applies. If unspecified an INGRESS rule is created.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Denotes whether the firewall policy rule is disabled. When set to true,
        the firewall policy rule is not enforced and traffic behaves as if it did
        not exist. If this is unspecified, the firewall policy rule will be
        enabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Denotes whether to enable logging for a particular rule.
        If logging is enabled, logs will be exported to the
        configured export destination in Stackdriver.
        """
        return pulumi.get(self, "enable_logging")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.NetworkFirewallPolicyWithRulesPredefinedRuleMatch']]:
        """
        (Output)
        A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
        Structure is documented below.
        """
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        (Output)
        An integer indicating the priority of a rule in the list. The priority must be a value
        between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
        highest priority and 2147483647 is the lowest priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        An optional name for the rule. This field is not a unique identifier
        and can be updated.
        """
        return pulumi.get(self, "rule_name")

    @_builtins.property
    @pulumi.getter(name="securityProfileGroup")
    def security_profile_group(self) -> Optional[_builtins.str]:
        """
        (Output)
        A fully-qualified URL of a SecurityProfile resource instance.
        Example:
        https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
        Must be specified if action is 'apply_security_profile_group'.
        """
        return pulumi.get(self, "security_profile_group")

    @_builtins.property
    @pulumi.getter(name="targetSecureTags")
    def target_secure_tags(self) -> Optional[Sequence['outputs.NetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag']]:
        """
        (Output)
        A list of secure tags that controls which instances the firewall rule
        applies to. If <code>targetSecureTag</code> are specified, then the
        firewall rule applies only to instances in the VPC network that have one
        of those EFFECTIVE secure tags, if all the target_secure_tag are in
        INEFFECTIVE state, then this rule will be ignored.
        <code>targetSecureTag</code> may not be set at the same time as
        <code>targetServiceAccounts</code>.
        If neither <code>targetServiceAccounts</code> nor
        <code>targetSecureTag</code> are specified, the firewall rule applies
        to all instances on the specified network.
        Maximum number of target label tags allowed is 256.
        Structure is documented below.
        """
        return pulumi.get(self, "target_secure_tags")

    @_builtins.property
    @pulumi.getter(name="targetServiceAccounts")
    def target_service_accounts(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        A list of service accounts indicating the sets of
        instances that are applied with this rule.
        """
        return pulumi.get(self, "target_service_accounts")

    @_builtins.property
    @pulumi.getter(name="tlsInspect")
    def tls_inspect(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Boolean flag indicating if the traffic should be TLS decrypted.
        It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
        """
        return pulumi.get(self, "tls_inspect")


@pulumi.output_type
class NetworkFirewallPolicyWithRulesPredefinedRuleMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destAddressGroups":
            suggest = "dest_address_groups"
        elif key == "destFqdns":
            suggest = "dest_fqdns"
        elif key == "destIpRanges":
            suggest = "dest_ip_ranges"
        elif key == "destRegionCodes":
            suggest = "dest_region_codes"
        elif key == "destThreatIntelligences":
            suggest = "dest_threat_intelligences"
        elif key == "layer4Configs":
            suggest = "layer4_configs"
        elif key == "srcAddressGroups":
            suggest = "src_address_groups"
        elif key == "srcFqdns":
            suggest = "src_fqdns"
        elif key == "srcIpRanges":
            suggest = "src_ip_ranges"
        elif key == "srcRegionCodes":
            suggest = "src_region_codes"
        elif key == "srcSecureTags":
            suggest = "src_secure_tags"
        elif key == "srcThreatIntelligences":
            suggest = "src_threat_intelligences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyWithRulesPredefinedRuleMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyWithRulesPredefinedRuleMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyWithRulesPredefinedRuleMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dest_address_groups: Optional[Sequence[_builtins.str]] = None,
                 dest_fqdns: Optional[Sequence[_builtins.str]] = None,
                 dest_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 dest_region_codes: Optional[Sequence[_builtins.str]] = None,
                 dest_threat_intelligences: Optional[Sequence[_builtins.str]] = None,
                 layer4_configs: Optional[Sequence['outputs.NetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config']] = None,
                 src_address_groups: Optional[Sequence[_builtins.str]] = None,
                 src_fqdns: Optional[Sequence[_builtins.str]] = None,
                 src_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 src_region_codes: Optional[Sequence[_builtins.str]] = None,
                 src_secure_tags: Optional[Sequence['outputs.NetworkFirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag']] = None,
                 src_threat_intelligences: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] dest_address_groups: Address groups which should be matched against the traffic destination.
               Maximum number of destination address groups is 10.
        :param Sequence[_builtins.str] dest_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against
               traffic destination. Maximum number of destination fqdn allowed is 100.
        :param Sequence[_builtins.str] dest_ip_ranges: Destination IP address range in CIDR format. Required for
               EGRESS rules.
        :param Sequence[_builtins.str] dest_region_codes: Region codes whose IP addresses will be used to match for destination
               of traffic. Should be specified as 2 letter country code defined as per
               ISO 3166 alpha-2 country codes. ex."US"
               Maximum number of destination region codes allowed is 5000.
        :param Sequence[_builtins.str] dest_threat_intelligences: Names of Network Threat Intelligence lists.
               The IPs in these lists will be matched against traffic destination.
        :param Sequence['NetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4ConfigArgs'] layer4_configs: Pairs of IP protocols and ports that the rule should match.
               Structure is documented below.
        :param Sequence[_builtins.str] src_address_groups: Address groups which should be matched against the traffic source.
               Maximum number of source address groups is 10.
        :param Sequence[_builtins.str] src_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against
               traffic source. Maximum number of source fqdn allowed is 100.
        :param Sequence[_builtins.str] src_ip_ranges: Source IP address range in CIDR format. Required for
               INGRESS rules.
        :param Sequence[_builtins.str] src_region_codes: Region codes whose IP addresses will be used to match for source
               of traffic. Should be specified as 2 letter country code defined as per
               ISO 3166 alpha-2 country codes. ex."US"
               Maximum number of source region codes allowed is 5000.
        :param Sequence['NetworkFirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTagArgs'] src_secure_tags: List of secure tag values, which should be matched at the source
               of the traffic.
               For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
               and there is no <code>srcIpRange</code>, this rule will be ignored.
               Maximum number of source tag values allowed is 256.
               Structure is documented below.
               
               
               <a name="nested_rule_rule_match_layer4_config"></a>The `layer4_config` block supports:
        :param Sequence[_builtins.str] src_threat_intelligences: Names of Network Threat Intelligence lists.
               The IPs in these lists will be matched against traffic source.
        """
        if dest_address_groups is not None:
            pulumi.set(__self__, "dest_address_groups", dest_address_groups)
        if dest_fqdns is not None:
            pulumi.set(__self__, "dest_fqdns", dest_fqdns)
        if dest_ip_ranges is not None:
            pulumi.set(__self__, "dest_ip_ranges", dest_ip_ranges)
        if dest_region_codes is not None:
            pulumi.set(__self__, "dest_region_codes", dest_region_codes)
        if dest_threat_intelligences is not None:
            pulumi.set(__self__, "dest_threat_intelligences", dest_threat_intelligences)
        if layer4_configs is not None:
            pulumi.set(__self__, "layer4_configs", layer4_configs)
        if src_address_groups is not None:
            pulumi.set(__self__, "src_address_groups", src_address_groups)
        if src_fqdns is not None:
            pulumi.set(__self__, "src_fqdns", src_fqdns)
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)
        if src_region_codes is not None:
            pulumi.set(__self__, "src_region_codes", src_region_codes)
        if src_secure_tags is not None:
            pulumi.set(__self__, "src_secure_tags", src_secure_tags)
        if src_threat_intelligences is not None:
            pulumi.set(__self__, "src_threat_intelligences", src_threat_intelligences)

    @_builtins.property
    @pulumi.getter(name="destAddressGroups")
    def dest_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic destination.
        Maximum number of destination address groups is 10.
        """
        return pulumi.get(self, "dest_address_groups")

    @_builtins.property
    @pulumi.getter(name="destFqdns")
    def dest_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against
        traffic destination. Maximum number of destination fqdn allowed is 100.
        """
        return pulumi.get(self, "dest_fqdns")

    @_builtins.property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Destination IP address range in CIDR format. Required for
        EGRESS rules.
        """
        return pulumi.get(self, "dest_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="destRegionCodes")
    def dest_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for destination
        of traffic. Should be specified as 2 letter country code defined as per
        ISO 3166 alpha-2 country codes. ex."US"
        Maximum number of destination region codes allowed is 5000.
        """
        return pulumi.get(self, "dest_region_codes")

    @_builtins.property
    @pulumi.getter(name="destThreatIntelligences")
    def dest_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists.
        The IPs in these lists will be matched against traffic destination.
        """
        return pulumi.get(self, "dest_threat_intelligences")

    @_builtins.property
    @pulumi.getter(name="layer4Configs")
    def layer4_configs(self) -> Optional[Sequence['outputs.NetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config']]:
        """
        Pairs of IP protocols and ports that the rule should match.
        Structure is documented below.
        """
        return pulumi.get(self, "layer4_configs")

    @_builtins.property
    @pulumi.getter(name="srcAddressGroups")
    def src_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic source.
        Maximum number of source address groups is 10.
        """
        return pulumi.get(self, "src_address_groups")

    @_builtins.property
    @pulumi.getter(name="srcFqdns")
    def src_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against
        traffic source. Maximum number of source fqdn allowed is 100.
        """
        return pulumi.get(self, "src_fqdns")

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Source IP address range in CIDR format. Required for
        INGRESS rules.
        """
        return pulumi.get(self, "src_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="srcRegionCodes")
    def src_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for source
        of traffic. Should be specified as 2 letter country code defined as per
        ISO 3166 alpha-2 country codes. ex."US"
        Maximum number of source region codes allowed is 5000.
        """
        return pulumi.get(self, "src_region_codes")

    @_builtins.property
    @pulumi.getter(name="srcSecureTags")
    def src_secure_tags(self) -> Optional[Sequence['outputs.NetworkFirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag']]:
        """
        List of secure tag values, which should be matched at the source
        of the traffic.
        For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
        and there is no <code>srcIpRange</code>, this rule will be ignored.
        Maximum number of source tag values allowed is 256.
        Structure is documented below.


        <a name="nested_rule_rule_match_layer4_config"></a>The `layer4_config` block supports:
        """
        return pulumi.get(self, "src_secure_tags")

    @_builtins.property
    @pulumi.getter(name="srcThreatIntelligences")
    def src_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists.
        The IPs in these lists will be matched against traffic source.
        """
        return pulumi.get(self, "src_threat_intelligences")


@pulumi.output_type
class NetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: Optional[_builtins.str] = None,
                 ports: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str ip_protocol: (Output)
               The IP protocol to which this rule applies. The protocol
               type is required when creating a firewall rule.
               This value can either be one of the following well
               known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
               or the IP protocol number.
        :param Sequence[_builtins.str] ports: (Output)
               An optional list of ports to which this rule applies. This field
               is only applicable for UDP or TCP protocol. Each entry must be
               either an integer or a range. If not specified, this rule
               applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and
               ["12345-12349"].
        """
        if ip_protocol is not None:
            pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> Optional[_builtins.str]:
        """
        (Output)
        The IP protocol to which this rule applies. The protocol
        type is required when creating a firewall rule.
        This value can either be one of the following well
        known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
        or the IP protocol number.
        """
        return pulumi.get(self, "ip_protocol")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and
        ["12345-12349"].
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class NetworkFirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
               @pattern tagValues/[0-9]+
        :param _builtins.str state: (Output)
               [Output Only] State of the secure tag, either `EFFECTIVE` or
               `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
               or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        @pattern tagValues/[0-9]+
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        [Output Only] State of the secure tag, either `EFFECTIVE` or
        `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
        or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
               @pattern tagValues/[0-9]+
        :param _builtins.str state: (Output)
               [Output Only] State of the secure tag, either `EFFECTIVE` or
               `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
               or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        @pattern tagValues/[0-9]+
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        [Output Only] State of the secure tag, either `EFFECTIVE` or
        `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
        or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkFirewallPolicyWithRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableLogging":
            suggest = "enable_logging"
        elif key == "ruleName":
            suggest = "rule_name"
        elif key == "securityProfileGroup":
            suggest = "security_profile_group"
        elif key == "targetSecureTags":
            suggest = "target_secure_tags"
        elif key == "targetServiceAccounts":
            suggest = "target_service_accounts"
        elif key == "tlsInspect":
            suggest = "tls_inspect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyWithRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyWithRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyWithRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 match: 'outputs.NetworkFirewallPolicyWithRulesRuleMatch',
                 priority: _builtins.int,
                 description: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 enable_logging: Optional[_builtins.bool] = None,
                 rule_name: Optional[_builtins.str] = None,
                 security_profile_group: Optional[_builtins.str] = None,
                 target_secure_tags: Optional[Sequence['outputs.NetworkFirewallPolicyWithRulesRuleTargetSecureTag']] = None,
                 target_service_accounts: Optional[Sequence[_builtins.str]] = None,
                 tls_inspect: Optional[_builtins.bool] = None):
        """
        :param _builtins.str action: The Action to perform when the client connection triggers the rule. Can currently be either
               "allow", "deny", "apply_security_profile_group" or "goto_next".
        :param 'NetworkFirewallPolicyWithRulesRuleMatchArgs' match: A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
               Structure is documented below.
        :param _builtins.int priority: An integer indicating the priority of a rule in the list. The priority must be a value
               between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
               highest priority and 2147483647 is the lowest priority.
        :param _builtins.str description: A description of the rule.
        :param _builtins.str direction: The direction in which this rule applies. If unspecified an INGRESS rule is created.
               Possible values are: `INGRESS`, `EGRESS`.
        :param _builtins.bool disabled: Denotes whether the firewall policy rule is disabled. When set to true,
               the firewall policy rule is not enforced and traffic behaves as if it did
               not exist. If this is unspecified, the firewall policy rule will be
               enabled.
        :param _builtins.bool enable_logging: Denotes whether to enable logging for a particular rule.
               If logging is enabled, logs will be exported to the
               configured export destination in Stackdriver.
        :param _builtins.str rule_name: An optional name for the rule. This field is not a unique identifier
               and can be updated.
        :param _builtins.str security_profile_group: A fully-qualified URL of a SecurityProfile resource instance.
               Example:
               https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
               Must be specified if action is 'apply_security_profile_group'.
        :param Sequence['NetworkFirewallPolicyWithRulesRuleTargetSecureTagArgs'] target_secure_tags: A list of secure tags that controls which instances the firewall rule
               applies to. If <code>targetSecureTag</code> are specified, then the
               firewall rule applies only to instances in the VPC network that have one
               of those EFFECTIVE secure tags, if all the target_secure_tag are in
               INEFFECTIVE state, then this rule will be ignored.
               <code>targetSecureTag</code> may not be set at the same time as
               <code>targetServiceAccounts</code>.
               If neither <code>targetServiceAccounts</code> nor
               <code>targetSecureTag</code> are specified, the firewall rule applies
               to all instances on the specified network.
               Maximum number of target label tags allowed is 256.
               Structure is documented below.
        :param Sequence[_builtins.str] target_service_accounts: A list of service accounts indicating the sets of
               instances that are applied with this rule.
        :param _builtins.bool tls_inspect: Boolean flag indicating if the traffic should be TLS decrypted.
               It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "priority", priority)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)
        if security_profile_group is not None:
            pulumi.set(__self__, "security_profile_group", security_profile_group)
        if target_secure_tags is not None:
            pulumi.set(__self__, "target_secure_tags", target_secure_tags)
        if target_service_accounts is not None:
            pulumi.set(__self__, "target_service_accounts", target_service_accounts)
        if tls_inspect is not None:
            pulumi.set(__self__, "tls_inspect", tls_inspect)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The Action to perform when the client connection triggers the rule. Can currently be either
        "allow", "deny", "apply_security_profile_group" or "goto_next".
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def match(self) -> 'outputs.NetworkFirewallPolicyWithRulesRuleMatch':
        """
        A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
        Structure is documented below.
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        An integer indicating the priority of a rule in the list. The priority must be a value
        between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
        highest priority and 2147483647 is the lowest priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of the rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The direction in which this rule applies. If unspecified an INGRESS rule is created.
        Possible values are: `INGRESS`, `EGRESS`.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Denotes whether the firewall policy rule is disabled. When set to true,
        the firewall policy rule is not enforced and traffic behaves as if it did
        not exist. If this is unspecified, the firewall policy rule will be
        enabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[_builtins.bool]:
        """
        Denotes whether to enable logging for a particular rule.
        If logging is enabled, logs will be exported to the
        configured export destination in Stackdriver.
        """
        return pulumi.get(self, "enable_logging")

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[_builtins.str]:
        """
        An optional name for the rule. This field is not a unique identifier
        and can be updated.
        """
        return pulumi.get(self, "rule_name")

    @_builtins.property
    @pulumi.getter(name="securityProfileGroup")
    def security_profile_group(self) -> Optional[_builtins.str]:
        """
        A fully-qualified URL of a SecurityProfile resource instance.
        Example:
        https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
        Must be specified if action is 'apply_security_profile_group'.
        """
        return pulumi.get(self, "security_profile_group")

    @_builtins.property
    @pulumi.getter(name="targetSecureTags")
    def target_secure_tags(self) -> Optional[Sequence['outputs.NetworkFirewallPolicyWithRulesRuleTargetSecureTag']]:
        """
        A list of secure tags that controls which instances the firewall rule
        applies to. If <code>targetSecureTag</code> are specified, then the
        firewall rule applies only to instances in the VPC network that have one
        of those EFFECTIVE secure tags, if all the target_secure_tag are in
        INEFFECTIVE state, then this rule will be ignored.
        <code>targetSecureTag</code> may not be set at the same time as
        <code>targetServiceAccounts</code>.
        If neither <code>targetServiceAccounts</code> nor
        <code>targetSecureTag</code> are specified, the firewall rule applies
        to all instances on the specified network.
        Maximum number of target label tags allowed is 256.
        Structure is documented below.
        """
        return pulumi.get(self, "target_secure_tags")

    @_builtins.property
    @pulumi.getter(name="targetServiceAccounts")
    def target_service_accounts(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of service accounts indicating the sets of
        instances that are applied with this rule.
        """
        return pulumi.get(self, "target_service_accounts")

    @_builtins.property
    @pulumi.getter(name="tlsInspect")
    def tls_inspect(self) -> Optional[_builtins.bool]:
        """
        Boolean flag indicating if the traffic should be TLS decrypted.
        It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
        """
        return pulumi.get(self, "tls_inspect")


@pulumi.output_type
class NetworkFirewallPolicyWithRulesRuleMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layer4Configs":
            suggest = "layer4_configs"
        elif key == "destAddressGroups":
            suggest = "dest_address_groups"
        elif key == "destFqdns":
            suggest = "dest_fqdns"
        elif key == "destIpRanges":
            suggest = "dest_ip_ranges"
        elif key == "destNetworkScope":
            suggest = "dest_network_scope"
        elif key == "destRegionCodes":
            suggest = "dest_region_codes"
        elif key == "destThreatIntelligences":
            suggest = "dest_threat_intelligences"
        elif key == "srcAddressGroups":
            suggest = "src_address_groups"
        elif key == "srcFqdns":
            suggest = "src_fqdns"
        elif key == "srcIpRanges":
            suggest = "src_ip_ranges"
        elif key == "srcNetworkScope":
            suggest = "src_network_scope"
        elif key == "srcNetworks":
            suggest = "src_networks"
        elif key == "srcRegionCodes":
            suggest = "src_region_codes"
        elif key == "srcSecureTags":
            suggest = "src_secure_tags"
        elif key == "srcThreatIntelligences":
            suggest = "src_threat_intelligences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyWithRulesRuleMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyWithRulesRuleMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyWithRulesRuleMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layer4_configs: Sequence['outputs.NetworkFirewallPolicyWithRulesRuleMatchLayer4Config'],
                 dest_address_groups: Optional[Sequence[_builtins.str]] = None,
                 dest_fqdns: Optional[Sequence[_builtins.str]] = None,
                 dest_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 dest_network_scope: Optional[_builtins.str] = None,
                 dest_region_codes: Optional[Sequence[_builtins.str]] = None,
                 dest_threat_intelligences: Optional[Sequence[_builtins.str]] = None,
                 src_address_groups: Optional[Sequence[_builtins.str]] = None,
                 src_fqdns: Optional[Sequence[_builtins.str]] = None,
                 src_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 src_network_scope: Optional[_builtins.str] = None,
                 src_networks: Optional[Sequence[_builtins.str]] = None,
                 src_region_codes: Optional[Sequence[_builtins.str]] = None,
                 src_secure_tags: Optional[Sequence['outputs.NetworkFirewallPolicyWithRulesRuleMatchSrcSecureTag']] = None,
                 src_threat_intelligences: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['NetworkFirewallPolicyWithRulesRuleMatchLayer4ConfigArgs'] layer4_configs: Pairs of IP protocols and ports that the rule should match.
               Structure is documented below.
        :param Sequence[_builtins.str] dest_address_groups: Address groups which should be matched against the traffic destination.
               Maximum number of destination address groups is 10.
        :param Sequence[_builtins.str] dest_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against
               traffic destination. Maximum number of destination fqdn allowed is 100.
        :param Sequence[_builtins.str] dest_ip_ranges: Destination IP address range in CIDR format. Required for
               EGRESS rules.
        :param _builtins.str dest_network_scope: Network scope of the traffic destination.
               Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        :param Sequence[_builtins.str] dest_region_codes: Region codes whose IP addresses will be used to match for destination
               of traffic. Should be specified as 2 letter country code defined as per
               ISO 3166 alpha-2 country codes. ex."US"
               Maximum number of destination region codes allowed is 5000.
        :param Sequence[_builtins.str] dest_threat_intelligences: Names of Network Threat Intelligence lists.
               The IPs in these lists will be matched against traffic destination.
        :param Sequence[_builtins.str] src_address_groups: Address groups which should be matched against the traffic source.
               Maximum number of source address groups is 10.
        :param Sequence[_builtins.str] src_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against
               traffic source. Maximum number of source fqdn allowed is 100.
        :param Sequence[_builtins.str] src_ip_ranges: Source IP address range in CIDR format. Required for
               INGRESS rules.
        :param _builtins.str src_network_scope: Network scope of the traffic source.
               Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        :param Sequence[_builtins.str] src_networks: Networks of the traffic source. It can be either a full or partial url.
        :param Sequence[_builtins.str] src_region_codes: Region codes whose IP addresses will be used to match for source
               of traffic. Should be specified as 2 letter country code defined as per
               ISO 3166 alpha-2 country codes. ex."US"
               Maximum number of source region codes allowed is 5000.
        :param Sequence['NetworkFirewallPolicyWithRulesRuleMatchSrcSecureTagArgs'] src_secure_tags: List of secure tag values, which should be matched at the source
               of the traffic.
               For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
               and there is no <code>srcIpRange</code>, this rule will be ignored.
               Maximum number of source tag values allowed is 256.
               Structure is documented below.
               
               
               <a name="nested_rule_rule_match_layer4_config"></a>The `layer4_config` block supports:
        :param Sequence[_builtins.str] src_threat_intelligences: Names of Network Threat Intelligence lists.
               The IPs in these lists will be matched against traffic source.
        """
        pulumi.set(__self__, "layer4_configs", layer4_configs)
        if dest_address_groups is not None:
            pulumi.set(__self__, "dest_address_groups", dest_address_groups)
        if dest_fqdns is not None:
            pulumi.set(__self__, "dest_fqdns", dest_fqdns)
        if dest_ip_ranges is not None:
            pulumi.set(__self__, "dest_ip_ranges", dest_ip_ranges)
        if dest_network_scope is not None:
            pulumi.set(__self__, "dest_network_scope", dest_network_scope)
        if dest_region_codes is not None:
            pulumi.set(__self__, "dest_region_codes", dest_region_codes)
        if dest_threat_intelligences is not None:
            pulumi.set(__self__, "dest_threat_intelligences", dest_threat_intelligences)
        if src_address_groups is not None:
            pulumi.set(__self__, "src_address_groups", src_address_groups)
        if src_fqdns is not None:
            pulumi.set(__self__, "src_fqdns", src_fqdns)
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)
        if src_network_scope is not None:
            pulumi.set(__self__, "src_network_scope", src_network_scope)
        if src_networks is not None:
            pulumi.set(__self__, "src_networks", src_networks)
        if src_region_codes is not None:
            pulumi.set(__self__, "src_region_codes", src_region_codes)
        if src_secure_tags is not None:
            pulumi.set(__self__, "src_secure_tags", src_secure_tags)
        if src_threat_intelligences is not None:
            pulumi.set(__self__, "src_threat_intelligences", src_threat_intelligences)

    @_builtins.property
    @pulumi.getter(name="layer4Configs")
    def layer4_configs(self) -> Sequence['outputs.NetworkFirewallPolicyWithRulesRuleMatchLayer4Config']:
        """
        Pairs of IP protocols and ports that the rule should match.
        Structure is documented below.
        """
        return pulumi.get(self, "layer4_configs")

    @_builtins.property
    @pulumi.getter(name="destAddressGroups")
    def dest_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic destination.
        Maximum number of destination address groups is 10.
        """
        return pulumi.get(self, "dest_address_groups")

    @_builtins.property
    @pulumi.getter(name="destFqdns")
    def dest_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against
        traffic destination. Maximum number of destination fqdn allowed is 100.
        """
        return pulumi.get(self, "dest_fqdns")

    @_builtins.property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Destination IP address range in CIDR format. Required for
        EGRESS rules.
        """
        return pulumi.get(self, "dest_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="destNetworkScope")
    def dest_network_scope(self) -> Optional[_builtins.str]:
        """
        Network scope of the traffic destination.
        Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        """
        return pulumi.get(self, "dest_network_scope")

    @_builtins.property
    @pulumi.getter(name="destRegionCodes")
    def dest_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for destination
        of traffic. Should be specified as 2 letter country code defined as per
        ISO 3166 alpha-2 country codes. ex."US"
        Maximum number of destination region codes allowed is 5000.
        """
        return pulumi.get(self, "dest_region_codes")

    @_builtins.property
    @pulumi.getter(name="destThreatIntelligences")
    def dest_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists.
        The IPs in these lists will be matched against traffic destination.
        """
        return pulumi.get(self, "dest_threat_intelligences")

    @_builtins.property
    @pulumi.getter(name="srcAddressGroups")
    def src_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic source.
        Maximum number of source address groups is 10.
        """
        return pulumi.get(self, "src_address_groups")

    @_builtins.property
    @pulumi.getter(name="srcFqdns")
    def src_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against
        traffic source. Maximum number of source fqdn allowed is 100.
        """
        return pulumi.get(self, "src_fqdns")

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Source IP address range in CIDR format. Required for
        INGRESS rules.
        """
        return pulumi.get(self, "src_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="srcNetworkScope")
    def src_network_scope(self) -> Optional[_builtins.str]:
        """
        Network scope of the traffic source.
        Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        """
        return pulumi.get(self, "src_network_scope")

    @_builtins.property
    @pulumi.getter(name="srcNetworks")
    def src_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Networks of the traffic source. It can be either a full or partial url.
        """
        return pulumi.get(self, "src_networks")

    @_builtins.property
    @pulumi.getter(name="srcRegionCodes")
    def src_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for source
        of traffic. Should be specified as 2 letter country code defined as per
        ISO 3166 alpha-2 country codes. ex."US"
        Maximum number of source region codes allowed is 5000.
        """
        return pulumi.get(self, "src_region_codes")

    @_builtins.property
    @pulumi.getter(name="srcSecureTags")
    def src_secure_tags(self) -> Optional[Sequence['outputs.NetworkFirewallPolicyWithRulesRuleMatchSrcSecureTag']]:
        """
        List of secure tag values, which should be matched at the source
        of the traffic.
        For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
        and there is no <code>srcIpRange</code>, this rule will be ignored.
        Maximum number of source tag values allowed is 256.
        Structure is documented below.


        <a name="nested_rule_rule_match_layer4_config"></a>The `layer4_config` block supports:
        """
        return pulumi.get(self, "src_secure_tags")

    @_builtins.property
    @pulumi.getter(name="srcThreatIntelligences")
    def src_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists.
        The IPs in these lists will be matched against traffic source.
        """
        return pulumi.get(self, "src_threat_intelligences")


@pulumi.output_type
class NetworkFirewallPolicyWithRulesRuleMatchLayer4Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallPolicyWithRulesRuleMatchLayer4Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallPolicyWithRulesRuleMatchLayer4Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallPolicyWithRulesRuleMatchLayer4Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: _builtins.str,
                 ports: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str ip_protocol: (Output)
               The IP protocol to which this rule applies. The protocol
               type is required when creating a firewall rule.
               This value can either be one of the following well
               known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
               or the IP protocol number.
        :param Sequence[_builtins.str] ports: (Output)
               An optional list of ports to which this rule applies. This field
               is only applicable for UDP or TCP protocol. Each entry must be
               either an integer or a range. If not specified, this rule
               applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and
               ["12345-12349"].
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> _builtins.str:
        """
        (Output)
        The IP protocol to which this rule applies. The protocol
        type is required when creating a firewall rule.
        This value can either be one of the following well
        known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
        or the IP protocol number.
        """
        return pulumi.get(self, "ip_protocol")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and
        ["12345-12349"].
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class NetworkFirewallPolicyWithRulesRuleMatchSrcSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
               @pattern tagValues/[0-9]+
        :param _builtins.str state: (Output)
               [Output Only] State of the secure tag, either `EFFECTIVE` or
               `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
               or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        @pattern tagValues/[0-9]+
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        [Output Only] State of the secure tag, either `EFFECTIVE` or
        `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
        or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkFirewallPolicyWithRulesRuleTargetSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
               @pattern tagValues/[0-9]+
        :param _builtins.str state: (Output)
               [Output Only] State of the secure tag, either `EFFECTIVE` or
               `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
               or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        @pattern tagValues/[0-9]+
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        [Output Only] State of the secure tag, either `EFFECTIVE` or
        `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
        or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the network. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456.
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource manager tags to be bound to the network. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class NodeGroupAutoscalingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxNodes":
            suggest = "max_nodes"
        elif key == "minNodes":
            suggest = "min_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeGroupAutoscalingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeGroupAutoscalingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeGroupAutoscalingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_nodes: Optional[_builtins.int] = None,
                 min_nodes: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.int max_nodes: Maximum size of the node group. Set to a value less than or equal
               to 100 and greater than or equal to min-nodes.
        :param _builtins.int min_nodes: Minimum size of the node group. Must be less
               than or equal to max-nodes. The default value is 0.
        :param _builtins.str mode: The autoscaling mode. Set to one of the following:
               - OFF: Disables the autoscaler.
               - ON: Enables scaling in and scaling out.
               - ONLY_SCALE_OUT: Enables only scaling out.
               You must use this mode if your node groups are configured to
               restart their hosted VMs on minimal servers.
               Possible values are: `OFF`, `ON`, `ONLY_SCALE_OUT`.
        """
        if max_nodes is not None:
            pulumi.set(__self__, "max_nodes", max_nodes)
        if min_nodes is not None:
            pulumi.set(__self__, "min_nodes", min_nodes)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> Optional[_builtins.int]:
        """
        Maximum size of the node group. Set to a value less than or equal
        to 100 and greater than or equal to min-nodes.
        """
        return pulumi.get(self, "max_nodes")

    @_builtins.property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> Optional[_builtins.int]:
        """
        Minimum size of the node group. Must be less
        than or equal to max-nodes. The default value is 0.
        """
        return pulumi.get(self, "min_nodes")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The autoscaling mode. Set to one of the following:
        - OFF: Disables the autoscaler.
        - ON: Enables scaling in and scaling out.
        - ONLY_SCALE_OUT: Enables only scaling out.
        You must use this mode if your node groups are configured to
        restart their hosted VMs on minimal servers.
        Possible values are: `OFF`, `ON`, `ONLY_SCALE_OUT`.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class NodeGroupMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeGroupMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeGroupMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeGroupMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_time: _builtins.str):
        """
        :param _builtins.str start_time: instances.start time of the window. This must be in UTC format that resolves to one of 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example, both 13:00-5 and 08:00 are valid.
        """
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        instances.start time of the window. This must be in UTC format that resolves to one of 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example, both 13:00-5 and 08:00 are valid.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class NodeGroupShareSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shareType":
            suggest = "share_type"
        elif key == "projectMaps":
            suggest = "project_maps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeGroupShareSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeGroupShareSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeGroupShareSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 share_type: _builtins.str,
                 project_maps: Optional[Sequence['outputs.NodeGroupShareSettingsProjectMap']] = None):
        """
        :param _builtins.str share_type: Node group sharing type.
               Possible values are: `ORGANIZATION`, `SPECIFIC_PROJECTS`, `LOCAL`.
        :param Sequence['NodeGroupShareSettingsProjectMapArgs'] project_maps: A map of project id and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.
               Structure is documented below.
        """
        pulumi.set(__self__, "share_type", share_type)
        if project_maps is not None:
            pulumi.set(__self__, "project_maps", project_maps)

    @_builtins.property
    @pulumi.getter(name="shareType")
    def share_type(self) -> _builtins.str:
        """
        Node group sharing type.
        Possible values are: `ORGANIZATION`, `SPECIFIC_PROJECTS`, `LOCAL`.
        """
        return pulumi.get(self, "share_type")

    @_builtins.property
    @pulumi.getter(name="projectMaps")
    def project_maps(self) -> Optional[Sequence['outputs.NodeGroupShareSettingsProjectMap']]:
        """
        A map of project id and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.
        Structure is documented below.
        """
        return pulumi.get(self, "project_maps")


@pulumi.output_type
class NodeGroupShareSettingsProjectMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeGroupShareSettingsProjectMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeGroupShareSettingsProjectMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeGroupShareSettingsProjectMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 project_id: _builtins.str):
        """
        :param _builtins.str id: The identifier for this object. Format specified above.
        :param _builtins.str project_id: The project id/number should be the same as the key of this project config in the project map.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The project id/number should be the same as the key of this project config in the project map.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class NodeTemplateAccelerator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorType":
            suggest = "accelerator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateAccelerator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateAccelerator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateAccelerator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional[_builtins.int] = None,
                 accelerator_type: Optional[_builtins.str] = None):
        """
        :param _builtins.int accelerator_count: The number of the guest accelerator cards exposed to this
               node template.
        :param _builtins.str accelerator_type: Full or partial URL of the accelerator type resource to expose
               to this node template.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_type is not None:
            pulumi.set(__self__, "accelerator_type", accelerator_type)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional[_builtins.int]:
        """
        The number of the guest accelerator cards exposed to this
        node template.
        """
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> Optional[_builtins.str]:
        """
        Full or partial URL of the accelerator type resource to expose
        to this node template.
        """
        return pulumi.get(self, "accelerator_type")


@pulumi.output_type
class NodeTemplateDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskCount":
            suggest = "disk_count"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "diskType":
            suggest = "disk_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_count: Optional[_builtins.int] = None,
                 disk_size_gb: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_count: Specifies the number of such disks.
        :param _builtins.int disk_size_gb: Specifies the size of the disk in base-2 GB.
        :param _builtins.str disk_type: Specifies the desired disk type on the node. This disk type must be a local storage type (e.g.: local-ssd). Note that for nodeTemplates, this should be the name of the disk type and not its URL.
        """
        if disk_count is not None:
            pulumi.set(__self__, "disk_count", disk_count)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @_builtins.property
    @pulumi.getter(name="diskCount")
    def disk_count(self) -> Optional[_builtins.int]:
        """
        Specifies the number of such disks.
        """
        return pulumi.get(self, "disk_count")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[_builtins.int]:
        """
        Specifies the size of the disk in base-2 GB.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        Specifies the desired disk type on the node. This disk type must be a local storage type (e.g.: local-ssd). Note that for nodeTemplates, this should be the name of the disk type and not its URL.
        """
        return pulumi.get(self, "disk_type")


@pulumi.output_type
class NodeTemplateNodeTypeFlexibility(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localSsd":
            suggest = "local_ssd"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateNodeTypeFlexibility. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateNodeTypeFlexibility.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateNodeTypeFlexibility.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpus: Optional[_builtins.str] = None,
                 local_ssd: Optional[_builtins.str] = None,
                 memory: Optional[_builtins.str] = None):
        """
        :param _builtins.str cpus: Number of virtual CPUs to use.
        :param _builtins.str local_ssd: (Output)
               Use local SSD
        :param _builtins.str memory: Physical memory available to the node, defined in MB.
        """
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if local_ssd is not None:
            pulumi.set(__self__, "local_ssd", local_ssd)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter
    def cpus(self) -> Optional[_builtins.str]:
        """
        Number of virtual CPUs to use.
        """
        return pulumi.get(self, "cpus")

    @_builtins.property
    @pulumi.getter(name="localSsd")
    def local_ssd(self) -> Optional[_builtins.str]:
        """
        (Output)
        Use local SSD
        """
        return pulumi.get(self, "local_ssd")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[_builtins.str]:
        """
        Physical memory available to the node, defined in MB.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class NodeTemplateServerBinding(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Type of server binding policy. If `RESTART_NODE_ON_ANY_SERVER`,
               nodes using this template will restart on any physical server
               following a maintenance event.
               If `RESTART_NODE_ON_MINIMAL_SERVER`, nodes using this template
               will restart on the same physical server following a maintenance
               event, instead of being live migrated to or restarted on a new
               physical server. This option may be useful if you are using
               software licenses tied to the underlying server characteristics
               such as physical sockets or cores, to avoid the need for
               additional licenses when maintenance occurs. However, VMs on such
               nodes will experience outages while maintenance is applied.
               Possible values are: `RESTART_NODE_ON_ANY_SERVER`, `RESTART_NODE_ON_MINIMAL_SERVERS`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of server binding policy. If `RESTART_NODE_ON_ANY_SERVER`,
        nodes using this template will restart on any physical server
        following a maintenance event.
        If `RESTART_NODE_ON_MINIMAL_SERVER`, nodes using this template
        will restart on the same physical server following a maintenance
        event, instead of being live migrated to or restarted on a new
        physical server. This option may be useful if you are using
        software licenses tied to the underlying server characteristics
        such as physical sockets or cores, to avoid the need for
        additional licenses when maintenance occurs. However, VMs on such
        nodes will experience outages while maintenance is applied.
        Possible values are: `RESTART_NODE_ON_ANY_SERVER`, `RESTART_NODE_ON_MINIMAL_SERVERS`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OrganizationSecurityPolicyRuleMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "versionedExpr":
            suggest = "versioned_expr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationSecurityPolicyRuleMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationSecurityPolicyRuleMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationSecurityPolicyRuleMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config: 'outputs.OrganizationSecurityPolicyRuleMatchConfig',
                 description: Optional[_builtins.str] = None,
                 versioned_expr: Optional[_builtins.str] = None):
        """
        :param 'OrganizationSecurityPolicyRuleMatchConfigArgs' config: The configuration options for matching the rule.
               Structure is documented below.
        :param _builtins.str description: A description of the rule.
        :param _builtins.str versioned_expr: Preconfigured versioned expression. For organization security policy rules,
               the only supported type is "FIREWALL".
               Default value is `FIREWALL`.
               Possible values are: `FIREWALL`.
        """
        pulumi.set(__self__, "config", config)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if versioned_expr is not None:
            pulumi.set(__self__, "versioned_expr", versioned_expr)

    @_builtins.property
    @pulumi.getter
    def config(self) -> 'outputs.OrganizationSecurityPolicyRuleMatchConfig':
        """
        The configuration options for matching the rule.
        Structure is documented below.
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of the rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="versionedExpr")
    def versioned_expr(self) -> Optional[_builtins.str]:
        """
        Preconfigured versioned expression. For organization security policy rules,
        the only supported type is "FIREWALL".
        Default value is `FIREWALL`.
        Possible values are: `FIREWALL`.
        """
        return pulumi.get(self, "versioned_expr")


@pulumi.output_type
class OrganizationSecurityPolicyRuleMatchConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layer4Configs":
            suggest = "layer4_configs"
        elif key == "destIpRanges":
            suggest = "dest_ip_ranges"
        elif key == "srcIpRanges":
            suggest = "src_ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationSecurityPolicyRuleMatchConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationSecurityPolicyRuleMatchConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationSecurityPolicyRuleMatchConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layer4_configs: Sequence['outputs.OrganizationSecurityPolicyRuleMatchConfigLayer4Config'],
                 dest_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 src_ip_ranges: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['OrganizationSecurityPolicyRuleMatchConfigLayer4ConfigArgs'] layer4_configs: Pairs of IP protocols and ports that the rule should match.
               Structure is documented below.
               
               
               <a name="nested_match_config_layer4_config"></a>The `layer4_config` block supports:
        :param Sequence[_builtins.str] dest_ip_ranges: Destination IP address range in CIDR format. Required for
               EGRESS rules.
        :param Sequence[_builtins.str] src_ip_ranges: Source IP address range in CIDR format. Required for
               INGRESS rules.
        """
        pulumi.set(__self__, "layer4_configs", layer4_configs)
        if dest_ip_ranges is not None:
            pulumi.set(__self__, "dest_ip_ranges", dest_ip_ranges)
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)

    @_builtins.property
    @pulumi.getter(name="layer4Configs")
    def layer4_configs(self) -> Sequence['outputs.OrganizationSecurityPolicyRuleMatchConfigLayer4Config']:
        """
        Pairs of IP protocols and ports that the rule should match.
        Structure is documented below.


        <a name="nested_match_config_layer4_config"></a>The `layer4_config` block supports:
        """
        return pulumi.get(self, "layer4_configs")

    @_builtins.property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Destination IP address range in CIDR format. Required for
        EGRESS rules.
        """
        return pulumi.get(self, "dest_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Source IP address range in CIDR format. Required for
        INGRESS rules.
        """
        return pulumi.get(self, "src_ip_ranges")


@pulumi.output_type
class OrganizationSecurityPolicyRuleMatchConfigLayer4Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationSecurityPolicyRuleMatchConfigLayer4Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationSecurityPolicyRuleMatchConfigLayer4Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationSecurityPolicyRuleMatchConfigLayer4Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: _builtins.str,
                 ports: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str ip_protocol: The IP protocol to which this rule applies. The protocol
               type is required when creating a firewall rule.
               This value can either be one of the following well
               known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
               or the IP protocol number.
        :param Sequence[_builtins.str] ports: An optional list of ports to which this rule applies. This field
               is only applicable for UDP or TCP protocol. Each entry must be
               either an integer or a range. If not specified, this rule
               applies to connections through any port.
               
               Example inputs include: ["22"], ["80","443"], and
               ["12345-12349"].
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> _builtins.str:
        """
        The IP protocol to which this rule applies. The protocol
        type is required when creating a firewall rule.
        This value can either be one of the following well
        known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
        or the IP protocol number.
        """
        return pulumi.get(self, "ip_protocol")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.

        Example inputs include: ["22"], ["80","443"], and
        ["12345-12349"].
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class PacketMirroringCollectorIlb(dict):
    def __init__(__self__, *,
                 url: _builtins.str):
        """
        :param _builtins.str url: The URL of the forwarding rule.
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the forwarding rule.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PacketMirroringFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrRanges":
            suggest = "cidr_ranges"
        elif key == "ipProtocols":
            suggest = "ip_protocols"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PacketMirroringFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PacketMirroringFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PacketMirroringFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_ranges: Optional[Sequence[_builtins.str]] = None,
                 direction: Optional[_builtins.str] = None,
                 ip_protocols: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] cidr_ranges: IP CIDR ranges that apply as a filter on the source (ingress) or
               destination (egress) IP in the IP header. Only IPv4 is supported.
        :param _builtins.str direction: Direction of traffic to mirror.
               Default value is `BOTH`.
               Possible values are: `INGRESS`, `EGRESS`, `BOTH`.
        :param Sequence[_builtins.str] ip_protocols: Possible IP protocols including tcp, udp, icmp and esp
        """
        if cidr_ranges is not None:
            pulumi.set(__self__, "cidr_ranges", cidr_ranges)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if ip_protocols is not None:
            pulumi.set(__self__, "ip_protocols", ip_protocols)

    @_builtins.property
    @pulumi.getter(name="cidrRanges")
    def cidr_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        IP CIDR ranges that apply as a filter on the source (ingress) or
        destination (egress) IP in the IP header. Only IPv4 is supported.
        """
        return pulumi.get(self, "cidr_ranges")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Direction of traffic to mirror.
        Default value is `BOTH`.
        Possible values are: `INGRESS`, `EGRESS`, `BOTH`.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="ipProtocols")
    def ip_protocols(self) -> Optional[Sequence[_builtins.str]]:
        """
        Possible IP protocols including tcp, udp, icmp and esp
        """
        return pulumi.get(self, "ip_protocols")


@pulumi.output_type
class PacketMirroringMirroredResources(dict):
    def __init__(__self__, *,
                 instances: Optional[Sequence['outputs.PacketMirroringMirroredResourcesInstance']] = None,
                 subnetworks: Optional[Sequence['outputs.PacketMirroringMirroredResourcesSubnetwork']] = None,
                 tags: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['PacketMirroringMirroredResourcesInstanceArgs'] instances: All the listed instances will be mirrored.  Specify at most 50.
               Structure is documented below.
        :param Sequence['PacketMirroringMirroredResourcesSubnetworkArgs'] subnetworks: All instances in one of these subnetworks will be mirrored.
               Structure is documented below.
        :param Sequence[_builtins.str] tags: All instances with these tags will be mirrored.
        """
        if instances is not None:
            pulumi.set(__self__, "instances", instances)
        if subnetworks is not None:
            pulumi.set(__self__, "subnetworks", subnetworks)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def instances(self) -> Optional[Sequence['outputs.PacketMirroringMirroredResourcesInstance']]:
        """
        All the listed instances will be mirrored.  Specify at most 50.
        Structure is documented below.
        """
        return pulumi.get(self, "instances")

    @_builtins.property
    @pulumi.getter
    def subnetworks(self) -> Optional[Sequence['outputs.PacketMirroringMirroredResourcesSubnetwork']]:
        """
        All instances in one of these subnetworks will be mirrored.
        Structure is documented below.
        """
        return pulumi.get(self, "subnetworks")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        All instances with these tags will be mirrored.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class PacketMirroringMirroredResourcesInstance(dict):
    def __init__(__self__, *,
                 url: _builtins.str):
        """
        :param _builtins.str url: The URL of the instances where this rule should be active.
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the instances where this rule should be active.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PacketMirroringMirroredResourcesSubnetwork(dict):
    def __init__(__self__, *,
                 url: _builtins.str):
        """
        :param _builtins.str url: The URL of the subnetwork where this rule should be active.
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the subnetwork where this rule should be active.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PacketMirroringNetwork(dict):
    def __init__(__self__, *,
                 url: _builtins.str):
        """
        :param _builtins.str url: The full self_link URL of the network where this rule is active.
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The full self_link URL of the network where this rule is active.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PerInstanceConfigPreservedState(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalIps":
            suggest = "external_ips"
        elif key == "internalIps":
            suggest = "internal_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PerInstanceConfigPreservedState. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PerInstanceConfigPreservedState.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PerInstanceConfigPreservedState.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disks: Optional[Sequence['outputs.PerInstanceConfigPreservedStateDisk']] = None,
                 external_ips: Optional[Sequence['outputs.PerInstanceConfigPreservedStateExternalIp']] = None,
                 internal_ips: Optional[Sequence['outputs.PerInstanceConfigPreservedStateInternalIp']] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Sequence['PerInstanceConfigPreservedStateDiskArgs'] disks: Stateful disks for the instance.
               Structure is documented below.
        :param Sequence['PerInstanceConfigPreservedStateExternalIpArgs'] external_ips: Preserved external IPs defined for this instance. This map is keyed with the name of the network interface.
               Structure is documented below.
        :param Sequence['PerInstanceConfigPreservedStateInternalIpArgs'] internal_ips: Preserved internal IPs defined for this instance. This map is keyed with the name of the network interface.
               Structure is documented below.
        :param Mapping[str, _builtins.str] metadata: Preserved metadata defined for this instance. This is a list of key->value pairs.
        """
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if external_ips is not None:
            pulumi.set(__self__, "external_ips", external_ips)
        if internal_ips is not None:
            pulumi.set(__self__, "internal_ips", internal_ips)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def disks(self) -> Optional[Sequence['outputs.PerInstanceConfigPreservedStateDisk']]:
        """
        Stateful disks for the instance.
        Structure is documented below.
        """
        return pulumi.get(self, "disks")

    @_builtins.property
    @pulumi.getter(name="externalIps")
    def external_ips(self) -> Optional[Sequence['outputs.PerInstanceConfigPreservedStateExternalIp']]:
        """
        Preserved external IPs defined for this instance. This map is keyed with the name of the network interface.
        Structure is documented below.
        """
        return pulumi.get(self, "external_ips")

    @_builtins.property
    @pulumi.getter(name="internalIps")
    def internal_ips(self) -> Optional[Sequence['outputs.PerInstanceConfigPreservedStateInternalIp']]:
        """
        Preserved internal IPs defined for this instance. This map is keyed with the name of the network interface.
        Structure is documented below.
        """
        return pulumi.get(self, "internal_ips")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Preserved metadata defined for this instance. This is a list of key->value pairs.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class PerInstanceConfigPreservedStateDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteRule":
            suggest = "delete_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PerInstanceConfigPreservedStateDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PerInstanceConfigPreservedStateDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PerInstanceConfigPreservedStateDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 source: _builtins.str,
                 delete_rule: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
        :param _builtins.str source: The URI of an existing persistent disk to attach under the specified device-name in the format
               `projects/project-id/zones/zone/disks/disk-name`.
        :param _builtins.str delete_rule: A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
               The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
               `NEVER` - detach the disk when the VM is deleted, but do not delete the disk.
               `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
               deleted from the instance group.
               Default value is `NEVER`.
               Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
        :param _builtins.str mode: The mode of the disk.
               Default value is `READ_WRITE`.
               Possible values are: `READ_ONLY`, `READ_WRITE`.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "source", source)
        if delete_rule is not None:
            pulumi.set(__self__, "delete_rule", delete_rule)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The URI of an existing persistent disk to attach under the specified device-name in the format
        `projects/project-id/zones/zone/disks/disk-name`.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[_builtins.str]:
        """
        A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
        The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
        `NEVER` - detach the disk when the VM is deleted, but do not delete the disk.
        `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
        deleted from the instance group.
        Default value is `NEVER`.
        Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
        """
        return pulumi.get(self, "delete_rule")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The mode of the disk.
        Default value is `READ_WRITE`.
        Possible values are: `READ_ONLY`, `READ_WRITE`.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class PerInstanceConfigPreservedStateExternalIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceName":
            suggest = "interface_name"
        elif key == "autoDelete":
            suggest = "auto_delete"
        elif key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PerInstanceConfigPreservedStateExternalIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PerInstanceConfigPreservedStateExternalIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PerInstanceConfigPreservedStateExternalIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_name: _builtins.str,
                 auto_delete: Optional[_builtins.str] = None,
                 ip_address: Optional['outputs.PerInstanceConfigPreservedStateExternalIpIpAddress'] = None):
        """
        :param _builtins.str interface_name: The identifier for this object. Format specified above.
        :param _builtins.str auto_delete: These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
               Default value is `NEVER`.
               Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
        :param 'PerInstanceConfigPreservedStateExternalIpIpAddressArgs' ip_address: Ip address representation
               Structure is documented below.
        """
        pulumi.set(__self__, "interface_name", interface_name)
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "interface_name")

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[_builtins.str]:
        """
        These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
        Default value is `NEVER`.
        Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional['outputs.PerInstanceConfigPreservedStateExternalIpIpAddress']:
        """
        Ip address representation
        Structure is documented below.
        """
        return pulumi.get(self, "ip_address")


@pulumi.output_type
class PerInstanceConfigPreservedStateExternalIpIpAddress(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: The URL of the reservation for this IP address.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        The URL of the reservation for this IP address.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class PerInstanceConfigPreservedStateInternalIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceName":
            suggest = "interface_name"
        elif key == "autoDelete":
            suggest = "auto_delete"
        elif key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PerInstanceConfigPreservedStateInternalIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PerInstanceConfigPreservedStateInternalIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PerInstanceConfigPreservedStateInternalIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_name: _builtins.str,
                 auto_delete: Optional[_builtins.str] = None,
                 ip_address: Optional['outputs.PerInstanceConfigPreservedStateInternalIpIpAddress'] = None):
        """
        :param _builtins.str interface_name: The identifier for this object. Format specified above.
        :param _builtins.str auto_delete: These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
               Default value is `NEVER`.
               Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
        :param 'PerInstanceConfigPreservedStateInternalIpIpAddressArgs' ip_address: Ip address representation
               Structure is documented below.
        """
        pulumi.set(__self__, "interface_name", interface_name)
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "interface_name")

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[_builtins.str]:
        """
        These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
        Default value is `NEVER`.
        Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional['outputs.PerInstanceConfigPreservedStateInternalIpIpAddress']:
        """
        Ip address representation
        Structure is documented below.
        """
        return pulumi.get(self, "ip_address")


@pulumi.output_type
class PerInstanceConfigPreservedStateInternalIpIpAddress(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: The URL of the reservation for this IP address.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        The URL of the reservation for this IP address.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class PreviewFeatureRolloutOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rolloutInput":
            suggest = "rollout_input"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PreviewFeatureRolloutOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PreviewFeatureRolloutOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PreviewFeatureRolloutOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rollout_input: Optional['outputs.PreviewFeatureRolloutOperationRolloutInput'] = None):
        """
        :param 'PreviewFeatureRolloutOperationRolloutInputArgs' rollout_input: The input for the rollout operation.
               Structure is documented below.
        """
        if rollout_input is not None:
            pulumi.set(__self__, "rollout_input", rollout_input)

    @_builtins.property
    @pulumi.getter(name="rolloutInput")
    def rollout_input(self) -> Optional['outputs.PreviewFeatureRolloutOperationRolloutInput']:
        """
        The input for the rollout operation.
        Structure is documented below.
        """
        return pulumi.get(self, "rollout_input")


@pulumi.output_type
class PreviewFeatureRolloutOperationRolloutInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedRolloutPlan":
            suggest = "predefined_rollout_plan"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PreviewFeatureRolloutOperationRolloutInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PreviewFeatureRolloutOperationRolloutInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PreviewFeatureRolloutOperationRolloutInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_rollout_plan: _builtins.str):
        """
        :param _builtins.str predefined_rollout_plan: Predefined rollout plans.
               Possible values are: `ROLLOUT_PLAN_FAST_ROLLOUT`.
        """
        pulumi.set(__self__, "predefined_rollout_plan", predefined_rollout_plan)

    @_builtins.property
    @pulumi.getter(name="predefinedRolloutPlan")
    def predefined_rollout_plan(self) -> _builtins.str:
        """
        Predefined rollout plans.
        Possible values are: `ROLLOUT_PLAN_FAST_ROLLOUT`.
        """
        return pulumi.get(self, "predefined_rollout_plan")


@pulumi.output_type
class PublicDelegatedPrefixPublicDelegatedSubPrefix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocatablePrefixLength":
            suggest = "allocatable_prefix_length"
        elif key == "delegateeProject":
            suggest = "delegatee_project"
        elif key == "ipCidrRange":
            suggest = "ip_cidr_range"
        elif key == "ipv6AccessType":
            suggest = "ipv6_access_type"
        elif key == "isAddress":
            suggest = "is_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PublicDelegatedPrefixPublicDelegatedSubPrefix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PublicDelegatedPrefixPublicDelegatedSubPrefix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PublicDelegatedPrefixPublicDelegatedSubPrefix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocatable_prefix_length: Optional[_builtins.int] = None,
                 delegatee_project: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 ip_cidr_range: Optional[_builtins.str] = None,
                 ipv6_access_type: Optional[_builtins.str] = None,
                 is_address: Optional[_builtins.bool] = None,
                 mode: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.int allocatable_prefix_length: The allocatable prefix length supported by this public delegated prefix. This field is optional and cannot be set for prefixes in DELEGATION mode. It cannot be set for IPv4 prefixes either, and it always defaults to 32.
        :param _builtins.str delegatee_project: Name of the project scoping this PublicDelegatedSubPrefix.
        :param _builtins.str description: An optional description of this resource.
        :param _builtins.str ip_cidr_range: The IP address range, in CIDR format, represented by this public delegated prefix.
        :param _builtins.str ipv6_access_type: (Output)
               The internet access type for IPv6 Public Delegated Prefixes. Inherited
               from parent prefix and can be one of following:
               * EXTERNAL: The prefix will be announced to the internet. All children
               PDPs will have access type as EXTERNAL.
               * INTERNAL: The prefix wont be announced to the internet. Prefix will
               be used privately within Google Cloud. All children PDPs will have
               access type as INTERNAL.
        :param _builtins.bool is_address: Whether the sub prefix is delegated for address creation.
        :param _builtins.str mode: Specifies the mode of this IPv6 PDP. MODE must be one of:
               * DELEGATION
               * EXTERNAL_IPV6_FORWARDING_RULE_CREATION
               * EXTERNAL_IPV6_SUBNETWORK_CREATION
               * INTERNAL_IPV6_SUBNETWORK_CREATION
               Possible values are: `DELEGATION`, `EXTERNAL_IPV6_FORWARDING_RULE_CREATION`, `EXTERNAL_IPV6_SUBNETWORK_CREATION`, `INTERNAL_IPV6_SUBNETWORK_CREATION`.
        :param _builtins.str name: Name of the resource. The name must be 1-63 characters long, and
               comply with RFC1035. Specifically, the name must be 1-63 characters
               long and match the regular expression `a-z?`
               which means the first character must be a lowercase letter, and all
               following characters must be a dash, lowercase letter, or digit,
               except the last character, which cannot be a dash.
        :param _builtins.str region: A region where the prefix will reside.
        :param _builtins.str status: The status of the sub public delegated prefix.
               Possible values are: `INITIALIZING`, `READY_TO_ANNOUNCE`, `ANNOUNCED`, `DELETING`.
        """
        if allocatable_prefix_length is not None:
            pulumi.set(__self__, "allocatable_prefix_length", allocatable_prefix_length)
        if delegatee_project is not None:
            pulumi.set(__self__, "delegatee_project", delegatee_project)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ip_cidr_range is not None:
            pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        if ipv6_access_type is not None:
            pulumi.set(__self__, "ipv6_access_type", ipv6_access_type)
        if is_address is not None:
            pulumi.set(__self__, "is_address", is_address)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="allocatablePrefixLength")
    def allocatable_prefix_length(self) -> Optional[_builtins.int]:
        """
        The allocatable prefix length supported by this public delegated prefix. This field is optional and cannot be set for prefixes in DELEGATION mode. It cannot be set for IPv4 prefixes either, and it always defaults to 32.
        """
        return pulumi.get(self, "allocatable_prefix_length")

    @_builtins.property
    @pulumi.getter(name="delegateeProject")
    def delegatee_project(self) -> Optional[_builtins.str]:
        """
        Name of the project scoping this PublicDelegatedSubPrefix.
        """
        return pulumi.get(self, "delegatee_project")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> Optional[_builtins.str]:
        """
        The IP address range, in CIDR format, represented by this public delegated prefix.
        """
        return pulumi.get(self, "ip_cidr_range")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessType")
    def ipv6_access_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The internet access type for IPv6 Public Delegated Prefixes. Inherited
        from parent prefix and can be one of following:
        * EXTERNAL: The prefix will be announced to the internet. All children
        PDPs will have access type as EXTERNAL.
        * INTERNAL: The prefix wont be announced to the internet. Prefix will
        be used privately within Google Cloud. All children PDPs will have
        access type as INTERNAL.
        """
        return pulumi.get(self, "ipv6_access_type")

    @_builtins.property
    @pulumi.getter(name="isAddress")
    def is_address(self) -> Optional[_builtins.bool]:
        """
        Whether the sub prefix is delegated for address creation.
        """
        return pulumi.get(self, "is_address")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Specifies the mode of this IPv6 PDP. MODE must be one of:
        * DELEGATION
        * EXTERNAL_IPV6_FORWARDING_RULE_CREATION
        * EXTERNAL_IPV6_SUBNETWORK_CREATION
        * INTERNAL_IPV6_SUBNETWORK_CREATION
        Possible values are: `DELEGATION`, `EXTERNAL_IPV6_FORWARDING_RULE_CREATION`, `EXTERNAL_IPV6_SUBNETWORK_CREATION`, `INTERNAL_IPV6_SUBNETWORK_CREATION`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the resource. The name must be 1-63 characters long, and
        comply with RFC1035. Specifically, the name must be 1-63 characters
        long and match the regular expression `a-z?`
        which means the first character must be a lowercase letter, and all
        following characters must be a dash, lowercase letter, or digit,
        except the last character, which cannot be a dash.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        A region where the prefix will reside.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The status of the sub public delegated prefix.
        Possible values are: `INITIALIZING`, `READY_TO_ANNOUNCE`, `ANNOUNCED`, `DELETING`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"
        elif key == "cooldownPeriod":
            suggest = "cooldown_period"
        elif key == "cpuUtilization":
            suggest = "cpu_utilization"
        elif key == "loadBalancingUtilization":
            suggest = "load_balancing_utilization"
        elif key == "scaleDownControl":
            suggest = "scale_down_control"
        elif key == "scaleInControl":
            suggest = "scale_in_control"
        elif key == "scalingSchedules":
            suggest = "scaling_schedules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionAutoscalerAutoscalingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionAutoscalerAutoscalingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionAutoscalerAutoscalingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_replicas: _builtins.int,
                 min_replicas: _builtins.int,
                 cooldown_period: Optional[_builtins.int] = None,
                 cpu_utilization: Optional['outputs.RegionAutoscalerAutoscalingPolicyCpuUtilization'] = None,
                 load_balancing_utilization: Optional['outputs.RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization'] = None,
                 metrics: Optional[Sequence['outputs.RegionAutoscalerAutoscalingPolicyMetric']] = None,
                 mode: Optional[_builtins.str] = None,
                 scale_down_control: Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleDownControl'] = None,
                 scale_in_control: Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleInControl'] = None,
                 scaling_schedules: Optional[Sequence['outputs.RegionAutoscalerAutoscalingPolicyScalingSchedule']] = None):
        """
        :param _builtins.int max_replicas: The maximum number of instances that the autoscaler can scale up
               to. This is required when creating or updating an autoscaler. The
               maximum number of replicas should not be lower than minimal number
               of replicas.
        :param _builtins.int min_replicas: The minimum number of replicas that the autoscaler can scale down
               to. This cannot be less than 0. If not provided, autoscaler will
               choose a default value depending on maximum number of instances
               allowed.
        :param _builtins.int cooldown_period: The number of seconds that the autoscaler should wait before it
               starts collecting information from a new instance. This prevents
               the autoscaler from collecting information when the instance is
               initializing, during which the collected usage would not be
               reliable. The default time autoscaler waits is 60 seconds.
               Virtual machine initialization times might vary because of
               numerous factors. We recommend that you test how long an
               instance may take to initialize. To do this, create an instance
               and time the startup process.
        :param 'RegionAutoscalerAutoscalingPolicyCpuUtilizationArgs' cpu_utilization: Defines the CPU utilization policy that allows the autoscaler to
               scale based on the average CPU utilization of a managed instance
               group.
               Structure is documented below.
        :param 'RegionAutoscalerAutoscalingPolicyLoadBalancingUtilizationArgs' load_balancing_utilization: Configuration parameters of autoscaling based on a load balancer.
               Structure is documented below.
        :param Sequence['RegionAutoscalerAutoscalingPolicyMetricArgs'] metrics: Configuration parameters of autoscaling based on a custom metric.
               Structure is documented below.
        :param _builtins.str mode: Defines operating mode for this policy.
        :param 'RegionAutoscalerAutoscalingPolicyScaleDownControlArgs' scale_down_control: Defines scale down controls to reduce the risk of response latency
               and outages due to abrupt scale-in events
               Structure is documented below.
        :param 'RegionAutoscalerAutoscalingPolicyScaleInControlArgs' scale_in_control: Defines scale in controls to reduce the risk of response latency
               and outages due to abrupt scale-in events
               Structure is documented below.
        :param Sequence['RegionAutoscalerAutoscalingPolicyScalingScheduleArgs'] scaling_schedules: Scaling schedules defined for an autoscaler. Multiple schedules can be set on an autoscaler and they can overlap.
               Structure is documented below.
        """
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "min_replicas", min_replicas)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if cpu_utilization is not None:
            pulumi.set(__self__, "cpu_utilization", cpu_utilization)
        if load_balancing_utilization is not None:
            pulumi.set(__self__, "load_balancing_utilization", load_balancing_utilization)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if scale_down_control is not None:
            pulumi.set(__self__, "scale_down_control", scale_down_control)
        if scale_in_control is not None:
            pulumi.set(__self__, "scale_in_control", scale_in_control)
        if scaling_schedules is not None:
            pulumi.set(__self__, "scaling_schedules", scaling_schedules)

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> _builtins.int:
        """
        The maximum number of instances that the autoscaler can scale up
        to. This is required when creating or updating an autoscaler. The
        maximum number of replicas should not be lower than minimal number
        of replicas.
        """
        return pulumi.get(self, "max_replicas")

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> _builtins.int:
        """
        The minimum number of replicas that the autoscaler can scale down
        to. This cannot be less than 0. If not provided, autoscaler will
        choose a default value depending on maximum number of instances
        allowed.
        """
        return pulumi.get(self, "min_replicas")

    @_builtins.property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[_builtins.int]:
        """
        The number of seconds that the autoscaler should wait before it
        starts collecting information from a new instance. This prevents
        the autoscaler from collecting information when the instance is
        initializing, during which the collected usage would not be
        reliable. The default time autoscaler waits is 60 seconds.
        Virtual machine initialization times might vary because of
        numerous factors. We recommend that you test how long an
        instance may take to initialize. To do this, create an instance
        and time the startup process.
        """
        return pulumi.get(self, "cooldown_period")

    @_builtins.property
    @pulumi.getter(name="cpuUtilization")
    def cpu_utilization(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyCpuUtilization']:
        """
        Defines the CPU utilization policy that allows the autoscaler to
        scale based on the average CPU utilization of a managed instance
        group.
        Structure is documented below.
        """
        return pulumi.get(self, "cpu_utilization")

    @_builtins.property
    @pulumi.getter(name="loadBalancingUtilization")
    def load_balancing_utilization(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization']:
        """
        Configuration parameters of autoscaling based on a load balancer.
        Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_utilization")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['outputs.RegionAutoscalerAutoscalingPolicyMetric']]:
        """
        Configuration parameters of autoscaling based on a custom metric.
        Structure is documented below.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Defines operating mode for this policy.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="scaleDownControl")
    def scale_down_control(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleDownControl']:
        """
        Defines scale down controls to reduce the risk of response latency
        and outages due to abrupt scale-in events
        Structure is documented below.
        """
        return pulumi.get(self, "scale_down_control")

    @_builtins.property
    @pulumi.getter(name="scaleInControl")
    def scale_in_control(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleInControl']:
        """
        Defines scale in controls to reduce the risk of response latency
        and outages due to abrupt scale-in events
        Structure is documented below.
        """
        return pulumi.get(self, "scale_in_control")

    @_builtins.property
    @pulumi.getter(name="scalingSchedules")
    def scaling_schedules(self) -> Optional[Sequence['outputs.RegionAutoscalerAutoscalingPolicyScalingSchedule']]:
        """
        Scaling schedules defined for an autoscaler. Multiple schedules can be set on an autoscaler and they can overlap.
        Structure is documented below.
        """
        return pulumi.get(self, "scaling_schedules")


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyCpuUtilization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predictiveMethod":
            suggest = "predictive_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionAutoscalerAutoscalingPolicyCpuUtilization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionAutoscalerAutoscalingPolicyCpuUtilization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionAutoscalerAutoscalingPolicyCpuUtilization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: _builtins.float,
                 predictive_method: Optional[_builtins.str] = None):
        """
        :param _builtins.float target: The target CPU utilization that the autoscaler should maintain.
               Must be a float value in the range (0, 1]. If not specified, the
               default is 0.6.
               If the CPU level is below the target utilization, the autoscaler
               scales down the number of instances until it reaches the minimum
               number of instances you specified or until the average CPU of
               your instances reaches the target utilization.
               If the average CPU is above the target utilization, the autoscaler
               scales up until it reaches the maximum number of instances you
               specified or until the average utilization reaches the target
               utilization.
        :param _builtins.str predictive_method: Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are:
               - NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics.
               - OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
        """
        pulumi.set(__self__, "target", target)
        if predictive_method is not None:
            pulumi.set(__self__, "predictive_method", predictive_method)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        The target CPU utilization that the autoscaler should maintain.
        Must be a float value in the range (0, 1]. If not specified, the
        default is 0.6.
        If the CPU level is below the target utilization, the autoscaler
        scales down the number of instances until it reaches the minimum
        number of instances you specified or until the average CPU of
        your instances reaches the target utilization.
        If the average CPU is above the target utilization, the autoscaler
        scales up until it reaches the maximum number of instances you
        specified or until the average utilization reaches the target
        utilization.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter(name="predictiveMethod")
    def predictive_method(self) -> Optional[_builtins.str]:
        """
        Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are:
        - NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics.
        - OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
        """
        return pulumi.get(self, "predictive_method")


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization(dict):
    def __init__(__self__, *,
                 target: _builtins.float):
        """
        :param _builtins.float target: Fraction of backend capacity utilization (set in HTTP(s) load
               balancing configuration) that autoscaler should maintain. Must
               be a positive float value. If not defined, the default is 0.8.
        """
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        Fraction of backend capacity utilization (set in HTTP(s) load
        balancing configuration) that autoscaler should maintain. Must
        be a positive float value. If not defined, the default is 0.8.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "singleInstanceAssignment":
            suggest = "single_instance_assignment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionAutoscalerAutoscalingPolicyMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionAutoscalerAutoscalingPolicyMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionAutoscalerAutoscalingPolicyMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 filter: Optional[_builtins.str] = None,
                 single_instance_assignment: Optional[_builtins.float] = None,
                 target: Optional[_builtins.float] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The identifier (type) of the Stackdriver Monitoring metric.
               The metric cannot have negative values.
               The metric must have a value type of INT64 or DOUBLE.
        :param _builtins.str filter: A filter string to be used as the filter string for
               a Stackdriver Monitoring TimeSeries.list API call.
               This filter is used to select a specific TimeSeries for
               the purpose of autoscaling and to determine whether the metric
               is exporting per-instance or per-group data.
               You can only use the AND operator for joining selectors.
               You can only use direct equality comparison operator (=) without
               any functions for each selector.
               You can specify the metric in both the filter string and in the
               metric field. However, if specified in both places, the metric must
               be identical.
               The monitored resource type determines what kind of values are
               expected for the metric. If it is a gce_instance, the autoscaler
               expects the metric to include a separate TimeSeries for each
               instance in a group. In such a case, you cannot filter on resource
               labels.
               If the resource type is any other value, the autoscaler expects
               this metric to contain values that apply to the entire autoscaled
               instance group and resource label filtering can be performed to
               point autoscaler at the correct TimeSeries to scale upon.
               This is called a per-group metric for the purpose of autoscaling.
               If not specified, the type defaults to gce_instance.
               You should provide a filter that is selective enough to pick just
               one TimeSeries for the autoscaled group or for each of the instances
               (if you are using gce_instance resource type). If multiple
               TimeSeries are returned upon the query execution, the autoscaler
               will sum their respective values to obtain its scaling value.
        :param _builtins.float single_instance_assignment: If scaling is based on a per-group metric value that represents the
               total amount of work to be done or resource usage, set this value to
               an amount assigned for a single instance of the scaled group.
               The autoscaler will keep the number of instances proportional to the
               value of this metric, the metric itself should not change value due
               to group resizing.
               For example, a good metric to use with the target is
               `pubsub.googleapis.com/subscription/num_undelivered_messages`
               or a custom metric exporting the total number of requests coming to
               your instances.
               A bad example would be a metric exporting an average or median
               latency, since this value can't include a chunk assignable to a
               single instance, it could be better used with utilization_target
               instead.
        :param _builtins.float target: The target value of the metric that autoscaler should
               maintain. This must be a positive value. A utilization
               metric scales number of virtual machines handling requests
               to increase or decrease proportionally to the metric.
               For example, a good metric to use as a utilizationTarget is
               www.googleapis.com/compute/instance/network/received_bytes_count.
               The autoscaler will work to keep this value constant for each
               of the instances.
        :param _builtins.str type: Defines how target utilization value is expressed for a
               Stackdriver Monitoring metric.
               Possible values are: `GAUGE`, `DELTA_PER_SECOND`, `DELTA_PER_MINUTE`.
        """
        pulumi.set(__self__, "name", name)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if single_instance_assignment is not None:
            pulumi.set(__self__, "single_instance_assignment", single_instance_assignment)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The identifier (type) of the Stackdriver Monitoring metric.
        The metric cannot have negative values.
        The metric must have a value type of INT64 or DOUBLE.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[_builtins.str]:
        """
        A filter string to be used as the filter string for
        a Stackdriver Monitoring TimeSeries.list API call.
        This filter is used to select a specific TimeSeries for
        the purpose of autoscaling and to determine whether the metric
        is exporting per-instance or per-group data.
        You can only use the AND operator for joining selectors.
        You can only use direct equality comparison operator (=) without
        any functions for each selector.
        You can specify the metric in both the filter string and in the
        metric field. However, if specified in both places, the metric must
        be identical.
        The monitored resource type determines what kind of values are
        expected for the metric. If it is a gce_instance, the autoscaler
        expects the metric to include a separate TimeSeries for each
        instance in a group. In such a case, you cannot filter on resource
        labels.
        If the resource type is any other value, the autoscaler expects
        this metric to contain values that apply to the entire autoscaled
        instance group and resource label filtering can be performed to
        point autoscaler at the correct TimeSeries to scale upon.
        This is called a per-group metric for the purpose of autoscaling.
        If not specified, the type defaults to gce_instance.
        You should provide a filter that is selective enough to pick just
        one TimeSeries for the autoscaled group or for each of the instances
        (if you are using gce_instance resource type). If multiple
        TimeSeries are returned upon the query execution, the autoscaler
        will sum their respective values to obtain its scaling value.
        """
        return pulumi.get(self, "filter")

    @_builtins.property
    @pulumi.getter(name="singleInstanceAssignment")
    def single_instance_assignment(self) -> Optional[_builtins.float]:
        """
        If scaling is based on a per-group metric value that represents the
        total amount of work to be done or resource usage, set this value to
        an amount assigned for a single instance of the scaled group.
        The autoscaler will keep the number of instances proportional to the
        value of this metric, the metric itself should not change value due
        to group resizing.
        For example, a good metric to use with the target is
        `pubsub.googleapis.com/subscription/num_undelivered_messages`
        or a custom metric exporting the total number of requests coming to
        your instances.
        A bad example would be a metric exporting an average or median
        latency, since this value can't include a chunk assignable to a
        single instance, it could be better used with utilization_target
        instead.
        """
        return pulumi.get(self, "single_instance_assignment")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.float]:
        """
        The target value of the metric that autoscaler should
        maintain. This must be a positive value. A utilization
        metric scales number of virtual machines handling requests
        to increase or decrease proportionally to the metric.
        For example, a good metric to use as a utilizationTarget is
        www.googleapis.com/compute/instance/network/received_bytes_count.
        The autoscaler will work to keep this value constant for each
        of the instances.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Defines how target utilization value is expressed for a
        Stackdriver Monitoring metric.
        Possible values are: `GAUGE`, `DELTA_PER_SECOND`, `DELTA_PER_MINUTE`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyScaleDownControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxScaledDownReplicas":
            suggest = "max_scaled_down_replicas"
        elif key == "timeWindowSec":
            suggest = "time_window_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionAutoscalerAutoscalingPolicyScaleDownControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionAutoscalerAutoscalingPolicyScaleDownControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionAutoscalerAutoscalingPolicyScaleDownControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_scaled_down_replicas: Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas'] = None,
                 time_window_sec: Optional[_builtins.int] = None):
        """
        :param 'RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicasArgs' max_scaled_down_replicas: A nested object resource.
               Structure is documented below.
        :param _builtins.int time_window_sec: How long back autoscaling should look when computing recommendations
               to include directives regarding slower scale down, as described above.
        """
        if max_scaled_down_replicas is not None:
            pulumi.set(__self__, "max_scaled_down_replicas", max_scaled_down_replicas)
        if time_window_sec is not None:
            pulumi.set(__self__, "time_window_sec", time_window_sec)

    @_builtins.property
    @pulumi.getter(name="maxScaledDownReplicas")
    def max_scaled_down_replicas(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas']:
        """
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "max_scaled_down_replicas")

    @_builtins.property
    @pulumi.getter(name="timeWindowSec")
    def time_window_sec(self) -> Optional[_builtins.int]:
        """
        How long back autoscaling should look when computing recommendations
        to include directives regarding slower scale down, as described above.
        """
        return pulumi.get(self, "time_window_sec")


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas(dict):
    def __init__(__self__, *,
                 fixed: Optional[_builtins.int] = None,
                 percent: Optional[_builtins.int] = None):
        """
        :param _builtins.int fixed: Specifies a fixed number of VM instances. This must be a positive
               integer.
        :param _builtins.int percent: Specifies a percentage of instances between 0 to 100%, inclusive.
               For example, specify 80 for 80%.
        """
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter
    def fixed(self) -> Optional[_builtins.int]:
        """
        Specifies a fixed number of VM instances. This must be a positive
        integer.
        """
        return pulumi.get(self, "fixed")

    @_builtins.property
    @pulumi.getter
    def percent(self) -> Optional[_builtins.int]:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive.
        For example, specify 80 for 80%.
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyScaleInControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxScaledInReplicas":
            suggest = "max_scaled_in_replicas"
        elif key == "timeWindowSec":
            suggest = "time_window_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionAutoscalerAutoscalingPolicyScaleInControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionAutoscalerAutoscalingPolicyScaleInControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionAutoscalerAutoscalingPolicyScaleInControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_scaled_in_replicas: Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas'] = None,
                 time_window_sec: Optional[_builtins.int] = None):
        """
        :param 'RegionAutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicasArgs' max_scaled_in_replicas: A nested object resource.
               Structure is documented below.
        :param _builtins.int time_window_sec: How long back autoscaling should look when computing recommendations
               to include directives regarding slower scale down, as described above.
        """
        if max_scaled_in_replicas is not None:
            pulumi.set(__self__, "max_scaled_in_replicas", max_scaled_in_replicas)
        if time_window_sec is not None:
            pulumi.set(__self__, "time_window_sec", time_window_sec)

    @_builtins.property
    @pulumi.getter(name="maxScaledInReplicas")
    def max_scaled_in_replicas(self) -> Optional['outputs.RegionAutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas']:
        """
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "max_scaled_in_replicas")

    @_builtins.property
    @pulumi.getter(name="timeWindowSec")
    def time_window_sec(self) -> Optional[_builtins.int]:
        """
        How long back autoscaling should look when computing recommendations
        to include directives regarding slower scale down, as described above.
        """
        return pulumi.get(self, "time_window_sec")


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas(dict):
    def __init__(__self__, *,
                 fixed: Optional[_builtins.int] = None,
                 percent: Optional[_builtins.int] = None):
        """
        :param _builtins.int fixed: Specifies a fixed number of VM instances. This must be a positive
               integer.
        :param _builtins.int percent: Specifies a percentage of instances between 0 to 100%, inclusive.
               For example, specify 80 for 80%.
        """
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter
    def fixed(self) -> Optional[_builtins.int]:
        """
        Specifies a fixed number of VM instances. This must be a positive
        integer.
        """
        return pulumi.get(self, "fixed")

    @_builtins.property
    @pulumi.getter
    def percent(self) -> Optional[_builtins.int]:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive.
        For example, specify 80 for 80%.
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class RegionAutoscalerAutoscalingPolicyScalingSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationSec":
            suggest = "duration_sec"
        elif key == "minRequiredReplicas":
            suggest = "min_required_replicas"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionAutoscalerAutoscalingPolicyScalingSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionAutoscalerAutoscalingPolicyScalingSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionAutoscalerAutoscalingPolicyScalingSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_sec: _builtins.int,
                 min_required_replicas: _builtins.int,
                 name: _builtins.str,
                 schedule: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 time_zone: Optional[_builtins.str] = None):
        """
        :param _builtins.int duration_sec: The duration of time intervals (in seconds) for which this scaling schedule will be running. The minimum allowed value is 300.
        :param _builtins.int min_required_replicas: Minimum number of VM instances that autoscaler will recommend in time intervals starting according to schedule.
        :param _builtins.str name: The identifier for this object. Format specified above.
        :param _builtins.str schedule: The start timestamps of time intervals when this scaling schedule should provide a scaling signal. This field uses the extended cron format (with an optional year field).
        :param _builtins.str description: A description of a scaling schedule.
        :param _builtins.bool disabled: A boolean value that specifies if a scaling schedule can influence autoscaler recommendations. If set to true, then a scaling schedule has no effect.
        :param _builtins.str time_zone: The time zone to be used when interpreting the schedule. The value of this field must be a time zone name from the tz database: http://en.wikipedia.org/wiki/Tz_database.
        """
        pulumi.set(__self__, "duration_sec", duration_sec)
        pulumi.set(__self__, "min_required_replicas", min_required_replicas)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="durationSec")
    def duration_sec(self) -> _builtins.int:
        """
        The duration of time intervals (in seconds) for which this scaling schedule will be running. The minimum allowed value is 300.
        """
        return pulumi.get(self, "duration_sec")

    @_builtins.property
    @pulumi.getter(name="minRequiredReplicas")
    def min_required_replicas(self) -> _builtins.int:
        """
        Minimum number of VM instances that autoscaler will recommend in time intervals starting according to schedule.
        """
        return pulumi.get(self, "min_required_replicas")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> _builtins.str:
        """
        The start timestamps of time intervals when this scaling schedule should provide a scaling signal. This field uses the extended cron format (with an optional year field).
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of a scaling schedule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        A boolean value that specifies if a scaling schedule can influence autoscaler recommendations. If set to true, then a scaling schedule has no effect.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        """
        The time zone to be used when interpreting the schedule. The value of this field must be a time zone name from the tz database: http://en.wikipedia.org/wiki/Tz_database.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class RegionBackendServiceBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "balancingMode":
            suggest = "balancing_mode"
        elif key == "capacityScaler":
            suggest = "capacity_scaler"
        elif key == "customMetrics":
            suggest = "custom_metrics"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "maxConnectionsPerEndpoint":
            suggest = "max_connections_per_endpoint"
        elif key == "maxConnectionsPerInstance":
            suggest = "max_connections_per_instance"
        elif key == "maxInFlightRequests":
            suggest = "max_in_flight_requests"
        elif key == "maxInFlightRequestsPerEndpoint":
            suggest = "max_in_flight_requests_per_endpoint"
        elif key == "maxInFlightRequestsPerInstance":
            suggest = "max_in_flight_requests_per_instance"
        elif key == "maxRate":
            suggest = "max_rate"
        elif key == "maxRatePerEndpoint":
            suggest = "max_rate_per_endpoint"
        elif key == "maxRatePerInstance":
            suggest = "max_rate_per_instance"
        elif key == "maxUtilization":
            suggest = "max_utilization"
        elif key == "trafficDuration":
            suggest = "traffic_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group: _builtins.str,
                 balancing_mode: Optional[_builtins.str] = None,
                 capacity_scaler: Optional[_builtins.float] = None,
                 custom_metrics: Optional[Sequence['outputs.RegionBackendServiceBackendCustomMetric']] = None,
                 description: Optional[_builtins.str] = None,
                 failover: Optional[_builtins.bool] = None,
                 max_connections: Optional[_builtins.int] = None,
                 max_connections_per_endpoint: Optional[_builtins.int] = None,
                 max_connections_per_instance: Optional[_builtins.int] = None,
                 max_in_flight_requests: Optional[_builtins.int] = None,
                 max_in_flight_requests_per_endpoint: Optional[_builtins.int] = None,
                 max_in_flight_requests_per_instance: Optional[_builtins.int] = None,
                 max_rate: Optional[_builtins.int] = None,
                 max_rate_per_endpoint: Optional[_builtins.float] = None,
                 max_rate_per_instance: Optional[_builtins.float] = None,
                 max_utilization: Optional[_builtins.float] = None,
                 traffic_duration: Optional[_builtins.str] = None):
        """
        :param _builtins.str group: The fully-qualified URL of an Instance Group or Network Endpoint
               Group resource. In case of instance group this defines the list
               of instances that serve traffic. Member virtual machine
               instances from each instance group must live in the same zone as
               the instance group itself. No two backends in a backend service
               are allowed to use same Instance Group resource.
               For Network Endpoint Groups this defines list of endpoints. All
               endpoints of Network Endpoint Group must be hosted on instances
               located in the same zone as the Network Endpoint Group.
               Backend services cannot mix Instance Group and
               Network Endpoint Group backends.
               When the `load_balancing_scheme` is INTERNAL, only instance groups
               are supported.
               Note that you must specify an Instance Group or Network Endpoint
               Group resource using the fully-qualified URL, rather than a
               partial URL.
        :param _builtins.str balancing_mode: Specifies the balancing mode for this backend.
               See the [Backend Services Overview](https://cloud.google.com/load-balancing/docs/backend-service#balancing-mode)
               for an explanation of load balancing modes.
               Default value is `UTILIZATION`.
               Possible values are: `UTILIZATION`, `RATE`, `CONNECTION`, `CUSTOM_METRICS`.
        :param _builtins.float capacity_scaler: A multiplier applied to the group's maximum servicing capacity
               (based on UTILIZATION, RATE or CONNECTION).
               ~>**NOTE**: This field cannot be set for
               INTERNAL region backend services (default loadBalancingScheme),
               but is required for non-INTERNAL backend service. The total
               capacity_scaler for all backends must be non-zero.
               A setting of 0 means the group is completely drained, offering
               0% of its available Capacity. Valid range is [0.0,1.0].
        :param Sequence['RegionBackendServiceBackendCustomMetricArgs'] custom_metrics: The set of custom metrics that are used for <code>CUSTOM_METRICS</code> BalancingMode.
               Structure is documented below.
        :param _builtins.str description: An optional description of this resource.
               Provide this property when you create the resource.
        :param _builtins.bool failover: This field designates whether this is a failover backend. More
               than one failover backend can be configured for a given RegionBackendService.
        :param _builtins.int max_connections: The max number of simultaneous connections for the group. Can
               be used with either CONNECTION or UTILIZATION balancing modes.
               Cannot be set for INTERNAL backend services.
               For CONNECTION mode, either maxConnections or one
               of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
               as appropriate for group type, must be set.
        :param _builtins.int max_connections_per_endpoint: The max number of simultaneous connections that a single backend
               network endpoint can handle. Cannot be set
               for INTERNAL backend services.
               This is used to calculate the capacity of the group. Can be
               used in either CONNECTION or UTILIZATION balancing modes. For
               CONNECTION mode, either maxConnections or
               maxConnectionsPerEndpoint must be set.
        :param _builtins.int max_connections_per_instance: The max number of simultaneous connections that a single
               backend instance can handle. Cannot be set for INTERNAL backend
               services.
               This is used to calculate the capacity of the group.
               Can be used in either CONNECTION or UTILIZATION balancing modes.
               For CONNECTION mode, either maxConnections or
               maxConnectionsPerInstance must be set.
        :param _builtins.int max_in_flight_requests: Defines a maximum number of in-flight requests for the whole NEG
               or instance group. Not available if backend's balancingMode is RATE
               or CONNECTION.
        :param _builtins.int max_in_flight_requests_per_endpoint: Defines a maximum number of in-flight requests for a single endpoint.
               Not available if backend's balancingMode is RATE or CONNECTION.
        :param _builtins.int max_in_flight_requests_per_instance: Defines a maximum number of in-flight requests for a single VM.
               Not available if backend's balancingMode is RATE or CONNECTION.
        :param _builtins.int max_rate: The max requests per second (RPS) of the group. Cannot be set
               for INTERNAL backend services.
               Can be used with either RATE or UTILIZATION balancing modes,
               but required if RATE mode. Either maxRate or one
               of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
               group type, must be set.
        :param _builtins.float max_rate_per_endpoint: The max requests per second (RPS) that a single backend network
               endpoint can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerEndpoint must be set. Cannot be set
               for INTERNAL backend services.
        :param _builtins.float max_rate_per_instance: The max requests per second (RPS) that a single backend
               instance can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerInstance must be set. Cannot be set
               for INTERNAL backend services.
        :param _builtins.float max_utilization: Used when balancingMode is UTILIZATION. This ratio defines the
               CPU utilization target for the group. Valid range is [0.0, 1.0].
               Cannot be set for INTERNAL backend services.
        :param _builtins.str traffic_duration: This field specifies how long a connection should be kept alive for:
               - LONG: Most of the requests are expected to take more than multiple
               seconds to finish.
               - SHORT: Most requests are expected to finish with a sub-second latency.
               Possible values are: `LONG`, `SHORT`.
        """
        pulumi.set(__self__, "group", group)
        if balancing_mode is not None:
            pulumi.set(__self__, "balancing_mode", balancing_mode)
        if capacity_scaler is not None:
            pulumi.set(__self__, "capacity_scaler", capacity_scaler)
        if custom_metrics is not None:
            pulumi.set(__self__, "custom_metrics", custom_metrics)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if failover is not None:
            pulumi.set(__self__, "failover", failover)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_connections_per_endpoint is not None:
            pulumi.set(__self__, "max_connections_per_endpoint", max_connections_per_endpoint)
        if max_connections_per_instance is not None:
            pulumi.set(__self__, "max_connections_per_instance", max_connections_per_instance)
        if max_in_flight_requests is not None:
            pulumi.set(__self__, "max_in_flight_requests", max_in_flight_requests)
        if max_in_flight_requests_per_endpoint is not None:
            pulumi.set(__self__, "max_in_flight_requests_per_endpoint", max_in_flight_requests_per_endpoint)
        if max_in_flight_requests_per_instance is not None:
            pulumi.set(__self__, "max_in_flight_requests_per_instance", max_in_flight_requests_per_instance)
        if max_rate is not None:
            pulumi.set(__self__, "max_rate", max_rate)
        if max_rate_per_endpoint is not None:
            pulumi.set(__self__, "max_rate_per_endpoint", max_rate_per_endpoint)
        if max_rate_per_instance is not None:
            pulumi.set(__self__, "max_rate_per_instance", max_rate_per_instance)
        if max_utilization is not None:
            pulumi.set(__self__, "max_utilization", max_utilization)
        if traffic_duration is not None:
            pulumi.set(__self__, "traffic_duration", traffic_duration)

    @_builtins.property
    @pulumi.getter
    def group(self) -> _builtins.str:
        """
        The fully-qualified URL of an Instance Group or Network Endpoint
        Group resource. In case of instance group this defines the list
        of instances that serve traffic. Member virtual machine
        instances from each instance group must live in the same zone as
        the instance group itself. No two backends in a backend service
        are allowed to use same Instance Group resource.
        For Network Endpoint Groups this defines list of endpoints. All
        endpoints of Network Endpoint Group must be hosted on instances
        located in the same zone as the Network Endpoint Group.
        Backend services cannot mix Instance Group and
        Network Endpoint Group backends.
        When the `load_balancing_scheme` is INTERNAL, only instance groups
        are supported.
        Note that you must specify an Instance Group or Network Endpoint
        Group resource using the fully-qualified URL, rather than a
        partial URL.
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter(name="balancingMode")
    def balancing_mode(self) -> Optional[_builtins.str]:
        """
        Specifies the balancing mode for this backend.
        See the [Backend Services Overview](https://cloud.google.com/load-balancing/docs/backend-service#balancing-mode)
        for an explanation of load balancing modes.
        Default value is `UTILIZATION`.
        Possible values are: `UTILIZATION`, `RATE`, `CONNECTION`, `CUSTOM_METRICS`.
        """
        return pulumi.get(self, "balancing_mode")

    @_builtins.property
    @pulumi.getter(name="capacityScaler")
    def capacity_scaler(self) -> Optional[_builtins.float]:
        """
        A multiplier applied to the group's maximum servicing capacity
        (based on UTILIZATION, RATE or CONNECTION).
        ~>**NOTE**: This field cannot be set for
        INTERNAL region backend services (default loadBalancingScheme),
        but is required for non-INTERNAL backend service. The total
        capacity_scaler for all backends must be non-zero.
        A setting of 0 means the group is completely drained, offering
        0% of its available Capacity. Valid range is [0.0,1.0].
        """
        return pulumi.get(self, "capacity_scaler")

    @_builtins.property
    @pulumi.getter(name="customMetrics")
    def custom_metrics(self) -> Optional[Sequence['outputs.RegionBackendServiceBackendCustomMetric']]:
        """
        The set of custom metrics that are used for <code>CUSTOM_METRICS</code> BalancingMode.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_metrics")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resource.
        Provide this property when you create the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def failover(self) -> Optional[_builtins.bool]:
        """
        This field designates whether this is a failover backend. More
        than one failover backend can be configured for a given RegionBackendService.
        """
        return pulumi.get(self, "failover")

    @_builtins.property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[_builtins.int]:
        """
        The max number of simultaneous connections for the group. Can
        be used with either CONNECTION or UTILIZATION balancing modes.
        Cannot be set for INTERNAL backend services.
        For CONNECTION mode, either maxConnections or one
        of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
        as appropriate for group type, must be set.
        """
        return pulumi.get(self, "max_connections")

    @_builtins.property
    @pulumi.getter(name="maxConnectionsPerEndpoint")
    def max_connections_per_endpoint(self) -> Optional[_builtins.int]:
        """
        The max number of simultaneous connections that a single backend
        network endpoint can handle. Cannot be set
        for INTERNAL backend services.
        This is used to calculate the capacity of the group. Can be
        used in either CONNECTION or UTILIZATION balancing modes. For
        CONNECTION mode, either maxConnections or
        maxConnectionsPerEndpoint must be set.
        """
        return pulumi.get(self, "max_connections_per_endpoint")

    @_builtins.property
    @pulumi.getter(name="maxConnectionsPerInstance")
    def max_connections_per_instance(self) -> Optional[_builtins.int]:
        """
        The max number of simultaneous connections that a single
        backend instance can handle. Cannot be set for INTERNAL backend
        services.
        This is used to calculate the capacity of the group.
        Can be used in either CONNECTION or UTILIZATION balancing modes.
        For CONNECTION mode, either maxConnections or
        maxConnectionsPerInstance must be set.
        """
        return pulumi.get(self, "max_connections_per_instance")

    @_builtins.property
    @pulumi.getter(name="maxInFlightRequests")
    def max_in_flight_requests(self) -> Optional[_builtins.int]:
        """
        Defines a maximum number of in-flight requests for the whole NEG
        or instance group. Not available if backend's balancingMode is RATE
        or CONNECTION.
        """
        return pulumi.get(self, "max_in_flight_requests")

    @_builtins.property
    @pulumi.getter(name="maxInFlightRequestsPerEndpoint")
    def max_in_flight_requests_per_endpoint(self) -> Optional[_builtins.int]:
        """
        Defines a maximum number of in-flight requests for a single endpoint.
        Not available if backend's balancingMode is RATE or CONNECTION.
        """
        return pulumi.get(self, "max_in_flight_requests_per_endpoint")

    @_builtins.property
    @pulumi.getter(name="maxInFlightRequestsPerInstance")
    def max_in_flight_requests_per_instance(self) -> Optional[_builtins.int]:
        """
        Defines a maximum number of in-flight requests for a single VM.
        Not available if backend's balancingMode is RATE or CONNECTION.
        """
        return pulumi.get(self, "max_in_flight_requests_per_instance")

    @_builtins.property
    @pulumi.getter(name="maxRate")
    def max_rate(self) -> Optional[_builtins.int]:
        """
        The max requests per second (RPS) of the group. Cannot be set
        for INTERNAL backend services.
        Can be used with either RATE or UTILIZATION balancing modes,
        but required if RATE mode. Either maxRate or one
        of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
        group type, must be set.
        """
        return pulumi.get(self, "max_rate")

    @_builtins.property
    @pulumi.getter(name="maxRatePerEndpoint")
    def max_rate_per_endpoint(self) -> Optional[_builtins.float]:
        """
        The max requests per second (RPS) that a single backend network
        endpoint can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerEndpoint must be set. Cannot be set
        for INTERNAL backend services.
        """
        return pulumi.get(self, "max_rate_per_endpoint")

    @_builtins.property
    @pulumi.getter(name="maxRatePerInstance")
    def max_rate_per_instance(self) -> Optional[_builtins.float]:
        """
        The max requests per second (RPS) that a single backend
        instance can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerInstance must be set. Cannot be set
        for INTERNAL backend services.
        """
        return pulumi.get(self, "max_rate_per_instance")

    @_builtins.property
    @pulumi.getter(name="maxUtilization")
    def max_utilization(self) -> Optional[_builtins.float]:
        """
        Used when balancingMode is UTILIZATION. This ratio defines the
        CPU utilization target for the group. Valid range is [0.0, 1.0].
        Cannot be set for INTERNAL backend services.
        """
        return pulumi.get(self, "max_utilization")

    @_builtins.property
    @pulumi.getter(name="trafficDuration")
    def traffic_duration(self) -> Optional[_builtins.str]:
        """
        This field specifies how long a connection should be kept alive for:
        - LONG: Most of the requests are expected to take more than multiple
        seconds to finish.
        - SHORT: Most requests are expected to finish with a sub-second latency.
        Possible values are: `LONG`, `SHORT`.
        """
        return pulumi.get(self, "traffic_duration")


@pulumi.output_type
class RegionBackendServiceBackendCustomMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dryRun":
            suggest = "dry_run"
        elif key == "maxUtilization":
            suggest = "max_utilization"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceBackendCustomMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceBackendCustomMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceBackendCustomMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dry_run: _builtins.bool,
                 name: _builtins.str,
                 max_utilization: Optional[_builtins.float] = None):
        """
        :param _builtins.bool dry_run: If true, the metric data is not used for load balancing.
        :param _builtins.str name: Name of a custom utilization signal. The name must be 1-64 characters
               long and match the regular expression a-z? which
               means the first character must be a lowercase letter, and all following
               characters must be a dash, period, underscore, lowercase letter, or
               digit, except the last character, which cannot be a dash, period, or
               underscore. For usage guidelines, see Custom Metrics balancing mode. This
               field can only be used for a global or regional backend service with the
               loadBalancingScheme set to <code>EXTERNAL_MANAGED</code>,
               <code>INTERNAL_MANAGED</code> <code>INTERNAL_SELF_MANAGED</code>.
        :param _builtins.float max_utilization: Optional parameter to define a target utilization for the Custom Metrics
               balancing mode. The valid range is <code>[0.0, 1.0]</code>.
        """
        pulumi.set(__self__, "dry_run", dry_run)
        pulumi.set(__self__, "name", name)
        if max_utilization is not None:
            pulumi.set(__self__, "max_utilization", max_utilization)

    @_builtins.property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> _builtins.bool:
        """
        If true, the metric data is not used for load balancing.
        """
        return pulumi.get(self, "dry_run")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a custom utilization signal. The name must be 1-64 characters
        long and match the regular expression a-z? which
        means the first character must be a lowercase letter, and all following
        characters must be a dash, period, underscore, lowercase letter, or
        digit, except the last character, which cannot be a dash, period, or
        underscore. For usage guidelines, see Custom Metrics balancing mode. This
        field can only be used for a global or regional backend service with the
        loadBalancingScheme set to <code>EXTERNAL_MANAGED</code>,
        <code>INTERNAL_MANAGED</code> <code>INTERNAL_SELF_MANAGED</code>.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="maxUtilization")
    def max_utilization(self) -> Optional[_builtins.float]:
        """
        Optional parameter to define a target utilization for the Custom Metrics
        balancing mode. The valid range is <code>[0.0, 1.0]</code>.
        """
        return pulumi.get(self, "max_utilization")


@pulumi.output_type
class RegionBackendServiceCdnPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheKeyPolicy":
            suggest = "cache_key_policy"
        elif key == "cacheMode":
            suggest = "cache_mode"
        elif key == "clientTtl":
            suggest = "client_ttl"
        elif key == "defaultTtl":
            suggest = "default_ttl"
        elif key == "maxTtl":
            suggest = "max_ttl"
        elif key == "negativeCaching":
            suggest = "negative_caching"
        elif key == "negativeCachingPolicies":
            suggest = "negative_caching_policies"
        elif key == "serveWhileStale":
            suggest = "serve_while_stale"
        elif key == "signedUrlCacheMaxAgeSec":
            suggest = "signed_url_cache_max_age_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceCdnPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceCdnPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceCdnPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_key_policy: Optional['outputs.RegionBackendServiceCdnPolicyCacheKeyPolicy'] = None,
                 cache_mode: Optional[_builtins.str] = None,
                 client_ttl: Optional[_builtins.int] = None,
                 default_ttl: Optional[_builtins.int] = None,
                 max_ttl: Optional[_builtins.int] = None,
                 negative_caching: Optional[_builtins.bool] = None,
                 negative_caching_policies: Optional[Sequence['outputs.RegionBackendServiceCdnPolicyNegativeCachingPolicy']] = None,
                 serve_while_stale: Optional[_builtins.int] = None,
                 signed_url_cache_max_age_sec: Optional[_builtins.int] = None):
        """
        :param 'RegionBackendServiceCdnPolicyCacheKeyPolicyArgs' cache_key_policy: The CacheKeyPolicy for this CdnPolicy.
               Structure is documented below.
        :param _builtins.str cache_mode: Specifies the cache setting for all responses from this backend.
               The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
               Possible values are: `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, `CACHE_ALL_STATIC`.
        :param _builtins.int client_ttl: Specifies the maximum allowed TTL for cached content served by this origin.
        :param _builtins.int default_ttl: Specifies the default TTL for cached content served by this origin for responses
               that do not have an existing valid TTL (max-age or s-max-age).
        :param _builtins.int max_ttl: Specifies the maximum allowed TTL for cached content served by this origin.
        :param _builtins.bool negative_caching: Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        :param Sequence['RegionBackendServiceCdnPolicyNegativeCachingPolicyArgs'] negative_caching_policies: Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
               Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
               Structure is documented below.
        :param _builtins.int serve_while_stale: Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        :param _builtins.int signed_url_cache_max_age_sec: Maximum number of seconds the response to a signed URL request
               will be considered fresh, defaults to 1hr (3600s). After this
               time period, the response will be revalidated before
               being served.
               When serving responses to signed URL requests, Cloud CDN will
               internally behave as though all responses from this backend had a
               "Cache-Control: public, max-age=[TTL]" header, regardless of any
               existing Cache-Control header. The actual headers served in
               responses will not be altered.
        """
        if cache_key_policy is not None:
            pulumi.set(__self__, "cache_key_policy", cache_key_policy)
        if cache_mode is not None:
            pulumi.set(__self__, "cache_mode", cache_mode)
        if client_ttl is not None:
            pulumi.set(__self__, "client_ttl", client_ttl)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if negative_caching is not None:
            pulumi.set(__self__, "negative_caching", negative_caching)
        if negative_caching_policies is not None:
            pulumi.set(__self__, "negative_caching_policies", negative_caching_policies)
        if serve_while_stale is not None:
            pulumi.set(__self__, "serve_while_stale", serve_while_stale)
        if signed_url_cache_max_age_sec is not None:
            pulumi.set(__self__, "signed_url_cache_max_age_sec", signed_url_cache_max_age_sec)

    @_builtins.property
    @pulumi.getter(name="cacheKeyPolicy")
    def cache_key_policy(self) -> Optional['outputs.RegionBackendServiceCdnPolicyCacheKeyPolicy']:
        """
        The CacheKeyPolicy for this CdnPolicy.
        Structure is documented below.
        """
        return pulumi.get(self, "cache_key_policy")

    @_builtins.property
    @pulumi.getter(name="cacheMode")
    def cache_mode(self) -> Optional[_builtins.str]:
        """
        Specifies the cache setting for all responses from this backend.
        The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
        Possible values are: `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, `CACHE_ALL_STATIC`.
        """
        return pulumi.get(self, "cache_mode")

    @_builtins.property
    @pulumi.getter(name="clientTtl")
    def client_ttl(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum allowed TTL for cached content served by this origin.
        """
        return pulumi.get(self, "client_ttl")

    @_builtins.property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[_builtins.int]:
        """
        Specifies the default TTL for cached content served by this origin for responses
        that do not have an existing valid TTL (max-age or s-max-age).
        """
        return pulumi.get(self, "default_ttl")

    @_builtins.property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum allowed TTL for cached content served by this origin.
        """
        return pulumi.get(self, "max_ttl")

    @_builtins.property
    @pulumi.getter(name="negativeCaching")
    def negative_caching(self) -> Optional[_builtins.bool]:
        """
        Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        """
        return pulumi.get(self, "negative_caching")

    @_builtins.property
    @pulumi.getter(name="negativeCachingPolicies")
    def negative_caching_policies(self) -> Optional[Sequence['outputs.RegionBackendServiceCdnPolicyNegativeCachingPolicy']]:
        """
        Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
        Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
        Structure is documented below.
        """
        return pulumi.get(self, "negative_caching_policies")

    @_builtins.property
    @pulumi.getter(name="serveWhileStale")
    def serve_while_stale(self) -> Optional[_builtins.int]:
        """
        Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        """
        return pulumi.get(self, "serve_while_stale")

    @_builtins.property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> Optional[_builtins.int]:
        """
        Maximum number of seconds the response to a signed URL request
        will be considered fresh, defaults to 1hr (3600s). After this
        time period, the response will be revalidated before
        being served.
        When serving responses to signed URL requests, Cloud CDN will
        internally behave as though all responses from this backend had a
        "Cache-Control: public, max-age=[TTL]" header, regardless of any
        existing Cache-Control header. The actual headers served in
        responses will not be altered.
        """
        return pulumi.get(self, "signed_url_cache_max_age_sec")


@pulumi.output_type
class RegionBackendServiceCdnPolicyCacheKeyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeHost":
            suggest = "include_host"
        elif key == "includeNamedCookies":
            suggest = "include_named_cookies"
        elif key == "includeProtocol":
            suggest = "include_protocol"
        elif key == "includeQueryString":
            suggest = "include_query_string"
        elif key == "queryStringBlacklists":
            suggest = "query_string_blacklists"
        elif key == "queryStringWhitelists":
            suggest = "query_string_whitelists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceCdnPolicyCacheKeyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceCdnPolicyCacheKeyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceCdnPolicyCacheKeyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_host: Optional[_builtins.bool] = None,
                 include_named_cookies: Optional[Sequence[_builtins.str]] = None,
                 include_protocol: Optional[_builtins.bool] = None,
                 include_query_string: Optional[_builtins.bool] = None,
                 query_string_blacklists: Optional[Sequence[_builtins.str]] = None,
                 query_string_whitelists: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool include_host: If true requests to different hosts will be cached separately.
        :param Sequence[_builtins.str] include_named_cookies: Names of cookies to include in cache keys.
        :param _builtins.bool include_protocol: If true, http and https requests will be cached separately.
        :param _builtins.bool include_query_string: If true, include query string parameters in the cache key
               according to query_string_whitelist and
               query_string_blacklist. If neither is set, the entire query
               string will be included.
               If false, the query string will be excluded from the cache
               key entirely.
        :param Sequence[_builtins.str] query_string_blacklists: Names of query string parameters to exclude in cache keys.
               All other parameters will be included. Either specify
               query_string_whitelist or query_string_blacklist, not both.
               '&' and '=' will be percent encoded and not treated as
               delimiters.
        :param Sequence[_builtins.str] query_string_whitelists: Names of query string parameters to include in cache keys.
               All other parameters will be excluded. Either specify
               query_string_whitelist or query_string_blacklist, not both.
               '&' and '=' will be percent encoded and not treated as
               delimiters.
        """
        if include_host is not None:
            pulumi.set(__self__, "include_host", include_host)
        if include_named_cookies is not None:
            pulumi.set(__self__, "include_named_cookies", include_named_cookies)
        if include_protocol is not None:
            pulumi.set(__self__, "include_protocol", include_protocol)
        if include_query_string is not None:
            pulumi.set(__self__, "include_query_string", include_query_string)
        if query_string_blacklists is not None:
            pulumi.set(__self__, "query_string_blacklists", query_string_blacklists)
        if query_string_whitelists is not None:
            pulumi.set(__self__, "query_string_whitelists", query_string_whitelists)

    @_builtins.property
    @pulumi.getter(name="includeHost")
    def include_host(self) -> Optional[_builtins.bool]:
        """
        If true requests to different hosts will be cached separately.
        """
        return pulumi.get(self, "include_host")

    @_builtins.property
    @pulumi.getter(name="includeNamedCookies")
    def include_named_cookies(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of cookies to include in cache keys.
        """
        return pulumi.get(self, "include_named_cookies")

    @_builtins.property
    @pulumi.getter(name="includeProtocol")
    def include_protocol(self) -> Optional[_builtins.bool]:
        """
        If true, http and https requests will be cached separately.
        """
        return pulumi.get(self, "include_protocol")

    @_builtins.property
    @pulumi.getter(name="includeQueryString")
    def include_query_string(self) -> Optional[_builtins.bool]:
        """
        If true, include query string parameters in the cache key
        according to query_string_whitelist and
        query_string_blacklist. If neither is set, the entire query
        string will be included.
        If false, the query string will be excluded from the cache
        key entirely.
        """
        return pulumi.get(self, "include_query_string")

    @_builtins.property
    @pulumi.getter(name="queryStringBlacklists")
    def query_string_blacklists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of query string parameters to exclude in cache keys.
        All other parameters will be included. Either specify
        query_string_whitelist or query_string_blacklist, not both.
        '&' and '=' will be percent encoded and not treated as
        delimiters.
        """
        return pulumi.get(self, "query_string_blacklists")

    @_builtins.property
    @pulumi.getter(name="queryStringWhitelists")
    def query_string_whitelists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of query string parameters to include in cache keys.
        All other parameters will be excluded. Either specify
        query_string_whitelist or query_string_blacklist, not both.
        '&' and '=' will be percent encoded and not treated as
        delimiters.
        """
        return pulumi.get(self, "query_string_whitelists")


@pulumi.output_type
class RegionBackendServiceCdnPolicyNegativeCachingPolicy(dict):
    def __init__(__self__, *,
                 code: Optional[_builtins.int] = None,
                 ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.int code: The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
               can be specified as values, and you cannot specify a status code more than once.
        :param _builtins.int ttl: The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
               (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.int]:
        """
        The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
        can be specified as values, and you cannot specify a status code more than once.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
        (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class RegionBackendServiceCircuitBreakers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "maxPendingRequests":
            suggest = "max_pending_requests"
        elif key == "maxRequests":
            suggest = "max_requests"
        elif key == "maxRequestsPerConnection":
            suggest = "max_requests_per_connection"
        elif key == "maxRetries":
            suggest = "max_retries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceCircuitBreakers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceCircuitBreakers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceCircuitBreakers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connect_timeout: Optional['outputs.RegionBackendServiceCircuitBreakersConnectTimeout'] = None,
                 max_connections: Optional[_builtins.int] = None,
                 max_pending_requests: Optional[_builtins.int] = None,
                 max_requests: Optional[_builtins.int] = None,
                 max_requests_per_connection: Optional[_builtins.int] = None,
                 max_retries: Optional[_builtins.int] = None):
        """
        :param 'RegionBackendServiceCircuitBreakersConnectTimeoutArgs' connect_timeout: The timeout for new network connections to hosts.
               Structure is documented below.
        :param _builtins.int max_connections: The maximum number of connections to the backend cluster.
               Defaults to 1024.
        :param _builtins.int max_pending_requests: The maximum number of pending requests to the backend cluster.
               Defaults to 1024.
        :param _builtins.int max_requests: The maximum number of parallel requests to the backend cluster.
               Defaults to 1024.
        :param _builtins.int max_requests_per_connection: Maximum requests for a single backend connection. This parameter
               is respected by both the HTTP/1.1 and HTTP/2 implementations. If
               not specified, there is no limit. Setting this parameter to 1
               will effectively disable keep alive.
        :param _builtins.int max_retries: The maximum number of parallel retries to the backend cluster.
               Defaults to 3.
        """
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_pending_requests is not None:
            pulumi.set(__self__, "max_pending_requests", max_pending_requests)
        if max_requests is not None:
            pulumi.set(__self__, "max_requests", max_requests)
        if max_requests_per_connection is not None:
            pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)

    @_builtins.property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional['outputs.RegionBackendServiceCircuitBreakersConnectTimeout']:
        """
        The timeout for new network connections to hosts.
        Structure is documented below.
        """
        return pulumi.get(self, "connect_timeout")

    @_builtins.property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[_builtins.int]:
        """
        The maximum number of connections to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_connections")

    @_builtins.property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> Optional[_builtins.int]:
        """
        The maximum number of pending requests to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_pending_requests")

    @_builtins.property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> Optional[_builtins.int]:
        """
        The maximum number of parallel requests to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_requests")

    @_builtins.property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> Optional[_builtins.int]:
        """
        Maximum requests for a single backend connection. This parameter
        is respected by both the HTTP/1.1 and HTTP/2 implementations. If
        not specified, there is no limit. Setting this parameter to 1
        will effectively disable keep alive.
        """
        return pulumi.get(self, "max_requests_per_connection")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        """
        The maximum number of parallel retries to the backend cluster.
        Defaults to 3.
        """
        return pulumi.get(self, "max_retries")


@pulumi.output_type
class RegionBackendServiceCircuitBreakersConnectTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionBackendServiceConnectionTrackingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionPersistenceOnUnhealthyBackends":
            suggest = "connection_persistence_on_unhealthy_backends"
        elif key == "enableStrongAffinity":
            suggest = "enable_strong_affinity"
        elif key == "idleTimeoutSec":
            suggest = "idle_timeout_sec"
        elif key == "trackingMode":
            suggest = "tracking_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceConnectionTrackingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceConnectionTrackingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceConnectionTrackingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_persistence_on_unhealthy_backends: Optional[_builtins.str] = None,
                 enable_strong_affinity: Optional[_builtins.bool] = None,
                 idle_timeout_sec: Optional[_builtins.int] = None,
                 tracking_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str connection_persistence_on_unhealthy_backends: Specifies connection persistence when backends are unhealthy.
               If set to `DEFAULT_FOR_PROTOCOL`, the existing connections persist on
               unhealthy backends only for connection-oriented protocols (TCP and SCTP)
               and only if the Tracking Mode is PER_CONNECTION (default tracking mode)
               or the Session Affinity is configured for 5-tuple. They do not persist
               for UDP.
               If set to `NEVER_PERSIST`, after a backend becomes unhealthy, the existing
               connections on the unhealthy backend are never persisted on the unhealthy
               backend. They are always diverted to newly selected healthy backends
               (unless all backends are unhealthy).
               If set to `ALWAYS_PERSIST`, existing connections always persist on
               unhealthy backends regardless of protocol and session affinity. It is
               generally not recommended to use this mode overriding the default.
               Default value is `DEFAULT_FOR_PROTOCOL`.
               Possible values are: `DEFAULT_FOR_PROTOCOL`, `NEVER_PERSIST`, `ALWAYS_PERSIST`.
        :param _builtins.bool enable_strong_affinity: Enable Strong Session Affinity for Network Load Balancing. This option is not available publicly.
        :param _builtins.int idle_timeout_sec: Specifies how long to keep a Connection Tracking entry while there is
               no matching traffic (in seconds).
               For L4 ILB the minimum(default) is 10 minutes and maximum is 16 hours.
               For NLB the minimum(default) is 60 seconds and the maximum is 16 hours.
        :param _builtins.str tracking_mode: Specifies the key used for connection tracking. There are two options:
               `PER_CONNECTION`: The Connection Tracking is performed as per the
               Connection Key (default Hash Method) for the specific protocol.
               `PER_SESSION`: The Connection Tracking is performed as per the
               configured Session Affinity. It matches the configured Session Affinity.
               Default value is `PER_CONNECTION`.
               Possible values are: `PER_CONNECTION`, `PER_SESSION`.
        """
        if connection_persistence_on_unhealthy_backends is not None:
            pulumi.set(__self__, "connection_persistence_on_unhealthy_backends", connection_persistence_on_unhealthy_backends)
        if enable_strong_affinity is not None:
            pulumi.set(__self__, "enable_strong_affinity", enable_strong_affinity)
        if idle_timeout_sec is not None:
            pulumi.set(__self__, "idle_timeout_sec", idle_timeout_sec)
        if tracking_mode is not None:
            pulumi.set(__self__, "tracking_mode", tracking_mode)

    @_builtins.property
    @pulumi.getter(name="connectionPersistenceOnUnhealthyBackends")
    def connection_persistence_on_unhealthy_backends(self) -> Optional[_builtins.str]:
        """
        Specifies connection persistence when backends are unhealthy.
        If set to `DEFAULT_FOR_PROTOCOL`, the existing connections persist on
        unhealthy backends only for connection-oriented protocols (TCP and SCTP)
        and only if the Tracking Mode is PER_CONNECTION (default tracking mode)
        or the Session Affinity is configured for 5-tuple. They do not persist
        for UDP.
        If set to `NEVER_PERSIST`, after a backend becomes unhealthy, the existing
        connections on the unhealthy backend are never persisted on the unhealthy
        backend. They are always diverted to newly selected healthy backends
        (unless all backends are unhealthy).
        If set to `ALWAYS_PERSIST`, existing connections always persist on
        unhealthy backends regardless of protocol and session affinity. It is
        generally not recommended to use this mode overriding the default.
        Default value is `DEFAULT_FOR_PROTOCOL`.
        Possible values are: `DEFAULT_FOR_PROTOCOL`, `NEVER_PERSIST`, `ALWAYS_PERSIST`.
        """
        return pulumi.get(self, "connection_persistence_on_unhealthy_backends")

    @_builtins.property
    @pulumi.getter(name="enableStrongAffinity")
    def enable_strong_affinity(self) -> Optional[_builtins.bool]:
        """
        Enable Strong Session Affinity for Network Load Balancing. This option is not available publicly.
        """
        return pulumi.get(self, "enable_strong_affinity")

    @_builtins.property
    @pulumi.getter(name="idleTimeoutSec")
    def idle_timeout_sec(self) -> Optional[_builtins.int]:
        """
        Specifies how long to keep a Connection Tracking entry while there is
        no matching traffic (in seconds).
        For L4 ILB the minimum(default) is 10 minutes and maximum is 16 hours.
        For NLB the minimum(default) is 60 seconds and the maximum is 16 hours.
        """
        return pulumi.get(self, "idle_timeout_sec")

    @_builtins.property
    @pulumi.getter(name="trackingMode")
    def tracking_mode(self) -> Optional[_builtins.str]:
        """
        Specifies the key used for connection tracking. There are two options:
        `PER_CONNECTION`: The Connection Tracking is performed as per the
        Connection Key (default Hash Method) for the specific protocol.
        `PER_SESSION`: The Connection Tracking is performed as per the
        configured Session Affinity. It matches the configured Session Affinity.
        Default value is `PER_CONNECTION`.
        Possible values are: `PER_CONNECTION`, `PER_SESSION`.
        """
        return pulumi.get(self, "tracking_mode")


@pulumi.output_type
class RegionBackendServiceConsistentHash(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpCookie":
            suggest = "http_cookie"
        elif key == "httpHeaderName":
            suggest = "http_header_name"
        elif key == "minimumRingSize":
            suggest = "minimum_ring_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceConsistentHash. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceConsistentHash.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceConsistentHash.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_cookie: Optional['outputs.RegionBackendServiceConsistentHashHttpCookie'] = None,
                 http_header_name: Optional[_builtins.str] = None,
                 minimum_ring_size: Optional[_builtins.int] = None):
        """
        :param 'RegionBackendServiceConsistentHashHttpCookieArgs' http_cookie: Hash is based on HTTP Cookie. This field describes a HTTP cookie
               that will be used as the hash key for the consistent hash load
               balancer. If the cookie is not present, it will be generated.
               This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
               Structure is documented below.
        :param _builtins.str http_header_name: The hash based on the value of the specified header field.
               This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        :param _builtins.int minimum_ring_size: The minimum number of virtual nodes to use for the hash ring.
               Larger ring sizes result in more granular load
               distributions. If the number of hosts in the load balancing pool
               is larger than the ring size, each host will be assigned a single
               virtual node.
               Defaults to 1024.
        """
        if http_cookie is not None:
            pulumi.set(__self__, "http_cookie", http_cookie)
        if http_header_name is not None:
            pulumi.set(__self__, "http_header_name", http_header_name)
        if minimum_ring_size is not None:
            pulumi.set(__self__, "minimum_ring_size", minimum_ring_size)

    @_builtins.property
    @pulumi.getter(name="httpCookie")
    def http_cookie(self) -> Optional['outputs.RegionBackendServiceConsistentHashHttpCookie']:
        """
        Hash is based on HTTP Cookie. This field describes a HTTP cookie
        that will be used as the hash key for the consistent hash load
        balancer. If the cookie is not present, it will be generated.
        This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
        Structure is documented below.
        """
        return pulumi.get(self, "http_cookie")

    @_builtins.property
    @pulumi.getter(name="httpHeaderName")
    def http_header_name(self) -> Optional[_builtins.str]:
        """
        The hash based on the value of the specified header field.
        This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        """
        return pulumi.get(self, "http_header_name")

    @_builtins.property
    @pulumi.getter(name="minimumRingSize")
    def minimum_ring_size(self) -> Optional[_builtins.int]:
        """
        The minimum number of virtual nodes to use for the hash ring.
        Larger ring sizes result in more granular load
        distributions. If the number of hosts in the load balancing pool
        is larger than the ring size, each host will be assigned a single
        virtual node.
        Defaults to 1024.
        """
        return pulumi.get(self, "minimum_ring_size")


@pulumi.output_type
class RegionBackendServiceConsistentHashHttpCookie(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 ttl: Optional['outputs.RegionBackendServiceConsistentHashHttpCookieTtl'] = None):
        """
        :param _builtins.str name: Name of the cookie.
        :param _builtins.str path: Path to set for the cookie.
        :param 'RegionBackendServiceConsistentHashHttpCookieTtlArgs' ttl: Lifetime of the cookie.
               Structure is documented below.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the cookie.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to set for the cookie.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional['outputs.RegionBackendServiceConsistentHashHttpCookieTtl']:
        """
        Lifetime of the cookie.
        Structure is documented below.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class RegionBackendServiceConsistentHashHttpCookieTtl(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionBackendServiceCustomMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dryRun":
            suggest = "dry_run"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceCustomMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceCustomMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceCustomMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dry_run: _builtins.bool,
                 name: _builtins.str):
        """
        :param _builtins.bool dry_run: If true, the metric data is not used for load balancing.
        :param _builtins.str name: Name of a custom utilization signal. The name must be 1-64 characters
               long and match the regular expression a-z? which
               means the first character must be a lowercase letter, and all following
               characters must be a dash, period, underscore, lowercase letter, or
               digit, except the last character, which cannot be a dash, period, or
               underscore. For usage guidelines, see Custom Metrics balancing mode. This
               field can only be used for a global or regional backend service with the
               loadBalancingScheme set to <code>EXTERNAL_MANAGED</code>,
               <code>INTERNAL_MANAGED</code> <code>INTERNAL_SELF_MANAGED</code>.
        """
        pulumi.set(__self__, "dry_run", dry_run)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> _builtins.bool:
        """
        If true, the metric data is not used for load balancing.
        """
        return pulumi.get(self, "dry_run")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a custom utilization signal. The name must be 1-64 characters
        long and match the regular expression a-z? which
        means the first character must be a lowercase letter, and all following
        characters must be a dash, period, underscore, lowercase letter, or
        digit, except the last character, which cannot be a dash, period, or
        underscore. For usage guidelines, see Custom Metrics balancing mode. This
        field can only be used for a global or regional backend service with the
        loadBalancingScheme set to <code>EXTERNAL_MANAGED</code>,
        <code>INTERNAL_MANAGED</code> <code>INTERNAL_SELF_MANAGED</code>.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RegionBackendServiceDynamicForwarding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipPortSelection":
            suggest = "ip_port_selection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceDynamicForwarding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceDynamicForwarding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceDynamicForwarding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_port_selection: Optional['outputs.RegionBackendServiceDynamicForwardingIpPortSelection'] = None):
        """
        :param 'RegionBackendServiceDynamicForwardingIpPortSelectionArgs' ip_port_selection: IP:PORT based dynamic forwarding configuration.
               Structure is documented below.
        """
        if ip_port_selection is not None:
            pulumi.set(__self__, "ip_port_selection", ip_port_selection)

    @_builtins.property
    @pulumi.getter(name="ipPortSelection")
    def ip_port_selection(self) -> Optional['outputs.RegionBackendServiceDynamicForwardingIpPortSelection']:
        """
        IP:PORT based dynamic forwarding configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "ip_port_selection")


@pulumi.output_type
class RegionBackendServiceDynamicForwardingIpPortSelection(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: A boolean flag enabling IP:PORT based dynamic forwarding.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        A boolean flag enabling IP:PORT based dynamic forwarding.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class RegionBackendServiceFailoverPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableConnectionDrainOnFailover":
            suggest = "disable_connection_drain_on_failover"
        elif key == "dropTrafficIfUnhealthy":
            suggest = "drop_traffic_if_unhealthy"
        elif key == "failoverRatio":
            suggest = "failover_ratio"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceFailoverPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceFailoverPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceFailoverPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_connection_drain_on_failover: Optional[_builtins.bool] = None,
                 drop_traffic_if_unhealthy: Optional[_builtins.bool] = None,
                 failover_ratio: Optional[_builtins.float] = None):
        """
        :param _builtins.bool disable_connection_drain_on_failover: On failover or failback, this field indicates whether connection drain
               will be honored. Setting this to true has the following effect: connections
               to the old active pool are not drained. Connections to the new active pool
               use the timeout of 10 min (currently fixed). Setting to false has the
               following effect: both old and new connections will have a drain timeout
               of 10 min.
               This can be set to true only if the protocol is TCP.
               The default is false.
        :param _builtins.bool drop_traffic_if_unhealthy: This option is used only when no healthy VMs are detected in the primary
               and backup instance groups. When set to true, traffic is dropped. When
               set to false, new connections are sent across all VMs in the primary group.
               The default is false.
        :param _builtins.float failover_ratio: The value of the field must be in [0, 1]. If the ratio of the healthy
               VMs in the primary backend is at or below this number, traffic arriving
               at the load-balanced IP will be directed to the failover backend.
               In case where 'failoverRatio' is not set or all the VMs in the backup
               backend are unhealthy, the traffic will be directed back to the primary
               backend in the "force" mode, where traffic will be spread to the healthy
               VMs with the best effort, or to all VMs when no VM is healthy.
               This field is only used with l4 load balancing.
        """
        if disable_connection_drain_on_failover is not None:
            pulumi.set(__self__, "disable_connection_drain_on_failover", disable_connection_drain_on_failover)
        if drop_traffic_if_unhealthy is not None:
            pulumi.set(__self__, "drop_traffic_if_unhealthy", drop_traffic_if_unhealthy)
        if failover_ratio is not None:
            pulumi.set(__self__, "failover_ratio", failover_ratio)

    @_builtins.property
    @pulumi.getter(name="disableConnectionDrainOnFailover")
    def disable_connection_drain_on_failover(self) -> Optional[_builtins.bool]:
        """
        On failover or failback, this field indicates whether connection drain
        will be honored. Setting this to true has the following effect: connections
        to the old active pool are not drained. Connections to the new active pool
        use the timeout of 10 min (currently fixed). Setting to false has the
        following effect: both old and new connections will have a drain timeout
        of 10 min.
        This can be set to true only if the protocol is TCP.
        The default is false.
        """
        return pulumi.get(self, "disable_connection_drain_on_failover")

    @_builtins.property
    @pulumi.getter(name="dropTrafficIfUnhealthy")
    def drop_traffic_if_unhealthy(self) -> Optional[_builtins.bool]:
        """
        This option is used only when no healthy VMs are detected in the primary
        and backup instance groups. When set to true, traffic is dropped. When
        set to false, new connections are sent across all VMs in the primary group.
        The default is false.
        """
        return pulumi.get(self, "drop_traffic_if_unhealthy")

    @_builtins.property
    @pulumi.getter(name="failoverRatio")
    def failover_ratio(self) -> Optional[_builtins.float]:
        """
        The value of the field must be in [0, 1]. If the ratio of the healthy
        VMs in the primary backend is at or below this number, traffic arriving
        at the load-balanced IP will be directed to the failover backend.
        In case where 'failoverRatio' is not set or all the VMs in the backup
        backend are unhealthy, the traffic will be directed back to the primary
        backend in the "force" mode, where traffic will be spread to the healthy
        VMs with the best effort, or to all VMs when no VM is healthy.
        This field is only used with l4 load balancing.
        """
        return pulumi.get(self, "failover_ratio")


@pulumi.output_type
class RegionBackendServiceHaPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fastIpMove":
            suggest = "fast_ip_move"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceHaPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceHaPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceHaPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fast_ip_move: Optional[_builtins.str] = None,
                 leader: Optional['outputs.RegionBackendServiceHaPolicyLeader'] = None):
        """
        :param _builtins.str fast_ip_move: Specifies whether fast IP move is enabled, and if so, the mechanism to achieve it.
               Supported values are:
               * `DISABLED`: Fast IP Move is disabled. You can only use the haPolicy.leader API to
               update the leader.
               * `GARP_RA`: Provides a method to very quickly define a new network endpoint as the
               leader. This method is faster than updating the leader using the
               haPolicy.leader API. Fast IP move works as follows: The VM hosting the
               network endpoint that should become the new leader sends either a
               Gratuitous ARP (GARP) packet (IPv4) or an ICMPv6 Router Advertisement(RA)
               packet (IPv6). Google Cloud immediately but temporarily associates the
               forwarding rule IP address with that VM, and both new and in-flight packets
               are quickly delivered to that VM.
               Possible values are: `DISABLED`, `GARP_RA`.
        :param 'RegionBackendServiceHaPolicyLeaderArgs' leader: Selects one of the network endpoints attached to the backend NEGs of this service as the
               active endpoint (the leader) that receives all traffic.
               Structure is documented below.
        """
        if fast_ip_move is not None:
            pulumi.set(__self__, "fast_ip_move", fast_ip_move)
        if leader is not None:
            pulumi.set(__self__, "leader", leader)

    @_builtins.property
    @pulumi.getter(name="fastIpMove")
    def fast_ip_move(self) -> Optional[_builtins.str]:
        """
        Specifies whether fast IP move is enabled, and if so, the mechanism to achieve it.
        Supported values are:
        * `DISABLED`: Fast IP Move is disabled. You can only use the haPolicy.leader API to
        update the leader.
        * `GARP_RA`: Provides a method to very quickly define a new network endpoint as the
        leader. This method is faster than updating the leader using the
        haPolicy.leader API. Fast IP move works as follows: The VM hosting the
        network endpoint that should become the new leader sends either a
        Gratuitous ARP (GARP) packet (IPv4) or an ICMPv6 Router Advertisement(RA)
        packet (IPv6). Google Cloud immediately but temporarily associates the
        forwarding rule IP address with that VM, and both new and in-flight packets
        are quickly delivered to that VM.
        Possible values are: `DISABLED`, `GARP_RA`.
        """
        return pulumi.get(self, "fast_ip_move")

    @_builtins.property
    @pulumi.getter
    def leader(self) -> Optional['outputs.RegionBackendServiceHaPolicyLeader']:
        """
        Selects one of the network endpoints attached to the backend NEGs of this service as the
        active endpoint (the leader) that receives all traffic.
        Structure is documented below.
        """
        return pulumi.get(self, "leader")


@pulumi.output_type
class RegionBackendServiceHaPolicyLeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendGroup":
            suggest = "backend_group"
        elif key == "networkEndpoint":
            suggest = "network_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceHaPolicyLeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceHaPolicyLeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceHaPolicyLeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_group: Optional[_builtins.str] = None,
                 network_endpoint: Optional['outputs.RegionBackendServiceHaPolicyLeaderNetworkEndpoint'] = None):
        """
        :param _builtins.str backend_group: A fully-qualified URL of the zonal Network Endpoint Group (NEG) that the leader is
               attached to.
        :param 'RegionBackendServiceHaPolicyLeaderNetworkEndpointArgs' network_endpoint: The network endpoint within the leader.backendGroup that is designated as the leader.
               Structure is documented below.
        """
        if backend_group is not None:
            pulumi.set(__self__, "backend_group", backend_group)
        if network_endpoint is not None:
            pulumi.set(__self__, "network_endpoint", network_endpoint)

    @_builtins.property
    @pulumi.getter(name="backendGroup")
    def backend_group(self) -> Optional[_builtins.str]:
        """
        A fully-qualified URL of the zonal Network Endpoint Group (NEG) that the leader is
        attached to.
        """
        return pulumi.get(self, "backend_group")

    @_builtins.property
    @pulumi.getter(name="networkEndpoint")
    def network_endpoint(self) -> Optional['outputs.RegionBackendServiceHaPolicyLeaderNetworkEndpoint']:
        """
        The network endpoint within the leader.backendGroup that is designated as the leader.
        Structure is documented below.
        """
        return pulumi.get(self, "network_endpoint")


@pulumi.output_type
class RegionBackendServiceHaPolicyLeaderNetworkEndpoint(dict):
    def __init__(__self__, *,
                 instance: Optional[_builtins.str] = None):
        """
        :param _builtins.str instance: The name of the VM instance of the leader network endpoint. The instance must
               already be attached to the NEG specified in the haPolicy.leader.backendGroup.
        """
        if instance is not None:
            pulumi.set(__self__, "instance", instance)

    @_builtins.property
    @pulumi.getter
    def instance(self) -> Optional[_builtins.str]:
        """
        The name of the VM instance of the leader network endpoint. The instance must
        already be attached to the NEG specified in the haPolicy.leader.backendGroup.
        """
        return pulumi.get(self, "instance")


@pulumi.output_type
class RegionBackendServiceIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class RegionBackendServiceIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class RegionBackendServiceIap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oauth2ClientId":
            suggest = "oauth2_client_id"
        elif key == "oauth2ClientSecret":
            suggest = "oauth2_client_secret"
        elif key == "oauth2ClientSecretSha256":
            suggest = "oauth2_client_secret_sha256"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceIap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceIap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceIap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 oauth2_client_id: Optional[_builtins.str] = None,
                 oauth2_client_secret: Optional[_builtins.str] = None,
                 oauth2_client_secret_sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Whether the serving infrastructure will authenticate and authorize all incoming requests.
        :param _builtins.str oauth2_client_id: OAuth2 Client ID for IAP
        :param _builtins.str oauth2_client_secret: OAuth2 Client Secret for IAP
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str oauth2_client_secret_sha256: (Output)
               OAuth2 Client Secret SHA-256 for IAP
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "enabled", enabled)
        if oauth2_client_id is not None:
            pulumi.set(__self__, "oauth2_client_id", oauth2_client_id)
        if oauth2_client_secret is not None:
            pulumi.set(__self__, "oauth2_client_secret", oauth2_client_secret)
        if oauth2_client_secret_sha256 is not None:
            pulumi.set(__self__, "oauth2_client_secret_sha256", oauth2_client_secret_sha256)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether the serving infrastructure will authenticate and authorize all incoming requests.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientId")
    def oauth2_client_id(self) -> Optional[_builtins.str]:
        """
        OAuth2 Client ID for IAP
        """
        return pulumi.get(self, "oauth2_client_id")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientSecret")
    def oauth2_client_secret(self) -> Optional[_builtins.str]:
        """
        OAuth2 Client Secret for IAP
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "oauth2_client_secret")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientSecretSha256")
    def oauth2_client_secret_sha256(self) -> Optional[_builtins.str]:
        """
        (Output)
        OAuth2 Client Secret SHA-256 for IAP
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "oauth2_client_secret_sha256")


@pulumi.output_type
class RegionBackendServiceLogConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optionalFields":
            suggest = "optional_fields"
        elif key == "optionalMode":
            suggest = "optional_mode"
        elif key == "sampleRate":
            suggest = "sample_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceLogConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceLogConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceLogConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None,
                 optional_fields: Optional[Sequence[_builtins.str]] = None,
                 optional_mode: Optional[_builtins.str] = None,
                 sample_rate: Optional[_builtins.float] = None):
        """
        :param _builtins.bool enable: Whether to enable logging for the load balancer traffic served by this backend service.
        :param Sequence[_builtins.str] optional_fields: Specifies the fields to include in logging. This field can only be specified if logging is enabled for this backend service.
        :param _builtins.str optional_mode: Specifies the optional logging mode for the load balancer traffic.
               Supported values: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM.
               Possible values are: `INCLUDE_ALL_OPTIONAL`, `EXCLUDE_ALL_OPTIONAL`, `CUSTOM`.
        :param _builtins.float sample_rate: This field can only be specified if logging is enabled for this backend service. The value of
               the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
               where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
               The default value is 1.0.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if optional_fields is not None:
            pulumi.set(__self__, "optional_fields", optional_fields)
        if optional_mode is not None:
            pulumi.set(__self__, "optional_mode", optional_mode)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        Whether to enable logging for the load balancer traffic served by this backend service.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="optionalFields")
    def optional_fields(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the fields to include in logging. This field can only be specified if logging is enabled for this backend service.
        """
        return pulumi.get(self, "optional_fields")

    @_builtins.property
    @pulumi.getter(name="optionalMode")
    def optional_mode(self) -> Optional[_builtins.str]:
        """
        Specifies the optional logging mode for the load balancer traffic.
        Supported values: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM.
        Possible values are: `INCLUDE_ALL_OPTIONAL`, `EXCLUDE_ALL_OPTIONAL`, `CUSTOM`.
        """
        return pulumi.get(self, "optional_mode")

    @_builtins.property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[_builtins.float]:
        """
        This field can only be specified if logging is enabled for this backend service. The value of
        the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
        where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
        The default value is 1.0.
        """
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class RegionBackendServiceNetworkPassThroughLbTrafficPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "zonalAffinity":
            suggest = "zonal_affinity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceNetworkPassThroughLbTrafficPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceNetworkPassThroughLbTrafficPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceNetworkPassThroughLbTrafficPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 zonal_affinity: Optional['outputs.RegionBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity'] = None):
        """
        :param 'RegionBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinityArgs' zonal_affinity: When configured, new connections are load balanced across healthy backend endpoints in the local zone.
               Structure is documented below.
        """
        if zonal_affinity is not None:
            pulumi.set(__self__, "zonal_affinity", zonal_affinity)

    @_builtins.property
    @pulumi.getter(name="zonalAffinity")
    def zonal_affinity(self) -> Optional['outputs.RegionBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity']:
        """
        When configured, new connections are load balanced across healthy backend endpoints in the local zone.
        Structure is documented below.
        """
        return pulumi.get(self, "zonal_affinity")


@pulumi.output_type
class RegionBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spilloverRatio":
            suggest = "spillover_ratio"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spillover: Optional[_builtins.str] = None,
                 spillover_ratio: Optional[_builtins.float] = None):
        """
        :param _builtins.str spillover: This field indicates whether zonal affinity is enabled or not.
               Default value is `ZONAL_AFFINITY_DISABLED`.
               Possible values are: `ZONAL_AFFINITY_DISABLED`, `ZONAL_AFFINITY_SPILL_CROSS_ZONE`, `ZONAL_AFFINITY_STAY_WITHIN_ZONE`.
        :param _builtins.float spillover_ratio: The value of the field must be in [0, 1]. When the ratio of the count of healthy backend endpoints in a zone
               to the count of backend endpoints in that same zone is equal to or above this threshold, the load balancer
               distributes new connections to all healthy endpoints in the local zone only. When the ratio of the count
               of healthy backend endpoints in a zone to the count of backend endpoints in that same zone is below this
               threshold, the load balancer distributes all new connections to all healthy endpoints across all zones.
        """
        if spillover is not None:
            pulumi.set(__self__, "spillover", spillover)
        if spillover_ratio is not None:
            pulumi.set(__self__, "spillover_ratio", spillover_ratio)

    @_builtins.property
    @pulumi.getter
    def spillover(self) -> Optional[_builtins.str]:
        """
        This field indicates whether zonal affinity is enabled or not.
        Default value is `ZONAL_AFFINITY_DISABLED`.
        Possible values are: `ZONAL_AFFINITY_DISABLED`, `ZONAL_AFFINITY_SPILL_CROSS_ZONE`, `ZONAL_AFFINITY_STAY_WITHIN_ZONE`.
        """
        return pulumi.get(self, "spillover")

    @_builtins.property
    @pulumi.getter(name="spilloverRatio")
    def spillover_ratio(self) -> Optional[_builtins.float]:
        """
        The value of the field must be in [0, 1]. When the ratio of the count of healthy backend endpoints in a zone
        to the count of backend endpoints in that same zone is equal to or above this threshold, the load balancer
        distributes new connections to all healthy endpoints in the local zone only. When the ratio of the count
        of healthy backend endpoints in a zone to the count of backend endpoints in that same zone is below this
        threshold, the load balancer distributes all new connections to all healthy endpoints across all zones.
        """
        return pulumi.get(self, "spillover_ratio")


@pulumi.output_type
class RegionBackendServiceOutlierDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseEjectionTime":
            suggest = "base_ejection_time"
        elif key == "consecutiveErrors":
            suggest = "consecutive_errors"
        elif key == "consecutiveGatewayFailure":
            suggest = "consecutive_gateway_failure"
        elif key == "enforcingConsecutiveErrors":
            suggest = "enforcing_consecutive_errors"
        elif key == "enforcingConsecutiveGatewayFailure":
            suggest = "enforcing_consecutive_gateway_failure"
        elif key == "enforcingSuccessRate":
            suggest = "enforcing_success_rate"
        elif key == "maxEjectionPercent":
            suggest = "max_ejection_percent"
        elif key == "successRateMinimumHosts":
            suggest = "success_rate_minimum_hosts"
        elif key == "successRateRequestVolume":
            suggest = "success_rate_request_volume"
        elif key == "successRateStdevFactor":
            suggest = "success_rate_stdev_factor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceOutlierDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceOutlierDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceOutlierDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_ejection_time: Optional['outputs.RegionBackendServiceOutlierDetectionBaseEjectionTime'] = None,
                 consecutive_errors: Optional[_builtins.int] = None,
                 consecutive_gateway_failure: Optional[_builtins.int] = None,
                 enforcing_consecutive_errors: Optional[_builtins.int] = None,
                 enforcing_consecutive_gateway_failure: Optional[_builtins.int] = None,
                 enforcing_success_rate: Optional[_builtins.int] = None,
                 interval: Optional['outputs.RegionBackendServiceOutlierDetectionInterval'] = None,
                 max_ejection_percent: Optional[_builtins.int] = None,
                 success_rate_minimum_hosts: Optional[_builtins.int] = None,
                 success_rate_request_volume: Optional[_builtins.int] = None,
                 success_rate_stdev_factor: Optional[_builtins.int] = None):
        """
        :param 'RegionBackendServiceOutlierDetectionBaseEjectionTimeArgs' base_ejection_time: The base time that a host is ejected for. The real time is equal to the base
               time multiplied by the number of times the host has been ejected. Defaults to
               30000ms or 30s.
               Structure is documented below.
        :param _builtins.int consecutive_errors: Number of errors before a host is ejected from the connection pool. When the
               backend host is accessed over HTTP, a 5xx return code qualifies as an error.
               Defaults to 5.
        :param _builtins.int consecutive_gateway_failure: The number of consecutive gateway failures (502, 503, 504 status or connection
               errors that are mapped to one of those status codes) before a consecutive
               gateway failure ejection occurs. Defaults to 5.
        :param _builtins.int enforcing_consecutive_errors: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive 5xx. This setting can be used to disable
               ejection or to ramp it up slowly. Defaults to 100.
        :param _builtins.int enforcing_consecutive_gateway_failure: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive gateway failures. This setting can be
               used to disable ejection or to ramp it up slowly. Defaults to 0.
        :param _builtins.int enforcing_success_rate: The percentage chance that a host will be actually ejected when an outlier
               status is detected through success rate statistics. This setting can be used to
               disable ejection or to ramp it up slowly. Defaults to 100.
        :param 'RegionBackendServiceOutlierDetectionIntervalArgs' interval: Time interval between ejection sweep analysis. This can result in both new
               ejections as well as hosts being returned to service. Defaults to 10 seconds.
               Structure is documented below.
        :param _builtins.int max_ejection_percent: Maximum percentage of hosts in the load balancing pool for the backend service
               that can be ejected. Defaults to 10%.
        :param _builtins.int success_rate_minimum_hosts: The number of hosts in a cluster that must have enough request volume to detect
               success rate outliers. If the number of hosts is less than this setting, outlier
               detection via success rate statistics is not performed for any host in the
               cluster. Defaults to 5.
        :param _builtins.int success_rate_request_volume: The minimum number of total requests that must be collected in one interval (as
               defined by the interval duration above) to include this host in success rate
               based outlier detection. If the volume is lower than this setting, outlier
               detection via success rate statistics is not performed for that host. Defaults
               to 100.
        :param _builtins.int success_rate_stdev_factor: This factor is used to determine the ejection threshold for success rate outlier
               ejection. The ejection threshold is the difference between the mean success
               rate, and the product of this factor and the standard deviation of the mean
               success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
               by a thousand to get a double. That is, if the desired factor is 1.9, the
               runtime value should be 1900. Defaults to 1900.
        """
        if base_ejection_time is not None:
            pulumi.set(__self__, "base_ejection_time", base_ejection_time)
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if consecutive_gateway_failure is not None:
            pulumi.set(__self__, "consecutive_gateway_failure", consecutive_gateway_failure)
        if enforcing_consecutive_errors is not None:
            pulumi.set(__self__, "enforcing_consecutive_errors", enforcing_consecutive_errors)
        if enforcing_consecutive_gateway_failure is not None:
            pulumi.set(__self__, "enforcing_consecutive_gateway_failure", enforcing_consecutive_gateway_failure)
        if enforcing_success_rate is not None:
            pulumi.set(__self__, "enforcing_success_rate", enforcing_success_rate)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        if success_rate_minimum_hosts is not None:
            pulumi.set(__self__, "success_rate_minimum_hosts", success_rate_minimum_hosts)
        if success_rate_request_volume is not None:
            pulumi.set(__self__, "success_rate_request_volume", success_rate_request_volume)
        if success_rate_stdev_factor is not None:
            pulumi.set(__self__, "success_rate_stdev_factor", success_rate_stdev_factor)

    @_builtins.property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional['outputs.RegionBackendServiceOutlierDetectionBaseEjectionTime']:
        """
        The base time that a host is ejected for. The real time is equal to the base
        time multiplied by the number of times the host has been ejected. Defaults to
        30000ms or 30s.
        Structure is documented below.
        """
        return pulumi.get(self, "base_ejection_time")

    @_builtins.property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[_builtins.int]:
        """
        Number of errors before a host is ejected from the connection pool. When the
        backend host is accessed over HTTP, a 5xx return code qualifies as an error.
        Defaults to 5.
        """
        return pulumi.get(self, "consecutive_errors")

    @_builtins.property
    @pulumi.getter(name="consecutiveGatewayFailure")
    def consecutive_gateway_failure(self) -> Optional[_builtins.int]:
        """
        The number of consecutive gateway failures (502, 503, 504 status or connection
        errors that are mapped to one of those status codes) before a consecutive
        gateway failure ejection occurs. Defaults to 5.
        """
        return pulumi.get(self, "consecutive_gateway_failure")

    @_builtins.property
    @pulumi.getter(name="enforcingConsecutiveErrors")
    def enforcing_consecutive_errors(self) -> Optional[_builtins.int]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive 5xx. This setting can be used to disable
        ejection or to ramp it up slowly. Defaults to 100.
        """
        return pulumi.get(self, "enforcing_consecutive_errors")

    @_builtins.property
    @pulumi.getter(name="enforcingConsecutiveGatewayFailure")
    def enforcing_consecutive_gateway_failure(self) -> Optional[_builtins.int]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive gateway failures. This setting can be
        used to disable ejection or to ramp it up slowly. Defaults to 0.
        """
        return pulumi.get(self, "enforcing_consecutive_gateway_failure")

    @_builtins.property
    @pulumi.getter(name="enforcingSuccessRate")
    def enforcing_success_rate(self) -> Optional[_builtins.int]:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through success rate statistics. This setting can be used to
        disable ejection or to ramp it up slowly. Defaults to 100.
        """
        return pulumi.get(self, "enforcing_success_rate")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional['outputs.RegionBackendServiceOutlierDetectionInterval']:
        """
        Time interval between ejection sweep analysis. This can result in both new
        ejections as well as hosts being returned to service. Defaults to 10 seconds.
        Structure is documented below.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[_builtins.int]:
        """
        Maximum percentage of hosts in the load balancing pool for the backend service
        that can be ejected. Defaults to 10%.
        """
        return pulumi.get(self, "max_ejection_percent")

    @_builtins.property
    @pulumi.getter(name="successRateMinimumHosts")
    def success_rate_minimum_hosts(self) -> Optional[_builtins.int]:
        """
        The number of hosts in a cluster that must have enough request volume to detect
        success rate outliers. If the number of hosts is less than this setting, outlier
        detection via success rate statistics is not performed for any host in the
        cluster. Defaults to 5.
        """
        return pulumi.get(self, "success_rate_minimum_hosts")

    @_builtins.property
    @pulumi.getter(name="successRateRequestVolume")
    def success_rate_request_volume(self) -> Optional[_builtins.int]:
        """
        The minimum number of total requests that must be collected in one interval (as
        defined by the interval duration above) to include this host in success rate
        based outlier detection. If the volume is lower than this setting, outlier
        detection via success rate statistics is not performed for that host. Defaults
        to 100.
        """
        return pulumi.get(self, "success_rate_request_volume")

    @_builtins.property
    @pulumi.getter(name="successRateStdevFactor")
    def success_rate_stdev_factor(self) -> Optional[_builtins.int]:
        """
        This factor is used to determine the ejection threshold for success rate outlier
        ejection. The ejection threshold is the difference between the mean success
        rate, and the product of this factor and the standard deviation of the mean
        success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
        by a thousand to get a double. That is, if the desired factor is 1.9, the
        runtime value should be 1900. Defaults to 1900.
        """
        return pulumi.get(self, "success_rate_stdev_factor")


@pulumi.output_type
class RegionBackendServiceOutlierDetectionBaseEjectionTime(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionBackendServiceOutlierDetectionInterval(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 `seconds` field and a positive
               `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 `seconds` field and a positive
        `nanos` field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionBackendServiceParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the region backend service. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456.
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource manager tags to be bound to the region backend service. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class RegionBackendServiceStrongSessionAffinityCookie(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 ttl: Optional['outputs.RegionBackendServiceStrongSessionAffinityCookieTtl'] = None):
        """
        :param _builtins.str name: Name of the cookie.
        :param _builtins.str path: Path to set for the cookie.
        :param 'RegionBackendServiceStrongSessionAffinityCookieTtlArgs' ttl: Lifetime of the cookie.
               Structure is documented below.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the cookie.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to set for the cookie.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional['outputs.RegionBackendServiceStrongSessionAffinityCookieTtl']:
        """
        Lifetime of the cookie.
        Structure is documented below.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class RegionBackendServiceStrongSessionAffinityCookieTtl(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionBackendServiceSubsetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subsetSize":
            suggest = "subset_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceSubsetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceSubsetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceSubsetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy: _builtins.str,
                 subset_size: Optional[_builtins.int] = None):
        """
        :param _builtins.str policy: The algorithm used for subsetting.
               Possible values are: `CONSISTENT_HASH_SUBSETTING`.
        :param _builtins.int subset_size: The number of backends per backend group assigned to each proxy instance or each service mesh client.
               An input parameter to the CONSISTENT_HASH_SUBSETTING algorithm. Can only be set if policy is set to
               CONSISTENT_HASH_SUBSETTING. Can only be set if load balancing scheme is INTERNAL_MANAGED or INTERNAL_SELF_MANAGED.
               subsetSize is optional for Internal HTTP(S) load balancing and required for Traffic Director.
               If you do not provide this value, Cloud Load Balancing will calculate it dynamically to optimize the number
               of proxies/clients visible to each backend and vice versa.
               Must be greater than 0. If subsetSize is larger than the number of backends/endpoints, then subsetting is disabled.
        """
        pulumi.set(__self__, "policy", policy)
        if subset_size is not None:
            pulumi.set(__self__, "subset_size", subset_size)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        """
        The algorithm used for subsetting.
        Possible values are: `CONSISTENT_HASH_SUBSETTING`.
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter(name="subsetSize")
    def subset_size(self) -> Optional[_builtins.int]:
        """
        The number of backends per backend group assigned to each proxy instance or each service mesh client.
        An input parameter to the CONSISTENT_HASH_SUBSETTING algorithm. Can only be set if policy is set to
        CONSISTENT_HASH_SUBSETTING. Can only be set if load balancing scheme is INTERNAL_MANAGED or INTERNAL_SELF_MANAGED.
        subsetSize is optional for Internal HTTP(S) load balancing and required for Traffic Director.
        If you do not provide this value, Cloud Load Balancing will calculate it dynamically to optimize the number
        of proxies/clients visible to each backend and vice versa.
        Must be greater than 0. If subsetSize is larger than the number of backends/endpoints, then subsetting is disabled.
        """
        return pulumi.get(self, "subset_size")


@pulumi.output_type
class RegionBackendServiceTlsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationConfig":
            suggest = "authentication_config"
        elif key == "subjectAltNames":
            suggest = "subject_alt_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceTlsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceTlsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceTlsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_config: Optional[_builtins.str] = None,
                 sni: Optional[_builtins.str] = None,
                 subject_alt_names: Optional[Sequence['outputs.RegionBackendServiceTlsSettingsSubjectAltName']] = None):
        """
        :param _builtins.str authentication_config: Reference to the BackendAuthenticationConfig resource from the networksecurity.googleapis.com namespace.
               Can be used in authenticating TLS connections to the backend, as specified by the authenticationMode field.
               Can only be specified if authenticationMode is not NONE.
        :param _builtins.str sni: Server Name Indication - see RFC3546 section 3.1. If set, the load balancer sends this string as the SNI hostname in the
               TLS connection to the backend, and requires that this string match a Subject Alternative Name (SAN) in the backend's
               server certificate. With a Regional Internet NEG backend, if the SNI is specified here, the load balancer uses it
               regardless of whether the Regional Internet NEG is specified with FQDN or IP address and port.
        :param Sequence['RegionBackendServiceTlsSettingsSubjectAltNameArgs'] subject_alt_names: A list of Subject Alternative Names (SANs) that the Load Balancer verifies during a TLS handshake with the backend.
               When the server presents its X.509 certificate to the Load Balancer, the Load Balancer inspects the certificate's SAN field,
               and requires that at least one SAN match one of the subjectAltNames in the list. This field is limited to 5 entries.
               When both sni and subjectAltNames are specified, the load balancer matches the backend certificate's SAN only to
               subjectAltNames.
               Structure is documented below.
        """
        if authentication_config is not None:
            pulumi.set(__self__, "authentication_config", authentication_config)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @_builtins.property
    @pulumi.getter(name="authenticationConfig")
    def authentication_config(self) -> Optional[_builtins.str]:
        """
        Reference to the BackendAuthenticationConfig resource from the networksecurity.googleapis.com namespace.
        Can be used in authenticating TLS connections to the backend, as specified by the authenticationMode field.
        Can only be specified if authenticationMode is not NONE.
        """
        return pulumi.get(self, "authentication_config")

    @_builtins.property
    @pulumi.getter
    def sni(self) -> Optional[_builtins.str]:
        """
        Server Name Indication - see RFC3546 section 3.1. If set, the load balancer sends this string as the SNI hostname in the
        TLS connection to the backend, and requires that this string match a Subject Alternative Name (SAN) in the backend's
        server certificate. With a Regional Internet NEG backend, if the SNI is specified here, the load balancer uses it
        regardless of whether the Regional Internet NEG is specified with FQDN or IP address and port.
        """
        return pulumi.get(self, "sni")

    @_builtins.property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[Sequence['outputs.RegionBackendServiceTlsSettingsSubjectAltName']]:
        """
        A list of Subject Alternative Names (SANs) that the Load Balancer verifies during a TLS handshake with the backend.
        When the server presents its X.509 certificate to the Load Balancer, the Load Balancer inspects the certificate's SAN field,
        and requires that at least one SAN match one of the subjectAltNames in the list. This field is limited to 5 entries.
        When both sni and subjectAltNames are specified, the load balancer matches the backend certificate's SAN only to
        subjectAltNames.
        Structure is documented below.
        """
        return pulumi.get(self, "subject_alt_names")


@pulumi.output_type
class RegionBackendServiceTlsSettingsSubjectAltName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "uniformResourceIdentifier":
            suggest = "uniform_resource_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionBackendServiceTlsSettingsSubjectAltName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionBackendServiceTlsSettingsSubjectAltName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionBackendServiceTlsSettingsSubjectAltName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[_builtins.str] = None,
                 uniform_resource_identifier: Optional[_builtins.str] = None):
        """
        :param _builtins.str dns_name: The SAN specified as a DNS Name.
        :param _builtins.str uniform_resource_identifier: The SAN specified as a URI.
        """
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if uniform_resource_identifier is not None:
            pulumi.set(__self__, "uniform_resource_identifier", uniform_resource_identifier)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[_builtins.str]:
        """
        The SAN specified as a DNS Name.
        """
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="uniformResourceIdentifier")
    def uniform_resource_identifier(self) -> Optional[_builtins.str]:
        """
        The SAN specified as a URI.
        """
        return pulumi.get(self, "uniform_resource_identifier")


@pulumi.output_type
class RegionCommitmentLicenseResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coresPerLicense":
            suggest = "cores_per_license"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionCommitmentLicenseResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionCommitmentLicenseResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionCommitmentLicenseResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license: _builtins.str,
                 amount: Optional[_builtins.str] = None,
                 cores_per_license: Optional[_builtins.str] = None):
        """
        :param _builtins.str license: Any applicable license URI.
        :param _builtins.str amount: The number of licenses purchased.
        :param _builtins.str cores_per_license: Specifies the core range of the instance for which this license applies.
        """
        pulumi.set(__self__, "license", license)
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if cores_per_license is not None:
            pulumi.set(__self__, "cores_per_license", cores_per_license)

    @_builtins.property
    @pulumi.getter
    def license(self) -> _builtins.str:
        """
        Any applicable license URI.
        """
        return pulumi.get(self, "license")

    @_builtins.property
    @pulumi.getter
    def amount(self) -> Optional[_builtins.str]:
        """
        The number of licenses purchased.
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter(name="coresPerLicense")
    def cores_per_license(self) -> Optional[_builtins.str]:
        """
        Specifies the core range of the instance for which this license applies.
        """
        return pulumi.get(self, "cores_per_license")


@pulumi.output_type
class RegionCommitmentResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorType":
            suggest = "accelerator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionCommitmentResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionCommitmentResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionCommitmentResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_type: Optional[_builtins.str] = None,
                 amount: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str accelerator_type: Name of the accelerator type resource. Applicable only when the type is ACCELERATOR.
        :param _builtins.str amount: The amount of the resource purchased (in a type-dependent unit,
               such as bytes). For vCPUs, this can just be an integer. For memory,
               this must be provided in MB. Memory must be a multiple of 256 MB,
               with up to 6.5GB of memory per every vCPU.
        :param _builtins.str type: Type of resource for which this commitment applies.
               Possible values are VCPU, MEMORY, LOCAL_SSD, and ACCELERATOR.
        """
        if accelerator_type is not None:
            pulumi.set(__self__, "accelerator_type", accelerator_type)
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> Optional[_builtins.str]:
        """
        Name of the accelerator type resource. Applicable only when the type is ACCELERATOR.
        """
        return pulumi.get(self, "accelerator_type")

    @_builtins.property
    @pulumi.getter
    def amount(self) -> Optional[_builtins.str]:
        """
        The amount of the resource purchased (in a type-dependent unit,
        such as bytes). For vCPUs, this can just be an integer. For memory,
        this must be provided in MB. Memory must be a multiple of 256 MB,
        with up to 6.5GB of memory per every vCPU.
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of resource for which this commitment applies.
        Possible values are VCPU, MEMORY, LOCAL_SSD, and ACCELERATOR.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RegionDiskAsyncPrimaryDisk(dict):
    def __init__(__self__, *,
                 disk: _builtins.str):
        """
        :param _builtins.str disk: Primary disk for asynchronous disk replication.
        """
        pulumi.set(__self__, "disk", disk)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> _builtins.str:
        """
        Primary disk for asynchronous disk replication.
        """
        return pulumi.get(self, "disk")


@pulumi.output_type
class RegionDiskDiskEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyName":
            suggest = "kms_key_name"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionDiskDiskEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionDiskDiskEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionDiskDiskEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_name: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_name: The name of the encryption key that is stored in Google Cloud KMS.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
               customer-supplied encryption key to either encrypt or decrypt
               this resource. You can provide either the rawKey or the rsaEncryptedKey.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str sha256: (Output)
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[_builtins.str]:
        """
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_name")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
        customer-supplied encryption key to either encrypt or decrypt
        this resource. You can provide either the rawKey or the rsaEncryptedKey.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        (Output)
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class RegionDiskGuestOsFeature(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
               Possible values are: `MULTI_IP_SUBNET`, `SECURE_BOOT`, `SEV_CAPABLE`, `UEFI_COMPATIBLE`, `VIRTIO_SCSI_MULTIQUEUE`, `WINDOWS`, `GVNIC`, `SEV_LIVE_MIGRATABLE`, `SEV_SNP_CAPABLE`, `SUSPEND_RESUME_COMPATIBLE`, `TDX_CAPABLE`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
        Possible values are: `MULTI_IP_SUBNET`, `SECURE_BOOT`, `SEV_CAPABLE`, `UEFI_COMPATIBLE`, `VIRTIO_SCSI_MULTIQUEUE`, `WINDOWS`, `GVNIC`, `SEV_LIVE_MIGRATABLE`, `SEV_SNP_CAPABLE`, `SUSPEND_RESUME_COMPATIBLE`, `TDX_CAPABLE`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RegionDiskIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class RegionDiskIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class RegionDiskSourceSnapshotEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyName":
            suggest = "kms_key_name"
        elif key == "rawKey":
            suggest = "raw_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionDiskSourceSnapshotEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionDiskSourceSnapshotEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionDiskSourceSnapshotEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_name: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_name: The name of the encryption key that is stored in Google Cloud KMS.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param _builtins.str sha256: (Output)
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[_builtins.str]:
        """
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_name")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        (Output)
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class RegionHealthCheckGrpcHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcServiceName":
            suggest = "grpc_service_name"
        elif key == "portName":
            suggest = "port_name"
        elif key == "portSpecification":
            suggest = "port_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionHealthCheckGrpcHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionHealthCheckGrpcHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionHealthCheckGrpcHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grpc_service_name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_name: Optional[_builtins.str] = None,
                 port_specification: Optional[_builtins.str] = None):
        """
        :param _builtins.str grpc_service_name: The gRPC service name for the health check.
               The value of grpcServiceName has the following meanings by convention:
               * Empty serviceName means the overall status of all services at the backend.
               * Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
               The grpcServiceName can only be ASCII.
        :param _builtins.int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        if grpc_service_name is not None:
            pulumi.set(__self__, "grpc_service_name", grpc_service_name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)

    @_builtins.property
    @pulumi.getter(name="grpcServiceName")
    def grpc_service_name(self) -> Optional[_builtins.str]:
        """
        The gRPC service name for the health check.
        The value of grpcServiceName has the following meanings by convention:
        * Empty serviceName means the overall status of all services at the backend.
        * Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
        The grpcServiceName can only be ASCII.
        """
        return pulumi.get(self, "grpc_service_name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[_builtins.str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[_builtins.str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")


@pulumi.output_type
class RegionHealthCheckGrpcTlsHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcServiceName":
            suggest = "grpc_service_name"
        elif key == "portSpecification":
            suggest = "port_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionHealthCheckGrpcTlsHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionHealthCheckGrpcTlsHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionHealthCheckGrpcTlsHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grpc_service_name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_specification: Optional[_builtins.str] = None):
        """
        :param _builtins.str grpc_service_name: The gRPC service name for the health check.
               The value of grpcServiceName has the following meanings by convention:
               * Empty serviceName means the overall status of all services at the backend.
               * Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
               The grpcServiceName can only be ASCII.
        :param _builtins.int port: The port number for the health check request.
               Must be specified if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: Not supported for GRPC with TLS health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, gRPC health check follows behavior specified in the `port` field.
               Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        if grpc_service_name is not None:
            pulumi.set(__self__, "grpc_service_name", grpc_service_name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)

    @_builtins.property
    @pulumi.getter(name="grpcServiceName")
    def grpc_service_name(self) -> Optional[_builtins.str]:
        """
        The gRPC service name for the health check.
        The value of grpcServiceName has the following meanings by convention:
        * Empty serviceName means the overall status of all services at the backend.
        * Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
        The grpcServiceName can only be ASCII.
        """
        return pulumi.get(self, "grpc_service_name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port number for the health check request.
        Must be specified if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[_builtins.str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: Not supported for GRPC with TLS health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, gRPC health check follows behavior specified in the `port` field.
        Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")


@pulumi.output_type
class RegionHealthCheckHttp2HealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portName":
            suggest = "port_name"
        elif key == "portSpecification":
            suggest = "port_specification"
        elif key == "proxyHeader":
            suggest = "proxy_header"
        elif key == "requestPath":
            suggest = "request_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionHealthCheckHttp2HealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionHealthCheckHttp2HealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionHealthCheckHttp2HealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_name: Optional[_builtins.str] = None,
                 port_specification: Optional[_builtins.str] = None,
                 proxy_header: Optional[_builtins.str] = None,
                 request_path: Optional[_builtins.str] = None,
                 response: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param _builtins.int port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               
                 * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
               
                 * 'USE_NAMED_PORT': The 'portName' is used for health checking.
               
                 * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
                 network endpoint is used for health checking. For other backends, the
                 port or named port specified in the Backend Service is used for health
                 checking.
               
               If not specified, HTTP2 health check follows behavior specified in 'port' and
               'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
        :param _builtins.str request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request_path is not None:
            pulumi.set(__self__, "request_path", request_path)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[_builtins.str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[_builtins.str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:

          * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.

          * 'USE_NAMED_PORT': The 'portName' is used for health checking.

          * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
          network endpoint is used for health checking. For other backends, the
          port or named port specified in the Backend Service is used for health
          checking.

        If not specified, HTTP2 health check follows behavior specified in 'port' and
        'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[_builtins.str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[_builtins.str]:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[_builtins.str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class RegionHealthCheckHttpHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portName":
            suggest = "port_name"
        elif key == "portSpecification":
            suggest = "port_specification"
        elif key == "proxyHeader":
            suggest = "proxy_header"
        elif key == "requestPath":
            suggest = "request_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionHealthCheckHttpHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionHealthCheckHttpHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionHealthCheckHttpHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_name: Optional[_builtins.str] = None,
                 port_specification: Optional[_builtins.str] = None,
                 proxy_header: Optional[_builtins.str] = None,
                 request_path: Optional[_builtins.str] = None,
                 response: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: The value of the host header in the HTTP health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param _builtins.int port: The TCP port number for the HTTP health check request.
               The default value is 80.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTP health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are: `NONE`, `PROXY_V1`.
        :param _builtins.str request_path: The request path of the HTTP health check request.
               The default value is /.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request_path is not None:
            pulumi.set(__self__, "request_path", request_path)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The value of the host header in the HTTP health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The TCP port number for the HTTP health check request.
        The default value is 80.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[_builtins.str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[_builtins.str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTP health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[_builtins.str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are: `NONE`, `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[_builtins.str]:
        """
        The request path of the HTTP health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[_builtins.str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class RegionHealthCheckHttpsHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portName":
            suggest = "port_name"
        elif key == "portSpecification":
            suggest = "port_specification"
        elif key == "proxyHeader":
            suggest = "proxy_header"
        elif key == "requestPath":
            suggest = "request_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionHealthCheckHttpsHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionHealthCheckHttpsHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionHealthCheckHttpsHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_name: Optional[_builtins.str] = None,
                 port_specification: Optional[_builtins.str] = None,
                 proxy_header: Optional[_builtins.str] = None,
                 request_path: Optional[_builtins.str] = None,
                 response: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: The value of the host header in the HTTPS health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param _builtins.int port: The TCP port number for the HTTPS health check request.
               The default value is 443.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTPS health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are: `NONE`, `PROXY_V1`.
        :param _builtins.str request_path: The request path of the HTTPS health check request.
               The default value is /.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request_path is not None:
            pulumi.set(__self__, "request_path", request_path)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The value of the host header in the HTTPS health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The TCP port number for the HTTPS health check request.
        The default value is 443.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[_builtins.str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[_builtins.str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTPS health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[_builtins.str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are: `NONE`, `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> Optional[_builtins.str]:
        """
        The request path of the HTTPS health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[_builtins.str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class RegionHealthCheckLogConfig(dict):
    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable: Indicates whether or not to export logs. This is false by default,
               which means no health check logging will be done.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        Indicates whether or not to export logs. This is false by default,
        which means no health check logging will be done.
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class RegionHealthCheckSslHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portName":
            suggest = "port_name"
        elif key == "portSpecification":
            suggest = "port_specification"
        elif key == "proxyHeader":
            suggest = "proxy_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionHealthCheckSslHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionHealthCheckSslHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionHealthCheckSslHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: Optional[_builtins.int] = None,
                 port_name: Optional[_builtins.str] = None,
                 port_specification: Optional[_builtins.str] = None,
                 proxy_header: Optional[_builtins.str] = None,
                 request: Optional[_builtins.str] = None,
                 response: Optional[_builtins.str] = None):
        """
        :param _builtins.int port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, HTTP2 health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are: `NONE`, `PROXY_V1`.
        :param _builtins.str request: The application data to send once the SSL connection has been
               established (default value is empty). If both request and response are
               empty, the connection establishment alone will indicate health. The request
               data can only be ASCII.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[_builtins.str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[_builtins.str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, HTTP2 health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[_builtins.str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are: `NONE`, `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[_builtins.str]:
        """
        The application data to send once the SSL connection has been
        established (default value is empty). If both request and response are
        empty, the connection establishment alone will indicate health. The request
        data can only be ASCII.
        """
        return pulumi.get(self, "request")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[_builtins.str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class RegionHealthCheckTcpHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portName":
            suggest = "port_name"
        elif key == "portSpecification":
            suggest = "port_specification"
        elif key == "proxyHeader":
            suggest = "proxy_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionHealthCheckTcpHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionHealthCheckTcpHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionHealthCheckTcpHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: Optional[_builtins.int] = None,
                 port_name: Optional[_builtins.str] = None,
                 port_specification: Optional[_builtins.str] = None,
                 proxy_header: Optional[_builtins.str] = None,
                 request: Optional[_builtins.str] = None,
                 response: Optional[_builtins.str] = None):
        """
        :param _builtins.int port: The TCP port number for the TCP health check request.
               The default value is 80.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
               * `USE_NAMED_PORT`: The `portName` is used for health checking.
               * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
               network endpoint is used for health checking. For other backends, the
               port or named port specified in the Backend Service is used for health
               checking.
               If not specified, TCP health check follows behavior specified in `port` and
               `portName` fields.
               Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend.
               Default value is `NONE`.
               Possible values are: `NONE`, `PROXY_V1`.
        :param _builtins.str request: The application data to send once the TCP connection has been
               established (default value is empty). If both request and response are
               empty, the connection establishment alone will indicate health. The request
               data can only be ASCII.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_specification is not None:
            pulumi.set(__self__, "port_specification", port_specification)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The TCP port number for the TCP health check request.
        The default value is 80.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[_builtins.str]:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> Optional[_builtins.str]:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:
        * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
        * `USE_NAMED_PORT`: The `portName` is used for health checking.
        * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
        network endpoint is used for health checking. For other backends, the
        port or named port specified in the Backend Service is used for health
        checking.
        If not specified, TCP health check follows behavior specified in `port` and
        `portName` fields.
        Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[_builtins.str]:
        """
        Specifies the type of proxy header to append before sending data to the
        backend.
        Default value is `NONE`.
        Possible values are: `NONE`, `PROXY_V1`.
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[_builtins.str]:
        """
        The application data to send once the TCP connection has been
        established (default value is empty). If both request and response are
        empty, the connection establishment alone will indicate health. The request
        data can only be ASCII.
        """
        return pulumi.get(self, "request")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[_builtins.str]:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class RegionInstanceGroupManagerAllInstancesConfig(dict):
    def __init__(__self__, *,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] labels: , The label key-value pairs that you want to patch onto the instance.
               
               - - -
        :param Mapping[str, _builtins.str] metadata: , The metadata key-value pairs that you want to patch onto the instance. For more information, see [Project and instance metadata](https://cloud.google.com/compute/docs/metadata#project_and_instance_metadata).
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        , The label key-value pairs that you want to patch onto the instance.

        - - -
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        , The metadata key-value pairs that you want to patch onto the instance. For more information, see [Project and instance metadata](https://cloud.google.com/compute/docs/metadata#project_and_instance_metadata).
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class RegionInstanceGroupManagerAutoHealingPolicies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheck":
            suggest = "health_check"
        elif key == "initialDelaySec":
            suggest = "initial_delay_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerAutoHealingPolicies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerAutoHealingPolicies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerAutoHealingPolicies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 health_check: _builtins.str,
                 initial_delay_sec: _builtins.int):
        """
        :param _builtins.str health_check: The health check resource that signals autohealing.
        :param _builtins.int initial_delay_sec: The number of seconds that the managed instance group waits before
               it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        pulumi.set(__self__, "health_check", health_check)
        pulumi.set(__self__, "initial_delay_sec", initial_delay_sec)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> _builtins.str:
        """
        The health check resource that signals autohealing.
        """
        return pulumi.get(self, "health_check")

    @_builtins.property
    @pulumi.getter(name="initialDelaySec")
    def initial_delay_sec(self) -> _builtins.int:
        """
        The number of seconds that the managed instance group waits before
        it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        return pulumi.get(self, "initial_delay_sec")


@pulumi.output_type
class RegionInstanceGroupManagerInstanceFlexibilityPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceSelections":
            suggest = "instance_selections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerInstanceFlexibilityPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerInstanceFlexibilityPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerInstanceFlexibilityPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_selections: Optional[Sequence['outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection']] = None):
        """
        :param Sequence['RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionArgs'] instance_selections: Named instance selections configuring properties that the group will use when creating new VMs.
        """
        if instance_selections is not None:
            pulumi.set(__self__, "instance_selections", instance_selections)

    @_builtins.property
    @pulumi.getter(name="instanceSelections")
    def instance_selections(self) -> Optional[Sequence['outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection']]:
        """
        Named instance selections configuring properties that the group will use when creating new VMs.
        """
        return pulumi.get(self, "instance_selections")


@pulumi.output_type
class RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineTypes":
            suggest = "machine_types"
        elif key == "minCpuPlatform":
            suggest = "min_cpu_platform"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 machine_types: Sequence[_builtins.str],
                 name: _builtins.str,
                 disks: Optional[Sequence['outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk']] = None,
                 min_cpu_platform: Optional[_builtins.str] = None,
                 rank: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] machine_types: Full machine-type names, e.g. "n1-standard-16"
        :param _builtins.str name: The name of the instance group manager. Must be 1-63
               characters long and comply with
               [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
               include lowercase letters, numbers, and hyphens.
        :param Sequence['RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskArgs'] disks: List of disks to be attached to the instances created from this selection.
        :param _builtins.str min_cpu_platform: Name of the minimum CPU platform to be used by this instance selection. e.g. 'Intel Ice Lake'
        :param _builtins.int rank: Preference of this instance selection. Lower number means higher preference. MIG will first try to create a VM based on the machine-type with lowest rank and fallback to next rank based on availability. Machine types and instance selections with the same rank have the same preference.
        """
        pulumi.set(__self__, "machine_types", machine_types)
        pulumi.set(__self__, "name", name)
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if min_cpu_platform is not None:
            pulumi.set(__self__, "min_cpu_platform", min_cpu_platform)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)

    @_builtins.property
    @pulumi.getter(name="machineTypes")
    def machine_types(self) -> Sequence[_builtins.str]:
        """
        Full machine-type names, e.g. "n1-standard-16"
        """
        return pulumi.get(self, "machine_types")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance group manager. Must be 1-63
        characters long and comply with
        [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
        include lowercase letters, numbers, and hyphens.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def disks(self) -> Optional[Sequence['outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk']]:
        """
        List of disks to be attached to the instances created from this selection.
        """
        return pulumi.get(self, "disks")

    @_builtins.property
    @pulumi.getter(name="minCpuPlatform")
    def min_cpu_platform(self) -> Optional[_builtins.str]:
        """
        Name of the minimum CPU platform to be used by this instance selection. e.g. 'Intel Ice Lake'
        """
        return pulumi.get(self, "min_cpu_platform")

    @_builtins.property
    @pulumi.getter
    def rank(self) -> Optional[_builtins.int]:
        """
        Preference of this instance selection. Lower number means higher preference. MIG will first try to create a VM based on the machine-type with lowest rank and fallback to next rank based on availability. Machine types and instance selections with the same rank have the same preference.
        """
        return pulumi.get(self, "rank")


@pulumi.output_type
class RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDelete":
            suggest = "auto_delete"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "diskEncryptionKey":
            suggest = "disk_encryption_key"
        elif key == "diskName":
            suggest = "disk_name"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "guestOsFeatures":
            suggest = "guest_os_features"
        elif key == "provisionedIops":
            suggest = "provisioned_iops"
        elif key == "provisionedThroughput":
            suggest = "provisioned_throughput"
        elif key == "resourceManagerTags":
            suggest = "resource_manager_tags"
        elif key == "resourcePolicies":
            suggest = "resource_policies"
        elif key == "sourceImage":
            suggest = "source_image"
        elif key == "sourceImageEncryptionKey":
            suggest = "source_image_encryption_key"
        elif key == "sourceSnapshot":
            suggest = "source_snapshot"
        elif key == "sourceSnapshotEncryptionKey":
            suggest = "source_snapshot_encryption_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 architecture: Optional[_builtins.str] = None,
                 auto_delete: Optional[_builtins.bool] = None,
                 boot: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 disk_encryption_key: Optional['outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKey'] = None,
                 disk_name: Optional[_builtins.str] = None,
                 disk_size_gb: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 guest_os_features: Optional[Sequence[_builtins.str]] = None,
                 interface: Optional[_builtins.str] = None,
                 labels: Optional[Sequence['outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabel']] = None,
                 mode: Optional[_builtins.str] = None,
                 provisioned_iops: Optional[_builtins.int] = None,
                 provisioned_throughput: Optional[_builtins.int] = None,
                 resource_manager_tags: Optional[Sequence['outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTag']] = None,
                 resource_policies: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 source_image: Optional[_builtins.str] = None,
                 source_image_encryption_key: Optional['outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKey'] = None,
                 source_snapshot: Optional[_builtins.str] = None,
                 source_snapshot_encryption_key: Optional['outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKey'] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str architecture: , The architecture of the image. Allowed values are ARM64 or X86_64.
        :param _builtins.bool auto_delete: , Whether or not the disk should be auto-deleted. This defaults to true.
        :param _builtins.bool boot: , Indicates that this is a boot disk. This defaults to false.
        :param _builtins.str device_name: , A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance. If not specified, the server chooses a default device name to apply to this disk.
        :param 'RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKeyArgs' disk_encryption_key: , Encrypts or decrypts a disk using a customer-supplied encryption key.  Structure is documented below.
        :param _builtins.str disk_name: , Name of the disk. When not provided, this defaults to the name of the instance.
        :param _builtins.int disk_size_gb: , The size of the image in gigabytes. If not specified, it will inherit the size of its base image. For SCRATCH disks, the size must be one of 375 or 3000 GB, with a default of 375 GB.
        :param _builtins.str disk_type: , The Google Compute Engine disk type. Such as "pd-ssd", "local-ssd", "pd-balanced" or "pd-standard".
        :param Sequence[_builtins.str] guest_os_features: , A list of features to enable on the guest operating system. Applicable only for bootable images.
        :param _builtins.str interface: , Specifies the disk interface to use for attaching this disk.
        :param Sequence['RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabelArgs'] labels: , A set of key/value label pairs to assign to disks. Structure is documented below.
        :param _builtins.str mode: , The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If you are attaching or creating a boot disk, this must read-write mode.
        :param _builtins.int provisioned_iops: , Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle. For more details, see the [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk) or the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks) depending on the selected disk_type.
        :param _builtins.int provisioned_throughput: , Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
        :param Sequence['RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTagArgs'] resource_manager_tags: , A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty. Structure is documented below.
        :param _builtins.str resource_policies: , A list (short name or id) of resource policies to attach to this disk. Currently a max of 1 resource policy is supported.
        :param _builtins.str source: , The name (not self_link) of the disk (such as those managed by google_compute_disk) to attach. > Note: Either source or source_image is required when creating a new instance except for when creating a local SSD.
        :param _builtins.str source_image: , The image from which to initialize this disk. This can be one of: the image's self_link, projects/{project}/global/images/{image}, projects/{project}/global/images/family/{family}, global/images/{image}, global/images/family/{family}, family/{family}, {project}/{family}, {project}/{image}, {family}, or {image}. > Note: Either source or source_image is required when creating a new instance except for when creating a local SSD.
        :param 'RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKeyArgs' source_image_encryption_key: , The customer-supplied encryption key of the source image. Required if the source image is protected by a customer-supplied encryption key. Instance templates do not store customer-supplied encryption keys, so you cannot create disks for instances in a managed instance group if the source images are encrypted with your own keys. Structure is documented below.
        :param _builtins.str source_snapshot: , The source snapshot to create this disk. When creating a new instance, one of initializeParams.sourceSnapshot, initializeParams.sourceImage, or disks.source is required except for local SSD.
        :param 'RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKeyArgs' source_snapshot_encryption_key: , The customer-supplied encryption key of the source snapshot. Structure is documented below.
               - - -
        :param _builtins.str type: , The type of Google Compute Engine disk, can be either "SCRATCH" or "PERSISTENT".
        """
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if boot is not None:
            pulumi.set(__self__, "boot", boot)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key is not None:
            pulumi.set(__self__, "disk_encryption_key", disk_encryption_key)
        if disk_name is not None:
            pulumi.set(__self__, "disk_name", disk_name)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if guest_os_features is not None:
            pulumi.set(__self__, "guest_os_features", guest_os_features)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if provisioned_iops is not None:
            pulumi.set(__self__, "provisioned_iops", provisioned_iops)
        if provisioned_throughput is not None:
            pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)
        if resource_policies is not None:
            pulumi.set(__self__, "resource_policies", resource_policies)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if source_image is not None:
            pulumi.set(__self__, "source_image", source_image)
        if source_image_encryption_key is not None:
            pulumi.set(__self__, "source_image_encryption_key", source_image_encryption_key)
        if source_snapshot is not None:
            pulumi.set(__self__, "source_snapshot", source_snapshot)
        if source_snapshot_encryption_key is not None:
            pulumi.set(__self__, "source_snapshot_encryption_key", source_snapshot_encryption_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def architecture(self) -> Optional[_builtins.str]:
        """
        , The architecture of the image. Allowed values are ARM64 or X86_64.
        """
        return pulumi.get(self, "architecture")

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[_builtins.bool]:
        """
        , Whether or not the disk should be auto-deleted. This defaults to true.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter
    def boot(self) -> Optional[_builtins.bool]:
        """
        , Indicates that this is a boot disk. This defaults to false.
        """
        return pulumi.get(self, "boot")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        , A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance. If not specified, the server chooses a default device name to apply to this disk.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKey")
    def disk_encryption_key(self) -> Optional['outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKey']:
        """
        , Encrypts or decrypts a disk using a customer-supplied encryption key.  Structure is documented below.
        """
        return pulumi.get(self, "disk_encryption_key")

    @_builtins.property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> Optional[_builtins.str]:
        """
        , Name of the disk. When not provided, this defaults to the name of the instance.
        """
        return pulumi.get(self, "disk_name")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[_builtins.int]:
        """
        , The size of the image in gigabytes. If not specified, it will inherit the size of its base image. For SCRATCH disks, the size must be one of 375 or 3000 GB, with a default of 375 GB.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        , The Google Compute Engine disk type. Such as "pd-ssd", "local-ssd", "pd-balanced" or "pd-standard".
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="guestOsFeatures")
    def guest_os_features(self) -> Optional[Sequence[_builtins.str]]:
        """
        , A list of features to enable on the guest operating system. Applicable only for bootable images.
        """
        return pulumi.get(self, "guest_os_features")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[_builtins.str]:
        """
        , Specifies the disk interface to use for attaching this disk.
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabel']]:
        """
        , A set of key/value label pairs to assign to disks. Structure is documented below.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        , The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If you are attaching or creating a boot disk, this must read-write mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="provisionedIops")
    def provisioned_iops(self) -> Optional[_builtins.int]:
        """
        , Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle. For more details, see the [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk) or the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks) depending on the selected disk_type.
        """
        return pulumi.get(self, "provisioned_iops")

    @_builtins.property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> Optional[_builtins.int]:
        """
        , Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
        """
        return pulumi.get(self, "provisioned_throughput")

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Sequence['outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTag']]:
        """
        , A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty. Structure is documented below.
        """
        return pulumi.get(self, "resource_manager_tags")

    @_builtins.property
    @pulumi.getter(name="resourcePolicies")
    def resource_policies(self) -> Optional[_builtins.str]:
        """
        , A list (short name or id) of resource policies to attach to this disk. Currently a max of 1 resource policy is supported.
        """
        return pulumi.get(self, "resource_policies")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        , The name (not self_link) of the disk (such as those managed by google_compute_disk) to attach. > Note: Either source or source_image is required when creating a new instance except for when creating a local SSD.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> Optional[_builtins.str]:
        """
        , The image from which to initialize this disk. This can be one of: the image's self_link, projects/{project}/global/images/{image}, projects/{project}/global/images/family/{family}, global/images/{image}, global/images/family/{family}, family/{family}, {project}/{family}, {project}/{image}, {family}, or {image}. > Note: Either source or source_image is required when creating a new instance except for when creating a local SSD.
        """
        return pulumi.get(self, "source_image")

    @_builtins.property
    @pulumi.getter(name="sourceImageEncryptionKey")
    def source_image_encryption_key(self) -> Optional['outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKey']:
        """
        , The customer-supplied encryption key of the source image. Required if the source image is protected by a customer-supplied encryption key. Instance templates do not store customer-supplied encryption keys, so you cannot create disks for instances in a managed instance group if the source images are encrypted with your own keys. Structure is documented below.
        """
        return pulumi.get(self, "source_image_encryption_key")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshot")
    def source_snapshot(self) -> Optional[_builtins.str]:
        """
        , The source snapshot to create this disk. When creating a new instance, one of initializeParams.sourceSnapshot, initializeParams.sourceImage, or disks.source is required except for local SSD.
        """
        return pulumi.get(self, "source_snapshot")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshotEncryptionKey")
    def source_snapshot_encryption_key(self) -> Optional['outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKey']:
        """
        , The customer-supplied encryption key of the source snapshot. Structure is documented below.
        - - -
        """
        return pulumi.get(self, "source_snapshot_encryption_key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        , The type of Google Compute Engine disk, can be either "SCRATCH" or "PERSISTENT".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: , The self link of the encryption key that is stored in Google Cloud KMS.
               - - -
        :param _builtins.str kms_key_service_account: , The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str raw_key: , Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: , Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        , The self link of the encryption key that is stored in Google Cloud KMS.
        - - -
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        , The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        , Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        , Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabel(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: , The unique key of the label to assign to disks.
        :param _builtins.str value: , The value of the label to assign to disks.
               - - -
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        , The unique key of the label to assign to disks.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        , The value of the label to assign to disks.
        - - -
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: , The unique key of the resource manager tag to assign to disks. Keys must be in the format tagKeys/{tag_key_id}.
        :param _builtins.str value: , The value of the resource manager tag to assign to disks. Values must be in the format tagValues/456.
               - - -
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        , The unique key of the resource manager tag to assign to disks. Keys must be in the format tagKeys/{tag_key_id}.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        , The value of the resource manager tag to assign to disks. Values must be in the format tagValues/456.
        - - -
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: , The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
               - - -
        :param _builtins.str kms_key_service_account: , The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str raw_key: , Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: , Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        , The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        - - -
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        , The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        , Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        , Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: , The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
               - - -
        :param _builtins.str kms_key_service_account: , The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str raw_key: , Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: , Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        , The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        - - -
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        , The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        , Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        , Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class RegionInstanceGroupManagerInstanceLifecyclePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultActionOnFailure":
            suggest = "default_action_on_failure"
        elif key == "forceUpdateOnRepair":
            suggest = "force_update_on_repair"
        elif key == "onFailedHealthCheck":
            suggest = "on_failed_health_check"
        elif key == "onRepair":
            suggest = "on_repair"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerInstanceLifecyclePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerInstanceLifecyclePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerInstanceLifecyclePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_action_on_failure: Optional[_builtins.str] = None,
                 force_update_on_repair: Optional[_builtins.str] = None,
                 on_failed_health_check: Optional[_builtins.str] = None,
                 on_repair: Optional['outputs.RegionInstanceGroupManagerInstanceLifecyclePolicyOnRepair'] = None):
        """
        :param _builtins.str default_action_on_failure: , Specifies the action that a MIG performs on a failed VM. If the value of the `on_failed_health_check` field is `DEFAULT_ACTION`, then the same action also applies to the VMs on which your application fails a health check. Valid options are: `DO_NOTHING`, `REPAIR`. If `DO_NOTHING`, then MIG does not repair a failed VM. If `REPAIR` (default), then MIG automatically repairs a failed VM by recreating it. For more information, see about repairing VMs in a MIG.
        :param _builtins.str force_update_on_repair: , Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: `YES`, `NO`. If `YES` and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If `NO` (default), then updates are applied in accordance with the group's update policy type.
        :param _builtins.str on_failed_health_check: , Specifies the action that a MIG performs on an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid options are: `DEFAULT_ACTION`, `DO_NOTHING`, `REPAIR`. If `DEFAULT_ACTION` (default), then MIG uses the same action configured for the  `default_action_on_failure` field. If `DO_NOTHING`, then MIG does not repair unhealthy VM. If `REPAIR`, then MIG automatically repairs an unhealthy VM by recreating it. For more information, see about repairing VMs in a MIG.
        :param 'RegionInstanceGroupManagerInstanceLifecyclePolicyOnRepairArgs' on_repair: , Configuration for VM repairs in the MIG. Structure is documented below.
               - - -
        """
        if default_action_on_failure is not None:
            pulumi.set(__self__, "default_action_on_failure", default_action_on_failure)
        if force_update_on_repair is not None:
            pulumi.set(__self__, "force_update_on_repair", force_update_on_repair)
        if on_failed_health_check is not None:
            pulumi.set(__self__, "on_failed_health_check", on_failed_health_check)
        if on_repair is not None:
            pulumi.set(__self__, "on_repair", on_repair)

    @_builtins.property
    @pulumi.getter(name="defaultActionOnFailure")
    def default_action_on_failure(self) -> Optional[_builtins.str]:
        """
        , Specifies the action that a MIG performs on a failed VM. If the value of the `on_failed_health_check` field is `DEFAULT_ACTION`, then the same action also applies to the VMs on which your application fails a health check. Valid options are: `DO_NOTHING`, `REPAIR`. If `DO_NOTHING`, then MIG does not repair a failed VM. If `REPAIR` (default), then MIG automatically repairs a failed VM by recreating it. For more information, see about repairing VMs in a MIG.
        """
        return pulumi.get(self, "default_action_on_failure")

    @_builtins.property
    @pulumi.getter(name="forceUpdateOnRepair")
    def force_update_on_repair(self) -> Optional[_builtins.str]:
        """
        , Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: `YES`, `NO`. If `YES` and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If `NO` (default), then updates are applied in accordance with the group's update policy type.
        """
        return pulumi.get(self, "force_update_on_repair")

    @_builtins.property
    @pulumi.getter(name="onFailedHealthCheck")
    def on_failed_health_check(self) -> Optional[_builtins.str]:
        """
        , Specifies the action that a MIG performs on an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid options are: `DEFAULT_ACTION`, `DO_NOTHING`, `REPAIR`. If `DEFAULT_ACTION` (default), then MIG uses the same action configured for the  `default_action_on_failure` field. If `DO_NOTHING`, then MIG does not repair unhealthy VM. If `REPAIR`, then MIG automatically repairs an unhealthy VM by recreating it. For more information, see about repairing VMs in a MIG.
        """
        return pulumi.get(self, "on_failed_health_check")

    @_builtins.property
    @pulumi.getter(name="onRepair")
    def on_repair(self) -> Optional['outputs.RegionInstanceGroupManagerInstanceLifecyclePolicyOnRepair']:
        """
        , Configuration for VM repairs in the MIG. Structure is documented below.
        - - -
        """
        return pulumi.get(self, "on_repair")


@pulumi.output_type
class RegionInstanceGroupManagerInstanceLifecyclePolicyOnRepair(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowChangingZone":
            suggest = "allow_changing_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerInstanceLifecyclePolicyOnRepair. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerInstanceLifecyclePolicyOnRepair.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerInstanceLifecyclePolicyOnRepair.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_changing_zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str allow_changing_zone: , Specifies whether the MIG can change a VM's zone during a repair. If "YES", MIG can select a different zone for the VM during a repair. Else if "NO", MIG cannot change a VM's zone during a repair. The default value of allow_changing_zone is "NO".
               
               - - -
               <a name="nested_instance_flexibility_policy"></a>The `instance_flexibility_policy` block supports:
        """
        if allow_changing_zone is not None:
            pulumi.set(__self__, "allow_changing_zone", allow_changing_zone)

    @_builtins.property
    @pulumi.getter(name="allowChangingZone")
    def allow_changing_zone(self) -> Optional[_builtins.str]:
        """
        , Specifies whether the MIG can change a VM's zone during a repair. If "YES", MIG can select a different zone for the VM during a repair. Else if "NO", MIG cannot change a VM's zone during a repair. The default value of allow_changing_zone is "NO".

        - - -
        <a name="nested_instance_flexibility_policy"></a>The `instance_flexibility_policy` block supports:
        """
        return pulumi.get(self, "allow_changing_zone")


@pulumi.output_type
class RegionInstanceGroupManagerNamedPort(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str name: The name of the port.
        :param _builtins.int port: The port number.
               - - -
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the port.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port number.
        - - -
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class RegionInstanceGroupManagerParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to bind to the managed instance group. The tags are key-value pairs. Keys must be in the format tagKeys/123 and values in the format tagValues/456. For more information, see [Manage tags for resources](https://cloud.google.com/compute/docs/tag-resources)
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource manager tags to bind to the managed instance group. The tags are key-value pairs. Keys must be in the format tagKeys/123 and values in the format tagValues/456. For more information, see [Manage tags for resources](https://cloud.google.com/compute/docs/tag-resources)
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class RegionInstanceGroupManagerStandbyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialDelaySec":
            suggest = "initial_delay_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerStandbyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerStandbyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerStandbyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_delay_sec: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.int initial_delay_sec: Specifies the number of seconds that the MIG should wait to suspend or stop a VM after that VM was created. The initial delay gives the initialization script the time to prepare your VM for a quick scale out. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
        :param _builtins.str mode: Defines how a MIG resumes or starts VMs from a standby pool when the group scales out. Valid options are: `MANUAL`, `SCALE_OUT_POOL`. If `MANUAL`(default), you have full control over which VMs are stopped and suspended in the MIG. If `SCALE_OUT_POOL`, the MIG uses the VMs from the standby pools to accelerate the scale out by resuming or starting them and then automatically replenishes the standby pool with new VMs to maintain the target sizes.
               - - -
        """
        if initial_delay_sec is not None:
            pulumi.set(__self__, "initial_delay_sec", initial_delay_sec)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="initialDelaySec")
    def initial_delay_sec(self) -> Optional[_builtins.int]:
        """
        Specifies the number of seconds that the MIG should wait to suspend or stop a VM after that VM was created. The initial delay gives the initialization script the time to prepare your VM for a quick scale out. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
        """
        return pulumi.get(self, "initial_delay_sec")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Defines how a MIG resumes or starts VMs from a standby pool when the group scales out. Valid options are: `MANUAL`, `SCALE_OUT_POOL`. If `MANUAL`(default), you have full control over which VMs are stopped and suspended in the MIG. If `SCALE_OUT_POOL`, the MIG uses the VMs from the standby pools to accelerate the scale out by resuming or starting them and then automatically replenishes the standby pool with new VMs to maintain the target sizes.
        - - -
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class RegionInstanceGroupManagerStatefulDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteRule":
            suggest = "delete_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerStatefulDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerStatefulDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerStatefulDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 delete_rule: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: , The device name of the disk to be attached.
        :param _builtins.str delete_rule: , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the disk when the VM is deleted, but do not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
        """
        pulumi.set(__self__, "device_name", device_name)
        if delete_rule is not None:
            pulumi.set(__self__, "delete_rule", delete_rule)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        , The device name of the disk to be attached.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[_builtins.str]:
        """
        , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the disk when the VM is deleted, but do not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
        """
        return pulumi.get(self, "delete_rule")


@pulumi.output_type
class RegionInstanceGroupManagerStatefulExternalIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteRule":
            suggest = "delete_rule"
        elif key == "interfaceName":
            suggest = "interface_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerStatefulExternalIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerStatefulExternalIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerStatefulExternalIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_rule: Optional[_builtins.str] = None,
                 interface_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str delete_rule: , A value that prescribes what should happen to the external ip when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the ip when the VM is deleted, but do not delete the ip. `ON_PERMANENT_INSTANCE_DELETION` will delete the external ip when the VM is permanently deleted from the instance group.
        :param _builtins.str interface_name: , The network interface name of the external Ip. Possible value: `nic0`.
        """
        if delete_rule is not None:
            pulumi.set(__self__, "delete_rule", delete_rule)
        if interface_name is not None:
            pulumi.set(__self__, "interface_name", interface_name)

    @_builtins.property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[_builtins.str]:
        """
        , A value that prescribes what should happen to the external ip when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the ip when the VM is deleted, but do not delete the ip. `ON_PERMANENT_INSTANCE_DELETION` will delete the external ip when the VM is permanently deleted from the instance group.
        """
        return pulumi.get(self, "delete_rule")

    @_builtins.property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> Optional[_builtins.str]:
        """
        , The network interface name of the external Ip. Possible value: `nic0`.
        """
        return pulumi.get(self, "interface_name")


@pulumi.output_type
class RegionInstanceGroupManagerStatefulInternalIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteRule":
            suggest = "delete_rule"
        elif key == "interfaceName":
            suggest = "interface_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerStatefulInternalIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerStatefulInternalIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerStatefulInternalIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_rule: Optional[_builtins.str] = None,
                 interface_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str delete_rule: , A value that prescribes what should happen to the internal ip when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the ip when the VM is deleted, but do not delete the ip. `ON_PERMANENT_INSTANCE_DELETION` will delete the internal ip when the VM is permanently deleted from the instance group.
        :param _builtins.str interface_name: , The network interface name of the internal Ip. Possible value: `nic0`.
        """
        if delete_rule is not None:
            pulumi.set(__self__, "delete_rule", delete_rule)
        if interface_name is not None:
            pulumi.set(__self__, "interface_name", interface_name)

    @_builtins.property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[_builtins.str]:
        """
        , A value that prescribes what should happen to the internal ip when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the ip when the VM is deleted, but do not delete the ip. `ON_PERMANENT_INSTANCE_DELETION` will delete the internal ip when the VM is permanently deleted from the instance group.
        """
        return pulumi.get(self, "delete_rule")

    @_builtins.property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> Optional[_builtins.str]:
        """
        , The network interface name of the internal Ip. Possible value: `nic0`.
        """
        return pulumi.get(self, "interface_name")


@pulumi.output_type
class RegionInstanceGroupManagerStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allInstancesConfigs":
            suggest = "all_instances_configs"
        elif key == "isStable":
            suggest = "is_stable"
        elif key == "versionTargets":
            suggest = "version_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_instances_configs: Optional[Sequence['outputs.RegionInstanceGroupManagerStatusAllInstancesConfig']] = None,
                 is_stable: Optional[_builtins.bool] = None,
                 statefuls: Optional[Sequence['outputs.RegionInstanceGroupManagerStatusStateful']] = None,
                 version_targets: Optional[Sequence['outputs.RegionInstanceGroupManagerStatusVersionTarget']] = None):
        """
        :param Sequence['RegionInstanceGroupManagerStatusAllInstancesConfigArgs'] all_instances_configs: Properties to set on all instances in the group. After setting
               allInstancesConfig on the group, you must update the group's instances to
               apply the configuration.
        :param _builtins.bool is_stable: A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
        :param Sequence['RegionInstanceGroupManagerStatusStatefulArgs'] statefuls: Stateful status of the given Instance Group Manager.
        :param Sequence['RegionInstanceGroupManagerStatusVersionTargetArgs'] version_targets: A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
        """
        if all_instances_configs is not None:
            pulumi.set(__self__, "all_instances_configs", all_instances_configs)
        if is_stable is not None:
            pulumi.set(__self__, "is_stable", is_stable)
        if statefuls is not None:
            pulumi.set(__self__, "statefuls", statefuls)
        if version_targets is not None:
            pulumi.set(__self__, "version_targets", version_targets)

    @_builtins.property
    @pulumi.getter(name="allInstancesConfigs")
    def all_instances_configs(self) -> Optional[Sequence['outputs.RegionInstanceGroupManagerStatusAllInstancesConfig']]:
        """
        Properties to set on all instances in the group. After setting
        allInstancesConfig on the group, you must update the group's instances to
        apply the configuration.
        """
        return pulumi.get(self, "all_instances_configs")

    @_builtins.property
    @pulumi.getter(name="isStable")
    def is_stable(self) -> Optional[_builtins.bool]:
        """
        A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
        """
        return pulumi.get(self, "is_stable")

    @_builtins.property
    @pulumi.getter
    def statefuls(self) -> Optional[Sequence['outputs.RegionInstanceGroupManagerStatusStateful']]:
        """
        Stateful status of the given Instance Group Manager.
        """
        return pulumi.get(self, "statefuls")

    @_builtins.property
    @pulumi.getter(name="versionTargets")
    def version_targets(self) -> Optional[Sequence['outputs.RegionInstanceGroupManagerStatusVersionTarget']]:
        """
        A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
        """
        return pulumi.get(self, "version_targets")


@pulumi.output_type
class RegionInstanceGroupManagerStatusAllInstancesConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentRevision":
            suggest = "current_revision"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerStatusAllInstancesConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerStatusAllInstancesConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerStatusAllInstancesConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_revision: Optional[_builtins.str] = None,
                 effective: Optional[_builtins.bool] = None):
        """
        :param _builtins.str current_revision: Current all-instances configuration revision. This value is in RFC3339 text format.
        :param _builtins.bool effective: A bit indicating whether this configuration has been applied to all managed instances in the group.
        """
        if current_revision is not None:
            pulumi.set(__self__, "current_revision", current_revision)
        if effective is not None:
            pulumi.set(__self__, "effective", effective)

    @_builtins.property
    @pulumi.getter(name="currentRevision")
    def current_revision(self) -> Optional[_builtins.str]:
        """
        Current all-instances configuration revision. This value is in RFC3339 text format.
        """
        return pulumi.get(self, "current_revision")

    @_builtins.property
    @pulumi.getter
    def effective(self) -> Optional[_builtins.bool]:
        """
        A bit indicating whether this configuration has been applied to all managed instances in the group.
        """
        return pulumi.get(self, "effective")


@pulumi.output_type
class RegionInstanceGroupManagerStatusStateful(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hasStatefulConfig":
            suggest = "has_stateful_config"
        elif key == "perInstanceConfigs":
            suggest = "per_instance_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerStatusStateful. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerStatusStateful.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerStatusStateful.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 has_stateful_config: Optional[_builtins.bool] = None,
                 per_instance_configs: Optional[Sequence['outputs.RegionInstanceGroupManagerStatusStatefulPerInstanceConfig']] = None):
        """
        :param _builtins.bool has_stateful_config: A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
        :param Sequence['RegionInstanceGroupManagerStatusStatefulPerInstanceConfigArgs'] per_instance_configs: Status of per-instance configs on the instances.
        """
        if has_stateful_config is not None:
            pulumi.set(__self__, "has_stateful_config", has_stateful_config)
        if per_instance_configs is not None:
            pulumi.set(__self__, "per_instance_configs", per_instance_configs)

    @_builtins.property
    @pulumi.getter(name="hasStatefulConfig")
    def has_stateful_config(self) -> Optional[_builtins.bool]:
        """
        A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
        """
        return pulumi.get(self, "has_stateful_config")

    @_builtins.property
    @pulumi.getter(name="perInstanceConfigs")
    def per_instance_configs(self) -> Optional[Sequence['outputs.RegionInstanceGroupManagerStatusStatefulPerInstanceConfig']]:
        """
        Status of per-instance configs on the instances.
        """
        return pulumi.get(self, "per_instance_configs")


@pulumi.output_type
class RegionInstanceGroupManagerStatusStatefulPerInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allEffective":
            suggest = "all_effective"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerStatusStatefulPerInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerStatusStatefulPerInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerStatusStatefulPerInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_effective: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool all_effective: A bit indicating if all of the group's per-instance configs (listed in the output of a listPerInstanceConfigs API call) have status `EFFECTIVE` or there are no per-instance-configs.
        """
        if all_effective is not None:
            pulumi.set(__self__, "all_effective", all_effective)

    @_builtins.property
    @pulumi.getter(name="allEffective")
    def all_effective(self) -> Optional[_builtins.bool]:
        """
        A bit indicating if all of the group's per-instance configs (listed in the output of a listPerInstanceConfigs API call) have status `EFFECTIVE` or there are no per-instance-configs.
        """
        return pulumi.get(self, "all_effective")


@pulumi.output_type
class RegionInstanceGroupManagerStatusVersionTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isReached":
            suggest = "is_reached"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerStatusVersionTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerStatusVersionTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerStatusVersionTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_reached: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_reached: A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
        """
        if is_reached is not None:
            pulumi.set(__self__, "is_reached", is_reached)

    @_builtins.property
    @pulumi.getter(name="isReached")
    def is_reached(self) -> Optional[_builtins.bool]:
        """
        A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
        """
        return pulumi.get(self, "is_reached")


@pulumi.output_type
class RegionInstanceGroupManagerUpdatePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimalAction":
            suggest = "minimal_action"
        elif key == "instanceRedistributionType":
            suggest = "instance_redistribution_type"
        elif key == "maxSurgeFixed":
            suggest = "max_surge_fixed"
        elif key == "maxSurgePercent":
            suggest = "max_surge_percent"
        elif key == "maxUnavailableFixed":
            suggest = "max_unavailable_fixed"
        elif key == "maxUnavailablePercent":
            suggest = "max_unavailable_percent"
        elif key == "minReadySec":
            suggest = "min_ready_sec"
        elif key == "mostDisruptiveAllowedAction":
            suggest = "most_disruptive_allowed_action"
        elif key == "replacementMethod":
            suggest = "replacement_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerUpdatePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerUpdatePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerUpdatePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimal_action: _builtins.str,
                 type: _builtins.str,
                 instance_redistribution_type: Optional[_builtins.str] = None,
                 max_surge_fixed: Optional[_builtins.int] = None,
                 max_surge_percent: Optional[_builtins.int] = None,
                 max_unavailable_fixed: Optional[_builtins.int] = None,
                 max_unavailable_percent: Optional[_builtins.int] = None,
                 min_ready_sec: Optional[_builtins.int] = None,
                 most_disruptive_allowed_action: Optional[_builtins.str] = None,
                 replacement_method: Optional[_builtins.str] = None):
        """
        :param _builtins.str minimal_action: Minimal action to be taken on an instance. You can specify either `NONE` to forbid any actions, `REFRESH` to update without stopping instances, `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `REFRESH`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        :param _builtins.str type: The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        :param _builtins.str instance_redistribution_type: The instance redistribution policy for regional managed instance groups. Valid values are: `"PROACTIVE"`, `"NONE"`. If `PROACTIVE` (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If `NONE`, proactive redistribution is disabled.
        :param _builtins.int max_surge_fixed: , Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with `max_surge_percent`. Both cannot be 0.
        :param _builtins.int max_surge_percent: , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with `max_surge_fixed`.
        :param _builtins.int max_unavailable_fixed: , Specifies a fixed number of VM instances. This must be a positive integer.
        :param _builtins.int max_unavailable_percent: , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%..
        :param _builtins.int min_ready_sec: , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
        :param _builtins.str most_disruptive_allowed_action: Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
        :param _builtins.str replacement_method: , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
               - - -
        """
        pulumi.set(__self__, "minimal_action", minimal_action)
        pulumi.set(__self__, "type", type)
        if instance_redistribution_type is not None:
            pulumi.set(__self__, "instance_redistribution_type", instance_redistribution_type)
        if max_surge_fixed is not None:
            pulumi.set(__self__, "max_surge_fixed", max_surge_fixed)
        if max_surge_percent is not None:
            pulumi.set(__self__, "max_surge_percent", max_surge_percent)
        if max_unavailable_fixed is not None:
            pulumi.set(__self__, "max_unavailable_fixed", max_unavailable_fixed)
        if max_unavailable_percent is not None:
            pulumi.set(__self__, "max_unavailable_percent", max_unavailable_percent)
        if min_ready_sec is not None:
            pulumi.set(__self__, "min_ready_sec", min_ready_sec)
        if most_disruptive_allowed_action is not None:
            pulumi.set(__self__, "most_disruptive_allowed_action", most_disruptive_allowed_action)
        if replacement_method is not None:
            pulumi.set(__self__, "replacement_method", replacement_method)

    @_builtins.property
    @pulumi.getter(name="minimalAction")
    def minimal_action(self) -> _builtins.str:
        """
        Minimal action to be taken on an instance. You can specify either `NONE` to forbid any actions, `REFRESH` to update without stopping instances, `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `REFRESH`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        """
        return pulumi.get(self, "minimal_action")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="instanceRedistributionType")
    def instance_redistribution_type(self) -> Optional[_builtins.str]:
        """
        The instance redistribution policy for regional managed instance groups. Valid values are: `"PROACTIVE"`, `"NONE"`. If `PROACTIVE` (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If `NONE`, proactive redistribution is disabled.
        """
        return pulumi.get(self, "instance_redistribution_type")

    @_builtins.property
    @pulumi.getter(name="maxSurgeFixed")
    def max_surge_fixed(self) -> Optional[_builtins.int]:
        """
        , Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with `max_surge_percent`. Both cannot be 0.
        """
        return pulumi.get(self, "max_surge_fixed")

    @_builtins.property
    @pulumi.getter(name="maxSurgePercent")
    def max_surge_percent(self) -> Optional[_builtins.int]:
        """
        , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with `max_surge_fixed`.
        """
        return pulumi.get(self, "max_surge_percent")

    @_builtins.property
    @pulumi.getter(name="maxUnavailableFixed")
    def max_unavailable_fixed(self) -> Optional[_builtins.int]:
        """
        , Specifies a fixed number of VM instances. This must be a positive integer.
        """
        return pulumi.get(self, "max_unavailable_fixed")

    @_builtins.property
    @pulumi.getter(name="maxUnavailablePercent")
    def max_unavailable_percent(self) -> Optional[_builtins.int]:
        """
        , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%..
        """
        return pulumi.get(self, "max_unavailable_percent")

    @_builtins.property
    @pulumi.getter(name="minReadySec")
    def min_ready_sec(self) -> Optional[_builtins.int]:
        """
        , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
        """
        return pulumi.get(self, "min_ready_sec")

    @_builtins.property
    @pulumi.getter(name="mostDisruptiveAllowedAction")
    def most_disruptive_allowed_action(self) -> Optional[_builtins.str]:
        """
        Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
        """
        return pulumi.get(self, "most_disruptive_allowed_action")

    @_builtins.property
    @pulumi.getter(name="replacementMethod")
    def replacement_method(self) -> Optional[_builtins.str]:
        """
        , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
        - - -
        """
        return pulumi.get(self, "replacement_method")


@pulumi.output_type
class RegionInstanceGroupManagerVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceTemplate":
            suggest = "instance_template"
        elif key == "targetSize":
            suggest = "target_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceGroupManagerVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceGroupManagerVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceGroupManagerVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_template: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 target_size: Optional['outputs.RegionInstanceGroupManagerVersionTargetSize'] = None):
        """
        :param _builtins.str instance_template: The full URL to an instance template from which all new instances of this version will be created.
        :param _builtins.str name: Version name.
        :param 'RegionInstanceGroupManagerVersionTargetSizeArgs' target_size: The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
               
               > Exactly one `version` you specify must not have a `target_size` specified. During a rolling update, the instance group manager will fulfill the `target_size`
               constraints of every other `version`, and any remaining instances will be provisioned with the version where `target_size` is unset.
        """
        pulumi.set(__self__, "instance_template", instance_template)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_size is not None:
            pulumi.set(__self__, "target_size", target_size)

    @_builtins.property
    @pulumi.getter(name="instanceTemplate")
    def instance_template(self) -> _builtins.str:
        """
        The full URL to an instance template from which all new instances of this version will be created.
        """
        return pulumi.get(self, "instance_template")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Version name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="targetSize")
    def target_size(self) -> Optional['outputs.RegionInstanceGroupManagerVersionTargetSize']:
        """
        The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.

        > Exactly one `version` you specify must not have a `target_size` specified. During a rolling update, the instance group manager will fulfill the `target_size`
        constraints of every other `version`, and any remaining instances will be provisioned with the version where `target_size` is unset.
        """
        return pulumi.get(self, "target_size")


@pulumi.output_type
class RegionInstanceGroupManagerVersionTargetSize(dict):
    def __init__(__self__, *,
                 fixed: Optional[_builtins.int] = None,
                 percent: Optional[_builtins.int] = None):
        """
        :param _builtins.int fixed: , The number of instances which are managed for this version. Conflicts with `percent`.
        :param _builtins.int percent: , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
               Note that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,
               one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
        """
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter
    def fixed(self) -> Optional[_builtins.int]:
        """
        , The number of instances which are managed for this version. Conflicts with `percent`.
        """
        return pulumi.get(self, "fixed")

    @_builtins.property
    @pulumi.getter
    def percent(self) -> Optional[_builtins.int]:
        """
        , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
        Note that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,
        one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class RegionInstanceTemplateAdvancedMachineFeatures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableNestedVirtualization":
            suggest = "enable_nested_virtualization"
        elif key == "enableUefiNetworking":
            suggest = "enable_uefi_networking"
        elif key == "performanceMonitoringUnit":
            suggest = "performance_monitoring_unit"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"
        elif key == "turboMode":
            suggest = "turbo_mode"
        elif key == "visibleCoreCount":
            suggest = "visible_core_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateAdvancedMachineFeatures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateAdvancedMachineFeatures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateAdvancedMachineFeatures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_nested_virtualization: Optional[_builtins.bool] = None,
                 enable_uefi_networking: Optional[_builtins.bool] = None,
                 performance_monitoring_unit: Optional[_builtins.str] = None,
                 threads_per_core: Optional[_builtins.int] = None,
                 turbo_mode: Optional[_builtins.str] = None,
                 visible_core_count: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enable_nested_virtualization: Defines whether the instance should have nested virtualization enabled. Defaults to false.
        :param _builtins.bool enable_uefi_networking: Whether to enable UEFI networking for instance creation.
        :param _builtins.str performance_monitoring_unit: [The PMU](https://cloud.google.com/compute/docs/pmu-overview) is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are `STANDARD`, `ENHANCED`, and `ARCHITECTURAL`.
        :param _builtins.int threads_per_core: The number of threads per physical core. To disable [simultaneous multithreading (SMT)](https://cloud.google.com/compute/docs/instances/disabling-smt) set this to 1.
        :param _builtins.str turbo_mode: Turbo frequency mode to use for the instance. Supported modes are currently either `ALL_CORE_MAX` or unset (default).
        :param _builtins.int visible_core_count: The number of physical cores to expose to an instance. [visible cores info (VC)](https://cloud.google.com/compute/docs/instances/customize-visible-cores).
        """
        if enable_nested_virtualization is not None:
            pulumi.set(__self__, "enable_nested_virtualization", enable_nested_virtualization)
        if enable_uefi_networking is not None:
            pulumi.set(__self__, "enable_uefi_networking", enable_uefi_networking)
        if performance_monitoring_unit is not None:
            pulumi.set(__self__, "performance_monitoring_unit", performance_monitoring_unit)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)
        if turbo_mode is not None:
            pulumi.set(__self__, "turbo_mode", turbo_mode)
        if visible_core_count is not None:
            pulumi.set(__self__, "visible_core_count", visible_core_count)

    @_builtins.property
    @pulumi.getter(name="enableNestedVirtualization")
    def enable_nested_virtualization(self) -> Optional[_builtins.bool]:
        """
        Defines whether the instance should have nested virtualization enabled. Defaults to false.
        """
        return pulumi.get(self, "enable_nested_virtualization")

    @_builtins.property
    @pulumi.getter(name="enableUefiNetworking")
    def enable_uefi_networking(self) -> Optional[_builtins.bool]:
        """
        Whether to enable UEFI networking for instance creation.
        """
        return pulumi.get(self, "enable_uefi_networking")

    @_builtins.property
    @pulumi.getter(name="performanceMonitoringUnit")
    def performance_monitoring_unit(self) -> Optional[_builtins.str]:
        """
        [The PMU](https://cloud.google.com/compute/docs/pmu-overview) is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are `STANDARD`, `ENHANCED`, and `ARCHITECTURAL`.
        """
        return pulumi.get(self, "performance_monitoring_unit")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[_builtins.int]:
        """
        The number of threads per physical core. To disable [simultaneous multithreading (SMT)](https://cloud.google.com/compute/docs/instances/disabling-smt) set this to 1.
        """
        return pulumi.get(self, "threads_per_core")

    @_builtins.property
    @pulumi.getter(name="turboMode")
    def turbo_mode(self) -> Optional[_builtins.str]:
        """
        Turbo frequency mode to use for the instance. Supported modes are currently either `ALL_CORE_MAX` or unset (default).
        """
        return pulumi.get(self, "turbo_mode")

    @_builtins.property
    @pulumi.getter(name="visibleCoreCount")
    def visible_core_count(self) -> Optional[_builtins.int]:
        """
        The number of physical cores to expose to an instance. [visible cores info (VC)](https://cloud.google.com/compute/docs/instances/customize-visible-cores).
        """
        return pulumi.get(self, "visible_core_count")


@pulumi.output_type
class RegionInstanceTemplateConfidentialInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confidentialInstanceType":
            suggest = "confidential_instance_type"
        elif key == "enableConfidentialCompute":
            suggest = "enable_confidential_compute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateConfidentialInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateConfidentialInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateConfidentialInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 confidential_instance_type: Optional[_builtins.str] = None,
                 enable_confidential_compute: Optional[_builtins.bool] = None):
        """
        :param _builtins.str confidential_instance_type: Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: `SEV`, `SEV_SNP`, `TDX`. `on_host_maintenance` can be set to MIGRATE if `confidential_instance_type` is set to `SEV` and `min_cpu_platform` is set to `"AMD Milan"`. Otherwise, `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM. If `SEV_SNP`, currently `min_cpu_platform` has to be set to `"AMD Milan"` or this will fail to create the VM.
        :param _builtins.bool enable_confidential_compute: Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, `on_host_maintenance` can be set to MIGRATE if `min_cpu_platform` is set to `"AMD Milan"`. Otherwise, `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.
        """
        if confidential_instance_type is not None:
            pulumi.set(__self__, "confidential_instance_type", confidential_instance_type)
        if enable_confidential_compute is not None:
            pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @_builtins.property
    @pulumi.getter(name="confidentialInstanceType")
    def confidential_instance_type(self) -> Optional[_builtins.str]:
        """
        Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: `SEV`, `SEV_SNP`, `TDX`. `on_host_maintenance` can be set to MIGRATE if `confidential_instance_type` is set to `SEV` and `min_cpu_platform` is set to `"AMD Milan"`. Otherwise, `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM. If `SEV_SNP`, currently `min_cpu_platform` has to be set to `"AMD Milan"` or this will fail to create the VM.
        """
        return pulumi.get(self, "confidential_instance_type")

    @_builtins.property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> Optional[_builtins.bool]:
        """
        Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, `on_host_maintenance` can be set to MIGRATE if `min_cpu_platform` is set to `"AMD Milan"`. Otherwise, `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.
        """
        return pulumi.get(self, "enable_confidential_compute")


@pulumi.output_type
class RegionInstanceTemplateDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDelete":
            suggest = "auto_delete"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "diskEncryptionKey":
            suggest = "disk_encryption_key"
        elif key == "diskName":
            suggest = "disk_name"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "guestOsFeatures":
            suggest = "guest_os_features"
        elif key == "provisionedIops":
            suggest = "provisioned_iops"
        elif key == "provisionedThroughput":
            suggest = "provisioned_throughput"
        elif key == "resourceManagerTags":
            suggest = "resource_manager_tags"
        elif key == "resourcePolicies":
            suggest = "resource_policies"
        elif key == "sourceImage":
            suggest = "source_image"
        elif key == "sourceImageEncryptionKey":
            suggest = "source_image_encryption_key"
        elif key == "sourceSnapshot":
            suggest = "source_snapshot"
        elif key == "sourceSnapshotEncryptionKey":
            suggest = "source_snapshot_encryption_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 architecture: Optional[_builtins.str] = None,
                 auto_delete: Optional[_builtins.bool] = None,
                 boot: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 disk_encryption_key: Optional['outputs.RegionInstanceTemplateDiskDiskEncryptionKey'] = None,
                 disk_name: Optional[_builtins.str] = None,
                 disk_size_gb: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 guest_os_features: Optional[Sequence[_builtins.str]] = None,
                 interface: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 mode: Optional[_builtins.str] = None,
                 provisioned_iops: Optional[_builtins.int] = None,
                 provisioned_throughput: Optional[_builtins.int] = None,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None,
                 resource_policies: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 source_image: Optional[_builtins.str] = None,
                 source_image_encryption_key: Optional['outputs.RegionInstanceTemplateDiskSourceImageEncryptionKey'] = None,
                 source_snapshot: Optional[_builtins.str] = None,
                 source_snapshot_encryption_key: Optional['outputs.RegionInstanceTemplateDiskSourceSnapshotEncryptionKey'] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str architecture: The architecture of the attached disk. Valid values are `ARM64` or `x86_64`.
        :param _builtins.bool auto_delete: Whether or not the disk should be auto-deleted.
               This defaults to true.
        :param _builtins.bool boot: Indicates that this is a boot disk.
        :param _builtins.str device_name: A unique device name that is reflected into the
               /dev/  tree of a Linux operating system running within the instance. If not
               specified, the server chooses a default device name to apply to this disk.
        :param 'RegionInstanceTemplateDiskDiskEncryptionKeyArgs' disk_encryption_key: Encrypts or decrypts a disk using a customer-supplied encryption key.
               
               If you are creating a new disk, this field encrypts the new disk using an encryption key that you provide. If you are attaching an existing disk that is already encrypted, this field decrypts the disk using the customer-supplied encryption key.
               
               If you encrypt a disk using a customer-supplied key, you must provide the same key again when you attempt to use this resource at a later time. For example, you must provide the key when you create a snapshot or an image from the disk or when you attach the disk to a virtual machine instance.
               
               If you do not provide an encryption key, then the disk will be encrypted using an automatically generated key and you do not need to provide a key to use the disk later.
               
               Instance templates do not store customer-supplied encryption keys, so you cannot use your own keys to encrypt disks in a managed instance group. Structure documented below.
        :param _builtins.str disk_name: Name of the disk. When not provided, this defaults
               to the name of the instance.
        :param _builtins.int disk_size_gb: The size of the image in gigabytes. If not
               specified, it will inherit the size of its base image. For SCRATCH disks,
               the size must be exactly 375GB.
        :param _builtins.str disk_type: The GCE disk type. Such as `"pd-ssd"`, `"local-ssd"`,
               `"pd-balanced"` or `"pd-standard"`.
        :param Sequence[_builtins.str] guest_os_features: A list of features to enable on the guest operating system. Applicable only for bootable images. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
        :param _builtins.str interface: Specifies the disk interface to use for attaching this disk,
               which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
               and the request will fail if you attempt to attach a persistent disk in any other format
               than SCSI. Local SSDs can use either NVME or SCSI.
        :param Mapping[str, _builtins.str] labels: A set of ket/value label pairs to assign to disk created from
               this template
        :param _builtins.str mode: The mode in which to attach this disk, either READ_WRITE
               or READ_ONLY. If you are attaching or creating a boot disk, this must
               read-write mode.
        :param _builtins.int provisioned_iops: Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle. For more details, see the [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk) or the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks) depending on the selected disk_type.
        :param _builtins.int provisioned_throughput: Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
        :param Mapping[str, _builtins.str] resource_manager_tags: A set of key/value resource manager tag pairs to bind to this disk. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456.
        :param _builtins.str resource_policies: - A list (short name or id) of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
        :param _builtins.str source: The name (**not self_link**)
               of the disk (such as those managed by `compute.Disk`) to attach.
               > **Note:** Either `source`, `source_image`, or `source_snapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param _builtins.str source_image: The image from which to
               initialize this disk. This can be one of: the image's `self_link`,
               `projects/{project}/global/images/{image}`,
               `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
               `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
               `{project}/{image}`, `{family}`, or `{image}`.
               > **Note:** Either `source`, `source_image`, or `source_snapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param 'RegionInstanceTemplateDiskSourceImageEncryptionKeyArgs' source_image_encryption_key: The customer-supplied encryption
               key of the source image. Required if the source image is protected by a
               customer-supplied encryption key.
               
               Instance templates do not store customer-supplied encryption keys, so you
               cannot create disks for instances in a managed instance group if the source
               images are encrypted with your own keys. Structure
               documented below.
        :param _builtins.str source_snapshot: The source snapshot to create this disk.
               > **Note:** Either `source`, `source_image`, or `source_snapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param 'RegionInstanceTemplateDiskSourceSnapshotEncryptionKeyArgs' source_snapshot_encryption_key: The customer-supplied encryption
               key of the source snapshot. Structure
               documented below.
        :param _builtins.str type: The type of GCE disk, can be either `"SCRATCH"` or
               `"PERSISTENT"`.
        """
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if boot is not None:
            pulumi.set(__self__, "boot", boot)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_encryption_key is not None:
            pulumi.set(__self__, "disk_encryption_key", disk_encryption_key)
        if disk_name is not None:
            pulumi.set(__self__, "disk_name", disk_name)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if guest_os_features is not None:
            pulumi.set(__self__, "guest_os_features", guest_os_features)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if provisioned_iops is not None:
            pulumi.set(__self__, "provisioned_iops", provisioned_iops)
        if provisioned_throughput is not None:
            pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)
        if resource_policies is not None:
            pulumi.set(__self__, "resource_policies", resource_policies)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if source_image is not None:
            pulumi.set(__self__, "source_image", source_image)
        if source_image_encryption_key is not None:
            pulumi.set(__self__, "source_image_encryption_key", source_image_encryption_key)
        if source_snapshot is not None:
            pulumi.set(__self__, "source_snapshot", source_snapshot)
        if source_snapshot_encryption_key is not None:
            pulumi.set(__self__, "source_snapshot_encryption_key", source_snapshot_encryption_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def architecture(self) -> Optional[_builtins.str]:
        """
        The architecture of the attached disk. Valid values are `ARM64` or `x86_64`.
        """
        return pulumi.get(self, "architecture")

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[_builtins.bool]:
        """
        Whether or not the disk should be auto-deleted.
        This defaults to true.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter
    def boot(self) -> Optional[_builtins.bool]:
        """
        Indicates that this is a boot disk.
        """
        return pulumi.get(self, "boot")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        A unique device name that is reflected into the
        /dev/  tree of a Linux operating system running within the instance. If not
        specified, the server chooses a default device name to apply to this disk.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKey")
    def disk_encryption_key(self) -> Optional['outputs.RegionInstanceTemplateDiskDiskEncryptionKey']:
        """
        Encrypts or decrypts a disk using a customer-supplied encryption key.

        If you are creating a new disk, this field encrypts the new disk using an encryption key that you provide. If you are attaching an existing disk that is already encrypted, this field decrypts the disk using the customer-supplied encryption key.

        If you encrypt a disk using a customer-supplied key, you must provide the same key again when you attempt to use this resource at a later time. For example, you must provide the key when you create a snapshot or an image from the disk or when you attach the disk to a virtual machine instance.

        If you do not provide an encryption key, then the disk will be encrypted using an automatically generated key and you do not need to provide a key to use the disk later.

        Instance templates do not store customer-supplied encryption keys, so you cannot use your own keys to encrypt disks in a managed instance group. Structure documented below.
        """
        return pulumi.get(self, "disk_encryption_key")

    @_builtins.property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> Optional[_builtins.str]:
        """
        Name of the disk. When not provided, this defaults
        to the name of the instance.
        """
        return pulumi.get(self, "disk_name")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[_builtins.int]:
        """
        The size of the image in gigabytes. If not
        specified, it will inherit the size of its base image. For SCRATCH disks,
        the size must be exactly 375GB.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        The GCE disk type. Such as `"pd-ssd"`, `"local-ssd"`,
        `"pd-balanced"` or `"pd-standard"`.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="guestOsFeatures")
    def guest_os_features(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of features to enable on the guest operating system. Applicable only for bootable images. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
        """
        return pulumi.get(self, "guest_os_features")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[_builtins.str]:
        """
        Specifies the disk interface to use for attaching this disk,
        which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
        and the request will fail if you attempt to attach a persistent disk in any other format
        than SCSI. Local SSDs can use either NVME or SCSI.
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of ket/value label pairs to assign to disk created from
        this template
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The mode in which to attach this disk, either READ_WRITE
        or READ_ONLY. If you are attaching or creating a boot disk, this must
        read-write mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="provisionedIops")
    def provisioned_iops(self) -> Optional[_builtins.int]:
        """
        Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle. For more details, see the [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk) or the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks) depending on the selected disk_type.
        """
        return pulumi.get(self, "provisioned_iops")

    @_builtins.property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> Optional[_builtins.int]:
        """
        Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
        """
        return pulumi.get(self, "provisioned_throughput")

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key/value resource manager tag pairs to bind to this disk. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")

    @_builtins.property
    @pulumi.getter(name="resourcePolicies")
    def resource_policies(self) -> Optional[_builtins.str]:
        """
        - A list (short name or id) of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
        """
        return pulumi.get(self, "resource_policies")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The name (**not self_link**)
        of the disk (such as those managed by `compute.Disk`) to attach.
        > **Note:** Either `source`, `source_image`, or `source_snapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> Optional[_builtins.str]:
        """
        The image from which to
        initialize this disk. This can be one of: the image's `self_link`,
        `projects/{project}/global/images/{image}`,
        `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
        `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
        `{project}/{image}`, `{family}`, or `{image}`.
        > **Note:** Either `source`, `source_image`, or `source_snapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        return pulumi.get(self, "source_image")

    @_builtins.property
    @pulumi.getter(name="sourceImageEncryptionKey")
    def source_image_encryption_key(self) -> Optional['outputs.RegionInstanceTemplateDiskSourceImageEncryptionKey']:
        """
        The customer-supplied encryption
        key of the source image. Required if the source image is protected by a
        customer-supplied encryption key.

        Instance templates do not store customer-supplied encryption keys, so you
        cannot create disks for instances in a managed instance group if the source
        images are encrypted with your own keys. Structure
        documented below.
        """
        return pulumi.get(self, "source_image_encryption_key")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshot")
    def source_snapshot(self) -> Optional[_builtins.str]:
        """
        The source snapshot to create this disk.
        > **Note:** Either `source`, `source_image`, or `source_snapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        return pulumi.get(self, "source_snapshot")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshotEncryptionKey")
    def source_snapshot_encryption_key(self) -> Optional['outputs.RegionInstanceTemplateDiskSourceSnapshotEncryptionKey']:
        """
        The customer-supplied encryption
        key of the source snapshot. Structure
        documented below.
        """
        return pulumi.get(self, "source_snapshot_encryption_key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of GCE disk, can be either `"SCRATCH"` or
        `"PERSISTENT"`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RegionInstanceTemplateDiskDiskEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateDiskDiskEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateDiskDiskEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateDiskDiskEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS
        :param _builtins.str kms_key_service_account: The service account being used for the
               encryption request for the given KMS key. If absent, the Compute Engine
               default service account is used.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key that is stored in Google Cloud KMS
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the
        encryption request for the given KMS key. If absent, the Compute Engine
        default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")


@pulumi.output_type
class RegionInstanceTemplateDiskSourceImageEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateDiskSourceImageEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateDiskSourceImageEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateDiskSourceImageEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is
               stored in Google Cloud KMS. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        :param _builtins.str kms_key_service_account: The service account being used for the
               encryption request for the given KMS key. If absent, the Compute Engine
               default service account is used.
        :param _builtins.str raw_key: A 256-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
               encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               to decrypt the given image. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt the given image. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key that is
        stored in Google Cloud KMS. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the
        encryption request for the given KMS key. If absent, the Compute Engine
        default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        A 256-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
        encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        to decrypt the given image. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt the given image. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class RegionInstanceTemplateDiskSourceSnapshotEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateDiskSourceSnapshotEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateDiskSourceSnapshotEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateDiskSourceSnapshotEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is
               stored in Google Cloud KMS. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        :param _builtins.str kms_key_service_account: The service account being used for the
               encryption request for the given KMS key. If absent, the Compute Engine
               default service account is used.
        :param _builtins.str raw_key: A 256-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
               encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               to decrypt this snapshot. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
               (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt this snapshot. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
               may be set.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The self link of the encryption key that is
        stored in Google Cloud KMS. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account being used for the
        encryption request for the given KMS key. If absent, the Compute Engine
        default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        A 256-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
        encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        to decrypt this snapshot. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
        (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt this snapshot. Only one of `kms_key_self_link`, `rsa_encrypted_key` and `raw_key`
        may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class RegionInstanceTemplateGuestAccelerator(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int count: The number of the guest accelerator cards exposed to this instance.
        :param _builtins.str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RegionInstanceTemplateNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConfigs":
            suggest = "access_configs"
        elif key == "aliasIpRanges":
            suggest = "alias_ip_ranges"
        elif key == "internalIpv6PrefixLength":
            suggest = "internal_ipv6_prefix_length"
        elif key == "ipv6AccessConfigs":
            suggest = "ipv6_access_configs"
        elif key == "ipv6AccessType":
            suggest = "ipv6_access_type"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "networkIp":
            suggest = "network_ip"
        elif key == "nicType":
            suggest = "nic_type"
        elif key == "queueCount":
            suggest = "queue_count"
        elif key == "stackType":
            suggest = "stack_type"
        elif key == "subnetworkProject":
            suggest = "subnetwork_project"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_configs: Optional[Sequence['outputs.RegionInstanceTemplateNetworkInterfaceAccessConfig']] = None,
                 alias_ip_ranges: Optional[Sequence['outputs.RegionInstanceTemplateNetworkInterfaceAliasIpRange']] = None,
                 internal_ipv6_prefix_length: Optional[_builtins.int] = None,
                 ipv6_access_configs: Optional[Sequence['outputs.RegionInstanceTemplateNetworkInterfaceIpv6AccessConfig']] = None,
                 ipv6_access_type: Optional[_builtins.str] = None,
                 ipv6_address: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None,
                 network_ip: Optional[_builtins.str] = None,
                 nic_type: Optional[_builtins.str] = None,
                 queue_count: Optional[_builtins.int] = None,
                 stack_type: Optional[_builtins.str] = None,
                 subnetwork: Optional[_builtins.str] = None,
                 subnetwork_project: Optional[_builtins.str] = None):
        """
        :param Sequence['RegionInstanceTemplateNetworkInterfaceAliasIpRangeArgs'] alias_ip_ranges: An
               array of alias IP ranges for this network interface. Can only be specified for network
               interfaces on subnet-mode networks. Structure documented below.
        :param _builtins.int internal_ipv6_prefix_length: The prefix length of the primary internal IPv6 range.
        :param Sequence['RegionInstanceTemplateNetworkInterfaceIpv6AccessConfigArgs'] ipv6_access_configs: An array of IPv6 access configurations for this interface.
               Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
               specified, then this instance will have no external IPv6 Internet access. Structure documented below.
        :param _builtins.str ipv6_access_type: One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
        :param _builtins.str ipv6_address: An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        :param _builtins.str name: The name of the network_interface.
        :param _builtins.str network: The name or self_link of the network to attach this interface to.
               Use `network` attribute for Legacy or Auto subnetted networks and
               `subnetwork` for custom subnetted networks.
        :param _builtins.str network_ip: The private IP address to assign to the instance. If
               empty, the address will be automatically assigned.
        :param _builtins.str nic_type: The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET, MRDMA, IRDMA.
        :param _builtins.int queue_count: The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        :param _builtins.str stack_type: The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6, IPV6_ONLY or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
        :param _builtins.str subnetwork: the name of the subnetwork to attach this interface
               to. The subnetwork must exist in the same `region` this instance will be
               created in. Either `network` or `subnetwork` must be provided.
        :param _builtins.str subnetwork_project: The ID of the project in which the subnetwork belongs.
               If it is not provided, the provider project is used.
        """
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if alias_ip_ranges is not None:
            pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        if internal_ipv6_prefix_length is not None:
            pulumi.set(__self__, "internal_ipv6_prefix_length", internal_ipv6_prefix_length)
        if ipv6_access_configs is not None:
            pulumi.set(__self__, "ipv6_access_configs", ipv6_access_configs)
        if ipv6_access_type is not None:
            pulumi.set(__self__, "ipv6_access_type", ipv6_access_type)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_ip is not None:
            pulumi.set(__self__, "network_ip", network_ip)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if queue_count is not None:
            pulumi.set(__self__, "queue_count", queue_count)
        if stack_type is not None:
            pulumi.set(__self__, "stack_type", stack_type)
        if subnetwork is not None:
            pulumi.set(__self__, "subnetwork", subnetwork)
        if subnetwork_project is not None:
            pulumi.set(__self__, "subnetwork_project", subnetwork_project)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.RegionInstanceTemplateNetworkInterfaceAccessConfig']]:
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[Sequence['outputs.RegionInstanceTemplateNetworkInterfaceAliasIpRange']]:
        """
        An
        array of alias IP ranges for this network interface. Can only be specified for network
        interfaces on subnet-mode networks. Structure documented below.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="internalIpv6PrefixLength")
    def internal_ipv6_prefix_length(self) -> Optional[_builtins.int]:
        """
        The prefix length of the primary internal IPv6 range.
        """
        return pulumi.get(self, "internal_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessConfigs")
    def ipv6_access_configs(self) -> Optional[Sequence['outputs.RegionInstanceTemplateNetworkInterfaceIpv6AccessConfig']]:
        """
        An array of IPv6 access configurations for this interface.
        Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
        specified, then this instance will have no external IPv6 Internet access. Structure documented below.
        """
        return pulumi.get(self, "ipv6_access_configs")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessType")
    def ipv6_access_type(self) -> Optional[_builtins.str]:
        """
        One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
        """
        return pulumi.get(self, "ipv6_access_type")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[_builtins.str]:
        """
        An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the network_interface.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        The name or self_link of the network to attach this interface to.
        Use `network` attribute for Legacy or Auto subnetted networks and
        `subnetwork` for custom subnetted networks.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> Optional[_builtins.str]:
        """
        The private IP address to assign to the instance. If
        empty, the address will be automatically assigned.
        """
        return pulumi.get(self, "network_ip")

    @_builtins.property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[_builtins.str]:
        """
        The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET, MRDMA, IRDMA.
        """
        return pulumi.get(self, "nic_type")

    @_builtins.property
    @pulumi.getter(name="queueCount")
    def queue_count(self) -> Optional[_builtins.int]:
        """
        The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        """
        return pulumi.get(self, "queue_count")

    @_builtins.property
    @pulumi.getter(name="stackType")
    def stack_type(self) -> Optional[_builtins.str]:
        """
        The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6, IPV6_ONLY or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
        """
        return pulumi.get(self, "stack_type")

    @_builtins.property
    @pulumi.getter
    def subnetwork(self) -> Optional[_builtins.str]:
        """
        the name of the subnetwork to attach this interface
        to. The subnetwork must exist in the same `region` this instance will be
        created in. Either `network` or `subnetwork` must be provided.
        """
        return pulumi.get(self, "subnetwork")

    @_builtins.property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> Optional[_builtins.str]:
        """
        The ID of the project in which the subnetwork belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "subnetwork_project")


@pulumi.output_type
class RegionInstanceTemplateNetworkInterfaceAccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "natIp":
            suggest = "nat_ip"
        elif key == "networkTier":
            suggest = "network_tier"
        elif key == "publicPtrDomainName":
            suggest = "public_ptr_domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateNetworkInterfaceAccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateNetworkInterfaceAccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateNetworkInterfaceAccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nat_ip: Optional[_builtins.str] = None,
                 network_tier: Optional[_builtins.str] = None,
                 public_ptr_domain_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str nat_ip: The IP address that will be 1:1 mapped to the instance's
               network ip. If not given, one will be generated.
        :param _builtins.str network_tier: The service-level to be provided for IPv6 traffic when the
               subnet has an external subnet. Only PREMIUM and STANDARD tier is valid for IPv6.
        :param _builtins.str public_ptr_domain_name: The DNS domain name for the public PTR record.The DNS domain name for the public PTR record.
        """
        if nat_ip is not None:
            pulumi.set(__self__, "nat_ip", nat_ip)
        if network_tier is not None:
            pulumi.set(__self__, "network_tier", network_tier)
        if public_ptr_domain_name is not None:
            pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)

    @_builtins.property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> Optional[_builtins.str]:
        """
        The IP address that will be 1:1 mapped to the instance's
        network ip. If not given, one will be generated.
        """
        return pulumi.get(self, "nat_ip")

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> Optional[_builtins.str]:
        """
        The service-level to be provided for IPv6 traffic when the
        subnet has an external subnet. Only PREMIUM and STANDARD tier is valid for IPv6.
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[_builtins.str]:
        """
        The DNS domain name for the public PTR record.The DNS domain name for the public PTR record.
        """
        return pulumi.get(self, "public_ptr_domain_name")


@pulumi.output_type
class RegionInstanceTemplateNetworkInterfaceAliasIpRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipCidrRange":
            suggest = "ip_cidr_range"
        elif key == "subnetworkRangeName":
            suggest = "subnetwork_range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateNetworkInterfaceAliasIpRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateNetworkInterfaceAliasIpRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateNetworkInterfaceAliasIpRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_cidr_range: _builtins.str,
                 subnetwork_range_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip_cidr_range: The IP CIDR range represented by this alias IP range. This IP CIDR range
               must belong to the specified subnetwork and cannot contain IP addresses reserved by
               system or used by other network interfaces. At the time of writing only a
               netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
               error.
        :param _builtins.str subnetwork_range_name: The subnetwork secondary range name specifying
               the secondary range from which to allocate the IP CIDR range for this alias IP
               range. If left unspecified, the primary range of the subnetwork will be used.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        if subnetwork_range_name is not None:
            pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @_builtins.property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> _builtins.str:
        """
        The IP CIDR range represented by this alias IP range. This IP CIDR range
        must belong to the specified subnetwork and cannot contain IP addresses reserved by
        system or used by other network interfaces. At the time of writing only a
        netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
        error.
        """
        return pulumi.get(self, "ip_cidr_range")

    @_builtins.property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> Optional[_builtins.str]:
        """
        The subnetwork secondary range name specifying
        the secondary range from which to allocate the IP CIDR range for this alias IP
        range. If left unspecified, the primary range of the subnetwork will be used.
        """
        return pulumi.get(self, "subnetwork_range_name")


@pulumi.output_type
class RegionInstanceTemplateNetworkInterfaceIpv6AccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkTier":
            suggest = "network_tier"
        elif key == "externalIpv6":
            suggest = "external_ipv6"
        elif key == "externalIpv6PrefixLength":
            suggest = "external_ipv6_prefix_length"
        elif key == "publicPtrDomainName":
            suggest = "public_ptr_domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateNetworkInterfaceIpv6AccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateNetworkInterfaceIpv6AccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateNetworkInterfaceIpv6AccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_tier: _builtins.str,
                 external_ipv6: Optional[_builtins.str] = None,
                 external_ipv6_prefix_length: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 public_ptr_domain_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str network_tier: The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
        :param _builtins.str external_ipv6: The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. The field is output only, an IPv6 address from a subnetwork associated with the instance will be allocated dynamically.
        :param _builtins.str external_ipv6_prefix_length: The prefix length of the external IPv6 range.
        :param _builtins.str name: The name of this access configuration.
        :param _builtins.str public_ptr_domain_name: The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
        """
        pulumi.set(__self__, "network_tier", network_tier)
        if external_ipv6 is not None:
            pulumi.set(__self__, "external_ipv6", external_ipv6)
        if external_ipv6_prefix_length is not None:
            pulumi.set(__self__, "external_ipv6_prefix_length", external_ipv6_prefix_length)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ptr_domain_name is not None:
            pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> _builtins.str:
        """
        The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="externalIpv6")
    def external_ipv6(self) -> Optional[_builtins.str]:
        """
        The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. The field is output only, an IPv6 address from a subnetwork associated with the instance will be allocated dynamically.
        """
        return pulumi.get(self, "external_ipv6")

    @_builtins.property
    @pulumi.getter(name="externalIpv6PrefixLength")
    def external_ipv6_prefix_length(self) -> Optional[_builtins.str]:
        """
        The prefix length of the external IPv6 range.
        """
        return pulumi.get(self, "external_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of this access configuration.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> Optional[_builtins.str]:
        """
        The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
        """
        return pulumi.get(self, "public_ptr_domain_name")


@pulumi.output_type
class RegionInstanceTemplateNetworkPerformanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalEgressBandwidthTier":
            suggest = "total_egress_bandwidth_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateNetworkPerformanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateNetworkPerformanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateNetworkPerformanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_egress_bandwidth_tier: _builtins.str):
        """
        :param _builtins.str total_egress_bandwidth_tier: The egress bandwidth tier to enable. Possible values: TIER_1, DEFAULT
        """
        pulumi.set(__self__, "total_egress_bandwidth_tier", total_egress_bandwidth_tier)

    @_builtins.property
    @pulumi.getter(name="totalEgressBandwidthTier")
    def total_egress_bandwidth_tier(self) -> _builtins.str:
        """
        The egress bandwidth tier to enable. Possible values: TIER_1, DEFAULT
        """
        return pulumi.get(self, "total_egress_bandwidth_tier")


@pulumi.output_type
class RegionInstanceTemplateReservationAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "specificReservation":
            suggest = "specific_reservation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateReservationAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateReservationAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateReservationAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 specific_reservation: Optional['outputs.RegionInstanceTemplateReservationAffinitySpecificReservation'] = None):
        """
        :param _builtins.str type: The type of reservation from which this instance can consume resources.
        :param 'RegionInstanceTemplateReservationAffinitySpecificReservationArgs' specific_reservation: Specifies the label selector for the reservation to use..
               Structure is documented below.
        """
        pulumi.set(__self__, "type", type)
        if specific_reservation is not None:
            pulumi.set(__self__, "specific_reservation", specific_reservation)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of reservation from which this instance can consume resources.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="specificReservation")
    def specific_reservation(self) -> Optional['outputs.RegionInstanceTemplateReservationAffinitySpecificReservation']:
        """
        Specifies the label selector for the reservation to use..
        Structure is documented below.
        """
        return pulumi.get(self, "specific_reservation")


@pulumi.output_type
class RegionInstanceTemplateReservationAffinitySpecificReservation(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
        :param Sequence[_builtins.str] values: Corresponds to the label values of a reservation resource.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Corresponds to the label values of a reservation resource.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RegionInstanceTemplateScheduling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automaticRestart":
            suggest = "automatic_restart"
        elif key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "gracefulShutdown":
            suggest = "graceful_shutdown"
        elif key == "hostErrorTimeoutSeconds":
            suggest = "host_error_timeout_seconds"
        elif key == "instanceTerminationAction":
            suggest = "instance_termination_action"
        elif key == "localSsdRecoveryTimeouts":
            suggest = "local_ssd_recovery_timeouts"
        elif key == "maintenanceInterval":
            suggest = "maintenance_interval"
        elif key == "maxRunDuration":
            suggest = "max_run_duration"
        elif key == "minNodeCpus":
            suggest = "min_node_cpus"
        elif key == "nodeAffinities":
            suggest = "node_affinities"
        elif key == "onHostMaintenance":
            suggest = "on_host_maintenance"
        elif key == "onInstanceStopAction":
            suggest = "on_instance_stop_action"
        elif key == "provisioningModel":
            suggest = "provisioning_model"
        elif key == "skipGuestOsShutdown":
            suggest = "skip_guest_os_shutdown"
        elif key == "terminationTime":
            suggest = "termination_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateScheduling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateScheduling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateScheduling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automatic_restart: Optional[_builtins.bool] = None,
                 availability_domain: Optional[_builtins.int] = None,
                 graceful_shutdown: Optional['outputs.RegionInstanceTemplateSchedulingGracefulShutdown'] = None,
                 host_error_timeout_seconds: Optional[_builtins.int] = None,
                 instance_termination_action: Optional[_builtins.str] = None,
                 local_ssd_recovery_timeouts: Optional[Sequence['outputs.RegionInstanceTemplateSchedulingLocalSsdRecoveryTimeout']] = None,
                 maintenance_interval: Optional[_builtins.str] = None,
                 max_run_duration: Optional['outputs.RegionInstanceTemplateSchedulingMaxRunDuration'] = None,
                 min_node_cpus: Optional[_builtins.int] = None,
                 node_affinities: Optional[Sequence['outputs.RegionInstanceTemplateSchedulingNodeAffinity']] = None,
                 on_host_maintenance: Optional[_builtins.str] = None,
                 on_instance_stop_action: Optional['outputs.RegionInstanceTemplateSchedulingOnInstanceStopAction'] = None,
                 preemptible: Optional[_builtins.bool] = None,
                 provisioning_model: Optional[_builtins.str] = None,
                 skip_guest_os_shutdown: Optional[_builtins.bool] = None,
                 termination_time: Optional[_builtins.str] = None):
        """
        :param _builtins.bool automatic_restart: Specifies whether the instance should be
               automatically restarted if it is terminated by Compute Engine (not
               terminated by a user). This defaults to true.
        :param _builtins.int availability_domain: Specifies the availability domain to place the instance in. The value must be a number between 1 and the number of availability domains specified in the spread placement policy attached to the instance.
        :param 'RegionInstanceTemplateSchedulingGracefulShutdownArgs' graceful_shutdown: Settings for the instance to perform a graceful shutdown.
        :param _builtins.int host_error_timeout_seconds: Specifies the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
        :param _builtins.str instance_termination_action: Describe the type of termination action for `SPOT` VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
        :param Sequence['RegionInstanceTemplateSchedulingLocalSsdRecoveryTimeoutArgs'] local_ssd_recovery_timeouts: Specifies the maximum amount of time a Local Ssd Vm should wait while
                 recovery of the Local Ssd state is attempted. Its value should be in
                 between 0 and 168 hours with hour granularity and the default value being 1
                 hour.
        :param _builtins.str maintenance_interval: Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
        :param 'RegionInstanceTemplateSchedulingMaxRunDurationArgs' max_run_duration: The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in `instance_termination_action`. Only support `DELETE` `instance_termination_action` at this point. Structure is documented below.
        :param _builtins.int min_node_cpus: Minimum number of cpus for the instance.
        :param Sequence['RegionInstanceTemplateSchedulingNodeAffinityArgs'] node_affinities: Specifies node affinities or anti-affinities
               to determine which sole-tenant nodes your instances and managed instance
               groups will use as host systems. Read more on sole-tenant node creation
               [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
               Structure documented below.
        :param _builtins.str on_host_maintenance: Defines the maintenance behavior for this
               instance.
        :param 'RegionInstanceTemplateSchedulingOnInstanceStopActionArgs' on_instance_stop_action: Defines the behaviour for instances with the instance_termination_action.
        :param _builtins.bool preemptible: Allows instance to be preempted. This defaults to
               false. Read more on this
               [here](https://cloud.google.com/compute/docs/instances/preemptible).
        :param _builtins.str provisioning_model: Describe the type of preemptible VM. This field accepts the value `STANDARD` or `SPOT`. If the value is `STANDARD`, there will be no discount. If this   is set to `SPOT`,
               `preemptible` should be `true` and `automatic_restart` should be
               `false`. For more info about
               `SPOT`, read [here](https://cloud.google.com/compute/docs/instances/spot)
        :param _builtins.bool skip_guest_os_shutdown: Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        :param _builtins.str termination_time: Specifies the timestamp, when the instance will be terminated, in RFC3339 text format. If specified, the instance termination action will be performed at the termination time.
        """
        if automatic_restart is not None:
            pulumi.set(__self__, "automatic_restart", automatic_restart)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if graceful_shutdown is not None:
            pulumi.set(__self__, "graceful_shutdown", graceful_shutdown)
        if host_error_timeout_seconds is not None:
            pulumi.set(__self__, "host_error_timeout_seconds", host_error_timeout_seconds)
        if instance_termination_action is not None:
            pulumi.set(__self__, "instance_termination_action", instance_termination_action)
        if local_ssd_recovery_timeouts is not None:
            pulumi.set(__self__, "local_ssd_recovery_timeouts", local_ssd_recovery_timeouts)
        if maintenance_interval is not None:
            pulumi.set(__self__, "maintenance_interval", maintenance_interval)
        if max_run_duration is not None:
            pulumi.set(__self__, "max_run_duration", max_run_duration)
        if min_node_cpus is not None:
            pulumi.set(__self__, "min_node_cpus", min_node_cpus)
        if node_affinities is not None:
            pulumi.set(__self__, "node_affinities", node_affinities)
        if on_host_maintenance is not None:
            pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        if on_instance_stop_action is not None:
            pulumi.set(__self__, "on_instance_stop_action", on_instance_stop_action)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)
        if provisioning_model is not None:
            pulumi.set(__self__, "provisioning_model", provisioning_model)
        if skip_guest_os_shutdown is not None:
            pulumi.set(__self__, "skip_guest_os_shutdown", skip_guest_os_shutdown)
        if termination_time is not None:
            pulumi.set(__self__, "termination_time", termination_time)

    @_builtins.property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the instance should be
        automatically restarted if it is terminated by Compute Engine (not
        terminated by a user). This defaults to true.
        """
        return pulumi.get(self, "automatic_restart")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[_builtins.int]:
        """
        Specifies the availability domain to place the instance in. The value must be a number between 1 and the number of availability domains specified in the spread placement policy attached to the instance.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="gracefulShutdown")
    def graceful_shutdown(self) -> Optional['outputs.RegionInstanceTemplateSchedulingGracefulShutdown']:
        """
        Settings for the instance to perform a graceful shutdown.
        """
        return pulumi.get(self, "graceful_shutdown")

    @_builtins.property
    @pulumi.getter(name="hostErrorTimeoutSeconds")
    def host_error_timeout_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
        """
        return pulumi.get(self, "host_error_timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="instanceTerminationAction")
    def instance_termination_action(self) -> Optional[_builtins.str]:
        """
        Describe the type of termination action for `SPOT` VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
        """
        return pulumi.get(self, "instance_termination_action")

    @_builtins.property
    @pulumi.getter(name="localSsdRecoveryTimeouts")
    def local_ssd_recovery_timeouts(self) -> Optional[Sequence['outputs.RegionInstanceTemplateSchedulingLocalSsdRecoveryTimeout']]:
        """
        Specifies the maximum amount of time a Local Ssd Vm should wait while
          recovery of the Local Ssd state is attempted. Its value should be in
          between 0 and 168 hours with hour granularity and the default value being 1
          hour.
        """
        return pulumi.get(self, "local_ssd_recovery_timeouts")

    @_builtins.property
    @pulumi.getter(name="maintenanceInterval")
    def maintenance_interval(self) -> Optional[_builtins.str]:
        """
        Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
        """
        return pulumi.get(self, "maintenance_interval")

    @_builtins.property
    @pulumi.getter(name="maxRunDuration")
    def max_run_duration(self) -> Optional['outputs.RegionInstanceTemplateSchedulingMaxRunDuration']:
        """
        The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in `instance_termination_action`. Only support `DELETE` `instance_termination_action` at this point. Structure is documented below.
        """
        return pulumi.get(self, "max_run_duration")

    @_builtins.property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> Optional[_builtins.int]:
        """
        Minimum number of cpus for the instance.
        """
        return pulumi.get(self, "min_node_cpus")

    @_builtins.property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Optional[Sequence['outputs.RegionInstanceTemplateSchedulingNodeAffinity']]:
        """
        Specifies node affinities or anti-affinities
        to determine which sole-tenant nodes your instances and managed instance
        groups will use as host systems. Read more on sole-tenant node creation
        [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
        Structure documented below.
        """
        return pulumi.get(self, "node_affinities")

    @_builtins.property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> Optional[_builtins.str]:
        """
        Defines the maintenance behavior for this
        instance.
        """
        return pulumi.get(self, "on_host_maintenance")

    @_builtins.property
    @pulumi.getter(name="onInstanceStopAction")
    def on_instance_stop_action(self) -> Optional['outputs.RegionInstanceTemplateSchedulingOnInstanceStopAction']:
        """
        Defines the behaviour for instances with the instance_termination_action.
        """
        return pulumi.get(self, "on_instance_stop_action")

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> Optional[_builtins.bool]:
        """
        Allows instance to be preempted. This defaults to
        false. Read more on this
        [here](https://cloud.google.com/compute/docs/instances/preemptible).
        """
        return pulumi.get(self, "preemptible")

    @_builtins.property
    @pulumi.getter(name="provisioningModel")
    def provisioning_model(self) -> Optional[_builtins.str]:
        """
        Describe the type of preemptible VM. This field accepts the value `STANDARD` or `SPOT`. If the value is `STANDARD`, there will be no discount. If this   is set to `SPOT`,
        `preemptible` should be `true` and `automatic_restart` should be
        `false`. For more info about
        `SPOT`, read [here](https://cloud.google.com/compute/docs/instances/spot)
        """
        return pulumi.get(self, "provisioning_model")

    @_builtins.property
    @pulumi.getter(name="skipGuestOsShutdown")
    def skip_guest_os_shutdown(self) -> Optional[_builtins.bool]:
        """
        Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        """
        return pulumi.get(self, "skip_guest_os_shutdown")

    @_builtins.property
    @pulumi.getter(name="terminationTime")
    def termination_time(self) -> Optional[_builtins.str]:
        """
        Specifies the timestamp, when the instance will be terminated, in RFC3339 text format. If specified, the instance termination action will be performed at the termination time.
        """
        return pulumi.get(self, "termination_time")


@pulumi.output_type
class RegionInstanceTemplateSchedulingGracefulShutdown(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxDuration":
            suggest = "max_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateSchedulingGracefulShutdown. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateSchedulingGracefulShutdown.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateSchedulingGracefulShutdown.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 max_duration: Optional['outputs.RegionInstanceTemplateSchedulingGracefulShutdownMaxDuration'] = None):
        """
        :param _builtins.bool enabled: Opts-in for graceful shutdown.
        :param 'RegionInstanceTemplateSchedulingGracefulShutdownMaxDurationArgs' max_duration: The time allotted for the instance to gracefully shut down.
               If the graceful shutdown isn't complete after this time, then the instance
               transitions to the STOPPING state. Structure is documented below:
        """
        pulumi.set(__self__, "enabled", enabled)
        if max_duration is not None:
            pulumi.set(__self__, "max_duration", max_duration)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Opts-in for graceful shutdown.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxDuration")
    def max_duration(self) -> Optional['outputs.RegionInstanceTemplateSchedulingGracefulShutdownMaxDuration']:
        """
        The time allotted for the instance to gracefully shut down.
        If the graceful shutdown isn't complete after this time, then the instance
        transitions to the STOPPING state. Structure is documented below:
        """
        return pulumi.get(self, "max_duration")


@pulumi.output_type
class RegionInstanceTemplateSchedulingGracefulShutdownMaxDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               The value must be between 1 and 3600, which is 3,600 seconds (one hour).`
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented with a 0
               `seconds` field and a positive `nanos` field. Must be from 0 to
               999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        The value must be between 1 and 3600, which is 3,600 seconds (one hour).`
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented with a 0
        `seconds` field and a positive `nanos` field. Must be from 0 to
        999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionInstanceTemplateSchedulingLocalSsdRecoveryTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionInstanceTemplateSchedulingMaxRunDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.int,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.int seconds: Span of time at a resolution of a second. Must be from 0 to
               315,576,000,000 inclusive. Note: these bounds are computed from: 60
               sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented with a 0
               `seconds` field and a positive `nanos` field. Must be from 0 to
               999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second. Must be from 0 to
        315,576,000,000 inclusive. Note: these bounds are computed from: 60
        sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented with a 0
        `seconds` field and a positive `nanos` field. Must be from 0 to
        999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionInstanceTemplateSchedulingNodeAffinity(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key for the node affinity label.
        :param _builtins.str operator: The operator. Can be `IN` for node-affinities
               or `NOT_IN` for anti-affinities.
        :param Sequence[_builtins.str] values: Corresponds to the label values of a reservation resource.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key for the node affinity label.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator. Can be `IN` for node-affinities
        or `NOT_IN` for anti-affinities.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Corresponds to the label values of a reservation resource.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RegionInstanceTemplateSchedulingOnInstanceStopAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discardLocalSsd":
            suggest = "discard_local_ssd"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateSchedulingOnInstanceStopAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateSchedulingOnInstanceStopAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateSchedulingOnInstanceStopAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 discard_local_ssd: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool discard_local_ssd: If true, the contents of any attached Local SSD disks will be discarded.
        """
        if discard_local_ssd is not None:
            pulumi.set(__self__, "discard_local_ssd", discard_local_ssd)

    @_builtins.property
    @pulumi.getter(name="discardLocalSsd")
    def discard_local_ssd(self) -> Optional[_builtins.bool]:
        """
        If true, the contents of any attached Local SSD disks will be discarded.
        """
        return pulumi.get(self, "discard_local_ssd")


@pulumi.output_type
class RegionInstanceTemplateServiceAccount(dict):
    def __init__(__self__, *,
                 scopes: Sequence[_builtins.str],
                 email: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] scopes: A list of service scopes. Both OAuth2 URLs and gcloud
               short names are supported. To allow full access to all Cloud APIs, use the
               `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
               
               The [service accounts documentation](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)
               explains that access scopes are the legacy method of specifying permissions for your instance.
               To follow best practices you should create a dedicated service account with the minimum permissions the VM requires.
               To use a dedicated service account this field should be configured as a list containing the `cloud-platform` scope.
               See [Authenticate workloads using service accounts best practices](https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances#best_practices)
               and [Best practices for using service accounts](https://cloud.google.com/iam/docs/best-practices-service-accounts#single-purpose).
        :param _builtins.str email: The service account e-mail address. If not given, the
               default Google Compute Engine service account is used.
        """
        pulumi.set(__self__, "scopes", scopes)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        """
        A list of service scopes. Both OAuth2 URLs and gcloud
        short names are supported. To allow full access to all Cloud APIs, use the
        `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).

        The [service accounts documentation](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)
        explains that access scopes are the legacy method of specifying permissions for your instance.
        To follow best practices you should create a dedicated service account with the minimum permissions the VM requires.
        To use a dedicated service account this field should be configured as a list containing the `cloud-platform` scope.
        See [Authenticate workloads using service accounts best practices](https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances#best_practices)
        and [Best practices for using service accounts](https://cloud.google.com/iam/docs/best-practices-service-accounts#single-purpose).
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The service account e-mail address. If not given, the
        default Google Compute Engine service account is used.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class RegionInstanceTemplateShieldedInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIntegrityMonitoring":
            suggest = "enable_integrity_monitoring"
        elif key == "enableSecureBoot":
            suggest = "enable_secure_boot"
        elif key == "enableVtpm":
            suggest = "enable_vtpm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionInstanceTemplateShieldedInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionInstanceTemplateShieldedInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionInstanceTemplateShieldedInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[_builtins.bool] = None,
                 enable_secure_boot: Optional[_builtins.bool] = None,
                 enable_vtpm: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable_integrity_monitoring: - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        :param _builtins.bool enable_secure_boot: - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        :param _builtins.bool enable_vtpm: - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        """
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        if enable_vtpm is not None:
            pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @_builtins.property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[_builtins.bool]:
        """
        - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @_builtins.property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[_builtins.bool]:
        """
        - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        """
        return pulumi.get(self, "enable_secure_boot")

    @_builtins.property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> Optional[_builtins.bool]:
        """
        - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        """
        return pulumi.get(self, "enable_vtpm")


@pulumi.output_type
class RegionNetworkEndpointGroupAppEngine(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlMask":
            suggest = "url_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionNetworkEndpointGroupAppEngine. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionNetworkEndpointGroupAppEngine.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionNetworkEndpointGroupAppEngine.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service: Optional[_builtins.str] = None,
                 url_mask: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str service: Optional serving service.
               The service name must be 1-63 characters long, and comply with RFC1035.
               Example value: "default", "my-service".
        :param _builtins.str url_mask: A template to parse service and version fields from a request URL.
               URL mask allows for routing to multiple App Engine services without
               having to create multiple Network Endpoint Groups and backend services.
               For example, the request URLs "foo1-dot-appname.appspot.com/v1" and
               "foo1-dot-appname.appspot.com/v2" can be backed by the same Serverless NEG with
               URL mask "-dot-appname.appspot.com/". The URL mask will parse
               them to { service = "foo1", version = "v1" } and { service = "foo1", version = "v2" } respectively.
        :param _builtins.str version: Optional serving version.
               The version must be 1-63 characters long, and comply with RFC1035.
               Example value: "v1", "v2".
        """
        if service is not None:
            pulumi.set(__self__, "service", service)
        if url_mask is not None:
            pulumi.set(__self__, "url_mask", url_mask)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Optional serving service.
        The service name must be 1-63 characters long, and comply with RFC1035.
        Example value: "default", "my-service".
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="urlMask")
    def url_mask(self) -> Optional[_builtins.str]:
        """
        A template to parse service and version fields from a request URL.
        URL mask allows for routing to multiple App Engine services without
        having to create multiple Network Endpoint Groups and backend services.
        For example, the request URLs "foo1-dot-appname.appspot.com/v1" and
        "foo1-dot-appname.appspot.com/v2" can be backed by the same Serverless NEG with
        URL mask "-dot-appname.appspot.com/". The URL mask will parse
        them to { service = "foo1", version = "v1" } and { service = "foo1", version = "v2" } respectively.
        """
        return pulumi.get(self, "url_mask")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Optional serving version.
        The version must be 1-63 characters long, and comply with RFC1035.
        Example value: "v1", "v2".
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class RegionNetworkEndpointGroupCloudFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlMask":
            suggest = "url_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionNetworkEndpointGroupCloudFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionNetworkEndpointGroupCloudFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionNetworkEndpointGroupCloudFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 function: Optional[_builtins.str] = None,
                 url_mask: Optional[_builtins.str] = None):
        """
        :param _builtins.str function: A user-defined name of the Cloud Function.
               The function name is case-sensitive and must be 1-63 characters long.
               Example value: "func1".
        :param _builtins.str url_mask: A template to parse function field from a request URL. URL mask allows
               for routing to multiple Cloud Functions without having to create
               multiple Network Endpoint Groups and backend services.
               For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
               can be backed by the same Serverless NEG with URL mask "/". The URL mask
               will parse them to { function = "function1" } and { function = "function2" } respectively.
        """
        if function is not None:
            pulumi.set(__self__, "function", function)
        if url_mask is not None:
            pulumi.set(__self__, "url_mask", url_mask)

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional[_builtins.str]:
        """
        A user-defined name of the Cloud Function.
        The function name is case-sensitive and must be 1-63 characters long.
        Example value: "func1".
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter(name="urlMask")
    def url_mask(self) -> Optional[_builtins.str]:
        """
        A template to parse function field from a request URL. URL mask allows
        for routing to multiple Cloud Functions without having to create
        multiple Network Endpoint Groups and backend services.
        For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
        can be backed by the same Serverless NEG with URL mask "/". The URL mask
        will parse them to { function = "function1" } and { function = "function2" } respectively.
        """
        return pulumi.get(self, "url_mask")


@pulumi.output_type
class RegionNetworkEndpointGroupCloudRun(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlMask":
            suggest = "url_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionNetworkEndpointGroupCloudRun. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionNetworkEndpointGroupCloudRun.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionNetworkEndpointGroupCloudRun.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None,
                 url_mask: Optional[_builtins.str] = None):
        """
        :param _builtins.str service: Cloud Run service is the main resource of Cloud Run.
               The service must be 1-63 characters long, and comply with RFC1035.
               Example value: "run-service".
        :param _builtins.str tag: Cloud Run tag represents the "named-revision" to provide
               additional fine-grained traffic routing information.
               The tag must be 1-63 characters long, and comply with RFC1035.
               Example value: "revision-0010".
        :param _builtins.str url_mask: A template to parse service and tag fields from a request URL.
               URL mask allows for routing to multiple Run services without having
               to create multiple network endpoint groups and backend services.
               For example, request URLs "foo1.domain.com/bar1" and "foo1.domain.com/bar2"
               an be backed by the same Serverless Network Endpoint Group (NEG) with
               URL mask ".domain.com/". The URL mask will parse them to { service="bar1", tag="foo1" }
               and { service="bar2", tag="foo2" } respectively.
        """
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if url_mask is not None:
            pulumi.set(__self__, "url_mask", url_mask)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Cloud Run service is the main resource of Cloud Run.
        The service must be 1-63 characters long, and comply with RFC1035.
        Example value: "run-service".
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        Cloud Run tag represents the "named-revision" to provide
        additional fine-grained traffic routing information.
        The tag must be 1-63 characters long, and comply with RFC1035.
        Example value: "revision-0010".
        """
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter(name="urlMask")
    def url_mask(self) -> Optional[_builtins.str]:
        """
        A template to parse service and tag fields from a request URL.
        URL mask allows for routing to multiple Run services without having
        to create multiple network endpoint groups and backend services.
        For example, request URLs "foo1.domain.com/bar1" and "foo1.domain.com/bar2"
        an be backed by the same Serverless Network Endpoint Group (NEG) with
        URL mask ".domain.com/". The URL mask will parse them to { service="bar1", tag="foo1" }
        and { service="bar2", tag="foo2" } respectively.
        """
        return pulumi.get(self, "url_mask")


@pulumi.output_type
class RegionNetworkEndpointGroupPscData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "producerPort":
            suggest = "producer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionNetworkEndpointGroupPscData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionNetworkEndpointGroupPscData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionNetworkEndpointGroupPscData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 producer_port: Optional[_builtins.str] = None):
        """
        :param _builtins.str producer_port: The PSC producer port to use when consumer PSC NEG connects to a producer. If
               this flag isn't specified for a PSC NEG with endpoint type
               private-service-connect, then PSC NEG will be connected to a first port in the
               available PSC producer port range.
        """
        if producer_port is not None:
            pulumi.set(__self__, "producer_port", producer_port)

    @_builtins.property
    @pulumi.getter(name="producerPort")
    def producer_port(self) -> Optional[_builtins.str]:
        """
        The PSC producer port to use when consumer PSC NEG connects to a producer. If
        this flag isn't specified for a PSC NEG with endpoint type
        private-service-connect, then PSC NEG will be connected to a first port in the
        available PSC producer port range.
        """
        return pulumi.get(self, "producer_port")


@pulumi.output_type
class RegionNetworkEndpointGroupServerlessDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlMask":
            suggest = "url_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionNetworkEndpointGroupServerlessDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionNetworkEndpointGroupServerlessDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionNetworkEndpointGroupServerlessDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 platform: _builtins.str,
                 resource: Optional[_builtins.str] = None,
                 url_mask: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str platform: The platform of the NEG backend target(s). Possible values:
               API Gateway: apigateway.googleapis.com
        :param _builtins.str resource: The user-defined name of the workload/instance. This value must be provided explicitly or in the urlMask.
               The resource identified by this value is platform-specific and is as follows: API Gateway: The gateway ID, App Engine: The service name,
               Cloud Functions: The function name, Cloud Run: The service name
        :param _builtins.str url_mask: A template to parse platform-specific fields from a request URL. URL mask allows for routing to multiple resources
               on the same serverless platform without having to create multiple Network Endpoint Groups and backend resources.
               The fields parsed by this template are platform-specific and are as follows: API Gateway: The gateway ID,
               App Engine: The service and version, Cloud Functions: The function name, Cloud Run: The service and tag
        :param _builtins.str version: The optional resource version. The version identified by this value is platform-specific and is follows:
               API Gateway: Unused, App Engine: The service version, Cloud Functions: Unused, Cloud Run: The service tag
        """
        pulumi.set(__self__, "platform", platform)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if url_mask is not None:
            pulumi.set(__self__, "url_mask", url_mask)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> _builtins.str:
        """
        The platform of the NEG backend target(s). Possible values:
        API Gateway: apigateway.googleapis.com
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter
    def resource(self) -> Optional[_builtins.str]:
        """
        The user-defined name of the workload/instance. This value must be provided explicitly or in the urlMask.
        The resource identified by this value is platform-specific and is as follows: API Gateway: The gateway ID, App Engine: The service name,
        Cloud Functions: The function name, Cloud Run: The service name
        """
        return pulumi.get(self, "resource")

    @_builtins.property
    @pulumi.getter(name="urlMask")
    def url_mask(self) -> Optional[_builtins.str]:
        """
        A template to parse platform-specific fields from a request URL. URL mask allows for routing to multiple resources
        on the same serverless platform without having to create multiple Network Endpoint Groups and backend resources.
        The fields parsed by this template are platform-specific and are as follows: API Gateway: The gateway ID,
        App Engine: The service and version, Cloud Functions: The function name, Cloud Run: The service and tag
        """
        return pulumi.get(self, "url_mask")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The optional resource version. The version identified by this value is platform-specific and is follows:
        API Gateway: Unused, App Engine: The service version, Cloud Functions: Unused, Cloud Run: The service tag
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class RegionNetworkFirewallPolicyRuleMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layer4Configs":
            suggest = "layer4_configs"
        elif key == "destAddressGroups":
            suggest = "dest_address_groups"
        elif key == "destFqdns":
            suggest = "dest_fqdns"
        elif key == "destIpRanges":
            suggest = "dest_ip_ranges"
        elif key == "destNetworkScope":
            suggest = "dest_network_scope"
        elif key == "destRegionCodes":
            suggest = "dest_region_codes"
        elif key == "destThreatIntelligences":
            suggest = "dest_threat_intelligences"
        elif key == "srcAddressGroups":
            suggest = "src_address_groups"
        elif key == "srcFqdns":
            suggest = "src_fqdns"
        elif key == "srcIpRanges":
            suggest = "src_ip_ranges"
        elif key == "srcNetworkScope":
            suggest = "src_network_scope"
        elif key == "srcNetworks":
            suggest = "src_networks"
        elif key == "srcRegionCodes":
            suggest = "src_region_codes"
        elif key == "srcSecureTags":
            suggest = "src_secure_tags"
        elif key == "srcThreatIntelligences":
            suggest = "src_threat_intelligences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionNetworkFirewallPolicyRuleMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionNetworkFirewallPolicyRuleMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionNetworkFirewallPolicyRuleMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layer4_configs: Sequence['outputs.RegionNetworkFirewallPolicyRuleMatchLayer4Config'],
                 dest_address_groups: Optional[Sequence[_builtins.str]] = None,
                 dest_fqdns: Optional[Sequence[_builtins.str]] = None,
                 dest_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 dest_network_scope: Optional[_builtins.str] = None,
                 dest_region_codes: Optional[Sequence[_builtins.str]] = None,
                 dest_threat_intelligences: Optional[Sequence[_builtins.str]] = None,
                 src_address_groups: Optional[Sequence[_builtins.str]] = None,
                 src_fqdns: Optional[Sequence[_builtins.str]] = None,
                 src_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 src_network_scope: Optional[_builtins.str] = None,
                 src_networks: Optional[Sequence[_builtins.str]] = None,
                 src_region_codes: Optional[Sequence[_builtins.str]] = None,
                 src_secure_tags: Optional[Sequence['outputs.RegionNetworkFirewallPolicyRuleMatchSrcSecureTag']] = None,
                 src_threat_intelligences: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['RegionNetworkFirewallPolicyRuleMatchLayer4ConfigArgs'] layer4_configs: Pairs of IP protocols and ports that the rule should match.
               Structure is documented below.
        :param Sequence[_builtins.str] dest_address_groups: Address groups which should be matched against the traffic destination. Maximum number of destination address groups is 10.
        :param Sequence[_builtins.str] dest_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against traffic destination. Maximum number of destination fqdn allowed is 100.
        :param Sequence[_builtins.str] dest_ip_ranges: CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
        :param _builtins.str dest_network_scope: Network scope of the traffic destination.
               Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        :param Sequence[_builtins.str] dest_region_codes: Region codes whose IP addresses will be used to match for destination of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of dest region codes allowed is 5000.
        :param Sequence[_builtins.str] dest_threat_intelligences: Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic destination.
        :param Sequence[_builtins.str] src_address_groups: Address groups which should be matched against the traffic source. Maximum number of source address groups is 10.
        :param Sequence[_builtins.str] src_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against traffic source. Maximum number of source fqdn allowed is 100.
        :param Sequence[_builtins.str] src_ip_ranges: CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
        :param _builtins.str src_network_scope: Network scope of the traffic source.
               Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        :param Sequence[_builtins.str] src_networks: Networks of the traffic source. It can be either a full or partial url.
        :param Sequence[_builtins.str] src_region_codes: Region codes whose IP addresses will be used to match for source of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of source region codes allowed is 5000.
        :param Sequence['RegionNetworkFirewallPolicyRuleMatchSrcSecureTagArgs'] src_secure_tags: List of secure tag values, which should be matched at the source of the traffic. For INGRESS rule, if all the srcSecureTag are INEFFECTIVE, and there is no srcIpRange, this rule will be ignored. Maximum number of source tag values allowed is 256.
               Structure is documented below.
        :param Sequence[_builtins.str] src_threat_intelligences: Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic source.
               
               
               <a name="nested_match_layer4_configs"></a>The `layer4_configs` block supports:
        """
        pulumi.set(__self__, "layer4_configs", layer4_configs)
        if dest_address_groups is not None:
            pulumi.set(__self__, "dest_address_groups", dest_address_groups)
        if dest_fqdns is not None:
            pulumi.set(__self__, "dest_fqdns", dest_fqdns)
        if dest_ip_ranges is not None:
            pulumi.set(__self__, "dest_ip_ranges", dest_ip_ranges)
        if dest_network_scope is not None:
            pulumi.set(__self__, "dest_network_scope", dest_network_scope)
        if dest_region_codes is not None:
            pulumi.set(__self__, "dest_region_codes", dest_region_codes)
        if dest_threat_intelligences is not None:
            pulumi.set(__self__, "dest_threat_intelligences", dest_threat_intelligences)
        if src_address_groups is not None:
            pulumi.set(__self__, "src_address_groups", src_address_groups)
        if src_fqdns is not None:
            pulumi.set(__self__, "src_fqdns", src_fqdns)
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)
        if src_network_scope is not None:
            pulumi.set(__self__, "src_network_scope", src_network_scope)
        if src_networks is not None:
            pulumi.set(__self__, "src_networks", src_networks)
        if src_region_codes is not None:
            pulumi.set(__self__, "src_region_codes", src_region_codes)
        if src_secure_tags is not None:
            pulumi.set(__self__, "src_secure_tags", src_secure_tags)
        if src_threat_intelligences is not None:
            pulumi.set(__self__, "src_threat_intelligences", src_threat_intelligences)

    @_builtins.property
    @pulumi.getter(name="layer4Configs")
    def layer4_configs(self) -> Sequence['outputs.RegionNetworkFirewallPolicyRuleMatchLayer4Config']:
        """
        Pairs of IP protocols and ports that the rule should match.
        Structure is documented below.
        """
        return pulumi.get(self, "layer4_configs")

    @_builtins.property
    @pulumi.getter(name="destAddressGroups")
    def dest_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic destination. Maximum number of destination address groups is 10.
        """
        return pulumi.get(self, "dest_address_groups")

    @_builtins.property
    @pulumi.getter(name="destFqdns")
    def dest_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against traffic destination. Maximum number of destination fqdn allowed is 100.
        """
        return pulumi.get(self, "dest_fqdns")

    @_builtins.property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
        """
        return pulumi.get(self, "dest_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="destNetworkScope")
    def dest_network_scope(self) -> Optional[_builtins.str]:
        """
        Network scope of the traffic destination.
        Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        """
        return pulumi.get(self, "dest_network_scope")

    @_builtins.property
    @pulumi.getter(name="destRegionCodes")
    def dest_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for destination of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of dest region codes allowed is 5000.
        """
        return pulumi.get(self, "dest_region_codes")

    @_builtins.property
    @pulumi.getter(name="destThreatIntelligences")
    def dest_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic destination.
        """
        return pulumi.get(self, "dest_threat_intelligences")

    @_builtins.property
    @pulumi.getter(name="srcAddressGroups")
    def src_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic source. Maximum number of source address groups is 10.
        """
        return pulumi.get(self, "src_address_groups")

    @_builtins.property
    @pulumi.getter(name="srcFqdns")
    def src_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against traffic source. Maximum number of source fqdn allowed is 100.
        """
        return pulumi.get(self, "src_fqdns")

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
        """
        return pulumi.get(self, "src_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="srcNetworkScope")
    def src_network_scope(self) -> Optional[_builtins.str]:
        """
        Network scope of the traffic source.
        Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        """
        return pulumi.get(self, "src_network_scope")

    @_builtins.property
    @pulumi.getter(name="srcNetworks")
    def src_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Networks of the traffic source. It can be either a full or partial url.
        """
        return pulumi.get(self, "src_networks")

    @_builtins.property
    @pulumi.getter(name="srcRegionCodes")
    def src_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for source of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of source region codes allowed is 5000.
        """
        return pulumi.get(self, "src_region_codes")

    @_builtins.property
    @pulumi.getter(name="srcSecureTags")
    def src_secure_tags(self) -> Optional[Sequence['outputs.RegionNetworkFirewallPolicyRuleMatchSrcSecureTag']]:
        """
        List of secure tag values, which should be matched at the source of the traffic. For INGRESS rule, if all the srcSecureTag are INEFFECTIVE, and there is no srcIpRange, this rule will be ignored. Maximum number of source tag values allowed is 256.
        Structure is documented below.
        """
        return pulumi.get(self, "src_secure_tags")

    @_builtins.property
    @pulumi.getter(name="srcThreatIntelligences")
    def src_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic source.


        <a name="nested_match_layer4_configs"></a>The `layer4_configs` block supports:
        """
        return pulumi.get(self, "src_threat_intelligences")


@pulumi.output_type
class RegionNetworkFirewallPolicyRuleMatchLayer4Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionNetworkFirewallPolicyRuleMatchLayer4Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionNetworkFirewallPolicyRuleMatchLayer4Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionNetworkFirewallPolicyRuleMatchLayer4Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: _builtins.str,
                 ports: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str ip_protocol: The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule.
               This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
        :param Sequence[_builtins.str] ports: An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> _builtins.str:
        """
        The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule.
        This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
        """
        return pulumi.get(self, "ip_protocol")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class RegionNetworkFirewallPolicyRuleMatchSrcSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
        :param _builtins.str state: (Output)
               State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class RegionNetworkFirewallPolicyRuleTargetSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
        :param _builtins.str state: (Output)
               State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class RegionNetworkFirewallPolicyWithRulesPredefinedRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableLogging":
            suggest = "enable_logging"
        elif key == "ruleName":
            suggest = "rule_name"
        elif key == "securityProfileGroup":
            suggest = "security_profile_group"
        elif key == "targetSecureTags":
            suggest = "target_secure_tags"
        elif key == "targetServiceAccounts":
            suggest = "target_service_accounts"
        elif key == "tlsInspect":
            suggest = "tls_inspect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionNetworkFirewallPolicyWithRulesPredefinedRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionNetworkFirewallPolicyWithRulesPredefinedRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionNetworkFirewallPolicyWithRulesPredefinedRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 enable_logging: Optional[_builtins.bool] = None,
                 matches: Optional[Sequence['outputs.RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatch']] = None,
                 priority: Optional[_builtins.int] = None,
                 rule_name: Optional[_builtins.str] = None,
                 security_profile_group: Optional[_builtins.str] = None,
                 target_secure_tags: Optional[Sequence['outputs.RegionNetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag']] = None,
                 target_service_accounts: Optional[Sequence[_builtins.str]] = None,
                 tls_inspect: Optional[_builtins.bool] = None):
        """
        :param _builtins.str action: (Output)
               The Action to perform when the client connection triggers the rule. Can currently be either
               "allow", "deny", "apply_security_profile_group" or "goto_next".
        :param _builtins.str description: An optional description of this resource.
        :param _builtins.str direction: (Output)
               The direction in which this rule applies. If unspecified an INGRESS rule is created.
        :param _builtins.bool disabled: (Output)
               Denotes whether the firewall policy rule is disabled. When set to true,
               the firewall policy rule is not enforced and traffic behaves as if it did
               not exist. If this is unspecified, the firewall policy rule will be
               enabled.
        :param _builtins.bool enable_logging: (Output)
               Denotes whether to enable logging for a particular rule.
               If logging is enabled, logs will be exported to the
               configured export destination in Stackdriver.
        :param Sequence['RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchArgs'] matches: (Output)
               A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
               Structure is documented below.
        :param _builtins.int priority: (Output)
               An integer indicating the priority of a rule in the list. The priority must be a value
               between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
               highest priority and 2147483647 is the lowest priority.
        :param _builtins.str rule_name: (Output)
               An optional name for the rule. This field is not a unique identifier
               and can be updated.
        :param _builtins.str security_profile_group: (Output)
               A fully-qualified URL of a SecurityProfile resource instance.
               Example:
               https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
               Must be specified if action is 'apply_security_profile_group'.
        :param Sequence['RegionNetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTagArgs'] target_secure_tags: (Output)
               A list of secure tags that controls which instances the firewall rule
               applies to. If <code>targetSecureTag</code> are specified, then the
               firewall rule applies only to instances in the VPC network that have one
               of those EFFECTIVE secure tags, if all the target_secure_tag are in
               INEFFECTIVE state, then this rule will be ignored.
               <code>targetSecureTag</code> may not be set at the same time as
               <code>targetServiceAccounts</code>.
               If neither <code>targetServiceAccounts</code> nor
               <code>targetSecureTag</code> are specified, the firewall rule applies
               to all instances on the specified network.
               Maximum number of target label tags allowed is 256.
               Structure is documented below.
        :param Sequence[_builtins.str] target_service_accounts: (Output)
               A list of service accounts indicating the sets of
               instances that are applied with this rule.
        :param _builtins.bool tls_inspect: (Output)
               Boolean flag indicating if the traffic should be TLS decrypted.
               It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)
        if security_profile_group is not None:
            pulumi.set(__self__, "security_profile_group", security_profile_group)
        if target_secure_tags is not None:
            pulumi.set(__self__, "target_secure_tags", target_secure_tags)
        if target_service_accounts is not None:
            pulumi.set(__self__, "target_service_accounts", target_service_accounts)
        if tls_inspect is not None:
            pulumi.set(__self__, "tls_inspect", tls_inspect)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Action to perform when the client connection triggers the rule. Can currently be either
        "allow", "deny", "apply_security_profile_group" or "goto_next".
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        (Output)
        The direction in which this rule applies. If unspecified an INGRESS rule is created.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Denotes whether the firewall policy rule is disabled. When set to true,
        the firewall policy rule is not enforced and traffic behaves as if it did
        not exist. If this is unspecified, the firewall policy rule will be
        enabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Denotes whether to enable logging for a particular rule.
        If logging is enabled, logs will be exported to the
        configured export destination in Stackdriver.
        """
        return pulumi.get(self, "enable_logging")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatch']]:
        """
        (Output)
        A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
        Structure is documented below.
        """
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        (Output)
        An integer indicating the priority of a rule in the list. The priority must be a value
        between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
        highest priority and 2147483647 is the lowest priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        An optional name for the rule. This field is not a unique identifier
        and can be updated.
        """
        return pulumi.get(self, "rule_name")

    @_builtins.property
    @pulumi.getter(name="securityProfileGroup")
    def security_profile_group(self) -> Optional[_builtins.str]:
        """
        (Output)
        A fully-qualified URL of a SecurityProfile resource instance.
        Example:
        https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
        Must be specified if action is 'apply_security_profile_group'.
        """
        return pulumi.get(self, "security_profile_group")

    @_builtins.property
    @pulumi.getter(name="targetSecureTags")
    def target_secure_tags(self) -> Optional[Sequence['outputs.RegionNetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag']]:
        """
        (Output)
        A list of secure tags that controls which instances the firewall rule
        applies to. If <code>targetSecureTag</code> are specified, then the
        firewall rule applies only to instances in the VPC network that have one
        of those EFFECTIVE secure tags, if all the target_secure_tag are in
        INEFFECTIVE state, then this rule will be ignored.
        <code>targetSecureTag</code> may not be set at the same time as
        <code>targetServiceAccounts</code>.
        If neither <code>targetServiceAccounts</code> nor
        <code>targetSecureTag</code> are specified, the firewall rule applies
        to all instances on the specified network.
        Maximum number of target label tags allowed is 256.
        Structure is documented below.
        """
        return pulumi.get(self, "target_secure_tags")

    @_builtins.property
    @pulumi.getter(name="targetServiceAccounts")
    def target_service_accounts(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        A list of service accounts indicating the sets of
        instances that are applied with this rule.
        """
        return pulumi.get(self, "target_service_accounts")

    @_builtins.property
    @pulumi.getter(name="tlsInspect")
    def tls_inspect(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Boolean flag indicating if the traffic should be TLS decrypted.
        It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
        """
        return pulumi.get(self, "tls_inspect")


@pulumi.output_type
class RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destAddressGroups":
            suggest = "dest_address_groups"
        elif key == "destFqdns":
            suggest = "dest_fqdns"
        elif key == "destIpRanges":
            suggest = "dest_ip_ranges"
        elif key == "destRegionCodes":
            suggest = "dest_region_codes"
        elif key == "destThreatIntelligences":
            suggest = "dest_threat_intelligences"
        elif key == "layer4Configs":
            suggest = "layer4_configs"
        elif key == "srcAddressGroups":
            suggest = "src_address_groups"
        elif key == "srcFqdns":
            suggest = "src_fqdns"
        elif key == "srcIpRanges":
            suggest = "src_ip_ranges"
        elif key == "srcRegionCodes":
            suggest = "src_region_codes"
        elif key == "srcSecureTags":
            suggest = "src_secure_tags"
        elif key == "srcThreatIntelligences":
            suggest = "src_threat_intelligences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dest_address_groups: Optional[Sequence[_builtins.str]] = None,
                 dest_fqdns: Optional[Sequence[_builtins.str]] = None,
                 dest_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 dest_region_codes: Optional[Sequence[_builtins.str]] = None,
                 dest_threat_intelligences: Optional[Sequence[_builtins.str]] = None,
                 layer4_configs: Optional[Sequence['outputs.RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config']] = None,
                 src_address_groups: Optional[Sequence[_builtins.str]] = None,
                 src_fqdns: Optional[Sequence[_builtins.str]] = None,
                 src_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 src_region_codes: Optional[Sequence[_builtins.str]] = None,
                 src_secure_tags: Optional[Sequence['outputs.RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag']] = None,
                 src_threat_intelligences: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] dest_address_groups: Address groups which should be matched against the traffic destination.
               Maximum number of destination address groups is 10.
        :param Sequence[_builtins.str] dest_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against
               traffic destination. Maximum number of destination fqdn allowed is 100.
        :param Sequence[_builtins.str] dest_ip_ranges: Destination IP address range in CIDR format. Required for
               EGRESS rules.
        :param Sequence[_builtins.str] dest_region_codes: Region codes whose IP addresses will be used to match for destination
               of traffic. Should be specified as 2 letter country code defined as per
               ISO 3166 alpha-2 country codes. ex."US"
               Maximum number of destination region codes allowed is 5000.
        :param Sequence[_builtins.str] dest_threat_intelligences: Names of Network Threat Intelligence lists.
               The IPs in these lists will be matched against traffic destination.
        :param Sequence['RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4ConfigArgs'] layer4_configs: Pairs of IP protocols and ports that the rule should match.
               Structure is documented below.
        :param Sequence[_builtins.str] src_address_groups: Address groups which should be matched against the traffic source.
               Maximum number of source address groups is 10.
        :param Sequence[_builtins.str] src_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against
               traffic source. Maximum number of source fqdn allowed is 100.
        :param Sequence[_builtins.str] src_ip_ranges: Source IP address range in CIDR format. Required for
               INGRESS rules.
        :param Sequence[_builtins.str] src_region_codes: Region codes whose IP addresses will be used to match for source
               of traffic. Should be specified as 2 letter country code defined as per
               ISO 3166 alpha-2 country codes. ex."US"
               Maximum number of source region codes allowed is 5000.
        :param Sequence['RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTagArgs'] src_secure_tags: List of secure tag values, which should be matched at the source
               of the traffic.
               For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
               and there is no <code>srcIpRange</code>, this rule will be ignored.
               Maximum number of source tag values allowed is 256.
               Structure is documented below.
               
               
               <a name="nested_rule_rule_match_layer4_config"></a>The `layer4_config` block supports:
        :param Sequence[_builtins.str] src_threat_intelligences: Names of Network Threat Intelligence lists.
               The IPs in these lists will be matched against traffic source.
        """
        if dest_address_groups is not None:
            pulumi.set(__self__, "dest_address_groups", dest_address_groups)
        if dest_fqdns is not None:
            pulumi.set(__self__, "dest_fqdns", dest_fqdns)
        if dest_ip_ranges is not None:
            pulumi.set(__self__, "dest_ip_ranges", dest_ip_ranges)
        if dest_region_codes is not None:
            pulumi.set(__self__, "dest_region_codes", dest_region_codes)
        if dest_threat_intelligences is not None:
            pulumi.set(__self__, "dest_threat_intelligences", dest_threat_intelligences)
        if layer4_configs is not None:
            pulumi.set(__self__, "layer4_configs", layer4_configs)
        if src_address_groups is not None:
            pulumi.set(__self__, "src_address_groups", src_address_groups)
        if src_fqdns is not None:
            pulumi.set(__self__, "src_fqdns", src_fqdns)
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)
        if src_region_codes is not None:
            pulumi.set(__self__, "src_region_codes", src_region_codes)
        if src_secure_tags is not None:
            pulumi.set(__self__, "src_secure_tags", src_secure_tags)
        if src_threat_intelligences is not None:
            pulumi.set(__self__, "src_threat_intelligences", src_threat_intelligences)

    @_builtins.property
    @pulumi.getter(name="destAddressGroups")
    def dest_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic destination.
        Maximum number of destination address groups is 10.
        """
        return pulumi.get(self, "dest_address_groups")

    @_builtins.property
    @pulumi.getter(name="destFqdns")
    def dest_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against
        traffic destination. Maximum number of destination fqdn allowed is 100.
        """
        return pulumi.get(self, "dest_fqdns")

    @_builtins.property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Destination IP address range in CIDR format. Required for
        EGRESS rules.
        """
        return pulumi.get(self, "dest_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="destRegionCodes")
    def dest_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for destination
        of traffic. Should be specified as 2 letter country code defined as per
        ISO 3166 alpha-2 country codes. ex."US"
        Maximum number of destination region codes allowed is 5000.
        """
        return pulumi.get(self, "dest_region_codes")

    @_builtins.property
    @pulumi.getter(name="destThreatIntelligences")
    def dest_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists.
        The IPs in these lists will be matched against traffic destination.
        """
        return pulumi.get(self, "dest_threat_intelligences")

    @_builtins.property
    @pulumi.getter(name="layer4Configs")
    def layer4_configs(self) -> Optional[Sequence['outputs.RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config']]:
        """
        Pairs of IP protocols and ports that the rule should match.
        Structure is documented below.
        """
        return pulumi.get(self, "layer4_configs")

    @_builtins.property
    @pulumi.getter(name="srcAddressGroups")
    def src_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic source.
        Maximum number of source address groups is 10.
        """
        return pulumi.get(self, "src_address_groups")

    @_builtins.property
    @pulumi.getter(name="srcFqdns")
    def src_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against
        traffic source. Maximum number of source fqdn allowed is 100.
        """
        return pulumi.get(self, "src_fqdns")

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Source IP address range in CIDR format. Required for
        INGRESS rules.
        """
        return pulumi.get(self, "src_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="srcRegionCodes")
    def src_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for source
        of traffic. Should be specified as 2 letter country code defined as per
        ISO 3166 alpha-2 country codes. ex."US"
        Maximum number of source region codes allowed is 5000.
        """
        return pulumi.get(self, "src_region_codes")

    @_builtins.property
    @pulumi.getter(name="srcSecureTags")
    def src_secure_tags(self) -> Optional[Sequence['outputs.RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag']]:
        """
        List of secure tag values, which should be matched at the source
        of the traffic.
        For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
        and there is no <code>srcIpRange</code>, this rule will be ignored.
        Maximum number of source tag values allowed is 256.
        Structure is documented below.


        <a name="nested_rule_rule_match_layer4_config"></a>The `layer4_config` block supports:
        """
        return pulumi.get(self, "src_secure_tags")

    @_builtins.property
    @pulumi.getter(name="srcThreatIntelligences")
    def src_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists.
        The IPs in these lists will be matched against traffic source.
        """
        return pulumi.get(self, "src_threat_intelligences")


@pulumi.output_type
class RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: Optional[_builtins.str] = None,
                 ports: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str ip_protocol: (Output)
               The IP protocol to which this rule applies. The protocol
               type is required when creating a firewall rule.
               This value can either be one of the following well
               known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
               or the IP protocol number.
        :param Sequence[_builtins.str] ports: (Output)
               An optional list of ports to which this rule applies. This field
               is only applicable for UDP or TCP protocol. Each entry must be
               either an integer or a range. If not specified, this rule
               applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and
               ["12345-12349"].
        """
        if ip_protocol is not None:
            pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> Optional[_builtins.str]:
        """
        (Output)
        The IP protocol to which this rule applies. The protocol
        type is required when creating a firewall rule.
        This value can either be one of the following well
        known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
        or the IP protocol number.
        """
        return pulumi.get(self, "ip_protocol")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and
        ["12345-12349"].
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
               @pattern tagValues/[0-9]+
        :param _builtins.str state: (Output)
               [Output Only] State of the secure tag, either `EFFECTIVE` or
               `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
               or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        @pattern tagValues/[0-9]+
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        [Output Only] State of the secure tag, either `EFFECTIVE` or
        `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
        or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class RegionNetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
               @pattern tagValues/[0-9]+
        :param _builtins.str state: (Output)
               [Output Only] State of the secure tag, either `EFFECTIVE` or
               `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
               or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        @pattern tagValues/[0-9]+
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        [Output Only] State of the secure tag, either `EFFECTIVE` or
        `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
        or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class RegionNetworkFirewallPolicyWithRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableLogging":
            suggest = "enable_logging"
        elif key == "ruleName":
            suggest = "rule_name"
        elif key == "securityProfileGroup":
            suggest = "security_profile_group"
        elif key == "targetSecureTags":
            suggest = "target_secure_tags"
        elif key == "targetServiceAccounts":
            suggest = "target_service_accounts"
        elif key == "tlsInspect":
            suggest = "tls_inspect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionNetworkFirewallPolicyWithRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionNetworkFirewallPolicyWithRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionNetworkFirewallPolicyWithRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 match: 'outputs.RegionNetworkFirewallPolicyWithRulesRuleMatch',
                 priority: _builtins.int,
                 description: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 enable_logging: Optional[_builtins.bool] = None,
                 rule_name: Optional[_builtins.str] = None,
                 security_profile_group: Optional[_builtins.str] = None,
                 target_secure_tags: Optional[Sequence['outputs.RegionNetworkFirewallPolicyWithRulesRuleTargetSecureTag']] = None,
                 target_service_accounts: Optional[Sequence[_builtins.str]] = None,
                 tls_inspect: Optional[_builtins.bool] = None):
        """
        :param _builtins.str action: The Action to perform when the client connection triggers the rule. Can currently be either
               "allow", "deny", "apply_security_profile_group" or "goto_next".
        :param 'RegionNetworkFirewallPolicyWithRulesRuleMatchArgs' match: A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
               Structure is documented below.
        :param _builtins.int priority: An integer indicating the priority of a rule in the list. The priority must be a value
               between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
               highest priority and 2147483647 is the lowest priority.
        :param _builtins.str description: A description of the rule.
        :param _builtins.str direction: The direction in which this rule applies. If unspecified an INGRESS rule is created.
               Possible values are: `INGRESS`, `EGRESS`.
        :param _builtins.bool disabled: Denotes whether the firewall policy rule is disabled. When set to true,
               the firewall policy rule is not enforced and traffic behaves as if it did
               not exist. If this is unspecified, the firewall policy rule will be
               enabled.
        :param _builtins.bool enable_logging: Denotes whether to enable logging for a particular rule.
               If logging is enabled, logs will be exported to the
               configured export destination in Stackdriver.
        :param _builtins.str rule_name: An optional name for the rule. This field is not a unique identifier
               and can be updated.
        :param _builtins.str security_profile_group: A fully-qualified URL of a SecurityProfile resource instance.
               Example:
               https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
               Must be specified if action is 'apply_security_profile_group'.
        :param Sequence['RegionNetworkFirewallPolicyWithRulesRuleTargetSecureTagArgs'] target_secure_tags: A list of secure tags that controls which instances the firewall rule
               applies to. If <code>targetSecureTag</code> are specified, then the
               firewall rule applies only to instances in the VPC network that have one
               of those EFFECTIVE secure tags, if all the target_secure_tag are in
               INEFFECTIVE state, then this rule will be ignored.
               <code>targetSecureTag</code> may not be set at the same time as
               <code>targetServiceAccounts</code>.
               If neither <code>targetServiceAccounts</code> nor
               <code>targetSecureTag</code> are specified, the firewall rule applies
               to all instances on the specified network.
               Maximum number of target label tags allowed is 256.
               Structure is documented below.
        :param Sequence[_builtins.str] target_service_accounts: A list of service accounts indicating the sets of
               instances that are applied with this rule.
        :param _builtins.bool tls_inspect: Boolean flag indicating if the traffic should be TLS decrypted.
               It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "priority", priority)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)
        if security_profile_group is not None:
            pulumi.set(__self__, "security_profile_group", security_profile_group)
        if target_secure_tags is not None:
            pulumi.set(__self__, "target_secure_tags", target_secure_tags)
        if target_service_accounts is not None:
            pulumi.set(__self__, "target_service_accounts", target_service_accounts)
        if tls_inspect is not None:
            pulumi.set(__self__, "tls_inspect", tls_inspect)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The Action to perform when the client connection triggers the rule. Can currently be either
        "allow", "deny", "apply_security_profile_group" or "goto_next".
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def match(self) -> 'outputs.RegionNetworkFirewallPolicyWithRulesRuleMatch':
        """
        A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
        Structure is documented below.
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        An integer indicating the priority of a rule in the list. The priority must be a value
        between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
        highest priority and 2147483647 is the lowest priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of the rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The direction in which this rule applies. If unspecified an INGRESS rule is created.
        Possible values are: `INGRESS`, `EGRESS`.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Denotes whether the firewall policy rule is disabled. When set to true,
        the firewall policy rule is not enforced and traffic behaves as if it did
        not exist. If this is unspecified, the firewall policy rule will be
        enabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[_builtins.bool]:
        """
        Denotes whether to enable logging for a particular rule.
        If logging is enabled, logs will be exported to the
        configured export destination in Stackdriver.
        """
        return pulumi.get(self, "enable_logging")

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[_builtins.str]:
        """
        An optional name for the rule. This field is not a unique identifier
        and can be updated.
        """
        return pulumi.get(self, "rule_name")

    @_builtins.property
    @pulumi.getter(name="securityProfileGroup")
    def security_profile_group(self) -> Optional[_builtins.str]:
        """
        A fully-qualified URL of a SecurityProfile resource instance.
        Example:
        https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
        Must be specified if action is 'apply_security_profile_group'.
        """
        return pulumi.get(self, "security_profile_group")

    @_builtins.property
    @pulumi.getter(name="targetSecureTags")
    def target_secure_tags(self) -> Optional[Sequence['outputs.RegionNetworkFirewallPolicyWithRulesRuleTargetSecureTag']]:
        """
        A list of secure tags that controls which instances the firewall rule
        applies to. If <code>targetSecureTag</code> are specified, then the
        firewall rule applies only to instances in the VPC network that have one
        of those EFFECTIVE secure tags, if all the target_secure_tag are in
        INEFFECTIVE state, then this rule will be ignored.
        <code>targetSecureTag</code> may not be set at the same time as
        <code>targetServiceAccounts</code>.
        If neither <code>targetServiceAccounts</code> nor
        <code>targetSecureTag</code> are specified, the firewall rule applies
        to all instances on the specified network.
        Maximum number of target label tags allowed is 256.
        Structure is documented below.
        """
        return pulumi.get(self, "target_secure_tags")

    @_builtins.property
    @pulumi.getter(name="targetServiceAccounts")
    def target_service_accounts(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of service accounts indicating the sets of
        instances that are applied with this rule.
        """
        return pulumi.get(self, "target_service_accounts")

    @_builtins.property
    @pulumi.getter(name="tlsInspect")
    def tls_inspect(self) -> Optional[_builtins.bool]:
        """
        Boolean flag indicating if the traffic should be TLS decrypted.
        It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
        """
        return pulumi.get(self, "tls_inspect")


@pulumi.output_type
class RegionNetworkFirewallPolicyWithRulesRuleMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layer4Configs":
            suggest = "layer4_configs"
        elif key == "destAddressGroups":
            suggest = "dest_address_groups"
        elif key == "destFqdns":
            suggest = "dest_fqdns"
        elif key == "destIpRanges":
            suggest = "dest_ip_ranges"
        elif key == "destNetworkScope":
            suggest = "dest_network_scope"
        elif key == "destRegionCodes":
            suggest = "dest_region_codes"
        elif key == "destThreatIntelligences":
            suggest = "dest_threat_intelligences"
        elif key == "srcAddressGroups":
            suggest = "src_address_groups"
        elif key == "srcFqdns":
            suggest = "src_fqdns"
        elif key == "srcIpRanges":
            suggest = "src_ip_ranges"
        elif key == "srcNetworkScope":
            suggest = "src_network_scope"
        elif key == "srcNetworks":
            suggest = "src_networks"
        elif key == "srcRegionCodes":
            suggest = "src_region_codes"
        elif key == "srcSecureTags":
            suggest = "src_secure_tags"
        elif key == "srcThreatIntelligences":
            suggest = "src_threat_intelligences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionNetworkFirewallPolicyWithRulesRuleMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionNetworkFirewallPolicyWithRulesRuleMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionNetworkFirewallPolicyWithRulesRuleMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layer4_configs: Sequence['outputs.RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4Config'],
                 dest_address_groups: Optional[Sequence[_builtins.str]] = None,
                 dest_fqdns: Optional[Sequence[_builtins.str]] = None,
                 dest_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 dest_network_scope: Optional[_builtins.str] = None,
                 dest_region_codes: Optional[Sequence[_builtins.str]] = None,
                 dest_threat_intelligences: Optional[Sequence[_builtins.str]] = None,
                 src_address_groups: Optional[Sequence[_builtins.str]] = None,
                 src_fqdns: Optional[Sequence[_builtins.str]] = None,
                 src_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 src_network_scope: Optional[_builtins.str] = None,
                 src_networks: Optional[Sequence[_builtins.str]] = None,
                 src_region_codes: Optional[Sequence[_builtins.str]] = None,
                 src_secure_tags: Optional[Sequence['outputs.RegionNetworkFirewallPolicyWithRulesRuleMatchSrcSecureTag']] = None,
                 src_threat_intelligences: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4ConfigArgs'] layer4_configs: Pairs of IP protocols and ports that the rule should match.
               Structure is documented below.
        :param Sequence[_builtins.str] dest_address_groups: Address groups which should be matched against the traffic destination.
               Maximum number of destination address groups is 10.
        :param Sequence[_builtins.str] dest_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against
               traffic destination. Maximum number of destination fqdn allowed is 100.
        :param Sequence[_builtins.str] dest_ip_ranges: Destination IP address range in CIDR format. Required for
               EGRESS rules.
        :param _builtins.str dest_network_scope: Network scope of the traffic destination.
               Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        :param Sequence[_builtins.str] dest_region_codes: Region codes whose IP addresses will be used to match for destination
               of traffic. Should be specified as 2 letter country code defined as per
               ISO 3166 alpha-2 country codes. ex."US"
               Maximum number of destination region codes allowed is 5000.
        :param Sequence[_builtins.str] dest_threat_intelligences: Names of Network Threat Intelligence lists.
               The IPs in these lists will be matched against traffic destination.
        :param Sequence[_builtins.str] src_address_groups: Address groups which should be matched against the traffic source.
               Maximum number of source address groups is 10.
        :param Sequence[_builtins.str] src_fqdns: Fully Qualified Domain Name (FQDN) which should be matched against
               traffic source. Maximum number of source fqdn allowed is 100.
        :param Sequence[_builtins.str] src_ip_ranges: Source IP address range in CIDR format. Required for
               INGRESS rules.
        :param _builtins.str src_network_scope: Network scope of the traffic source.
               Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        :param Sequence[_builtins.str] src_networks: Networks of the traffic source. It can be either a full or partial url.
        :param Sequence[_builtins.str] src_region_codes: Region codes whose IP addresses will be used to match for source
               of traffic. Should be specified as 2 letter country code defined as per
               ISO 3166 alpha-2 country codes. ex."US"
               Maximum number of source region codes allowed is 5000.
        :param Sequence['RegionNetworkFirewallPolicyWithRulesRuleMatchSrcSecureTagArgs'] src_secure_tags: List of secure tag values, which should be matched at the source
               of the traffic.
               For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
               and there is no <code>srcIpRange</code>, this rule will be ignored.
               Maximum number of source tag values allowed is 256.
               Structure is documented below.
               
               
               <a name="nested_rule_rule_match_layer4_config"></a>The `layer4_config` block supports:
        :param Sequence[_builtins.str] src_threat_intelligences: Names of Network Threat Intelligence lists.
               The IPs in these lists will be matched against traffic source.
        """
        pulumi.set(__self__, "layer4_configs", layer4_configs)
        if dest_address_groups is not None:
            pulumi.set(__self__, "dest_address_groups", dest_address_groups)
        if dest_fqdns is not None:
            pulumi.set(__self__, "dest_fqdns", dest_fqdns)
        if dest_ip_ranges is not None:
            pulumi.set(__self__, "dest_ip_ranges", dest_ip_ranges)
        if dest_network_scope is not None:
            pulumi.set(__self__, "dest_network_scope", dest_network_scope)
        if dest_region_codes is not None:
            pulumi.set(__self__, "dest_region_codes", dest_region_codes)
        if dest_threat_intelligences is not None:
            pulumi.set(__self__, "dest_threat_intelligences", dest_threat_intelligences)
        if src_address_groups is not None:
            pulumi.set(__self__, "src_address_groups", src_address_groups)
        if src_fqdns is not None:
            pulumi.set(__self__, "src_fqdns", src_fqdns)
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)
        if src_network_scope is not None:
            pulumi.set(__self__, "src_network_scope", src_network_scope)
        if src_networks is not None:
            pulumi.set(__self__, "src_networks", src_networks)
        if src_region_codes is not None:
            pulumi.set(__self__, "src_region_codes", src_region_codes)
        if src_secure_tags is not None:
            pulumi.set(__self__, "src_secure_tags", src_secure_tags)
        if src_threat_intelligences is not None:
            pulumi.set(__self__, "src_threat_intelligences", src_threat_intelligences)

    @_builtins.property
    @pulumi.getter(name="layer4Configs")
    def layer4_configs(self) -> Sequence['outputs.RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4Config']:
        """
        Pairs of IP protocols and ports that the rule should match.
        Structure is documented below.
        """
        return pulumi.get(self, "layer4_configs")

    @_builtins.property
    @pulumi.getter(name="destAddressGroups")
    def dest_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic destination.
        Maximum number of destination address groups is 10.
        """
        return pulumi.get(self, "dest_address_groups")

    @_builtins.property
    @pulumi.getter(name="destFqdns")
    def dest_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against
        traffic destination. Maximum number of destination fqdn allowed is 100.
        """
        return pulumi.get(self, "dest_fqdns")

    @_builtins.property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Destination IP address range in CIDR format. Required for
        EGRESS rules.
        """
        return pulumi.get(self, "dest_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="destNetworkScope")
    def dest_network_scope(self) -> Optional[_builtins.str]:
        """
        Network scope of the traffic destination.
        Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        """
        return pulumi.get(self, "dest_network_scope")

    @_builtins.property
    @pulumi.getter(name="destRegionCodes")
    def dest_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for destination
        of traffic. Should be specified as 2 letter country code defined as per
        ISO 3166 alpha-2 country codes. ex."US"
        Maximum number of destination region codes allowed is 5000.
        """
        return pulumi.get(self, "dest_region_codes")

    @_builtins.property
    @pulumi.getter(name="destThreatIntelligences")
    def dest_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists.
        The IPs in these lists will be matched against traffic destination.
        """
        return pulumi.get(self, "dest_threat_intelligences")

    @_builtins.property
    @pulumi.getter(name="srcAddressGroups")
    def src_address_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Address groups which should be matched against the traffic source.
        Maximum number of source address groups is 10.
        """
        return pulumi.get(self, "src_address_groups")

    @_builtins.property
    @pulumi.getter(name="srcFqdns")
    def src_fqdns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Fully Qualified Domain Name (FQDN) which should be matched against
        traffic source. Maximum number of source fqdn allowed is 100.
        """
        return pulumi.get(self, "src_fqdns")

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Source IP address range in CIDR format. Required for
        INGRESS rules.
        """
        return pulumi.get(self, "src_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="srcNetworkScope")
    def src_network_scope(self) -> Optional[_builtins.str]:
        """
        Network scope of the traffic source.
        Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        """
        return pulumi.get(self, "src_network_scope")

    @_builtins.property
    @pulumi.getter(name="srcNetworks")
    def src_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Networks of the traffic source. It can be either a full or partial url.
        """
        return pulumi.get(self, "src_networks")

    @_builtins.property
    @pulumi.getter(name="srcRegionCodes")
    def src_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Region codes whose IP addresses will be used to match for source
        of traffic. Should be specified as 2 letter country code defined as per
        ISO 3166 alpha-2 country codes. ex."US"
        Maximum number of source region codes allowed is 5000.
        """
        return pulumi.get(self, "src_region_codes")

    @_builtins.property
    @pulumi.getter(name="srcSecureTags")
    def src_secure_tags(self) -> Optional[Sequence['outputs.RegionNetworkFirewallPolicyWithRulesRuleMatchSrcSecureTag']]:
        """
        List of secure tag values, which should be matched at the source
        of the traffic.
        For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
        and there is no <code>srcIpRange</code>, this rule will be ignored.
        Maximum number of source tag values allowed is 256.
        Structure is documented below.


        <a name="nested_rule_rule_match_layer4_config"></a>The `layer4_config` block supports:
        """
        return pulumi.get(self, "src_secure_tags")

    @_builtins.property
    @pulumi.getter(name="srcThreatIntelligences")
    def src_threat_intelligences(self) -> Optional[Sequence[_builtins.str]]:
        """
        Names of Network Threat Intelligence lists.
        The IPs in these lists will be matched against traffic source.
        """
        return pulumi.get(self, "src_threat_intelligences")


@pulumi.output_type
class RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: _builtins.str,
                 ports: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str ip_protocol: (Output)
               The IP protocol to which this rule applies. The protocol
               type is required when creating a firewall rule.
               This value can either be one of the following well
               known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
               or the IP protocol number.
        :param Sequence[_builtins.str] ports: (Output)
               An optional list of ports to which this rule applies. This field
               is only applicable for UDP or TCP protocol. Each entry must be
               either an integer or a range. If not specified, this rule
               applies to connections through any port.
               Example inputs include: ["22"], ["80","443"], and
               ["12345-12349"].
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> _builtins.str:
        """
        (Output)
        The IP protocol to which this rule applies. The protocol
        type is required when creating a firewall rule.
        This value can either be one of the following well
        known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
        or the IP protocol number.
        """
        return pulumi.get(self, "ip_protocol")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        An optional list of ports to which this rule applies. This field
        is only applicable for UDP or TCP protocol. Each entry must be
        either an integer or a range. If not specified, this rule
        applies to connections through any port.
        Example inputs include: ["22"], ["80","443"], and
        ["12345-12349"].
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class RegionNetworkFirewallPolicyWithRulesRuleMatchSrcSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
               @pattern tagValues/[0-9]+
        :param _builtins.str state: (Output)
               [Output Only] State of the secure tag, either `EFFECTIVE` or
               `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
               or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        @pattern tagValues/[0-9]+
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        [Output Only] State of the secure tag, either `EFFECTIVE` or
        `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
        or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class RegionNetworkFirewallPolicyWithRulesRuleTargetSecureTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the secure tag, created with TagManager's TagValue API.
               @pattern tagValues/[0-9]+
        :param _builtins.str state: (Output)
               [Output Only] State of the secure tag, either `EFFECTIVE` or
               `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
               or its network is deleted.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the secure tag, created with TagManager's TagValue API.
        @pattern tagValues/[0-9]+
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        [Output Only] State of the secure tag, either `EFFECTIVE` or
        `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
        or its network is deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class RegionPerInstanceConfigPreservedState(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalIps":
            suggest = "external_ips"
        elif key == "internalIps":
            suggest = "internal_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionPerInstanceConfigPreservedState. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionPerInstanceConfigPreservedState.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionPerInstanceConfigPreservedState.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disks: Optional[Sequence['outputs.RegionPerInstanceConfigPreservedStateDisk']] = None,
                 external_ips: Optional[Sequence['outputs.RegionPerInstanceConfigPreservedStateExternalIp']] = None,
                 internal_ips: Optional[Sequence['outputs.RegionPerInstanceConfigPreservedStateInternalIp']] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Sequence['RegionPerInstanceConfigPreservedStateDiskArgs'] disks: Stateful disks for the instance.
               Structure is documented below.
        :param Sequence['RegionPerInstanceConfigPreservedStateExternalIpArgs'] external_ips: Preserved external IPs defined for this instance. This map is keyed with the name of the network interface.
               Structure is documented below.
        :param Sequence['RegionPerInstanceConfigPreservedStateInternalIpArgs'] internal_ips: Preserved internal IPs defined for this instance. This map is keyed with the name of the network interface.
               Structure is documented below.
        :param Mapping[str, _builtins.str] metadata: Preserved metadata defined for this instance. This is a list of key->value pairs.
        """
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if external_ips is not None:
            pulumi.set(__self__, "external_ips", external_ips)
        if internal_ips is not None:
            pulumi.set(__self__, "internal_ips", internal_ips)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def disks(self) -> Optional[Sequence['outputs.RegionPerInstanceConfigPreservedStateDisk']]:
        """
        Stateful disks for the instance.
        Structure is documented below.
        """
        return pulumi.get(self, "disks")

    @_builtins.property
    @pulumi.getter(name="externalIps")
    def external_ips(self) -> Optional[Sequence['outputs.RegionPerInstanceConfigPreservedStateExternalIp']]:
        """
        Preserved external IPs defined for this instance. This map is keyed with the name of the network interface.
        Structure is documented below.
        """
        return pulumi.get(self, "external_ips")

    @_builtins.property
    @pulumi.getter(name="internalIps")
    def internal_ips(self) -> Optional[Sequence['outputs.RegionPerInstanceConfigPreservedStateInternalIp']]:
        """
        Preserved internal IPs defined for this instance. This map is keyed with the name of the network interface.
        Structure is documented below.
        """
        return pulumi.get(self, "internal_ips")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Preserved metadata defined for this instance. This is a list of key->value pairs.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class RegionPerInstanceConfigPreservedStateDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteRule":
            suggest = "delete_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionPerInstanceConfigPreservedStateDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionPerInstanceConfigPreservedStateDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionPerInstanceConfigPreservedStateDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 source: _builtins.str,
                 delete_rule: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
        :param _builtins.str source: The URI of an existing persistent disk to attach under the specified device-name in the format
               `projects/project-id/zones/zone/disks/disk-name`.
        :param _builtins.str delete_rule: A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
               The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
               `NEVER` - detach the disk when the VM is deleted, but do not delete the disk.
               `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
               deleted from the instance group.
               Default value is `NEVER`.
               Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
        :param _builtins.str mode: The mode of the disk.
               Default value is `READ_WRITE`.
               Possible values are: `READ_ONLY`, `READ_WRITE`.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "source", source)
        if delete_rule is not None:
            pulumi.set(__self__, "delete_rule", delete_rule)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The URI of an existing persistent disk to attach under the specified device-name in the format
        `projects/project-id/zones/zone/disks/disk-name`.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> Optional[_builtins.str]:
        """
        A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
        The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
        `NEVER` - detach the disk when the VM is deleted, but do not delete the disk.
        `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
        deleted from the instance group.
        Default value is `NEVER`.
        Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
        """
        return pulumi.get(self, "delete_rule")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The mode of the disk.
        Default value is `READ_WRITE`.
        Possible values are: `READ_ONLY`, `READ_WRITE`.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class RegionPerInstanceConfigPreservedStateExternalIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceName":
            suggest = "interface_name"
        elif key == "autoDelete":
            suggest = "auto_delete"
        elif key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionPerInstanceConfigPreservedStateExternalIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionPerInstanceConfigPreservedStateExternalIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionPerInstanceConfigPreservedStateExternalIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_name: _builtins.str,
                 auto_delete: Optional[_builtins.str] = None,
                 ip_address: Optional['outputs.RegionPerInstanceConfigPreservedStateExternalIpIpAddress'] = None):
        """
        :param _builtins.str interface_name: The identifier for this object. Format specified above.
        :param _builtins.str auto_delete: These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
               Default value is `NEVER`.
               Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
        :param 'RegionPerInstanceConfigPreservedStateExternalIpIpAddressArgs' ip_address: Ip address representation
               Structure is documented below.
        """
        pulumi.set(__self__, "interface_name", interface_name)
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "interface_name")

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[_builtins.str]:
        """
        These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
        Default value is `NEVER`.
        Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional['outputs.RegionPerInstanceConfigPreservedStateExternalIpIpAddress']:
        """
        Ip address representation
        Structure is documented below.
        """
        return pulumi.get(self, "ip_address")


@pulumi.output_type
class RegionPerInstanceConfigPreservedStateExternalIpIpAddress(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: The URL of the reservation for this IP address.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        The URL of the reservation for this IP address.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class RegionPerInstanceConfigPreservedStateInternalIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceName":
            suggest = "interface_name"
        elif key == "autoDelete":
            suggest = "auto_delete"
        elif key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionPerInstanceConfigPreservedStateInternalIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionPerInstanceConfigPreservedStateInternalIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionPerInstanceConfigPreservedStateInternalIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_name: _builtins.str,
                 auto_delete: Optional[_builtins.str] = None,
                 ip_address: Optional['outputs.RegionPerInstanceConfigPreservedStateInternalIpIpAddress'] = None):
        """
        :param _builtins.str interface_name: The identifier for this object. Format specified above.
        :param _builtins.str auto_delete: These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
               Default value is `NEVER`.
               Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
        :param 'RegionPerInstanceConfigPreservedStateInternalIpIpAddressArgs' ip_address: Ip address representation
               Structure is documented below.
        """
        pulumi.set(__self__, "interface_name", interface_name)
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "interface_name")

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[_builtins.str]:
        """
        These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
        Default value is `NEVER`.
        Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional['outputs.RegionPerInstanceConfigPreservedStateInternalIpIpAddress']:
        """
        Ip address representation
        Structure is documented below.
        """
        return pulumi.get(self, "ip_address")


@pulumi.output_type
class RegionPerInstanceConfigPreservedStateInternalIpIpAddress(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: The URL of the reservation for this IP address.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        The URL of the reservation for this IP address.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class RegionResizeRequestRequestedRunDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 600 to 604800 inclusive. Note: minimum and maximum allowed range for requestedRunDuration is 10 minutes (600 seconds) and 7 days(604800 seconds) correspondingly.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 600 to 604800 inclusive. Note: minimum and maximum allowed range for requestedRunDuration is 10 minutes (600 seconds) and 7 days(604800 seconds) correspondingly.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionResizeRequestStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastAttempts":
            suggest = "last_attempts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionResizeRequestStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionResizeRequestStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionResizeRequestStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 errors: Optional[Sequence['outputs.RegionResizeRequestStatusError']] = None,
                 last_attempts: Optional[Sequence['outputs.RegionResizeRequestStatusLastAttempt']] = None):
        """
        :param Sequence['RegionResizeRequestStatusErrorArgs'] errors: (Output)
               Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.
               Structure is documented below.
        :param Sequence['RegionResizeRequestStatusLastAttemptArgs'] last_attempts: (Output)
               Information about the last attempt to fulfill the request. The value is temporary since the ResizeRequest can retry, as long as it's still active and the last attempt value can either be cleared or replaced with a different error. Since ResizeRequest retries infrequently, the value may be stale and no longer show an active problem. The value is cleared when ResizeRequest transitions to the final state (becomes inactive). If the final state is FAILED the error describing it will be storred in the "error" field only.
               Structure is documented below.
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if last_attempts is not None:
            pulumi.set(__self__, "last_attempts", last_attempts)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusError']]:
        """
        (Output)
        Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.
        Structure is documented below.
        """
        return pulumi.get(self, "errors")

    @_builtins.property
    @pulumi.getter(name="lastAttempts")
    def last_attempts(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusLastAttempt']]:
        """
        (Output)
        Information about the last attempt to fulfill the request. The value is temporary since the ResizeRequest can retry, as long as it's still active and the last attempt value can either be cleared or replaced with a different error. Since ResizeRequest retries infrequently, the value may be stale and no longer show an active problem. The value is cleared when ResizeRequest transitions to the final state (becomes inactive). If the final state is FAILED the error describing it will be storred in the "error" field only.
        Structure is documented below.
        """
        return pulumi.get(self, "last_attempts")


@pulumi.output_type
class RegionResizeRequestStatusError(dict):
    def __init__(__self__, *,
                 errors: Optional[Sequence['outputs.RegionResizeRequestStatusErrorError']] = None):
        """
        :param Sequence['RegionResizeRequestStatusErrorErrorArgs'] errors: (Output)
               The array of errors encountered while processing this operation.
               Structure is documented below.
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusErrorError']]:
        """
        (Output)
        The array of errors encountered while processing this operation.
        Structure is documented below.
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class RegionResizeRequestStatusErrorError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorDetails":
            suggest = "error_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionResizeRequestStatusErrorError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionResizeRequestStatusErrorError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionResizeRequestStatusErrorError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 error_details: Optional[Sequence['outputs.RegionResizeRequestStatusErrorErrorErrorDetail']] = None,
                 location: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None):
        """
        :param _builtins.str code: (Output)
               The error type identifier for this error.
        :param Sequence['RegionResizeRequestStatusErrorErrorErrorDetailArgs'] error_details: (Output)
               An array of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
               Structure is documented below.
        :param _builtins.str location: (Output)
               Indicates the field in the request that caused the error. This property is optional.
        :param _builtins.str message: (Output)
               The localized error message in the above locale.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if error_details is not None:
            pulumi.set(__self__, "error_details", error_details)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The error type identifier for this error.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter(name="errorDetails")
    def error_details(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusErrorErrorErrorDetail']]:
        """
        (Output)
        An array of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
        Structure is documented below.
        """
        return pulumi.get(self, "error_details")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        (Output)
        Indicates the field in the request that caused the error. This property is optional.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        (Output)
        The localized error message in the above locale.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class RegionResizeRequestStatusErrorErrorErrorDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorInfos":
            suggest = "error_infos"
        elif key == "localizedMessages":
            suggest = "localized_messages"
        elif key == "quotaInfos":
            suggest = "quota_infos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionResizeRequestStatusErrorErrorErrorDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionResizeRequestStatusErrorErrorErrorDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionResizeRequestStatusErrorErrorErrorDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_infos: Optional[Sequence['outputs.RegionResizeRequestStatusErrorErrorErrorDetailErrorInfo']] = None,
                 helps: Optional[Sequence['outputs.RegionResizeRequestStatusErrorErrorErrorDetailHelp']] = None,
                 localized_messages: Optional[Sequence['outputs.RegionResizeRequestStatusErrorErrorErrorDetailLocalizedMessage']] = None,
                 quota_infos: Optional[Sequence['outputs.RegionResizeRequestStatusErrorErrorErrorDetailQuotaInfo']] = None):
        """
        :param Sequence['RegionResizeRequestStatusErrorErrorErrorDetailErrorInfoArgs'] error_infos: (Output)
               A nested object resource.
               Structure is documented below.
        :param Sequence['RegionResizeRequestStatusErrorErrorErrorDetailHelpArgs'] helps: (Output)
               A nested object resource.
               Structure is documented below.
        :param Sequence['RegionResizeRequestStatusErrorErrorErrorDetailLocalizedMessageArgs'] localized_messages: (Output)
               A nested object resource.
               Structure is documented below.
        :param Sequence['RegionResizeRequestStatusErrorErrorErrorDetailQuotaInfoArgs'] quota_infos: (Output)
               A nested object resource.
               Structure is documented below.
        """
        if error_infos is not None:
            pulumi.set(__self__, "error_infos", error_infos)
        if helps is not None:
            pulumi.set(__self__, "helps", helps)
        if localized_messages is not None:
            pulumi.set(__self__, "localized_messages", localized_messages)
        if quota_infos is not None:
            pulumi.set(__self__, "quota_infos", quota_infos)

    @_builtins.property
    @pulumi.getter(name="errorInfos")
    def error_infos(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusErrorErrorErrorDetailErrorInfo']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "error_infos")

    @_builtins.property
    @pulumi.getter
    def helps(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusErrorErrorErrorDetailHelp']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "helps")

    @_builtins.property
    @pulumi.getter(name="localizedMessages")
    def localized_messages(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusErrorErrorErrorDetailLocalizedMessage']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "localized_messages")

    @_builtins.property
    @pulumi.getter(name="quotaInfos")
    def quota_infos(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusErrorErrorErrorDetailQuotaInfo']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "quota_infos")


@pulumi.output_type
class RegionResizeRequestStatusErrorErrorErrorDetailErrorInfo(dict):
    def __init__(__self__, *,
                 domain: Optional[_builtins.str] = None,
                 metadatas: Optional[Mapping[str, _builtins.str]] = None,
                 reason: Optional[_builtins.str] = None):
        """
        :param _builtins.str domain: (Output)
               The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com".
        :param Mapping[str, _builtins.str] metadatas: (Output)
               Additional structured details about this error.
        :param _builtins.str reason: (Output)
               The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        (Output)
        The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com".
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def metadatas(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Output)
        Additional structured details about this error.
        """
        return pulumi.get(self, "metadatas")

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[_builtins.str]:
        """
        (Output)
        The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors.
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class RegionResizeRequestStatusErrorErrorErrorDetailHelp(dict):
    def __init__(__self__, *,
                 links: Optional[Sequence['outputs.RegionResizeRequestStatusErrorErrorErrorDetailHelpLink']] = None):
        """
        :param Sequence['RegionResizeRequestStatusErrorErrorErrorDetailHelpLinkArgs'] links: (Output)
               A nested object resource.
               Structure is documented below.
        """
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusErrorErrorErrorDetailHelpLink']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "links")


@pulumi.output_type
class RegionResizeRequestStatusErrorErrorErrorDetailHelpLink(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: An optional description of this resize-request.
        :param _builtins.str url: (Output)
               The URL of the link.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resize-request.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        (Output)
        The URL of the link.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class RegionResizeRequestStatusErrorErrorErrorDetailLocalizedMessage(dict):
    def __init__(__self__, *,
                 locale: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None):
        """
        :param _builtins.str locale: (Output)
               The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"
        :param _builtins.str message: (Output)
               The localized error message in the above locale.
        """
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def locale(self) -> Optional[_builtins.str]:
        """
        (Output)
        The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"
        """
        return pulumi.get(self, "locale")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        (Output)
        The localized error message in the above locale.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class RegionResizeRequestStatusErrorErrorErrorDetailQuotaInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "futureLimit":
            suggest = "future_limit"
        elif key == "limitName":
            suggest = "limit_name"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "rolloutStatus":
            suggest = "rollout_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionResizeRequestStatusErrorErrorErrorDetailQuotaInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionResizeRequestStatusErrorErrorErrorDetailQuotaInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionResizeRequestStatusErrorErrorErrorDetailQuotaInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimensions: Optional[Mapping[str, _builtins.str]] = None,
                 future_limit: Optional[_builtins.int] = None,
                 limit: Optional[_builtins.int] = None,
                 limit_name: Optional[_builtins.str] = None,
                 metric_name: Optional[_builtins.str] = None,
                 rollout_status: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] dimensions: (Output)
               The map holding related quota dimensions
        :param _builtins.int future_limit: (Output)
               Future quota limit being rolled out. The limit's unit depends on the quota type or metric.
        :param _builtins.int limit: (Output)
               Current effective quota limit. The limit's unit depends on the quota type or metric.
        :param _builtins.str limit_name: (Output)
               The name of the quota limit.
        :param _builtins.str metric_name: (Output)
               The Compute Engine quota metric name.
        :param _builtins.str rollout_status: (Output)
               Rollout status of the future quota limit.
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if future_limit is not None:
            pulumi.set(__self__, "future_limit", future_limit)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if limit_name is not None:
            pulumi.set(__self__, "limit_name", limit_name)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if rollout_status is not None:
            pulumi.set(__self__, "rollout_status", rollout_status)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Output)
        The map holding related quota dimensions
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="futureLimit")
    def future_limit(self) -> Optional[_builtins.int]:
        """
        (Output)
        Future quota limit being rolled out. The limit's unit depends on the quota type or metric.
        """
        return pulumi.get(self, "future_limit")

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.int]:
        """
        (Output)
        Current effective quota limit. The limit's unit depends on the quota type or metric.
        """
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter(name="limitName")
    def limit_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the quota limit.
        """
        return pulumi.get(self, "limit_name")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Compute Engine quota metric name.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="rolloutStatus")
    def rollout_status(self) -> Optional[_builtins.str]:
        """
        (Output)
        Rollout status of the future quota limit.
        """
        return pulumi.get(self, "rollout_status")


@pulumi.output_type
class RegionResizeRequestStatusLastAttempt(dict):
    def __init__(__self__, *,
                 errors: Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptError']] = None):
        """
        :param Sequence['RegionResizeRequestStatusLastAttemptErrorArgs'] errors: (Output)
               Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.
               Structure is documented below.
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptError']]:
        """
        (Output)
        Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.
        Structure is documented below.
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class RegionResizeRequestStatusLastAttemptError(dict):
    def __init__(__self__, *,
                 errors: Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptErrorError']] = None):
        """
        :param Sequence['RegionResizeRequestStatusLastAttemptErrorErrorArgs'] errors: (Output)
               The array of errors encountered while processing this operation.
               Structure is documented below.
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptErrorError']]:
        """
        (Output)
        The array of errors encountered while processing this operation.
        Structure is documented below.
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class RegionResizeRequestStatusLastAttemptErrorError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorDetails":
            suggest = "error_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionResizeRequestStatusLastAttemptErrorError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionResizeRequestStatusLastAttemptErrorError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionResizeRequestStatusLastAttemptErrorError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 error_details: Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetail']] = None,
                 location: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None):
        """
        :param _builtins.str code: (Output)
               The error type identifier for this error.
        :param Sequence['RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailArgs'] error_details: (Output)
               An array of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
               Structure is documented below.
        :param _builtins.str location: (Output)
               Indicates the field in the request that caused the error. This property is optional.
        :param _builtins.str message: (Output)
               The localized error message in the above locale.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if error_details is not None:
            pulumi.set(__self__, "error_details", error_details)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The error type identifier for this error.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter(name="errorDetails")
    def error_details(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetail']]:
        """
        (Output)
        An array of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
        Structure is documented below.
        """
        return pulumi.get(self, "error_details")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        (Output)
        Indicates the field in the request that caused the error. This property is optional.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        (Output)
        The localized error message in the above locale.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class RegionResizeRequestStatusLastAttemptErrorErrorErrorDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorInfos":
            suggest = "error_infos"
        elif key == "localizedMessages":
            suggest = "localized_messages"
        elif key == "quotaInfos":
            suggest = "quota_infos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionResizeRequestStatusLastAttemptErrorErrorErrorDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionResizeRequestStatusLastAttemptErrorErrorErrorDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionResizeRequestStatusLastAttemptErrorErrorErrorDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_infos: Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailErrorInfo']] = None,
                 helps: Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailHelp']] = None,
                 localized_messages: Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailLocalizedMessage']] = None,
                 quota_infos: Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo']] = None):
        """
        :param Sequence['RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailErrorInfoArgs'] error_infos: (Output)
               A nested object resource.
               Structure is documented below.
        :param Sequence['RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpArgs'] helps: (Output)
               A nested object resource.
               Structure is documented below.
        :param Sequence['RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailLocalizedMessageArgs'] localized_messages: (Output)
               A nested object resource.
               Structure is documented below.
        :param Sequence['RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfoArgs'] quota_infos: (Output)
               A nested object resource.
               Structure is documented below.
        """
        if error_infos is not None:
            pulumi.set(__self__, "error_infos", error_infos)
        if helps is not None:
            pulumi.set(__self__, "helps", helps)
        if localized_messages is not None:
            pulumi.set(__self__, "localized_messages", localized_messages)
        if quota_infos is not None:
            pulumi.set(__self__, "quota_infos", quota_infos)

    @_builtins.property
    @pulumi.getter(name="errorInfos")
    def error_infos(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailErrorInfo']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "error_infos")

    @_builtins.property
    @pulumi.getter
    def helps(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailHelp']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "helps")

    @_builtins.property
    @pulumi.getter(name="localizedMessages")
    def localized_messages(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailLocalizedMessage']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "localized_messages")

    @_builtins.property
    @pulumi.getter(name="quotaInfos")
    def quota_infos(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "quota_infos")


@pulumi.output_type
class RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailErrorInfo(dict):
    def __init__(__self__, *,
                 domain: Optional[_builtins.str] = None,
                 metadatas: Optional[Mapping[str, _builtins.str]] = None,
                 reason: Optional[_builtins.str] = None):
        """
        :param _builtins.str domain: (Output)
               The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com".
        :param Mapping[str, _builtins.str] metadatas: (Output)
               Additional structured details about this error.
        :param _builtins.str reason: (Output)
               The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        (Output)
        The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com".
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def metadatas(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Output)
        Additional structured details about this error.
        """
        return pulumi.get(self, "metadatas")

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[_builtins.str]:
        """
        (Output)
        The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors.
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailHelp(dict):
    def __init__(__self__, *,
                 links: Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpLink']] = None):
        """
        :param Sequence['RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpLinkArgs'] links: (Output)
               A nested object resource.
               Structure is documented below.
        """
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpLink']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "links")


@pulumi.output_type
class RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpLink(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: An optional description of this resize-request.
        :param _builtins.str url: (Output)
               The URL of the link.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resize-request.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        (Output)
        The URL of the link.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailLocalizedMessage(dict):
    def __init__(__self__, *,
                 locale: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None):
        """
        :param _builtins.str locale: (Output)
               The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"
        :param _builtins.str message: (Output)
               The localized error message in the above locale.
        """
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def locale(self) -> Optional[_builtins.str]:
        """
        (Output)
        The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"
        """
        return pulumi.get(self, "locale")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        (Output)
        The localized error message in the above locale.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "futureLimit":
            suggest = "future_limit"
        elif key == "limitName":
            suggest = "limit_name"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "rolloutStatus":
            suggest = "rollout_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimensions: Optional[Mapping[str, _builtins.str]] = None,
                 future_limit: Optional[_builtins.int] = None,
                 limit: Optional[_builtins.int] = None,
                 limit_name: Optional[_builtins.str] = None,
                 metric_name: Optional[_builtins.str] = None,
                 rollout_status: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] dimensions: (Output)
               The map holding related quota dimensions
        :param _builtins.int future_limit: (Output)
               Future quota limit being rolled out. The limit's unit depends on the quota type or metric.
        :param _builtins.int limit: (Output)
               Current effective quota limit. The limit's unit depends on the quota type or metric.
        :param _builtins.str limit_name: (Output)
               The name of the quota limit.
        :param _builtins.str metric_name: (Output)
               The Compute Engine quota metric name.
        :param _builtins.str rollout_status: (Output)
               Rollout status of the future quota limit.
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if future_limit is not None:
            pulumi.set(__self__, "future_limit", future_limit)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if limit_name is not None:
            pulumi.set(__self__, "limit_name", limit_name)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if rollout_status is not None:
            pulumi.set(__self__, "rollout_status", rollout_status)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Output)
        The map holding related quota dimensions
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="futureLimit")
    def future_limit(self) -> Optional[_builtins.int]:
        """
        (Output)
        Future quota limit being rolled out. The limit's unit depends on the quota type or metric.
        """
        return pulumi.get(self, "future_limit")

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.int]:
        """
        (Output)
        Current effective quota limit. The limit's unit depends on the quota type or metric.
        """
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter(name="limitName")
    def limit_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the quota limit.
        """
        return pulumi.get(self, "limit_name")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Compute Engine quota metric name.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="rolloutStatus")
    def rollout_status(self) -> Optional[_builtins.str]:
        """
        (Output)
        Rollout status of the future quota limit.
        """
        return pulumi.get(self, "rollout_status")


@pulumi.output_type
class RegionSecurityPolicyAdvancedOptionsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonCustomConfig":
            suggest = "json_custom_config"
        elif key == "jsonParsing":
            suggest = "json_parsing"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "requestBodyInspectionSize":
            suggest = "request_body_inspection_size"
        elif key == "userIpRequestHeaders":
            suggest = "user_ip_request_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionSecurityPolicyAdvancedOptionsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionSecurityPolicyAdvancedOptionsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionSecurityPolicyAdvancedOptionsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 json_custom_config: Optional['outputs.RegionSecurityPolicyAdvancedOptionsConfigJsonCustomConfig'] = None,
                 json_parsing: Optional[_builtins.str] = None,
                 log_level: Optional[_builtins.str] = None,
                 request_body_inspection_size: Optional[_builtins.str] = None,
                 user_ip_request_headers: Optional[Sequence[_builtins.str]] = None):
        """
        :param 'RegionSecurityPolicyAdvancedOptionsConfigJsonCustomConfigArgs' json_custom_config: Custom configuration to apply the JSON parsing. Only applicable when JSON parsing is set to STANDARD.
               Structure is documented below.
        :param _builtins.str json_parsing: JSON body parsing. Supported values include: "DISABLED", "STANDARD", "STANDARD_WITH_GRAPHQL".
               Possible values are: `DISABLED`, `STANDARD`, `STANDARD_WITH_GRAPHQL`.
        :param _builtins.str log_level: Logging level. Supported values include: "NORMAL", "VERBOSE".
               Possible values are: `NORMAL`, `VERBOSE`.
        :param _builtins.str request_body_inspection_size: The maximum request size chosen by the customer with Waf enabled. Values supported are "8KB", "16KB, "32KB", "48KB" and "64KB".
               Values are case insensitive.
               Possible values are: `8KB`, `16KB`, `32KB`, `48KB`, `64KB`.
        :param Sequence[_builtins.str] user_ip_request_headers: An optional list of case-insensitive request header names to use for resolving the callers client IP address.
        """
        if json_custom_config is not None:
            pulumi.set(__self__, "json_custom_config", json_custom_config)
        if json_parsing is not None:
            pulumi.set(__self__, "json_parsing", json_parsing)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if request_body_inspection_size is not None:
            pulumi.set(__self__, "request_body_inspection_size", request_body_inspection_size)
        if user_ip_request_headers is not None:
            pulumi.set(__self__, "user_ip_request_headers", user_ip_request_headers)

    @_builtins.property
    @pulumi.getter(name="jsonCustomConfig")
    def json_custom_config(self) -> Optional['outputs.RegionSecurityPolicyAdvancedOptionsConfigJsonCustomConfig']:
        """
        Custom configuration to apply the JSON parsing. Only applicable when JSON parsing is set to STANDARD.
        Structure is documented below.
        """
        return pulumi.get(self, "json_custom_config")

    @_builtins.property
    @pulumi.getter(name="jsonParsing")
    def json_parsing(self) -> Optional[_builtins.str]:
        """
        JSON body parsing. Supported values include: "DISABLED", "STANDARD", "STANDARD_WITH_GRAPHQL".
        Possible values are: `DISABLED`, `STANDARD`, `STANDARD_WITH_GRAPHQL`.
        """
        return pulumi.get(self, "json_parsing")

    @_builtins.property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[_builtins.str]:
        """
        Logging level. Supported values include: "NORMAL", "VERBOSE".
        Possible values are: `NORMAL`, `VERBOSE`.
        """
        return pulumi.get(self, "log_level")

    @_builtins.property
    @pulumi.getter(name="requestBodyInspectionSize")
    def request_body_inspection_size(self) -> Optional[_builtins.str]:
        """
        The maximum request size chosen by the customer with Waf enabled. Values supported are "8KB", "16KB, "32KB", "48KB" and "64KB".
        Values are case insensitive.
        Possible values are: `8KB`, `16KB`, `32KB`, `48KB`, `64KB`.
        """
        return pulumi.get(self, "request_body_inspection_size")

    @_builtins.property
    @pulumi.getter(name="userIpRequestHeaders")
    def user_ip_request_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        An optional list of case-insensitive request header names to use for resolving the callers client IP address.
        """
        return pulumi.get(self, "user_ip_request_headers")


@pulumi.output_type
class RegionSecurityPolicyAdvancedOptionsConfigJsonCustomConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentTypes":
            suggest = "content_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionSecurityPolicyAdvancedOptionsConfigJsonCustomConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionSecurityPolicyAdvancedOptionsConfigJsonCustomConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionSecurityPolicyAdvancedOptionsConfigJsonCustomConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_types: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] content_types: A list of custom Content-Type header values to apply the JSON parsing.
        """
        pulumi.set(__self__, "content_types", content_types)

    @_builtins.property
    @pulumi.getter(name="contentTypes")
    def content_types(self) -> Sequence[_builtins.str]:
        """
        A list of custom Content-Type header values to apply the JSON parsing.
        """
        return pulumi.get(self, "content_types")


@pulumi.output_type
class RegionSecurityPolicyDdosProtectionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ddosProtection":
            suggest = "ddos_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionSecurityPolicyDdosProtectionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionSecurityPolicyDdosProtectionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionSecurityPolicyDdosProtectionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ddos_protection: _builtins.str):
        """
        :param _builtins.str ddos_protection: Google Cloud Armor offers the following options to help protect systems against DDoS attacks:
               - STANDARD: basic always-on protection for network load balancers, protocol forwarding, or VMs with public IP addresses.
               - ADVANCED: additional protections for Managed Protection Plus subscribers who use network load balancers, protocol forwarding, or VMs with public IP addresses.
               - ADVANCED_PREVIEW: flag to enable the security policy in preview mode.
               Possible values are: `ADVANCED`, `ADVANCED_PREVIEW`, `STANDARD`.
        """
        pulumi.set(__self__, "ddos_protection", ddos_protection)

    @_builtins.property
    @pulumi.getter(name="ddosProtection")
    def ddos_protection(self) -> _builtins.str:
        """
        Google Cloud Armor offers the following options to help protect systems against DDoS attacks:
        - STANDARD: basic always-on protection for network load balancers, protocol forwarding, or VMs with public IP addresses.
        - ADVANCED: additional protections for Managed Protection Plus subscribers who use network load balancers, protocol forwarding, or VMs with public IP addresses.
        - ADVANCED_PREVIEW: flag to enable the security policy in preview mode.
        Possible values are: `ADVANCED`, `ADVANCED_PREVIEW`, `STANDARD`.
        """
        return pulumi.get(self, "ddos_protection")


@pulumi.output_type
class RegionSecurityPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkMatch":
            suggest = "network_match"
        elif key == "preconfiguredWafConfig":
            suggest = "preconfigured_waf_config"
        elif key == "rateLimitOptions":
            suggest = "rate_limit_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionSecurityPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionSecurityPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionSecurityPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 priority: _builtins.int,
                 description: Optional[_builtins.str] = None,
                 match: Optional['outputs.RegionSecurityPolicyRuleMatch'] = None,
                 network_match: Optional['outputs.RegionSecurityPolicyRuleNetworkMatch'] = None,
                 preconfigured_waf_config: Optional['outputs.RegionSecurityPolicyRulePreconfiguredWafConfig'] = None,
                 preview: Optional[_builtins.bool] = None,
                 rate_limit_options: Optional['outputs.RegionSecurityPolicyRuleRateLimitOptions'] = None):
        """
        :param _builtins.str action: The Action to perform when the rule is matched. The following are the valid actions:
               * allow: allow access to target.
               * deny(STATUS): deny access to target, returns the HTTP response code specified. Valid values for STATUS are 403, 404, and 502.
               * rate_based_ban: limit client traffic to the configured threshold and ban the client if the traffic exceeds the threshold. Configure parameters for this action in RateLimitOptions. Requires rateLimitOptions to be set.
               * redirect: redirect to a different target. This can either be an internal reCAPTCHA redirect, or an external URL-based redirect via a 302 response. Parameters for this action can be configured via redirectOptions. This action is only supported in Global Security Policies of type CLOUD_ARMOR.
               * throttle: limit client traffic to the configured threshold. Configure parameters for this action in rateLimitOptions. Requires rateLimitOptions to be set for this.
        :param _builtins.int priority: An integer indicating the priority of a rule in the list.
               The priority must be a positive value between 0 and 2147483647.
               Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest priority.
        :param _builtins.str description: An optional description of this resource. Provide this property when you create the resource.
        :param 'RegionSecurityPolicyRuleMatchArgs' match: A match condition that incoming traffic is evaluated against.
               If it evaluates to true, the corresponding 'action' is enforced.
               Structure is documented below.
        :param 'RegionSecurityPolicyRuleNetworkMatchArgs' network_match: A match condition that incoming packets are evaluated against for CLOUD_ARMOR_NETWORK security policies. If it matches, the corresponding 'action' is enforced.
               The match criteria for a rule consists of built-in match fields (like 'srcIpRanges') and potentially multiple user-defined match fields ('userDefinedFields').
               Field values may be extracted directly from the packet or derived from it (e.g. 'srcRegionCodes'). Some fields may not be present in every packet (e.g. 'srcPorts'). A user-defined field is only present if the base header is found in the packet and the entire field is in bounds.
               Each match field may specify which values can match it, listing one or more ranges, prefixes, or exact values that are considered a match for the field. A field value must be present in order to match a specified match field. If no match values are specified for a match field, then any field value is considered to match it, and it's not required to be present. For strings specifying '*' is also equivalent to match all.
               For a packet to match a rule, all specified match fields must match the corresponding field values derived from the packet.
               Example:
               networkMatch: srcIpRanges: - "192.0.2.0/24" - "198.51.100.0/24" userDefinedFields: - name: "ipv4_fragment_offset" values: - "1-0x1fff"
               The above match condition matches packets with a source IP in 192.0.2.0/24 or 198.51.100.0/24 and a user-defined field named "ipv4_fragment_offset" with a value between 1 and 0x1fff inclusive
               Structure is documented below.
        :param 'RegionSecurityPolicyRulePreconfiguredWafConfigArgs' preconfigured_waf_config: Preconfigured WAF configuration to be applied for the rule.
               If the rule does not evaluate preconfigured WAF rules, i.e., if evaluatePreconfiguredWaf() is not used, this field will have no effect.
               Structure is documented below.
        :param _builtins.bool preview: If set to true, the specified action is not enforced.
        :param 'RegionSecurityPolicyRuleRateLimitOptionsArgs' rate_limit_options: Must be specified if the action is "rate_based_ban" or "throttle". Cannot be specified for any other actions.
               Structure is documented below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "priority", priority)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if network_match is not None:
            pulumi.set(__self__, "network_match", network_match)
        if preconfigured_waf_config is not None:
            pulumi.set(__self__, "preconfigured_waf_config", preconfigured_waf_config)
        if preview is not None:
            pulumi.set(__self__, "preview", preview)
        if rate_limit_options is not None:
            pulumi.set(__self__, "rate_limit_options", rate_limit_options)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The Action to perform when the rule is matched. The following are the valid actions:
        * allow: allow access to target.
        * deny(STATUS): deny access to target, returns the HTTP response code specified. Valid values for STATUS are 403, 404, and 502.
        * rate_based_ban: limit client traffic to the configured threshold and ban the client if the traffic exceeds the threshold. Configure parameters for this action in RateLimitOptions. Requires rateLimitOptions to be set.
        * redirect: redirect to a different target. This can either be an internal reCAPTCHA redirect, or an external URL-based redirect via a 302 response. Parameters for this action can be configured via redirectOptions. This action is only supported in Global Security Policies of type CLOUD_ARMOR.
        * throttle: limit client traffic to the configured threshold. Configure parameters for this action in rateLimitOptions. Requires rateLimitOptions to be set for this.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        An integer indicating the priority of a rule in the list.
        The priority must be a positive value between 0 and 2147483647.
        Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resource. Provide this property when you create the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional['outputs.RegionSecurityPolicyRuleMatch']:
        """
        A match condition that incoming traffic is evaluated against.
        If it evaluates to true, the corresponding 'action' is enforced.
        Structure is documented below.
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter(name="networkMatch")
    def network_match(self) -> Optional['outputs.RegionSecurityPolicyRuleNetworkMatch']:
        """
        A match condition that incoming packets are evaluated against for CLOUD_ARMOR_NETWORK security policies. If it matches, the corresponding 'action' is enforced.
        The match criteria for a rule consists of built-in match fields (like 'srcIpRanges') and potentially multiple user-defined match fields ('userDefinedFields').
        Field values may be extracted directly from the packet or derived from it (e.g. 'srcRegionCodes'). Some fields may not be present in every packet (e.g. 'srcPorts'). A user-defined field is only present if the base header is found in the packet and the entire field is in bounds.
        Each match field may specify which values can match it, listing one or more ranges, prefixes, or exact values that are considered a match for the field. A field value must be present in order to match a specified match field. If no match values are specified for a match field, then any field value is considered to match it, and it's not required to be present. For strings specifying '*' is also equivalent to match all.
        For a packet to match a rule, all specified match fields must match the corresponding field values derived from the packet.
        Example:
        networkMatch: srcIpRanges: - "192.0.2.0/24" - "198.51.100.0/24" userDefinedFields: - name: "ipv4_fragment_offset" values: - "1-0x1fff"
        The above match condition matches packets with a source IP in 192.0.2.0/24 or 198.51.100.0/24 and a user-defined field named "ipv4_fragment_offset" with a value between 1 and 0x1fff inclusive
        Structure is documented below.
        """
        return pulumi.get(self, "network_match")

    @_builtins.property
    @pulumi.getter(name="preconfiguredWafConfig")
    def preconfigured_waf_config(self) -> Optional['outputs.RegionSecurityPolicyRulePreconfiguredWafConfig']:
        """
        Preconfigured WAF configuration to be applied for the rule.
        If the rule does not evaluate preconfigured WAF rules, i.e., if evaluatePreconfiguredWaf() is not used, this field will have no effect.
        Structure is documented below.
        """
        return pulumi.get(self, "preconfigured_waf_config")

    @_builtins.property
    @pulumi.getter
    def preview(self) -> Optional[_builtins.bool]:
        """
        If set to true, the specified action is not enforced.
        """
        return pulumi.get(self, "preview")

    @_builtins.property
    @pulumi.getter(name="rateLimitOptions")
    def rate_limit_options(self) -> Optional['outputs.RegionSecurityPolicyRuleRateLimitOptions']:
        """
        Must be specified if the action is "rate_based_ban" or "throttle". Cannot be specified for any other actions.
        Structure is documented below.
        """
        return pulumi.get(self, "rate_limit_options")


@pulumi.output_type
class RegionSecurityPolicyRuleMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "versionedExpr":
            suggest = "versioned_expr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionSecurityPolicyRuleMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionSecurityPolicyRuleMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionSecurityPolicyRuleMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config: Optional['outputs.RegionSecurityPolicyRuleMatchConfig'] = None,
                 expr: Optional['outputs.RegionSecurityPolicyRuleMatchExpr'] = None,
                 versioned_expr: Optional[_builtins.str] = None):
        """
        :param 'RegionSecurityPolicyRuleMatchConfigArgs' config: The configuration options available when specifying versionedExpr.
               This field must be specified if versionedExpr is specified and cannot be specified if versionedExpr is not specified.
               Structure is documented below.
        :param 'RegionSecurityPolicyRuleMatchExprArgs' expr: User defined CEVAL expression. A CEVAL expression is used to specify match criteria such as origin.ip, source.region_code and contents in the request header.
               Structure is documented below.
        :param _builtins.str versioned_expr: Preconfigured versioned expression. If this field is specified, config must also be specified.
               Available preconfigured expressions along with their requirements are: SRC_IPS_V1 - must specify the corresponding srcIpRange field in config.
               Possible values are: `SRC_IPS_V1`.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if versioned_expr is not None:
            pulumi.set(__self__, "versioned_expr", versioned_expr)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional['outputs.RegionSecurityPolicyRuleMatchConfig']:
        """
        The configuration options available when specifying versionedExpr.
        This field must be specified if versionedExpr is specified and cannot be specified if versionedExpr is not specified.
        Structure is documented below.
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def expr(self) -> Optional['outputs.RegionSecurityPolicyRuleMatchExpr']:
        """
        User defined CEVAL expression. A CEVAL expression is used to specify match criteria such as origin.ip, source.region_code and contents in the request header.
        Structure is documented below.
        """
        return pulumi.get(self, "expr")

    @_builtins.property
    @pulumi.getter(name="versionedExpr")
    def versioned_expr(self) -> Optional[_builtins.str]:
        """
        Preconfigured versioned expression. If this field is specified, config must also be specified.
        Available preconfigured expressions along with their requirements are: SRC_IPS_V1 - must specify the corresponding srcIpRange field in config.
        Possible values are: `SRC_IPS_V1`.
        """
        return pulumi.get(self, "versioned_expr")


@pulumi.output_type
class RegionSecurityPolicyRuleMatchConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "srcIpRanges":
            suggest = "src_ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionSecurityPolicyRuleMatchConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionSecurityPolicyRuleMatchConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionSecurityPolicyRuleMatchConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 src_ip_ranges: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] src_ip_ranges: CIDR IP address range. Maximum number of srcIpRanges allowed is 10.
        """
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        CIDR IP address range. Maximum number of srcIpRanges allowed is 10.
        """
        return pulumi.get(self, "src_ip_ranges")


@pulumi.output_type
class RegionSecurityPolicyRuleMatchExpr(dict):
    def __init__(__self__, *,
                 expression: _builtins.str):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax. The application context of the containing message determines which well-known feature set of CEL is supported.
        """
        pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax. The application context of the containing message determines which well-known feature set of CEL is supported.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class RegionSecurityPolicyRuleNetworkMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destIpRanges":
            suggest = "dest_ip_ranges"
        elif key == "destPorts":
            suggest = "dest_ports"
        elif key == "ipProtocols":
            suggest = "ip_protocols"
        elif key == "srcAsns":
            suggest = "src_asns"
        elif key == "srcIpRanges":
            suggest = "src_ip_ranges"
        elif key == "srcPorts":
            suggest = "src_ports"
        elif key == "srcRegionCodes":
            suggest = "src_region_codes"
        elif key == "userDefinedFields":
            suggest = "user_defined_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionSecurityPolicyRuleNetworkMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionSecurityPolicyRuleNetworkMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionSecurityPolicyRuleNetworkMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dest_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 dest_ports: Optional[Sequence[_builtins.str]] = None,
                 ip_protocols: Optional[Sequence[_builtins.str]] = None,
                 src_asns: Optional[Sequence[_builtins.int]] = None,
                 src_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 src_ports: Optional[Sequence[_builtins.str]] = None,
                 src_region_codes: Optional[Sequence[_builtins.str]] = None,
                 user_defined_fields: Optional[Sequence['outputs.RegionSecurityPolicyRuleNetworkMatchUserDefinedField']] = None):
        """
        :param Sequence[_builtins.str] dest_ip_ranges: Destination IPv4/IPv6 addresses or CIDR prefixes, in standard text format.
        :param Sequence[_builtins.str] dest_ports: Destination port numbers for TCP/UDP/SCTP. Each element can be a 16-bit unsigned decimal number (e.g. "80") or range (e.g. "0-1023").
        :param Sequence[_builtins.str] ip_protocols: IPv4 protocol / IPv6 next header (after extension headers). Each element can be an 8-bit unsigned decimal number (e.g. "6"), range (e.g. "253-254"), or one of the following protocol names: "tcp", "udp", "icmp", "esp", "ah", "ipip", or "sctp".
        :param Sequence[_builtins.int] src_asns: BGP Autonomous System Number associated with the source IP address.
        :param Sequence[_builtins.str] src_ip_ranges: Source IPv4/IPv6 addresses or CIDR prefixes, in standard text format.
        :param Sequence[_builtins.str] src_ports: Source port numbers for TCP/UDP/SCTP. Each element can be a 16-bit unsigned decimal number (e.g. "80") or range (e.g. "0-1023").
        :param Sequence[_builtins.str] src_region_codes: Two-letter ISO 3166-1 alpha-2 country code associated with the source IP address.
        :param Sequence['RegionSecurityPolicyRuleNetworkMatchUserDefinedFieldArgs'] user_defined_fields: User-defined fields. Each element names a defined field and lists the matching values for that field.
               Structure is documented below.
        """
        if dest_ip_ranges is not None:
            pulumi.set(__self__, "dest_ip_ranges", dest_ip_ranges)
        if dest_ports is not None:
            pulumi.set(__self__, "dest_ports", dest_ports)
        if ip_protocols is not None:
            pulumi.set(__self__, "ip_protocols", ip_protocols)
        if src_asns is not None:
            pulumi.set(__self__, "src_asns", src_asns)
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)
        if src_ports is not None:
            pulumi.set(__self__, "src_ports", src_ports)
        if src_region_codes is not None:
            pulumi.set(__self__, "src_region_codes", src_region_codes)
        if user_defined_fields is not None:
            pulumi.set(__self__, "user_defined_fields", user_defined_fields)

    @_builtins.property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Destination IPv4/IPv6 addresses or CIDR prefixes, in standard text format.
        """
        return pulumi.get(self, "dest_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="destPorts")
    def dest_ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        Destination port numbers for TCP/UDP/SCTP. Each element can be a 16-bit unsigned decimal number (e.g. "80") or range (e.g. "0-1023").
        """
        return pulumi.get(self, "dest_ports")

    @_builtins.property
    @pulumi.getter(name="ipProtocols")
    def ip_protocols(self) -> Optional[Sequence[_builtins.str]]:
        """
        IPv4 protocol / IPv6 next header (after extension headers). Each element can be an 8-bit unsigned decimal number (e.g. "6"), range (e.g. "253-254"), or one of the following protocol names: "tcp", "udp", "icmp", "esp", "ah", "ipip", or "sctp".
        """
        return pulumi.get(self, "ip_protocols")

    @_builtins.property
    @pulumi.getter(name="srcAsns")
    def src_asns(self) -> Optional[Sequence[_builtins.int]]:
        """
        BGP Autonomous System Number associated with the source IP address.
        """
        return pulumi.get(self, "src_asns")

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Source IPv4/IPv6 addresses or CIDR prefixes, in standard text format.
        """
        return pulumi.get(self, "src_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="srcPorts")
    def src_ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        Source port numbers for TCP/UDP/SCTP. Each element can be a 16-bit unsigned decimal number (e.g. "80") or range (e.g. "0-1023").
        """
        return pulumi.get(self, "src_ports")

    @_builtins.property
    @pulumi.getter(name="srcRegionCodes")
    def src_region_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Two-letter ISO 3166-1 alpha-2 country code associated with the source IP address.
        """
        return pulumi.get(self, "src_region_codes")

    @_builtins.property
    @pulumi.getter(name="userDefinedFields")
    def user_defined_fields(self) -> Optional[Sequence['outputs.RegionSecurityPolicyRuleNetworkMatchUserDefinedField']]:
        """
        User-defined fields. Each element names a defined field and lists the matching values for that field.
        Structure is documented below.
        """
        return pulumi.get(self, "user_defined_fields")


@pulumi.output_type
class RegionSecurityPolicyRuleNetworkMatchUserDefinedField(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: Name of the user-defined field, as given in the definition.
        :param Sequence[_builtins.str] values: Matching values of the field. Each element can be a 32-bit unsigned decimal or hexadecimal (starting with "0x") number (e.g. "64") or range (e.g. "0x400-0x7ff").
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the user-defined field, as given in the definition.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Matching values of the field. Each element can be a 32-bit unsigned decimal or hexadecimal (starting with "0x") number (e.g. "64") or range (e.g. "0x400-0x7ff").
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RegionSecurityPolicyRulePreconfiguredWafConfig(dict):
    def __init__(__self__, *,
                 exclusions: Optional[Sequence['outputs.RegionSecurityPolicyRulePreconfiguredWafConfigExclusion']] = None):
        """
        :param Sequence['RegionSecurityPolicyRulePreconfiguredWafConfigExclusionArgs'] exclusions: An exclusion to apply during preconfigured WAF evaluation.
               Structure is documented below.
        """
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence['outputs.RegionSecurityPolicyRulePreconfiguredWafConfigExclusion']]:
        """
        An exclusion to apply during preconfigured WAF evaluation.
        Structure is documented below.
        """
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class RegionSecurityPolicyRulePreconfiguredWafConfigExclusion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetRuleSet":
            suggest = "target_rule_set"
        elif key == "requestCookies":
            suggest = "request_cookies"
        elif key == "requestHeaders":
            suggest = "request_headers"
        elif key == "requestQueryParams":
            suggest = "request_query_params"
        elif key == "requestUris":
            suggest = "request_uris"
        elif key == "targetRuleIds":
            suggest = "target_rule_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionSecurityPolicyRulePreconfiguredWafConfigExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionSecurityPolicyRulePreconfiguredWafConfigExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionSecurityPolicyRulePreconfiguredWafConfigExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_rule_set: _builtins.str,
                 request_cookies: Optional[Sequence['outputs.RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCooky']] = None,
                 request_headers: Optional[Sequence['outputs.RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeader']] = None,
                 request_query_params: Optional[Sequence['outputs.RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParam']] = None,
                 request_uris: Optional[Sequence['outputs.RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUri']] = None,
                 target_rule_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str target_rule_set: Target WAF rule set to apply the preconfigured WAF exclusion.
        :param Sequence['RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCookyArgs'] request_cookies: Request cookie whose value will be excluded from inspection during preconfigured WAF evaluation.
               Structure is documented below.
        :param Sequence['RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeaderArgs'] request_headers: Request header whose value will be excluded from inspection during preconfigured WAF evaluation.
               Structure is documented below.
        :param Sequence['RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParamArgs'] request_query_params: Request query parameter whose value will be excluded from inspection during preconfigured WAF evaluation.
               Note that the parameter can be in the query string or in the POST body.
               Structure is documented below.
        :param Sequence['RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUriArgs'] request_uris: Request URI from the request line to be excluded from inspection during preconfigured WAF evaluation.
               When specifying this field, the query or fragment part should be excluded.
               Structure is documented below.
        :param Sequence[_builtins.str] target_rule_ids: A list of target rule IDs under the WAF rule set to apply the preconfigured WAF exclusion.
               If omitted, it refers to all the rule IDs under the WAF rule set.
        """
        pulumi.set(__self__, "target_rule_set", target_rule_set)
        if request_cookies is not None:
            pulumi.set(__self__, "request_cookies", request_cookies)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if request_query_params is not None:
            pulumi.set(__self__, "request_query_params", request_query_params)
        if request_uris is not None:
            pulumi.set(__self__, "request_uris", request_uris)
        if target_rule_ids is not None:
            pulumi.set(__self__, "target_rule_ids", target_rule_ids)

    @_builtins.property
    @pulumi.getter(name="targetRuleSet")
    def target_rule_set(self) -> _builtins.str:
        """
        Target WAF rule set to apply the preconfigured WAF exclusion.
        """
        return pulumi.get(self, "target_rule_set")

    @_builtins.property
    @pulumi.getter(name="requestCookies")
    def request_cookies(self) -> Optional[Sequence['outputs.RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCooky']]:
        """
        Request cookie whose value will be excluded from inspection during preconfigured WAF evaluation.
        Structure is documented below.
        """
        return pulumi.get(self, "request_cookies")

    @_builtins.property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Sequence['outputs.RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeader']]:
        """
        Request header whose value will be excluded from inspection during preconfigured WAF evaluation.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers")

    @_builtins.property
    @pulumi.getter(name="requestQueryParams")
    def request_query_params(self) -> Optional[Sequence['outputs.RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParam']]:
        """
        Request query parameter whose value will be excluded from inspection during preconfigured WAF evaluation.
        Note that the parameter can be in the query string or in the POST body.
        Structure is documented below.
        """
        return pulumi.get(self, "request_query_params")

    @_builtins.property
    @pulumi.getter(name="requestUris")
    def request_uris(self) -> Optional[Sequence['outputs.RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUri']]:
        """
        Request URI from the request line to be excluded from inspection during preconfigured WAF evaluation.
        When specifying this field, the query or fragment part should be excluded.
        Structure is documented below.
        """
        return pulumi.get(self, "request_uris")

    @_builtins.property
    @pulumi.getter(name="targetRuleIds")
    def target_rule_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of target rule IDs under the WAF rule set to apply the preconfigured WAF exclusion.
        If omitted, it refers to all the rule IDs under the WAF rule set.
        """
        return pulumi.get(self, "target_rule_ids")


@pulumi.output_type
class RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCooky(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value.
               Available options:
               EQUALS: The operator matches if the field value equals the specified value.
               STARTS_WITH: The operator matches if the field value starts with the specified value.
               ENDS_WITH: The operator matches if the field value ends with the specified value.
               CONTAINS: The operator matches if the field value contains the specified value.
               EQUALS_ANY: The operator matches if the field value is any value.
               Possible values are: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EQUALS_ANY`, `STARTS_WITH`.
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
               The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value.
        Available options:
        EQUALS: The operator matches if the field value equals the specified value.
        STARTS_WITH: The operator matches if the field value starts with the specified value.
        ENDS_WITH: The operator matches if the field value ends with the specified value.
        CONTAINS: The operator matches if the field value contains the specified value.
        EQUALS_ANY: The operator matches if the field value is any value.
        Possible values are: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EQUALS_ANY`, `STARTS_WITH`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
        The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeader(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value.
               Available options:
               EQUALS: The operator matches if the field value equals the specified value.
               STARTS_WITH: The operator matches if the field value starts with the specified value.
               ENDS_WITH: The operator matches if the field value ends with the specified value.
               CONTAINS: The operator matches if the field value contains the specified value.
               EQUALS_ANY: The operator matches if the field value is any value.
               Possible values are: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EQUALS_ANY`, `STARTS_WITH`.
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
               The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value.
        Available options:
        EQUALS: The operator matches if the field value equals the specified value.
        STARTS_WITH: The operator matches if the field value starts with the specified value.
        ENDS_WITH: The operator matches if the field value ends with the specified value.
        CONTAINS: The operator matches if the field value contains the specified value.
        EQUALS_ANY: The operator matches if the field value is any value.
        Possible values are: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EQUALS_ANY`, `STARTS_WITH`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
        The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParam(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value.
               Available options:
               EQUALS: The operator matches if the field value equals the specified value.
               STARTS_WITH: The operator matches if the field value starts with the specified value.
               ENDS_WITH: The operator matches if the field value ends with the specified value.
               CONTAINS: The operator matches if the field value contains the specified value.
               EQUALS_ANY: The operator matches if the field value is any value.
               Possible values are: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EQUALS_ANY`, `STARTS_WITH`.
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
               The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value.
        Available options:
        EQUALS: The operator matches if the field value equals the specified value.
        STARTS_WITH: The operator matches if the field value starts with the specified value.
        ENDS_WITH: The operator matches if the field value ends with the specified value.
        CONTAINS: The operator matches if the field value contains the specified value.
        EQUALS_ANY: The operator matches if the field value is any value.
        Possible values are: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EQUALS_ANY`, `STARTS_WITH`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
        The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUri(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value.
               Available options:
               EQUALS: The operator matches if the field value equals the specified value.
               STARTS_WITH: The operator matches if the field value starts with the specified value.
               ENDS_WITH: The operator matches if the field value ends with the specified value.
               CONTAINS: The operator matches if the field value contains the specified value.
               EQUALS_ANY: The operator matches if the field value is any value.
               Possible values are: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EQUALS_ANY`, `STARTS_WITH`.
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
               The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value.
        Available options:
        EQUALS: The operator matches if the field value equals the specified value.
        STARTS_WITH: The operator matches if the field value starts with the specified value.
        ENDS_WITH: The operator matches if the field value ends with the specified value.
        CONTAINS: The operator matches if the field value contains the specified value.
        EQUALS_ANY: The operator matches if the field value is any value.
        Possible values are: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EQUALS_ANY`, `STARTS_WITH`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
        The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RegionSecurityPolicyRuleRateLimitOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "banDurationSec":
            suggest = "ban_duration_sec"
        elif key == "banThreshold":
            suggest = "ban_threshold"
        elif key == "conformAction":
            suggest = "conform_action"
        elif key == "enforceOnKey":
            suggest = "enforce_on_key"
        elif key == "enforceOnKeyConfigs":
            suggest = "enforce_on_key_configs"
        elif key == "enforceOnKeyName":
            suggest = "enforce_on_key_name"
        elif key == "exceedAction":
            suggest = "exceed_action"
        elif key == "rateLimitThreshold":
            suggest = "rate_limit_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionSecurityPolicyRuleRateLimitOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionSecurityPolicyRuleRateLimitOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionSecurityPolicyRuleRateLimitOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ban_duration_sec: Optional[_builtins.int] = None,
                 ban_threshold: Optional['outputs.RegionSecurityPolicyRuleRateLimitOptionsBanThreshold'] = None,
                 conform_action: Optional[_builtins.str] = None,
                 enforce_on_key: Optional[_builtins.str] = None,
                 enforce_on_key_configs: Optional[Sequence['outputs.RegionSecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig']] = None,
                 enforce_on_key_name: Optional[_builtins.str] = None,
                 exceed_action: Optional[_builtins.str] = None,
                 rate_limit_threshold: Optional['outputs.RegionSecurityPolicyRuleRateLimitOptionsRateLimitThreshold'] = None):
        """
        :param _builtins.int ban_duration_sec: Can only be specified if the action for the rule is "rate_based_ban".
               If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
        :param 'RegionSecurityPolicyRuleRateLimitOptionsBanThresholdArgs' ban_threshold: Can only be specified if the action for the rule is "rate_based_ban".
               If specified, the key will be banned for the configured 'banDurationSec' when the number of requests that exceed the 'rateLimitThreshold' also exceed this 'banThreshold'.
               Structure is documented below.
        :param _builtins.str conform_action: Action to take for requests that are under the configured rate limit threshold.
               Valid option is "allow" only.
        :param _builtins.str enforce_on_key: Determines the key to enforce the rateLimitThreshold on. Possible values are:
               * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKey" is not configured.
               * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
               * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
               * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
               * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
               * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
               * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
               * REGION_CODE: The country/region from which the request originates.
               * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
               * TLS_JA4_FINGERPRINT: JA4 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
               * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP.
               Possible values are: `ALL`, `IP`, `HTTP_HEADER`, `XFF_IP`, `HTTP_COOKIE`, `HTTP_PATH`, `SNI`, `REGION_CODE`, `TLS_JA3_FINGERPRINT`, `TLS_JA4_FINGERPRINT`, `USER_IP`.
        :param Sequence['RegionSecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfigArgs'] enforce_on_key_configs: If specified, any combination of values of enforceOnKeyType/enforceOnKeyName is treated as the key on which ratelimit threshold/action is enforced.
               You can specify up to 3 enforceOnKeyConfigs.
               If enforceOnKeyConfigs is specified, enforceOnKey must not be specified.
               Structure is documented below.
        :param _builtins.str enforce_on_key_name: Rate limit key name applicable only for the following key types:
               HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
               HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        :param _builtins.str exceed_action: Action to take for requests that are above the configured rate limit threshold, to deny with a specified HTTP response code.
               Valid options are deny(STATUS), where valid values for STATUS are 403, 404, 429, and 502.
        :param 'RegionSecurityPolicyRuleRateLimitOptionsRateLimitThresholdArgs' rate_limit_threshold: Threshold at which to begin ratelimiting.
               Structure is documented below.
        """
        if ban_duration_sec is not None:
            pulumi.set(__self__, "ban_duration_sec", ban_duration_sec)
        if ban_threshold is not None:
            pulumi.set(__self__, "ban_threshold", ban_threshold)
        if conform_action is not None:
            pulumi.set(__self__, "conform_action", conform_action)
        if enforce_on_key is not None:
            pulumi.set(__self__, "enforce_on_key", enforce_on_key)
        if enforce_on_key_configs is not None:
            pulumi.set(__self__, "enforce_on_key_configs", enforce_on_key_configs)
        if enforce_on_key_name is not None:
            pulumi.set(__self__, "enforce_on_key_name", enforce_on_key_name)
        if exceed_action is not None:
            pulumi.set(__self__, "exceed_action", exceed_action)
        if rate_limit_threshold is not None:
            pulumi.set(__self__, "rate_limit_threshold", rate_limit_threshold)

    @_builtins.property
    @pulumi.getter(name="banDurationSec")
    def ban_duration_sec(self) -> Optional[_builtins.int]:
        """
        Can only be specified if the action for the rule is "rate_based_ban".
        If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
        """
        return pulumi.get(self, "ban_duration_sec")

    @_builtins.property
    @pulumi.getter(name="banThreshold")
    def ban_threshold(self) -> Optional['outputs.RegionSecurityPolicyRuleRateLimitOptionsBanThreshold']:
        """
        Can only be specified if the action for the rule is "rate_based_ban".
        If specified, the key will be banned for the configured 'banDurationSec' when the number of requests that exceed the 'rateLimitThreshold' also exceed this 'banThreshold'.
        Structure is documented below.
        """
        return pulumi.get(self, "ban_threshold")

    @_builtins.property
    @pulumi.getter(name="conformAction")
    def conform_action(self) -> Optional[_builtins.str]:
        """
        Action to take for requests that are under the configured rate limit threshold.
        Valid option is "allow" only.
        """
        return pulumi.get(self, "conform_action")

    @_builtins.property
    @pulumi.getter(name="enforceOnKey")
    def enforce_on_key(self) -> Optional[_builtins.str]:
        """
        Determines the key to enforce the rateLimitThreshold on. Possible values are:
        * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKey" is not configured.
        * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
        * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
        * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
        * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
        * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
        * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
        * REGION_CODE: The country/region from which the request originates.
        * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
        * TLS_JA4_FINGERPRINT: JA4 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
        * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP.
        Possible values are: `ALL`, `IP`, `HTTP_HEADER`, `XFF_IP`, `HTTP_COOKIE`, `HTTP_PATH`, `SNI`, `REGION_CODE`, `TLS_JA3_FINGERPRINT`, `TLS_JA4_FINGERPRINT`, `USER_IP`.
        """
        return pulumi.get(self, "enforce_on_key")

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyConfigs")
    def enforce_on_key_configs(self) -> Optional[Sequence['outputs.RegionSecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig']]:
        """
        If specified, any combination of values of enforceOnKeyType/enforceOnKeyName is treated as the key on which ratelimit threshold/action is enforced.
        You can specify up to 3 enforceOnKeyConfigs.
        If enforceOnKeyConfigs is specified, enforceOnKey must not be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "enforce_on_key_configs")

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyName")
    def enforce_on_key_name(self) -> Optional[_builtins.str]:
        """
        Rate limit key name applicable only for the following key types:
        HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
        HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        """
        return pulumi.get(self, "enforce_on_key_name")

    @_builtins.property
    @pulumi.getter(name="exceedAction")
    def exceed_action(self) -> Optional[_builtins.str]:
        """
        Action to take for requests that are above the configured rate limit threshold, to deny with a specified HTTP response code.
        Valid options are deny(STATUS), where valid values for STATUS are 403, 404, 429, and 502.
        """
        return pulumi.get(self, "exceed_action")

    @_builtins.property
    @pulumi.getter(name="rateLimitThreshold")
    def rate_limit_threshold(self) -> Optional['outputs.RegionSecurityPolicyRuleRateLimitOptionsRateLimitThreshold']:
        """
        Threshold at which to begin ratelimiting.
        Structure is documented below.
        """
        return pulumi.get(self, "rate_limit_threshold")


@pulumi.output_type
class RegionSecurityPolicyRuleRateLimitOptionsBanThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalSec":
            suggest = "interval_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionSecurityPolicyRuleRateLimitOptionsBanThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionSecurityPolicyRuleRateLimitOptionsBanThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionSecurityPolicyRuleRateLimitOptionsBanThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[_builtins.int] = None,
                 interval_sec: Optional[_builtins.int] = None):
        """
        :param _builtins.int count: Number of HTTP(S) requests for calculating the threshold.
        :param _builtins.int interval_sec: Interval over which the threshold is computed.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval_sec is not None:
            pulumi.set(__self__, "interval_sec", interval_sec)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        Number of HTTP(S) requests for calculating the threshold.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="intervalSec")
    def interval_sec(self) -> Optional[_builtins.int]:
        """
        Interval over which the threshold is computed.
        """
        return pulumi.get(self, "interval_sec")


@pulumi.output_type
class RegionSecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enforceOnKeyName":
            suggest = "enforce_on_key_name"
        elif key == "enforceOnKeyType":
            suggest = "enforce_on_key_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionSecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionSecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionSecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enforce_on_key_name: Optional[_builtins.str] = None,
                 enforce_on_key_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str enforce_on_key_name: Rate limit key name applicable only for the following key types:
               HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
               HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        :param _builtins.str enforce_on_key_type: Determines the key to enforce the rateLimitThreshold on. Possible values are:
               * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKeyConfigs" is not configured.
               * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
               * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
               * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
               * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
               * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
               * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
               * REGION_CODE: The country/region from which the request originates.
               * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
               * TLS_JA4_FINGERPRINT: JA4 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
               * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP.
               Possible values are: `ALL`, `IP`, `HTTP_HEADER`, `XFF_IP`, `HTTP_COOKIE`, `HTTP_PATH`, `SNI`, `REGION_CODE`, `TLS_JA3_FINGERPRINT`, `TLS_JA4_FINGERPRINT`, `USER_IP`.
        """
        if enforce_on_key_name is not None:
            pulumi.set(__self__, "enforce_on_key_name", enforce_on_key_name)
        if enforce_on_key_type is not None:
            pulumi.set(__self__, "enforce_on_key_type", enforce_on_key_type)

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyName")
    def enforce_on_key_name(self) -> Optional[_builtins.str]:
        """
        Rate limit key name applicable only for the following key types:
        HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
        HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        """
        return pulumi.get(self, "enforce_on_key_name")

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyType")
    def enforce_on_key_type(self) -> Optional[_builtins.str]:
        """
        Determines the key to enforce the rateLimitThreshold on. Possible values are:
        * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKeyConfigs" is not configured.
        * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
        * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
        * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
        * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
        * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
        * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
        * REGION_CODE: The country/region from which the request originates.
        * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
        * TLS_JA4_FINGERPRINT: JA4 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
        * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP.
        Possible values are: `ALL`, `IP`, `HTTP_HEADER`, `XFF_IP`, `HTTP_COOKIE`, `HTTP_PATH`, `SNI`, `REGION_CODE`, `TLS_JA3_FINGERPRINT`, `TLS_JA4_FINGERPRINT`, `USER_IP`.
        """
        return pulumi.get(self, "enforce_on_key_type")


@pulumi.output_type
class RegionSecurityPolicyRuleRateLimitOptionsRateLimitThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalSec":
            suggest = "interval_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionSecurityPolicyRuleRateLimitOptionsRateLimitThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionSecurityPolicyRuleRateLimitOptionsRateLimitThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionSecurityPolicyRuleRateLimitOptionsRateLimitThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[_builtins.int] = None,
                 interval_sec: Optional[_builtins.int] = None):
        """
        :param _builtins.int count: Number of HTTP(S) requests for calculating the threshold.
        :param _builtins.int interval_sec: Interval over which the threshold is computed.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval_sec is not None:
            pulumi.set(__self__, "interval_sec", interval_sec)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        Number of HTTP(S) requests for calculating the threshold.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="intervalSec")
    def interval_sec(self) -> Optional[_builtins.int]:
        """
        Interval over which the threshold is computed.
        """
        return pulumi.get(self, "interval_sec")


@pulumi.output_type
class RegionSecurityPolicyUserDefinedField(dict):
    def __init__(__self__, *,
                 base: _builtins.str,
                 mask: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 offset: Optional[_builtins.int] = None,
                 size: Optional[_builtins.int] = None):
        """
        :param _builtins.str base: The base relative to which 'offset' is measured. Possible values are:
               - IPV4: Points to the beginning of the IPv4 header.
               - IPV6: Points to the beginning of the IPv6 header.
               - TCP: Points to the beginning of the TCP header, skipping over any IPv4 options or IPv6 extension headers. Not present for non-first fragments.
               - UDP: Points to the beginning of the UDP header, skipping over any IPv4 options or IPv6 extension headers. Not present for non-first fragments.
               Possible values are: `IPV4`, `IPV6`, `TCP`, `UDP`.
        :param _builtins.str mask: If specified, apply this mask (bitwise AND) to the field to ignore bits before matching.
               Encoded as a hexadecimal number (starting with "0x").
               The last byte of the field (in network byte order) corresponds to the least significant byte of the mask.
        :param _builtins.str name: Name of the user-defined field, as given in the definition.
        :param _builtins.int offset: Offset of the first byte of the field (in network byte order) relative to 'base'.
        :param _builtins.int size: Size of the field in bytes. Valid values: 1-4.
        """
        pulumi.set(__self__, "base", base)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def base(self) -> _builtins.str:
        """
        The base relative to which 'offset' is measured. Possible values are:
        - IPV4: Points to the beginning of the IPv4 header.
        - IPV6: Points to the beginning of the IPv6 header.
        - TCP: Points to the beginning of the TCP header, skipping over any IPv4 options or IPv6 extension headers. Not present for non-first fragments.
        - UDP: Points to the beginning of the UDP header, skipping over any IPv4 options or IPv6 extension headers. Not present for non-first fragments.
        Possible values are: `IPV4`, `IPV6`, `TCP`, `UDP`.
        """
        return pulumi.get(self, "base")

    @_builtins.property
    @pulumi.getter
    def mask(self) -> Optional[_builtins.str]:
        """
        If specified, apply this mask (bitwise AND) to the field to ignore bits before matching.
        Encoded as a hexadecimal number (starting with "0x").
        The last byte of the field (in network byte order) corresponds to the least significant byte of the mask.
        """
        return pulumi.get(self, "mask")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the user-defined field, as given in the definition.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.int]:
        """
        Offset of the first byte of the field (in network byte order) relative to 'base'.
        """
        return pulumi.get(self, "offset")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        Size of the field in bytes. Valid values: 1-4.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class RegionUrlMapDefaultRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "corsPolicy":
            suggest = "cors_policy"
        elif key == "faultInjectionPolicy":
            suggest = "fault_injection_policy"
        elif key == "requestMirrorPolicy":
            suggest = "request_mirror_policy"
        elif key == "retryPolicy":
            suggest = "retry_policy"
        elif key == "urlRewrite":
            suggest = "url_rewrite"
        elif key == "weightedBackendServices":
            suggest = "weighted_backend_services"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapDefaultRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapDefaultRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapDefaultRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cors_policy: Optional['outputs.RegionUrlMapDefaultRouteActionCorsPolicy'] = None,
                 fault_injection_policy: Optional['outputs.RegionUrlMapDefaultRouteActionFaultInjectionPolicy'] = None,
                 request_mirror_policy: Optional['outputs.RegionUrlMapDefaultRouteActionRequestMirrorPolicy'] = None,
                 retry_policy: Optional['outputs.RegionUrlMapDefaultRouteActionRetryPolicy'] = None,
                 timeout: Optional['outputs.RegionUrlMapDefaultRouteActionTimeout'] = None,
                 url_rewrite: Optional['outputs.RegionUrlMapDefaultRouteActionUrlRewrite'] = None,
                 weighted_backend_services: Optional[Sequence['outputs.RegionUrlMapDefaultRouteActionWeightedBackendService']] = None):
        """
        :param 'RegionUrlMapDefaultRouteActionCorsPolicyArgs' cors_policy: The specification for allowing client side cross-origin requests. Please see
               [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
               Structure is documented below.
        :param 'RegionUrlMapDefaultRouteActionFaultInjectionPolicyArgs' fault_injection_policy: The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
               As part of fault injection, when clients send requests to a backend service, delays can be introduced by a load balancer on a percentage of requests before sending those requests to the backend service.
               Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
               timeout and retryPolicy is ignored by clients that are configured with a faultInjectionPolicy if: 1. The traffic is generated by fault injection AND 2. The fault injection is not a delay fault injection.
               Fault injection is not supported with the global external HTTP(S) load balancer (classic). To see which load balancers support fault injection, see Load balancing: [Routing and traffic management features](https://cloud.google.com/load-balancing/docs/features#routing-traffic-management).
               Structure is documented below.
        :param 'RegionUrlMapDefaultRouteActionRequestMirrorPolicyArgs' request_mirror_policy: Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
               The load balancer does not wait for responses from the shadow service. Before sending traffic to the shadow service, the host / authority header is suffixed with -shadow.
               Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
               Structure is documented below.
        :param 'RegionUrlMapDefaultRouteActionRetryPolicyArgs' retry_policy: Specifies the retry policy associated with this route.
               Structure is documented below.
        :param 'RegionUrlMapDefaultRouteActionTimeoutArgs' timeout: Specifies the timeout for the selected route. Timeout is computed from the time the request has been fully processed (known as end-of-stream) up until the response has been processed. Timeout includes all retries.
               If not specified, this field uses the largest timeout among all backend services associated with the route.
               Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
               Structure is documented below.
        :param 'RegionUrlMapDefaultRouteActionUrlRewriteArgs' url_rewrite: The spec to modify the URL of the request, before forwarding the request to the matched service.
               urlRewrite is the only action supported in UrlMaps for external HTTP(S) load balancers.
               Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
               Structure is documented below.
        :param Sequence['RegionUrlMapDefaultRouteActionWeightedBackendServiceArgs'] weighted_backend_services: A list of weighted backend services to send traffic to when a route match occurs. The weights determine the fraction of traffic that flows to their corresponding backend service. If all traffic needs to go to a single backend service, there must be one weightedBackendService with weight set to a non-zero number.
               After a backend service is identified and before forwarding the request to the backend service, advanced routing actions such as URL rewrites and header transformations are applied depending on additional settings specified in this HttpRouteAction.
               Structure is documented below.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if fault_injection_policy is not None:
            pulumi.set(__self__, "fault_injection_policy", fault_injection_policy)
        if request_mirror_policy is not None:
            pulumi.set(__self__, "request_mirror_policy", request_mirror_policy)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)
        if weighted_backend_services is not None:
            pulumi.set(__self__, "weighted_backend_services", weighted_backend_services)

    @_builtins.property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.RegionUrlMapDefaultRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see
        [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
        Structure is documented below.
        """
        return pulumi.get(self, "cors_policy")

    @_builtins.property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.RegionUrlMapDefaultRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
        As part of fault injection, when clients send requests to a backend service, delays can be introduced by a load balancer on a percentage of requests before sending those requests to the backend service.
        Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
        timeout and retryPolicy is ignored by clients that are configured with a faultInjectionPolicy if: 1. The traffic is generated by fault injection AND 2. The fault injection is not a delay fault injection.
        Fault injection is not supported with the global external HTTP(S) load balancer (classic). To see which load balancers support fault injection, see Load balancing: [Routing and traffic management features](https://cloud.google.com/load-balancing/docs/features#routing-traffic-management).
        Structure is documented below.
        """
        return pulumi.get(self, "fault_injection_policy")

    @_builtins.property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.RegionUrlMapDefaultRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
        The load balancer does not wait for responses from the shadow service. Before sending traffic to the shadow service, the host / authority header is suffixed with -shadow.
        Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
        Structure is documented below.
        """
        return pulumi.get(self, "request_mirror_policy")

    @_builtins.property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.RegionUrlMapDefaultRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        return pulumi.get(self, "retry_policy")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.RegionUrlMapDefaultRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time the request has been fully processed (known as end-of-stream) up until the response has been processed. Timeout includes all retries.
        If not specified, this field uses the largest timeout among all backend services associated with the route.
        Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
        Structure is documented below.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.RegionUrlMapDefaultRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, before forwarding the request to the matched service.
        urlRewrite is the only action supported in UrlMaps for external HTTP(S) load balancers.
        Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
        Structure is documented below.
        """
        return pulumi.get(self, "url_rewrite")

    @_builtins.property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[Sequence['outputs.RegionUrlMapDefaultRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match occurs. The weights determine the fraction of traffic that flows to their corresponding backend service. If all traffic needs to go to a single backend service, there must be one weightedBackendService with weight set to a non-zero number.
        After a backend service is identified and before forwarding the request to the backend service, advanced routing actions such as URL rewrites and header transformations are applied depending on additional settings specified in this HttpRouteAction.
        Structure is documented below.
        """
        return pulumi.get(self, "weighted_backend_services")


@pulumi.output_type
class RegionUrlMapDefaultRouteActionCorsPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOriginRegexes":
            suggest = "allow_origin_regexes"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapDefaultRouteActionCorsPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapDefaultRouteActionCorsPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapDefaultRouteActionCorsPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origin_regexes: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional[Sequence[_builtins.str]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        :param _builtins.bool allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This field translates to the Access-Control-Allow-Credentials header.
               Default is false.
        :param Sequence[_builtins.str] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param Sequence[_builtins.str] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param Sequence[_builtins.str] allow_origin_regexes: Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[_builtins.str] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param _builtins.bool disabled: If true, the setting specifies the CORS policy is disabled. The default value of false, which indicates that the CORS policy is in effect.
        :param Sequence[_builtins.str] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param _builtins.int max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin_regexes is not None:
            pulumi.set(__self__, "allow_origin_regexes", allow_origin_regexes)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This field translates to the Access-Control-Allow-Credentials header.
        Default is false.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origin_regexes")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If true, the setting specifies the CORS policy is disabled. The default value of false, which indicates that the CORS policy is in effect.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class RegionUrlMapDefaultRouteActionFaultInjectionPolicy(dict):
    def __init__(__self__, *,
                 abort: Optional['outputs.RegionUrlMapDefaultRouteActionFaultInjectionPolicyAbort'] = None,
                 delay: Optional['outputs.RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelay'] = None):
        """
        :param 'RegionUrlMapDefaultRouteActionFaultInjectionPolicyAbortArgs' abort: The specification for how client requests are aborted as part of fault injection.
               Structure is documented below.
        :param 'RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelayArgs' delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
               Structure is documented below.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def abort(self) -> Optional['outputs.RegionUrlMapDefaultRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        return pulumi.get(self, "abort")

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional['outputs.RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class RegionUrlMapDefaultRouteActionFaultInjectionPolicyAbort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpStatus":
            suggest = "http_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapDefaultRouteActionFaultInjectionPolicyAbort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapDefaultRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapDefaultRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_status: Optional[_builtins.int] = None,
                 percentage: Optional[_builtins.float] = None):
        """
        :param _builtins.int http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if http_status is not None:
            pulumi.set(__self__, "http_status", http_status)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[_builtins.int]:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        return pulumi.get(self, "http_status")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedDelay":
            suggest = "fixed_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_delay: Optional['outputs.RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay'] = None,
                 percentage: Optional[_builtins.float] = None):
        """
        :param 'RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelayArgs' fixed_delay: Specifies the value of the fixed delay interval.
               Structure is documented below.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if fixed_delay is not None:
            pulumi.set(__self__, "fixed_delay", fixed_delay)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> Optional['outputs.RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay']:
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_delay")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class RegionUrlMapDefaultRouteActionRequestMirrorPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "mirrorPercent":
            suggest = "mirror_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapDefaultRouteActionRequestMirrorPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapDefaultRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapDefaultRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: Optional[_builtins.str] = None,
                 mirror_percent: Optional[_builtins.float] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the RegionBackendService resource being mirrored to.
               The backend service configured for a mirroring policy must reference backends that are of the same type as the original backend service matched in the URL map.
               Serverless NEG backends are not currently supported as a mirrored backend service.
        :param _builtins.float mirror_percent: The percentage of requests to be mirrored to backendService.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if backend_service is not None:
            pulumi.set(__self__, "backend_service", backend_service)
        if mirror_percent is not None:
            pulumi.set(__self__, "mirror_percent", mirror_percent)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> Optional[_builtins.str]:
        """
        The full or partial URL to the RegionBackendService resource being mirrored to.
        The backend service configured for a mirroring policy must reference backends that are of the same type as the original backend service matched in the URL map.
        Serverless NEG backends are not currently supported as a mirrored backend service.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter(name="mirrorPercent")
    def mirror_percent(self) -> Optional[_builtins.float]:
        """
        The percentage of requests to be mirrored to backendService.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "mirror_percent")


@pulumi.output_type
class RegionUrlMapDefaultRouteActionRetryPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numRetries":
            suggest = "num_retries"
        elif key == "perTryTimeout":
            suggest = "per_try_timeout"
        elif key == "retryConditions":
            suggest = "retry_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapDefaultRouteActionRetryPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapDefaultRouteActionRetryPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapDefaultRouteActionRetryPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_retries: Optional[_builtins.int] = None,
                 per_try_timeout: Optional['outputs.RegionUrlMapDefaultRouteActionRetryPolicyPerTryTimeout'] = None,
                 retry_conditions: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param 'RegionUrlMapDefaultRouteActionRetryPolicyPerTryTimeoutArgs' per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param Sequence[_builtins.str] retry_conditions: Specifies one or more conditions when this retry policy applies.
               Valid values are listed below. Only the following codes are supported when the URL map is bound to target gRPC proxy that has validateForProxyless field set to true: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
               - 5xx : retry is attempted if the instance or endpoint responds with any 5xx response code, or if the instance or endpoint does not respond at all. For example, disconnects, reset, read timeout, connection failure, and refused streams.
               - gateway-error : Similar to 5xx, but only applies to response codes 502, 503 or 504.
               - connect-failure : a retry is attempted on failures connecting to the instance or endpoint. For example, connection timeouts.
               - retriable-4xx : a retry is attempted if the instance or endpoint responds with a 4xx response code. The only error that you can retry is error code 409.
               - refused-stream : a retry is attempted if the instance or endpoint resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
               - cancelled : a retry is attempted if the gRPC status code in the response header is set to cancelled.
               - deadline-exceeded : a retry is attempted if the gRPC status code in the response header is set to deadline-exceeded.
               - internal :  a retry is attempted if the gRPC status code in the response header is set to internal.
               - resource-exhausted : a retry is attempted if the gRPC status code in the response header is set to resource-exhausted.
               - unavailable : a retry is attempted if the gRPC status code in the response header is set to unavailable.
        """
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_conditions is not None:
            pulumi.set(__self__, "retry_conditions", retry_conditions)

    @_builtins.property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[_builtins.int]:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        return pulumi.get(self, "num_retries")

    @_builtins.property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.RegionUrlMapDefaultRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "per_try_timeout")

    @_builtins.property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies one or more conditions when this retry policy applies.
        Valid values are listed below. Only the following codes are supported when the URL map is bound to target gRPC proxy that has validateForProxyless field set to true: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
        - 5xx : retry is attempted if the instance or endpoint responds with any 5xx response code, or if the instance or endpoint does not respond at all. For example, disconnects, reset, read timeout, connection failure, and refused streams.
        - gateway-error : Similar to 5xx, but only applies to response codes 502, 503 or 504.
        - connect-failure : a retry is attempted on failures connecting to the instance or endpoint. For example, connection timeouts.
        - retriable-4xx : a retry is attempted if the instance or endpoint responds with a 4xx response code. The only error that you can retry is error code 409.
        - refused-stream : a retry is attempted if the instance or endpoint resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        - cancelled : a retry is attempted if the gRPC status code in the response header is set to cancelled.
        - deadline-exceeded : a retry is attempted if the gRPC status code in the response header is set to deadline-exceeded.
        - internal :  a retry is attempted if the gRPC status code in the response header is set to internal.
        - resource-exhausted : a retry is attempted if the gRPC status code in the response header is set to resource-exhausted.
        - unavailable : a retry is attempted if the gRPC status code in the response header is set to unavailable.
        """
        return pulumi.get(self, "retry_conditions")


@pulumi.output_type
class RegionUrlMapDefaultRouteActionRetryPolicyPerTryTimeout(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class RegionUrlMapDefaultRouteActionTimeout(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class RegionUrlMapDefaultRouteActionUrlRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostRewrite":
            suggest = "host_rewrite"
        elif key == "pathPrefixRewrite":
            suggest = "path_prefix_rewrite"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapDefaultRouteActionUrlRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapDefaultRouteActionUrlRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapDefaultRouteActionUrlRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_rewrite: Optional[_builtins.str] = None,
                 path_prefix_rewrite: Optional[_builtins.str] = None):
        """
        :param _builtins.str host_rewrite: Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite.
               The value must be from 1 to 255 characters.
        :param _builtins.str path_prefix_rewrite: Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite.
               The value must be from 1 to 1024 characters.
        """
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if path_prefix_rewrite is not None:
            pulumi.set(__self__, "path_prefix_rewrite", path_prefix_rewrite)

    @_builtins.property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[_builtins.str]:
        """
        Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite.
        The value must be from 1 to 255 characters.
        """
        return pulumi.get(self, "host_rewrite")

    @_builtins.property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[_builtins.str]:
        """
        Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite.
        The value must be from 1 to 1024 characters.
        """
        return pulumi.get(self, "path_prefix_rewrite")


@pulumi.output_type
class RegionUrlMapDefaultRouteActionWeightedBackendService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "headerAction":
            suggest = "header_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapDefaultRouteActionWeightedBackendService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapDefaultRouteActionWeightedBackendService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapDefaultRouteActionWeightedBackendService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: Optional[_builtins.str] = None,
                 header_action: Optional['outputs.RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderAction'] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
        :param 'RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
               headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
               Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
               Structure is documented below.
        :param _builtins.int weight: Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy.
               The value must be from 0 to 1000.
        """
        if backend_service is not None:
            pulumi.set(__self__, "backend_service", backend_service)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> Optional[_builtins.str]:
        """
        The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
        headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
        Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy.
        The value must be from 0 to 1000.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"
        elif key == "requestHeadersToRemoves":
            suggest = "request_headers_to_removes"
        elif key == "responseHeadersToAdds":
            suggest = "response_headers_to_adds"
        elif key == "responseHeadersToRemoves":
            suggest = "response_headers_to_removes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[_builtins.str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request before forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[_builtins.str] request_headers_to_removes: A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
        :param Sequence['RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response before sending the response back to the client.
               Structure is documented below.
        :param Sequence[_builtins.str] response_headers_to_removes: A list of header names for headers that need to be removed from the response before sending the response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request before forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response before sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the response before sending the response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")


@pulumi.output_type
class RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[_builtins.str] = None,
                 header_value: Optional[_builtins.str] = None,
                 replace: Optional[_builtins.bool] = None):
        """
        :param _builtins.str header_name: The name of the header.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
               The default value is false.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.bool]:
        """
        If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
        The default value is false.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[_builtins.str] = None,
                 header_value: Optional[_builtins.str] = None,
                 replace: Optional[_builtins.bool] = None):
        """
        :param _builtins.str header_name: The name of the header.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
               The default value is false.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.bool]:
        """
        If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
        The default value is false.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class RegionUrlMapDefaultUrlRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stripQuery":
            suggest = "strip_query"
        elif key == "hostRedirect":
            suggest = "host_redirect"
        elif key == "httpsRedirect":
            suggest = "https_redirect"
        elif key == "pathRedirect":
            suggest = "path_redirect"
        elif key == "prefixRedirect":
            suggest = "prefix_redirect"
        elif key == "redirectResponseCode":
            suggest = "redirect_response_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapDefaultUrlRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapDefaultUrlRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapDefaultUrlRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 strip_query: _builtins.bool,
                 host_redirect: Optional[_builtins.str] = None,
                 https_redirect: Optional[_builtins.bool] = None,
                 path_redirect: Optional[_builtins.str] = None,
                 prefix_redirect: Optional[_builtins.str] = None,
                 redirect_response_code: Optional[_builtins.str] = None):
        """
        :param _builtins.bool strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param _builtins.str host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param _builtins.bool https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param _builtins.str path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param _builtins.str prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param _builtins.str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        pulumi.set(__self__, "strip_query", strip_query)
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)

    @_builtins.property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> _builtins.bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        return pulumi.get(self, "strip_query")

    @_builtins.property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[_builtins.str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_redirect")

    @_builtins.property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[_builtins.bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        return pulumi.get(self, "https_redirect")

    @_builtins.property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[_builtins.str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        return pulumi.get(self, "path_redirect")

    @_builtins.property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[_builtins.str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "prefix_redirect")

    @_builtins.property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[_builtins.str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")


@pulumi.output_type
class RegionUrlMapHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"
        elif key == "requestHeadersToRemoves":
            suggest = "request_headers_to_removes"
        elif key == "responseHeadersToAdds":
            suggest = "response_headers_to_adds"
        elif key == "responseHeadersToRemoves":
            suggest = "response_headers_to_removes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[_builtins.str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['RegionUrlMapHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request before forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[_builtins.str] request_headers_to_removes: A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
        :param Sequence['RegionUrlMapHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response before sending the response back to the client.
               Structure is documented below.
        :param Sequence[_builtins.str] response_headers_to_removes: A list of header names for headers that need to be removed from the response before sending the response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request before forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response before sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the response before sending the response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")


@pulumi.output_type
class RegionUrlMapHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[_builtins.str] = None,
                 header_value: Optional[_builtins.str] = None,
                 replace: Optional[_builtins.bool] = None):
        """
        :param _builtins.str header_name: The name of the header.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
               The default value is false.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.bool]:
        """
        If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
        The default value is false.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class RegionUrlMapHeaderActionResponseHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapHeaderActionResponseHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[_builtins.str] = None,
                 header_value: Optional[_builtins.str] = None,
                 replace: Optional[_builtins.bool] = None):
        """
        :param _builtins.str header_name: The name of the header.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
               The default value is false.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.bool]:
        """
        If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
        The default value is false.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class RegionUrlMapHostRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathMatcher":
            suggest = "path_matcher"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapHostRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapHostRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapHostRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Sequence[_builtins.str],
                 path_matcher: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] hosts: The list of host patterns to match. They must be valid
               hostnames, except * will match any string of ([a-z0-9-.]*). In
               that case, * must be the first character and must be followed in
               the pattern by either - or ..
        :param _builtins.str path_matcher: The name of the PathMatcher to use to match the path portion of
               the URL if the hostRule matches the URL's host portion.
        :param _builtins.str description: An optional description of this HostRule. Provide this property
               when you create the resource.
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "path_matcher", path_matcher)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence[_builtins.str]:
        """
        The list of host patterns to match. They must be valid
        hostnames, except * will match any string of ([a-z0-9-.]*). In
        that case, * must be the first character and must be followed in
        the pattern by either - or ..
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="pathMatcher")
    def path_matcher(self) -> _builtins.str:
        """
        The name of the PathMatcher to use to match the path portion of
        the URL if the hostRule matches the URL's host portion.
        """
        return pulumi.get(self, "path_matcher")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this HostRule. Provide this property
        when you create the resource.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class RegionUrlMapPathMatcher(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultRouteAction":
            suggest = "default_route_action"
        elif key == "defaultService":
            suggest = "default_service"
        elif key == "defaultUrlRedirect":
            suggest = "default_url_redirect"
        elif key == "headerAction":
            suggest = "header_action"
        elif key == "pathRules":
            suggest = "path_rules"
        elif key == "routeRules":
            suggest = "route_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcher. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcher.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcher.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 default_route_action: Optional['outputs.RegionUrlMapPathMatcherDefaultRouteAction'] = None,
                 default_service: Optional[_builtins.str] = None,
                 default_url_redirect: Optional['outputs.RegionUrlMapPathMatcherDefaultUrlRedirect'] = None,
                 description: Optional[_builtins.str] = None,
                 header_action: Optional['outputs.RegionUrlMapPathMatcherHeaderAction'] = None,
                 path_rules: Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRule']] = None,
                 route_rules: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRule']] = None):
        """
        :param _builtins.str name: The name to which this PathMatcher is referred by the HostRule.
        :param 'RegionUrlMapPathMatcherDefaultRouteActionArgs' default_route_action: defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
               advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
               to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
               Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
               Only one of defaultRouteAction or defaultUrlRedirect must be set.
               Structure is documented below.
        :param _builtins.str default_service: A reference to a RegionBackendService resource. This will be used if
               none of the pathRules defined by this PathMatcher is matched by
               the URL's path portion.
        :param 'RegionUrlMapPathMatcherDefaultUrlRedirectArgs' default_url_redirect: When none of the specified hostRules match, the request is redirected to a URL specified
               by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
               defaultRouteAction must not be set.
               Structure is documented below.
        :param _builtins.str description: An optional description of this resource.
        :param 'RegionUrlMapPathMatcherHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
               headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
               Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
               Structure is documented below.
        :param Sequence['RegionUrlMapPathMatcherPathRuleArgs'] path_rules: The list of path rules. Use this list instead of routeRules when routing based
               on simple path matching is all that's required. The order by which path rules
               are specified does not matter. Matches are always done on the longest-path-first
               basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
               irrespective of the order in which those paths appear in this list. Within a
               given pathMatcher, only one of pathRules or routeRules must be set.
               Structure is documented below.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleArgs'] route_rules: The list of ordered HTTP route rules. Use this list instead of pathRules when
               advanced route matching and routing actions are desired. The order of specifying
               routeRules matters: the first rule that matches will cause its specified routing
               action to take effect. Within a given pathMatcher, only one of pathRules or
               routeRules must be set. routeRules are not supported in UrlMaps intended for
               External load balancers.
               Structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        if default_route_action is not None:
            pulumi.set(__self__, "default_route_action", default_route_action)
        if default_service is not None:
            pulumi.set(__self__, "default_service", default_service)
        if default_url_redirect is not None:
            pulumi.set(__self__, "default_url_redirect", default_url_redirect)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)
        if path_rules is not None:
            pulumi.set(__self__, "path_rules", path_rules)
        if route_rules is not None:
            pulumi.set(__self__, "route_rules", route_rules)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name to which this PathMatcher is referred by the HostRule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="defaultRouteAction")
    def default_route_action(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultRouteAction']:
        """
        defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
        advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
        to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
        Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
        Only one of defaultRouteAction or defaultUrlRedirect must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "default_route_action")

    @_builtins.property
    @pulumi.getter(name="defaultService")
    def default_service(self) -> Optional[_builtins.str]:
        """
        A reference to a RegionBackendService resource. This will be used if
        none of the pathRules defined by this PathMatcher is matched by
        the URL's path portion.
        """
        return pulumi.get(self, "default_service")

    @_builtins.property
    @pulumi.getter(name="defaultUrlRedirect")
    def default_url_redirect(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultUrlRedirect']:
        """
        When none of the specified hostRules match, the request is redirected to a URL specified
        by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
        defaultRouteAction must not be set.
        Structure is documented below.
        """
        return pulumi.get(self, "default_url_redirect")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.RegionUrlMapPathMatcherHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
        headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
        Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    @_builtins.property
    @pulumi.getter(name="pathRules")
    def path_rules(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRule']]:
        """
        The list of path rules. Use this list instead of routeRules when routing based
        on simple path matching is all that's required. The order by which path rules
        are specified does not matter. Matches are always done on the longest-path-first
        basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
        irrespective of the order in which those paths appear in this list. Within a
        given pathMatcher, only one of pathRules or routeRules must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "path_rules")

    @_builtins.property
    @pulumi.getter(name="routeRules")
    def route_rules(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRule']]:
        """
        The list of ordered HTTP route rules. Use this list instead of pathRules when
        advanced route matching and routing actions are desired. The order of specifying
        routeRules matters: the first rule that matches will cause its specified routing
        action to take effect. Within a given pathMatcher, only one of pathRules or
        routeRules must be set. routeRules are not supported in UrlMaps intended for
        External load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "route_rules")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "corsPolicy":
            suggest = "cors_policy"
        elif key == "faultInjectionPolicy":
            suggest = "fault_injection_policy"
        elif key == "maxStreamDuration":
            suggest = "max_stream_duration"
        elif key == "requestMirrorPolicy":
            suggest = "request_mirror_policy"
        elif key == "retryPolicy":
            suggest = "retry_policy"
        elif key == "urlRewrite":
            suggest = "url_rewrite"
        elif key == "weightedBackendServices":
            suggest = "weighted_backend_services"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherDefaultRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherDefaultRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherDefaultRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cors_policy: Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionCorsPolicy'] = None,
                 fault_injection_policy: Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicy'] = None,
                 max_stream_duration: Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionMaxStreamDuration'] = None,
                 request_mirror_policy: Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionRequestMirrorPolicy'] = None,
                 retry_policy: Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionRetryPolicy'] = None,
                 timeout: Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionTimeout'] = None,
                 url_rewrite: Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionUrlRewrite'] = None,
                 weighted_backend_services: Optional[Sequence['outputs.RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendService']] = None):
        """
        :param 'RegionUrlMapPathMatcherDefaultRouteActionCorsPolicyArgs' cors_policy: The specification for allowing client side cross-origin requests. Please see
               [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyArgs' fault_injection_policy: The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
               As part of fault injection, when clients send requests to a backend service, delays can be introduced by a load balancer on a percentage of requests before sending those requests to the backend service.
               Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
               timeout and retryPolicy is ignored by clients that are configured with a faultInjectionPolicy if: 1. The traffic is generated by fault injection AND 2. The fault injection is not a delay fault injection.
               Fault injection is not supported with the global external HTTP(S) load balancer (classic). To see which load balancers support fault injection, see Load balancing: [Routing and traffic management features](https://cloud.google.com/load-balancing/docs/features#routing-traffic-management).
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherDefaultRouteActionMaxStreamDurationArgs' max_stream_duration: Specifies the maximum duration (timeout) for streams on the selected route.
               Unlike the `Timeout` field where the timeout duration starts from the time the request
               has been fully processed (known as end-of-stream), the duration in this field
               is computed from the beginning of the stream until the response has been processed,
               including all retries. A stream that does not complete in this duration is closed.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherDefaultRouteActionRequestMirrorPolicyArgs' request_mirror_policy: Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
               The load balancer does not wait for responses from the shadow service. Before sending traffic to the shadow service, the host / authority header is suffixed with -shadow.
               Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherDefaultRouteActionRetryPolicyArgs' retry_policy: Specifies the retry policy associated with this route.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherDefaultRouteActionTimeoutArgs' timeout: Specifies the timeout for the selected route. Timeout is computed from the time the request has been fully processed (known as end-of-stream) up until the response has been processed. Timeout includes all retries.
               If not specified, this field uses the largest timeout among all backend services associated with the route.
               Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherDefaultRouteActionUrlRewriteArgs' url_rewrite: The spec to modify the URL of the request, before forwarding the request to the matched service.
               urlRewrite is the only action supported in UrlMaps for external HTTP(S) load balancers.
               Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
               Structure is documented below.
        :param Sequence['RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceArgs'] weighted_backend_services: A list of weighted backend services to send traffic to when a route match occurs. The weights determine the fraction of traffic that flows to their corresponding backend service. If all traffic needs to go to a single backend service, there must be one weightedBackendService with weight set to a non-zero number.
               After a backend service is identified and before forwarding the request to the backend service, advanced routing actions such as URL rewrites and header transformations are applied depending on additional settings specified in this HttpRouteAction.
               Structure is documented below.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if fault_injection_policy is not None:
            pulumi.set(__self__, "fault_injection_policy", fault_injection_policy)
        if max_stream_duration is not None:
            pulumi.set(__self__, "max_stream_duration", max_stream_duration)
        if request_mirror_policy is not None:
            pulumi.set(__self__, "request_mirror_policy", request_mirror_policy)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)
        if weighted_backend_services is not None:
            pulumi.set(__self__, "weighted_backend_services", weighted_backend_services)

    @_builtins.property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see
        [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
        Structure is documented below.
        """
        return pulumi.get(self, "cors_policy")

    @_builtins.property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
        As part of fault injection, when clients send requests to a backend service, delays can be introduced by a load balancer on a percentage of requests before sending those requests to the backend service.
        Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
        timeout and retryPolicy is ignored by clients that are configured with a faultInjectionPolicy if: 1. The traffic is generated by fault injection AND 2. The fault injection is not a delay fault injection.
        Fault injection is not supported with the global external HTTP(S) load balancer (classic). To see which load balancers support fault injection, see Load balancing: [Routing and traffic management features](https://cloud.google.com/load-balancing/docs/features#routing-traffic-management).
        Structure is documented below.
        """
        return pulumi.get(self, "fault_injection_policy")

    @_builtins.property
    @pulumi.getter(name="maxStreamDuration")
    def max_stream_duration(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionMaxStreamDuration']:
        """
        Specifies the maximum duration (timeout) for streams on the selected route.
        Unlike the `Timeout` field where the timeout duration starts from the time the request
        has been fully processed (known as end-of-stream), the duration in this field
        is computed from the beginning of the stream until the response has been processed,
        including all retries. A stream that does not complete in this duration is closed.
        Structure is documented below.
        """
        return pulumi.get(self, "max_stream_duration")

    @_builtins.property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
        The load balancer does not wait for responses from the shadow service. Before sending traffic to the shadow service, the host / authority header is suffixed with -shadow.
        Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
        Structure is documented below.
        """
        return pulumi.get(self, "request_mirror_policy")

    @_builtins.property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        return pulumi.get(self, "retry_policy")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time the request has been fully processed (known as end-of-stream) up until the response has been processed. Timeout includes all retries.
        If not specified, this field uses the largest timeout among all backend services associated with the route.
        Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
        Structure is documented below.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, before forwarding the request to the matched service.
        urlRewrite is the only action supported in UrlMaps for external HTTP(S) load balancers.
        Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
        Structure is documented below.
        """
        return pulumi.get(self, "url_rewrite")

    @_builtins.property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match occurs. The weights determine the fraction of traffic that flows to their corresponding backend service. If all traffic needs to go to a single backend service, there must be one weightedBackendService with weight set to a non-zero number.
        After a backend service is identified and before forwarding the request to the backend service, advanced routing actions such as URL rewrites and header transformations are applied depending on additional settings specified in this HttpRouteAction.
        Structure is documented below.
        """
        return pulumi.get(self, "weighted_backend_services")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionCorsPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOriginRegexes":
            suggest = "allow_origin_regexes"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherDefaultRouteActionCorsPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionCorsPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionCorsPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origin_regexes: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional[Sequence[_builtins.str]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        :param _builtins.bool allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This field translates to the Access-Control-Allow-Credentials header.
               Default is false.
        :param Sequence[_builtins.str] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param Sequence[_builtins.str] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param Sequence[_builtins.str] allow_origin_regexes: Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[_builtins.str] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param _builtins.bool disabled: If true, the setting specifies the CORS policy is disabled. The default value of false, which indicates that the CORS policy is in effect.
        :param Sequence[_builtins.str] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param _builtins.int max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin_regexes is not None:
            pulumi.set(__self__, "allow_origin_regexes", allow_origin_regexes)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This field translates to the Access-Control-Allow-Credentials header.
        Default is false.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origin_regexes")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If true, the setting specifies the CORS policy is disabled. The default value of false, which indicates that the CORS policy is in effect.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicy(dict):
    def __init__(__self__, *,
                 abort: Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort'] = None,
                 delay: Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay'] = None):
        """
        :param 'RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbortArgs' abort: The specification for how client requests are aborted as part of fault injection.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayArgs' delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
               Structure is documented below.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def abort(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        return pulumi.get(self, "abort")

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpStatus":
            suggest = "http_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_status: Optional[_builtins.int] = None,
                 percentage: Optional[_builtins.float] = None):
        """
        :param _builtins.int http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if http_status is not None:
            pulumi.set(__self__, "http_status", http_status)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[_builtins.int]:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        return pulumi.get(self, "http_status")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedDelay":
            suggest = "fixed_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_delay: Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay'] = None,
                 percentage: Optional[_builtins.float] = None):
        """
        :param 'RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayArgs' fixed_delay: Specifies the value of the fixed delay interval.
               Structure is documented below.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if fixed_delay is not None:
            pulumi.set(__self__, "fixed_delay", fixed_delay)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay']:
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_delay")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionMaxStreamDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionRequestMirrorPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "mirrorPercent":
            suggest = "mirror_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherDefaultRouteActionRequestMirrorPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: _builtins.str,
                 mirror_percent: Optional[_builtins.float] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the RegionBackendService resource being mirrored to.
               The backend service configured for a mirroring policy must reference backends that are of the same type as the original backend service matched in the URL map.
               Serverless NEG backends are not currently supported as a mirrored backend service.
        :param _builtins.float mirror_percent: The percentage of requests to be mirrored to backendService.
               The value must be between 0.0 and 100.0 inclusive.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        if mirror_percent is not None:
            pulumi.set(__self__, "mirror_percent", mirror_percent)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> _builtins.str:
        """
        The full or partial URL to the RegionBackendService resource being mirrored to.
        The backend service configured for a mirroring policy must reference backends that are of the same type as the original backend service matched in the URL map.
        Serverless NEG backends are not currently supported as a mirrored backend service.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter(name="mirrorPercent")
    def mirror_percent(self) -> Optional[_builtins.float]:
        """
        The percentage of requests to be mirrored to backendService.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "mirror_percent")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionRetryPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numRetries":
            suggest = "num_retries"
        elif key == "perTryTimeout":
            suggest = "per_try_timeout"
        elif key == "retryConditions":
            suggest = "retry_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherDefaultRouteActionRetryPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionRetryPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionRetryPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_retries: Optional[_builtins.int] = None,
                 per_try_timeout: Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout'] = None,
                 retry_conditions: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param 'RegionUrlMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutArgs' per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param Sequence[_builtins.str] retry_conditions: Specifies one or more conditions when this retry policy applies.
               Valid values are listed below. Only the following codes are supported when the URL map is bound to target gRPC proxy that has validateForProxyless field set to true: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
               - 5xx : retry is attempted if the instance or endpoint responds with any 5xx response code, or if the instance or endpoint does not respond at all. For example, disconnects, reset, read timeout, connection failure, and refused streams.
               - gateway-error : Similar to 5xx, but only applies to response codes 502, 503 or 504.
               - connect-failure : a retry is attempted on failures connecting to the instance or endpoint. For example, connection timeouts.
               - retriable-4xx : a retry is attempted if the instance or endpoint responds with a 4xx response code. The only error that you can retry is error code 409.
               - refused-stream : a retry is attempted if the instance or endpoint resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
               - cancelled : a retry is attempted if the gRPC status code in the response header is set to cancelled.
               - deadline-exceeded : a retry is attempted if the gRPC status code in the response header is set to deadline-exceeded.
               - internal :  a retry is attempted if the gRPC status code in the response header is set to internal.
               - resource-exhausted : a retry is attempted if the gRPC status code in the response header is set to resource-exhausted.
               - unavailable : a retry is attempted if the gRPC status code in the response header is set to unavailable.
        """
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_conditions is not None:
            pulumi.set(__self__, "retry_conditions", retry_conditions)

    @_builtins.property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[_builtins.int]:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        return pulumi.get(self, "num_retries")

    @_builtins.property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "per_try_timeout")

    @_builtins.property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies one or more conditions when this retry policy applies.
        Valid values are listed below. Only the following codes are supported when the URL map is bound to target gRPC proxy that has validateForProxyless field set to true: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
        - 5xx : retry is attempted if the instance or endpoint responds with any 5xx response code, or if the instance or endpoint does not respond at all. For example, disconnects, reset, read timeout, connection failure, and refused streams.
        - gateway-error : Similar to 5xx, but only applies to response codes 502, 503 or 504.
        - connect-failure : a retry is attempted on failures connecting to the instance or endpoint. For example, connection timeouts.
        - retriable-4xx : a retry is attempted if the instance or endpoint responds with a 4xx response code. The only error that you can retry is error code 409.
        - refused-stream : a retry is attempted if the instance or endpoint resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        - cancelled : a retry is attempted if the gRPC status code in the response header is set to cancelled.
        - deadline-exceeded : a retry is attempted if the gRPC status code in the response header is set to deadline-exceeded.
        - internal :  a retry is attempted if the gRPC status code in the response header is set to internal.
        - resource-exhausted : a retry is attempted if the gRPC status code in the response header is set to resource-exhausted.
        - unavailable : a retry is attempted if the gRPC status code in the response header is set to unavailable.
        """
        return pulumi.get(self, "retry_conditions")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionTimeout(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionUrlRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostRewrite":
            suggest = "host_rewrite"
        elif key == "pathPrefixRewrite":
            suggest = "path_prefix_rewrite"
        elif key == "pathTemplateRewrite":
            suggest = "path_template_rewrite"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherDefaultRouteActionUrlRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionUrlRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionUrlRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_rewrite: Optional[_builtins.str] = None,
                 path_prefix_rewrite: Optional[_builtins.str] = None,
                 path_template_rewrite: Optional[_builtins.str] = None):
        """
        :param _builtins.str host_rewrite: Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite.
               The value must be from 1 to 255 characters.
        :param _builtins.str path_prefix_rewrite: Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite.
               The value must be from 1 to 1024 characters.
        :param _builtins.str path_template_rewrite: If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax.
               A corresponding pathTemplateMatch must be specified. Any template variables must exist in the pathTemplateMatch field.
               * At least one variable must be specified in the pathTemplateMatch field
               * You can omit variables from the rewritten URL
               * The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}.
               For example, a pathTemplateMatch of /static/{format=**} could be rewritten as /static/content/{format} to prefix
               /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be
               rewritten as /content/{format}/{country}/{suffix}.
               At least one non-empty routeRules[].matchRules[].path_template_match is required.
               Only one of pathPrefixRewrite or pathTemplateRewrite may be specified.
        """
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if path_prefix_rewrite is not None:
            pulumi.set(__self__, "path_prefix_rewrite", path_prefix_rewrite)
        if path_template_rewrite is not None:
            pulumi.set(__self__, "path_template_rewrite", path_template_rewrite)

    @_builtins.property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[_builtins.str]:
        """
        Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite.
        The value must be from 1 to 255 characters.
        """
        return pulumi.get(self, "host_rewrite")

    @_builtins.property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[_builtins.str]:
        """
        Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite.
        The value must be from 1 to 1024 characters.
        """
        return pulumi.get(self, "path_prefix_rewrite")

    @_builtins.property
    @pulumi.getter(name="pathTemplateRewrite")
    def path_template_rewrite(self) -> Optional[_builtins.str]:
        """
        If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax.
        A corresponding pathTemplateMatch must be specified. Any template variables must exist in the pathTemplateMatch field.
        * At least one variable must be specified in the pathTemplateMatch field
        * You can omit variables from the rewritten URL
        * The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}.
        For example, a pathTemplateMatch of /static/{format=**} could be rewritten as /static/content/{format} to prefix
        /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be
        rewritten as /content/{format}/{country}/{suffix}.
        At least one non-empty routeRules[].matchRules[].path_template_match is required.
        Only one of pathPrefixRewrite or pathTemplateRewrite may be specified.
        """
        return pulumi.get(self, "path_template_rewrite")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "headerAction":
            suggest = "header_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: Optional[_builtins.str] = None,
                 header_action: Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction'] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
        :param 'RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
               headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
               Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
               Structure is documented below.
        :param _builtins.int weight: Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy.
               The value must be from 0 to 1000.
        """
        if backend_service is not None:
            pulumi.set(__self__, "backend_service", backend_service)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> Optional[_builtins.str]:
        """
        The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
        headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
        Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy.
        The value must be from 0 to 1000.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"
        elif key == "requestHeadersToRemoves":
            suggest = "request_headers_to_removes"
        elif key == "responseHeadersToAdds":
            suggest = "response_headers_to_adds"
        elif key == "responseHeadersToRemoves":
            suggest = "response_headers_to_removes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[_builtins.str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request before forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[_builtins.str] request_headers_to_removes: A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
        :param Sequence['RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response before sending the response back to the client.
               Structure is documented below.
        :param Sequence[_builtins.str] response_headers_to_removes: A list of header names for headers that need to be removed from the response before sending the response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request before forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response before sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the response before sending the response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[_builtins.str] = None,
                 header_value: Optional[_builtins.str] = None,
                 replace: Optional[_builtins.bool] = None):
        """
        :param _builtins.str header_name: The name of the header.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
               The default value is false.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.bool]:
        """
        If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
        The default value is false.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[_builtins.str] = None,
                 header_value: Optional[_builtins.str] = None,
                 replace: Optional[_builtins.bool] = None):
        """
        :param _builtins.str header_name: The name of the header.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
               The default value is false.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.bool]:
        """
        If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
        The default value is false.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class RegionUrlMapPathMatcherDefaultUrlRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stripQuery":
            suggest = "strip_query"
        elif key == "hostRedirect":
            suggest = "host_redirect"
        elif key == "httpsRedirect":
            suggest = "https_redirect"
        elif key == "pathRedirect":
            suggest = "path_redirect"
        elif key == "prefixRedirect":
            suggest = "prefix_redirect"
        elif key == "redirectResponseCode":
            suggest = "redirect_response_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherDefaultUrlRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherDefaultUrlRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherDefaultUrlRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 strip_query: _builtins.bool,
                 host_redirect: Optional[_builtins.str] = None,
                 https_redirect: Optional[_builtins.bool] = None,
                 path_redirect: Optional[_builtins.str] = None,
                 prefix_redirect: Optional[_builtins.str] = None,
                 redirect_response_code: Optional[_builtins.str] = None):
        """
        :param _builtins.bool strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param _builtins.str host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param _builtins.bool https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param _builtins.str path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param _builtins.str prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param _builtins.str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        pulumi.set(__self__, "strip_query", strip_query)
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)

    @_builtins.property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> _builtins.bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        return pulumi.get(self, "strip_query")

    @_builtins.property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[_builtins.str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_redirect")

    @_builtins.property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[_builtins.bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        return pulumi.get(self, "https_redirect")

    @_builtins.property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[_builtins.str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        return pulumi.get(self, "path_redirect")

    @_builtins.property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[_builtins.str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "prefix_redirect")

    @_builtins.property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[_builtins.str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")


@pulumi.output_type
class RegionUrlMapPathMatcherHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"
        elif key == "requestHeadersToRemoves":
            suggest = "request_headers_to_removes"
        elif key == "responseHeadersToAdds":
            suggest = "response_headers_to_adds"
        elif key == "responseHeadersToRemoves":
            suggest = "response_headers_to_removes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[_builtins.str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['RegionUrlMapPathMatcherHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request before forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[_builtins.str] request_headers_to_removes: A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
        :param Sequence['RegionUrlMapPathMatcherHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response before sending the response back to the client.
               Structure is documented below.
        :param Sequence[_builtins.str] response_headers_to_removes: A list of header names for headers that need to be removed from the response before sending the response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request before forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response before sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the response before sending the response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")


@pulumi.output_type
class RegionUrlMapPathMatcherHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[_builtins.str] = None,
                 header_value: Optional[_builtins.str] = None,
                 replace: Optional[_builtins.bool] = None):
        """
        :param _builtins.str header_name: The name of the header.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
               The default value is false.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.bool]:
        """
        If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
        The default value is false.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class RegionUrlMapPathMatcherHeaderActionResponseHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherHeaderActionResponseHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[_builtins.str] = None,
                 header_value: Optional[_builtins.str] = None,
                 replace: Optional[_builtins.bool] = None):
        """
        :param _builtins.str header_name: The name of the header.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
               The default value is false.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.bool]:
        """
        If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
        The default value is false.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeAction":
            suggest = "route_action"
        elif key == "urlRedirect":
            suggest = "url_redirect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherPathRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherPathRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherPathRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paths: Sequence[_builtins.str],
                 route_action: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteAction'] = None,
                 service: Optional[_builtins.str] = None,
                 url_redirect: Optional['outputs.RegionUrlMapPathMatcherPathRuleUrlRedirect'] = None):
        """
        :param Sequence[_builtins.str] paths: The list of path patterns to match. Each must start with / and the only place a
               \\* is allowed is at the end following a /. The string fed to the path matcher
               does not include any text after the first ? or #, and those chars are not
               allowed here.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionArgs' route_action: In response to a matching path, the load balancer performs advanced routing
               actions like URL rewrites, header transformations, etc. prior to forwarding the
               request to the selected backend. If routeAction specifies any
               weightedBackendServices, service must not be set. Conversely if service is set,
               routeAction cannot contain any  weightedBackendServices. Only one of routeAction
               or urlRedirect must be set.
               Structure is documented below.
        :param _builtins.str service: The region backend service resource to which traffic is
               directed if this rule is matched. If routeAction is additionally specified,
               advanced routing actions like URL Rewrites, etc. take effect prior to sending
               the request to the backend. However, if service is specified, routeAction cannot
               contain any weightedBackendService s. Conversely, if routeAction specifies any
               weightedBackendServices, service must not be specified. Only one of urlRedirect,
               service or routeAction.weightedBackendService must be set.
        :param 'RegionUrlMapPathMatcherPathRuleUrlRedirectArgs' url_redirect: When a path pattern is matched, the request is redirected to a URL specified
               by urlRedirect. If urlRedirect is specified, service or routeAction must not
               be set.
               Structure is documented below.
        """
        pulumi.set(__self__, "paths", paths)
        if route_action is not None:
            pulumi.set(__self__, "route_action", route_action)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if url_redirect is not None:
            pulumi.set(__self__, "url_redirect", url_redirect)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence[_builtins.str]:
        """
        The list of path patterns to match. Each must start with / and the only place a
        \\* is allowed is at the end following a /. The string fed to the path matcher
        does not include any text after the first ? or #, and those chars are not
        allowed here.
        """
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter(name="routeAction")
    def route_action(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteAction']:
        """
        In response to a matching path, the load balancer performs advanced routing
        actions like URL rewrites, header transformations, etc. prior to forwarding the
        request to the selected backend. If routeAction specifies any
        weightedBackendServices, service must not be set. Conversely if service is set,
        routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        or urlRedirect must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "route_action")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        The region backend service resource to which traffic is
        directed if this rule is matched. If routeAction is additionally specified,
        advanced routing actions like URL Rewrites, etc. take effect prior to sending
        the request to the backend. However, if service is specified, routeAction cannot
        contain any weightedBackendService s. Conversely, if routeAction specifies any
        weightedBackendServices, service must not be specified. Only one of urlRedirect,
        service or routeAction.weightedBackendService must be set.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="urlRedirect")
    def url_redirect(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleUrlRedirect']:
        """
        When a path pattern is matched, the request is redirected to a URL specified
        by urlRedirect. If urlRedirect is specified, service or routeAction must not
        be set.
        Structure is documented below.
        """
        return pulumi.get(self, "url_redirect")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "corsPolicy":
            suggest = "cors_policy"
        elif key == "faultInjectionPolicy":
            suggest = "fault_injection_policy"
        elif key == "requestMirrorPolicy":
            suggest = "request_mirror_policy"
        elif key == "retryPolicy":
            suggest = "retry_policy"
        elif key == "urlRewrite":
            suggest = "url_rewrite"
        elif key == "weightedBackendServices":
            suggest = "weighted_backend_services"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherPathRuleRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cors_policy: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy'] = None,
                 fault_injection_policy: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy'] = None,
                 request_mirror_policy: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy'] = None,
                 retry_policy: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy'] = None,
                 timeout: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionTimeout'] = None,
                 url_rewrite: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite'] = None,
                 weighted_backend_services: Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService']] = None):
        """
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicyArgs' cors_policy: The specification for allowing client side cross-origin requests. Please see W3C
               Recommendation for Cross Origin Resource Sharing
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyArgs' fault_injection_policy: The specification for fault injection introduced into traffic to test the
               resiliency of clients to backend service failure. As part of fault injection,
               when clients send requests to a backend service, delays can be introduced by
               Loadbalancer on a percentage of requests before sending those request to the
               backend service. Similarly requests from clients can be aborted by the
               Loadbalancer for a percentage of requests. timeout and retry_policy will be
               ignored by clients that are configured with a fault_injection_policy.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicyArgs' request_mirror_policy: Specifies the policy on how requests intended for the route's backends are
               shadowed to a separate mirrored backend service. Loadbalancer does not wait for
               responses from the shadow service. Prior to sending traffic to the shadow
               service, the host / authority header is suffixed with -shadow.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyArgs' retry_policy: Specifies the retry policy associated with this route.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionTimeoutArgs' timeout: Specifies the timeout for the selected route. Timeout is computed from the time
               the request is has been fully processed (i.e. end-of-stream) up until the
               response has been completely processed. Timeout includes all retries. If not
               specified, the default value is 15 seconds.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionUrlRewriteArgs' url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to
               the matched service
               Structure is documented below.
        :param Sequence['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceArgs'] weighted_backend_services: A list of weighted backend services to send traffic to when a route match
               occurs. The weights determine the fraction of traffic that flows to their
               corresponding backend service. If all traffic needs to go to a single backend
               service, there must be one  weightedBackendService with weight set to a non 0
               number. Once a backendService is identified and before forwarding the request to
               the backend service, advanced routing actions like Url rewrites and header
               transformations are applied depending on additional settings specified in this
               HttpRouteAction.
               Structure is documented below.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if fault_injection_policy is not None:
            pulumi.set(__self__, "fault_injection_policy", fault_injection_policy)
        if request_mirror_policy is not None:
            pulumi.set(__self__, "request_mirror_policy", request_mirror_policy)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)
        if weighted_backend_services is not None:
            pulumi.set(__self__, "weighted_backend_services", weighted_backend_services)

    @_builtins.property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see W3C
        Recommendation for Cross Origin Resource Sharing
        Structure is documented below.
        """
        return pulumi.get(self, "cors_policy")

    @_builtins.property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the
        resiliency of clients to backend service failure. As part of fault injection,
        when clients send requests to a backend service, delays can be introduced by
        Loadbalancer on a percentage of requests before sending those request to the
        backend service. Similarly requests from clients can be aborted by the
        Loadbalancer for a percentage of requests. timeout and retry_policy will be
        ignored by clients that are configured with a fault_injection_policy.
        Structure is documented below.
        """
        return pulumi.get(self, "fault_injection_policy")

    @_builtins.property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are
        shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        responses from the shadow service. Prior to sending traffic to the shadow
        service, the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        return pulumi.get(self, "request_mirror_policy")

    @_builtins.property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        return pulumi.get(self, "retry_policy")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time
        the request is has been fully processed (i.e. end-of-stream) up until the
        response has been completely processed. Timeout includes all retries. If not
        specified, the default value is 15 seconds.
        Structure is documented below.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to
        the matched service
        Structure is documented below.
        """
        return pulumi.get(self, "url_rewrite")

    @_builtins.property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match
        occurs. The weights determine the fraction of traffic that flows to their
        corresponding backend service. If all traffic needs to go to a single backend
        service, there must be one  weightedBackendService with weight set to a non 0
        number. Once a backendService is identified and before forwarding the request to
        the backend service, advanced routing actions like Url rewrites and header
        transformations are applied depending on additional settings specified in this
        HttpRouteAction.
        Structure is documented below.
        """
        return pulumi.get(self, "weighted_backend_services")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOriginRegexes":
            suggest = "allow_origin_regexes"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: _builtins.bool,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origin_regexes: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional[Sequence[_builtins.str]] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        :param _builtins.bool disabled: If true, the setting specifies the CORS policy is disabled. The default value of false, which indicates that the CORS policy is in effect.
        :param _builtins.bool allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This field translates to the Access-Control-Allow-Credentials header.
               Default is false.
        :param Sequence[_builtins.str] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param Sequence[_builtins.str] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param Sequence[_builtins.str] allow_origin_regexes: Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[_builtins.str] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[_builtins.str] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param _builtins.int max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        pulumi.set(__self__, "disabled", disabled)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin_regexes is not None:
            pulumi.set(__self__, "allow_origin_regexes", allow_origin_regexes)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        If true, the setting specifies the CORS policy is disabled. The default value of false, which indicates that the CORS policy is in effect.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This field translates to the Access-Control-Allow-Credentials header.
        Default is false.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origin_regexes")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy(dict):
    def __init__(__self__, *,
                 abort: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort'] = None,
                 delay: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay'] = None):
        """
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortArgs' abort: The specification for how client requests are aborted as part of fault injection.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayArgs' delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
               Structure is documented below.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def abort(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        return pulumi.get(self, "abort")

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpStatus":
            suggest = "http_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_status: _builtins.int,
                 percentage: _builtins.float):
        """
        :param _builtins.int http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        pulumi.set(__self__, "http_status", http_status)
        pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> _builtins.int:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        return pulumi.get(self, "http_status")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> _builtins.float:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedDelay":
            suggest = "fixed_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_delay: 'outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
                 percentage: _builtins.float):
        """
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs' fixed_delay: Specifies the value of the fixed delay interval.
               Structure is documented below.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        pulumi.set(__self__, "fixed_delay", fixed_delay)
        pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> 'outputs.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay':
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_delay")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> _builtins.float:
        """
        The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "mirrorPercent":
            suggest = "mirror_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: _builtins.str,
                 mirror_percent: Optional[_builtins.float] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the RegionBackendService resource being mirrored to.
               The backend service configured for a mirroring policy must reference backends that are of the same type as the original backend service matched in the URL map.
               Serverless NEG backends are not currently supported as a mirrored backend service.
        :param _builtins.float mirror_percent: The percentage of requests to be mirrored to backendService.
               The value must be between 0.0 and 100.0 inclusive.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        if mirror_percent is not None:
            pulumi.set(__self__, "mirror_percent", mirror_percent)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> _builtins.str:
        """
        The full or partial URL to the RegionBackendService resource being mirrored to.
        The backend service configured for a mirroring policy must reference backends that are of the same type as the original backend service matched in the URL map.
        Serverless NEG backends are not currently supported as a mirrored backend service.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter(name="mirrorPercent")
    def mirror_percent(self) -> Optional[_builtins.float]:
        """
        The percentage of requests to be mirrored to backendService.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "mirror_percent")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numRetries":
            suggest = "num_retries"
        elif key == "perTryTimeout":
            suggest = "per_try_timeout"
        elif key == "retryConditions":
            suggest = "retry_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_retries: Optional[_builtins.int] = None,
                 per_try_timeout: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout'] = None,
                 retry_conditions: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutArgs' per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param Sequence[_builtins.str] retry_conditions: Specifies one or more conditions when this retry policy applies.
               Valid values are listed below. Only the following codes are supported when the URL map is bound to target gRPC proxy that has validateForProxyless field set to true: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
               - 5xx : retry is attempted if the instance or endpoint responds with any 5xx response code, or if the instance or endpoint does not respond at all. For example, disconnects, reset, read timeout, connection failure, and refused streams.
               - gateway-error : Similar to 5xx, but only applies to response codes 502, 503 or 504.
               - connect-failure : a retry is attempted on failures connecting to the instance or endpoint. For example, connection timeouts.
               - retriable-4xx : a retry is attempted if the instance or endpoint responds with a 4xx response code. The only error that you can retry is error code 409.
               - refused-stream : a retry is attempted if the instance or endpoint resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
               - cancelled : a retry is attempted if the gRPC status code in the response header is set to cancelled.
               - deadline-exceeded : a retry is attempted if the gRPC status code in the response header is set to deadline-exceeded.
               - internal :  a retry is attempted if the gRPC status code in the response header is set to internal.
               - resource-exhausted : a retry is attempted if the gRPC status code in the response header is set to resource-exhausted.
               - unavailable : a retry is attempted if the gRPC status code in the response header is set to unavailable.
        """
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_conditions is not None:
            pulumi.set(__self__, "retry_conditions", retry_conditions)

    @_builtins.property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[_builtins.int]:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        return pulumi.get(self, "num_retries")

    @_builtins.property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "per_try_timeout")

    @_builtins.property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies one or more conditions when this retry policy applies.
        Valid values are listed below. Only the following codes are supported when the URL map is bound to target gRPC proxy that has validateForProxyless field set to true: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
        - 5xx : retry is attempted if the instance or endpoint responds with any 5xx response code, or if the instance or endpoint does not respond at all. For example, disconnects, reset, read timeout, connection failure, and refused streams.
        - gateway-error : Similar to 5xx, but only applies to response codes 502, 503 or 504.
        - connect-failure : a retry is attempted on failures connecting to the instance or endpoint. For example, connection timeouts.
        - retriable-4xx : a retry is attempted if the instance or endpoint responds with a 4xx response code. The only error that you can retry is error code 409.
        - refused-stream : a retry is attempted if the instance or endpoint resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        - cancelled : a retry is attempted if the gRPC status code in the response header is set to cancelled.
        - deadline-exceeded : a retry is attempted if the gRPC status code in the response header is set to deadline-exceeded.
        - internal :  a retry is attempted if the gRPC status code in the response header is set to internal.
        - resource-exhausted : a retry is attempted if the gRPC status code in the response header is set to resource-exhausted.
        - unavailable : a retry is attempted if the gRPC status code in the response header is set to unavailable.
        """
        return pulumi.get(self, "retry_conditions")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostRewrite":
            suggest = "host_rewrite"
        elif key == "pathPrefixRewrite":
            suggest = "path_prefix_rewrite"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_rewrite: Optional[_builtins.str] = None,
                 path_prefix_rewrite: Optional[_builtins.str] = None):
        """
        :param _builtins.str host_rewrite: Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite.
               The value must be from 1 to 255 characters.
        :param _builtins.str path_prefix_rewrite: Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite.
               The value must be from 1 to 1024 characters.
        """
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if path_prefix_rewrite is not None:
            pulumi.set(__self__, "path_prefix_rewrite", path_prefix_rewrite)

    @_builtins.property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[_builtins.str]:
        """
        Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite.
        The value must be from 1 to 255 characters.
        """
        return pulumi.get(self, "host_rewrite")

    @_builtins.property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[_builtins.str]:
        """
        Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite.
        The value must be from 1 to 1024 characters.
        """
        return pulumi.get(self, "path_prefix_rewrite")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "headerAction":
            suggest = "header_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: _builtins.str,
                 weight: _builtins.int,
                 header_action: Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction'] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
        :param _builtins.int weight: Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy.
               The value must be from 0 to 1000.
        :param 'RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
               headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
               Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
               Structure is documented below.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        pulumi.set(__self__, "weight", weight)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> _builtins.str:
        """
        The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy.
        The value must be from 0 to 1000.
        """
        return pulumi.get(self, "weight")

    @_builtins.property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
        headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
        Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"
        elif key == "requestHeadersToRemoves":
            suggest = "request_headers_to_removes"
        elif key == "responseHeadersToAdds":
            suggest = "response_headers_to_adds"
        elif key == "responseHeadersToRemoves":
            suggest = "response_headers_to_removes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[_builtins.str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request before forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[_builtins.str] request_headers_to_removes: A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
        :param Sequence['RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response before sending the response back to the client.
               Structure is documented below.
        :param Sequence[_builtins.str] response_headers_to_removes: A list of header names for headers that need to be removed from the response before sending the response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request before forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response before sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the response before sending the response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
               The default value is false.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
        The default value is false.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
               The default value is false.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
        The default value is false.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class RegionUrlMapPathMatcherPathRuleUrlRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stripQuery":
            suggest = "strip_query"
        elif key == "hostRedirect":
            suggest = "host_redirect"
        elif key == "httpsRedirect":
            suggest = "https_redirect"
        elif key == "pathRedirect":
            suggest = "path_redirect"
        elif key == "prefixRedirect":
            suggest = "prefix_redirect"
        elif key == "redirectResponseCode":
            suggest = "redirect_response_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherPathRuleUrlRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherPathRuleUrlRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherPathRuleUrlRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 strip_query: _builtins.bool,
                 host_redirect: Optional[_builtins.str] = None,
                 https_redirect: Optional[_builtins.bool] = None,
                 path_redirect: Optional[_builtins.str] = None,
                 prefix_redirect: Optional[_builtins.str] = None,
                 redirect_response_code: Optional[_builtins.str] = None):
        """
        :param _builtins.bool strip_query: If set to true, any accompanying query portion of the original URL is removed
               prior to redirecting the request. If set to false, the query portion of the
               original URL is retained.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param _builtins.str host_redirect: The host that will be used in the redirect response instead of the one
               that was supplied in the request. The value must be between 1 and 255
               characters.
        :param _builtins.bool https_redirect: If set to true, the URL scheme in the redirected request is set to https.
               If set to false, the URL scheme of the redirected request will remain the
               same as that of the request. This must only be set for UrlMaps used in
               TargetHttpProxys. Setting this true for TargetHttpsProxy is not
               permitted. The default is set to false.
        :param _builtins.str path_redirect: The path that will be used in the redirect response instead of the one
               that was supplied in the request. pathRedirect cannot be supplied
               together with prefixRedirect. Supply one alone or neither. If neither is
               supplied, the path of the original request will be used for the redirect.
               The value must be between 1 and 1024 characters.
        :param _builtins.str prefix_redirect: The prefix that replaces the prefixMatch specified in the
               HttpRouteRuleMatch, retaining the remaining portion of the URL before
               redirecting the request. prefixRedirect cannot be supplied together with
               pathRedirect. Supply one alone or neither. If neither is supplied, the
               path of the original request will be used for the redirect. The value
               must be between 1 and 1024 characters.
        :param _builtins.str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        pulumi.set(__self__, "strip_query", strip_query)
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)

    @_builtins.property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> _builtins.bool:
        """
        If set to true, any accompanying query portion of the original URL is removed
        prior to redirecting the request. If set to false, the query portion of the
        original URL is retained.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        return pulumi.get(self, "strip_query")

    @_builtins.property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[_builtins.str]:
        """
        The host that will be used in the redirect response instead of the one
        that was supplied in the request. The value must be between 1 and 255
        characters.
        """
        return pulumi.get(self, "host_redirect")

    @_builtins.property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[_builtins.bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https.
        If set to false, the URL scheme of the redirected request will remain the
        same as that of the request. This must only be set for UrlMaps used in
        TargetHttpProxys. Setting this true for TargetHttpsProxy is not
        permitted. The default is set to false.
        """
        return pulumi.get(self, "https_redirect")

    @_builtins.property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[_builtins.str]:
        """
        The path that will be used in the redirect response instead of the one
        that was supplied in the request. pathRedirect cannot be supplied
        together with prefixRedirect. Supply one alone or neither. If neither is
        supplied, the path of the original request will be used for the redirect.
        The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "path_redirect")

    @_builtins.property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[_builtins.str]:
        """
        The prefix that replaces the prefixMatch specified in the
        HttpRouteRuleMatch, retaining the remaining portion of the URL before
        redirecting the request. prefixRedirect cannot be supplied together with
        pathRedirect. Supply one alone or neither. If neither is supplied, the
        path of the original request will be used for the redirect. The value
        must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "prefix_redirect")

    @_builtins.property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[_builtins.str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerAction":
            suggest = "header_action"
        elif key == "matchRules":
            suggest = "match_rules"
        elif key == "routeAction":
            suggest = "route_action"
        elif key == "urlRedirect":
            suggest = "url_redirect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 priority: _builtins.int,
                 header_action: Optional['outputs.RegionUrlMapPathMatcherRouteRuleHeaderAction'] = None,
                 match_rules: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRule']] = None,
                 route_action: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteAction'] = None,
                 service: Optional[_builtins.str] = None,
                 url_redirect: Optional['outputs.RegionUrlMapPathMatcherRouteRuleUrlRedirect'] = None):
        """
        :param _builtins.int priority: For routeRules within a given pathMatcher, priority determines the order
               in which load balancer will interpret routeRules. RouteRules are evaluated
               in order of priority, from the lowest to highest number. The priority of
               a rule decreases as its number increases (1, 2, 3, N+1). The first rule
               that matches the request is applied.
               You cannot configure two or more routeRules with the same priority.
               Priority for each rule must be set to a number between 0 and
               2147483647 inclusive.
               Priority numbers can have gaps, which enable you to add or remove rules
               in the future without affecting the rest of the rules. For example,
               1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
               you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
               future without any impact on existing rules.
        :param 'RegionUrlMapPathMatcherRouteRuleHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService. The headerAction specified here are applied before
               the matching pathMatchers[].headerAction and after pathMatchers[].routeRules[].r
               outeAction.weightedBackendService.backendServiceWeightAction[].headerAction
               Structure is documented below.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleMatchRuleArgs'] match_rules: The rules for determining a match.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionArgs' route_action: In response to a matching matchRule, the load balancer performs advanced routing
               actions like URL rewrites, header transformations, etc. prior to forwarding the
               request to the selected backend. If  routeAction specifies any
               weightedBackendServices, service must not be set. Conversely if service is set,
               routeAction cannot contain any  weightedBackendServices. Only one of routeAction
               or urlRedirect must be set.
               Structure is documented below.
        :param _builtins.str service: The region backend service resource to which traffic is
               directed if this rule is matched. If routeAction is additionally specified,
               advanced routing actions like URL Rewrites, etc. take effect prior to sending
               the request to the backend. However, if service is specified, routeAction cannot
               contain any weightedBackendService s. Conversely, if routeAction specifies any
               weightedBackendServices, service must not be specified. Only one of urlRedirect,
               service or routeAction.weightedBackendService must be set.
        :param 'RegionUrlMapPathMatcherRouteRuleUrlRedirectArgs' url_redirect: When this rule is matched, the request is redirected to a URL specified by
               urlRedirect. If urlRedirect is specified, service or routeAction must not be
               set.
               Structure is documented below.
        """
        pulumi.set(__self__, "priority", priority)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)
        if match_rules is not None:
            pulumi.set(__self__, "match_rules", match_rules)
        if route_action is not None:
            pulumi.set(__self__, "route_action", route_action)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if url_redirect is not None:
            pulumi.set(__self__, "url_redirect", url_redirect)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        For routeRules within a given pathMatcher, priority determines the order
        in which load balancer will interpret routeRules. RouteRules are evaluated
        in order of priority, from the lowest to highest number. The priority of
        a rule decreases as its number increases (1, 2, 3, N+1). The first rule
        that matches the request is applied.
        You cannot configure two or more routeRules with the same priority.
        Priority for each rule must be set to a number between 0 and
        2147483647 inclusive.
        Priority numbers can have gaps, which enable you to add or remove rules
        in the future without affecting the rest of the rules. For example,
        1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
        you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
        future without any impact on existing rules.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService. The headerAction specified here are applied before
        the matching pathMatchers[].headerAction and after pathMatchers[].routeRules[].r
        outeAction.weightedBackendService.backendServiceWeightAction[].headerAction
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    @_builtins.property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRule']]:
        """
        The rules for determining a match.
        Structure is documented below.
        """
        return pulumi.get(self, "match_rules")

    @_builtins.property
    @pulumi.getter(name="routeAction")
    def route_action(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteAction']:
        """
        In response to a matching matchRule, the load balancer performs advanced routing
        actions like URL rewrites, header transformations, etc. prior to forwarding the
        request to the selected backend. If  routeAction specifies any
        weightedBackendServices, service must not be set. Conversely if service is set,
        routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        or urlRedirect must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "route_action")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        The region backend service resource to which traffic is
        directed if this rule is matched. If routeAction is additionally specified,
        advanced routing actions like URL Rewrites, etc. take effect prior to sending
        the request to the backend. However, if service is specified, routeAction cannot
        contain any weightedBackendService s. Conversely, if routeAction specifies any
        weightedBackendServices, service must not be specified. Only one of urlRedirect,
        service or routeAction.weightedBackendService must be set.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="urlRedirect")
    def url_redirect(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleUrlRedirect']:
        """
        When this rule is matched, the request is redirected to a URL specified by
        urlRedirect. If urlRedirect is specified, service or routeAction must not be
        set.
        Structure is documented below.
        """
        return pulumi.get(self, "url_redirect")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"
        elif key == "requestHeadersToRemoves":
            suggest = "request_headers_to_removes"
        elif key == "responseHeadersToAdds":
            suggest = "response_headers_to_adds"
        elif key == "responseHeadersToRemoves":
            suggest = "response_headers_to_removes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[_builtins.str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request before forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[_builtins.str] request_headers_to_removes: A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response before sending the response back to the client.
               Structure is documented below.
        :param Sequence[_builtins.str] response_headers_to_removes: A list of header names for headers that need to be removed from the response before sending the response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request before forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response before sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the response before sending the response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
               The default value is false.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
        The default value is false.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
               The default value is false.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
        The default value is false.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullPathMatch":
            suggest = "full_path_match"
        elif key == "headerMatches":
            suggest = "header_matches"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "metadataFilters":
            suggest = "metadata_filters"
        elif key == "pathTemplateMatch":
            suggest = "path_template_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "queryParameterMatches":
            suggest = "query_parameter_matches"
        elif key == "regexMatch":
            suggest = "regex_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleMatchRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleMatchRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleMatchRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 full_path_match: Optional[_builtins.str] = None,
                 header_matches: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch']] = None,
                 ignore_case: Optional[_builtins.bool] = None,
                 metadata_filters: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter']] = None,
                 path_template_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 query_parameter_matches: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch']] = None,
                 regex_match: Optional[_builtins.str] = None):
        """
        :param _builtins.str full_path_match: For satisfying the matchRule condition, the path of the request must exactly
               match the value specified in fullPathMatch after removing any query parameters
               and anchor that may be part of the original URL. FullPathMatch must be between 1
               and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
               be specified.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs'] header_matches: Specifies a list of header match criteria, all of which must match corresponding
               headers in the request.
               Structure is documented below.
        :param _builtins.bool ignore_case: Specifies that prefixMatch and fullPathMatch matches are case sensitive.
               Defaults to false.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterArgs'] metadata_filters: Opaque filter criteria used by Loadbalancer to restrict routing configuration to
               a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
               clients present node metadata. If a match takes place, the relevant routing
               configuration is made available to those proxies. For each metadataFilter in
               this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
               filterLabels must match the corresponding label provided in the metadata. If its
               filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
               with corresponding labels in the provided metadata. metadataFilters specified
               here can be overrides those specified in ForwardingRule that refers to this
               UrlMap. metadataFilters only applies to Loadbalancers that have their
               loadBalancingScheme set to INTERNAL_SELF_MANAGED.
               Structure is documented below.
        :param _builtins.str path_template_match: For satisfying the matchRule condition, the path of the request
               must match the wildcard pattern specified in pathTemplateMatch
               after removing any query parameters and anchor that may be part
               of the original URL.
               pathTemplateMatch must be between 1 and 255 characters
               (inclusive).  The pattern specified by pathTemplateMatch may
               have at most 5 wildcard operators and at most 5 variable
               captures in total.
        :param _builtins.str prefix_match: For satisfying the matchRule condition, the request's path must begin with the
               specified prefixMatch. prefixMatch must begin with a /. The value must be
               between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
               regexMatch must be specified.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs'] query_parameter_matches: Specifies a list of query parameter match criteria, all of which must match
               corresponding query parameters in the request.
               Structure is documented below.
        :param _builtins.str regex_match: For satisfying the matchRule condition, the path of the request must satisfy the
               regular expression specified in regexMatch after removing any query parameters
               and anchor supplied with the original URL. For regular expression grammar please
               see en.cppreference.com/w/cpp/regex/ecmascript  Only one of prefixMatch,
               fullPathMatch or regexMatch must be specified.
        """
        if full_path_match is not None:
            pulumi.set(__self__, "full_path_match", full_path_match)
        if header_matches is not None:
            pulumi.set(__self__, "header_matches", header_matches)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if metadata_filters is not None:
            pulumi.set(__self__, "metadata_filters", metadata_filters)
        if path_template_match is not None:
            pulumi.set(__self__, "path_template_match", path_template_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if query_parameter_matches is not None:
            pulumi.set(__self__, "query_parameter_matches", query_parameter_matches)
        if regex_match is not None:
            pulumi.set(__self__, "regex_match", regex_match)

    @_builtins.property
    @pulumi.getter(name="fullPathMatch")
    def full_path_match(self) -> Optional[_builtins.str]:
        """
        For satisfying the matchRule condition, the path of the request must exactly
        match the value specified in fullPathMatch after removing any query parameters
        and anchor that may be part of the original URL. FullPathMatch must be between 1
        and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
        be specified.
        """
        return pulumi.get(self, "full_path_match")

    @_builtins.property
    @pulumi.getter(name="headerMatches")
    def header_matches(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch']]:
        """
        Specifies a list of header match criteria, all of which must match corresponding
        headers in the request.
        Structure is documented below.
        """
        return pulumi.get(self, "header_matches")

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[_builtins.bool]:
        """
        Specifies that prefixMatch and fullPathMatch matches are case sensitive.
        Defaults to false.
        """
        return pulumi.get(self, "ignore_case")

    @_builtins.property
    @pulumi.getter(name="metadataFilters")
    def metadata_filters(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter']]:
        """
        Opaque filter criteria used by Loadbalancer to restrict routing configuration to
        a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
        clients present node metadata. If a match takes place, the relevant routing
        configuration is made available to those proxies. For each metadataFilter in
        this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
        filterLabels must match the corresponding label provided in the metadata. If its
        filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
        with corresponding labels in the provided metadata. metadataFilters specified
        here can be overrides those specified in ForwardingRule that refers to this
        UrlMap. metadataFilters only applies to Loadbalancers that have their
        loadBalancingScheme set to INTERNAL_SELF_MANAGED.
        Structure is documented below.
        """
        return pulumi.get(self, "metadata_filters")

    @_builtins.property
    @pulumi.getter(name="pathTemplateMatch")
    def path_template_match(self) -> Optional[_builtins.str]:
        """
        For satisfying the matchRule condition, the path of the request
        must match the wildcard pattern specified in pathTemplateMatch
        after removing any query parameters and anchor that may be part
        of the original URL.
        pathTemplateMatch must be between 1 and 255 characters
        (inclusive).  The pattern specified by pathTemplateMatch may
        have at most 5 wildcard operators and at most 5 variable
        captures in total.
        """
        return pulumi.get(self, "path_template_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        """
        For satisfying the matchRule condition, the request's path must begin with the
        specified prefixMatch. prefixMatch must begin with a /. The value must be
        between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
        regexMatch must be specified.
        """
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="queryParameterMatches")
    def query_parameter_matches(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch']]:
        """
        Specifies a list of query parameter match criteria, all of which must match
        corresponding query parameters in the request.
        Structure is documented below.
        """
        return pulumi.get(self, "query_parameter_matches")

    @_builtins.property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[_builtins.str]:
        """
        For satisfying the matchRule condition, the path of the request must satisfy the
        regular expression specified in regexMatch after removing any query parameters
        and anchor supplied with the original URL. For regular expression grammar please
        see en.cppreference.com/w/cpp/regex/ecmascript  Only one of prefixMatch,
        fullPathMatch or regexMatch must be specified.
        """
        return pulumi.get(self, "regex_match")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "exactMatch":
            suggest = "exact_match"
        elif key == "invertMatch":
            suggest = "invert_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "presentMatch":
            suggest = "present_match"
        elif key == "rangeMatch":
            suggest = "range_match"
        elif key == "regexMatch":
            suggest = "regex_match"
        elif key == "suffixMatch":
            suggest = "suffix_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 exact_match: Optional[_builtins.str] = None,
                 invert_match: Optional[_builtins.bool] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 present_match: Optional[_builtins.bool] = None,
                 range_match: Optional['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch'] = None,
                 regex_match: Optional[_builtins.str] = None,
                 suffix_match: Optional[_builtins.str] = None):
        """
        :param _builtins.str header_name: The name of the HTTP header to match. For matching against the HTTP request's
               authority, use a headerMatch with the header name ":authority". For matching a
               request's method, use the headerName ":method".
        :param _builtins.str exact_match: The value should exactly match contents of exactMatch. Only one of exactMatch,
               prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
        :param _builtins.bool invert_match: If set to false, the headerMatch is considered a match if the match criteria
               above are met. If set to true, the headerMatch is considered a match if the
               match criteria above are NOT met. Defaults to false.
        :param _builtins.str prefix_match: The value of the header must start with the contents of prefixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        :param _builtins.bool present_match: A header with the contents of headerName must exist. The match takes place
               whether or not the request's header has a value or not. Only one of exactMatch,
               prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
        :param 'RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatchArgs' range_match: The header value must be an integer and its value must be in the range specified
               in rangeMatch. If the header does not contain an integer, number or is empty,
               the match fails. For example for a range [-5, 0]
               * -3 will match
               * 0 will not match
               * 0.25 will not match
               * -3someString will not match.
               Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
               rangeMatch must be set.
               Structure is documented below.
        :param _builtins.str regex_match: The value of the header must match the regular expression specified in
               regexMatch. For regular expression grammar, please see:
               en.cppreference.com/w/cpp/regex/ecmascript  For matching against a port
               specified in the HTTP request, use a headerMatch with headerName set to PORT and
               a regular expression that satisfies the RFC2616 Host header's port specifier.
               Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
               rangeMatch must be set.
        :param _builtins.str suffix_match: The value of the header must end with the contents of suffixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        """
        pulumi.set(__self__, "header_name", header_name)
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if invert_match is not None:
            pulumi.set(__self__, "invert_match", invert_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if present_match is not None:
            pulumi.set(__self__, "present_match", present_match)
        if range_match is not None:
            pulumi.set(__self__, "range_match", range_match)
        if regex_match is not None:
            pulumi.set(__self__, "regex_match", regex_match)
        if suffix_match is not None:
            pulumi.set(__self__, "suffix_match", suffix_match)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the HTTP header to match. For matching against the HTTP request's
        authority, use a headerMatch with the header name ":authority". For matching a
        request's method, use the headerName ":method".
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        """
        The value should exactly match contents of exactMatch. Only one of exactMatch,
        prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
        """
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="invertMatch")
    def invert_match(self) -> Optional[_builtins.bool]:
        """
        If set to false, the headerMatch is considered a match if the match criteria
        above are met. If set to true, the headerMatch is considered a match if the
        match criteria above are NOT met. Defaults to false.
        """
        return pulumi.get(self, "invert_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        """
        The value of the header must start with the contents of prefixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="presentMatch")
    def present_match(self) -> Optional[_builtins.bool]:
        """
        A header with the contents of headerName must exist. The match takes place
        whether or not the request's header has a value or not. Only one of exactMatch,
        prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
        """
        return pulumi.get(self, "present_match")

    @_builtins.property
    @pulumi.getter(name="rangeMatch")
    def range_match(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch']:
        """
        The header value must be an integer and its value must be in the range specified
        in rangeMatch. If the header does not contain an integer, number or is empty,
        the match fails. For example for a range [-5, 0]
        * -3 will match
        * 0 will not match
        * 0.25 will not match
        * -3someString will not match.
        Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
        rangeMatch must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "range_match")

    @_builtins.property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[_builtins.str]:
        """
        The value of the header must match the regular expression specified in
        regexMatch. For regular expression grammar, please see:
        en.cppreference.com/w/cpp/regex/ecmascript  For matching against a port
        specified in the HTTP request, use a headerMatch with headerName set to PORT and
        a regular expression that satisfies the RFC2616 Host header's port specifier.
        Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
        rangeMatch must be set.
        """
        return pulumi.get(self, "regex_match")

    @_builtins.property
    @pulumi.getter(name="suffixMatch")
    def suffix_match(self) -> Optional[_builtins.str]:
        """
        The value of the header must end with the contents of suffixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        return pulumi.get(self, "suffix_match")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeEnd":
            suggest = "range_end"
        elif key == "rangeStart":
            suggest = "range_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_end: _builtins.int,
                 range_start: _builtins.int):
        """
        :param _builtins.int range_end: The end of the range (exclusive).
        :param _builtins.int range_start: The start of the range (inclusive).
        """
        pulumi.set(__self__, "range_end", range_end)
        pulumi.set(__self__, "range_start", range_start)

    @_builtins.property
    @pulumi.getter(name="rangeEnd")
    def range_end(self) -> _builtins.int:
        """
        The end of the range (exclusive).
        """
        return pulumi.get(self, "range_end")

    @_builtins.property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> _builtins.int:
        """
        The start of the range (inclusive).
        """
        return pulumi.get(self, "range_start")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterLabels":
            suggest = "filter_labels"
        elif key == "filterMatchCriteria":
            suggest = "filter_match_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_labels: Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel'],
                 filter_match_criteria: _builtins.str):
        """
        :param Sequence['RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabelArgs'] filter_labels: The list of label value pairs that must match labels in the provided metadata
               based on filterMatchCriteria  This list must not be empty and can have at the
               most 64 entries.
               Structure is documented below.
        :param _builtins.str filter_match_criteria: Specifies how individual filterLabel matches within the list of filterLabels
               contribute towards the overall metadataFilter match. Supported values are:
               * MATCH_ANY: At least one of the filterLabels must have a matching label in the
               provided metadata.
               * MATCH_ALL: All filterLabels must have matching labels in
               the provided metadata.
               Possible values are: `MATCH_ALL`, `MATCH_ANY`.
        """
        pulumi.set(__self__, "filter_labels", filter_labels)
        pulumi.set(__self__, "filter_match_criteria", filter_match_criteria)

    @_builtins.property
    @pulumi.getter(name="filterLabels")
    def filter_labels(self) -> Sequence['outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel']:
        """
        The list of label value pairs that must match labels in the provided metadata
        based on filterMatchCriteria  This list must not be empty and can have at the
        most 64 entries.
        Structure is documented below.
        """
        return pulumi.get(self, "filter_labels")

    @_builtins.property
    @pulumi.getter(name="filterMatchCriteria")
    def filter_match_criteria(self) -> _builtins.str:
        """
        Specifies how individual filterLabel matches within the list of filterLabels
        contribute towards the overall metadataFilter match. Supported values are:
        * MATCH_ANY: At least one of the filterLabels must have a matching label in the
        provided metadata.
        * MATCH_ALL: All filterLabels must have matching labels in
        the provided metadata.
        Possible values are: `MATCH_ALL`, `MATCH_ANY`.
        """
        return pulumi.get(self, "filter_match_criteria")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Name of metadata label. The name can have a maximum length of 1024 characters
               and must be at least 1 character long.
        :param _builtins.str value: The value of the label must match the specified value. value can have a maximum
               length of 1024 characters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of metadata label. The name can have a maximum length of 1024 characters
        and must be at least 1 character long.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the label must match the specified value. value can have a maximum
        length of 1024 characters.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "presentMatch":
            suggest = "present_match"
        elif key == "regexMatch":
            suggest = "regex_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 exact_match: Optional[_builtins.str] = None,
                 present_match: Optional[_builtins.bool] = None,
                 regex_match: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the query parameter to match. The query parameter must exist in the
               request, in the absence of which the request match fails.
        :param _builtins.str exact_match: The queryParameterMatch matches if the value of the parameter exactly matches
               the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
               must be set.
        :param _builtins.bool present_match: Specifies that the queryParameterMatch matches if the request contains the query
               parameter, irrespective of whether the parameter has a value or not. Only one of
               presentMatch, exactMatch and regexMatch must be set.
        :param _builtins.str regex_match: The queryParameterMatch matches if the value of the parameter matches the
               regular expression specified by regexMatch. For the regular expression grammar,
               please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
               exactMatch and regexMatch must be set.
        """
        pulumi.set(__self__, "name", name)
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if present_match is not None:
            pulumi.set(__self__, "present_match", present_match)
        if regex_match is not None:
            pulumi.set(__self__, "regex_match", regex_match)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the query parameter to match. The query parameter must exist in the
        request, in the absence of which the request match fails.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        """
        The queryParameterMatch matches if the value of the parameter exactly matches
        the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        must be set.
        """
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="presentMatch")
    def present_match(self) -> Optional[_builtins.bool]:
        """
        Specifies that the queryParameterMatch matches if the request contains the query
        parameter, irrespective of whether the parameter has a value or not. Only one of
        presentMatch, exactMatch and regexMatch must be set.
        """
        return pulumi.get(self, "present_match")

    @_builtins.property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[_builtins.str]:
        """
        The queryParameterMatch matches if the value of the parameter matches the
        regular expression specified by regexMatch. For the regular expression grammar,
        please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        exactMatch and regexMatch must be set.
        """
        return pulumi.get(self, "regex_match")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "corsPolicy":
            suggest = "cors_policy"
        elif key == "faultInjectionPolicy":
            suggest = "fault_injection_policy"
        elif key == "requestMirrorPolicy":
            suggest = "request_mirror_policy"
        elif key == "retryPolicy":
            suggest = "retry_policy"
        elif key == "urlRewrite":
            suggest = "url_rewrite"
        elif key == "weightedBackendServices":
            suggest = "weighted_backend_services"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cors_policy: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy'] = None,
                 fault_injection_policy: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy'] = None,
                 request_mirror_policy: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy'] = None,
                 retry_policy: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy'] = None,
                 timeout: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionTimeout'] = None,
                 url_rewrite: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite'] = None,
                 weighted_backend_services: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService']] = None):
        """
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicyArgs' cors_policy: The specification for allowing client side cross-origin requests. Please see W3C
               Recommendation for Cross Origin Resource Sharing
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyArgs' fault_injection_policy: The specification for fault injection introduced into traffic to test the
               resiliency of clients to backend service failure. As part of fault injection,
               when clients send requests to a backend service, delays can be introduced by
               Loadbalancer on a percentage of requests before sending those request to the
               backend service. Similarly requests from clients can be aborted by the
               Loadbalancer for a percentage of requests. timeout and retry_policy will be
               ignored by clients that are configured with a fault_injection_policy.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicyArgs' request_mirror_policy: Specifies the policy on how requests intended for the route's backends are
               shadowed to a separate mirrored backend service. Loadbalancer does not wait for
               responses from the shadow service. Prior to sending traffic to the shadow
               service, the host / authority header is suffixed with -shadow.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyArgs' retry_policy: Specifies the retry policy associated with this route.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionTimeoutArgs' timeout: Specifies the timeout for the selected route. Timeout is computed from the time
               the request is has been fully processed (i.e. end-of-stream) up until the
               response has been completely processed. Timeout includes all retries. If not
               specified, the default value is 15 seconds.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewriteArgs' url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to
               the matched service
               Structure is documented below.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceArgs'] weighted_backend_services: A list of weighted backend services to send traffic to when a route match
               occurs. The weights determine the fraction of traffic that flows to their
               corresponding backend service. If all traffic needs to go to a single backend
               service, there must be one  weightedBackendService with weight set to a non 0
               number. Once a backendService is identified and before forwarding the request to
               the backend service, advanced routing actions like Url rewrites and header
               transformations are applied depending on additional settings specified in this
               HttpRouteAction.
               Structure is documented below.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if fault_injection_policy is not None:
            pulumi.set(__self__, "fault_injection_policy", fault_injection_policy)
        if request_mirror_policy is not None:
            pulumi.set(__self__, "request_mirror_policy", request_mirror_policy)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)
        if weighted_backend_services is not None:
            pulumi.set(__self__, "weighted_backend_services", weighted_backend_services)

    @_builtins.property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see W3C
        Recommendation for Cross Origin Resource Sharing
        Structure is documented below.
        """
        return pulumi.get(self, "cors_policy")

    @_builtins.property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the
        resiliency of clients to backend service failure. As part of fault injection,
        when clients send requests to a backend service, delays can be introduced by
        Loadbalancer on a percentage of requests before sending those request to the
        backend service. Similarly requests from clients can be aborted by the
        Loadbalancer for a percentage of requests. timeout and retry_policy will be
        ignored by clients that are configured with a fault_injection_policy.
        Structure is documented below.
        """
        return pulumi.get(self, "fault_injection_policy")

    @_builtins.property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are
        shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        responses from the shadow service. Prior to sending traffic to the shadow
        service, the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        return pulumi.get(self, "request_mirror_policy")

    @_builtins.property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        return pulumi.get(self, "retry_policy")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time
        the request is has been fully processed (i.e. end-of-stream) up until the
        response has been completely processed. Timeout includes all retries. If not
        specified, the default value is 15 seconds.
        Structure is documented below.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to
        the matched service
        Structure is documented below.
        """
        return pulumi.get(self, "url_rewrite")

    @_builtins.property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match
        occurs. The weights determine the fraction of traffic that flows to their
        corresponding backend service. If all traffic needs to go to a single backend
        service, there must be one  weightedBackendService with weight set to a non 0
        number. Once a backendService is identified and before forwarding the request to
        the backend service, advanced routing actions like Url rewrites and header
        transformations are applied depending on additional settings specified in this
        HttpRouteAction.
        Structure is documented below.
        """
        return pulumi.get(self, "weighted_backend_services")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOriginRegexes":
            suggest = "allow_origin_regexes"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origin_regexes: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional[Sequence[_builtins.str]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        :param _builtins.bool allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This field translates to the Access-Control-Allow-Credentials header.
               Default is false.
        :param Sequence[_builtins.str] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param Sequence[_builtins.str] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param Sequence[_builtins.str] allow_origin_regexes: Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[_builtins.str] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param _builtins.bool disabled: If true, the setting specifies the CORS policy is disabled. The default value of false, which indicates that the CORS policy is in effect.
        :param Sequence[_builtins.str] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param _builtins.int max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin_regexes is not None:
            pulumi.set(__self__, "allow_origin_regexes", allow_origin_regexes)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This field translates to the Access-Control-Allow-Credentials header.
        Default is false.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origin_regexes")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If true, the setting specifies the CORS policy is disabled. The default value of false, which indicates that the CORS policy is in effect.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy(dict):
    def __init__(__self__, *,
                 abort: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort'] = None,
                 delay: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay'] = None):
        """
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbortArgs' abort: The specification for how client requests are aborted as part of fault injection.
               Structure is documented below.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayArgs' delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
               Structure is documented below.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def abort(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        return pulumi.get(self, "abort")

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpStatus":
            suggest = "http_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_status: Optional[_builtins.int] = None,
                 percentage: Optional[_builtins.float] = None):
        """
        :param _builtins.int http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if http_status is not None:
            pulumi.set(__self__, "http_status", http_status)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[_builtins.int]:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        return pulumi.get(self, "http_status")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedDelay":
            suggest = "fixed_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_delay: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay'] = None,
                 percentage: Optional[_builtins.float] = None):
        """
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs' fixed_delay: Specifies the value of the fixed delay interval.
               Structure is documented below.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if fixed_delay is not None:
            pulumi.set(__self__, "fixed_delay", fixed_delay)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay']:
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_delay")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "mirrorPercent":
            suggest = "mirror_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: _builtins.str,
                 mirror_percent: Optional[_builtins.float] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the RegionBackendService resource being mirrored to.
               The backend service configured for a mirroring policy must reference backends that are of the same type as the original backend service matched in the URL map.
               Serverless NEG backends are not currently supported as a mirrored backend service.
        :param _builtins.float mirror_percent: The percentage of requests to be mirrored to backendService.
               The value must be between 0.0 and 100.0 inclusive.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        if mirror_percent is not None:
            pulumi.set(__self__, "mirror_percent", mirror_percent)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> _builtins.str:
        """
        The full or partial URL to the RegionBackendService resource being mirrored to.
        The backend service configured for a mirroring policy must reference backends that are of the same type as the original backend service matched in the URL map.
        Serverless NEG backends are not currently supported as a mirrored backend service.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter(name="mirrorPercent")
    def mirror_percent(self) -> Optional[_builtins.float]:
        """
        The percentage of requests to be mirrored to backendService.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "mirror_percent")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numRetries":
            suggest = "num_retries"
        elif key == "perTryTimeout":
            suggest = "per_try_timeout"
        elif key == "retryConditions":
            suggest = "retry_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_retries: _builtins.int,
                 per_try_timeout: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout'] = None,
                 retry_conditions: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeoutArgs' per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param Sequence[_builtins.str] retry_conditions: Specifies one or more conditions when this retry policy applies.
               Valid values are listed below. Only the following codes are supported when the URL map is bound to target gRPC proxy that has validateForProxyless field set to true: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
               - 5xx : retry is attempted if the instance or endpoint responds with any 5xx response code, or if the instance or endpoint does not respond at all. For example, disconnects, reset, read timeout, connection failure, and refused streams.
               - gateway-error : Similar to 5xx, but only applies to response codes 502, 503 or 504.
               - connect-failure : a retry is attempted on failures connecting to the instance or endpoint. For example, connection timeouts.
               - retriable-4xx : a retry is attempted if the instance or endpoint responds with a 4xx response code. The only error that you can retry is error code 409.
               - refused-stream : a retry is attempted if the instance or endpoint resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
               - cancelled : a retry is attempted if the gRPC status code in the response header is set to cancelled.
               - deadline-exceeded : a retry is attempted if the gRPC status code in the response header is set to deadline-exceeded.
               - internal :  a retry is attempted if the gRPC status code in the response header is set to internal.
               - resource-exhausted : a retry is attempted if the gRPC status code in the response header is set to resource-exhausted.
               - unavailable : a retry is attempted if the gRPC status code in the response header is set to unavailable.
        """
        pulumi.set(__self__, "num_retries", num_retries)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_conditions is not None:
            pulumi.set(__self__, "retry_conditions", retry_conditions)

    @_builtins.property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> _builtins.int:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        return pulumi.get(self, "num_retries")

    @_builtins.property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "per_try_timeout")

    @_builtins.property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies one or more conditions when this retry policy applies.
        Valid values are listed below. Only the following codes are supported when the URL map is bound to target gRPC proxy that has validateForProxyless field set to true: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
        - 5xx : retry is attempted if the instance or endpoint responds with any 5xx response code, or if the instance or endpoint does not respond at all. For example, disconnects, reset, read timeout, connection failure, and refused streams.
        - gateway-error : Similar to 5xx, but only applies to response codes 502, 503 or 504.
        - connect-failure : a retry is attempted on failures connecting to the instance or endpoint. For example, connection timeouts.
        - retriable-4xx : a retry is attempted if the instance or endpoint responds with a 4xx response code. The only error that you can retry is error code 409.
        - refused-stream : a retry is attempted if the instance or endpoint resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
        - cancelled : a retry is attempted if the gRPC status code in the response header is set to cancelled.
        - deadline-exceeded : a retry is attempted if the gRPC status code in the response header is set to deadline-exceeded.
        - internal :  a retry is attempted if the gRPC status code in the response header is set to internal.
        - resource-exhausted : a retry is attempted if the gRPC status code in the response header is set to resource-exhausted.
        - unavailable : a retry is attempted if the gRPC status code in the response header is set to unavailable.
        """
        return pulumi.get(self, "retry_conditions")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostRewrite":
            suggest = "host_rewrite"
        elif key == "pathPrefixRewrite":
            suggest = "path_prefix_rewrite"
        elif key == "pathTemplateRewrite":
            suggest = "path_template_rewrite"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_rewrite: Optional[_builtins.str] = None,
                 path_prefix_rewrite: Optional[_builtins.str] = None,
                 path_template_rewrite: Optional[_builtins.str] = None):
        """
        :param _builtins.str host_rewrite: Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite.
               The value must be from 1 to 255 characters.
        :param _builtins.str path_prefix_rewrite: Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite.
               The value must be from 1 to 1024 characters.
        :param _builtins.str path_template_rewrite: If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax.
               A corresponding pathTemplateMatch must be specified. Any template variables must exist in the pathTemplateMatch field.
               * At least one variable must be specified in the pathTemplateMatch field
               * You can omit variables from the rewritten URL
               * The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}.
               For example, a pathTemplateMatch of /static/{format=**} could be rewritten as /static/content/{format} to prefix
               /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be
               rewritten as /content/{format}/{country}/{suffix}.
               At least one non-empty routeRules[].matchRules[].path_template_match is required.
               Only one of pathPrefixRewrite or pathTemplateRewrite may be specified.
        """
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if path_prefix_rewrite is not None:
            pulumi.set(__self__, "path_prefix_rewrite", path_prefix_rewrite)
        if path_template_rewrite is not None:
            pulumi.set(__self__, "path_template_rewrite", path_template_rewrite)

    @_builtins.property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[_builtins.str]:
        """
        Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite.
        The value must be from 1 to 255 characters.
        """
        return pulumi.get(self, "host_rewrite")

    @_builtins.property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[_builtins.str]:
        """
        Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite.
        The value must be from 1 to 1024 characters.
        """
        return pulumi.get(self, "path_prefix_rewrite")

    @_builtins.property
    @pulumi.getter(name="pathTemplateRewrite")
    def path_template_rewrite(self) -> Optional[_builtins.str]:
        """
        If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax.
        A corresponding pathTemplateMatch must be specified. Any template variables must exist in the pathTemplateMatch field.
        * At least one variable must be specified in the pathTemplateMatch field
        * You can omit variables from the rewritten URL
        * The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}.
        For example, a pathTemplateMatch of /static/{format=**} could be rewritten as /static/content/{format} to prefix
        /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be
        rewritten as /content/{format}/{country}/{suffix}.
        At least one non-empty routeRules[].matchRules[].path_template_match is required.
        Only one of pathPrefixRewrite or pathTemplateRewrite may be specified.
        """
        return pulumi.get(self, "path_template_rewrite")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "headerAction":
            suggest = "header_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: _builtins.str,
                 weight: _builtins.int,
                 header_action: Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction'] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
        :param _builtins.int weight: Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy.
               The value must be from 0 to 1000.
        :param 'RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
               headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
               Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
               Structure is documented below.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        pulumi.set(__self__, "weight", weight)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> _builtins.str:
        """
        The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy.
        The value must be from 0 to 1000.
        """
        return pulumi.get(self, "weight")

    @_builtins.property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
        headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
        Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"
        elif key == "requestHeadersToRemoves":
            suggest = "request_headers_to_removes"
        elif key == "responseHeadersToAdds":
            suggest = "response_headers_to_adds"
        elif key == "responseHeadersToRemoves":
            suggest = "response_headers_to_removes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[_builtins.str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request before forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[_builtins.str] request_headers_to_removes: A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
        :param Sequence['RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response before sending the response back to the client.
               Structure is documented below.
        :param Sequence[_builtins.str] response_headers_to_removes: A list of header names for headers that need to be removed from the response before sending the response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request before forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response before sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the response before sending the response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
               The default value is false.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
        The default value is false.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
               The default value is false.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
        The default value is false.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class RegionUrlMapPathMatcherRouteRuleUrlRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostRedirect":
            suggest = "host_redirect"
        elif key == "httpsRedirect":
            suggest = "https_redirect"
        elif key == "pathRedirect":
            suggest = "path_redirect"
        elif key == "prefixRedirect":
            suggest = "prefix_redirect"
        elif key == "redirectResponseCode":
            suggest = "redirect_response_code"
        elif key == "stripQuery":
            suggest = "strip_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegionUrlMapPathMatcherRouteRuleUrlRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegionUrlMapPathMatcherRouteRuleUrlRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegionUrlMapPathMatcherRouteRuleUrlRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_redirect: Optional[_builtins.str] = None,
                 https_redirect: Optional[_builtins.bool] = None,
                 path_redirect: Optional[_builtins.str] = None,
                 prefix_redirect: Optional[_builtins.str] = None,
                 redirect_response_code: Optional[_builtins.str] = None,
                 strip_query: Optional[_builtins.bool] = None):
        """
        :param _builtins.str host_redirect: The host that will be used in the redirect response instead of the one
               that was supplied in the request. The value must be between 1 and 255
               characters.
        :param _builtins.bool https_redirect: If set to true, the URL scheme in the redirected request is set to https.
               If set to false, the URL scheme of the redirected request will remain the
               same as that of the request. This must only be set for UrlMaps used in
               TargetHttpProxys. Setting this true for TargetHttpsProxy is not
               permitted. The default is set to false.
        :param _builtins.str path_redirect: The path that will be used in the redirect response instead of the one
               that was supplied in the request. pathRedirect cannot be supplied
               together with prefixRedirect. Supply one alone or neither. If neither is
               supplied, the path of the original request will be used for the redirect.
               The value must be between 1 and 1024 characters.
        :param _builtins.str prefix_redirect: The prefix that replaces the prefixMatch specified in the
               HttpRouteRuleMatch, retaining the remaining portion of the URL before
               redirecting the request. prefixRedirect cannot be supplied together with
               pathRedirect. Supply one alone or neither. If neither is supplied, the
               path of the original request will be used for the redirect. The value
               must be between 1 and 1024 characters.
        :param _builtins.str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        :param _builtins.bool strip_query: If set to true, any accompanying query portion of the original URL is removed
               prior to redirecting the request. If set to false, the query portion of the
               original URL is retained.
               This field is required to ensure an empty block is not set. The normal default value is false.
        """
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)
        if strip_query is not None:
            pulumi.set(__self__, "strip_query", strip_query)

    @_builtins.property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[_builtins.str]:
        """
        The host that will be used in the redirect response instead of the one
        that was supplied in the request. The value must be between 1 and 255
        characters.
        """
        return pulumi.get(self, "host_redirect")

    @_builtins.property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[_builtins.bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https.
        If set to false, the URL scheme of the redirected request will remain the
        same as that of the request. This must only be set for UrlMaps used in
        TargetHttpProxys. Setting this true for TargetHttpsProxy is not
        permitted. The default is set to false.
        """
        return pulumi.get(self, "https_redirect")

    @_builtins.property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[_builtins.str]:
        """
        The path that will be used in the redirect response instead of the one
        that was supplied in the request. pathRedirect cannot be supplied
        together with prefixRedirect. Supply one alone or neither. If neither is
        supplied, the path of the original request will be used for the redirect.
        The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "path_redirect")

    @_builtins.property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[_builtins.str]:
        """
        The prefix that replaces the prefixMatch specified in the
        HttpRouteRuleMatch, retaining the remaining portion of the URL before
        redirecting the request. prefixRedirect cannot be supplied together with
        pathRedirect. Supply one alone or neither. If neither is supplied, the
        path of the original request will be used for the redirect. The value
        must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "prefix_redirect")

    @_builtins.property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[_builtins.str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")

    @_builtins.property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> Optional[_builtins.bool]:
        """
        If set to true, any accompanying query portion of the original URL is removed
        prior to redirecting the request. If set to false, the query portion of the
        original URL is retained.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        return pulumi.get(self, "strip_query")


@pulumi.output_type
class RegionUrlMapTest(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 path: _builtins.str,
                 service: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Host portion of the URL.
        :param _builtins.str path: Path portion of the URL.
        :param _builtins.str service: A reference to expected RegionBackendService resource the given URL should be mapped to.
        :param _builtins.str description: Description of this test case.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "service", service)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        Host portion of the URL.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path portion of the URL.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        A reference to expected RegionBackendService resource the given URL should be mapped to.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of this test case.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class ReservationDeleteAfterDuration(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Number of nanoseconds for the auto-delete duration.
        :param _builtins.str seconds: Number of seconds for the auto-delete duration.
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Number of nanoseconds for the auto-delete duration.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Number of seconds for the auto-delete duration.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class ReservationReservationSharingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceShareType":
            suggest = "service_share_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservationReservationSharingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservationReservationSharingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservationReservationSharingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_share_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_share_type: Sharing config for all Google Cloud services.
               Possible values are: `ALLOW_ALL`, `DISALLOW_ALL`.
        """
        if service_share_type is not None:
            pulumi.set(__self__, "service_share_type", service_share_type)

    @_builtins.property
    @pulumi.getter(name="serviceShareType")
    def service_share_type(self) -> Optional[_builtins.str]:
        """
        Sharing config for all Google Cloud services.
        Possible values are: `ALLOW_ALL`, `DISALLOW_ALL`.
        """
        return pulumi.get(self, "service_share_type")


@pulumi.output_type
class ReservationResourceStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthInfos":
            suggest = "health_infos"
        elif key == "reservationBlockCount":
            suggest = "reservation_block_count"
        elif key == "reservationMaintenances":
            suggest = "reservation_maintenances"
        elif key == "specificSkuAllocations":
            suggest = "specific_sku_allocations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservationResourceStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservationResourceStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservationResourceStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 health_infos: Optional[Sequence['outputs.ReservationResourceStatusHealthInfo']] = None,
                 reservation_block_count: Optional[_builtins.int] = None,
                 reservation_maintenances: Optional[Sequence['outputs.ReservationResourceStatusReservationMaintenance']] = None,
                 specific_sku_allocations: Optional[Sequence['outputs.ReservationResourceStatusSpecificSkuAllocation']] = None):
        """
        :param Sequence['ReservationResourceStatusHealthInfoArgs'] health_infos: (Output)
               Health information for the reservation.
               Structure is documented below.
        :param _builtins.int reservation_block_count: (Output)
               The number of reservation blocks associated with this reservation.
        :param Sequence['ReservationResourceStatusReservationMaintenanceArgs'] reservation_maintenances: (Output)
               Maintenance information for this reservation
               Structure is documented below.
        :param Sequence['ReservationResourceStatusSpecificSkuAllocationArgs'] specific_sku_allocations: (Output)
               Allocation Properties of this reservation.
               Structure is documented below.
        """
        if health_infos is not None:
            pulumi.set(__self__, "health_infos", health_infos)
        if reservation_block_count is not None:
            pulumi.set(__self__, "reservation_block_count", reservation_block_count)
        if reservation_maintenances is not None:
            pulumi.set(__self__, "reservation_maintenances", reservation_maintenances)
        if specific_sku_allocations is not None:
            pulumi.set(__self__, "specific_sku_allocations", specific_sku_allocations)

    @_builtins.property
    @pulumi.getter(name="healthInfos")
    def health_infos(self) -> Optional[Sequence['outputs.ReservationResourceStatusHealthInfo']]:
        """
        (Output)
        Health information for the reservation.
        Structure is documented below.
        """
        return pulumi.get(self, "health_infos")

    @_builtins.property
    @pulumi.getter(name="reservationBlockCount")
    def reservation_block_count(self) -> Optional[_builtins.int]:
        """
        (Output)
        The number of reservation blocks associated with this reservation.
        """
        return pulumi.get(self, "reservation_block_count")

    @_builtins.property
    @pulumi.getter(name="reservationMaintenances")
    def reservation_maintenances(self) -> Optional[Sequence['outputs.ReservationResourceStatusReservationMaintenance']]:
        """
        (Output)
        Maintenance information for this reservation
        Structure is documented below.
        """
        return pulumi.get(self, "reservation_maintenances")

    @_builtins.property
    @pulumi.getter(name="specificSkuAllocations")
    def specific_sku_allocations(self) -> Optional[Sequence['outputs.ReservationResourceStatusSpecificSkuAllocation']]:
        """
        (Output)
        Allocation Properties of this reservation.
        Structure is documented below.
        """
        return pulumi.get(self, "specific_sku_allocations")


@pulumi.output_type
class ReservationResourceStatusHealthInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "degradedBlockCount":
            suggest = "degraded_block_count"
        elif key == "healthStatus":
            suggest = "health_status"
        elif key == "healthyBlockCount":
            suggest = "healthy_block_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservationResourceStatusHealthInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservationResourceStatusHealthInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservationResourceStatusHealthInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 degraded_block_count: Optional[_builtins.int] = None,
                 health_status: Optional[_builtins.str] = None,
                 healthy_block_count: Optional[_builtins.int] = None):
        """
        :param _builtins.int degraded_block_count: (Output)
               The number of reservation blocks that are degraded.
        :param _builtins.str health_status: (Output)
               The health status of the reservation.
        :param _builtins.int healthy_block_count: (Output)
               The number of reservation blocks that are healthy.
        """
        if degraded_block_count is not None:
            pulumi.set(__self__, "degraded_block_count", degraded_block_count)
        if health_status is not None:
            pulumi.set(__self__, "health_status", health_status)
        if healthy_block_count is not None:
            pulumi.set(__self__, "healthy_block_count", healthy_block_count)

    @_builtins.property
    @pulumi.getter(name="degradedBlockCount")
    def degraded_block_count(self) -> Optional[_builtins.int]:
        """
        (Output)
        The number of reservation blocks that are degraded.
        """
        return pulumi.get(self, "degraded_block_count")

    @_builtins.property
    @pulumi.getter(name="healthStatus")
    def health_status(self) -> Optional[_builtins.str]:
        """
        (Output)
        The health status of the reservation.
        """
        return pulumi.get(self, "health_status")

    @_builtins.property
    @pulumi.getter(name="healthyBlockCount")
    def healthy_block_count(self) -> Optional[_builtins.int]:
        """
        (Output)
        The number of reservation blocks that are healthy.
        """
        return pulumi.get(self, "healthy_block_count")


@pulumi.output_type
class ReservationResourceStatusReservationMaintenance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceMaintenanceOngoingCount":
            suggest = "instance_maintenance_ongoing_count"
        elif key == "instanceMaintenancePendingCount":
            suggest = "instance_maintenance_pending_count"
        elif key == "maintenanceOngoingCount":
            suggest = "maintenance_ongoing_count"
        elif key == "maintenancePendingCount":
            suggest = "maintenance_pending_count"
        elif key == "schedulingType":
            suggest = "scheduling_type"
        elif key == "subblockInfraMaintenanceOngoingCount":
            suggest = "subblock_infra_maintenance_ongoing_count"
        elif key == "subblockInfraMaintenancePendingCount":
            suggest = "subblock_infra_maintenance_pending_count"
        elif key == "upcomingGroupMaintenances":
            suggest = "upcoming_group_maintenances"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservationResourceStatusReservationMaintenance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservationResourceStatusReservationMaintenance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservationResourceStatusReservationMaintenance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_maintenance_ongoing_count: Optional[_builtins.int] = None,
                 instance_maintenance_pending_count: Optional[_builtins.int] = None,
                 maintenance_ongoing_count: Optional[_builtins.int] = None,
                 maintenance_pending_count: Optional[_builtins.int] = None,
                 scheduling_type: Optional[_builtins.str] = None,
                 subblock_infra_maintenance_ongoing_count: Optional[_builtins.int] = None,
                 subblock_infra_maintenance_pending_count: Optional[_builtins.int] = None,
                 upcoming_group_maintenances: Optional[Sequence['outputs.ReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenance']] = None):
        """
        :param _builtins.int instance_maintenance_ongoing_count: (Output)
               Describes number of instances that have ongoing maintenance.
        :param _builtins.int instance_maintenance_pending_count: (Output)
               Describes number of instances that have pending maintenance.
        :param _builtins.int maintenance_ongoing_count: (Output)
               Progress for ongoing maintenance for this group of VMs/hosts. Describes number of hosts in the block that have ongoing maintenance.
        :param _builtins.int maintenance_pending_count: (Output)
               Progress for ongoing maintenance for this group of VMs/hosts. Describes number of hosts in the block that have pending maintenance.
        :param _builtins.str scheduling_type: (Output)
               The type of maintenance for the reservation.
        :param _builtins.int subblock_infra_maintenance_ongoing_count: (Output)
               Describes number of subblock Infrastructure that has ongoing maintenance. Here, Subblock Infrastructure Maintenance pertains to upstream hardware contained in the Subblock that is necessary for a VM Family(e.g. NVLink Domains). Not all VM Families will support this field.
        :param _builtins.int subblock_infra_maintenance_pending_count: (Output)
               Describes number of subblock Infrastructure that has pending maintenance. Here, Subblock Infrastructure Maintenance pertains to upstream hardware contained in the Subblock that is necessary for a VM Family (e.g. NVLink Domains). Not all VM Families will support this field.
        :param Sequence['ReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceArgs'] upcoming_group_maintenances: (Output)
               Maintenance information on this group of VMs.
               Structure is documented below.
        """
        if instance_maintenance_ongoing_count is not None:
            pulumi.set(__self__, "instance_maintenance_ongoing_count", instance_maintenance_ongoing_count)
        if instance_maintenance_pending_count is not None:
            pulumi.set(__self__, "instance_maintenance_pending_count", instance_maintenance_pending_count)
        if maintenance_ongoing_count is not None:
            pulumi.set(__self__, "maintenance_ongoing_count", maintenance_ongoing_count)
        if maintenance_pending_count is not None:
            pulumi.set(__self__, "maintenance_pending_count", maintenance_pending_count)
        if scheduling_type is not None:
            pulumi.set(__self__, "scheduling_type", scheduling_type)
        if subblock_infra_maintenance_ongoing_count is not None:
            pulumi.set(__self__, "subblock_infra_maintenance_ongoing_count", subblock_infra_maintenance_ongoing_count)
        if subblock_infra_maintenance_pending_count is not None:
            pulumi.set(__self__, "subblock_infra_maintenance_pending_count", subblock_infra_maintenance_pending_count)
        if upcoming_group_maintenances is not None:
            pulumi.set(__self__, "upcoming_group_maintenances", upcoming_group_maintenances)

    @_builtins.property
    @pulumi.getter(name="instanceMaintenanceOngoingCount")
    def instance_maintenance_ongoing_count(self) -> Optional[_builtins.int]:
        """
        (Output)
        Describes number of instances that have ongoing maintenance.
        """
        return pulumi.get(self, "instance_maintenance_ongoing_count")

    @_builtins.property
    @pulumi.getter(name="instanceMaintenancePendingCount")
    def instance_maintenance_pending_count(self) -> Optional[_builtins.int]:
        """
        (Output)
        Describes number of instances that have pending maintenance.
        """
        return pulumi.get(self, "instance_maintenance_pending_count")

    @_builtins.property
    @pulumi.getter(name="maintenanceOngoingCount")
    def maintenance_ongoing_count(self) -> Optional[_builtins.int]:
        """
        (Output)
        Progress for ongoing maintenance for this group of VMs/hosts. Describes number of hosts in the block that have ongoing maintenance.
        """
        return pulumi.get(self, "maintenance_ongoing_count")

    @_builtins.property
    @pulumi.getter(name="maintenancePendingCount")
    def maintenance_pending_count(self) -> Optional[_builtins.int]:
        """
        (Output)
        Progress for ongoing maintenance for this group of VMs/hosts. Describes number of hosts in the block that have pending maintenance.
        """
        return pulumi.get(self, "maintenance_pending_count")

    @_builtins.property
    @pulumi.getter(name="schedulingType")
    def scheduling_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The type of maintenance for the reservation.
        """
        return pulumi.get(self, "scheduling_type")

    @_builtins.property
    @pulumi.getter(name="subblockInfraMaintenanceOngoingCount")
    def subblock_infra_maintenance_ongoing_count(self) -> Optional[_builtins.int]:
        """
        (Output)
        Describes number of subblock Infrastructure that has ongoing maintenance. Here, Subblock Infrastructure Maintenance pertains to upstream hardware contained in the Subblock that is necessary for a VM Family(e.g. NVLink Domains). Not all VM Families will support this field.
        """
        return pulumi.get(self, "subblock_infra_maintenance_ongoing_count")

    @_builtins.property
    @pulumi.getter(name="subblockInfraMaintenancePendingCount")
    def subblock_infra_maintenance_pending_count(self) -> Optional[_builtins.int]:
        """
        (Output)
        Describes number of subblock Infrastructure that has pending maintenance. Here, Subblock Infrastructure Maintenance pertains to upstream hardware contained in the Subblock that is necessary for a VM Family (e.g. NVLink Domains). Not all VM Families will support this field.
        """
        return pulumi.get(self, "subblock_infra_maintenance_pending_count")

    @_builtins.property
    @pulumi.getter(name="upcomingGroupMaintenances")
    def upcoming_group_maintenances(self) -> Optional[Sequence['outputs.ReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenance']]:
        """
        (Output)
        Maintenance information on this group of VMs.
        Structure is documented below.
        """
        return pulumi.get(self, "upcoming_group_maintenances")


@pulumi.output_type
class ReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canReschedule":
            suggest = "can_reschedule"
        elif key == "latestWindowStartTime":
            suggest = "latest_window_start_time"
        elif key == "maintenanceOnShutdown":
            suggest = "maintenance_on_shutdown"
        elif key == "maintenanceReasons":
            suggest = "maintenance_reasons"
        elif key == "maintenanceStatus":
            suggest = "maintenance_status"
        elif key == "windowEndTime":
            suggest = "window_end_time"
        elif key == "windowStartTime":
            suggest = "window_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_reschedule: Optional[_builtins.bool] = None,
                 latest_window_start_time: Optional[_builtins.str] = None,
                 maintenance_on_shutdown: Optional[_builtins.bool] = None,
                 maintenance_reasons: Optional[Sequence[_builtins.str]] = None,
                 maintenance_status: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 window_end_time: Optional[_builtins.str] = None,
                 window_start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.bool can_reschedule: (Output)
               Indicates if the maintenance can be customer triggered.
        :param _builtins.str latest_window_start_time: (Output)
               The latest time for the planned maintenance window to start. This timestamp value is in RFC3339 text format.
        :param _builtins.bool maintenance_on_shutdown: (Output)
               Indicates whether the UpcomingMaintenance will be triggered on VM shutdown.
        :param Sequence[_builtins.str] maintenance_reasons: (Output)
               The reasons for the maintenance. Only valid for vms.
        :param _builtins.str maintenance_status: (Output)
               Status of the maintenance.
        :param _builtins.str type: (Output)
               Defines the type of maintenance.
        :param _builtins.str window_end_time: (Output)
               The time by which the maintenance disruption will be completed. This timestamp value is in RFC3339 text format.
        :param _builtins.str window_start_time: (Output)
               The current start time of the maintenance window. This timestamp value is in RFC3339 text format.
        """
        if can_reschedule is not None:
            pulumi.set(__self__, "can_reschedule", can_reschedule)
        if latest_window_start_time is not None:
            pulumi.set(__self__, "latest_window_start_time", latest_window_start_time)
        if maintenance_on_shutdown is not None:
            pulumi.set(__self__, "maintenance_on_shutdown", maintenance_on_shutdown)
        if maintenance_reasons is not None:
            pulumi.set(__self__, "maintenance_reasons", maintenance_reasons)
        if maintenance_status is not None:
            pulumi.set(__self__, "maintenance_status", maintenance_status)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if window_end_time is not None:
            pulumi.set(__self__, "window_end_time", window_end_time)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @_builtins.property
    @pulumi.getter(name="canReschedule")
    def can_reschedule(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Indicates if the maintenance can be customer triggered.
        """
        return pulumi.get(self, "can_reschedule")

    @_builtins.property
    @pulumi.getter(name="latestWindowStartTime")
    def latest_window_start_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        The latest time for the planned maintenance window to start. This timestamp value is in RFC3339 text format.
        """
        return pulumi.get(self, "latest_window_start_time")

    @_builtins.property
    @pulumi.getter(name="maintenanceOnShutdown")
    def maintenance_on_shutdown(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Indicates whether the UpcomingMaintenance will be triggered on VM shutdown.
        """
        return pulumi.get(self, "maintenance_on_shutdown")

    @_builtins.property
    @pulumi.getter(name="maintenanceReasons")
    def maintenance_reasons(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        The reasons for the maintenance. Only valid for vms.
        """
        return pulumi.get(self, "maintenance_reasons")

    @_builtins.property
    @pulumi.getter(name="maintenanceStatus")
    def maintenance_status(self) -> Optional[_builtins.str]:
        """
        (Output)
        Status of the maintenance.
        """
        return pulumi.get(self, "maintenance_status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        (Output)
        Defines the type of maintenance.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="windowEndTime")
    def window_end_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        The time by which the maintenance disruption will be completed. This timestamp value is in RFC3339 text format.
        """
        return pulumi.get(self, "window_end_time")

    @_builtins.property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        The current start time of the maintenance window. This timestamp value is in RFC3339 text format.
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class ReservationResourceStatusSpecificSkuAllocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceInstanceTemplateId":
            suggest = "source_instance_template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservationResourceStatusSpecificSkuAllocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservationResourceStatusSpecificSkuAllocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservationResourceStatusSpecificSkuAllocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_instance_template_id: Optional[_builtins.str] = None,
                 utilizations: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str source_instance_template_id: (Output)
               ID of the instance template used to populate reservation properties.
        :param Mapping[str, _builtins.str] utilizations: (Output)
               Per service utilization breakdown. The Key is the Google Cloud managed service name.
        """
        if source_instance_template_id is not None:
            pulumi.set(__self__, "source_instance_template_id", source_instance_template_id)
        if utilizations is not None:
            pulumi.set(__self__, "utilizations", utilizations)

    @_builtins.property
    @pulumi.getter(name="sourceInstanceTemplateId")
    def source_instance_template_id(self) -> Optional[_builtins.str]:
        """
        (Output)
        ID of the instance template used to populate reservation properties.
        """
        return pulumi.get(self, "source_instance_template_id")

    @_builtins.property
    @pulumi.getter
    def utilizations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Output)
        Per service utilization breakdown. The Key is the Google Cloud managed service name.
        """
        return pulumi.get(self, "utilizations")


@pulumi.output_type
class ReservationShareSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectMaps":
            suggest = "project_maps"
        elif key == "shareType":
            suggest = "share_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservationShareSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservationShareSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservationShareSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_maps: Optional[Sequence['outputs.ReservationShareSettingsProjectMap']] = None,
                 projects: Optional[Sequence[_builtins.str]] = None,
                 share_type: Optional[_builtins.str] = None):
        """
        :param Sequence['ReservationShareSettingsProjectMapArgs'] project_maps: A map of project number and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.
               Structure is documented below.
        :param Sequence[_builtins.str] projects: List of project IDs with which the reservation is shared.
        :param _builtins.str share_type: Type of sharing for this shared-reservation
               Possible values are: `LOCAL`, `SPECIFIC_PROJECTS`.
        """
        if project_maps is not None:
            pulumi.set(__self__, "project_maps", project_maps)
        if projects is not None:
            pulumi.set(__self__, "projects", projects)
        if share_type is not None:
            pulumi.set(__self__, "share_type", share_type)

    @_builtins.property
    @pulumi.getter(name="projectMaps")
    def project_maps(self) -> Optional[Sequence['outputs.ReservationShareSettingsProjectMap']]:
        """
        A map of project number and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.
        Structure is documented below.
        """
        return pulumi.get(self, "project_maps")

    @_builtins.property
    @pulumi.getter
    def projects(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of project IDs with which the reservation is shared.
        """
        return pulumi.get(self, "projects")

    @_builtins.property
    @pulumi.getter(name="shareType")
    def share_type(self) -> Optional[_builtins.str]:
        """
        Type of sharing for this shared-reservation
        Possible values are: `LOCAL`, `SPECIFIC_PROJECTS`.
        """
        return pulumi.get(self, "share_type")


@pulumi.output_type
class ReservationShareSettingsProjectMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservationShareSettingsProjectMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservationShareSettingsProjectMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservationShareSettingsProjectMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 project_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The identifier for this object. Format specified above.
        :param _builtins.str project_id: The project id/number, should be same as the key of this project config in the project map.
        """
        pulumi.set(__self__, "id", id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        The project id/number, should be same as the key of this project config in the project map.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class ReservationSpecificReservation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assuredCount":
            suggest = "assured_count"
        elif key == "inUseCount":
            suggest = "in_use_count"
        elif key == "instanceProperties":
            suggest = "instance_properties"
        elif key == "sourceInstanceTemplate":
            suggest = "source_instance_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservationSpecificReservation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservationSpecificReservation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservationSpecificReservation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: _builtins.int,
                 assured_count: Optional[_builtins.int] = None,
                 in_use_count: Optional[_builtins.int] = None,
                 instance_properties: Optional['outputs.ReservationSpecificReservationInstanceProperties'] = None,
                 source_instance_template: Optional[_builtins.str] = None):
        """
        :param _builtins.int count: The number of resources that are allocated.
        :param _builtins.int assured_count: (Output)
               Indicates how many instances are actually usable currently.
        :param _builtins.int in_use_count: (Output)
               How many instances are in use.
        :param 'ReservationSpecificReservationInstancePropertiesArgs' instance_properties: The instance properties for the reservation.
               Structure is documented below.
        :param _builtins.str source_instance_template: Specifies the instance template to create the reservation. If you use this field, you must exclude the
               instanceProperties field.
        """
        pulumi.set(__self__, "count", count)
        if assured_count is not None:
            pulumi.set(__self__, "assured_count", assured_count)
        if in_use_count is not None:
            pulumi.set(__self__, "in_use_count", in_use_count)
        if instance_properties is not None:
            pulumi.set(__self__, "instance_properties", instance_properties)
        if source_instance_template is not None:
            pulumi.set(__self__, "source_instance_template", source_instance_template)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of resources that are allocated.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="assuredCount")
    def assured_count(self) -> Optional[_builtins.int]:
        """
        (Output)
        Indicates how many instances are actually usable currently.
        """
        return pulumi.get(self, "assured_count")

    @_builtins.property
    @pulumi.getter(name="inUseCount")
    def in_use_count(self) -> Optional[_builtins.int]:
        """
        (Output)
        How many instances are in use.
        """
        return pulumi.get(self, "in_use_count")

    @_builtins.property
    @pulumi.getter(name="instanceProperties")
    def instance_properties(self) -> Optional['outputs.ReservationSpecificReservationInstanceProperties']:
        """
        The instance properties for the reservation.
        Structure is documented below.
        """
        return pulumi.get(self, "instance_properties")

    @_builtins.property
    @pulumi.getter(name="sourceInstanceTemplate")
    def source_instance_template(self) -> Optional[_builtins.str]:
        """
        Specifies the instance template to create the reservation. If you use this field, you must exclude the
        instanceProperties field.
        """
        return pulumi.get(self, "source_instance_template")


@pulumi.output_type
class ReservationSpecificReservationInstanceProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineType":
            suggest = "machine_type"
        elif key == "guestAccelerators":
            suggest = "guest_accelerators"
        elif key == "localSsds":
            suggest = "local_ssds"
        elif key == "locationHint":
            suggest = "location_hint"
        elif key == "maintenanceInterval":
            suggest = "maintenance_interval"
        elif key == "minCpuPlatform":
            suggest = "min_cpu_platform"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservationSpecificReservationInstanceProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservationSpecificReservationInstanceProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservationSpecificReservationInstanceProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 machine_type: _builtins.str,
                 guest_accelerators: Optional[Sequence['outputs.ReservationSpecificReservationInstancePropertiesGuestAccelerator']] = None,
                 local_ssds: Optional[Sequence['outputs.ReservationSpecificReservationInstancePropertiesLocalSsd']] = None,
                 location_hint: Optional[_builtins.str] = None,
                 maintenance_interval: Optional[_builtins.str] = None,
                 min_cpu_platform: Optional[_builtins.str] = None):
        """
        :param _builtins.str machine_type: The name of the machine type to reserve.
        :param Sequence['ReservationSpecificReservationInstancePropertiesGuestAcceleratorArgs'] guest_accelerators: Guest accelerator type and count.
               Structure is documented below.
        :param Sequence['ReservationSpecificReservationInstancePropertiesLocalSsdArgs'] local_ssds: The amount of local ssd to reserve with each instance. This
               reserves disks of type `local-ssd`.
               Structure is documented below.
        :param _builtins.str location_hint: (Output)
               An opaque location hint used to place the allocation close to other resources. This field is for use by internal tools that use the public API.
        :param _builtins.str maintenance_interval: Specifies the frequency of planned maintenance events.
               Possible values are: `AS_NEEDED`, `PERIODIC`, `RECURRENT`.
        :param _builtins.str min_cpu_platform: The minimum CPU platform for the reservation. For example,
               `"Intel Skylake"`. See
               the CPU platform availability reference](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform#availablezones)
               for information on available CPU platforms.
        """
        pulumi.set(__self__, "machine_type", machine_type)
        if guest_accelerators is not None:
            pulumi.set(__self__, "guest_accelerators", guest_accelerators)
        if local_ssds is not None:
            pulumi.set(__self__, "local_ssds", local_ssds)
        if location_hint is not None:
            pulumi.set(__self__, "location_hint", location_hint)
        if maintenance_interval is not None:
            pulumi.set(__self__, "maintenance_interval", maintenance_interval)
        if min_cpu_platform is not None:
            pulumi.set(__self__, "min_cpu_platform", min_cpu_platform)

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> _builtins.str:
        """
        The name of the machine type to reserve.
        """
        return pulumi.get(self, "machine_type")

    @_builtins.property
    @pulumi.getter(name="guestAccelerators")
    def guest_accelerators(self) -> Optional[Sequence['outputs.ReservationSpecificReservationInstancePropertiesGuestAccelerator']]:
        """
        Guest accelerator type and count.
        Structure is documented below.
        """
        return pulumi.get(self, "guest_accelerators")

    @_builtins.property
    @pulumi.getter(name="localSsds")
    def local_ssds(self) -> Optional[Sequence['outputs.ReservationSpecificReservationInstancePropertiesLocalSsd']]:
        """
        The amount of local ssd to reserve with each instance. This
        reserves disks of type `local-ssd`.
        Structure is documented below.
        """
        return pulumi.get(self, "local_ssds")

    @_builtins.property
    @pulumi.getter(name="locationHint")
    def location_hint(self) -> Optional[_builtins.str]:
        """
        (Output)
        An opaque location hint used to place the allocation close to other resources. This field is for use by internal tools that use the public API.
        """
        return pulumi.get(self, "location_hint")

    @_builtins.property
    @pulumi.getter(name="maintenanceInterval")
    def maintenance_interval(self) -> Optional[_builtins.str]:
        """
        Specifies the frequency of planned maintenance events.
        Possible values are: `AS_NEEDED`, `PERIODIC`, `RECURRENT`.
        """
        return pulumi.get(self, "maintenance_interval")

    @_builtins.property
    @pulumi.getter(name="minCpuPlatform")
    def min_cpu_platform(self) -> Optional[_builtins.str]:
        """
        The minimum CPU platform for the reservation. For example,
        `"Intel Skylake"`. See
        the CPU platform availability reference](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform#availablezones)
        for information on available CPU platforms.
        """
        return pulumi.get(self, "min_cpu_platform")


@pulumi.output_type
class ReservationSpecificReservationInstancePropertiesGuestAccelerator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorType":
            suggest = "accelerator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservationSpecificReservationInstancePropertiesGuestAccelerator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservationSpecificReservationInstancePropertiesGuestAccelerator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservationSpecificReservationInstancePropertiesGuestAccelerator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: _builtins.int,
                 accelerator_type: _builtins.str):
        """
        :param _builtins.int accelerator_count: The number of the guest accelerator cards exposed to
               this instance.
        :param _builtins.str accelerator_type: The full or partial URL of the accelerator type to
               attach to this instance. For example:
               `projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100`
               If you are creating an instance template, specify only the accelerator name.
        """
        pulumi.set(__self__, "accelerator_count", accelerator_count)
        pulumi.set(__self__, "accelerator_type", accelerator_type)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> _builtins.int:
        """
        The number of the guest accelerator cards exposed to
        this instance.
        """
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> _builtins.str:
        """
        The full or partial URL of the accelerator type to
        attach to this instance. For example:
        `projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100`
        If you are creating an instance template, specify only the accelerator name.
        """
        return pulumi.get(self, "accelerator_type")


@pulumi.output_type
class ReservationSpecificReservationInstancePropertiesLocalSsd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeGb":
            suggest = "disk_size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservationSpecificReservationInstancePropertiesLocalSsd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservationSpecificReservationInstancePropertiesLocalSsd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservationSpecificReservationInstancePropertiesLocalSsd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_gb: _builtins.int,
                 interface: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_size_gb: The size of the disk in base-2 GB.
        :param _builtins.str interface: The disk interface to use for attaching this disk.
               Default value is `SCSI`.
               Possible values are: `SCSI`, `NVME`.
        """
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.int:
        """
        The size of the disk in base-2 GB.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[_builtins.str]:
        """
        The disk interface to use for attaching this disk.
        Default value is `SCSI`.
        Possible values are: `SCSI`, `NVME`.
        """
        return pulumi.get(self, "interface")


@pulumi.output_type
class ResizeRequestRequestedRunDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 600 to 604800 inclusive. Note: minimum and maximum allowed range for requestedRunDuration is 10 minutes (600 seconds) and 7 days(604800 seconds) correspondingly.
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 600 to 604800 inclusive. Note: minimum and maximum allowed range for requestedRunDuration is 10 minutes (600 seconds) and 7 days(604800 seconds) correspondingly.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class ResizeRequestStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastAttempts":
            suggest = "last_attempts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResizeRequestStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResizeRequestStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResizeRequestStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 errors: Optional[Sequence['outputs.ResizeRequestStatusError']] = None,
                 last_attempts: Optional[Sequence['outputs.ResizeRequestStatusLastAttempt']] = None):
        """
        :param Sequence['ResizeRequestStatusErrorArgs'] errors: (Output)
               Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.
               Structure is documented below.
        :param Sequence['ResizeRequestStatusLastAttemptArgs'] last_attempts: (Output)
               Information about the last attempt to fulfill the request. The value is temporary since the ResizeRequest can retry, as long as it's still active and the last attempt value can either be cleared or replaced with a different error. Since ResizeRequest retries infrequently, the value may be stale and no longer show an active problem. The value is cleared when ResizeRequest transitions to the final state (becomes inactive). If the final state is FAILED the error describing it will be storred in the "error" field only.
               Structure is documented below.
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if last_attempts is not None:
            pulumi.set(__self__, "last_attempts", last_attempts)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.ResizeRequestStatusError']]:
        """
        (Output)
        Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.
        Structure is documented below.
        """
        return pulumi.get(self, "errors")

    @_builtins.property
    @pulumi.getter(name="lastAttempts")
    def last_attempts(self) -> Optional[Sequence['outputs.ResizeRequestStatusLastAttempt']]:
        """
        (Output)
        Information about the last attempt to fulfill the request. The value is temporary since the ResizeRequest can retry, as long as it's still active and the last attempt value can either be cleared or replaced with a different error. Since ResizeRequest retries infrequently, the value may be stale and no longer show an active problem. The value is cleared when ResizeRequest transitions to the final state (becomes inactive). If the final state is FAILED the error describing it will be storred in the "error" field only.
        Structure is documented below.
        """
        return pulumi.get(self, "last_attempts")


@pulumi.output_type
class ResizeRequestStatusError(dict):
    def __init__(__self__, *,
                 errors: Optional[Sequence['outputs.ResizeRequestStatusErrorError']] = None):
        """
        :param Sequence['ResizeRequestStatusErrorErrorArgs'] errors: (Output)
               The array of errors encountered while processing this operation.
               Structure is documented below.
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.ResizeRequestStatusErrorError']]:
        """
        (Output)
        The array of errors encountered while processing this operation.
        Structure is documented below.
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class ResizeRequestStatusErrorError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorDetails":
            suggest = "error_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResizeRequestStatusErrorError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResizeRequestStatusErrorError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResizeRequestStatusErrorError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 error_details: Optional[Sequence['outputs.ResizeRequestStatusErrorErrorErrorDetail']] = None,
                 location: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None):
        """
        :param _builtins.str code: (Output)
               The error type identifier for this error.
        :param Sequence['ResizeRequestStatusErrorErrorErrorDetailArgs'] error_details: (Output)
               An array of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
               Structure is documented below.
        :param _builtins.str location: (Output)
               Indicates the field in the request that caused the error. This property is optional.
        :param _builtins.str message: (Output)
               The localized error message in the above locale.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if error_details is not None:
            pulumi.set(__self__, "error_details", error_details)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The error type identifier for this error.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter(name="errorDetails")
    def error_details(self) -> Optional[Sequence['outputs.ResizeRequestStatusErrorErrorErrorDetail']]:
        """
        (Output)
        An array of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
        Structure is documented below.
        """
        return pulumi.get(self, "error_details")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        (Output)
        Indicates the field in the request that caused the error. This property is optional.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        (Output)
        The localized error message in the above locale.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class ResizeRequestStatusErrorErrorErrorDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorInfos":
            suggest = "error_infos"
        elif key == "localizedMessages":
            suggest = "localized_messages"
        elif key == "quotaInfos":
            suggest = "quota_infos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResizeRequestStatusErrorErrorErrorDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResizeRequestStatusErrorErrorErrorDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResizeRequestStatusErrorErrorErrorDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_infos: Optional[Sequence['outputs.ResizeRequestStatusErrorErrorErrorDetailErrorInfo']] = None,
                 helps: Optional[Sequence['outputs.ResizeRequestStatusErrorErrorErrorDetailHelp']] = None,
                 localized_messages: Optional[Sequence['outputs.ResizeRequestStatusErrorErrorErrorDetailLocalizedMessage']] = None,
                 quota_infos: Optional[Sequence['outputs.ResizeRequestStatusErrorErrorErrorDetailQuotaInfo']] = None):
        """
        :param Sequence['ResizeRequestStatusErrorErrorErrorDetailErrorInfoArgs'] error_infos: (Output)
               A nested object resource.
               Structure is documented below.
        :param Sequence['ResizeRequestStatusErrorErrorErrorDetailHelpArgs'] helps: (Output)
               A nested object resource.
               Structure is documented below.
        :param Sequence['ResizeRequestStatusErrorErrorErrorDetailLocalizedMessageArgs'] localized_messages: (Output)
               A nested object resource.
               Structure is documented below.
        :param Sequence['ResizeRequestStatusErrorErrorErrorDetailQuotaInfoArgs'] quota_infos: (Output)
               A nested object resource.
               Structure is documented below.
        """
        if error_infos is not None:
            pulumi.set(__self__, "error_infos", error_infos)
        if helps is not None:
            pulumi.set(__self__, "helps", helps)
        if localized_messages is not None:
            pulumi.set(__self__, "localized_messages", localized_messages)
        if quota_infos is not None:
            pulumi.set(__self__, "quota_infos", quota_infos)

    @_builtins.property
    @pulumi.getter(name="errorInfos")
    def error_infos(self) -> Optional[Sequence['outputs.ResizeRequestStatusErrorErrorErrorDetailErrorInfo']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "error_infos")

    @_builtins.property
    @pulumi.getter
    def helps(self) -> Optional[Sequence['outputs.ResizeRequestStatusErrorErrorErrorDetailHelp']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "helps")

    @_builtins.property
    @pulumi.getter(name="localizedMessages")
    def localized_messages(self) -> Optional[Sequence['outputs.ResizeRequestStatusErrorErrorErrorDetailLocalizedMessage']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "localized_messages")

    @_builtins.property
    @pulumi.getter(name="quotaInfos")
    def quota_infos(self) -> Optional[Sequence['outputs.ResizeRequestStatusErrorErrorErrorDetailQuotaInfo']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "quota_infos")


@pulumi.output_type
class ResizeRequestStatusErrorErrorErrorDetailErrorInfo(dict):
    def __init__(__self__, *,
                 domain: Optional[_builtins.str] = None,
                 metadatas: Optional[Mapping[str, _builtins.str]] = None,
                 reason: Optional[_builtins.str] = None):
        """
        :param _builtins.str domain: (Output)
               The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com".
        :param Mapping[str, _builtins.str] metadatas: (Output)
               Additional structured details about this error.
        :param _builtins.str reason: (Output)
               The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        (Output)
        The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com".
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def metadatas(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Output)
        Additional structured details about this error.
        """
        return pulumi.get(self, "metadatas")

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[_builtins.str]:
        """
        (Output)
        The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors.
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class ResizeRequestStatusErrorErrorErrorDetailHelp(dict):
    def __init__(__self__, *,
                 links: Optional[Sequence['outputs.ResizeRequestStatusErrorErrorErrorDetailHelpLink']] = None):
        """
        :param Sequence['ResizeRequestStatusErrorErrorErrorDetailHelpLinkArgs'] links: (Output)
               A nested object resource.
               Structure is documented below.
        """
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.ResizeRequestStatusErrorErrorErrorDetailHelpLink']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "links")


@pulumi.output_type
class ResizeRequestStatusErrorErrorErrorDetailHelpLink(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: An optional description of this resize-request.
        :param _builtins.str url: (Output)
               The URL of the link.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resize-request.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        (Output)
        The URL of the link.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ResizeRequestStatusErrorErrorErrorDetailLocalizedMessage(dict):
    def __init__(__self__, *,
                 locale: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None):
        """
        :param _builtins.str locale: (Output)
               The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"
        :param _builtins.str message: (Output)
               The localized error message in the above locale.
        """
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def locale(self) -> Optional[_builtins.str]:
        """
        (Output)
        The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"
        """
        return pulumi.get(self, "locale")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        (Output)
        The localized error message in the above locale.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class ResizeRequestStatusErrorErrorErrorDetailQuotaInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "futureLimit":
            suggest = "future_limit"
        elif key == "limitName":
            suggest = "limit_name"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "rolloutStatus":
            suggest = "rollout_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResizeRequestStatusErrorErrorErrorDetailQuotaInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResizeRequestStatusErrorErrorErrorDetailQuotaInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResizeRequestStatusErrorErrorErrorDetailQuotaInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimensions: Optional[Mapping[str, _builtins.str]] = None,
                 future_limit: Optional[_builtins.int] = None,
                 limit: Optional[_builtins.int] = None,
                 limit_name: Optional[_builtins.str] = None,
                 metric_name: Optional[_builtins.str] = None,
                 rollout_status: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] dimensions: (Output)
               The map holding related quota dimensions
        :param _builtins.int future_limit: (Output)
               Future quota limit being rolled out. The limit's unit depends on the quota type or metric.
        :param _builtins.int limit: (Output)
               Current effective quota limit. The limit's unit depends on the quota type or metric.
        :param _builtins.str limit_name: (Output)
               The name of the quota limit.
        :param _builtins.str metric_name: (Output)
               The Compute Engine quota metric name.
        :param _builtins.str rollout_status: (Output)
               Rollout status of the future quota limit.
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if future_limit is not None:
            pulumi.set(__self__, "future_limit", future_limit)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if limit_name is not None:
            pulumi.set(__self__, "limit_name", limit_name)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if rollout_status is not None:
            pulumi.set(__self__, "rollout_status", rollout_status)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Output)
        The map holding related quota dimensions
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="futureLimit")
    def future_limit(self) -> Optional[_builtins.int]:
        """
        (Output)
        Future quota limit being rolled out. The limit's unit depends on the quota type or metric.
        """
        return pulumi.get(self, "future_limit")

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.int]:
        """
        (Output)
        Current effective quota limit. The limit's unit depends on the quota type or metric.
        """
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter(name="limitName")
    def limit_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the quota limit.
        """
        return pulumi.get(self, "limit_name")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Compute Engine quota metric name.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="rolloutStatus")
    def rollout_status(self) -> Optional[_builtins.str]:
        """
        (Output)
        Rollout status of the future quota limit.
        """
        return pulumi.get(self, "rollout_status")


@pulumi.output_type
class ResizeRequestStatusLastAttempt(dict):
    def __init__(__self__, *,
                 errors: Optional[Sequence['outputs.ResizeRequestStatusLastAttemptError']] = None):
        """
        :param Sequence['ResizeRequestStatusLastAttemptErrorArgs'] errors: (Output)
               Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.
               Structure is documented below.
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.ResizeRequestStatusLastAttemptError']]:
        """
        (Output)
        Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.
        Structure is documented below.
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class ResizeRequestStatusLastAttemptError(dict):
    def __init__(__self__, *,
                 errors: Optional[Sequence['outputs.ResizeRequestStatusLastAttemptErrorError']] = None):
        """
        :param Sequence['ResizeRequestStatusLastAttemptErrorErrorArgs'] errors: (Output)
               The array of errors encountered while processing this operation.
               Structure is documented below.
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.ResizeRequestStatusLastAttemptErrorError']]:
        """
        (Output)
        The array of errors encountered while processing this operation.
        Structure is documented below.
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class ResizeRequestStatusLastAttemptErrorError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorDetails":
            suggest = "error_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResizeRequestStatusLastAttemptErrorError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResizeRequestStatusLastAttemptErrorError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResizeRequestStatusLastAttemptErrorError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 error_details: Optional[Sequence['outputs.ResizeRequestStatusLastAttemptErrorErrorErrorDetail']] = None,
                 location: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None):
        """
        :param _builtins.str code: (Output)
               The error type identifier for this error.
        :param Sequence['ResizeRequestStatusLastAttemptErrorErrorErrorDetailArgs'] error_details: (Output)
               An array of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
               Structure is documented below.
        :param _builtins.str location: (Output)
               Indicates the field in the request that caused the error. This property is optional.
        :param _builtins.str message: (Output)
               The localized error message in the above locale.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if error_details is not None:
            pulumi.set(__self__, "error_details", error_details)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The error type identifier for this error.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter(name="errorDetails")
    def error_details(self) -> Optional[Sequence['outputs.ResizeRequestStatusLastAttemptErrorErrorErrorDetail']]:
        """
        (Output)
        An array of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
        Structure is documented below.
        """
        return pulumi.get(self, "error_details")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        (Output)
        Indicates the field in the request that caused the error. This property is optional.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        (Output)
        The localized error message in the above locale.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class ResizeRequestStatusLastAttemptErrorErrorErrorDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorInfos":
            suggest = "error_infos"
        elif key == "localizedMessages":
            suggest = "localized_messages"
        elif key == "quotaInfos":
            suggest = "quota_infos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResizeRequestStatusLastAttemptErrorErrorErrorDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResizeRequestStatusLastAttemptErrorErrorErrorDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResizeRequestStatusLastAttemptErrorErrorErrorDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_infos: Optional[Sequence['outputs.ResizeRequestStatusLastAttemptErrorErrorErrorDetailErrorInfo']] = None,
                 helps: Optional[Sequence['outputs.ResizeRequestStatusLastAttemptErrorErrorErrorDetailHelp']] = None,
                 localized_messages: Optional[Sequence['outputs.ResizeRequestStatusLastAttemptErrorErrorErrorDetailLocalizedMessage']] = None,
                 quota_infos: Optional[Sequence['outputs.ResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo']] = None):
        """
        :param Sequence['ResizeRequestStatusLastAttemptErrorErrorErrorDetailErrorInfoArgs'] error_infos: (Output)
               A nested object resource.
               Structure is documented below.
        :param Sequence['ResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpArgs'] helps: (Output)
               A nested object resource.
               Structure is documented below.
        :param Sequence['ResizeRequestStatusLastAttemptErrorErrorErrorDetailLocalizedMessageArgs'] localized_messages: (Output)
               A nested object resource.
               Structure is documented below.
        :param Sequence['ResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfoArgs'] quota_infos: (Output)
               A nested object resource.
               Structure is documented below.
        """
        if error_infos is not None:
            pulumi.set(__self__, "error_infos", error_infos)
        if helps is not None:
            pulumi.set(__self__, "helps", helps)
        if localized_messages is not None:
            pulumi.set(__self__, "localized_messages", localized_messages)
        if quota_infos is not None:
            pulumi.set(__self__, "quota_infos", quota_infos)

    @_builtins.property
    @pulumi.getter(name="errorInfos")
    def error_infos(self) -> Optional[Sequence['outputs.ResizeRequestStatusLastAttemptErrorErrorErrorDetailErrorInfo']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "error_infos")

    @_builtins.property
    @pulumi.getter
    def helps(self) -> Optional[Sequence['outputs.ResizeRequestStatusLastAttemptErrorErrorErrorDetailHelp']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "helps")

    @_builtins.property
    @pulumi.getter(name="localizedMessages")
    def localized_messages(self) -> Optional[Sequence['outputs.ResizeRequestStatusLastAttemptErrorErrorErrorDetailLocalizedMessage']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "localized_messages")

    @_builtins.property
    @pulumi.getter(name="quotaInfos")
    def quota_infos(self) -> Optional[Sequence['outputs.ResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "quota_infos")


@pulumi.output_type
class ResizeRequestStatusLastAttemptErrorErrorErrorDetailErrorInfo(dict):
    def __init__(__self__, *,
                 domain: Optional[_builtins.str] = None,
                 metadatas: Optional[Mapping[str, _builtins.str]] = None,
                 reason: Optional[_builtins.str] = None):
        """
        :param _builtins.str domain: (Output)
               The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com".
        :param Mapping[str, _builtins.str] metadatas: (Output)
               Additional structured details about this error.
        :param _builtins.str reason: (Output)
               The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        (Output)
        The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com".
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def metadatas(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Output)
        Additional structured details about this error.
        """
        return pulumi.get(self, "metadatas")

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[_builtins.str]:
        """
        (Output)
        The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors.
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class ResizeRequestStatusLastAttemptErrorErrorErrorDetailHelp(dict):
    def __init__(__self__, *,
                 links: Optional[Sequence['outputs.ResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpLink']] = None):
        """
        :param Sequence['ResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpLinkArgs'] links: (Output)
               A nested object resource.
               Structure is documented below.
        """
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.ResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpLink']]:
        """
        (Output)
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "links")


@pulumi.output_type
class ResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpLink(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: An optional description of this resize-request.
        :param _builtins.str url: (Output)
               The URL of the link.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resize-request.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        (Output)
        The URL of the link.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ResizeRequestStatusLastAttemptErrorErrorErrorDetailLocalizedMessage(dict):
    def __init__(__self__, *,
                 locale: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None):
        """
        :param _builtins.str locale: (Output)
               The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"
        :param _builtins.str message: (Output)
               The localized error message in the above locale.
        """
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def locale(self) -> Optional[_builtins.str]:
        """
        (Output)
        The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"
        """
        return pulumi.get(self, "locale")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        (Output)
        The localized error message in the above locale.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class ResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "futureLimit":
            suggest = "future_limit"
        elif key == "limitName":
            suggest = "limit_name"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "rolloutStatus":
            suggest = "rollout_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimensions: Optional[Mapping[str, _builtins.str]] = None,
                 future_limit: Optional[_builtins.int] = None,
                 limit: Optional[_builtins.int] = None,
                 limit_name: Optional[_builtins.str] = None,
                 metric_name: Optional[_builtins.str] = None,
                 rollout_status: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] dimensions: (Output)
               The map holding related quota dimensions
        :param _builtins.int future_limit: (Output)
               Future quota limit being rolled out. The limit's unit depends on the quota type or metric.
        :param _builtins.int limit: (Output)
               Current effective quota limit. The limit's unit depends on the quota type or metric.
        :param _builtins.str limit_name: (Output)
               The name of the quota limit.
        :param _builtins.str metric_name: (Output)
               The Compute Engine quota metric name.
        :param _builtins.str rollout_status: (Output)
               Rollout status of the future quota limit.
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if future_limit is not None:
            pulumi.set(__self__, "future_limit", future_limit)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if limit_name is not None:
            pulumi.set(__self__, "limit_name", limit_name)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if rollout_status is not None:
            pulumi.set(__self__, "rollout_status", rollout_status)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Output)
        The map holding related quota dimensions
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="futureLimit")
    def future_limit(self) -> Optional[_builtins.int]:
        """
        (Output)
        Future quota limit being rolled out. The limit's unit depends on the quota type or metric.
        """
        return pulumi.get(self, "future_limit")

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.int]:
        """
        (Output)
        Current effective quota limit. The limit's unit depends on the quota type or metric.
        """
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter(name="limitName")
    def limit_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the quota limit.
        """
        return pulumi.get(self, "limit_name")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Compute Engine quota metric name.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="rolloutStatus")
    def rollout_status(self) -> Optional[_builtins.str]:
        """
        (Output)
        Rollout status of the future quota limit.
        """
        return pulumi.get(self, "rollout_status")


@pulumi.output_type
class ResourcePolicyDiskConsistencyGroupPolicy(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Enable disk consistency on the resource policy.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable disk consistency on the resource policy.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ResourcePolicyGroupPlacementPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityDomainCount":
            suggest = "availability_domain_count"
        elif key == "gpuTopology":
            suggest = "gpu_topology"
        elif key == "maxDistance":
            suggest = "max_distance"
        elif key == "tpuTopology":
            suggest = "tpu_topology"
        elif key == "vmCount":
            suggest = "vm_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePolicyGroupPlacementPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePolicyGroupPlacementPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePolicyGroupPlacementPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_domain_count: Optional[_builtins.int] = None,
                 collocation: Optional[_builtins.str] = None,
                 gpu_topology: Optional[_builtins.str] = None,
                 max_distance: Optional[_builtins.int] = None,
                 tpu_topology: Optional[_builtins.str] = None,
                 vm_count: Optional[_builtins.int] = None):
        """
        :param _builtins.int availability_domain_count: The number of availability domains instances will be spread across. If two instances are in different
               availability domain, they will not be put in the same low latency network
        :param _builtins.str collocation: Collocation specifies whether to place VMs inside the same availability domain on the same low-latency network.
               Specify `COLLOCATED` to enable collocation. Can only be specified with `vm_count`. If compute instances are created
               with a COLLOCATED policy, then exactly `vm_count` instances must be created at the same time with the resource policy
               attached.
               Possible values are: `COLLOCATED`.
        :param _builtins.str gpu_topology: Specifies the shape of the GPU slice, in slice based GPU families eg. A4X.
        :param _builtins.int max_distance: Specifies the number of max logical switches.
        :param _builtins.str tpu_topology: Specifies the shape of the TPU slice.
        :param _builtins.int vm_count: Number of VMs in this placement group. Google does not recommend that you use this field
               unless you use a compact policy and you want your policy to work only if it contains this
               exact number of VMs.
        """
        if availability_domain_count is not None:
            pulumi.set(__self__, "availability_domain_count", availability_domain_count)
        if collocation is not None:
            pulumi.set(__self__, "collocation", collocation)
        if gpu_topology is not None:
            pulumi.set(__self__, "gpu_topology", gpu_topology)
        if max_distance is not None:
            pulumi.set(__self__, "max_distance", max_distance)
        if tpu_topology is not None:
            pulumi.set(__self__, "tpu_topology", tpu_topology)
        if vm_count is not None:
            pulumi.set(__self__, "vm_count", vm_count)

    @_builtins.property
    @pulumi.getter(name="availabilityDomainCount")
    def availability_domain_count(self) -> Optional[_builtins.int]:
        """
        The number of availability domains instances will be spread across. If two instances are in different
        availability domain, they will not be put in the same low latency network
        """
        return pulumi.get(self, "availability_domain_count")

    @_builtins.property
    @pulumi.getter
    def collocation(self) -> Optional[_builtins.str]:
        """
        Collocation specifies whether to place VMs inside the same availability domain on the same low-latency network.
        Specify `COLLOCATED` to enable collocation. Can only be specified with `vm_count`. If compute instances are created
        with a COLLOCATED policy, then exactly `vm_count` instances must be created at the same time with the resource policy
        attached.
        Possible values are: `COLLOCATED`.
        """
        return pulumi.get(self, "collocation")

    @_builtins.property
    @pulumi.getter(name="gpuTopology")
    def gpu_topology(self) -> Optional[_builtins.str]:
        """
        Specifies the shape of the GPU slice, in slice based GPU families eg. A4X.
        """
        return pulumi.get(self, "gpu_topology")

    @_builtins.property
    @pulumi.getter(name="maxDistance")
    def max_distance(self) -> Optional[_builtins.int]:
        """
        Specifies the number of max logical switches.
        """
        return pulumi.get(self, "max_distance")

    @_builtins.property
    @pulumi.getter(name="tpuTopology")
    def tpu_topology(self) -> Optional[_builtins.str]:
        """
        Specifies the shape of the TPU slice.
        """
        return pulumi.get(self, "tpu_topology")

    @_builtins.property
    @pulumi.getter(name="vmCount")
    def vm_count(self) -> Optional[_builtins.int]:
        """
        Number of VMs in this placement group. Google does not recommend that you use this field
        unless you use a compact policy and you want your policy to work only if it contains this
        exact number of VMs.
        """
        return pulumi.get(self, "vm_count")


@pulumi.output_type
class ResourcePolicyInstanceSchedulePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeZone":
            suggest = "time_zone"
        elif key == "expirationTime":
            suggest = "expiration_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "vmStartSchedule":
            suggest = "vm_start_schedule"
        elif key == "vmStopSchedule":
            suggest = "vm_stop_schedule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePolicyInstanceSchedulePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePolicyInstanceSchedulePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePolicyInstanceSchedulePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_zone: _builtins.str,
                 expiration_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 vm_start_schedule: Optional['outputs.ResourcePolicyInstanceSchedulePolicyVmStartSchedule'] = None,
                 vm_stop_schedule: Optional['outputs.ResourcePolicyInstanceSchedulePolicyVmStopSchedule'] = None):
        """
        :param _builtins.str time_zone: Specifies the time zone to be used in interpreting the schedule. The value of this field must be a time zone name
               from the tz database: http://en.wikipedia.org/wiki/Tz_database.
        :param _builtins.str expiration_time: The expiration time of the schedule. The timestamp is an RFC3339 string.
        :param _builtins.str start_time: The start time of the schedule. The timestamp is an RFC3339 string.
        :param 'ResourcePolicyInstanceSchedulePolicyVmStartScheduleArgs' vm_start_schedule: Specifies the schedule for starting instances.
               Structure is documented below.
        :param 'ResourcePolicyInstanceSchedulePolicyVmStopScheduleArgs' vm_stop_schedule: Specifies the schedule for stopping instances.
               Structure is documented below.
        """
        pulumi.set(__self__, "time_zone", time_zone)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if vm_start_schedule is not None:
            pulumi.set(__self__, "vm_start_schedule", vm_start_schedule)
        if vm_stop_schedule is not None:
            pulumi.set(__self__, "vm_stop_schedule", vm_stop_schedule)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        Specifies the time zone to be used in interpreting the schedule. The value of this field must be a time zone name
        from the tz database: http://en.wikipedia.org/wiki/Tz_database.
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[_builtins.str]:
        """
        The expiration time of the schedule. The timestamp is an RFC3339 string.
        """
        return pulumi.get(self, "expiration_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        The start time of the schedule. The timestamp is an RFC3339 string.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="vmStartSchedule")
    def vm_start_schedule(self) -> Optional['outputs.ResourcePolicyInstanceSchedulePolicyVmStartSchedule']:
        """
        Specifies the schedule for starting instances.
        Structure is documented below.
        """
        return pulumi.get(self, "vm_start_schedule")

    @_builtins.property
    @pulumi.getter(name="vmStopSchedule")
    def vm_stop_schedule(self) -> Optional['outputs.ResourcePolicyInstanceSchedulePolicyVmStopSchedule']:
        """
        Specifies the schedule for stopping instances.
        Structure is documented below.
        """
        return pulumi.get(self, "vm_stop_schedule")


@pulumi.output_type
class ResourcePolicyInstanceSchedulePolicyVmStartSchedule(dict):
    def __init__(__self__, *,
                 schedule: _builtins.str):
        """
        :param _builtins.str schedule: Specifies the frequency for the operation, using the unix-cron format.
        """
        pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> _builtins.str:
        """
        Specifies the frequency for the operation, using the unix-cron format.
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class ResourcePolicyInstanceSchedulePolicyVmStopSchedule(dict):
    def __init__(__self__, *,
                 schedule: _builtins.str):
        """
        :param _builtins.str schedule: Specifies the frequency for the operation, using the unix-cron format.
        """
        pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> _builtins.str:
        """
        Specifies the frequency for the operation, using the unix-cron format.
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionPolicy":
            suggest = "retention_policy"
        elif key == "snapshotProperties":
            suggest = "snapshot_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePolicySnapshotSchedulePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePolicySnapshotSchedulePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePolicySnapshotSchedulePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schedule: 'outputs.ResourcePolicySnapshotSchedulePolicySchedule',
                 retention_policy: Optional['outputs.ResourcePolicySnapshotSchedulePolicyRetentionPolicy'] = None,
                 snapshot_properties: Optional['outputs.ResourcePolicySnapshotSchedulePolicySnapshotProperties'] = None):
        """
        :param 'ResourcePolicySnapshotSchedulePolicyScheduleArgs' schedule: Contains one of an `hourlySchedule`, `dailySchedule`, or `weeklySchedule`.
               Structure is documented below.
        :param 'ResourcePolicySnapshotSchedulePolicyRetentionPolicyArgs' retention_policy: Retention policy applied to snapshots created by this resource policy.
               Structure is documented below.
        :param 'ResourcePolicySnapshotSchedulePolicySnapshotPropertiesArgs' snapshot_properties: Properties with which the snapshots are created, such as labels.
               Structure is documented below.
        """
        pulumi.set(__self__, "schedule", schedule)
        if retention_policy is not None:
            pulumi.set(__self__, "retention_policy", retention_policy)
        if snapshot_properties is not None:
            pulumi.set(__self__, "snapshot_properties", snapshot_properties)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> 'outputs.ResourcePolicySnapshotSchedulePolicySchedule':
        """
        Contains one of an `hourlySchedule`, `dailySchedule`, or `weeklySchedule`.
        Structure is documented below.
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicyRetentionPolicy']:
        """
        Retention policy applied to snapshots created by this resource policy.
        Structure is documented below.
        """
        return pulumi.get(self, "retention_policy")

    @_builtins.property
    @pulumi.getter(name="snapshotProperties")
    def snapshot_properties(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicySnapshotProperties']:
        """
        Properties with which the snapshots are created, such as labels.
        Structure is documented below.
        """
        return pulumi.get(self, "snapshot_properties")


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyRetentionPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRetentionDays":
            suggest = "max_retention_days"
        elif key == "onSourceDiskDelete":
            suggest = "on_source_disk_delete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePolicySnapshotSchedulePolicyRetentionPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePolicySnapshotSchedulePolicyRetentionPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePolicySnapshotSchedulePolicyRetentionPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_retention_days: _builtins.int,
                 on_source_disk_delete: Optional[_builtins.str] = None):
        """
        :param _builtins.int max_retention_days: Maximum age of the snapshot that is allowed to be kept.
        :param _builtins.str on_source_disk_delete: Specifies the behavior to apply to scheduled snapshots when
               the source disk is deleted.
               Default value is `KEEP_AUTO_SNAPSHOTS`.
               Possible values are: `KEEP_AUTO_SNAPSHOTS`, `APPLY_RETENTION_POLICY`.
        """
        pulumi.set(__self__, "max_retention_days", max_retention_days)
        if on_source_disk_delete is not None:
            pulumi.set(__self__, "on_source_disk_delete", on_source_disk_delete)

    @_builtins.property
    @pulumi.getter(name="maxRetentionDays")
    def max_retention_days(self) -> _builtins.int:
        """
        Maximum age of the snapshot that is allowed to be kept.
        """
        return pulumi.get(self, "max_retention_days")

    @_builtins.property
    @pulumi.getter(name="onSourceDiskDelete")
    def on_source_disk_delete(self) -> Optional[_builtins.str]:
        """
        Specifies the behavior to apply to scheduled snapshots when
        the source disk is deleted.
        Default value is `KEEP_AUTO_SNAPSHOTS`.
        Possible values are: `KEEP_AUTO_SNAPSHOTS`, `APPLY_RETENTION_POLICY`.
        """
        return pulumi.get(self, "on_source_disk_delete")


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicySchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dailySchedule":
            suggest = "daily_schedule"
        elif key == "hourlySchedule":
            suggest = "hourly_schedule"
        elif key == "weeklySchedule":
            suggest = "weekly_schedule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePolicySnapshotSchedulePolicySchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePolicySnapshotSchedulePolicySchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePolicySnapshotSchedulePolicySchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 daily_schedule: Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule'] = None,
                 hourly_schedule: Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule'] = None,
                 weekly_schedule: Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule'] = None):
        """
        :param 'ResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleArgs' daily_schedule: The policy will execute every nth day at the specified time.
               Structure is documented below.
        :param 'ResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleArgs' hourly_schedule: The policy will execute every nth hour starting at the specified time.
               Structure is documented below.
        :param 'ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleArgs' weekly_schedule: Allows specifying a snapshot time for each day of the week.
               Structure is documented below.
        """
        if daily_schedule is not None:
            pulumi.set(__self__, "daily_schedule", daily_schedule)
        if hourly_schedule is not None:
            pulumi.set(__self__, "hourly_schedule", hourly_schedule)
        if weekly_schedule is not None:
            pulumi.set(__self__, "weekly_schedule", weekly_schedule)

    @_builtins.property
    @pulumi.getter(name="dailySchedule")
    def daily_schedule(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule']:
        """
        The policy will execute every nth day at the specified time.
        Structure is documented below.
        """
        return pulumi.get(self, "daily_schedule")

    @_builtins.property
    @pulumi.getter(name="hourlySchedule")
    def hourly_schedule(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule']:
        """
        The policy will execute every nth hour starting at the specified time.
        Structure is documented below.
        """
        return pulumi.get(self, "hourly_schedule")

    @_builtins.property
    @pulumi.getter(name="weeklySchedule")
    def weekly_schedule(self) -> Optional['outputs.ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule']:
        """
        Allows specifying a snapshot time for each day of the week.
        Structure is documented below.
        """
        return pulumi.get(self, "weekly_schedule")


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysInCycle":
            suggest = "days_in_cycle"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_in_cycle: _builtins.int,
                 start_time: _builtins.str):
        """
        :param _builtins.int days_in_cycle: Defines a schedule with units measured in days. The value determines how many days pass between the start of each cycle. Days in cycle for snapshot schedule policy must be 1.
        :param _builtins.str start_time: This must be in UTC format that resolves to one of
               00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example,
               both 13:00-5 and 08:00 are valid.
        """
        pulumi.set(__self__, "days_in_cycle", days_in_cycle)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="daysInCycle")
    def days_in_cycle(self) -> _builtins.int:
        """
        Defines a schedule with units measured in days. The value determines how many days pass between the start of each cycle. Days in cycle for snapshot schedule policy must be 1.
        """
        return pulumi.get(self, "days_in_cycle")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        This must be in UTC format that resolves to one of
        00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example,
        both 13:00-5 and 08:00 are valid.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hoursInCycle":
            suggest = "hours_in_cycle"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hours_in_cycle: _builtins.int,
                 start_time: _builtins.str):
        """
        :param _builtins.int hours_in_cycle: The number of hours between snapshots.
        :param _builtins.str start_time: Time within the window to start the operations.
               It must be in an hourly format "HH:MM",
               where HH : [00-23] and MM : [00] GMT. eg: 21:00
        """
        pulumi.set(__self__, "hours_in_cycle", hours_in_cycle)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="hoursInCycle")
    def hours_in_cycle(self) -> _builtins.int:
        """
        The number of hours between snapshots.
        """
        return pulumi.get(self, "hours_in_cycle")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Time within the window to start the operations.
        It must be in an hourly format "HH:MM",
        where HH : [00-23] and MM : [00] GMT. eg: 21:00
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeeks":
            suggest = "day_of_weeks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_weeks: Sequence['outputs.ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek']):
        """
        :param Sequence['ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekArgs'] day_of_weeks: May contain up to seven (one for each day of the week) snapshot times.
               Structure is documented below.
        """
        pulumi.set(__self__, "day_of_weeks", day_of_weeks)

    @_builtins.property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> Sequence['outputs.ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek']:
        """
        May contain up to seven (one for each day of the week) snapshot times.
        Structure is documented below.
        """
        return pulumi.get(self, "day_of_weeks")


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day: _builtins.str,
                 start_time: _builtins.str):
        """
        :param _builtins.str day: The day of the week to create the snapshot. e.g. MONDAY
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param _builtins.str start_time: Time within the window to start the operations.
               It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def day(self) -> _builtins.str:
        """
        The day of the week to create the snapshot. e.g. MONDAY
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Time within the window to start the operations.
        It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ResourcePolicySnapshotSchedulePolicySnapshotProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chainName":
            suggest = "chain_name"
        elif key == "guestFlush":
            suggest = "guest_flush"
        elif key == "storageLocations":
            suggest = "storage_locations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePolicySnapshotSchedulePolicySnapshotProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePolicySnapshotSchedulePolicySnapshotProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePolicySnapshotSchedulePolicySnapshotProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chain_name: Optional[_builtins.str] = None,
                 guest_flush: Optional[_builtins.bool] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 storage_locations: Optional[_builtins.str] = None):
        """
        :param _builtins.str chain_name: Creates the new snapshot in the snapshot chain labeled with the
               specified name. The chain name must be 1-63 characters long and comply
               with RFC1035.
        :param _builtins.bool guest_flush: Whether to perform a 'guest aware' snapshot.
        :param Mapping[str, _builtins.str] labels: A set of key-value pairs.
        :param _builtins.str storage_locations: Cloud Storage bucket location to store the auto snapshot
               (regional or multi-regional)
        """
        if chain_name is not None:
            pulumi.set(__self__, "chain_name", chain_name)
        if guest_flush is not None:
            pulumi.set(__self__, "guest_flush", guest_flush)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if storage_locations is not None:
            pulumi.set(__self__, "storage_locations", storage_locations)

    @_builtins.property
    @pulumi.getter(name="chainName")
    def chain_name(self) -> Optional[_builtins.str]:
        """
        Creates the new snapshot in the snapshot chain labeled with the
        specified name. The chain name must be 1-63 characters long and comply
        with RFC1035.
        """
        return pulumi.get(self, "chain_name")

    @_builtins.property
    @pulumi.getter(name="guestFlush")
    def guest_flush(self) -> Optional[_builtins.bool]:
        """
        Whether to perform a 'guest aware' snapshot.
        """
        return pulumi.get(self, "guest_flush")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key-value pairs.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="storageLocations")
    def storage_locations(self) -> Optional[_builtins.str]:
        """
        Cloud Storage bucket location to store the auto snapshot
        (regional or multi-regional)
        """
        return pulumi.get(self, "storage_locations")


@pulumi.output_type
class ResourcePolicyWorkloadPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorTopology":
            suggest = "accelerator_topology"
        elif key == "maxTopologyDistance":
            suggest = "max_topology_distance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePolicyWorkloadPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePolicyWorkloadPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePolicyWorkloadPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 accelerator_topology: Optional[_builtins.str] = None,
                 max_topology_distance: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of workload policy.
               Possible values are: `HIGH_AVAILABILITY`, `HIGH_THROUGHPUT`.
        :param _builtins.str accelerator_topology: The accelerator topology. This field can be set only when the workload policy type is HIGH_THROUGHPUT
               and cannot be set if max topology distance is set.
        :param _builtins.str max_topology_distance: The maximum topology distance. This field can be set only when the workload policy type is HIGH_THROUGHPUT
               and cannot be set if accelerator topology is set.
               Possible values are: `BLOCK`, `CLUSTER`, `SUBBLOCK`.
        """
        pulumi.set(__self__, "type", type)
        if accelerator_topology is not None:
            pulumi.set(__self__, "accelerator_topology", accelerator_topology)
        if max_topology_distance is not None:
            pulumi.set(__self__, "max_topology_distance", max_topology_distance)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of workload policy.
        Possible values are: `HIGH_AVAILABILITY`, `HIGH_THROUGHPUT`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="acceleratorTopology")
    def accelerator_topology(self) -> Optional[_builtins.str]:
        """
        The accelerator topology. This field can be set only when the workload policy type is HIGH_THROUGHPUT
        and cannot be set if max topology distance is set.
        """
        return pulumi.get(self, "accelerator_topology")

    @_builtins.property
    @pulumi.getter(name="maxTopologyDistance")
    def max_topology_distance(self) -> Optional[_builtins.str]:
        """
        The maximum topology distance. This field can be set only when the workload policy type is HIGH_THROUGHPUT
        and cannot be set if accelerator topology is set.
        Possible values are: `BLOCK`, `CLUSTER`, `SUBBLOCK`.
        """
        return pulumi.get(self, "max_topology_distance")


@pulumi.output_type
class RouteAsPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asLists":
            suggest = "as_lists"
        elif key == "pathSegmentType":
            suggest = "path_segment_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteAsPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteAsPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteAsPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 as_lists: Optional[Sequence[_builtins.int]] = None,
                 path_segment_type: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.int] as_lists: (Output)
               The AS numbers of the AS Path.
        :param _builtins.str path_segment_type: (Output)
               The type of the AS Path, which can be one of the following values:
               - 'AS_SET': unordered set of autonomous systems that the route in has traversed
               - 'AS_SEQUENCE': ordered set of autonomous systems that the route has traversed
               - 'AS_CONFED_SEQUENCE': ordered set of Member Autonomous Systems in the local confederation that the route has traversed
               - 'AS_CONFED_SET': unordered set of Member Autonomous Systems in the local confederation that the route has traversed
        """
        if as_lists is not None:
            pulumi.set(__self__, "as_lists", as_lists)
        if path_segment_type is not None:
            pulumi.set(__self__, "path_segment_type", path_segment_type)

    @_builtins.property
    @pulumi.getter(name="asLists")
    def as_lists(self) -> Optional[Sequence[_builtins.int]]:
        """
        (Output)
        The AS numbers of the AS Path.
        """
        return pulumi.get(self, "as_lists")

    @_builtins.property
    @pulumi.getter(name="pathSegmentType")
    def path_segment_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The type of the AS Path, which can be one of the following values:
        - 'AS_SET': unordered set of autonomous systems that the route in has traversed
        - 'AS_SEQUENCE': ordered set of autonomous systems that the route has traversed
        - 'AS_CONFED_SEQUENCE': ordered set of Member Autonomous Systems in the local confederation that the route has traversed
        - 'AS_CONFED_SET': unordered set of Member Autonomous Systems in the local confederation that the route has traversed
        """
        return pulumi.get(self, "path_segment_type")


@pulumi.output_type
class RouteParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the route. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456. The field is ignored when empty.
               The field is immutable and causes resource replacement when mutated. This field is only
               set at create time and modifying this field after creation will trigger recreation.
               To apply tags to an existing resource, see the tags.TagBinding resource.
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource manager tags to be bound to the route. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456. The field is ignored when empty.
        The field is immutable and causes resource replacement when mutated. This field is only
        set at create time and modifying this field after creation will trigger recreation.
        To apply tags to an existing resource, see the tags.TagBinding resource.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class RouteWarning(dict):
    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 datas: Optional[Sequence['outputs.RouteWarningData']] = None,
                 message: Optional[_builtins.str] = None):
        """
        :param _builtins.str code: (Output)
               A warning code, if applicable. For example, Compute Engine returns
               NO_RESULTS_ON_PAGE if there are no results in the response.
        :param Sequence['RouteWarningDataArgs'] datas: (Output)
               Metadata about this warning in key: value format. For example:
               "data":   {  "key": "scope",  "value": "zones/us-east1-d"  }
               Structure is [documented below.
        :param _builtins.str message: (Output)
               A human-readable description of the warning code.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if datas is not None:
            pulumi.set(__self__, "datas", datas)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        (Output)
        A warning code, if applicable. For example, Compute Engine returns
        NO_RESULTS_ON_PAGE if there are no results in the response.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def datas(self) -> Optional[Sequence['outputs.RouteWarningData']]:
        """
        (Output)
        Metadata about this warning in key: value format. For example:
        "data":   {  "key": "scope",  "value": "zones/us-east1-d"  }
        Structure is [documented below.
        """
        return pulumi.get(self, "datas")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        (Output)
        A human-readable description of the warning code.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class RouteWarningData(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: (Output)
               A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
        :param _builtins.str value: (Output)
               A warning data value corresponding to the key.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Output)
        A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (Output)
        A warning data value corresponding to the key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RouterBgp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advertiseMode":
            suggest = "advertise_mode"
        elif key == "advertisedGroups":
            suggest = "advertised_groups"
        elif key == "advertisedIpRanges":
            suggest = "advertised_ip_ranges"
        elif key == "identifierRange":
            suggest = "identifier_range"
        elif key == "keepaliveInterval":
            suggest = "keepalive_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouterBgp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouterBgp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouterBgp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: _builtins.int,
                 advertise_mode: Optional[_builtins.str] = None,
                 advertised_groups: Optional[Sequence[_builtins.str]] = None,
                 advertised_ip_ranges: Optional[Sequence['outputs.RouterBgpAdvertisedIpRange']] = None,
                 identifier_range: Optional[_builtins.str] = None,
                 keepalive_interval: Optional[_builtins.int] = None):
        """
        :param _builtins.int asn: Local BGP Autonomous System Number (ASN). Must be an RFC6996
               private ASN, either 16-bit or 32-bit. The value will be fixed for
               this router resource. All VPN tunnels that link to this router
               will have the same local ASN.
        :param _builtins.str advertise_mode: User-specified flag to indicate which mode to use for advertisement.
               Default value is `DEFAULT`.
               Possible values are: `DEFAULT`, `CUSTOM`.
        :param Sequence[_builtins.str] advertised_groups: User-specified list of prefix groups to advertise in custom mode.
               This field can only be populated if advertiseMode is CUSTOM and
               is advertised to all peers of the router. These groups will be
               advertised in addition to any specified prefixes. Leave this field
               blank to advertise no custom groups.
               This enum field has the one valid value: ALL_SUBNETS
        :param Sequence['RouterBgpAdvertisedIpRangeArgs'] advertised_ip_ranges: User-specified list of individual IP ranges to advertise in
               custom mode. This field can only be populated if advertiseMode
               is CUSTOM and is advertised to all peers of the router. These IP
               ranges will be advertised in addition to any specified groups.
               Leave this field blank to advertise no custom IP ranges.
               Structure is documented below.
        :param _builtins.str identifier_range: Explicitly specifies a range of valid BGP Identifiers for this Router.
               It is provided as a link-local IPv4 range (from 169.254.0.0/16), of
               size at least /30, even if the BGP sessions are over IPv6. It must
               not overlap with any IPv4 BGP session ranges. Other vendors commonly
               call this router ID.
        :param _builtins.int keepalive_interval: The interval in seconds between BGP keepalive messages that are sent
               to the peer. Hold time is three times the interval at which keepalive
               messages are sent, and the hold time is the maximum number of seconds
               allowed to elapse between successive keepalive messages that BGP
               receives from a peer.
               BGP will use the smaller of either the local hold time value or the
               peer's hold time value as the hold time for the BGP connection
               between the two peers. If set, this value must be between 20 and 60.
               The default is 20.
        """
        pulumi.set(__self__, "asn", asn)
        if advertise_mode is not None:
            pulumi.set(__self__, "advertise_mode", advertise_mode)
        if advertised_groups is not None:
            pulumi.set(__self__, "advertised_groups", advertised_groups)
        if advertised_ip_ranges is not None:
            pulumi.set(__self__, "advertised_ip_ranges", advertised_ip_ranges)
        if identifier_range is not None:
            pulumi.set(__self__, "identifier_range", identifier_range)
        if keepalive_interval is not None:
            pulumi.set(__self__, "keepalive_interval", keepalive_interval)

    @_builtins.property
    @pulumi.getter
    def asn(self) -> _builtins.int:
        """
        Local BGP Autonomous System Number (ASN). Must be an RFC6996
        private ASN, either 16-bit or 32-bit. The value will be fixed for
        this router resource. All VPN tunnels that link to this router
        will have the same local ASN.
        """
        return pulumi.get(self, "asn")

    @_builtins.property
    @pulumi.getter(name="advertiseMode")
    def advertise_mode(self) -> Optional[_builtins.str]:
        """
        User-specified flag to indicate which mode to use for advertisement.
        Default value is `DEFAULT`.
        Possible values are: `DEFAULT`, `CUSTOM`.
        """
        return pulumi.get(self, "advertise_mode")

    @_builtins.property
    @pulumi.getter(name="advertisedGroups")
    def advertised_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        User-specified list of prefix groups to advertise in custom mode.
        This field can only be populated if advertiseMode is CUSTOM and
        is advertised to all peers of the router. These groups will be
        advertised in addition to any specified prefixes. Leave this field
        blank to advertise no custom groups.
        This enum field has the one valid value: ALL_SUBNETS
        """
        return pulumi.get(self, "advertised_groups")

    @_builtins.property
    @pulumi.getter(name="advertisedIpRanges")
    def advertised_ip_ranges(self) -> Optional[Sequence['outputs.RouterBgpAdvertisedIpRange']]:
        """
        User-specified list of individual IP ranges to advertise in
        custom mode. This field can only be populated if advertiseMode
        is CUSTOM and is advertised to all peers of the router. These IP
        ranges will be advertised in addition to any specified groups.
        Leave this field blank to advertise no custom IP ranges.
        Structure is documented below.
        """
        return pulumi.get(self, "advertised_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="identifierRange")
    def identifier_range(self) -> Optional[_builtins.str]:
        """
        Explicitly specifies a range of valid BGP Identifiers for this Router.
        It is provided as a link-local IPv4 range (from 169.254.0.0/16), of
        size at least /30, even if the BGP sessions are over IPv6. It must
        not overlap with any IPv4 BGP session ranges. Other vendors commonly
        call this router ID.
        """
        return pulumi.get(self, "identifier_range")

    @_builtins.property
    @pulumi.getter(name="keepaliveInterval")
    def keepalive_interval(self) -> Optional[_builtins.int]:
        """
        The interval in seconds between BGP keepalive messages that are sent
        to the peer. Hold time is three times the interval at which keepalive
        messages are sent, and the hold time is the maximum number of seconds
        allowed to elapse between successive keepalive messages that BGP
        receives from a peer.
        BGP will use the smaller of either the local hold time value or the
        peer's hold time value as the hold time for the BGP connection
        between the two peers. If set, this value must be between 20 and 60.
        The default is 20.
        """
        return pulumi.get(self, "keepalive_interval")


@pulumi.output_type
class RouterBgpAdvertisedIpRange(dict):
    def __init__(__self__, *,
                 range: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str range: The IP range to advertise. The value must be a
               CIDR-formatted string.
        :param _builtins.str description: User-specified description for the IP range.
               
               <a name="nested_md5_authentication_keys"></a>The `md5_authentication_keys` block supports:
        """
        pulumi.set(__self__, "range", range)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def range(self) -> _builtins.str:
        """
        The IP range to advertise. The value must be a
        CIDR-formatted string.
        """
        return pulumi.get(self, "range")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        User-specified description for the IP range.

        <a name="nested_md5_authentication_keys"></a>The `md5_authentication_keys` block supports:
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class RouterMd5AuthenticationKeys(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str key: Value of the key used for MD5 authentication.
        :param _builtins.str name: Name of the resource. The name must be 1-63 characters long, and
               comply with RFC1035. Specifically, the name must be 1-63 characters
               long and match the regular expression `a-z?`
               which means the first character must be a lowercase letter, and all
               following characters must be a dash, lowercase letter, or digit,
               except the last character, which cannot be a dash.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Value of the key used for MD5 authentication.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the resource. The name must be 1-63 characters long, and
        comply with RFC1035. Specifically, the name must be 1-63 characters
        long and match the regular expression `a-z?`
        which means the first character must be a lowercase letter, and all
        following characters must be a dash, lowercase letter, or digit,
        except the last character, which cannot be a dash.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RouterNatLogConfig(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool,
                 filter: _builtins.str):
        """
        :param _builtins.bool enable: Indicates whether or not to export logs.
        :param _builtins.str filter: Specifies the desired filtering of logs on this NAT.
               Possible values are: `ERRORS_ONLY`, `TRANSLATIONS_ONLY`, `ALL`.
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Indicates whether or not to export logs.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> _builtins.str:
        """
        Specifies the desired filtering of logs on this NAT.
        Possible values are: `ERRORS_ONLY`, `TRANSLATIONS_ONLY`, `ALL`.
        """
        return pulumi.get(self, "filter")


@pulumi.output_type
class RouterNatNat64Subnetwork(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the NAT service. The name must be 1-63 characters long and
               comply with RFC1035.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the NAT service. The name must be 1-63 characters long and
        comply with RFC1035.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RouterNatRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleNumber":
            suggest = "rule_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouterNatRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouterNatRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouterNatRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match: _builtins.str,
                 rule_number: _builtins.int,
                 action: Optional['outputs.RouterNatRuleAction'] = None,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str match: CEL expression that specifies the match condition that egress traffic from a VM is evaluated against.
               If it evaluates to true, the corresponding action is enforced.
               The following examples are valid match expressions for public NAT:
               "inIpRange(destination.ip, '1.1.0.0/16') || inIpRange(destination.ip, '2.2.0.0/16')"
               "destination.ip == '1.1.0.1' || destination.ip == '8.8.8.8'"
               The following example is a valid match expression for private NAT:
               "nexthop.hub == 'https://networkconnectivity.googleapis.com/v1alpha1/projects/my-project/global/hub/hub-1'"
        :param _builtins.int rule_number: An integer uniquely identifying a rule in the list.
               The rule number must be a positive value between 0 and 65000, and must be unique among rules within a NAT.
        :param 'RouterNatRuleActionArgs' action: The action to be enforced for traffic that matches this rule.
               Structure is documented below.
        :param _builtins.str description: An optional description of this rule.
        """
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "rule_number", rule_number)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        CEL expression that specifies the match condition that egress traffic from a VM is evaluated against.
        If it evaluates to true, the corresponding action is enforced.
        The following examples are valid match expressions for public NAT:
        "inIpRange(destination.ip, '1.1.0.0/16') || inIpRange(destination.ip, '2.2.0.0/16')"
        "destination.ip == '1.1.0.1' || destination.ip == '8.8.8.8'"
        The following example is a valid match expression for private NAT:
        "nexthop.hub == 'https://networkconnectivity.googleapis.com/v1alpha1/projects/my-project/global/hub/hub-1'"
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> _builtins.int:
        """
        An integer uniquely identifying a rule in the list.
        The rule number must be a positive value between 0 and 65000, and must be unique among rules within a NAT.
        """
        return pulumi.get(self, "rule_number")

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional['outputs.RouterNatRuleAction']:
        """
        The action to be enforced for traffic that matches this rule.
        Structure is documented below.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this rule.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class RouterNatRuleAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceNatActiveIps":
            suggest = "source_nat_active_ips"
        elif key == "sourceNatActiveRanges":
            suggest = "source_nat_active_ranges"
        elif key == "sourceNatDrainIps":
            suggest = "source_nat_drain_ips"
        elif key == "sourceNatDrainRanges":
            suggest = "source_nat_drain_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouterNatRuleAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouterNatRuleAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouterNatRuleAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_nat_active_ips: Optional[Sequence[_builtins.str]] = None,
                 source_nat_active_ranges: Optional[Sequence[_builtins.str]] = None,
                 source_nat_drain_ips: Optional[Sequence[_builtins.str]] = None,
                 source_nat_drain_ranges: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] source_nat_active_ips: A list of URLs of the IP resources used for this NAT rule.
               These IP addresses must be valid static external IP addresses assigned to the project.
               This field is used for public NAT.
        :param Sequence[_builtins.str] source_nat_active_ranges: A list of URLs of the subnetworks used as source ranges for this NAT Rule.
               These subnetworks must have purpose set to PRIVATE_NAT.
               This field is used for private NAT.
        :param Sequence[_builtins.str] source_nat_drain_ips: A list of URLs of the IP resources to be drained.
               These IPs must be valid static external IPs that have been assigned to the NAT.
               These IPs should be used for updating/patching a NAT rule only.
               This field is used for public NAT.
        :param Sequence[_builtins.str] source_nat_drain_ranges: A list of URLs of subnetworks representing source ranges to be drained.
               This is only supported on patch/update, and these subnetworks must have previously been used as active ranges in this NAT Rule.
               This field is used for private NAT.
        """
        if source_nat_active_ips is not None:
            pulumi.set(__self__, "source_nat_active_ips", source_nat_active_ips)
        if source_nat_active_ranges is not None:
            pulumi.set(__self__, "source_nat_active_ranges", source_nat_active_ranges)
        if source_nat_drain_ips is not None:
            pulumi.set(__self__, "source_nat_drain_ips", source_nat_drain_ips)
        if source_nat_drain_ranges is not None:
            pulumi.set(__self__, "source_nat_drain_ranges", source_nat_drain_ranges)

    @_builtins.property
    @pulumi.getter(name="sourceNatActiveIps")
    def source_nat_active_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of URLs of the IP resources used for this NAT rule.
        These IP addresses must be valid static external IP addresses assigned to the project.
        This field is used for public NAT.
        """
        return pulumi.get(self, "source_nat_active_ips")

    @_builtins.property
    @pulumi.getter(name="sourceNatActiveRanges")
    def source_nat_active_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of URLs of the subnetworks used as source ranges for this NAT Rule.
        These subnetworks must have purpose set to PRIVATE_NAT.
        This field is used for private NAT.
        """
        return pulumi.get(self, "source_nat_active_ranges")

    @_builtins.property
    @pulumi.getter(name="sourceNatDrainIps")
    def source_nat_drain_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of URLs of the IP resources to be drained.
        These IPs must be valid static external IPs that have been assigned to the NAT.
        These IPs should be used for updating/patching a NAT rule only.
        This field is used for public NAT.
        """
        return pulumi.get(self, "source_nat_drain_ips")

    @_builtins.property
    @pulumi.getter(name="sourceNatDrainRanges")
    def source_nat_drain_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of URLs of subnetworks representing source ranges to be drained.
        This is only supported on patch/update, and these subnetworks must have previously been used as active ranges in this NAT Rule.
        This field is used for private NAT.
        """
        return pulumi.get(self, "source_nat_drain_ranges")


@pulumi.output_type
class RouterNatSubnetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceIpRangesToNats":
            suggest = "source_ip_ranges_to_nats"
        elif key == "secondaryIpRangeNames":
            suggest = "secondary_ip_range_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouterNatSubnetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouterNatSubnetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouterNatSubnetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 source_ip_ranges_to_nats: Sequence[_builtins.str],
                 secondary_ip_range_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: Self-link of the subnetwork resource that will use NAT64
        :param Sequence[_builtins.str] source_ip_ranges_to_nats: List of options for which source IPs in the subnetwork
               should have NAT enabled. Supported values include:
               `ALL_IP_RANGES`, `LIST_OF_SECONDARY_IP_RANGES`,
               `PRIMARY_IP_RANGE`.
        :param Sequence[_builtins.str] secondary_ip_range_names: List of the secondary ranges of the subnetwork that are allowed
               to use NAT. This can be populated only if
               `LIST_OF_SECONDARY_IP_RANGES` is one of the values in
               sourceIpRangesToNat
               
               <a name="nested_nat64_subnetwork"></a>The `nat64_subnetwork` block supports:
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_ip_ranges_to_nats", source_ip_ranges_to_nats)
        if secondary_ip_range_names is not None:
            pulumi.set(__self__, "secondary_ip_range_names", secondary_ip_range_names)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Self-link of the subnetwork resource that will use NAT64
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="sourceIpRangesToNats")
    def source_ip_ranges_to_nats(self) -> Sequence[_builtins.str]:
        """
        List of options for which source IPs in the subnetwork
        should have NAT enabled. Supported values include:
        `ALL_IP_RANGES`, `LIST_OF_SECONDARY_IP_RANGES`,
        `PRIMARY_IP_RANGE`.
        """
        return pulumi.get(self, "source_ip_ranges_to_nats")

    @_builtins.property
    @pulumi.getter(name="secondaryIpRangeNames")
    def secondary_ip_range_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of the secondary ranges of the subnetwork that are allowed
        to use NAT. This can be populated only if
        `LIST_OF_SECONDARY_IP_RANGES` is one of the values in
        sourceIpRangesToNat

        <a name="nested_nat64_subnetwork"></a>The `nat64_subnetwork` block supports:
        """
        return pulumi.get(self, "secondary_ip_range_names")


@pulumi.output_type
class RouterParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouterParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouterParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouterParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the router. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456.
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource manager tags to be bound to the router. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class RouterPeerAdvertisedIpRange(dict):
    def __init__(__self__, *,
                 range: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str range: The IP range to advertise. The value must be a
               CIDR-formatted string.
        :param _builtins.str description: User-specified description for the IP range.
        """
        pulumi.set(__self__, "range", range)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def range(self) -> _builtins.str:
        """
        The IP range to advertise. The value must be a
        CIDR-formatted string.
        """
        return pulumi.get(self, "range")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        User-specified description for the IP range.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class RouterPeerBfd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sessionInitializationMode":
            suggest = "session_initialization_mode"
        elif key == "minReceiveInterval":
            suggest = "min_receive_interval"
        elif key == "minTransmitInterval":
            suggest = "min_transmit_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouterPeerBfd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouterPeerBfd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouterPeerBfd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 session_initialization_mode: _builtins.str,
                 min_receive_interval: Optional[_builtins.int] = None,
                 min_transmit_interval: Optional[_builtins.int] = None,
                 multiplier: Optional[_builtins.int] = None):
        """
        :param _builtins.str session_initialization_mode: The BFD session initialization mode for this BGP peer.
               If set to `ACTIVE`, the Cloud Router will initiate the BFD session
               for this BGP peer. If set to `PASSIVE`, the Cloud Router will wait
               for the peer router to initiate the BFD session for this BGP peer.
               If set to `DISABLED`, BFD is disabled for this BGP peer.
               Possible values are: `ACTIVE`, `DISABLED`, `PASSIVE`.
        :param _builtins.int min_receive_interval: The minimum interval, in milliseconds, between BFD control packets
               received from the peer router. The actual value is negotiated
               between the two routers and is equal to the greater of this value
               and the transmit interval of the other router. If set, this value
               must be between 1000 and 30000.
        :param _builtins.int min_transmit_interval: The minimum interval, in milliseconds, between BFD control packets
               transmitted to the peer router. The actual value is negotiated
               between the two routers and is equal to the greater of this value
               and the corresponding receive interval of the other router. If set,
               this value must be between 1000 and 30000.
        :param _builtins.int multiplier: The number of consecutive BFD packets that must be missed before
               BFD declares that a peer is unavailable. If set, the value must
               be a value between 5 and 16.
               
               <a name="nested_md5_authentication_key"></a>The `md5_authentication_key` block supports:
        """
        pulumi.set(__self__, "session_initialization_mode", session_initialization_mode)
        if min_receive_interval is not None:
            pulumi.set(__self__, "min_receive_interval", min_receive_interval)
        if min_transmit_interval is not None:
            pulumi.set(__self__, "min_transmit_interval", min_transmit_interval)
        if multiplier is not None:
            pulumi.set(__self__, "multiplier", multiplier)

    @_builtins.property
    @pulumi.getter(name="sessionInitializationMode")
    def session_initialization_mode(self) -> _builtins.str:
        """
        The BFD session initialization mode for this BGP peer.
        If set to `ACTIVE`, the Cloud Router will initiate the BFD session
        for this BGP peer. If set to `PASSIVE`, the Cloud Router will wait
        for the peer router to initiate the BFD session for this BGP peer.
        If set to `DISABLED`, BFD is disabled for this BGP peer.
        Possible values are: `ACTIVE`, `DISABLED`, `PASSIVE`.
        """
        return pulumi.get(self, "session_initialization_mode")

    @_builtins.property
    @pulumi.getter(name="minReceiveInterval")
    def min_receive_interval(self) -> Optional[_builtins.int]:
        """
        The minimum interval, in milliseconds, between BFD control packets
        received from the peer router. The actual value is negotiated
        between the two routers and is equal to the greater of this value
        and the transmit interval of the other router. If set, this value
        must be between 1000 and 30000.
        """
        return pulumi.get(self, "min_receive_interval")

    @_builtins.property
    @pulumi.getter(name="minTransmitInterval")
    def min_transmit_interval(self) -> Optional[_builtins.int]:
        """
        The minimum interval, in milliseconds, between BFD control packets
        transmitted to the peer router. The actual value is negotiated
        between the two routers and is equal to the greater of this value
        and the corresponding receive interval of the other router. If set,
        this value must be between 1000 and 30000.
        """
        return pulumi.get(self, "min_transmit_interval")

    @_builtins.property
    @pulumi.getter
    def multiplier(self) -> Optional[_builtins.int]:
        """
        The number of consecutive BFD packets that must be missed before
        BFD declares that a peer is unavailable. If set, the value must
        be a value between 5 and 16.

        <a name="nested_md5_authentication_key"></a>The `md5_authentication_key` block supports:
        """
        return pulumi.get(self, "multiplier")


@pulumi.output_type
class RouterPeerCustomLearnedIpRange(dict):
    def __init__(__self__, *,
                 range: _builtins.str):
        """
        :param _builtins.str range: The IP range to learn. The value must be a
               CIDR-formatted string.
        """
        pulumi.set(__self__, "range", range)

    @_builtins.property
    @pulumi.getter
    def range(self) -> _builtins.str:
        """
        The IP range to learn. The value must be a
        CIDR-formatted string.
        """
        return pulumi.get(self, "range")


@pulumi.output_type
class RouterPeerMd5AuthenticationKey(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str key: Value of the key.
        :param _builtins.str name: Name of this BGP peer. The name must be 1-63 characters long,
               and comply with RFC1035. Specifically, the name must be 1-63 characters
               long and match the regular expression `a-z?` which
               means the first character must be a lowercase letter, and all
               following characters must be a dash, lowercase letter, or digit,
               except the last character, which cannot be a dash.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Value of the key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of this BGP peer. The name must be 1-63 characters long,
        and comply with RFC1035. Specifically, the name must be 1-63 characters
        long and match the regular expression `a-z?` which
        means the first character must be a lowercase letter, and all
        following characters must be a dash, lowercase letter, or digit,
        except the last character, which cannot be a dash.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RouterRoutePolicyTerm(dict):
    def __init__(__self__, *,
                 match: 'outputs.RouterRoutePolicyTermMatch',
                 priority: _builtins.int,
                 actions: Optional[Sequence['outputs.RouterRoutePolicyTermAction']] = None):
        """
        :param 'RouterRoutePolicyTermMatchArgs' match: CEL expression evaluated against a route to determine if this term applies (see Policy Language).
               Structure is documented below.
        :param _builtins.int priority: The evaluation priority for this term, which must be between 0 (inclusive) and 231 (exclusive), and unique within the list.
        :param Sequence['RouterRoutePolicyTermActionArgs'] actions: 'CEL expressions to evaluate to modify a route when this term matches.'\\
               Structure is documented below.
        """
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "priority", priority)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @_builtins.property
    @pulumi.getter
    def match(self) -> 'outputs.RouterRoutePolicyTermMatch':
        """
        CEL expression evaluated against a route to determine if this term applies (see Policy Language).
        Structure is documented below.
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        The evaluation priority for this term, which must be between 0 (inclusive) and 231 (exclusive), and unique within the list.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.RouterRoutePolicyTermAction']]:
        """
        'CEL expressions to evaluate to modify a route when this term matches.'\\
        Structure is documented below.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class RouterRoutePolicyTermAction(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression
               Language syntax.
        :param _builtins.str description: Description of the expression
        :param _builtins.str location: String indicating the location of the expression for error
               reporting, e.g. a file name and a position in the file
        :param _builtins.str title: Title for the expression, i.e. a short string describing its
               purpose.
        """
        pulumi.set(__self__, "expression", expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression
        Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the expression
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        String indicating the location of the expression for error
        reporting, e.g. a file name and a position in the file
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Title for the expression, i.e. a short string describing its
        purpose.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class RouterRoutePolicyTermMatch(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str description: Description of the expression
        :param _builtins.str location: String indicating the location of the expression for error reporting, e.g. a file name and a position in the file
        :param _builtins.str title: Title for the expression, i.e. a short string describing its purpose.
        """
        pulumi.set(__self__, "expression", expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the expression
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        String indicating the location of the expression for error reporting, e.g. a file name and a position in the file
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class RouterStatusBestRouteResult(dict):
    def __init__(__self__, *,
                 as_paths: Sequence['outputs.RouterStatusBestRouteAsPathResult'],
                 creation_timestamp: _builtins.str,
                 description: _builtins.str,
                 dest_range: _builtins.str,
                 name: _builtins.str,
                 network: _builtins.str,
                 next_hop_gateway: _builtins.str,
                 next_hop_hub: _builtins.str,
                 next_hop_ilb: _builtins.str,
                 next_hop_instance: _builtins.str,
                 next_hop_instance_zone: _builtins.str,
                 next_hop_inter_region_cost: _builtins.str,
                 next_hop_ip: _builtins.str,
                 next_hop_med: _builtins.str,
                 next_hop_network: _builtins.str,
                 next_hop_origin: _builtins.str,
                 next_hop_peering: _builtins.str,
                 next_hop_vpn_tunnel: _builtins.str,
                 params: Sequence['outputs.RouterStatusBestRouteParamResult'],
                 priority: _builtins.int,
                 project: _builtins.str,
                 route_status: _builtins.str,
                 route_type: _builtins.str,
                 self_link: _builtins.str,
                 tags: Sequence[_builtins.str],
                 warnings: Sequence['outputs.RouterStatusBestRouteWarningResult']):
        """
        :param _builtins.str creation_timestamp: Creation timestamp in RFC3339 text format.
        :param _builtins.str description: An optional description of this resource. Provide this property
               when you create the resource.
        :param _builtins.str dest_range: The destination range of outgoing packets that this route applies to.
               Only IPv4 is supported.
        :param _builtins.str name: The name of the router.
        :param _builtins.str network: The network name or resource link to the parent
               network of this subnetwork.
        :param _builtins.str next_hop_gateway: URL to a gateway that should handle matching packets.
               Currently, you can only specify the internet gateway, using a full or
               partial valid URL:
               * 'https://www.googleapis.com/compute/v1/projects/project/global/gateways/default-internet-gateway'
               * 'projects/project/global/gateways/default-internet-gateway'
               * 'global/gateways/default-internet-gateway'
               * The string 'default-internet-gateway'.
        :param _builtins.str next_hop_hub: The hub network that should handle matching packets, which should conform to RFC1035.
        :param _builtins.str next_hop_ilb: The IP address or URL to a forwarding rule of type
               loadBalancingScheme=INTERNAL that should handle matching
               packets.
               
               With the GA provider you can only specify the forwarding
               rule as a partial or full URL. For example, the following
               are all valid values:
               * 10.128.0.56
               * https://www.googleapis.com/compute/v1/projects/project/regions/region/forwardingRules/forwardingRule
               * regions/region/forwardingRules/forwardingRule
               
               When the beta provider, you can also specify the IP address
               of a forwarding rule from the same VPC or any peered VPC.
               
               Note that this can only be used when the destinationRange is
               a public (non-RFC 1918) IP CIDR range.
        :param _builtins.str next_hop_instance: URL to an instance that should handle matching packets.
               You can specify this as a full or partial URL. For example:
               * 'https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance'
               * 'projects/project/zones/zone/instances/instance'
               * 'zones/zone/instances/instance'
               * Just the instance name, with the zone in 'next_hop_instance_zone'.
        :param _builtins.str next_hop_instance_zone: The zone of the instance specified in next_hop_instance. Omit if next_hop_instance is specified as a URL.
        :param _builtins.str next_hop_inter_region_cost: Internal fixed region-to-region cost that Google Cloud calculates based on factors such as network performance, distance, and available bandwidth between regions.
        :param _builtins.str next_hop_ip: Network IP address of an instance that should handle matching packets.
        :param _builtins.str next_hop_med: Multi-Exit Discriminator, a BGP route metric that indicates the desirability of a particular route in a network.
        :param _builtins.str next_hop_network: URL to a Network that should handle matching packets.
        :param _builtins.str next_hop_origin: Indicates the origin of the route. Can be IGP (Interior Gateway Protocol), EGP (Exterior Gateway Protocol), or INCOMPLETE.
        :param _builtins.str next_hop_peering: The network peering name that should handle matching packets, which should conform to RFC1035.
        :param _builtins.str next_hop_vpn_tunnel: URL to a VpnTunnel that should handle matching packets.
        :param Sequence['RouterStatusBestRouteParamArgs'] params: Additional params passed with the request, but not persisted as part of resource payload
        :param _builtins.int priority: The priority of this route. Priority is used to break ties in cases
               where there is more than one matching route of equal prefix length.
               
               In the case of two routes with equal prefix length, the one with the
               lowest-numbered priority value wins.
               
               Default value is 1000. Valid range is 0 through 65535.
        :param _builtins.str project: The ID of the project in which the resource
               belongs. If it is not provided, the provider project is used.
        :param _builtins.str route_status: The status of the route, which can be one of the following values:
               - 'ACTIVE' for an active route
               - 'INACTIVE' for an inactive route
        :param _builtins.str route_type: The type of this route, which can be one of the following values:
               - 'TRANSIT' for a transit route that this router learned from another Cloud Router and will readvertise to one of its BGP peers
               - 'SUBNET' for a route from a subnet of the VPC
               - 'BGP' for a route learned from a BGP peer of this router
               - 'STATIC' for a static route
        :param Sequence[_builtins.str] tags: A list of instance tags to which this route applies.
        :param Sequence['RouterStatusBestRouteWarningArgs'] warnings: If potential misconfigurations are detected for this route, this field will be populated with warning messages.
        """
        pulumi.set(__self__, "as_paths", as_paths)
        pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dest_range", dest_range)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "next_hop_gateway", next_hop_gateway)
        pulumi.set(__self__, "next_hop_hub", next_hop_hub)
        pulumi.set(__self__, "next_hop_ilb", next_hop_ilb)
        pulumi.set(__self__, "next_hop_instance", next_hop_instance)
        pulumi.set(__self__, "next_hop_instance_zone", next_hop_instance_zone)
        pulumi.set(__self__, "next_hop_inter_region_cost", next_hop_inter_region_cost)
        pulumi.set(__self__, "next_hop_ip", next_hop_ip)
        pulumi.set(__self__, "next_hop_med", next_hop_med)
        pulumi.set(__self__, "next_hop_network", next_hop_network)
        pulumi.set(__self__, "next_hop_origin", next_hop_origin)
        pulumi.set(__self__, "next_hop_peering", next_hop_peering)
        pulumi.set(__self__, "next_hop_vpn_tunnel", next_hop_vpn_tunnel)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "route_status", route_status)
        pulumi.set(__self__, "route_type", route_type)
        pulumi.set(__self__, "self_link", self_link)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "warnings", warnings)

    @_builtins.property
    @pulumi.getter(name="asPaths")
    def as_paths(self) -> Sequence['outputs.RouterStatusBestRouteAsPathResult']:
        return pulumi.get(self, "as_paths")

    @_builtins.property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> _builtins.str:
        """
        Creation timestamp in RFC3339 text format.
        """
        return pulumi.get(self, "creation_timestamp")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        An optional description of this resource. Provide this property
        when you create the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="destRange")
    def dest_range(self) -> _builtins.str:
        """
        The destination range of outgoing packets that this route applies to.
        Only IPv4 is supported.
        """
        return pulumi.get(self, "dest_range")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the router.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The network name or resource link to the parent
        network of this subnetwork.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="nextHopGateway")
    def next_hop_gateway(self) -> _builtins.str:
        """
        URL to a gateway that should handle matching packets.
        Currently, you can only specify the internet gateway, using a full or
        partial valid URL:
        * 'https://www.googleapis.com/compute/v1/projects/project/global/gateways/default-internet-gateway'
        * 'projects/project/global/gateways/default-internet-gateway'
        * 'global/gateways/default-internet-gateway'
        * The string 'default-internet-gateway'.
        """
        return pulumi.get(self, "next_hop_gateway")

    @_builtins.property
    @pulumi.getter(name="nextHopHub")
    def next_hop_hub(self) -> _builtins.str:
        """
        The hub network that should handle matching packets, which should conform to RFC1035.
        """
        return pulumi.get(self, "next_hop_hub")

    @_builtins.property
    @pulumi.getter(name="nextHopIlb")
    def next_hop_ilb(self) -> _builtins.str:
        """
        The IP address or URL to a forwarding rule of type
        loadBalancingScheme=INTERNAL that should handle matching
        packets.

        With the GA provider you can only specify the forwarding
        rule as a partial or full URL. For example, the following
        are all valid values:
        * 10.128.0.56
        * https://www.googleapis.com/compute/v1/projects/project/regions/region/forwardingRules/forwardingRule
        * regions/region/forwardingRules/forwardingRule

        When the beta provider, you can also specify the IP address
        of a forwarding rule from the same VPC or any peered VPC.

        Note that this can only be used when the destinationRange is
        a public (non-RFC 1918) IP CIDR range.
        """
        return pulumi.get(self, "next_hop_ilb")

    @_builtins.property
    @pulumi.getter(name="nextHopInstance")
    def next_hop_instance(self) -> _builtins.str:
        """
        URL to an instance that should handle matching packets.
        You can specify this as a full or partial URL. For example:
        * 'https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance'
        * 'projects/project/zones/zone/instances/instance'
        * 'zones/zone/instances/instance'
        * Just the instance name, with the zone in 'next_hop_instance_zone'.
        """
        return pulumi.get(self, "next_hop_instance")

    @_builtins.property
    @pulumi.getter(name="nextHopInstanceZone")
    def next_hop_instance_zone(self) -> _builtins.str:
        """
        The zone of the instance specified in next_hop_instance. Omit if next_hop_instance is specified as a URL.
        """
        return pulumi.get(self, "next_hop_instance_zone")

    @_builtins.property
    @pulumi.getter(name="nextHopInterRegionCost")
    def next_hop_inter_region_cost(self) -> _builtins.str:
        """
        Internal fixed region-to-region cost that Google Cloud calculates based on factors such as network performance, distance, and available bandwidth between regions.
        """
        return pulumi.get(self, "next_hop_inter_region_cost")

    @_builtins.property
    @pulumi.getter(name="nextHopIp")
    def next_hop_ip(self) -> _builtins.str:
        """
        Network IP address of an instance that should handle matching packets.
        """
        return pulumi.get(self, "next_hop_ip")

    @_builtins.property
    @pulumi.getter(name="nextHopMed")
    def next_hop_med(self) -> _builtins.str:
        """
        Multi-Exit Discriminator, a BGP route metric that indicates the desirability of a particular route in a network.
        """
        return pulumi.get(self, "next_hop_med")

    @_builtins.property
    @pulumi.getter(name="nextHopNetwork")
    def next_hop_network(self) -> _builtins.str:
        """
        URL to a Network that should handle matching packets.
        """
        return pulumi.get(self, "next_hop_network")

    @_builtins.property
    @pulumi.getter(name="nextHopOrigin")
    def next_hop_origin(self) -> _builtins.str:
        """
        Indicates the origin of the route. Can be IGP (Interior Gateway Protocol), EGP (Exterior Gateway Protocol), or INCOMPLETE.
        """
        return pulumi.get(self, "next_hop_origin")

    @_builtins.property
    @pulumi.getter(name="nextHopPeering")
    def next_hop_peering(self) -> _builtins.str:
        """
        The network peering name that should handle matching packets, which should conform to RFC1035.
        """
        return pulumi.get(self, "next_hop_peering")

    @_builtins.property
    @pulumi.getter(name="nextHopVpnTunnel")
    def next_hop_vpn_tunnel(self) -> _builtins.str:
        """
        URL to a VpnTunnel that should handle matching packets.
        """
        return pulumi.get(self, "next_hop_vpn_tunnel")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Sequence['outputs.RouterStatusBestRouteParamResult']:
        """
        Additional params passed with the request, but not persisted as part of resource payload
        """
        return pulumi.get(self, "params")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        The priority of this route. Priority is used to break ties in cases
        where there is more than one matching route of equal prefix length.

        In the case of two routes with equal prefix length, the one with the
        lowest-numbered priority value wins.

        Default value is 1000. Valid range is 0 through 65535.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        The ID of the project in which the resource
        belongs. If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter(name="routeStatus")
    def route_status(self) -> _builtins.str:
        """
        The status of the route, which can be one of the following values:
        - 'ACTIVE' for an active route
        - 'INACTIVE' for an inactive route
        """
        return pulumi.get(self, "route_status")

    @_builtins.property
    @pulumi.getter(name="routeType")
    def route_type(self) -> _builtins.str:
        """
        The type of this route, which can be one of the following values:
        - 'TRANSIT' for a transit route that this router learned from another Cloud Router and will readvertise to one of its BGP peers
        - 'SUBNET' for a route from a subnet of the VPC
        - 'BGP' for a route learned from a BGP peer of this router
        - 'STATIC' for a static route
        """
        return pulumi.get(self, "route_type")

    @_builtins.property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> _builtins.str:
        return pulumi.get(self, "self_link")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        A list of instance tags to which this route applies.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def warnings(self) -> Sequence['outputs.RouterStatusBestRouteWarningResult']:
        """
        If potential misconfigurations are detected for this route, this field will be populated with warning messages.
        """
        return pulumi.get(self, "warnings")


@pulumi.output_type
class RouterStatusBestRouteAsPathResult(dict):
    def __init__(__self__, *,
                 as_lists: Sequence[_builtins.int],
                 path_segment_type: _builtins.str):
        """
        :param Sequence[_builtins.int] as_lists: The AS numbers of the AS Path.
        :param _builtins.str path_segment_type: The type of the AS Path, which can be one of the following values:
               - 'AS_SET': unordered set of autonomous systems that the route in has traversed
               - 'AS_SEQUENCE': ordered set of autonomous systems that the route has traversed
               - 'AS_CONFED_SEQUENCE': ordered set of Member Autonomous Systems in the local confederation that the route has traversed
               - 'AS_CONFED_SET': unordered set of Member Autonomous Systems in the local confederation that the route has traversed
        """
        pulumi.set(__self__, "as_lists", as_lists)
        pulumi.set(__self__, "path_segment_type", path_segment_type)

    @_builtins.property
    @pulumi.getter(name="asLists")
    def as_lists(self) -> Sequence[_builtins.int]:
        """
        The AS numbers of the AS Path.
        """
        return pulumi.get(self, "as_lists")

    @_builtins.property
    @pulumi.getter(name="pathSegmentType")
    def path_segment_type(self) -> _builtins.str:
        """
        The type of the AS Path, which can be one of the following values:
        - 'AS_SET': unordered set of autonomous systems that the route in has traversed
        - 'AS_SEQUENCE': ordered set of autonomous systems that the route has traversed
        - 'AS_CONFED_SEQUENCE': ordered set of Member Autonomous Systems in the local confederation that the route has traversed
        - 'AS_CONFED_SET': unordered set of Member Autonomous Systems in the local confederation that the route has traversed
        """
        return pulumi.get(self, "path_segment_type")


@pulumi.output_type
class RouterStatusBestRouteParamResult(dict):
    def __init__(__self__, *,
                 resource_manager_tags: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the route. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456. The field is ignored when empty.
               The field is immutable and causes resource replacement when mutated. This field is only
               set at create time and modifying this field after creation will trigger recreation.
               To apply tags to an existing resource, see the tags.TagBinding resource.
        """
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        Resource manager tags to be bound to the route. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456. The field is ignored when empty.
        The field is immutable and causes resource replacement when mutated. This field is only
        set at create time and modifying this field after creation will trigger recreation.
        To apply tags to an existing resource, see the tags.TagBinding resource.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class RouterStatusBestRouteWarningResult(dict):
    def __init__(__self__, *,
                 code: _builtins.str,
                 datas: Sequence['outputs.RouterStatusBestRouteWarningDataResult'],
                 message: _builtins.str):
        """
        :param _builtins.str code: A warning code, if applicable. For example, Compute Engine returns
               NO_RESULTS_ON_PAGE if there are no results in the response.
        :param Sequence['RouterStatusBestRouteWarningDataArgs'] datas: Metadata about this warning in key: value format. For example:
               "data": [  {  "key": "scope",  "value": "zones/us-east1-d"  }
        :param _builtins.str message: A human-readable description of the warning code.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "datas", datas)
        pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        A warning code, if applicable. For example, Compute Engine returns
        NO_RESULTS_ON_PAGE if there are no results in the response.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def datas(self) -> Sequence['outputs.RouterStatusBestRouteWarningDataResult']:
        """
        Metadata about this warning in key: value format. For example:
        "data": [  {  "key": "scope",  "value": "zones/us-east1-d"  }
        """
        return pulumi.get(self, "datas")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        A human-readable description of the warning code.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class RouterStatusBestRouteWarningDataResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
        :param _builtins.str value: A warning data value corresponding to the key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A warning data value corresponding to the key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RouterStatusBestRoutesForRouterResult(dict):
    def __init__(__self__, *,
                 as_paths: Sequence['outputs.RouterStatusBestRoutesForRouterAsPathResult'],
                 creation_timestamp: _builtins.str,
                 description: _builtins.str,
                 dest_range: _builtins.str,
                 name: _builtins.str,
                 network: _builtins.str,
                 next_hop_gateway: _builtins.str,
                 next_hop_hub: _builtins.str,
                 next_hop_ilb: _builtins.str,
                 next_hop_instance: _builtins.str,
                 next_hop_instance_zone: _builtins.str,
                 next_hop_inter_region_cost: _builtins.str,
                 next_hop_ip: _builtins.str,
                 next_hop_med: _builtins.str,
                 next_hop_network: _builtins.str,
                 next_hop_origin: _builtins.str,
                 next_hop_peering: _builtins.str,
                 next_hop_vpn_tunnel: _builtins.str,
                 params: Sequence['outputs.RouterStatusBestRoutesForRouterParamResult'],
                 priority: _builtins.int,
                 project: _builtins.str,
                 route_status: _builtins.str,
                 route_type: _builtins.str,
                 self_link: _builtins.str,
                 tags: Sequence[_builtins.str],
                 warnings: Sequence['outputs.RouterStatusBestRoutesForRouterWarningResult']):
        """
        :param _builtins.str creation_timestamp: Creation timestamp in RFC3339 text format.
        :param _builtins.str description: An optional description of this resource. Provide this property
               when you create the resource.
        :param _builtins.str dest_range: The destination range of outgoing packets that this route applies to.
               Only IPv4 is supported.
        :param _builtins.str name: The name of the router.
        :param _builtins.str network: The network name or resource link to the parent
               network of this subnetwork.
        :param _builtins.str next_hop_gateway: URL to a gateway that should handle matching packets.
               Currently, you can only specify the internet gateway, using a full or
               partial valid URL:
               * 'https://www.googleapis.com/compute/v1/projects/project/global/gateways/default-internet-gateway'
               * 'projects/project/global/gateways/default-internet-gateway'
               * 'global/gateways/default-internet-gateway'
               * The string 'default-internet-gateway'.
        :param _builtins.str next_hop_hub: The hub network that should handle matching packets, which should conform to RFC1035.
        :param _builtins.str next_hop_ilb: The IP address or URL to a forwarding rule of type
               loadBalancingScheme=INTERNAL that should handle matching
               packets.
               
               With the GA provider you can only specify the forwarding
               rule as a partial or full URL. For example, the following
               are all valid values:
               * 10.128.0.56
               * https://www.googleapis.com/compute/v1/projects/project/regions/region/forwardingRules/forwardingRule
               * regions/region/forwardingRules/forwardingRule
               
               When the beta provider, you can also specify the IP address
               of a forwarding rule from the same VPC or any peered VPC.
               
               Note that this can only be used when the destinationRange is
               a public (non-RFC 1918) IP CIDR range.
        :param _builtins.str next_hop_instance: URL to an instance that should handle matching packets.
               You can specify this as a full or partial URL. For example:
               * 'https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance'
               * 'projects/project/zones/zone/instances/instance'
               * 'zones/zone/instances/instance'
               * Just the instance name, with the zone in 'next_hop_instance_zone'.
        :param _builtins.str next_hop_instance_zone: The zone of the instance specified in next_hop_instance. Omit if next_hop_instance is specified as a URL.
        :param _builtins.str next_hop_inter_region_cost: Internal fixed region-to-region cost that Google Cloud calculates based on factors such as network performance, distance, and available bandwidth between regions.
        :param _builtins.str next_hop_ip: Network IP address of an instance that should handle matching packets.
        :param _builtins.str next_hop_med: Multi-Exit Discriminator, a BGP route metric that indicates the desirability of a particular route in a network.
        :param _builtins.str next_hop_network: URL to a Network that should handle matching packets.
        :param _builtins.str next_hop_origin: Indicates the origin of the route. Can be IGP (Interior Gateway Protocol), EGP (Exterior Gateway Protocol), or INCOMPLETE.
        :param _builtins.str next_hop_peering: The network peering name that should handle matching packets, which should conform to RFC1035.
        :param _builtins.str next_hop_vpn_tunnel: URL to a VpnTunnel that should handle matching packets.
        :param Sequence['RouterStatusBestRoutesForRouterParamArgs'] params: Additional params passed with the request, but not persisted as part of resource payload
        :param _builtins.int priority: The priority of this route. Priority is used to break ties in cases
               where there is more than one matching route of equal prefix length.
               
               In the case of two routes with equal prefix length, the one with the
               lowest-numbered priority value wins.
               
               Default value is 1000. Valid range is 0 through 65535.
        :param _builtins.str project: The ID of the project in which the resource
               belongs. If it is not provided, the provider project is used.
        :param _builtins.str route_status: The status of the route, which can be one of the following values:
               - 'ACTIVE' for an active route
               - 'INACTIVE' for an inactive route
        :param _builtins.str route_type: The type of this route, which can be one of the following values:
               - 'TRANSIT' for a transit route that this router learned from another Cloud Router and will readvertise to one of its BGP peers
               - 'SUBNET' for a route from a subnet of the VPC
               - 'BGP' for a route learned from a BGP peer of this router
               - 'STATIC' for a static route
        :param Sequence[_builtins.str] tags: A list of instance tags to which this route applies.
        :param Sequence['RouterStatusBestRoutesForRouterWarningArgs'] warnings: If potential misconfigurations are detected for this route, this field will be populated with warning messages.
        """
        pulumi.set(__self__, "as_paths", as_paths)
        pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dest_range", dest_range)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "next_hop_gateway", next_hop_gateway)
        pulumi.set(__self__, "next_hop_hub", next_hop_hub)
        pulumi.set(__self__, "next_hop_ilb", next_hop_ilb)
        pulumi.set(__self__, "next_hop_instance", next_hop_instance)
        pulumi.set(__self__, "next_hop_instance_zone", next_hop_instance_zone)
        pulumi.set(__self__, "next_hop_inter_region_cost", next_hop_inter_region_cost)
        pulumi.set(__self__, "next_hop_ip", next_hop_ip)
        pulumi.set(__self__, "next_hop_med", next_hop_med)
        pulumi.set(__self__, "next_hop_network", next_hop_network)
        pulumi.set(__self__, "next_hop_origin", next_hop_origin)
        pulumi.set(__self__, "next_hop_peering", next_hop_peering)
        pulumi.set(__self__, "next_hop_vpn_tunnel", next_hop_vpn_tunnel)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "route_status", route_status)
        pulumi.set(__self__, "route_type", route_type)
        pulumi.set(__self__, "self_link", self_link)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "warnings", warnings)

    @_builtins.property
    @pulumi.getter(name="asPaths")
    def as_paths(self) -> Sequence['outputs.RouterStatusBestRoutesForRouterAsPathResult']:
        return pulumi.get(self, "as_paths")

    @_builtins.property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> _builtins.str:
        """
        Creation timestamp in RFC3339 text format.
        """
        return pulumi.get(self, "creation_timestamp")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        An optional description of this resource. Provide this property
        when you create the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="destRange")
    def dest_range(self) -> _builtins.str:
        """
        The destination range of outgoing packets that this route applies to.
        Only IPv4 is supported.
        """
        return pulumi.get(self, "dest_range")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the router.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The network name or resource link to the parent
        network of this subnetwork.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="nextHopGateway")
    def next_hop_gateway(self) -> _builtins.str:
        """
        URL to a gateway that should handle matching packets.
        Currently, you can only specify the internet gateway, using a full or
        partial valid URL:
        * 'https://www.googleapis.com/compute/v1/projects/project/global/gateways/default-internet-gateway'
        * 'projects/project/global/gateways/default-internet-gateway'
        * 'global/gateways/default-internet-gateway'
        * The string 'default-internet-gateway'.
        """
        return pulumi.get(self, "next_hop_gateway")

    @_builtins.property
    @pulumi.getter(name="nextHopHub")
    def next_hop_hub(self) -> _builtins.str:
        """
        The hub network that should handle matching packets, which should conform to RFC1035.
        """
        return pulumi.get(self, "next_hop_hub")

    @_builtins.property
    @pulumi.getter(name="nextHopIlb")
    def next_hop_ilb(self) -> _builtins.str:
        """
        The IP address or URL to a forwarding rule of type
        loadBalancingScheme=INTERNAL that should handle matching
        packets.

        With the GA provider you can only specify the forwarding
        rule as a partial or full URL. For example, the following
        are all valid values:
        * 10.128.0.56
        * https://www.googleapis.com/compute/v1/projects/project/regions/region/forwardingRules/forwardingRule
        * regions/region/forwardingRules/forwardingRule

        When the beta provider, you can also specify the IP address
        of a forwarding rule from the same VPC or any peered VPC.

        Note that this can only be used when the destinationRange is
        a public (non-RFC 1918) IP CIDR range.
        """
        return pulumi.get(self, "next_hop_ilb")

    @_builtins.property
    @pulumi.getter(name="nextHopInstance")
    def next_hop_instance(self) -> _builtins.str:
        """
        URL to an instance that should handle matching packets.
        You can specify this as a full or partial URL. For example:
        * 'https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance'
        * 'projects/project/zones/zone/instances/instance'
        * 'zones/zone/instances/instance'
        * Just the instance name, with the zone in 'next_hop_instance_zone'.
        """
        return pulumi.get(self, "next_hop_instance")

    @_builtins.property
    @pulumi.getter(name="nextHopInstanceZone")
    def next_hop_instance_zone(self) -> _builtins.str:
        """
        The zone of the instance specified in next_hop_instance. Omit if next_hop_instance is specified as a URL.
        """
        return pulumi.get(self, "next_hop_instance_zone")

    @_builtins.property
    @pulumi.getter(name="nextHopInterRegionCost")
    def next_hop_inter_region_cost(self) -> _builtins.str:
        """
        Internal fixed region-to-region cost that Google Cloud calculates based on factors such as network performance, distance, and available bandwidth between regions.
        """
        return pulumi.get(self, "next_hop_inter_region_cost")

    @_builtins.property
    @pulumi.getter(name="nextHopIp")
    def next_hop_ip(self) -> _builtins.str:
        """
        Network IP address of an instance that should handle matching packets.
        """
        return pulumi.get(self, "next_hop_ip")

    @_builtins.property
    @pulumi.getter(name="nextHopMed")
    def next_hop_med(self) -> _builtins.str:
        """
        Multi-Exit Discriminator, a BGP route metric that indicates the desirability of a particular route in a network.
        """
        return pulumi.get(self, "next_hop_med")

    @_builtins.property
    @pulumi.getter(name="nextHopNetwork")
    def next_hop_network(self) -> _builtins.str:
        """
        URL to a Network that should handle matching packets.
        """
        return pulumi.get(self, "next_hop_network")

    @_builtins.property
    @pulumi.getter(name="nextHopOrigin")
    def next_hop_origin(self) -> _builtins.str:
        """
        Indicates the origin of the route. Can be IGP (Interior Gateway Protocol), EGP (Exterior Gateway Protocol), or INCOMPLETE.
        """
        return pulumi.get(self, "next_hop_origin")

    @_builtins.property
    @pulumi.getter(name="nextHopPeering")
    def next_hop_peering(self) -> _builtins.str:
        """
        The network peering name that should handle matching packets, which should conform to RFC1035.
        """
        return pulumi.get(self, "next_hop_peering")

    @_builtins.property
    @pulumi.getter(name="nextHopVpnTunnel")
    def next_hop_vpn_tunnel(self) -> _builtins.str:
        """
        URL to a VpnTunnel that should handle matching packets.
        """
        return pulumi.get(self, "next_hop_vpn_tunnel")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Sequence['outputs.RouterStatusBestRoutesForRouterParamResult']:
        """
        Additional params passed with the request, but not persisted as part of resource payload
        """
        return pulumi.get(self, "params")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        The priority of this route. Priority is used to break ties in cases
        where there is more than one matching route of equal prefix length.

        In the case of two routes with equal prefix length, the one with the
        lowest-numbered priority value wins.

        Default value is 1000. Valid range is 0 through 65535.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        The ID of the project in which the resource
        belongs. If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter(name="routeStatus")
    def route_status(self) -> _builtins.str:
        """
        The status of the route, which can be one of the following values:
        - 'ACTIVE' for an active route
        - 'INACTIVE' for an inactive route
        """
        return pulumi.get(self, "route_status")

    @_builtins.property
    @pulumi.getter(name="routeType")
    def route_type(self) -> _builtins.str:
        """
        The type of this route, which can be one of the following values:
        - 'TRANSIT' for a transit route that this router learned from another Cloud Router and will readvertise to one of its BGP peers
        - 'SUBNET' for a route from a subnet of the VPC
        - 'BGP' for a route learned from a BGP peer of this router
        - 'STATIC' for a static route
        """
        return pulumi.get(self, "route_type")

    @_builtins.property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> _builtins.str:
        return pulumi.get(self, "self_link")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        A list of instance tags to which this route applies.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def warnings(self) -> Sequence['outputs.RouterStatusBestRoutesForRouterWarningResult']:
        """
        If potential misconfigurations are detected for this route, this field will be populated with warning messages.
        """
        return pulumi.get(self, "warnings")


@pulumi.output_type
class RouterStatusBestRoutesForRouterAsPathResult(dict):
    def __init__(__self__, *,
                 as_lists: Sequence[_builtins.int],
                 path_segment_type: _builtins.str):
        """
        :param Sequence[_builtins.int] as_lists: The AS numbers of the AS Path.
        :param _builtins.str path_segment_type: The type of the AS Path, which can be one of the following values:
               - 'AS_SET': unordered set of autonomous systems that the route in has traversed
               - 'AS_SEQUENCE': ordered set of autonomous systems that the route has traversed
               - 'AS_CONFED_SEQUENCE': ordered set of Member Autonomous Systems in the local confederation that the route has traversed
               - 'AS_CONFED_SET': unordered set of Member Autonomous Systems in the local confederation that the route has traversed
        """
        pulumi.set(__self__, "as_lists", as_lists)
        pulumi.set(__self__, "path_segment_type", path_segment_type)

    @_builtins.property
    @pulumi.getter(name="asLists")
    def as_lists(self) -> Sequence[_builtins.int]:
        """
        The AS numbers of the AS Path.
        """
        return pulumi.get(self, "as_lists")

    @_builtins.property
    @pulumi.getter(name="pathSegmentType")
    def path_segment_type(self) -> _builtins.str:
        """
        The type of the AS Path, which can be one of the following values:
        - 'AS_SET': unordered set of autonomous systems that the route in has traversed
        - 'AS_SEQUENCE': ordered set of autonomous systems that the route has traversed
        - 'AS_CONFED_SEQUENCE': ordered set of Member Autonomous Systems in the local confederation that the route has traversed
        - 'AS_CONFED_SET': unordered set of Member Autonomous Systems in the local confederation that the route has traversed
        """
        return pulumi.get(self, "path_segment_type")


@pulumi.output_type
class RouterStatusBestRoutesForRouterParamResult(dict):
    def __init__(__self__, *,
                 resource_manager_tags: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the route. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456. The field is ignored when empty.
               The field is immutable and causes resource replacement when mutated. This field is only
               set at create time and modifying this field after creation will trigger recreation.
               To apply tags to an existing resource, see the tags.TagBinding resource.
        """
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        Resource manager tags to be bound to the route. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456. The field is ignored when empty.
        The field is immutable and causes resource replacement when mutated. This field is only
        set at create time and modifying this field after creation will trigger recreation.
        To apply tags to an existing resource, see the tags.TagBinding resource.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class RouterStatusBestRoutesForRouterWarningResult(dict):
    def __init__(__self__, *,
                 code: _builtins.str,
                 datas: Sequence['outputs.RouterStatusBestRoutesForRouterWarningDataResult'],
                 message: _builtins.str):
        """
        :param _builtins.str code: A warning code, if applicable. For example, Compute Engine returns
               NO_RESULTS_ON_PAGE if there are no results in the response.
        :param Sequence['RouterStatusBestRoutesForRouterWarningDataArgs'] datas: Metadata about this warning in key: value format. For example:
               "data": [  {  "key": "scope",  "value": "zones/us-east1-d"  }
        :param _builtins.str message: A human-readable description of the warning code.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "datas", datas)
        pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        A warning code, if applicable. For example, Compute Engine returns
        NO_RESULTS_ON_PAGE if there are no results in the response.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def datas(self) -> Sequence['outputs.RouterStatusBestRoutesForRouterWarningDataResult']:
        """
        Metadata about this warning in key: value format. For example:
        "data": [  {  "key": "scope",  "value": "zones/us-east1-d"  }
        """
        return pulumi.get(self, "datas")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        A human-readable description of the warning code.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class RouterStatusBestRoutesForRouterWarningDataResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
        :param _builtins.str value: A warning data value corresponding to the key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A warning data value corresponding to the key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SecurityPolicyAdaptiveProtectionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDeployConfig":
            suggest = "auto_deploy_config"
        elif key == "layer7DdosDefenseConfig":
            suggest = "layer7_ddos_defense_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyAdaptiveProtectionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyAdaptiveProtectionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyAdaptiveProtectionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_deploy_config: Optional['outputs.SecurityPolicyAdaptiveProtectionConfigAutoDeployConfig'] = None,
                 layer7_ddos_defense_config: Optional['outputs.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig'] = None):
        """
        :param 'SecurityPolicyAdaptiveProtectionConfigAutoDeployConfigArgs' auto_deploy_config: Configuration for [Automatically deploy Adaptive Protection suggested rules](https://cloud.google.com/armor/docs/adaptive-protection-auto-deploy?hl=en). Structure is documented below.
               
               <a name="nested_layer_7_ddos_defense_config"></a>The `layer_7_ddos_defense_config` block supports:
        :param 'SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigArgs' layer7_ddos_defense_config: Configuration for [Google Cloud Armor Adaptive Protection Layer 7 DDoS Defense](https://cloud.google.com/armor/docs/adaptive-protection-overview?hl=en). Structure is documented below.
        """
        if auto_deploy_config is not None:
            pulumi.set(__self__, "auto_deploy_config", auto_deploy_config)
        if layer7_ddos_defense_config is not None:
            pulumi.set(__self__, "layer7_ddos_defense_config", layer7_ddos_defense_config)

    @_builtins.property
    @pulumi.getter(name="autoDeployConfig")
    def auto_deploy_config(self) -> Optional['outputs.SecurityPolicyAdaptiveProtectionConfigAutoDeployConfig']:
        """
        Configuration for [Automatically deploy Adaptive Protection suggested rules](https://cloud.google.com/armor/docs/adaptive-protection-auto-deploy?hl=en). Structure is documented below.

        <a name="nested_layer_7_ddos_defense_config"></a>The `layer_7_ddos_defense_config` block supports:
        """
        return pulumi.get(self, "auto_deploy_config")

    @_builtins.property
    @pulumi.getter(name="layer7DdosDefenseConfig")
    def layer7_ddos_defense_config(self) -> Optional['outputs.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig']:
        """
        Configuration for [Google Cloud Armor Adaptive Protection Layer 7 DDoS Defense](https://cloud.google.com/armor/docs/adaptive-protection-overview?hl=en). Structure is documented below.
        """
        return pulumi.get(self, "layer7_ddos_defense_config")


@pulumi.output_type
class SecurityPolicyAdaptiveProtectionConfigAutoDeployConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confidenceThreshold":
            suggest = "confidence_threshold"
        elif key == "expirationSec":
            suggest = "expiration_sec"
        elif key == "impactedBaselineThreshold":
            suggest = "impacted_baseline_threshold"
        elif key == "loadThreshold":
            suggest = "load_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyAdaptiveProtectionConfigAutoDeployConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyAdaptiveProtectionConfigAutoDeployConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyAdaptiveProtectionConfigAutoDeployConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 confidence_threshold: Optional[_builtins.float] = None,
                 expiration_sec: Optional[_builtins.int] = None,
                 impacted_baseline_threshold: Optional[_builtins.float] = None,
                 load_threshold: Optional[_builtins.float] = None):
        """
        :param _builtins.float confidence_threshold: Rules are only automatically deployed for alerts on potential attacks with confidence scores greater than this threshold.
        :param _builtins.int expiration_sec: Google Cloud Armor stops applying the action in the automatically deployed rule to an identified attacker after this duration. The rule continues to operate against new requests.
        :param _builtins.float impacted_baseline_threshold: Rules are only automatically deployed when the estimated impact to baseline traffic from the suggested mitigation is below this threshold.
        :param _builtins.float load_threshold: Identifies new attackers only when the load to the backend service that is under attack exceeds this threshold.
        """
        if confidence_threshold is not None:
            pulumi.set(__self__, "confidence_threshold", confidence_threshold)
        if expiration_sec is not None:
            pulumi.set(__self__, "expiration_sec", expiration_sec)
        if impacted_baseline_threshold is not None:
            pulumi.set(__self__, "impacted_baseline_threshold", impacted_baseline_threshold)
        if load_threshold is not None:
            pulumi.set(__self__, "load_threshold", load_threshold)

    @_builtins.property
    @pulumi.getter(name="confidenceThreshold")
    def confidence_threshold(self) -> Optional[_builtins.float]:
        """
        Rules are only automatically deployed for alerts on potential attacks with confidence scores greater than this threshold.
        """
        return pulumi.get(self, "confidence_threshold")

    @_builtins.property
    @pulumi.getter(name="expirationSec")
    def expiration_sec(self) -> Optional[_builtins.int]:
        """
        Google Cloud Armor stops applying the action in the automatically deployed rule to an identified attacker after this duration. The rule continues to operate against new requests.
        """
        return pulumi.get(self, "expiration_sec")

    @_builtins.property
    @pulumi.getter(name="impactedBaselineThreshold")
    def impacted_baseline_threshold(self) -> Optional[_builtins.float]:
        """
        Rules are only automatically deployed when the estimated impact to baseline traffic from the suggested mitigation is below this threshold.
        """
        return pulumi.get(self, "impacted_baseline_threshold")

    @_builtins.property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[_builtins.float]:
        """
        Identifies new attackers only when the load to the backend service that is under attack exceeds this threshold.
        """
        return pulumi.get(self, "load_threshold")


@pulumi.output_type
class SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleVisibility":
            suggest = "rule_visibility"
        elif key == "thresholdConfigs":
            suggest = "threshold_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None,
                 rule_visibility: Optional[_builtins.str] = None,
                 threshold_configs: Optional[Sequence['outputs.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig']] = None):
        """
        :param _builtins.bool enable: If set to true, enables CAAP for L7 DDoS detection.
        :param _builtins.str rule_visibility: Rule visibility. Supported values include: "STANDARD", "PREMIUM".
        :param Sequence['SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigArgs'] threshold_configs: Configuration options for layer7 adaptive protection for various customizable thresholds.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if rule_visibility is not None:
            pulumi.set(__self__, "rule_visibility", rule_visibility)
        if threshold_configs is not None:
            pulumi.set(__self__, "threshold_configs", threshold_configs)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        If set to true, enables CAAP for L7 DDoS detection.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="ruleVisibility")
    def rule_visibility(self) -> Optional[_builtins.str]:
        """
        Rule visibility. Supported values include: "STANDARD", "PREMIUM".
        """
        return pulumi.get(self, "rule_visibility")

    @_builtins.property
    @pulumi.getter(name="thresholdConfigs")
    def threshold_configs(self) -> Optional[Sequence['outputs.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig']]:
        """
        Configuration options for layer7 adaptive protection for various customizable thresholds.
        """
        return pulumi.get(self, "threshold_configs")


@pulumi.output_type
class SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDeployConfidenceThreshold":
            suggest = "auto_deploy_confidence_threshold"
        elif key == "autoDeployExpirationSec":
            suggest = "auto_deploy_expiration_sec"
        elif key == "autoDeployImpactedBaselineThreshold":
            suggest = "auto_deploy_impacted_baseline_threshold"
        elif key == "autoDeployLoadThreshold":
            suggest = "auto_deploy_load_threshold"
        elif key == "detectionAbsoluteQps":
            suggest = "detection_absolute_qps"
        elif key == "detectionLoadThreshold":
            suggest = "detection_load_threshold"
        elif key == "detectionRelativeToBaselineQps":
            suggest = "detection_relative_to_baseline_qps"
        elif key == "trafficGranularityConfigs":
            suggest = "traffic_granularity_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 auto_deploy_confidence_threshold: Optional[_builtins.float] = None,
                 auto_deploy_expiration_sec: Optional[_builtins.int] = None,
                 auto_deploy_impacted_baseline_threshold: Optional[_builtins.float] = None,
                 auto_deploy_load_threshold: Optional[_builtins.float] = None,
                 detection_absolute_qps: Optional[_builtins.float] = None,
                 detection_load_threshold: Optional[_builtins.float] = None,
                 detection_relative_to_baseline_qps: Optional[_builtins.float] = None,
                 traffic_granularity_configs: Optional[Sequence['outputs.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig']] = None):
        """
        :param _builtins.str name: The name of config. The name must be 1-63 characters long, and comply with RFC1035. The name must be unique within the security policy.
        :param _builtins.float auto_deploy_confidence_threshold: Confidence threshold above which Adaptive Protection's auto-deploy takes actions.
        :param _builtins.int auto_deploy_expiration_sec: Duration over which Adaptive Protection's auto-deployed actions last.
        :param _builtins.float auto_deploy_impacted_baseline_threshold: Impacted baseline threshold below which Adaptive Protection's auto-deploy takes actions.
        :param _builtins.float auto_deploy_load_threshold: Load threshold above which Adaptive Protection automatically deploy threshold based on the backend load threshold and detect a new rule during an alerted attack.
        :param _builtins.float detection_absolute_qps: Detection threshold based on absolute QPS.
        :param _builtins.float detection_load_threshold: Detection threshold based on the backend service's load.
        :param _builtins.float detection_relative_to_baseline_qps: Detection threshold based on QPS relative to the average of baseline traffic.
        :param Sequence['SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfigArgs'] traffic_granularity_configs: Configuration options for enabling Adaptive Protection to work on the specified service granularity. Structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        if auto_deploy_confidence_threshold is not None:
            pulumi.set(__self__, "auto_deploy_confidence_threshold", auto_deploy_confidence_threshold)
        if auto_deploy_expiration_sec is not None:
            pulumi.set(__self__, "auto_deploy_expiration_sec", auto_deploy_expiration_sec)
        if auto_deploy_impacted_baseline_threshold is not None:
            pulumi.set(__self__, "auto_deploy_impacted_baseline_threshold", auto_deploy_impacted_baseline_threshold)
        if auto_deploy_load_threshold is not None:
            pulumi.set(__self__, "auto_deploy_load_threshold", auto_deploy_load_threshold)
        if detection_absolute_qps is not None:
            pulumi.set(__self__, "detection_absolute_qps", detection_absolute_qps)
        if detection_load_threshold is not None:
            pulumi.set(__self__, "detection_load_threshold", detection_load_threshold)
        if detection_relative_to_baseline_qps is not None:
            pulumi.set(__self__, "detection_relative_to_baseline_qps", detection_relative_to_baseline_qps)
        if traffic_granularity_configs is not None:
            pulumi.set(__self__, "traffic_granularity_configs", traffic_granularity_configs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of config. The name must be 1-63 characters long, and comply with RFC1035. The name must be unique within the security policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="autoDeployConfidenceThreshold")
    def auto_deploy_confidence_threshold(self) -> Optional[_builtins.float]:
        """
        Confidence threshold above which Adaptive Protection's auto-deploy takes actions.
        """
        return pulumi.get(self, "auto_deploy_confidence_threshold")

    @_builtins.property
    @pulumi.getter(name="autoDeployExpirationSec")
    def auto_deploy_expiration_sec(self) -> Optional[_builtins.int]:
        """
        Duration over which Adaptive Protection's auto-deployed actions last.
        """
        return pulumi.get(self, "auto_deploy_expiration_sec")

    @_builtins.property
    @pulumi.getter(name="autoDeployImpactedBaselineThreshold")
    def auto_deploy_impacted_baseline_threshold(self) -> Optional[_builtins.float]:
        """
        Impacted baseline threshold below which Adaptive Protection's auto-deploy takes actions.
        """
        return pulumi.get(self, "auto_deploy_impacted_baseline_threshold")

    @_builtins.property
    @pulumi.getter(name="autoDeployLoadThreshold")
    def auto_deploy_load_threshold(self) -> Optional[_builtins.float]:
        """
        Load threshold above which Adaptive Protection automatically deploy threshold based on the backend load threshold and detect a new rule during an alerted attack.
        """
        return pulumi.get(self, "auto_deploy_load_threshold")

    @_builtins.property
    @pulumi.getter(name="detectionAbsoluteQps")
    def detection_absolute_qps(self) -> Optional[_builtins.float]:
        """
        Detection threshold based on absolute QPS.
        """
        return pulumi.get(self, "detection_absolute_qps")

    @_builtins.property
    @pulumi.getter(name="detectionLoadThreshold")
    def detection_load_threshold(self) -> Optional[_builtins.float]:
        """
        Detection threshold based on the backend service's load.
        """
        return pulumi.get(self, "detection_load_threshold")

    @_builtins.property
    @pulumi.getter(name="detectionRelativeToBaselineQps")
    def detection_relative_to_baseline_qps(self) -> Optional[_builtins.float]:
        """
        Detection threshold based on QPS relative to the average of baseline traffic.
        """
        return pulumi.get(self, "detection_relative_to_baseline_qps")

    @_builtins.property
    @pulumi.getter(name="trafficGranularityConfigs")
    def traffic_granularity_configs(self) -> Optional[Sequence['outputs.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig']]:
        """
        Configuration options for enabling Adaptive Protection to work on the specified service granularity. Structure is documented below.
        """
        return pulumi.get(self, "traffic_granularity_configs")


@pulumi.output_type
class SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableEachUniqueValue":
            suggest = "enable_each_unique_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 enable_each_unique_value: Optional[_builtins.bool] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of this configuration, a granular traffic unit can be one of the following:
               * `HTTP_HEADER_HOST`
               * `HTTP_PATH`
        :param _builtins.bool enable_each_unique_value: If enabled, traffic matching each unique value for the specified type constitutes a separate traffic unit. It can only be set to true if value is empty.
        :param _builtins.str value: Requests that match this value constitute a granular traffic unit.
        """
        pulumi.set(__self__, "type", type)
        if enable_each_unique_value is not None:
            pulumi.set(__self__, "enable_each_unique_value", enable_each_unique_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of this configuration, a granular traffic unit can be one of the following:
        * `HTTP_HEADER_HOST`
        * `HTTP_PATH`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="enableEachUniqueValue")
    def enable_each_unique_value(self) -> Optional[_builtins.bool]:
        """
        If enabled, traffic matching each unique value for the specified type constitutes a separate traffic unit. It can only be set to true if value is empty.
        """
        return pulumi.get(self, "enable_each_unique_value")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Requests that match this value constitute a granular traffic unit.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SecurityPolicyAdvancedOptionsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonCustomConfig":
            suggest = "json_custom_config"
        elif key == "jsonParsing":
            suggest = "json_parsing"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "requestBodyInspectionSize":
            suggest = "request_body_inspection_size"
        elif key == "userIpRequestHeaders":
            suggest = "user_ip_request_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyAdvancedOptionsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyAdvancedOptionsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyAdvancedOptionsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 json_custom_config: Optional['outputs.SecurityPolicyAdvancedOptionsConfigJsonCustomConfig'] = None,
                 json_parsing: Optional[_builtins.str] = None,
                 log_level: Optional[_builtins.str] = None,
                 request_body_inspection_size: Optional[_builtins.str] = None,
                 user_ip_request_headers: Optional[Sequence[_builtins.str]] = None):
        """
        :param 'SecurityPolicyAdvancedOptionsConfigJsonCustomConfigArgs' json_custom_config: Custom configuration to apply the JSON parsing. Only applicable when
               `json_parsing` is set to `STANDARD`. Structure is documented below.
        :param _builtins.str json_parsing: Whether or not to JSON parse the payload body. Defaults to `DISABLED`.
               * `DISABLED` - Don't parse JSON payloads in POST bodies.
               * `STANDARD` - Parse JSON payloads in POST bodies.
               * `STANDARD_WITH_GRAPHQL` - Parse JSON and GraphQL payloads in POST bodies.
        :param _builtins.str log_level: Log level to use. Defaults to `NORMAL`.
               * `NORMAL` - Normal log level.
               * `VERBOSE` - Verbose log level.
        :param _builtins.str request_body_inspection_size: The maximum request size chosen by the customer with Waf enabled. Values supported are "8KB", "16KB, "32KB", "48KB" and "64KB". Values are case insensitive.
        :param Sequence[_builtins.str] user_ip_request_headers: An optional list of case-insensitive request header names to use for resolving the callers client IP address.
        """
        if json_custom_config is not None:
            pulumi.set(__self__, "json_custom_config", json_custom_config)
        if json_parsing is not None:
            pulumi.set(__self__, "json_parsing", json_parsing)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if request_body_inspection_size is not None:
            pulumi.set(__self__, "request_body_inspection_size", request_body_inspection_size)
        if user_ip_request_headers is not None:
            pulumi.set(__self__, "user_ip_request_headers", user_ip_request_headers)

    @_builtins.property
    @pulumi.getter(name="jsonCustomConfig")
    def json_custom_config(self) -> Optional['outputs.SecurityPolicyAdvancedOptionsConfigJsonCustomConfig']:
        """
        Custom configuration to apply the JSON parsing. Only applicable when
        `json_parsing` is set to `STANDARD`. Structure is documented below.
        """
        return pulumi.get(self, "json_custom_config")

    @_builtins.property
    @pulumi.getter(name="jsonParsing")
    def json_parsing(self) -> Optional[_builtins.str]:
        """
        Whether or not to JSON parse the payload body. Defaults to `DISABLED`.
        * `DISABLED` - Don't parse JSON payloads in POST bodies.
        * `STANDARD` - Parse JSON payloads in POST bodies.
        * `STANDARD_WITH_GRAPHQL` - Parse JSON and GraphQL payloads in POST bodies.
        """
        return pulumi.get(self, "json_parsing")

    @_builtins.property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[_builtins.str]:
        """
        Log level to use. Defaults to `NORMAL`.
        * `NORMAL` - Normal log level.
        * `VERBOSE` - Verbose log level.
        """
        return pulumi.get(self, "log_level")

    @_builtins.property
    @pulumi.getter(name="requestBodyInspectionSize")
    def request_body_inspection_size(self) -> Optional[_builtins.str]:
        """
        The maximum request size chosen by the customer with Waf enabled. Values supported are "8KB", "16KB, "32KB", "48KB" and "64KB". Values are case insensitive.
        """
        return pulumi.get(self, "request_body_inspection_size")

    @_builtins.property
    @pulumi.getter(name="userIpRequestHeaders")
    def user_ip_request_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        An optional list of case-insensitive request header names to use for resolving the callers client IP address.
        """
        return pulumi.get(self, "user_ip_request_headers")


@pulumi.output_type
class SecurityPolicyAdvancedOptionsConfigJsonCustomConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentTypes":
            suggest = "content_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyAdvancedOptionsConfigJsonCustomConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyAdvancedOptionsConfigJsonCustomConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyAdvancedOptionsConfigJsonCustomConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_types: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] content_types: A list of custom Content-Type header values to apply the JSON parsing. The
               format of the Content-Type header values is defined in
               [RFC 1341](https://www.ietf.org/rfc/rfc1341.txt). When configuring a custom Content-Type header
               value, only the type/subtype needs to be specified, and the parameters should be excluded.
        """
        pulumi.set(__self__, "content_types", content_types)

    @_builtins.property
    @pulumi.getter(name="contentTypes")
    def content_types(self) -> Sequence[_builtins.str]:
        """
        A list of custom Content-Type header values to apply the JSON parsing. The
        format of the Content-Type header values is defined in
        [RFC 1341](https://www.ietf.org/rfc/rfc1341.txt). When configuring a custom Content-Type header
        value, only the type/subtype needs to be specified, and the parameters should be excluded.
        """
        return pulumi.get(self, "content_types")


@pulumi.output_type
class SecurityPolicyRecaptchaOptionsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectSiteKey":
            suggest = "redirect_site_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyRecaptchaOptionsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyRecaptchaOptionsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyRecaptchaOptionsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_site_key: _builtins.str):
        """
        :param _builtins.str redirect_site_key: A field to supply a reCAPTCHA site key to be used for all the rules using the redirect action with the type of `GOOGLE_RECAPTCHA` under the security policy. The specified site key needs to be created from the reCAPTCHA API. The user is responsible for the validity of the specified site key. If not specified, a Google-managed site key is used.
        """
        pulumi.set(__self__, "redirect_site_key", redirect_site_key)

    @_builtins.property
    @pulumi.getter(name="redirectSiteKey")
    def redirect_site_key(self) -> _builtins.str:
        """
        A field to supply a reCAPTCHA site key to be used for all the rules using the redirect action with the type of `GOOGLE_RECAPTCHA` under the security policy. The specified site key needs to be created from the reCAPTCHA API. The user is responsible for the validity of the specified site key. If not specified, a Google-managed site key is used.
        """
        return pulumi.get(self, "redirect_site_key")


@pulumi.output_type
class SecurityPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerAction":
            suggest = "header_action"
        elif key == "preconfiguredWafConfig":
            suggest = "preconfigured_waf_config"
        elif key == "rateLimitOptions":
            suggest = "rate_limit_options"
        elif key == "redirectOptions":
            suggest = "redirect_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 match: 'outputs.SecurityPolicyRuleMatch',
                 priority: _builtins.int,
                 description: Optional[_builtins.str] = None,
                 header_action: Optional['outputs.SecurityPolicyRuleHeaderAction'] = None,
                 preconfigured_waf_config: Optional['outputs.SecurityPolicyRulePreconfiguredWafConfig'] = None,
                 preview: Optional[_builtins.bool] = None,
                 rate_limit_options: Optional['outputs.SecurityPolicyRuleRateLimitOptions'] = None,
                 redirect_options: Optional['outputs.SecurityPolicyRuleRedirectOptions'] = None):
        """
        :param _builtins.str action: Action to take when `match` matches the request. Valid values:
        :param 'SecurityPolicyRuleMatchArgs' match: A match condition that incoming traffic is evaluated against.
               If it evaluates to true, the corresponding `action` is enforced. Structure is documented below.
        :param _builtins.int priority: An unique positive integer indicating the priority of evaluation for a rule.
               Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
        :param _builtins.str description: An optional description of this rule. Max size is 64.
        :param 'SecurityPolicyRuleHeaderActionArgs' header_action: Additional actions that are performed on headers. Structure is documented below.
        :param 'SecurityPolicyRulePreconfiguredWafConfigArgs' preconfigured_waf_config: Preconfigured WAF configuration to be applied for the rule. If the rule does not evaluate preconfigured WAF rules, i.e., if `evaluatePreconfiguredWaf()` is not used, this field will have no effect. Structure is documented below.
        :param _builtins.bool preview: When set to true, the `action` specified above is not enforced.
               Stackdriver logs for requests that trigger a preview action are annotated as such.
        :param 'SecurityPolicyRuleRateLimitOptionsArgs' rate_limit_options: Must be specified if the `action` is `rate_based_ban` or `throttle`. Cannot be specified for other actions. Structure is documented below.
        :param 'SecurityPolicyRuleRedirectOptionsArgs' redirect_options: Can be specified if the `action` is `redirect`. Cannot be specified for other actions. Structure is documented below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "priority", priority)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)
        if preconfigured_waf_config is not None:
            pulumi.set(__self__, "preconfigured_waf_config", preconfigured_waf_config)
        if preview is not None:
            pulumi.set(__self__, "preview", preview)
        if rate_limit_options is not None:
            pulumi.set(__self__, "rate_limit_options", rate_limit_options)
        if redirect_options is not None:
            pulumi.set(__self__, "redirect_options", redirect_options)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Action to take when `match` matches the request. Valid values:
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def match(self) -> 'outputs.SecurityPolicyRuleMatch':
        """
        A match condition that incoming traffic is evaluated against.
        If it evaluates to true, the corresponding `action` is enforced. Structure is documented below.
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        An unique positive integer indicating the priority of evaluation for a rule.
        Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this rule. Max size is 64.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.SecurityPolicyRuleHeaderAction']:
        """
        Additional actions that are performed on headers. Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    @_builtins.property
    @pulumi.getter(name="preconfiguredWafConfig")
    def preconfigured_waf_config(self) -> Optional['outputs.SecurityPolicyRulePreconfiguredWafConfig']:
        """
        Preconfigured WAF configuration to be applied for the rule. If the rule does not evaluate preconfigured WAF rules, i.e., if `evaluatePreconfiguredWaf()` is not used, this field will have no effect. Structure is documented below.
        """
        return pulumi.get(self, "preconfigured_waf_config")

    @_builtins.property
    @pulumi.getter
    def preview(self) -> Optional[_builtins.bool]:
        """
        When set to true, the `action` specified above is not enforced.
        Stackdriver logs for requests that trigger a preview action are annotated as such.
        """
        return pulumi.get(self, "preview")

    @_builtins.property
    @pulumi.getter(name="rateLimitOptions")
    def rate_limit_options(self) -> Optional['outputs.SecurityPolicyRuleRateLimitOptions']:
        """
        Must be specified if the `action` is `rate_based_ban` or `throttle`. Cannot be specified for other actions. Structure is documented below.
        """
        return pulumi.get(self, "rate_limit_options")

    @_builtins.property
    @pulumi.getter(name="redirectOptions")
    def redirect_options(self) -> Optional['outputs.SecurityPolicyRuleRedirectOptions']:
        """
        Can be specified if the `action` is `redirect`. Cannot be specified for other actions. Structure is documented below.
        """
        return pulumi.get(self, "redirect_options")


@pulumi.output_type
class SecurityPolicyRuleHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyRuleHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyRuleHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyRuleHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.SecurityPolicyRuleHeaderActionRequestHeadersToAdd']] = None):
        """
        :param Sequence['SecurityPolicyRuleHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: The list of request headers to add or overwrite if they're already present.
               Structure is documented below.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.SecurityPolicyRuleHeaderActionRequestHeadersToAdd']]:
        """
        The list of request headers to add or overwrite if they're already present.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")


@pulumi.output_type
class SecurityPolicyRuleHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyRuleHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyRuleHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyRuleHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[_builtins.str] = None,
                 header_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str header_name: The name of the header to set.
        :param _builtins.str header_value: The value to set the named header to.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header to set.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The value to set the named header to.
        """
        return pulumi.get(self, "header_value")


@pulumi.output_type
class SecurityPolicyRuleMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exprOptions":
            suggest = "expr_options"
        elif key == "versionedExpr":
            suggest = "versioned_expr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyRuleMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyRuleMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyRuleMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config: Optional['outputs.SecurityPolicyRuleMatchConfig'] = None,
                 expr: Optional['outputs.SecurityPolicyRuleMatchExpr'] = None,
                 expr_options: Optional['outputs.SecurityPolicyRuleMatchExprOptions'] = None,
                 versioned_expr: Optional[_builtins.str] = None):
        """
        :param 'SecurityPolicyRuleMatchConfigArgs' config: The configuration options available when specifying versionedExpr.
               This field must be specified if versionedExpr is specified and cannot be specified if versionedExpr is not specified.
               Structure is documented below.
        :param 'SecurityPolicyRuleMatchExprArgs' expr: User defined CEVAL expression. A CEVAL expression is used to specify match criteria such as origin.ip, source.region_code and contents in the request header.
               Structure is documented below.
        :param 'SecurityPolicyRuleMatchExprOptionsArgs' expr_options: The configuration options available when specifying a user defined CEVAL expression (i.e., 'expr').
               Structure is documented below.
        :param _builtins.str versioned_expr: Preconfigured versioned expression. If this field is specified, config must also be specified.
               Available preconfigured expressions along with their requirements are: SRC_IPS_V1 - must specify the corresponding srcIpRange field in config.
               Possible values are: `SRC_IPS_V1`.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if expr_options is not None:
            pulumi.set(__self__, "expr_options", expr_options)
        if versioned_expr is not None:
            pulumi.set(__self__, "versioned_expr", versioned_expr)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional['outputs.SecurityPolicyRuleMatchConfig']:
        """
        The configuration options available when specifying versionedExpr.
        This field must be specified if versionedExpr is specified and cannot be specified if versionedExpr is not specified.
        Structure is documented below.
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def expr(self) -> Optional['outputs.SecurityPolicyRuleMatchExpr']:
        """
        User defined CEVAL expression. A CEVAL expression is used to specify match criteria such as origin.ip, source.region_code and contents in the request header.
        Structure is documented below.
        """
        return pulumi.get(self, "expr")

    @_builtins.property
    @pulumi.getter(name="exprOptions")
    def expr_options(self) -> Optional['outputs.SecurityPolicyRuleMatchExprOptions']:
        """
        The configuration options available when specifying a user defined CEVAL expression (i.e., 'expr').
        Structure is documented below.
        """
        return pulumi.get(self, "expr_options")

    @_builtins.property
    @pulumi.getter(name="versionedExpr")
    def versioned_expr(self) -> Optional[_builtins.str]:
        """
        Preconfigured versioned expression. If this field is specified, config must also be specified.
        Available preconfigured expressions along with their requirements are: SRC_IPS_V1 - must specify the corresponding srcIpRange field in config.
        Possible values are: `SRC_IPS_V1`.
        """
        return pulumi.get(self, "versioned_expr")


@pulumi.output_type
class SecurityPolicyRuleMatchConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "srcIpRanges":
            suggest = "src_ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyRuleMatchConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyRuleMatchConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyRuleMatchConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 src_ip_ranges: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] src_ip_ranges: CIDR IP address range. Maximum number of srcIpRanges allowed is 10.
        """
        if src_ip_ranges is not None:
            pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        CIDR IP address range. Maximum number of srcIpRanges allowed is 10.
        """
        return pulumi.get(self, "src_ip_ranges")


@pulumi.output_type
class SecurityPolicyRuleMatchExpr(dict):
    def __init__(__self__, *,
                 expression: _builtins.str):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax. The application context of the containing message determines which well-known feature set of CEL is supported.
        """
        pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax. The application context of the containing message determines which well-known feature set of CEL is supported.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class SecurityPolicyRuleMatchExprOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recaptchaOptions":
            suggest = "recaptcha_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyRuleMatchExprOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyRuleMatchExprOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyRuleMatchExprOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recaptcha_options: 'outputs.SecurityPolicyRuleMatchExprOptionsRecaptchaOptions'):
        """
        :param 'SecurityPolicyRuleMatchExprOptionsRecaptchaOptionsArgs' recaptcha_options: reCAPTCHA configuration options to be applied for the rule. If the rule does not evaluate reCAPTCHA tokens, this field has no effect.
               Structure is documented below.
        """
        pulumi.set(__self__, "recaptcha_options", recaptcha_options)

    @_builtins.property
    @pulumi.getter(name="recaptchaOptions")
    def recaptcha_options(self) -> 'outputs.SecurityPolicyRuleMatchExprOptionsRecaptchaOptions':
        """
        reCAPTCHA configuration options to be applied for the rule. If the rule does not evaluate reCAPTCHA tokens, this field has no effect.
        Structure is documented below.
        """
        return pulumi.get(self, "recaptcha_options")


@pulumi.output_type
class SecurityPolicyRuleMatchExprOptionsRecaptchaOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionTokenSiteKeys":
            suggest = "action_token_site_keys"
        elif key == "sessionTokenSiteKeys":
            suggest = "session_token_site_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyRuleMatchExprOptionsRecaptchaOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyRuleMatchExprOptionsRecaptchaOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyRuleMatchExprOptionsRecaptchaOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_token_site_keys: Optional[Sequence[_builtins.str]] = None,
                 session_token_site_keys: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] action_token_site_keys: A list of site keys to be used during the validation of reCAPTCHA action-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
        :param Sequence[_builtins.str] session_token_site_keys: A list of site keys to be used during the validation of reCAPTCHA session-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
        """
        if action_token_site_keys is not None:
            pulumi.set(__self__, "action_token_site_keys", action_token_site_keys)
        if session_token_site_keys is not None:
            pulumi.set(__self__, "session_token_site_keys", session_token_site_keys)

    @_builtins.property
    @pulumi.getter(name="actionTokenSiteKeys")
    def action_token_site_keys(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of site keys to be used during the validation of reCAPTCHA action-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
        """
        return pulumi.get(self, "action_token_site_keys")

    @_builtins.property
    @pulumi.getter(name="sessionTokenSiteKeys")
    def session_token_site_keys(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of site keys to be used during the validation of reCAPTCHA session-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
        """
        return pulumi.get(self, "session_token_site_keys")


@pulumi.output_type
class SecurityPolicyRulePreconfiguredWafConfig(dict):
    def __init__(__self__, *,
                 exclusions: Optional[Sequence['outputs.SecurityPolicyRulePreconfiguredWafConfigExclusion']] = None):
        """
        :param Sequence['SecurityPolicyRulePreconfiguredWafConfigExclusionArgs'] exclusions: An exclusion to apply during preconfigured WAF evaluation.
               Structure is documented below.
        """
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence['outputs.SecurityPolicyRulePreconfiguredWafConfigExclusion']]:
        """
        An exclusion to apply during preconfigured WAF evaluation.
        Structure is documented below.
        """
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class SecurityPolicyRulePreconfiguredWafConfigExclusion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetRuleSet":
            suggest = "target_rule_set"
        elif key == "requestCookies":
            suggest = "request_cookies"
        elif key == "requestHeaders":
            suggest = "request_headers"
        elif key == "requestQueryParams":
            suggest = "request_query_params"
        elif key == "requestUris":
            suggest = "request_uris"
        elif key == "targetRuleIds":
            suggest = "target_rule_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyRulePreconfiguredWafConfigExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyRulePreconfiguredWafConfigExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyRulePreconfiguredWafConfigExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_rule_set: _builtins.str,
                 request_cookies: Optional[Sequence['outputs.SecurityPolicyRulePreconfiguredWafConfigExclusionRequestCooky']] = None,
                 request_headers: Optional[Sequence['outputs.SecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeader']] = None,
                 request_query_params: Optional[Sequence['outputs.SecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParam']] = None,
                 request_uris: Optional[Sequence['outputs.SecurityPolicyRulePreconfiguredWafConfigExclusionRequestUri']] = None,
                 target_rule_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str target_rule_set: Target WAF rule set to apply the preconfigured WAF exclusion.
        :param Sequence['SecurityPolicyRulePreconfiguredWafConfigExclusionRequestCookyArgs'] request_cookies: Request cookie whose value will be excluded from inspection during preconfigured WAF evaluation.
               Structure is documented below.
        :param Sequence['SecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeaderArgs'] request_headers: Request header whose value will be excluded from inspection during preconfigured WAF evaluation.
               Structure is documented below.
        :param Sequence['SecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParamArgs'] request_query_params: Request query parameter whose value will be excluded from inspection during preconfigured WAF evaluation.
               Note that the parameter can be in the query string or in the POST body.
               Structure is documented below.
        :param Sequence['SecurityPolicyRulePreconfiguredWafConfigExclusionRequestUriArgs'] request_uris: Request URI from the request line to be excluded from inspection during preconfigured WAF evaluation.
               When specifying this field, the query or fragment part should be excluded.
               Structure is documented below.
        :param Sequence[_builtins.str] target_rule_ids: A list of target rule IDs under the WAF rule set to apply the preconfigured WAF exclusion.
               If omitted, it refers to all the rule IDs under the WAF rule set.
        """
        pulumi.set(__self__, "target_rule_set", target_rule_set)
        if request_cookies is not None:
            pulumi.set(__self__, "request_cookies", request_cookies)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if request_query_params is not None:
            pulumi.set(__self__, "request_query_params", request_query_params)
        if request_uris is not None:
            pulumi.set(__self__, "request_uris", request_uris)
        if target_rule_ids is not None:
            pulumi.set(__self__, "target_rule_ids", target_rule_ids)

    @_builtins.property
    @pulumi.getter(name="targetRuleSet")
    def target_rule_set(self) -> _builtins.str:
        """
        Target WAF rule set to apply the preconfigured WAF exclusion.
        """
        return pulumi.get(self, "target_rule_set")

    @_builtins.property
    @pulumi.getter(name="requestCookies")
    def request_cookies(self) -> Optional[Sequence['outputs.SecurityPolicyRulePreconfiguredWafConfigExclusionRequestCooky']]:
        """
        Request cookie whose value will be excluded from inspection during preconfigured WAF evaluation.
        Structure is documented below.
        """
        return pulumi.get(self, "request_cookies")

    @_builtins.property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Sequence['outputs.SecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeader']]:
        """
        Request header whose value will be excluded from inspection during preconfigured WAF evaluation.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers")

    @_builtins.property
    @pulumi.getter(name="requestQueryParams")
    def request_query_params(self) -> Optional[Sequence['outputs.SecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParam']]:
        """
        Request query parameter whose value will be excluded from inspection during preconfigured WAF evaluation.
        Note that the parameter can be in the query string or in the POST body.
        Structure is documented below.
        """
        return pulumi.get(self, "request_query_params")

    @_builtins.property
    @pulumi.getter(name="requestUris")
    def request_uris(self) -> Optional[Sequence['outputs.SecurityPolicyRulePreconfiguredWafConfigExclusionRequestUri']]:
        """
        Request URI from the request line to be excluded from inspection during preconfigured WAF evaluation.
        When specifying this field, the query or fragment part should be excluded.
        Structure is documented below.
        """
        return pulumi.get(self, "request_uris")

    @_builtins.property
    @pulumi.getter(name="targetRuleIds")
    def target_rule_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of target rule IDs under the WAF rule set to apply the preconfigured WAF exclusion.
        If omitted, it refers to all the rule IDs under the WAF rule set.
        """
        return pulumi.get(self, "target_rule_ids")


@pulumi.output_type
class SecurityPolicyRulePreconfiguredWafConfigExclusionRequestCooky(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value.
               Available options:
               EQUALS: The operator matches if the field value equals the specified value.
               STARTS_WITH: The operator matches if the field value starts with the specified value.
               ENDS_WITH: The operator matches if the field value ends with the specified value.
               CONTAINS: The operator matches if the field value contains the specified value.
               EQUALS_ANY: The operator matches if the field value is any value.
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
               The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value.
        Available options:
        EQUALS: The operator matches if the field value equals the specified value.
        STARTS_WITH: The operator matches if the field value starts with the specified value.
        ENDS_WITH: The operator matches if the field value ends with the specified value.
        CONTAINS: The operator matches if the field value contains the specified value.
        EQUALS_ANY: The operator matches if the field value is any value.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
        The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeader(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value.
               Available options:
               EQUALS: The operator matches if the field value equals the specified value.
               STARTS_WITH: The operator matches if the field value starts with the specified value.
               ENDS_WITH: The operator matches if the field value ends with the specified value.
               CONTAINS: The operator matches if the field value contains the specified value.
               EQUALS_ANY: The operator matches if the field value is any value.
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
               The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value.
        Available options:
        EQUALS: The operator matches if the field value equals the specified value.
        STARTS_WITH: The operator matches if the field value starts with the specified value.
        ENDS_WITH: The operator matches if the field value ends with the specified value.
        CONTAINS: The operator matches if the field value contains the specified value.
        EQUALS_ANY: The operator matches if the field value is any value.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
        The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParam(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value.
               Available options:
               EQUALS: The operator matches if the field value equals the specified value.
               STARTS_WITH: The operator matches if the field value starts with the specified value.
               ENDS_WITH: The operator matches if the field value ends with the specified value.
               CONTAINS: The operator matches if the field value contains the specified value.
               EQUALS_ANY: The operator matches if the field value is any value.
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
               The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value.
        Available options:
        EQUALS: The operator matches if the field value equals the specified value.
        STARTS_WITH: The operator matches if the field value starts with the specified value.
        ENDS_WITH: The operator matches if the field value ends with the specified value.
        CONTAINS: The operator matches if the field value contains the specified value.
        EQUALS_ANY: The operator matches if the field value is any value.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
        The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SecurityPolicyRulePreconfiguredWafConfigExclusionRequestUri(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value.
               Available options:
               EQUALS: The operator matches if the field value equals the specified value.
               STARTS_WITH: The operator matches if the field value starts with the specified value.
               ENDS_WITH: The operator matches if the field value ends with the specified value.
               CONTAINS: The operator matches if the field value contains the specified value.
               EQUALS_ANY: The operator matches if the field value is any value.
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
               The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value.
        Available options:
        EQUALS: The operator matches if the field value equals the specified value.
        STARTS_WITH: The operator matches if the field value starts with the specified value.
        ENDS_WITH: The operator matches if the field value ends with the specified value.
        CONTAINS: The operator matches if the field value contains the specified value.
        EQUALS_ANY: The operator matches if the field value is any value.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
        The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SecurityPolicyRuleRateLimitOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "banDurationSec":
            suggest = "ban_duration_sec"
        elif key == "banThreshold":
            suggest = "ban_threshold"
        elif key == "conformAction":
            suggest = "conform_action"
        elif key == "enforceOnKey":
            suggest = "enforce_on_key"
        elif key == "enforceOnKeyConfigs":
            suggest = "enforce_on_key_configs"
        elif key == "enforceOnKeyName":
            suggest = "enforce_on_key_name"
        elif key == "exceedAction":
            suggest = "exceed_action"
        elif key == "exceedRedirectOptions":
            suggest = "exceed_redirect_options"
        elif key == "rateLimitThreshold":
            suggest = "rate_limit_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyRuleRateLimitOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyRuleRateLimitOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyRuleRateLimitOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ban_duration_sec: Optional[_builtins.int] = None,
                 ban_threshold: Optional['outputs.SecurityPolicyRuleRateLimitOptionsBanThreshold'] = None,
                 conform_action: Optional[_builtins.str] = None,
                 enforce_on_key: Optional[_builtins.str] = None,
                 enforce_on_key_configs: Optional[Sequence['outputs.SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig']] = None,
                 enforce_on_key_name: Optional[_builtins.str] = None,
                 exceed_action: Optional[_builtins.str] = None,
                 exceed_redirect_options: Optional['outputs.SecurityPolicyRuleRateLimitOptionsExceedRedirectOptions'] = None,
                 rate_limit_threshold: Optional['outputs.SecurityPolicyRuleRateLimitOptionsRateLimitThreshold'] = None):
        """
        :param _builtins.int ban_duration_sec: Can only be specified if the action for the rule is "rate_based_ban".
               If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
        :param 'SecurityPolicyRuleRateLimitOptionsBanThresholdArgs' ban_threshold: Can only be specified if the action for the rule is "rate_based_ban".
               If specified, the key will be banned for the configured 'banDurationSec' when the number of requests that exceed the 'rateLimitThreshold' also exceed this 'banThreshold'.
               Structure is documented below.
        :param _builtins.str conform_action: Action to take for requests that are under the configured rate limit threshold.
               Valid option is "allow" only.
        :param _builtins.str enforce_on_key: Determines the key to enforce the rateLimitThreshold on. Possible values are:
               * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKey" is not configured.
               * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
               * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
               * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
               * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
               * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
               * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
               * REGION_CODE: The country/region from which the request originates.
               * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
               * TLS_JA4_FINGERPRINT: JA4 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
               * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP.
               Possible values are: `ALL`, `IP`, `HTTP_HEADER`, `XFF_IP`, `HTTP_COOKIE`, `HTTP_PATH`, `SNI`, `REGION_CODE`, `TLS_JA3_FINGERPRINT`, `TLS_JA4_FINGERPRINT`, `USER_IP`.
        :param Sequence['SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfigArgs'] enforce_on_key_configs: If specified, any combination of values of enforceOnKeyType/enforceOnKeyName is treated as the key on which ratelimit threshold/action is enforced.
               You can specify up to 3 enforceOnKeyConfigs.
               If enforceOnKeyConfigs is specified, enforceOnKey must not be specified.
               Structure is documented below.
        :param _builtins.str enforce_on_key_name: Rate limit key name applicable only for the following key types:
               HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
               HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        :param _builtins.str exceed_action: Action to take for requests that are above the configured rate limit threshold, to either deny with a specified HTTP response code, or redirect to a different endpoint.
               Valid options are deny(STATUS), where valid values for STATUS are 403, 404, 429, and 502.
        :param 'SecurityPolicyRuleRateLimitOptionsExceedRedirectOptionsArgs' exceed_redirect_options: Parameters defining the redirect action that is used as the exceed action. Cannot be specified if the exceed action is not redirect. This field is only supported in Global Security Policies of type CLOUD_ARMOR.
               Structure is documented below.
        :param 'SecurityPolicyRuleRateLimitOptionsRateLimitThresholdArgs' rate_limit_threshold: Threshold at which to begin ratelimiting.
               Structure is documented below.
        """
        if ban_duration_sec is not None:
            pulumi.set(__self__, "ban_duration_sec", ban_duration_sec)
        if ban_threshold is not None:
            pulumi.set(__self__, "ban_threshold", ban_threshold)
        if conform_action is not None:
            pulumi.set(__self__, "conform_action", conform_action)
        if enforce_on_key is not None:
            pulumi.set(__self__, "enforce_on_key", enforce_on_key)
        if enforce_on_key_configs is not None:
            pulumi.set(__self__, "enforce_on_key_configs", enforce_on_key_configs)
        if enforce_on_key_name is not None:
            pulumi.set(__self__, "enforce_on_key_name", enforce_on_key_name)
        if exceed_action is not None:
            pulumi.set(__self__, "exceed_action", exceed_action)
        if exceed_redirect_options is not None:
            pulumi.set(__self__, "exceed_redirect_options", exceed_redirect_options)
        if rate_limit_threshold is not None:
            pulumi.set(__self__, "rate_limit_threshold", rate_limit_threshold)

    @_builtins.property
    @pulumi.getter(name="banDurationSec")
    def ban_duration_sec(self) -> Optional[_builtins.int]:
        """
        Can only be specified if the action for the rule is "rate_based_ban".
        If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
        """
        return pulumi.get(self, "ban_duration_sec")

    @_builtins.property
    @pulumi.getter(name="banThreshold")
    def ban_threshold(self) -> Optional['outputs.SecurityPolicyRuleRateLimitOptionsBanThreshold']:
        """
        Can only be specified if the action for the rule is "rate_based_ban".
        If specified, the key will be banned for the configured 'banDurationSec' when the number of requests that exceed the 'rateLimitThreshold' also exceed this 'banThreshold'.
        Structure is documented below.
        """
        return pulumi.get(self, "ban_threshold")

    @_builtins.property
    @pulumi.getter(name="conformAction")
    def conform_action(self) -> Optional[_builtins.str]:
        """
        Action to take for requests that are under the configured rate limit threshold.
        Valid option is "allow" only.
        """
        return pulumi.get(self, "conform_action")

    @_builtins.property
    @pulumi.getter(name="enforceOnKey")
    def enforce_on_key(self) -> Optional[_builtins.str]:
        """
        Determines the key to enforce the rateLimitThreshold on. Possible values are:
        * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKey" is not configured.
        * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
        * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
        * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
        * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
        * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
        * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
        * REGION_CODE: The country/region from which the request originates.
        * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
        * TLS_JA4_FINGERPRINT: JA4 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
        * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP.
        Possible values are: `ALL`, `IP`, `HTTP_HEADER`, `XFF_IP`, `HTTP_COOKIE`, `HTTP_PATH`, `SNI`, `REGION_CODE`, `TLS_JA3_FINGERPRINT`, `TLS_JA4_FINGERPRINT`, `USER_IP`.
        """
        return pulumi.get(self, "enforce_on_key")

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyConfigs")
    def enforce_on_key_configs(self) -> Optional[Sequence['outputs.SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig']]:
        """
        If specified, any combination of values of enforceOnKeyType/enforceOnKeyName is treated as the key on which ratelimit threshold/action is enforced.
        You can specify up to 3 enforceOnKeyConfigs.
        If enforceOnKeyConfigs is specified, enforceOnKey must not be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "enforce_on_key_configs")

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyName")
    def enforce_on_key_name(self) -> Optional[_builtins.str]:
        """
        Rate limit key name applicable only for the following key types:
        HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
        HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        """
        return pulumi.get(self, "enforce_on_key_name")

    @_builtins.property
    @pulumi.getter(name="exceedAction")
    def exceed_action(self) -> Optional[_builtins.str]:
        """
        Action to take for requests that are above the configured rate limit threshold, to either deny with a specified HTTP response code, or redirect to a different endpoint.
        Valid options are deny(STATUS), where valid values for STATUS are 403, 404, 429, and 502.
        """
        return pulumi.get(self, "exceed_action")

    @_builtins.property
    @pulumi.getter(name="exceedRedirectOptions")
    def exceed_redirect_options(self) -> Optional['outputs.SecurityPolicyRuleRateLimitOptionsExceedRedirectOptions']:
        """
        Parameters defining the redirect action that is used as the exceed action. Cannot be specified if the exceed action is not redirect. This field is only supported in Global Security Policies of type CLOUD_ARMOR.
        Structure is documented below.
        """
        return pulumi.get(self, "exceed_redirect_options")

    @_builtins.property
    @pulumi.getter(name="rateLimitThreshold")
    def rate_limit_threshold(self) -> Optional['outputs.SecurityPolicyRuleRateLimitOptionsRateLimitThreshold']:
        """
        Threshold at which to begin ratelimiting.
        Structure is documented below.
        """
        return pulumi.get(self, "rate_limit_threshold")


@pulumi.output_type
class SecurityPolicyRuleRateLimitOptionsBanThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalSec":
            suggest = "interval_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyRuleRateLimitOptionsBanThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyRuleRateLimitOptionsBanThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyRuleRateLimitOptionsBanThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[_builtins.int] = None,
                 interval_sec: Optional[_builtins.int] = None):
        """
        :param _builtins.int count: Number of HTTP(S) requests for calculating the threshold.
        :param _builtins.int interval_sec: Interval over which the threshold is computed.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval_sec is not None:
            pulumi.set(__self__, "interval_sec", interval_sec)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        Number of HTTP(S) requests for calculating the threshold.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="intervalSec")
    def interval_sec(self) -> Optional[_builtins.int]:
        """
        Interval over which the threshold is computed.
        """
        return pulumi.get(self, "interval_sec")


@pulumi.output_type
class SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enforceOnKeyName":
            suggest = "enforce_on_key_name"
        elif key == "enforceOnKeyType":
            suggest = "enforce_on_key_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enforce_on_key_name: Optional[_builtins.str] = None,
                 enforce_on_key_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str enforce_on_key_name: Rate limit key name applicable only for the following key types:
               HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
               HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        :param _builtins.str enforce_on_key_type: Determines the key to enforce the rateLimitThreshold on. Possible values are:
               * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKeyConfigs" is not configured.
               * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
               * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
               * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
               * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
               * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
               * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
               * REGION_CODE: The country/region from which the request originates.
               * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
               * TLS_JA4_FINGERPRINT: JA4 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
               * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP.
               Possible values are: `ALL`, `IP`, `HTTP_HEADER`, `XFF_IP`, `HTTP_COOKIE`, `HTTP_PATH`, `SNI`, `REGION_CODE`, `TLS_JA3_FINGERPRINT`, `TLS_JA4_FINGERPRINT`, `USER_IP`.
        """
        if enforce_on_key_name is not None:
            pulumi.set(__self__, "enforce_on_key_name", enforce_on_key_name)
        if enforce_on_key_type is not None:
            pulumi.set(__self__, "enforce_on_key_type", enforce_on_key_type)

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyName")
    def enforce_on_key_name(self) -> Optional[_builtins.str]:
        """
        Rate limit key name applicable only for the following key types:
        HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
        HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        """
        return pulumi.get(self, "enforce_on_key_name")

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyType")
    def enforce_on_key_type(self) -> Optional[_builtins.str]:
        """
        Determines the key to enforce the rateLimitThreshold on. Possible values are:
        * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKeyConfigs" is not configured.
        * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
        * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
        * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
        * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
        * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
        * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
        * REGION_CODE: The country/region from which the request originates.
        * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
        * TLS_JA4_FINGERPRINT: JA4 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
        * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP.
        Possible values are: `ALL`, `IP`, `HTTP_HEADER`, `XFF_IP`, `HTTP_COOKIE`, `HTTP_PATH`, `SNI`, `REGION_CODE`, `TLS_JA3_FINGERPRINT`, `TLS_JA4_FINGERPRINT`, `USER_IP`.
        """
        return pulumi.get(self, "enforce_on_key_type")


@pulumi.output_type
class SecurityPolicyRuleRateLimitOptionsExceedRedirectOptions(dict):
    def __init__(__self__, *,
                 target: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str target: Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
        :param _builtins.str type: Type of the redirect action.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the redirect action.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SecurityPolicyRuleRateLimitOptionsRateLimitThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalSec":
            suggest = "interval_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyRuleRateLimitOptionsRateLimitThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyRuleRateLimitOptionsRateLimitThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyRuleRateLimitOptionsRateLimitThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[_builtins.int] = None,
                 interval_sec: Optional[_builtins.int] = None):
        """
        :param _builtins.int count: Number of HTTP(S) requests for calculating the threshold.
        :param _builtins.int interval_sec: Interval over which the threshold is computed.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval_sec is not None:
            pulumi.set(__self__, "interval_sec", interval_sec)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        Number of HTTP(S) requests for calculating the threshold.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="intervalSec")
    def interval_sec(self) -> Optional[_builtins.int]:
        """
        Interval over which the threshold is computed.
        """
        return pulumi.get(self, "interval_sec")


@pulumi.output_type
class SecurityPolicyRuleRedirectOptions(dict):
    def __init__(__self__, *,
                 target: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str target: Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
        :param _builtins.str type: Type of the redirect action.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the redirect action.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SecurityScanConfigAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customAccount":
            suggest = "custom_account"
        elif key == "googleAccount":
            suggest = "google_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityScanConfigAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityScanConfigAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityScanConfigAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_account: Optional['outputs.SecurityScanConfigAuthenticationCustomAccount'] = None,
                 google_account: Optional['outputs.SecurityScanConfigAuthenticationGoogleAccount'] = None):
        """
        :param 'SecurityScanConfigAuthenticationCustomAccountArgs' custom_account: Describes authentication configuration that uses a custom account.
               Structure is documented below.
        :param 'SecurityScanConfigAuthenticationGoogleAccountArgs' google_account: Describes authentication configuration that uses a Google account.
               Structure is documented below.
        """
        if custom_account is not None:
            pulumi.set(__self__, "custom_account", custom_account)
        if google_account is not None:
            pulumi.set(__self__, "google_account", google_account)

    @_builtins.property
    @pulumi.getter(name="customAccount")
    def custom_account(self) -> Optional['outputs.SecurityScanConfigAuthenticationCustomAccount']:
        """
        Describes authentication configuration that uses a custom account.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_account")

    @_builtins.property
    @pulumi.getter(name="googleAccount")
    def google_account(self) -> Optional['outputs.SecurityScanConfigAuthenticationGoogleAccount']:
        """
        Describes authentication configuration that uses a Google account.
        Structure is documented below.
        """
        return pulumi.get(self, "google_account")


@pulumi.output_type
class SecurityScanConfigAuthenticationCustomAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginUrl":
            suggest = "login_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityScanConfigAuthenticationCustomAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityScanConfigAuthenticationCustomAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityScanConfigAuthenticationCustomAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_url: _builtins.str,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str login_url: The login form URL of the website.
        :param _builtins.str password: The password of the custom account. The credential is stored encrypted
               in GCP.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str username: The user name of the custom account.
        """
        pulumi.set(__self__, "login_url", login_url)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="loginUrl")
    def login_url(self) -> _builtins.str:
        """
        The login form URL of the website.
        """
        return pulumi.get(self, "login_url")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the custom account. The credential is stored encrypted
        in GCP.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The user name of the custom account.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SecurityScanConfigAuthenticationGoogleAccount(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: The password of the Google account. The credential is stored encrypted
               in GCP.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str username: The user name of the Google account.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the Google account. The credential is stored encrypted
        in GCP.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The user name of the Google account.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SecurityScanConfigSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalDurationDays":
            suggest = "interval_duration_days"
        elif key == "scheduleTime":
            suggest = "schedule_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityScanConfigSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityScanConfigSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityScanConfigSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_duration_days: _builtins.int,
                 schedule_time: Optional[_builtins.str] = None):
        """
        :param _builtins.int interval_duration_days: The duration of time between executions in days
        :param _builtins.str schedule_time: A timestamp indicates when the next run will be scheduled. The value is refreshed
               by the server after each run. If unspecified, it will default to current server time,
               which means the scan will be scheduled to start immediately.
        """
        pulumi.set(__self__, "interval_duration_days", interval_duration_days)
        if schedule_time is not None:
            pulumi.set(__self__, "schedule_time", schedule_time)

    @_builtins.property
    @pulumi.getter(name="intervalDurationDays")
    def interval_duration_days(self) -> _builtins.int:
        """
        The duration of time between executions in days
        """
        return pulumi.get(self, "interval_duration_days")

    @_builtins.property
    @pulumi.getter(name="scheduleTime")
    def schedule_time(self) -> Optional[_builtins.str]:
        """
        A timestamp indicates when the next run will be scheduled. The value is refreshed
        by the server after each run. If unspecified, it will default to current server time,
        which means the scan will be scheduled to start immediately.
        """
        return pulumi.get(self, "schedule_time")


@pulumi.output_type
class ServiceAttachmentConnectedEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerNetwork":
            suggest = "consumer_network"
        elif key == "natIps":
            suggest = "nat_ips"
        elif key == "propagatedConnectionCount":
            suggest = "propagated_connection_count"
        elif key == "pscConnectionId":
            suggest = "psc_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAttachmentConnectedEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAttachmentConnectedEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAttachmentConnectedEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_network: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 nat_ips: Optional[Sequence[_builtins.str]] = None,
                 propagated_connection_count: Optional[_builtins.int] = None,
                 psc_connection_id: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str consumer_network: (Output)
               The url of the consumer network.
        :param _builtins.str endpoint: (Output)
               The URL of the consumer forwarding rule.
        :param Sequence[_builtins.str] nat_ips: (Output)
               The nat IPs of the connected endpoint.
        :param _builtins.int propagated_connection_count: (Output)
               The number of consumer Network Connectivity Center spokes that the connected Private Service Connect endpoint has propagated to.
        :param _builtins.str psc_connection_id: (Output)
               The PSC connection id of the connected endpoint.
        :param _builtins.str status: (Output)
               The status of the connection from the consumer forwarding rule to
               this service attachment.
        """
        if consumer_network is not None:
            pulumi.set(__self__, "consumer_network", consumer_network)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if nat_ips is not None:
            pulumi.set(__self__, "nat_ips", nat_ips)
        if propagated_connection_count is not None:
            pulumi.set(__self__, "propagated_connection_count", propagated_connection_count)
        if psc_connection_id is not None:
            pulumi.set(__self__, "psc_connection_id", psc_connection_id)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="consumerNetwork")
    def consumer_network(self) -> Optional[_builtins.str]:
        """
        (Output)
        The url of the consumer network.
        """
        return pulumi.get(self, "consumer_network")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        (Output)
        The URL of the consumer forwarding rule.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="natIps")
    def nat_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        The nat IPs of the connected endpoint.
        """
        return pulumi.get(self, "nat_ips")

    @_builtins.property
    @pulumi.getter(name="propagatedConnectionCount")
    def propagated_connection_count(self) -> Optional[_builtins.int]:
        """
        (Output)
        The number of consumer Network Connectivity Center spokes that the connected Private Service Connect endpoint has propagated to.
        """
        return pulumi.get(self, "propagated_connection_count")

    @_builtins.property
    @pulumi.getter(name="pscConnectionId")
    def psc_connection_id(self) -> Optional[_builtins.str]:
        """
        (Output)
        The PSC connection id of the connected endpoint.
        """
        return pulumi.get(self, "psc_connection_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        (Output)
        The status of the connection from the consumer forwarding rule to
        this service attachment.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ServiceAttachmentConsumerAcceptList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionLimit":
            suggest = "connection_limit"
        elif key == "networkUrl":
            suggest = "network_url"
        elif key == "projectIdOrNum":
            suggest = "project_id_or_num"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAttachmentConsumerAcceptList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAttachmentConsumerAcceptList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAttachmentConsumerAcceptList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_limit: _builtins.int,
                 network_url: Optional[_builtins.str] = None,
                 project_id_or_num: Optional[_builtins.str] = None):
        """
        :param _builtins.int connection_limit: The number of consumer forwarding rules the consumer project can
               create.
        :param _builtins.str network_url: The network that is allowed to connect to this service attachment.
               Only one of project_id_or_num and network_url may be set.
        :param _builtins.str project_id_or_num: A project that is allowed to connect to this service attachment.
               Only one of project_id_or_num and network_url may be set.
        """
        pulumi.set(__self__, "connection_limit", connection_limit)
        if network_url is not None:
            pulumi.set(__self__, "network_url", network_url)
        if project_id_or_num is not None:
            pulumi.set(__self__, "project_id_or_num", project_id_or_num)

    @_builtins.property
    @pulumi.getter(name="connectionLimit")
    def connection_limit(self) -> _builtins.int:
        """
        The number of consumer forwarding rules the consumer project can
        create.
        """
        return pulumi.get(self, "connection_limit")

    @_builtins.property
    @pulumi.getter(name="networkUrl")
    def network_url(self) -> Optional[_builtins.str]:
        """
        The network that is allowed to connect to this service attachment.
        Only one of project_id_or_num and network_url may be set.
        """
        return pulumi.get(self, "network_url")

    @_builtins.property
    @pulumi.getter(name="projectIdOrNum")
    def project_id_or_num(self) -> Optional[_builtins.str]:
        """
        A project that is allowed to connect to this service attachment.
        Only one of project_id_or_num and network_url may be set.
        """
        return pulumi.get(self, "project_id_or_num")


@pulumi.output_type
class ServiceAttachmentPscServiceAttachmentId(dict):
    def __init__(__self__, *,
                 high: Optional[_builtins.str] = None,
                 low: Optional[_builtins.str] = None):
        """
        :param _builtins.str high: (Output)
               The high 64 bits of the PSC service attachment ID.
        :param _builtins.str low: (Output)
               The low 64 bits of the PSC service attachment ID.
        """
        if high is not None:
            pulumi.set(__self__, "high", high)
        if low is not None:
            pulumi.set(__self__, "low", low)

    @_builtins.property
    @pulumi.getter
    def high(self) -> Optional[_builtins.str]:
        """
        (Output)
        The high 64 bits of the PSC service attachment ID.
        """
        return pulumi.get(self, "high")

    @_builtins.property
    @pulumi.getter
    def low(self) -> Optional[_builtins.str]:
        """
        (Output)
        The low 64 bits of the PSC service attachment ID.
        """
        return pulumi.get(self, "low")


@pulumi.output_type
class ServiceAttachmentTunnelingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encapsulationProfile":
            suggest = "encapsulation_profile"
        elif key == "routingMode":
            suggest = "routing_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAttachmentTunnelingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAttachmentTunnelingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAttachmentTunnelingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encapsulation_profile: Optional[_builtins.str] = None,
                 routing_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str encapsulation_profile: The encapsulation profile for tunneling traffic.
        :param _builtins.str routing_mode: The routing mode for tunneling traffic.
        """
        if encapsulation_profile is not None:
            pulumi.set(__self__, "encapsulation_profile", encapsulation_profile)
        if routing_mode is not None:
            pulumi.set(__self__, "routing_mode", routing_mode)

    @_builtins.property
    @pulumi.getter(name="encapsulationProfile")
    def encapsulation_profile(self) -> Optional[_builtins.str]:
        """
        The encapsulation profile for tunneling traffic.
        """
        return pulumi.get(self, "encapsulation_profile")

    @_builtins.property
    @pulumi.getter(name="routingMode")
    def routing_mode(self) -> Optional[_builtins.str]:
        """
        The routing mode for tunneling traffic.
        """
        return pulumi.get(self, "routing_mode")


@pulumi.output_type
class SnapshotIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class SnapshotIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class SnapshotSettingsStorageLocation(dict):
    def __init__(__self__, *,
                 policy: _builtins.str,
                 locations: Optional[Sequence['outputs.SnapshotSettingsStorageLocationLocation']] = None):
        """
        :param _builtins.str policy: The chosen location policy
               Possible values are: `NEAREST_MULTI_REGION`, `LOCAL_REGION`, `SPECIFIC_LOCATIONS`.
        :param Sequence['SnapshotSettingsStorageLocationLocationArgs'] locations: When the policy is SPECIFIC_LOCATIONS, snapshots will be stored in the
               locations listed in this field. Keys are Cloud Storage bucket locations.
               Only one location can be specified.
               Structure is documented below.
        """
        pulumi.set(__self__, "policy", policy)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        """
        The chosen location policy
        Possible values are: `NEAREST_MULTI_REGION`, `LOCAL_REGION`, `SPECIFIC_LOCATIONS`.
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.SnapshotSettingsStorageLocationLocation']]:
        """
        When the policy is SPECIFIC_LOCATIONS, snapshots will be stored in the
        locations listed in this field. Keys are Cloud Storage bucket locations.
        Only one location can be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class SnapshotSettingsStorageLocationLocation(dict):
    def __init__(__self__, *,
                 location: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str location: The identifier for this object. Format specified above.
        :param _builtins.str name: Name of the location. It should be one of the Cloud Storage buckets.
               Only one location can be specified. (should match location)
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the location. It should be one of the Cloud Storage buckets.
        Only one location can be specified. (should match location)
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SnapshotSnapshotEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnapshotSnapshotEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnapshotSnapshotEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnapshotSnapshotEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The name of the encryption key that is stored in Google Cloud KMS.
        :param _builtins.str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str rsa_encrypted_key: Specifies an encryption key stored in Google Cloud KMS, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str sha256: (Output)
               The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an encryption key stored in Google Cloud KMS, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        (Output)
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class SnapshotSourceDiskEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeySelfLink":
            suggest = "kms_key_self_link"
        elif key == "kmsKeyServiceAccount":
            suggest = "kms_key_service_account"
        elif key == "rawKey":
            suggest = "raw_key"
        elif key == "rsaEncryptedKey":
            suggest = "rsa_encrypted_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnapshotSourceDiskEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnapshotSourceDiskEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnapshotSourceDiskEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_self_link: Optional[_builtins.str] = None,
                 kms_key_service_account: Optional[_builtins.str] = None,
                 raw_key: Optional[_builtins.str] = None,
                 rsa_encrypted_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_self_link: The name of the encryption key that is stored in Google Cloud KMS.
        :param _builtins.str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str rsa_encrypted_key: Specifies an encryption key stored in Google Cloud KMS, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        if kms_key_self_link is not None:
            pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        if kms_key_service_account is not None:
            pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        if raw_key is not None:
            pulumi.set(__self__, "raw_key", raw_key)
        if rsa_encrypted_key is not None:
            pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> Optional[_builtins.str]:
        """
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> Optional[_builtins.str]:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> Optional[_builtins.str]:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> Optional[_builtins.str]:
        """
        Specifies an encryption key stored in Google Cloud KMS, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class StoragePoolIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class StoragePoolIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class StoragePoolResourceStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskCount":
            suggest = "disk_count"
        elif key == "lastResizeTimestamp":
            suggest = "last_resize_timestamp"
        elif key == "maxTotalProvisionedDiskCapacityGb":
            suggest = "max_total_provisioned_disk_capacity_gb"
        elif key == "poolUsedCapacityBytes":
            suggest = "pool_used_capacity_bytes"
        elif key == "poolUsedIops":
            suggest = "pool_used_iops"
        elif key == "poolUsedThroughput":
            suggest = "pool_used_throughput"
        elif key == "poolUserWrittenBytes":
            suggest = "pool_user_written_bytes"
        elif key == "totalProvisionedDiskCapacityGb":
            suggest = "total_provisioned_disk_capacity_gb"
        elif key == "totalProvisionedDiskIops":
            suggest = "total_provisioned_disk_iops"
        elif key == "totalProvisionedDiskThroughput":
            suggest = "total_provisioned_disk_throughput"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StoragePoolResourceStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StoragePoolResourceStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StoragePoolResourceStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_count: Optional[_builtins.str] = None,
                 last_resize_timestamp: Optional[_builtins.str] = None,
                 max_total_provisioned_disk_capacity_gb: Optional[_builtins.str] = None,
                 pool_used_capacity_bytes: Optional[_builtins.str] = None,
                 pool_used_iops: Optional[_builtins.str] = None,
                 pool_used_throughput: Optional[_builtins.str] = None,
                 pool_user_written_bytes: Optional[_builtins.str] = None,
                 total_provisioned_disk_capacity_gb: Optional[_builtins.str] = None,
                 total_provisioned_disk_iops: Optional[_builtins.str] = None,
                 total_provisioned_disk_throughput: Optional[_builtins.str] = None):
        """
        :param _builtins.str disk_count: (Output)
               Number of disks used.
        :param _builtins.str last_resize_timestamp: (Output)
               Timestamp of the last successful resize in RFC3339 text format.
        :param _builtins.str max_total_provisioned_disk_capacity_gb: (Output)
               Maximum allowed aggregate disk size in gigabytes.
        :param _builtins.str pool_used_capacity_bytes: (Output)
               Space used by data stored in disks within the storage pool (in bytes).
               This will reflect the total number of bytes written to the disks in the pool, in contrast to the capacity of those disks.
        :param _builtins.str pool_used_iops: (Output)
               Sum of all the disks' provisioned IOPS, minus some amount that is allowed per disk that is not counted towards pool's IOPS capacity. For more information, see https://cloud.google.com/compute/docs/disks/storage-pools.
        :param _builtins.str pool_used_throughput: (Output)
               Sum of all the disks' provisioned throughput in MB/s.
        :param _builtins.str pool_user_written_bytes: (Output)
               Amount of data written into the pool, before it is compacted.
        :param _builtins.str total_provisioned_disk_capacity_gb: (Output)
               Sum of all the capacity provisioned in disks in this storage pool.
               A disk's provisioned capacity is the same as its total capacity.
        :param _builtins.str total_provisioned_disk_iops: (Output)
               Sum of all the disks' provisioned IOPS.
        :param _builtins.str total_provisioned_disk_throughput: (Output)
               Sum of all the disks' provisioned throughput in MB/s,
               minus some amount that is allowed per disk that is not counted towards pool's throughput capacity.
        """
        if disk_count is not None:
            pulumi.set(__self__, "disk_count", disk_count)
        if last_resize_timestamp is not None:
            pulumi.set(__self__, "last_resize_timestamp", last_resize_timestamp)
        if max_total_provisioned_disk_capacity_gb is not None:
            pulumi.set(__self__, "max_total_provisioned_disk_capacity_gb", max_total_provisioned_disk_capacity_gb)
        if pool_used_capacity_bytes is not None:
            pulumi.set(__self__, "pool_used_capacity_bytes", pool_used_capacity_bytes)
        if pool_used_iops is not None:
            pulumi.set(__self__, "pool_used_iops", pool_used_iops)
        if pool_used_throughput is not None:
            pulumi.set(__self__, "pool_used_throughput", pool_used_throughput)
        if pool_user_written_bytes is not None:
            pulumi.set(__self__, "pool_user_written_bytes", pool_user_written_bytes)
        if total_provisioned_disk_capacity_gb is not None:
            pulumi.set(__self__, "total_provisioned_disk_capacity_gb", total_provisioned_disk_capacity_gb)
        if total_provisioned_disk_iops is not None:
            pulumi.set(__self__, "total_provisioned_disk_iops", total_provisioned_disk_iops)
        if total_provisioned_disk_throughput is not None:
            pulumi.set(__self__, "total_provisioned_disk_throughput", total_provisioned_disk_throughput)

    @_builtins.property
    @pulumi.getter(name="diskCount")
    def disk_count(self) -> Optional[_builtins.str]:
        """
        (Output)
        Number of disks used.
        """
        return pulumi.get(self, "disk_count")

    @_builtins.property
    @pulumi.getter(name="lastResizeTimestamp")
    def last_resize_timestamp(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp of the last successful resize in RFC3339 text format.
        """
        return pulumi.get(self, "last_resize_timestamp")

    @_builtins.property
    @pulumi.getter(name="maxTotalProvisionedDiskCapacityGb")
    def max_total_provisioned_disk_capacity_gb(self) -> Optional[_builtins.str]:
        """
        (Output)
        Maximum allowed aggregate disk size in gigabytes.
        """
        return pulumi.get(self, "max_total_provisioned_disk_capacity_gb")

    @_builtins.property
    @pulumi.getter(name="poolUsedCapacityBytes")
    def pool_used_capacity_bytes(self) -> Optional[_builtins.str]:
        """
        (Output)
        Space used by data stored in disks within the storage pool (in bytes).
        This will reflect the total number of bytes written to the disks in the pool, in contrast to the capacity of those disks.
        """
        return pulumi.get(self, "pool_used_capacity_bytes")

    @_builtins.property
    @pulumi.getter(name="poolUsedIops")
    def pool_used_iops(self) -> Optional[_builtins.str]:
        """
        (Output)
        Sum of all the disks' provisioned IOPS, minus some amount that is allowed per disk that is not counted towards pool's IOPS capacity. For more information, see https://cloud.google.com/compute/docs/disks/storage-pools.
        """
        return pulumi.get(self, "pool_used_iops")

    @_builtins.property
    @pulumi.getter(name="poolUsedThroughput")
    def pool_used_throughput(self) -> Optional[_builtins.str]:
        """
        (Output)
        Sum of all the disks' provisioned throughput in MB/s.
        """
        return pulumi.get(self, "pool_used_throughput")

    @_builtins.property
    @pulumi.getter(name="poolUserWrittenBytes")
    def pool_user_written_bytes(self) -> Optional[_builtins.str]:
        """
        (Output)
        Amount of data written into the pool, before it is compacted.
        """
        return pulumi.get(self, "pool_user_written_bytes")

    @_builtins.property
    @pulumi.getter(name="totalProvisionedDiskCapacityGb")
    def total_provisioned_disk_capacity_gb(self) -> Optional[_builtins.str]:
        """
        (Output)
        Sum of all the capacity provisioned in disks in this storage pool.
        A disk's provisioned capacity is the same as its total capacity.
        """
        return pulumi.get(self, "total_provisioned_disk_capacity_gb")

    @_builtins.property
    @pulumi.getter(name="totalProvisionedDiskIops")
    def total_provisioned_disk_iops(self) -> Optional[_builtins.str]:
        """
        (Output)
        Sum of all the disks' provisioned IOPS.
        """
        return pulumi.get(self, "total_provisioned_disk_iops")

    @_builtins.property
    @pulumi.getter(name="totalProvisionedDiskThroughput")
    def total_provisioned_disk_throughput(self) -> Optional[_builtins.str]:
        """
        (Output)
        Sum of all the disks' provisioned throughput in MB/s,
        minus some amount that is allowed per disk that is not counted towards pool's throughput capacity.
        """
        return pulumi.get(self, "total_provisioned_disk_throughput")


@pulumi.output_type
class StoragePoolStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskCount":
            suggest = "disk_count"
        elif key == "lastResizeTimestamp":
            suggest = "last_resize_timestamp"
        elif key == "maxTotalProvisionedDiskCapacityGb":
            suggest = "max_total_provisioned_disk_capacity_gb"
        elif key == "poolUsedCapacityBytes":
            suggest = "pool_used_capacity_bytes"
        elif key == "poolUsedIops":
            suggest = "pool_used_iops"
        elif key == "poolUsedThroughput":
            suggest = "pool_used_throughput"
        elif key == "poolUserWrittenBytes":
            suggest = "pool_user_written_bytes"
        elif key == "totalProvisionedDiskCapacityGb":
            suggest = "total_provisioned_disk_capacity_gb"
        elif key == "totalProvisionedDiskIops":
            suggest = "total_provisioned_disk_iops"
        elif key == "totalProvisionedDiskThroughput":
            suggest = "total_provisioned_disk_throughput"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StoragePoolStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StoragePoolStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StoragePoolStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_count: Optional[_builtins.str] = None,
                 last_resize_timestamp: Optional[_builtins.str] = None,
                 max_total_provisioned_disk_capacity_gb: Optional[_builtins.str] = None,
                 pool_used_capacity_bytes: Optional[_builtins.str] = None,
                 pool_used_iops: Optional[_builtins.str] = None,
                 pool_used_throughput: Optional[_builtins.str] = None,
                 pool_user_written_bytes: Optional[_builtins.str] = None,
                 total_provisioned_disk_capacity_gb: Optional[_builtins.str] = None,
                 total_provisioned_disk_iops: Optional[_builtins.str] = None,
                 total_provisioned_disk_throughput: Optional[_builtins.str] = None):
        """
        :param _builtins.str disk_count: (Output)
               Number of disks used.
        :param _builtins.str last_resize_timestamp: (Output)
               Timestamp of the last successful resize in RFC3339 text format.
        :param _builtins.str max_total_provisioned_disk_capacity_gb: (Output)
               Maximum allowed aggregate disk size in gigabytes.
        :param _builtins.str pool_used_capacity_bytes: (Output)
               Space used by data stored in disks within the storage pool (in bytes).
               This will reflect the total number of bytes written to the disks in the pool, in contrast to the capacity of those disks.
        :param _builtins.str pool_used_iops: (Output)
               Sum of all the disks' provisioned IOPS, minus some amount that is allowed per disk that is not counted towards pool's IOPS capacity. For more information, see https://cloud.google.com/compute/docs/disks/storage-pools.
        :param _builtins.str pool_used_throughput: (Output)
               Sum of all the disks' provisioned throughput in MB/s.
        :param _builtins.str pool_user_written_bytes: (Output)
               Amount of data written into the pool, before it is compacted.
        :param _builtins.str total_provisioned_disk_capacity_gb: (Output)
               Sum of all the capacity provisioned in disks in this storage pool.
               A disk's provisioned capacity is the same as its total capacity.
        :param _builtins.str total_provisioned_disk_iops: (Output)
               Sum of all the disks' provisioned IOPS.
        :param _builtins.str total_provisioned_disk_throughput: (Output)
               Sum of all the disks' provisioned throughput in MB/s,
               minus some amount that is allowed per disk that is not counted towards pool's throughput capacity.
        """
        if disk_count is not None:
            pulumi.set(__self__, "disk_count", disk_count)
        if last_resize_timestamp is not None:
            pulumi.set(__self__, "last_resize_timestamp", last_resize_timestamp)
        if max_total_provisioned_disk_capacity_gb is not None:
            pulumi.set(__self__, "max_total_provisioned_disk_capacity_gb", max_total_provisioned_disk_capacity_gb)
        if pool_used_capacity_bytes is not None:
            pulumi.set(__self__, "pool_used_capacity_bytes", pool_used_capacity_bytes)
        if pool_used_iops is not None:
            pulumi.set(__self__, "pool_used_iops", pool_used_iops)
        if pool_used_throughput is not None:
            pulumi.set(__self__, "pool_used_throughput", pool_used_throughput)
        if pool_user_written_bytes is not None:
            pulumi.set(__self__, "pool_user_written_bytes", pool_user_written_bytes)
        if total_provisioned_disk_capacity_gb is not None:
            pulumi.set(__self__, "total_provisioned_disk_capacity_gb", total_provisioned_disk_capacity_gb)
        if total_provisioned_disk_iops is not None:
            pulumi.set(__self__, "total_provisioned_disk_iops", total_provisioned_disk_iops)
        if total_provisioned_disk_throughput is not None:
            pulumi.set(__self__, "total_provisioned_disk_throughput", total_provisioned_disk_throughput)

    @_builtins.property
    @pulumi.getter(name="diskCount")
    def disk_count(self) -> Optional[_builtins.str]:
        """
        (Output)
        Number of disks used.
        """
        return pulumi.get(self, "disk_count")

    @_builtins.property
    @pulumi.getter(name="lastResizeTimestamp")
    def last_resize_timestamp(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp of the last successful resize in RFC3339 text format.
        """
        return pulumi.get(self, "last_resize_timestamp")

    @_builtins.property
    @pulumi.getter(name="maxTotalProvisionedDiskCapacityGb")
    def max_total_provisioned_disk_capacity_gb(self) -> Optional[_builtins.str]:
        """
        (Output)
        Maximum allowed aggregate disk size in gigabytes.
        """
        return pulumi.get(self, "max_total_provisioned_disk_capacity_gb")

    @_builtins.property
    @pulumi.getter(name="poolUsedCapacityBytes")
    def pool_used_capacity_bytes(self) -> Optional[_builtins.str]:
        """
        (Output)
        Space used by data stored in disks within the storage pool (in bytes).
        This will reflect the total number of bytes written to the disks in the pool, in contrast to the capacity of those disks.
        """
        return pulumi.get(self, "pool_used_capacity_bytes")

    @_builtins.property
    @pulumi.getter(name="poolUsedIops")
    def pool_used_iops(self) -> Optional[_builtins.str]:
        """
        (Output)
        Sum of all the disks' provisioned IOPS, minus some amount that is allowed per disk that is not counted towards pool's IOPS capacity. For more information, see https://cloud.google.com/compute/docs/disks/storage-pools.
        """
        return pulumi.get(self, "pool_used_iops")

    @_builtins.property
    @pulumi.getter(name="poolUsedThroughput")
    def pool_used_throughput(self) -> Optional[_builtins.str]:
        """
        (Output)
        Sum of all the disks' provisioned throughput in MB/s.
        """
        return pulumi.get(self, "pool_used_throughput")

    @_builtins.property
    @pulumi.getter(name="poolUserWrittenBytes")
    def pool_user_written_bytes(self) -> Optional[_builtins.str]:
        """
        (Output)
        Amount of data written into the pool, before it is compacted.
        """
        return pulumi.get(self, "pool_user_written_bytes")

    @_builtins.property
    @pulumi.getter(name="totalProvisionedDiskCapacityGb")
    def total_provisioned_disk_capacity_gb(self) -> Optional[_builtins.str]:
        """
        (Output)
        Sum of all the capacity provisioned in disks in this storage pool.
        A disk's provisioned capacity is the same as its total capacity.
        """
        return pulumi.get(self, "total_provisioned_disk_capacity_gb")

    @_builtins.property
    @pulumi.getter(name="totalProvisionedDiskIops")
    def total_provisioned_disk_iops(self) -> Optional[_builtins.str]:
        """
        (Output)
        Sum of all the disks' provisioned IOPS.
        """
        return pulumi.get(self, "total_provisioned_disk_iops")

    @_builtins.property
    @pulumi.getter(name="totalProvisionedDiskThroughput")
    def total_provisioned_disk_throughput(self) -> Optional[_builtins.str]:
        """
        (Output)
        Sum of all the disks' provisioned throughput in MB/s,
        minus some amount that is allowed per disk that is not counted towards pool's throughput capacity.
        """
        return pulumi.get(self, "total_provisioned_disk_throughput")


@pulumi.output_type
class SubnetworkIAMBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        :param _builtins.str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
               
               > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
               identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
               consider it to be an entirely different resource and will treat it as such.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
        identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
        consider it to be an entirely different resource and will treat it as such.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class SubnetworkIAMMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax.
        :param _builtins.str title: A title for the expression, i.e. a short string describing its purpose.
        :param _builtins.str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
               
               > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
               identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
               consider it to be an entirely different resource and will treat it as such.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
        identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
        consider it to be an entirely different resource and will treat it as such.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class SubnetworkLogConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationInterval":
            suggest = "aggregation_interval"
        elif key == "filterExpr":
            suggest = "filter_expr"
        elif key == "flowSampling":
            suggest = "flow_sampling"
        elif key == "metadataFields":
            suggest = "metadata_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubnetworkLogConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubnetworkLogConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubnetworkLogConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_interval: Optional[_builtins.str] = None,
                 filter_expr: Optional[_builtins.str] = None,
                 flow_sampling: Optional[_builtins.float] = None,
                 metadata: Optional[_builtins.str] = None,
                 metadata_fields: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str aggregation_interval: Can only be specified if VPC flow logging for this subnetwork is enabled.
               Toggles the aggregation interval for collecting flow logs. Increasing the
               interval time will reduce the amount of generated flow logs for long
               lasting connections. Default is an interval of 5 seconds per connection.
               Default value is `INTERVAL_5_SEC`.
               Possible values are: `INTERVAL_5_SEC`, `INTERVAL_30_SEC`, `INTERVAL_1_MIN`, `INTERVAL_5_MIN`, `INTERVAL_10_MIN`, `INTERVAL_15_MIN`.
        :param _builtins.str filter_expr: Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
               https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
               The default value is 'true', which evaluates to include everything.
        :param _builtins.float flow_sampling: Can only be specified if VPC flow logging for this subnetwork is enabled.
               The value of the field must be in [0, 1]. Set the sampling rate of VPC
               flow logs within the subnetwork where 1.0 means all collected logs are
               reported and 0.0 means no logs are reported. Default is 0.5 which means
               half of all collected logs are reported.
        :param _builtins.str metadata: Can only be specified if VPC flow logging for this subnetwork is enabled.
               Configures whether metadata fields should be added to the reported VPC
               flow logs.
               Default value is `INCLUDE_ALL_METADATA`.
               Possible values are: `EXCLUDE_ALL_METADATA`, `INCLUDE_ALL_METADATA`, `CUSTOM_METADATA`.
        :param Sequence[_builtins.str] metadata_fields: List of metadata fields that should be added to reported logs.
               Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.
        """
        if aggregation_interval is not None:
            pulumi.set(__self__, "aggregation_interval", aggregation_interval)
        if filter_expr is not None:
            pulumi.set(__self__, "filter_expr", filter_expr)
        if flow_sampling is not None:
            pulumi.set(__self__, "flow_sampling", flow_sampling)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)

    @_builtins.property
    @pulumi.getter(name="aggregationInterval")
    def aggregation_interval(self) -> Optional[_builtins.str]:
        """
        Can only be specified if VPC flow logging for this subnetwork is enabled.
        Toggles the aggregation interval for collecting flow logs. Increasing the
        interval time will reduce the amount of generated flow logs for long
        lasting connections. Default is an interval of 5 seconds per connection.
        Default value is `INTERVAL_5_SEC`.
        Possible values are: `INTERVAL_5_SEC`, `INTERVAL_30_SEC`, `INTERVAL_1_MIN`, `INTERVAL_5_MIN`, `INTERVAL_10_MIN`, `INTERVAL_15_MIN`.
        """
        return pulumi.get(self, "aggregation_interval")

    @_builtins.property
    @pulumi.getter(name="filterExpr")
    def filter_expr(self) -> Optional[_builtins.str]:
        """
        Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
        https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
        The default value is 'true', which evaluates to include everything.
        """
        return pulumi.get(self, "filter_expr")

    @_builtins.property
    @pulumi.getter(name="flowSampling")
    def flow_sampling(self) -> Optional[_builtins.float]:
        """
        Can only be specified if VPC flow logging for this subnetwork is enabled.
        The value of the field must be in [0, 1]. Set the sampling rate of VPC
        flow logs within the subnetwork where 1.0 means all collected logs are
        reported and 0.0 means no logs are reported. Default is 0.5 which means
        half of all collected logs are reported.
        """
        return pulumi.get(self, "flow_sampling")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[_builtins.str]:
        """
        Can only be specified if VPC flow logging for this subnetwork is enabled.
        Configures whether metadata fields should be added to the reported VPC
        flow logs.
        Default value is `INCLUDE_ALL_METADATA`.
        Possible values are: `EXCLUDE_ALL_METADATA`, `INCLUDE_ALL_METADATA`, `CUSTOM_METADATA`.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of metadata fields that should be added to reported logs.
        Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.
        """
        return pulumi.get(self, "metadata_fields")


@pulumi.output_type
class SubnetworkParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceManagerTags":
            suggest = "resource_manager_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubnetworkParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubnetworkParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubnetworkParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_manager_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the subnetwork. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456. The field is ignored when empty.
               The field is immutable and causes resource replacement when mutated. This field is only
               set at create time and modifying this field after creation will trigger recreation.
               To apply tags to an existing resource, see the tags.TagBinding resource.
        """
        if resource_manager_tags is not None:
            pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource manager tags to be bound to the subnetwork. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456. The field is ignored when empty.
        The field is immutable and causes resource replacement when mutated. This field is only
        set at create time and modifying this field after creation will trigger recreation.
        To apply tags to an existing resource, see the tags.TagBinding resource.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class SubnetworkSecondaryIpRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"
        elif key == "ipCidrRange":
            suggest = "ip_cidr_range"
        elif key == "reservedInternalRange":
            suggest = "reserved_internal_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubnetworkSecondaryIpRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubnetworkSecondaryIpRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubnetworkSecondaryIpRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: _builtins.str,
                 ip_cidr_range: Optional[_builtins.str] = None,
                 reserved_internal_range: Optional[_builtins.str] = None):
        """
        :param _builtins.str range_name: The name associated with this subnetwork secondary range, used
               when adding an alias IP range to a VM instance. The name must
               be 1-63 characters long, and comply with RFC1035. The name
               must be unique within the subnetwork.
        :param _builtins.str ip_cidr_range: The range of IP addresses belonging to this subnetwork secondary
               range. Provide this property when you create the subnetwork.
               Ranges must be unique and non-overlapping with all primary and
               secondary IP ranges within a network. Only IPv4 is supported.
               Field is optional when `reserved_internal_range` is defined, otherwise required.
        :param _builtins.str reserved_internal_range: The ID of the reserved internal range. Must be prefixed with `networkconnectivity.googleapis.com`
               E.g. `networkconnectivity.googleapis.com/projects/{project}/locations/global/internalRanges/{rangeId}`
        """
        pulumi.set(__self__, "range_name", range_name)
        if ip_cidr_range is not None:
            pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        if reserved_internal_range is not None:
            pulumi.set(__self__, "reserved_internal_range", reserved_internal_range)

    @_builtins.property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> _builtins.str:
        """
        The name associated with this subnetwork secondary range, used
        when adding an alias IP range to a VM instance. The name must
        be 1-63 characters long, and comply with RFC1035. The name
        must be unique within the subnetwork.
        """
        return pulumi.get(self, "range_name")

    @_builtins.property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> Optional[_builtins.str]:
        """
        The range of IP addresses belonging to this subnetwork secondary
        range. Provide this property when you create the subnetwork.
        Ranges must be unique and non-overlapping with all primary and
        secondary IP ranges within a network. Only IPv4 is supported.
        Field is optional when `reserved_internal_range` is defined, otherwise required.
        """
        return pulumi.get(self, "ip_cidr_range")

    @_builtins.property
    @pulumi.getter(name="reservedInternalRange")
    def reserved_internal_range(self) -> Optional[_builtins.str]:
        """
        The ID of the reserved internal range. Must be prefixed with `networkconnectivity.googleapis.com`
        E.g. `networkconnectivity.googleapis.com/projects/{project}/locations/global/internalRanges/{rangeId}`
        """
        return pulumi.get(self, "reserved_internal_range")


@pulumi.output_type
class URLMapDefaultCustomErrorResponsePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorResponseRules":
            suggest = "error_response_rules"
        elif key == "errorService":
            suggest = "error_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapDefaultCustomErrorResponsePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapDefaultCustomErrorResponsePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapDefaultCustomErrorResponsePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_response_rules: Optional[Sequence['outputs.URLMapDefaultCustomErrorResponsePolicyErrorResponseRule']] = None,
                 error_service: Optional[_builtins.str] = None):
        """
        :param Sequence['URLMapDefaultCustomErrorResponsePolicyErrorResponseRuleArgs'] error_response_rules: Specifies rules for returning error responses.
               In a given policy, if you specify rules for both a range of error codes as well as rules for specific error codes then rules with specific error codes have a higher priority.
               For example, assume that you configure a rule for 401 (Un-authorized) code, and another for all 4 series error codes (4XX).
               If the backend service returns a 401, then the rule for 401 will be applied. However if the backend service returns a 403, the rule for 4xx takes effect.
               Structure is documented below.
        :param _builtins.str error_service: The full or partial URL to the BackendBucket resource that contains the custom error content. Examples are:
               https://www.googleapis.com/compute/v1/projects/project/global/backendBuckets/myBackendBucket
               compute/v1/projects/project/global/backendBuckets/myBackendBucket
               global/backendBuckets/myBackendBucket
               If errorService is not specified at lower levels like pathMatcher, pathRule and routeRule, an errorService specified at a higher level in the UrlMap will be used. If UrlMap.defaultCustomErrorResponsePolicy contains one or more errorResponseRules[], it must specify errorService.
               If load balancer cannot reach the backendBucket, a simple Not Found Error will be returned, with the original response code (or overrideResponseCode if configured).
        """
        if error_response_rules is not None:
            pulumi.set(__self__, "error_response_rules", error_response_rules)
        if error_service is not None:
            pulumi.set(__self__, "error_service", error_service)

    @_builtins.property
    @pulumi.getter(name="errorResponseRules")
    def error_response_rules(self) -> Optional[Sequence['outputs.URLMapDefaultCustomErrorResponsePolicyErrorResponseRule']]:
        """
        Specifies rules for returning error responses.
        In a given policy, if you specify rules for both a range of error codes as well as rules for specific error codes then rules with specific error codes have a higher priority.
        For example, assume that you configure a rule for 401 (Un-authorized) code, and another for all 4 series error codes (4XX).
        If the backend service returns a 401, then the rule for 401 will be applied. However if the backend service returns a 403, the rule for 4xx takes effect.
        Structure is documented below.
        """
        return pulumi.get(self, "error_response_rules")

    @_builtins.property
    @pulumi.getter(name="errorService")
    def error_service(self) -> Optional[_builtins.str]:
        """
        The full or partial URL to the BackendBucket resource that contains the custom error content. Examples are:
        https://www.googleapis.com/compute/v1/projects/project/global/backendBuckets/myBackendBucket
        compute/v1/projects/project/global/backendBuckets/myBackendBucket
        global/backendBuckets/myBackendBucket
        If errorService is not specified at lower levels like pathMatcher, pathRule and routeRule, an errorService specified at a higher level in the UrlMap will be used. If UrlMap.defaultCustomErrorResponsePolicy contains one or more errorResponseRules[], it must specify errorService.
        If load balancer cannot reach the backendBucket, a simple Not Found Error will be returned, with the original response code (or overrideResponseCode if configured).
        """
        return pulumi.get(self, "error_service")


@pulumi.output_type
class URLMapDefaultCustomErrorResponsePolicyErrorResponseRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchResponseCodes":
            suggest = "match_response_codes"
        elif key == "overrideResponseCode":
            suggest = "override_response_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapDefaultCustomErrorResponsePolicyErrorResponseRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapDefaultCustomErrorResponsePolicyErrorResponseRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapDefaultCustomErrorResponsePolicyErrorResponseRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_response_codes: Optional[Sequence[_builtins.str]] = None,
                 override_response_code: Optional[_builtins.int] = None,
                 path: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] match_response_codes: Valid values include:
               - A number between 400 and 599: For example 401 or 503, in which case the load balancer applies the policy if the error code exactly matches this value.
               - 5xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 500 to 599.
               - 4xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 400 to 499.
               Values must be unique within matchResponseCodes and across all errorResponseRules of CustomErrorResponsePolicy.
        :param _builtins.int override_response_code: The HTTP status code returned with the response containing the custom error content.
               If overrideResponseCode is not supplied, the same response code returned by the original backend bucket or backend service is returned to the client.
        :param _builtins.str path: The full path to a file within backendBucket. For example: /errors/defaultError.html
               path must start with a leading slash. path cannot have trailing slashes.
               If the file is not available in backendBucket or the load balancer cannot reach the BackendBucket, a simple Not Found Error is returned to the client.
               The value must be from 1 to 1024 characters.
        """
        if match_response_codes is not None:
            pulumi.set(__self__, "match_response_codes", match_response_codes)
        if override_response_code is not None:
            pulumi.set(__self__, "override_response_code", override_response_code)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="matchResponseCodes")
    def match_response_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Valid values include:
        - A number between 400 and 599: For example 401 or 503, in which case the load balancer applies the policy if the error code exactly matches this value.
        - 5xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 500 to 599.
        - 4xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 400 to 499.
        Values must be unique within matchResponseCodes and across all errorResponseRules of CustomErrorResponsePolicy.
        """
        return pulumi.get(self, "match_response_codes")

    @_builtins.property
    @pulumi.getter(name="overrideResponseCode")
    def override_response_code(self) -> Optional[_builtins.int]:
        """
        The HTTP status code returned with the response containing the custom error content.
        If overrideResponseCode is not supplied, the same response code returned by the original backend bucket or backend service is returned to the client.
        """
        return pulumi.get(self, "override_response_code")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        The full path to a file within backendBucket. For example: /errors/defaultError.html
        path must start with a leading slash. path cannot have trailing slashes.
        If the file is not available in backendBucket or the load balancer cannot reach the BackendBucket, a simple Not Found Error is returned to the client.
        The value must be from 1 to 1024 characters.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class URLMapDefaultRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "corsPolicy":
            suggest = "cors_policy"
        elif key == "faultInjectionPolicy":
            suggest = "fault_injection_policy"
        elif key == "maxStreamDuration":
            suggest = "max_stream_duration"
        elif key == "requestMirrorPolicy":
            suggest = "request_mirror_policy"
        elif key == "retryPolicy":
            suggest = "retry_policy"
        elif key == "urlRewrite":
            suggest = "url_rewrite"
        elif key == "weightedBackendServices":
            suggest = "weighted_backend_services"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapDefaultRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapDefaultRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapDefaultRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cors_policy: Optional['outputs.URLMapDefaultRouteActionCorsPolicy'] = None,
                 fault_injection_policy: Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicy'] = None,
                 max_stream_duration: Optional['outputs.URLMapDefaultRouteActionMaxStreamDuration'] = None,
                 request_mirror_policy: Optional['outputs.URLMapDefaultRouteActionRequestMirrorPolicy'] = None,
                 retry_policy: Optional['outputs.URLMapDefaultRouteActionRetryPolicy'] = None,
                 timeout: Optional['outputs.URLMapDefaultRouteActionTimeout'] = None,
                 url_rewrite: Optional['outputs.URLMapDefaultRouteActionUrlRewrite'] = None,
                 weighted_backend_services: Optional[Sequence['outputs.URLMapDefaultRouteActionWeightedBackendService']] = None):
        """
        :param 'URLMapDefaultRouteActionCorsPolicyArgs' cors_policy: The specification for allowing client side cross-origin requests. Please see
               [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
               Structure is documented below.
        :param 'URLMapDefaultRouteActionFaultInjectionPolicyArgs' fault_injection_policy: The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
               As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
               percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
               by the Loadbalancer for a percentage of requests.
               timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
               Structure is documented below.
        :param 'URLMapDefaultRouteActionMaxStreamDurationArgs' max_stream_duration: Specifies the maximum duration (timeout) for streams on the selected route.
               Unlike the `Timeout` field where the timeout duration starts from the time the request
               has been fully processed (known as end-of-stream), the duration in this field
               is computed from the beginning of the stream until the response has been processed,
               including all retries. A stream that does not complete in this duration is closed.
               Structure is documented below.
        :param 'URLMapDefaultRouteActionRequestMirrorPolicyArgs' request_mirror_policy: Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
               Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
               the host / authority header is suffixed with -shadow.
               Structure is documented below.
        :param 'URLMapDefaultRouteActionRetryPolicyArgs' retry_policy: Specifies the retry policy associated with this route.
               Structure is documented below.
        :param 'URLMapDefaultRouteActionTimeoutArgs' timeout: Specifies the timeout for the selected route. Timeout is computed from the time the request has been
               fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
               If not specified, will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param 'URLMapDefaultRouteActionUrlRewriteArgs' url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to the matched service.
               Structure is documented below.
        :param Sequence['URLMapDefaultRouteActionWeightedBackendServiceArgs'] weighted_backend_services: A list of weighted backend services to send traffic to when a route match occurs.
               The weights determine the fraction of traffic that flows to their corresponding backend service.
               If all traffic needs to go to a single backend service, there must be one weightedBackendService
               with weight set to a non 0 number.
               Once a backendService is identified and before forwarding the request to the backend service,
               advanced routing actions like Url rewrites and header transformations are applied depending on
               additional settings specified in this HttpRouteAction.
               Structure is documented below.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if fault_injection_policy is not None:
            pulumi.set(__self__, "fault_injection_policy", fault_injection_policy)
        if max_stream_duration is not None:
            pulumi.set(__self__, "max_stream_duration", max_stream_duration)
        if request_mirror_policy is not None:
            pulumi.set(__self__, "request_mirror_policy", request_mirror_policy)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)
        if weighted_backend_services is not None:
            pulumi.set(__self__, "weighted_backend_services", weighted_backend_services)

    @_builtins.property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.URLMapDefaultRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see
        [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
        Structure is documented below.
        """
        return pulumi.get(self, "cors_policy")

    @_builtins.property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
        As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
        percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
        by the Loadbalancer for a percentage of requests.
        timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
        Structure is documented below.
        """
        return pulumi.get(self, "fault_injection_policy")

    @_builtins.property
    @pulumi.getter(name="maxStreamDuration")
    def max_stream_duration(self) -> Optional['outputs.URLMapDefaultRouteActionMaxStreamDuration']:
        """
        Specifies the maximum duration (timeout) for streams on the selected route.
        Unlike the `Timeout` field where the timeout duration starts from the time the request
        has been fully processed (known as end-of-stream), the duration in this field
        is computed from the beginning of the stream until the response has been processed,
        including all retries. A stream that does not complete in this duration is closed.
        Structure is documented below.
        """
        return pulumi.get(self, "max_stream_duration")

    @_builtins.property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.URLMapDefaultRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
        Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
        the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        return pulumi.get(self, "request_mirror_policy")

    @_builtins.property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.URLMapDefaultRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        return pulumi.get(self, "retry_policy")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.URLMapDefaultRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time the request has been
        fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
        If not specified, will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.URLMapDefaultRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to the matched service.
        Structure is documented below.
        """
        return pulumi.get(self, "url_rewrite")

    @_builtins.property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[Sequence['outputs.URLMapDefaultRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match occurs.
        The weights determine the fraction of traffic that flows to their corresponding backend service.
        If all traffic needs to go to a single backend service, there must be one weightedBackendService
        with weight set to a non 0 number.
        Once a backendService is identified and before forwarding the request to the backend service,
        advanced routing actions like Url rewrites and header transformations are applied depending on
        additional settings specified in this HttpRouteAction.
        Structure is documented below.
        """
        return pulumi.get(self, "weighted_backend_services")


@pulumi.output_type
class URLMapDefaultRouteActionCorsPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOriginRegexes":
            suggest = "allow_origin_regexes"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapDefaultRouteActionCorsPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapDefaultRouteActionCorsPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapDefaultRouteActionCorsPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origin_regexes: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional[Sequence[_builtins.str]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        :param _builtins.bool allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
               This translates to the Access-Control-Allow-Credentials header.
        :param Sequence[_builtins.str] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param Sequence[_builtins.str] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param Sequence[_builtins.str] allow_origin_regexes: Specifies the regular expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[_builtins.str] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param _builtins.bool disabled: If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        :param Sequence[_builtins.str] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param _builtins.int max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin_regexes is not None:
            pulumi.set(__self__, "allow_origin_regexes", allow_origin_regexes)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
        This translates to the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the regular expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origin_regexes")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class URLMapDefaultRouteActionFaultInjectionPolicy(dict):
    def __init__(__self__, *,
                 abort: Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyAbort'] = None,
                 delay: Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyDelay'] = None):
        """
        :param 'URLMapDefaultRouteActionFaultInjectionPolicyAbortArgs' abort: The specification for how client requests are aborted as part of fault injection.
               Structure is documented below.
        :param 'URLMapDefaultRouteActionFaultInjectionPolicyDelayArgs' delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
               Structure is documented below.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def abort(self) -> Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        return pulumi.get(self, "abort")

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class URLMapDefaultRouteActionFaultInjectionPolicyAbort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpStatus":
            suggest = "http_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapDefaultRouteActionFaultInjectionPolicyAbort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapDefaultRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapDefaultRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_status: Optional[_builtins.int] = None,
                 percentage: Optional[_builtins.float] = None):
        """
        :param _builtins.int http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if http_status is not None:
            pulumi.set(__self__, "http_status", http_status)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[_builtins.int]:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        return pulumi.get(self, "http_status")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class URLMapDefaultRouteActionFaultInjectionPolicyDelay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedDelay":
            suggest = "fixed_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapDefaultRouteActionFaultInjectionPolicyDelay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapDefaultRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapDefaultRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_delay: Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay'] = None,
                 percentage: Optional[_builtins.float] = None):
        """
        :param 'URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelayArgs' fixed_delay: Specifies the value of the fixed delay interval.
               Structure is documented below.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if fixed_delay is not None:
            pulumi.set(__self__, "fixed_delay", fixed_delay)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> Optional['outputs.URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay']:
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_delay")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class URLMapDefaultRouteActionMaxStreamDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class URLMapDefaultRouteActionRequestMirrorPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "mirrorPercent":
            suggest = "mirror_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapDefaultRouteActionRequestMirrorPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapDefaultRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapDefaultRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: _builtins.str,
                 mirror_percent: Optional[_builtins.float] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the BackendService resource being mirrored to.
        :param _builtins.float mirror_percent: The percentage of requests to be mirrored to backendService.
               The value must be between 0.0 and 100.0 inclusive.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        if mirror_percent is not None:
            pulumi.set(__self__, "mirror_percent", mirror_percent)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> _builtins.str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter(name="mirrorPercent")
    def mirror_percent(self) -> Optional[_builtins.float]:
        """
        The percentage of requests to be mirrored to backendService.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "mirror_percent")


@pulumi.output_type
class URLMapDefaultRouteActionRetryPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numRetries":
            suggest = "num_retries"
        elif key == "perTryTimeout":
            suggest = "per_try_timeout"
        elif key == "retryConditions":
            suggest = "retry_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapDefaultRouteActionRetryPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapDefaultRouteActionRetryPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapDefaultRouteActionRetryPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_retries: Optional[_builtins.int] = None,
                 per_try_timeout: Optional['outputs.URLMapDefaultRouteActionRetryPolicyPerTryTimeout'] = None,
                 retry_conditions: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param 'URLMapDefaultRouteActionRetryPolicyPerTryTimeoutArgs' per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param Sequence[_builtins.str] retry_conditions: Specfies one or more conditions when this retry rule applies. Valid values are:
               * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
               or if the backend service does not respond at all, example: disconnects, reset, read timeout,
               * connection failure, and refused streams.
               * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
               * connect-failure: Loadbalancer will retry on failures connecting to backend services,
               for example due to connection timeouts.
               * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
               This reset type indicates that it is safe to retry.
               * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
               * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
               * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
               * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_conditions is not None:
            pulumi.set(__self__, "retry_conditions", retry_conditions)

    @_builtins.property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[_builtins.int]:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        return pulumi.get(self, "num_retries")

    @_builtins.property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.URLMapDefaultRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "per_try_timeout")

    @_builtins.property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specfies one or more conditions when this retry rule applies. Valid values are:
        * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
        or if the backend service does not respond at all, example: disconnects, reset, read timeout,
        * connection failure, and refused streams.
        * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
        * connect-failure: Loadbalancer will retry on failures connecting to backend services,
        for example due to connection timeouts.
        * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
        This reset type indicates that it is safe to retry.
        * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
        * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
        * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
        * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        return pulumi.get(self, "retry_conditions")


@pulumi.output_type
class URLMapDefaultRouteActionRetryPolicyPerTryTimeout(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class URLMapDefaultRouteActionTimeout(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class URLMapDefaultRouteActionUrlRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostRewrite":
            suggest = "host_rewrite"
        elif key == "pathPrefixRewrite":
            suggest = "path_prefix_rewrite"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapDefaultRouteActionUrlRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapDefaultRouteActionUrlRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapDefaultRouteActionUrlRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_rewrite: Optional[_builtins.str] = None,
                 path_prefix_rewrite: Optional[_builtins.str] = None):
        """
        :param _builtins.str host_rewrite: Prior to forwarding the request to the selected service, the request's host header is replaced
               with contents of hostRewrite.
               The value must be between 1 and 255 characters.
        :param _builtins.str path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching portion of the
               request's path is replaced by pathPrefixRewrite.
               The value must be between 1 and 1024 characters.
        """
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if path_prefix_rewrite is not None:
            pulumi.set(__self__, "path_prefix_rewrite", path_prefix_rewrite)

    @_builtins.property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[_builtins.str]:
        """
        Prior to forwarding the request to the selected service, the request's host header is replaced
        with contents of hostRewrite.
        The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_rewrite")

    @_builtins.property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[_builtins.str]:
        """
        Prior to forwarding the request to the selected backend service, the matching portion of the
        request's path is replaced by pathPrefixRewrite.
        The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "path_prefix_rewrite")


@pulumi.output_type
class URLMapDefaultRouteActionWeightedBackendService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "headerAction":
            suggest = "header_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapDefaultRouteActionWeightedBackendService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapDefaultRouteActionWeightedBackendService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapDefaultRouteActionWeightedBackendService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: Optional[_builtins.str] = None,
                 header_action: Optional['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderAction'] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the default BackendService resource. Before forwarding the
               request to backendService, the loadbalancer applies any relevant headerActions
               specified as part of this backendServiceWeight.
        :param 'URLMapDefaultRouteActionWeightedBackendServiceHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.
               Structure is documented below.
        :param _builtins.int weight: Specifies the fraction of traffic sent to backendService, computed as
               weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request
               has been directed to a backendService, subsequent requests will be sent to the same backendService
               as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        """
        if backend_service is not None:
            pulumi.set(__self__, "backend_service", backend_service)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> Optional[_builtins.str]:
        """
        The full or partial URL to the default BackendService resource. Before forwarding the
        request to backendService, the loadbalancer applies any relevant headerActions
        specified as part of this backendServiceWeight.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Specifies the fraction of traffic sent to backendService, computed as
        weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request
        has been directed to a backendService, subsequent requests will be sent to the same backendService
        as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class URLMapDefaultRouteActionWeightedBackendServiceHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"
        elif key == "requestHeadersToRemoves":
            suggest = "request_headers_to_removes"
        elif key == "responseHeadersToAdds":
            suggest = "response_headers_to_adds"
        elif key == "responseHeadersToRemoves":
            suggest = "response_headers_to_removes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapDefaultRouteActionWeightedBackendServiceHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapDefaultRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapDefaultRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[_builtins.str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[_builtins.str] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param Sequence['URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[_builtins.str] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")


@pulumi.output_type
class URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[_builtins.str] = None,
                 header_value: Optional[_builtins.str] = None,
                 replace: Optional[_builtins.bool] = None):
        """
        :param _builtins.str header_name: The name of the header to add.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.bool]:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[_builtins.str] = None,
                 header_value: Optional[_builtins.str] = None,
                 replace: Optional[_builtins.bool] = None):
        """
        :param _builtins.str header_name: The name of the header to add.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.bool]:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class URLMapDefaultUrlRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stripQuery":
            suggest = "strip_query"
        elif key == "hostRedirect":
            suggest = "host_redirect"
        elif key == "httpsRedirect":
            suggest = "https_redirect"
        elif key == "pathRedirect":
            suggest = "path_redirect"
        elif key == "prefixRedirect":
            suggest = "prefix_redirect"
        elif key == "redirectResponseCode":
            suggest = "redirect_response_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapDefaultUrlRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapDefaultUrlRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapDefaultUrlRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 strip_query: _builtins.bool,
                 host_redirect: Optional[_builtins.str] = None,
                 https_redirect: Optional[_builtins.bool] = None,
                 path_redirect: Optional[_builtins.str] = None,
                 prefix_redirect: Optional[_builtins.str] = None,
                 redirect_response_code: Optional[_builtins.str] = None):
        """
        :param _builtins.bool strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained. The default is set to false.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param _builtins.str host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param _builtins.bool https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param _builtins.str path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param _builtins.str prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param _builtins.str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        pulumi.set(__self__, "strip_query", strip_query)
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)

    @_builtins.property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> _builtins.bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained. The default is set to false.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        return pulumi.get(self, "strip_query")

    @_builtins.property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[_builtins.str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_redirect")

    @_builtins.property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[_builtins.bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        return pulumi.get(self, "https_redirect")

    @_builtins.property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[_builtins.str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        return pulumi.get(self, "path_redirect")

    @_builtins.property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[_builtins.str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "prefix_redirect")

    @_builtins.property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[_builtins.str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")


@pulumi.output_type
class URLMapHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"
        elif key == "requestHeadersToRemoves":
            suggest = "request_headers_to_removes"
        elif key == "responseHeadersToAdds":
            suggest = "response_headers_to_adds"
        elif key == "responseHeadersToRemoves":
            suggest = "response_headers_to_removes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.URLMapHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[_builtins.str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.URLMapHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['URLMapHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[_builtins.str] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param Sequence['URLMapHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[_builtins.str] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")


@pulumi.output_type
class URLMapHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header to add.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class URLMapHeaderActionResponseHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapHeaderActionResponseHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header to add.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class URLMapHostRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathMatcher":
            suggest = "path_matcher"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapHostRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapHostRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapHostRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Sequence[_builtins.str],
                 path_matcher: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] hosts: The list of host patterns to match. They must be valid hostnames, except * will
               match any string of ([a-z0-9-.]*). In that case, * must be the first character
               and must be followed in the pattern by either - or ..
        :param _builtins.str path_matcher: The name of the PathMatcher to use to match the path portion of the URL if the
               hostRule matches the URL's host portion.
        :param _builtins.str description: An optional description of this resource. Provide this property when you create
               the resource.
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "path_matcher", path_matcher)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence[_builtins.str]:
        """
        The list of host patterns to match. They must be valid hostnames, except * will
        match any string of ([a-z0-9-.]*). In that case, * must be the first character
        and must be followed in the pattern by either - or ..
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="pathMatcher")
    def path_matcher(self) -> _builtins.str:
        """
        The name of the PathMatcher to use to match the path portion of the URL if the
        hostRule matches the URL's host portion.
        """
        return pulumi.get(self, "path_matcher")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resource. Provide this property when you create
        the resource.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class URLMapPathMatcher(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultCustomErrorResponsePolicy":
            suggest = "default_custom_error_response_policy"
        elif key == "defaultRouteAction":
            suggest = "default_route_action"
        elif key == "defaultService":
            suggest = "default_service"
        elif key == "defaultUrlRedirect":
            suggest = "default_url_redirect"
        elif key == "headerAction":
            suggest = "header_action"
        elif key == "pathRules":
            suggest = "path_rules"
        elif key == "routeRules":
            suggest = "route_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcher. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcher.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcher.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 default_custom_error_response_policy: Optional['outputs.URLMapPathMatcherDefaultCustomErrorResponsePolicy'] = None,
                 default_route_action: Optional['outputs.URLMapPathMatcherDefaultRouteAction'] = None,
                 default_service: Optional[_builtins.str] = None,
                 default_url_redirect: Optional['outputs.URLMapPathMatcherDefaultUrlRedirect'] = None,
                 description: Optional[_builtins.str] = None,
                 header_action: Optional['outputs.URLMapPathMatcherHeaderAction'] = None,
                 path_rules: Optional[Sequence['outputs.URLMapPathMatcherPathRule']] = None,
                 route_rules: Optional[Sequence['outputs.URLMapPathMatcherRouteRule']] = None):
        """
        :param _builtins.str name: The name to which this PathMatcher is referred by the HostRule.
        :param 'URLMapPathMatcherDefaultCustomErrorResponsePolicyArgs' default_custom_error_response_policy: defaultCustomErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
               This policy takes effect at the PathMatcher level and applies only when no policy has been defined for the error code at lower levels like RouteRule and PathRule within this PathMatcher. If an error code does not have a policy defined in defaultCustomErrorResponsePolicy, then a policy defined for the error code in UrlMap.defaultCustomErrorResponsePolicy takes effect.
               For example, consider a UrlMap with the following configuration:
               UrlMap.defaultCustomErrorResponsePolicy is configured with policies for 5xx and 4xx errors
               A RouteRule for /coming_soon/ is configured for the error code 404.
               If the request is for www.myotherdomain.com and a 404 is encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404 response is encountered for the request www.example.com/current_events/, the pathMatcher's policy takes effect. If however, the request for www.example.com/coming_soon/ encounters a 404, the policy in RouteRule.customErrorResponsePolicy takes effect. If any of the requests in this example encounter a 500 error code, the policy at UrlMap.defaultCustomErrorResponsePolicy takes effect.
               When used in conjunction with pathMatcher.defaultRouteAction.retryPolicy, retries take precedence. Only once all retries are exhausted, the defaultCustomErrorResponsePolicy is applied. While attempting a retry, if load balancer is successful in reaching the service, the defaultCustomErrorResponsePolicy is ignored and the response from the service is returned to the client.
               defaultCustomErrorResponsePolicy is supported only for global external Application Load Balancers.
               Structure is documented below.
        :param 'URLMapPathMatcherDefaultRouteActionArgs' default_route_action: defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
               advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
               to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
               Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
               Only one of defaultRouteAction or defaultUrlRedirect must be set.
               Structure is documented below.
        :param _builtins.str default_service: The backend service or backend bucket to use when none of the given paths match.
        :param 'URLMapPathMatcherDefaultUrlRedirectArgs' default_url_redirect: When none of the specified hostRules match, the request is redirected to a URL specified
               by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
               defaultRouteAction must not be set.
               Structure is documented below.
        :param _builtins.str description: An optional description of this resource. Provide this property when you create
               the resource.
        :param 'URLMapPathMatcherHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService. HeaderAction specified here are applied after the
               matching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap
               Structure is documented below.
        :param Sequence['URLMapPathMatcherPathRuleArgs'] path_rules: The list of path rules. Use this list instead of routeRules when routing based
               on simple path matching is all that's required. The order by which path rules
               are specified does not matter. Matches are always done on the longest-path-first
               basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
               irrespective of the order in which those paths appear in this list. Within a
               given pathMatcher, only one of pathRules or routeRules must be set.
               Structure is documented below.
        :param Sequence['URLMapPathMatcherRouteRuleArgs'] route_rules: The list of ordered HTTP route rules. Use this list instead of pathRules when
               advanced route matching and routing actions are desired. The order of specifying
               routeRules matters: the first rule that matches will cause its specified routing
               action to take effect. Within a given pathMatcher, only one of pathRules or
               routeRules must be set. routeRules are not supported in UrlMaps intended for
               External load balancers.
               Structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        if default_custom_error_response_policy is not None:
            pulumi.set(__self__, "default_custom_error_response_policy", default_custom_error_response_policy)
        if default_route_action is not None:
            pulumi.set(__self__, "default_route_action", default_route_action)
        if default_service is not None:
            pulumi.set(__self__, "default_service", default_service)
        if default_url_redirect is not None:
            pulumi.set(__self__, "default_url_redirect", default_url_redirect)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)
        if path_rules is not None:
            pulumi.set(__self__, "path_rules", path_rules)
        if route_rules is not None:
            pulumi.set(__self__, "route_rules", route_rules)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name to which this PathMatcher is referred by the HostRule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="defaultCustomErrorResponsePolicy")
    def default_custom_error_response_policy(self) -> Optional['outputs.URLMapPathMatcherDefaultCustomErrorResponsePolicy']:
        """
        defaultCustomErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
        This policy takes effect at the PathMatcher level and applies only when no policy has been defined for the error code at lower levels like RouteRule and PathRule within this PathMatcher. If an error code does not have a policy defined in defaultCustomErrorResponsePolicy, then a policy defined for the error code in UrlMap.defaultCustomErrorResponsePolicy takes effect.
        For example, consider a UrlMap with the following configuration:
        UrlMap.defaultCustomErrorResponsePolicy is configured with policies for 5xx and 4xx errors
        A RouteRule for /coming_soon/ is configured for the error code 404.
        If the request is for www.myotherdomain.com and a 404 is encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404 response is encountered for the request www.example.com/current_events/, the pathMatcher's policy takes effect. If however, the request for www.example.com/coming_soon/ encounters a 404, the policy in RouteRule.customErrorResponsePolicy takes effect. If any of the requests in this example encounter a 500 error code, the policy at UrlMap.defaultCustomErrorResponsePolicy takes effect.
        When used in conjunction with pathMatcher.defaultRouteAction.retryPolicy, retries take precedence. Only once all retries are exhausted, the defaultCustomErrorResponsePolicy is applied. While attempting a retry, if load balancer is successful in reaching the service, the defaultCustomErrorResponsePolicy is ignored and the response from the service is returned to the client.
        defaultCustomErrorResponsePolicy is supported only for global external Application Load Balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "default_custom_error_response_policy")

    @_builtins.property
    @pulumi.getter(name="defaultRouteAction")
    def default_route_action(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteAction']:
        """
        defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
        advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
        to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
        Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
        Only one of defaultRouteAction or defaultUrlRedirect must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "default_route_action")

    @_builtins.property
    @pulumi.getter(name="defaultService")
    def default_service(self) -> Optional[_builtins.str]:
        """
        The backend service or backend bucket to use when none of the given paths match.
        """
        return pulumi.get(self, "default_service")

    @_builtins.property
    @pulumi.getter(name="defaultUrlRedirect")
    def default_url_redirect(self) -> Optional['outputs.URLMapPathMatcherDefaultUrlRedirect']:
        """
        When none of the specified hostRules match, the request is redirected to a URL specified
        by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
        defaultRouteAction must not be set.
        Structure is documented below.
        """
        return pulumi.get(self, "default_url_redirect")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        An optional description of this resource. Provide this property when you create
        the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService. HeaderAction specified here are applied after the
        matching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    @_builtins.property
    @pulumi.getter(name="pathRules")
    def path_rules(self) -> Optional[Sequence['outputs.URLMapPathMatcherPathRule']]:
        """
        The list of path rules. Use this list instead of routeRules when routing based
        on simple path matching is all that's required. The order by which path rules
        are specified does not matter. Matches are always done on the longest-path-first
        basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
        irrespective of the order in which those paths appear in this list. Within a
        given pathMatcher, only one of pathRules or routeRules must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "path_rules")

    @_builtins.property
    @pulumi.getter(name="routeRules")
    def route_rules(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRule']]:
        """
        The list of ordered HTTP route rules. Use this list instead of pathRules when
        advanced route matching and routing actions are desired. The order of specifying
        routeRules matters: the first rule that matches will cause its specified routing
        action to take effect. Within a given pathMatcher, only one of pathRules or
        routeRules must be set. routeRules are not supported in UrlMaps intended for
        External load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "route_rules")


@pulumi.output_type
class URLMapPathMatcherDefaultCustomErrorResponsePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorResponseRules":
            suggest = "error_response_rules"
        elif key == "errorService":
            suggest = "error_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherDefaultCustomErrorResponsePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherDefaultCustomErrorResponsePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherDefaultCustomErrorResponsePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_response_rules: Optional[Sequence['outputs.URLMapPathMatcherDefaultCustomErrorResponsePolicyErrorResponseRule']] = None,
                 error_service: Optional[_builtins.str] = None):
        """
        :param Sequence['URLMapPathMatcherDefaultCustomErrorResponsePolicyErrorResponseRuleArgs'] error_response_rules: Specifies rules for returning error responses.
               In a given policy, if you specify rules for both a range of error codes as well as rules for specific error codes then rules with specific error codes have a higher priority.
               For example, assume that you configure a rule for 401 (Un-authorized) code, and another for all 4 series error codes (4XX).
               If the backend service returns a 401, then the rule for 401 will be applied. However if the backend service returns a 403, the rule for 4xx takes effect.
               Structure is documented below.
        :param _builtins.str error_service: The full or partial URL to the BackendBucket resource that contains the custom error content. Examples are:
               https://www.googleapis.com/compute/v1/projects/project/global/backendBuckets/myBackendBucket
               compute/v1/projects/project/global/backendBuckets/myBackendBucket
               global/backendBuckets/myBackendBucket
               If errorService is not specified at lower levels like pathMatcher, pathRule and routeRule, an errorService specified at a higher level in the UrlMap will be used. If UrlMap.defaultCustomErrorResponsePolicy contains one or more errorResponseRules[], it must specify errorService.
               If load balancer cannot reach the backendBucket, a simple Not Found Error will be returned, with the original response code (or overrideResponseCode if configured).
        """
        if error_response_rules is not None:
            pulumi.set(__self__, "error_response_rules", error_response_rules)
        if error_service is not None:
            pulumi.set(__self__, "error_service", error_service)

    @_builtins.property
    @pulumi.getter(name="errorResponseRules")
    def error_response_rules(self) -> Optional[Sequence['outputs.URLMapPathMatcherDefaultCustomErrorResponsePolicyErrorResponseRule']]:
        """
        Specifies rules for returning error responses.
        In a given policy, if you specify rules for both a range of error codes as well as rules for specific error codes then rules with specific error codes have a higher priority.
        For example, assume that you configure a rule for 401 (Un-authorized) code, and another for all 4 series error codes (4XX).
        If the backend service returns a 401, then the rule for 401 will be applied. However if the backend service returns a 403, the rule for 4xx takes effect.
        Structure is documented below.
        """
        return pulumi.get(self, "error_response_rules")

    @_builtins.property
    @pulumi.getter(name="errorService")
    def error_service(self) -> Optional[_builtins.str]:
        """
        The full or partial URL to the BackendBucket resource that contains the custom error content. Examples are:
        https://www.googleapis.com/compute/v1/projects/project/global/backendBuckets/myBackendBucket
        compute/v1/projects/project/global/backendBuckets/myBackendBucket
        global/backendBuckets/myBackendBucket
        If errorService is not specified at lower levels like pathMatcher, pathRule and routeRule, an errorService specified at a higher level in the UrlMap will be used. If UrlMap.defaultCustomErrorResponsePolicy contains one or more errorResponseRules[], it must specify errorService.
        If load balancer cannot reach the backendBucket, a simple Not Found Error will be returned, with the original response code (or overrideResponseCode if configured).
        """
        return pulumi.get(self, "error_service")


@pulumi.output_type
class URLMapPathMatcherDefaultCustomErrorResponsePolicyErrorResponseRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchResponseCodes":
            suggest = "match_response_codes"
        elif key == "overrideResponseCode":
            suggest = "override_response_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherDefaultCustomErrorResponsePolicyErrorResponseRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherDefaultCustomErrorResponsePolicyErrorResponseRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherDefaultCustomErrorResponsePolicyErrorResponseRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_response_codes: Optional[Sequence[_builtins.str]] = None,
                 override_response_code: Optional[_builtins.int] = None,
                 path: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] match_response_codes: Valid values include:
               - A number between 400 and 599: For example 401 or 503, in which case the load balancer applies the policy if the error code exactly matches this value.
               - 5xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 500 to 599.
               - 4xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 400 to 499.
               Values must be unique within matchResponseCodes and across all errorResponseRules of CustomErrorResponsePolicy.
        :param _builtins.int override_response_code: The HTTP status code returned with the response containing the custom error content.
               If overrideResponseCode is not supplied, the same response code returned by the original backend bucket or backend service is returned to the client.
        :param _builtins.str path: The full path to a file within backendBucket. For example: /errors/defaultError.html
               path must start with a leading slash. path cannot have trailing slashes.
               If the file is not available in backendBucket or the load balancer cannot reach the BackendBucket, a simple Not Found Error is returned to the client.
               The value must be from 1 to 1024 characters.
        """
        if match_response_codes is not None:
            pulumi.set(__self__, "match_response_codes", match_response_codes)
        if override_response_code is not None:
            pulumi.set(__self__, "override_response_code", override_response_code)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="matchResponseCodes")
    def match_response_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Valid values include:
        - A number between 400 and 599: For example 401 or 503, in which case the load balancer applies the policy if the error code exactly matches this value.
        - 5xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 500 to 599.
        - 4xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 400 to 499.
        Values must be unique within matchResponseCodes and across all errorResponseRules of CustomErrorResponsePolicy.
        """
        return pulumi.get(self, "match_response_codes")

    @_builtins.property
    @pulumi.getter(name="overrideResponseCode")
    def override_response_code(self) -> Optional[_builtins.int]:
        """
        The HTTP status code returned with the response containing the custom error content.
        If overrideResponseCode is not supplied, the same response code returned by the original backend bucket or backend service is returned to the client.
        """
        return pulumi.get(self, "override_response_code")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        The full path to a file within backendBucket. For example: /errors/defaultError.html
        path must start with a leading slash. path cannot have trailing slashes.
        If the file is not available in backendBucket or the load balancer cannot reach the BackendBucket, a simple Not Found Error is returned to the client.
        The value must be from 1 to 1024 characters.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "corsPolicy":
            suggest = "cors_policy"
        elif key == "faultInjectionPolicy":
            suggest = "fault_injection_policy"
        elif key == "maxStreamDuration":
            suggest = "max_stream_duration"
        elif key == "requestMirrorPolicy":
            suggest = "request_mirror_policy"
        elif key == "retryPolicy":
            suggest = "retry_policy"
        elif key == "urlRewrite":
            suggest = "url_rewrite"
        elif key == "weightedBackendServices":
            suggest = "weighted_backend_services"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherDefaultRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherDefaultRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherDefaultRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cors_policy: Optional['outputs.URLMapPathMatcherDefaultRouteActionCorsPolicy'] = None,
                 fault_injection_policy: Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicy'] = None,
                 max_stream_duration: Optional['outputs.URLMapPathMatcherDefaultRouteActionMaxStreamDuration'] = None,
                 request_mirror_policy: Optional['outputs.URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy'] = None,
                 retry_policy: Optional['outputs.URLMapPathMatcherDefaultRouteActionRetryPolicy'] = None,
                 timeout: Optional['outputs.URLMapPathMatcherDefaultRouteActionTimeout'] = None,
                 url_rewrite: Optional['outputs.URLMapPathMatcherDefaultRouteActionUrlRewrite'] = None,
                 weighted_backend_services: Optional[Sequence['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendService']] = None):
        """
        :param 'URLMapPathMatcherDefaultRouteActionCorsPolicyArgs' cors_policy: The specification for allowing client side cross-origin requests. Please see
               [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
               Structure is documented below.
        :param 'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyArgs' fault_injection_policy: The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
               As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
               percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
               by the Loadbalancer for a percentage of requests.
               timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
               Structure is documented below.
        :param 'URLMapPathMatcherDefaultRouteActionMaxStreamDurationArgs' max_stream_duration: Specifies the maximum duration (timeout) for streams on the selected route.
               Unlike the `Timeout` field where the timeout duration starts from the time the request
               has been fully processed (known as end-of-stream), the duration in this field
               is computed from the beginning of the stream until the response has been processed,
               including all retries. A stream that does not complete in this duration is closed.
               Structure is documented below.
        :param 'URLMapPathMatcherDefaultRouteActionRequestMirrorPolicyArgs' request_mirror_policy: Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
               Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
               the host / authority header is suffixed with -shadow.
               Structure is documented below.
        :param 'URLMapPathMatcherDefaultRouteActionRetryPolicyArgs' retry_policy: Specifies the retry policy associated with this route.
               Structure is documented below.
        :param 'URLMapPathMatcherDefaultRouteActionTimeoutArgs' timeout: Specifies the timeout for the selected route. Timeout is computed from the time the request has been
               fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
               If not specified, will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param 'URLMapPathMatcherDefaultRouteActionUrlRewriteArgs' url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to the matched service.
               Structure is documented below.
        :param Sequence['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceArgs'] weighted_backend_services: A list of weighted backend services to send traffic to when a route match occurs.
               The weights determine the fraction of traffic that flows to their corresponding backend service.
               If all traffic needs to go to a single backend service, there must be one weightedBackendService
               with weight set to a non 0 number.
               Once a backendService is identified and before forwarding the request to the backend service,
               advanced routing actions like Url rewrites and header transformations are applied depending on
               additional settings specified in this HttpRouteAction.
               Structure is documented below.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if fault_injection_policy is not None:
            pulumi.set(__self__, "fault_injection_policy", fault_injection_policy)
        if max_stream_duration is not None:
            pulumi.set(__self__, "max_stream_duration", max_stream_duration)
        if request_mirror_policy is not None:
            pulumi.set(__self__, "request_mirror_policy", request_mirror_policy)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)
        if weighted_backend_services is not None:
            pulumi.set(__self__, "weighted_backend_services", weighted_backend_services)

    @_builtins.property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see
        [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
        Structure is documented below.
        """
        return pulumi.get(self, "cors_policy")

    @_builtins.property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
        As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
        percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
        by the Loadbalancer for a percentage of requests.
        timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
        Structure is documented below.
        """
        return pulumi.get(self, "fault_injection_policy")

    @_builtins.property
    @pulumi.getter(name="maxStreamDuration")
    def max_stream_duration(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionMaxStreamDuration']:
        """
        Specifies the maximum duration (timeout) for streams on the selected route.
        Unlike the `Timeout` field where the timeout duration starts from the time the request
        has been fully processed (known as end-of-stream), the duration in this field
        is computed from the beginning of the stream until the response has been processed,
        including all retries. A stream that does not complete in this duration is closed.
        Structure is documented below.
        """
        return pulumi.get(self, "max_stream_duration")

    @_builtins.property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
        Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
        the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        return pulumi.get(self, "request_mirror_policy")

    @_builtins.property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        return pulumi.get(self, "retry_policy")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time the request has been
        fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
        If not specified, will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to the matched service.
        Structure is documented below.
        """
        return pulumi.get(self, "url_rewrite")

    @_builtins.property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[Sequence['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match occurs.
        The weights determine the fraction of traffic that flows to their corresponding backend service.
        If all traffic needs to go to a single backend service, there must be one weightedBackendService
        with weight set to a non 0 number.
        Once a backendService is identified and before forwarding the request to the backend service,
        advanced routing actions like Url rewrites and header transformations are applied depending on
        additional settings specified in this HttpRouteAction.
        Structure is documented below.
        """
        return pulumi.get(self, "weighted_backend_services")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionCorsPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOriginRegexes":
            suggest = "allow_origin_regexes"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherDefaultRouteActionCorsPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherDefaultRouteActionCorsPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherDefaultRouteActionCorsPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origin_regexes: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional[Sequence[_builtins.str]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        :param _builtins.bool allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
               This translates to the Access-Control-Allow-Credentials header.
        :param Sequence[_builtins.str] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param Sequence[_builtins.str] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param Sequence[_builtins.str] allow_origin_regexes: Specifies the regular expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[_builtins.str] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param _builtins.bool disabled: If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        :param Sequence[_builtins.str] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param _builtins.int max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin_regexes is not None:
            pulumi.set(__self__, "allow_origin_regexes", allow_origin_regexes)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
        This translates to the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the regular expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origin_regexes")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicy(dict):
    def __init__(__self__, *,
                 abort: Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort'] = None,
                 delay: Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay'] = None):
        """
        :param 'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbortArgs' abort: The specification for how client requests are aborted as part of fault injection.
               Structure is documented below.
        :param 'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayArgs' delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
               Structure is documented below.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def abort(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        return pulumi.get(self, "abort")

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpStatus":
            suggest = "http_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_status: Optional[_builtins.int] = None,
                 percentage: Optional[_builtins.float] = None):
        """
        :param _builtins.int http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if http_status is not None:
            pulumi.set(__self__, "http_status", http_status)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[_builtins.int]:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        return pulumi.get(self, "http_status")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedDelay":
            suggest = "fixed_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_delay: Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay'] = None,
                 percentage: Optional[_builtins.float] = None):
        """
        :param 'URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayArgs' fixed_delay: Specifies the value of the fixed delay interval.
               Structure is documented below.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if fixed_delay is not None:
            pulumi.set(__self__, "fixed_delay", fixed_delay)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay']:
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_delay")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionMaxStreamDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "mirrorPercent":
            suggest = "mirror_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: _builtins.str,
                 mirror_percent: Optional[_builtins.float] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the BackendService resource being mirrored to.
        :param _builtins.float mirror_percent: The percentage of requests to be mirrored to backendService.
               The value must be between 0.0 and 100.0 inclusive.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        if mirror_percent is not None:
            pulumi.set(__self__, "mirror_percent", mirror_percent)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> _builtins.str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter(name="mirrorPercent")
    def mirror_percent(self) -> Optional[_builtins.float]:
        """
        The percentage of requests to be mirrored to backendService.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "mirror_percent")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionRetryPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numRetries":
            suggest = "num_retries"
        elif key == "perTryTimeout":
            suggest = "per_try_timeout"
        elif key == "retryConditions":
            suggest = "retry_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherDefaultRouteActionRetryPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherDefaultRouteActionRetryPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherDefaultRouteActionRetryPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_retries: Optional[_builtins.int] = None,
                 per_try_timeout: Optional['outputs.URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout'] = None,
                 retry_conditions: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param 'URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutArgs' per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param Sequence[_builtins.str] retry_conditions: Specfies one or more conditions when this retry rule applies. Valid values are:
               * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
               or if the backend service does not respond at all, example: disconnects, reset, read timeout,
               * connection failure, and refused streams.
               * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
               * connect-failure: Loadbalancer will retry on failures connecting to backend services,
               for example due to connection timeouts.
               * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
               This reset type indicates that it is safe to retry.
               * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
               * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
               * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
               * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_conditions is not None:
            pulumi.set(__self__, "retry_conditions", retry_conditions)

    @_builtins.property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[_builtins.int]:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        return pulumi.get(self, "num_retries")

    @_builtins.property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "per_try_timeout")

    @_builtins.property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specfies one or more conditions when this retry rule applies. Valid values are:
        * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
        or if the backend service does not respond at all, example: disconnects, reset, read timeout,
        * connection failure, and refused streams.
        * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
        * connect-failure: Loadbalancer will retry on failures connecting to backend services,
        for example due to connection timeouts.
        * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
        This reset type indicates that it is safe to retry.
        * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
        * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
        * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
        * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        return pulumi.get(self, "retry_conditions")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionTimeout(dict):
    def __init__(__self__, *,
                 nanos: Optional[_builtins.int] = None,
                 seconds: Optional[_builtins.str] = None):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.str]:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionUrlRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostRewrite":
            suggest = "host_rewrite"
        elif key == "pathPrefixRewrite":
            suggest = "path_prefix_rewrite"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherDefaultRouteActionUrlRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherDefaultRouteActionUrlRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherDefaultRouteActionUrlRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_rewrite: Optional[_builtins.str] = None,
                 path_prefix_rewrite: Optional[_builtins.str] = None):
        """
        :param _builtins.str host_rewrite: Prior to forwarding the request to the selected service, the request's host header is replaced
               with contents of hostRewrite.
               The value must be between 1 and 255 characters.
        :param _builtins.str path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching portion of the
               request's path is replaced by pathPrefixRewrite.
               The value must be between 1 and 1024 characters.
        """
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if path_prefix_rewrite is not None:
            pulumi.set(__self__, "path_prefix_rewrite", path_prefix_rewrite)

    @_builtins.property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[_builtins.str]:
        """
        Prior to forwarding the request to the selected service, the request's host header is replaced
        with contents of hostRewrite.
        The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_rewrite")

    @_builtins.property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[_builtins.str]:
        """
        Prior to forwarding the request to the selected backend service, the matching portion of the
        request's path is replaced by pathPrefixRewrite.
        The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "path_prefix_rewrite")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "headerAction":
            suggest = "header_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherDefaultRouteActionWeightedBackendService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherDefaultRouteActionWeightedBackendService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherDefaultRouteActionWeightedBackendService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: Optional[_builtins.str] = None,
                 header_action: Optional['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction'] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the default BackendService resource. Before forwarding the
               request to backendService, the loadbalancer applies any relevant headerActions
               specified as part of this backendServiceWeight.
        :param 'URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.
               Structure is documented below.
        :param _builtins.int weight: Specifies the fraction of traffic sent to backendService, computed as
               weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request
               has been directed to a backendService, subsequent requests will be sent to the same backendService
               as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        """
        if backend_service is not None:
            pulumi.set(__self__, "backend_service", backend_service)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> Optional[_builtins.str]:
        """
        The full or partial URL to the default BackendService resource. Before forwarding the
        request to backendService, the loadbalancer applies any relevant headerActions
        specified as part of this backendServiceWeight.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Specifies the fraction of traffic sent to backendService, computed as
        weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request
        has been directed to a backendService, subsequent requests will be sent to the same backendService
        as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"
        elif key == "requestHeadersToRemoves":
            suggest = "request_headers_to_removes"
        elif key == "responseHeadersToAdds":
            suggest = "response_headers_to_adds"
        elif key == "responseHeadersToRemoves":
            suggest = "response_headers_to_removes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[_builtins.str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[_builtins.str] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param Sequence['URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[_builtins.str] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[_builtins.str] = None,
                 header_value: Optional[_builtins.str] = None,
                 replace: Optional[_builtins.bool] = None):
        """
        :param _builtins.str header_name: The name of the header to add.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.bool]:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[_builtins.str] = None,
                 header_value: Optional[_builtins.str] = None,
                 replace: Optional[_builtins.bool] = None):
        """
        :param _builtins.str header_name: The name of the header to add.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.bool]:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class URLMapPathMatcherDefaultUrlRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stripQuery":
            suggest = "strip_query"
        elif key == "hostRedirect":
            suggest = "host_redirect"
        elif key == "httpsRedirect":
            suggest = "https_redirect"
        elif key == "pathRedirect":
            suggest = "path_redirect"
        elif key == "prefixRedirect":
            suggest = "prefix_redirect"
        elif key == "redirectResponseCode":
            suggest = "redirect_response_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherDefaultUrlRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherDefaultUrlRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherDefaultUrlRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 strip_query: _builtins.bool,
                 host_redirect: Optional[_builtins.str] = None,
                 https_redirect: Optional[_builtins.bool] = None,
                 path_redirect: Optional[_builtins.str] = None,
                 prefix_redirect: Optional[_builtins.str] = None,
                 redirect_response_code: Optional[_builtins.str] = None):
        """
        :param _builtins.bool strip_query: If set to true, any accompanying query portion of the original URL is removed prior
               to redirecting the request. If set to false, the query portion of the original URL is
               retained. The default is set to false.
               This field is required to ensure an empty block is not set. The normal default value is false.
        :param _builtins.str host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param _builtins.bool https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set to
               false, the URL scheme of the redirected request will remain the same as that of the
               request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
               true for TargetHttpsProxy is not permitted. The default is set to false.
        :param _builtins.str path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. pathRedirect cannot be supplied together with
               prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
               original request will be used for the redirect. The value must be between 1 and 1024
               characters.
        :param _builtins.str prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
               prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
               neither. If neither is supplied, the path of the original request will be used for
               the redirect. The value must be between 1 and 1024 characters.
        :param _builtins.str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
               will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case,
               the request method will be retained.
        """
        pulumi.set(__self__, "strip_query", strip_query)
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)

    @_builtins.property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> _builtins.bool:
        """
        If set to true, any accompanying query portion of the original URL is removed prior
        to redirecting the request. If set to false, the query portion of the original URL is
        retained. The default is set to false.
        This field is required to ensure an empty block is not set. The normal default value is false.
        """
        return pulumi.get(self, "strip_query")

    @_builtins.property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[_builtins.str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_redirect")

    @_builtins.property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[_builtins.bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set to
        false, the URL scheme of the redirected request will remain the same as that of the
        request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
        true for TargetHttpsProxy is not permitted. The default is set to false.
        """
        return pulumi.get(self, "https_redirect")

    @_builtins.property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[_builtins.str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. pathRedirect cannot be supplied together with
        prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
        original request will be used for the redirect. The value must be between 1 and 1024
        characters.
        """
        return pulumi.get(self, "path_redirect")

    @_builtins.property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[_builtins.str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
        neither. If neither is supplied, the path of the original request will be used for
        the redirect. The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "prefix_redirect")

    @_builtins.property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[_builtins.str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
        will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case,
        the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")


@pulumi.output_type
class URLMapPathMatcherHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"
        elif key == "requestHeadersToRemoves":
            suggest = "request_headers_to_removes"
        elif key == "responseHeadersToAdds":
            suggest = "response_headers_to_adds"
        elif key == "responseHeadersToRemoves":
            suggest = "response_headers_to_removes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[_builtins.str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['URLMapPathMatcherHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[_builtins.str] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param Sequence['URLMapPathMatcherHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[_builtins.str] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")


@pulumi.output_type
class URLMapPathMatcherHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header to add.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class URLMapPathMatcherHeaderActionResponseHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherHeaderActionResponseHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header to add.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class URLMapPathMatcherPathRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customErrorResponsePolicy":
            suggest = "custom_error_response_policy"
        elif key == "routeAction":
            suggest = "route_action"
        elif key == "urlRedirect":
            suggest = "url_redirect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paths: Sequence[_builtins.str],
                 custom_error_response_policy: Optional['outputs.URLMapPathMatcherPathRuleCustomErrorResponsePolicy'] = None,
                 route_action: Optional['outputs.URLMapPathMatcherPathRuleRouteAction'] = None,
                 service: Optional[_builtins.str] = None,
                 url_redirect: Optional['outputs.URLMapPathMatcherPathRuleUrlRedirect'] = None):
        """
        :param Sequence[_builtins.str] paths: The list of path patterns to match. Each must start with / and the only place a
               \\* is allowed is at the end following a /. The string fed to the path matcher
               does not include any text after the first ? or #, and those chars are not
               allowed here.
        :param 'URLMapPathMatcherPathRuleCustomErrorResponsePolicyArgs' custom_error_response_policy: customErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
               If a policy for an error code is not configured for the PathRule, a policy for the error code configured in pathMatcher.defaultCustomErrorResponsePolicy is applied. If one is not specified in pathMatcher.defaultCustomErrorResponsePolicy, the policy configured in UrlMap.defaultCustomErrorResponsePolicy takes effect.
               For example, consider a UrlMap with the following configuration:
               UrlMap.defaultCustomErrorResponsePolicy are configured with policies for 5xx and 4xx errors
               A PathRule for /coming_soon/ is configured for the error code 404.
               If the request is for www.myotherdomain.com and a 404 is encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404 response is encountered for the request www.example.com/current_events/, the pathMatcher's policy takes effect. If however, the request for www.example.com/coming_soon/ encounters a 404, the policy in PathRule.customErrorResponsePolicy takes effect. If any of the requests in this example encounter a 500 error code, the policy at UrlMap.defaultCustomErrorResponsePolicy takes effect.
               customErrorResponsePolicy is supported only for global external Application Load Balancers.
               Structure is documented below.
        :param 'URLMapPathMatcherPathRuleRouteActionArgs' route_action: In response to a matching path, the load balancer performs advanced routing
               actions like URL rewrites, header transformations, etc. prior to forwarding the
               request to the selected backend. If routeAction specifies any
               weightedBackendServices, service must not be set. Conversely if service is set,
               routeAction cannot contain any  weightedBackendServices. Only one of routeAction
               or urlRedirect must be set.
               Structure is documented below.
        :param _builtins.str service: The backend service or backend bucket to use if any of the given paths match.
        :param 'URLMapPathMatcherPathRuleUrlRedirectArgs' url_redirect: When a path pattern is matched, the request is redirected to a URL specified
               by urlRedirect. If urlRedirect is specified, service or routeAction must not
               be set.
               Structure is documented below.
        """
        pulumi.set(__self__, "paths", paths)
        if custom_error_response_policy is not None:
            pulumi.set(__self__, "custom_error_response_policy", custom_error_response_policy)
        if route_action is not None:
            pulumi.set(__self__, "route_action", route_action)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if url_redirect is not None:
            pulumi.set(__self__, "url_redirect", url_redirect)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence[_builtins.str]:
        """
        The list of path patterns to match. Each must start with / and the only place a
        \\* is allowed is at the end following a /. The string fed to the path matcher
        does not include any text after the first ? or #, and those chars are not
        allowed here.
        """
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter(name="customErrorResponsePolicy")
    def custom_error_response_policy(self) -> Optional['outputs.URLMapPathMatcherPathRuleCustomErrorResponsePolicy']:
        """
        customErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
        If a policy for an error code is not configured for the PathRule, a policy for the error code configured in pathMatcher.defaultCustomErrorResponsePolicy is applied. If one is not specified in pathMatcher.defaultCustomErrorResponsePolicy, the policy configured in UrlMap.defaultCustomErrorResponsePolicy takes effect.
        For example, consider a UrlMap with the following configuration:
        UrlMap.defaultCustomErrorResponsePolicy are configured with policies for 5xx and 4xx errors
        A PathRule for /coming_soon/ is configured for the error code 404.
        If the request is for www.myotherdomain.com and a 404 is encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404 response is encountered for the request www.example.com/current_events/, the pathMatcher's policy takes effect. If however, the request for www.example.com/coming_soon/ encounters a 404, the policy in PathRule.customErrorResponsePolicy takes effect. If any of the requests in this example encounter a 500 error code, the policy at UrlMap.defaultCustomErrorResponsePolicy takes effect.
        customErrorResponsePolicy is supported only for global external Application Load Balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_error_response_policy")

    @_builtins.property
    @pulumi.getter(name="routeAction")
    def route_action(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteAction']:
        """
        In response to a matching path, the load balancer performs advanced routing
        actions like URL rewrites, header transformations, etc. prior to forwarding the
        request to the selected backend. If routeAction specifies any
        weightedBackendServices, service must not be set. Conversely if service is set,
        routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        or urlRedirect must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "route_action")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        The backend service or backend bucket to use if any of the given paths match.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="urlRedirect")
    def url_redirect(self) -> Optional['outputs.URLMapPathMatcherPathRuleUrlRedirect']:
        """
        When a path pattern is matched, the request is redirected to a URL specified
        by urlRedirect. If urlRedirect is specified, service or routeAction must not
        be set.
        Structure is documented below.
        """
        return pulumi.get(self, "url_redirect")


@pulumi.output_type
class URLMapPathMatcherPathRuleCustomErrorResponsePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorResponseRules":
            suggest = "error_response_rules"
        elif key == "errorService":
            suggest = "error_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRuleCustomErrorResponsePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRuleCustomErrorResponsePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRuleCustomErrorResponsePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_response_rules: Optional[Sequence['outputs.URLMapPathMatcherPathRuleCustomErrorResponsePolicyErrorResponseRule']] = None,
                 error_service: Optional[_builtins.str] = None):
        """
        :param Sequence['URLMapPathMatcherPathRuleCustomErrorResponsePolicyErrorResponseRuleArgs'] error_response_rules: Specifies rules for returning error responses.
               In a given policy, if you specify rules for both a range of error codes as well as rules for specific error codes then rules with specific error codes have a higher priority.
               For example, assume that you configure a rule for 401 (Un-authorized) code, and another for all 4 series error codes (4XX).
               If the backend service returns a 401, then the rule for 401 will be applied. However if the backend service returns a 403, the rule for 4xx takes effect.
               Structure is documented below.
        :param _builtins.str error_service: The full or partial URL to the BackendBucket resource that contains the custom error content. Examples are:
               https://www.googleapis.com/compute/v1/projects/project/global/backendBuckets/myBackendBucket
               compute/v1/projects/project/global/backendBuckets/myBackendBucket
               global/backendBuckets/myBackendBucket
               If errorService is not specified at lower levels like pathMatcher, pathRule and routeRule, an errorService specified at a higher level in the UrlMap will be used. If UrlMap.defaultCustomErrorResponsePolicy contains one or more errorResponseRules[], it must specify errorService.
               If load balancer cannot reach the backendBucket, a simple Not Found Error will be returned, with the original response code (or overrideResponseCode if configured).
        """
        if error_response_rules is not None:
            pulumi.set(__self__, "error_response_rules", error_response_rules)
        if error_service is not None:
            pulumi.set(__self__, "error_service", error_service)

    @_builtins.property
    @pulumi.getter(name="errorResponseRules")
    def error_response_rules(self) -> Optional[Sequence['outputs.URLMapPathMatcherPathRuleCustomErrorResponsePolicyErrorResponseRule']]:
        """
        Specifies rules for returning error responses.
        In a given policy, if you specify rules for both a range of error codes as well as rules for specific error codes then rules with specific error codes have a higher priority.
        For example, assume that you configure a rule for 401 (Un-authorized) code, and another for all 4 series error codes (4XX).
        If the backend service returns a 401, then the rule for 401 will be applied. However if the backend service returns a 403, the rule for 4xx takes effect.
        Structure is documented below.
        """
        return pulumi.get(self, "error_response_rules")

    @_builtins.property
    @pulumi.getter(name="errorService")
    def error_service(self) -> Optional[_builtins.str]:
        """
        The full or partial URL to the BackendBucket resource that contains the custom error content. Examples are:
        https://www.googleapis.com/compute/v1/projects/project/global/backendBuckets/myBackendBucket
        compute/v1/projects/project/global/backendBuckets/myBackendBucket
        global/backendBuckets/myBackendBucket
        If errorService is not specified at lower levels like pathMatcher, pathRule and routeRule, an errorService specified at a higher level in the UrlMap will be used. If UrlMap.defaultCustomErrorResponsePolicy contains one or more errorResponseRules[], it must specify errorService.
        If load balancer cannot reach the backendBucket, a simple Not Found Error will be returned, with the original response code (or overrideResponseCode if configured).
        """
        return pulumi.get(self, "error_service")


@pulumi.output_type
class URLMapPathMatcherPathRuleCustomErrorResponsePolicyErrorResponseRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchResponseCodes":
            suggest = "match_response_codes"
        elif key == "overrideResponseCode":
            suggest = "override_response_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRuleCustomErrorResponsePolicyErrorResponseRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRuleCustomErrorResponsePolicyErrorResponseRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRuleCustomErrorResponsePolicyErrorResponseRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_response_codes: Optional[Sequence[_builtins.str]] = None,
                 override_response_code: Optional[_builtins.int] = None,
                 path: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] match_response_codes: Valid values include:
               - A number between 400 and 599: For example 401 or 503, in which case the load balancer applies the policy if the error code exactly matches this value.
               - 5xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 500 to 599.
               - 4xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 400 to 499.
               Values must be unique within matchResponseCodes and across all errorResponseRules of CustomErrorResponsePolicy.
        :param _builtins.int override_response_code: The HTTP status code returned with the response containing the custom error content.
               If overrideResponseCode is not supplied, the same response code returned by the original backend bucket or backend service is returned to the client.
        :param _builtins.str path: The full path to a file within backendBucket. For example: /errors/defaultError.html
               path must start with a leading slash. path cannot have trailing slashes.
               If the file is not available in backendBucket or the load balancer cannot reach the BackendBucket, a simple Not Found Error is returned to the client.
               The value must be from 1 to 1024 characters.
        """
        if match_response_codes is not None:
            pulumi.set(__self__, "match_response_codes", match_response_codes)
        if override_response_code is not None:
            pulumi.set(__self__, "override_response_code", override_response_code)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="matchResponseCodes")
    def match_response_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Valid values include:
        - A number between 400 and 599: For example 401 or 503, in which case the load balancer applies the policy if the error code exactly matches this value.
        - 5xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 500 to 599.
        - 4xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 400 to 499.
        Values must be unique within matchResponseCodes and across all errorResponseRules of CustomErrorResponsePolicy.
        """
        return pulumi.get(self, "match_response_codes")

    @_builtins.property
    @pulumi.getter(name="overrideResponseCode")
    def override_response_code(self) -> Optional[_builtins.int]:
        """
        The HTTP status code returned with the response containing the custom error content.
        If overrideResponseCode is not supplied, the same response code returned by the original backend bucket or backend service is returned to the client.
        """
        return pulumi.get(self, "override_response_code")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        The full path to a file within backendBucket. For example: /errors/defaultError.html
        path must start with a leading slash. path cannot have trailing slashes.
        If the file is not available in backendBucket or the load balancer cannot reach the BackendBucket, a simple Not Found Error is returned to the client.
        The value must be from 1 to 1024 characters.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "corsPolicy":
            suggest = "cors_policy"
        elif key == "faultInjectionPolicy":
            suggest = "fault_injection_policy"
        elif key == "maxStreamDuration":
            suggest = "max_stream_duration"
        elif key == "requestMirrorPolicy":
            suggest = "request_mirror_policy"
        elif key == "retryPolicy":
            suggest = "retry_policy"
        elif key == "urlRewrite":
            suggest = "url_rewrite"
        elif key == "weightedBackendServices":
            suggest = "weighted_backend_services"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRuleRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRuleRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRuleRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cors_policy: Optional['outputs.URLMapPathMatcherPathRuleRouteActionCorsPolicy'] = None,
                 fault_injection_policy: Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy'] = None,
                 max_stream_duration: Optional['outputs.URLMapPathMatcherPathRuleRouteActionMaxStreamDuration'] = None,
                 request_mirror_policy: Optional['outputs.URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy'] = None,
                 retry_policy: Optional['outputs.URLMapPathMatcherPathRuleRouteActionRetryPolicy'] = None,
                 timeout: Optional['outputs.URLMapPathMatcherPathRuleRouteActionTimeout'] = None,
                 url_rewrite: Optional['outputs.URLMapPathMatcherPathRuleRouteActionUrlRewrite'] = None,
                 weighted_backend_services: Optional[Sequence['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendService']] = None):
        """
        :param 'URLMapPathMatcherPathRuleRouteActionCorsPolicyArgs' cors_policy: The specification for allowing client side cross-origin requests. Please see W3C
               Recommendation for Cross Origin Resource Sharing
               Structure is documented below.
        :param 'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyArgs' fault_injection_policy: The specification for fault injection introduced into traffic to test the
               resiliency of clients to backend service failure. As part of fault injection,
               when clients send requests to a backend service, delays can be introduced by
               Loadbalancer on a percentage of requests before sending those request to the
               backend service. Similarly requests from clients can be aborted by the
               Loadbalancer for a percentage of requests. timeout and retry_policy will be
               ignored by clients that are configured with a fault_injection_policy.
               Structure is documented below.
        :param 'URLMapPathMatcherPathRuleRouteActionMaxStreamDurationArgs' max_stream_duration: Specifies the maximum duration (timeout) for streams on the selected route.
               Unlike the `Timeout` field where the timeout duration starts from the time the request
               has been fully processed (known as end-of-stream), the duration in this field
               is computed from the beginning of the stream until the response has been processed,
               including all retries. A stream that does not complete in this duration is closed.
               Structure is documented below.
        :param 'URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicyArgs' request_mirror_policy: Specifies the policy on how requests intended for the route's backends are
               shadowed to a separate mirrored backend service. Loadbalancer does not wait for
               responses from the shadow service. Prior to sending traffic to the shadow
               service, the host / authority header is suffixed with -shadow.
               Structure is documented below.
        :param 'URLMapPathMatcherPathRuleRouteActionRetryPolicyArgs' retry_policy: Specifies the retry policy associated with this route.
               Structure is documented below.
        :param 'URLMapPathMatcherPathRuleRouteActionTimeoutArgs' timeout: Specifies the timeout for the selected route. Timeout is computed from the time
               the request is has been fully processed (i.e. end-of-stream) up until the
               response has been completely processed. Timeout includes all retries. If not
               specified, the default value is 15 seconds.
               Structure is documented below.
        :param 'URLMapPathMatcherPathRuleRouteActionUrlRewriteArgs' url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to
               the matched service
               Structure is documented below.
        :param Sequence['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceArgs'] weighted_backend_services: A list of weighted backend services to send traffic to when a route match
               occurs. The weights determine the fraction of traffic that flows to their
               corresponding backend service. If all traffic needs to go to a single backend
               service, there must be one  weightedBackendService with weight set to a non 0
               number. Once a backendService is identified and before forwarding the request to
               the backend service, advanced routing actions like Url rewrites and header
               transformations are applied depending on additional settings specified in this
               HttpRouteAction.
               Structure is documented below.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if fault_injection_policy is not None:
            pulumi.set(__self__, "fault_injection_policy", fault_injection_policy)
        if max_stream_duration is not None:
            pulumi.set(__self__, "max_stream_duration", max_stream_duration)
        if request_mirror_policy is not None:
            pulumi.set(__self__, "request_mirror_policy", request_mirror_policy)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)
        if weighted_backend_services is not None:
            pulumi.set(__self__, "weighted_backend_services", weighted_backend_services)

    @_builtins.property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see W3C
        Recommendation for Cross Origin Resource Sharing
        Structure is documented below.
        """
        return pulumi.get(self, "cors_policy")

    @_builtins.property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the
        resiliency of clients to backend service failure. As part of fault injection,
        when clients send requests to a backend service, delays can be introduced by
        Loadbalancer on a percentage of requests before sending those request to the
        backend service. Similarly requests from clients can be aborted by the
        Loadbalancer for a percentage of requests. timeout and retry_policy will be
        ignored by clients that are configured with a fault_injection_policy.
        Structure is documented below.
        """
        return pulumi.get(self, "fault_injection_policy")

    @_builtins.property
    @pulumi.getter(name="maxStreamDuration")
    def max_stream_duration(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionMaxStreamDuration']:
        """
        Specifies the maximum duration (timeout) for streams on the selected route.
        Unlike the `Timeout` field where the timeout duration starts from the time the request
        has been fully processed (known as end-of-stream), the duration in this field
        is computed from the beginning of the stream until the response has been processed,
        including all retries. A stream that does not complete in this duration is closed.
        Structure is documented below.
        """
        return pulumi.get(self, "max_stream_duration")

    @_builtins.property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are
        shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        responses from the shadow service. Prior to sending traffic to the shadow
        service, the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        return pulumi.get(self, "request_mirror_policy")

    @_builtins.property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        return pulumi.get(self, "retry_policy")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time
        the request is has been fully processed (i.e. end-of-stream) up until the
        response has been completely processed. Timeout includes all retries. If not
        specified, the default value is 15 seconds.
        Structure is documented below.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to
        the matched service
        Structure is documented below.
        """
        return pulumi.get(self, "url_rewrite")

    @_builtins.property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[Sequence['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match
        occurs. The weights determine the fraction of traffic that flows to their
        corresponding backend service. If all traffic needs to go to a single backend
        service, there must be one  weightedBackendService with weight set to a non 0
        number. Once a backendService is identified and before forwarding the request to
        the backend service, advanced routing actions like Url rewrites and header
        transformations are applied depending on additional settings specified in this
        HttpRouteAction.
        Structure is documented below.
        """
        return pulumi.get(self, "weighted_backend_services")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionCorsPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOriginRegexes":
            suggest = "allow_origin_regexes"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRuleRouteActionCorsPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRuleRouteActionCorsPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRuleRouteActionCorsPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: _builtins.bool,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origin_regexes: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional[Sequence[_builtins.str]] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        :param _builtins.bool disabled: If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        :param _builtins.bool allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
               This translates to the Access-Control-Allow-Credentials header.
        :param Sequence[_builtins.str] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param Sequence[_builtins.str] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param Sequence[_builtins.str] allow_origin_regexes: Specifies the regular expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[_builtins.str] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[_builtins.str] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param _builtins.int max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        pulumi.set(__self__, "disabled", disabled)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin_regexes is not None:
            pulumi.set(__self__, "allow_origin_regexes", allow_origin_regexes)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
        This translates to the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the regular expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origin_regexes")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy(dict):
    def __init__(__self__, *,
                 abort: Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort'] = None,
                 delay: Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay'] = None):
        """
        :param 'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortArgs' abort: The specification for how client requests are aborted as part of fault injection.
               Structure is documented below.
        :param 'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayArgs' delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
               Structure is documented below.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def abort(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        return pulumi.get(self, "abort")

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpStatus":
            suggest = "http_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_status: _builtins.int,
                 percentage: _builtins.float):
        """
        :param _builtins.int http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        pulumi.set(__self__, "http_status", http_status)
        pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> _builtins.int:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        return pulumi.get(self, "http_status")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> _builtins.float:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedDelay":
            suggest = "fixed_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_delay: 'outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay',
                 percentage: _builtins.float):
        """
        :param 'URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs' fixed_delay: Specifies the value of the fixed delay interval.
               Structure is documented below.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        pulumi.set(__self__, "fixed_delay", fixed_delay)
        pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> 'outputs.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay':
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_delay")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> _builtins.float:
        """
        The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionMaxStreamDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "mirrorPercent":
            suggest = "mirror_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: _builtins.str,
                 mirror_percent: Optional[_builtins.float] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the BackendService resource being mirrored to.
        :param _builtins.float mirror_percent: The percentage of requests to be mirrored to backendService.
               The value must be between 0.0 and 100.0 inclusive.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        if mirror_percent is not None:
            pulumi.set(__self__, "mirror_percent", mirror_percent)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> _builtins.str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter(name="mirrorPercent")
    def mirror_percent(self) -> Optional[_builtins.float]:
        """
        The percentage of requests to be mirrored to backendService.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "mirror_percent")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionRetryPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numRetries":
            suggest = "num_retries"
        elif key == "perTryTimeout":
            suggest = "per_try_timeout"
        elif key == "retryConditions":
            suggest = "retry_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRuleRouteActionRetryPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRuleRouteActionRetryPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRuleRouteActionRetryPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_retries: Optional[_builtins.int] = None,
                 per_try_timeout: Optional['outputs.URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout'] = None,
                 retry_conditions: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param 'URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutArgs' per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param Sequence[_builtins.str] retry_conditions: Specfies one or more conditions when this retry rule applies. Valid values are:
               * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
               or if the backend service does not respond at all, example: disconnects, reset, read timeout,
               * connection failure, and refused streams.
               * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
               * connect-failure: Loadbalancer will retry on failures connecting to backend services,
               for example due to connection timeouts.
               * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
               This reset type indicates that it is safe to retry.
               * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
               * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
               * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
               * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_conditions is not None:
            pulumi.set(__self__, "retry_conditions", retry_conditions)

    @_builtins.property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[_builtins.int]:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        return pulumi.get(self, "num_retries")

    @_builtins.property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "per_try_timeout")

    @_builtins.property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specfies one or more conditions when this retry rule applies. Valid values are:
        * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
        or if the backend service does not respond at all, example: disconnects, reset, read timeout,
        * connection failure, and refused streams.
        * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
        * connect-failure: Loadbalancer will retry on failures connecting to backend services,
        for example due to connection timeouts.
        * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
        This reset type indicates that it is safe to retry.
        * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
        * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
        * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
        * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        return pulumi.get(self, "retry_conditions")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionUrlRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostRewrite":
            suggest = "host_rewrite"
        elif key == "pathPrefixRewrite":
            suggest = "path_prefix_rewrite"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRuleRouteActionUrlRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRuleRouteActionUrlRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRuleRouteActionUrlRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_rewrite: Optional[_builtins.str] = None,
                 path_prefix_rewrite: Optional[_builtins.str] = None):
        """
        :param _builtins.str host_rewrite: Prior to forwarding the request to the selected service, the request's host header is replaced
               with contents of hostRewrite.
               The value must be between 1 and 255 characters.
        :param _builtins.str path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching portion of the
               request's path is replaced by pathPrefixRewrite.
               The value must be between 1 and 1024 characters.
        """
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if path_prefix_rewrite is not None:
            pulumi.set(__self__, "path_prefix_rewrite", path_prefix_rewrite)

    @_builtins.property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[_builtins.str]:
        """
        Prior to forwarding the request to the selected service, the request's host header is replaced
        with contents of hostRewrite.
        The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_rewrite")

    @_builtins.property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[_builtins.str]:
        """
        Prior to forwarding the request to the selected backend service, the matching portion of the
        request's path is replaced by pathPrefixRewrite.
        The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "path_prefix_rewrite")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "headerAction":
            suggest = "header_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRuleRouteActionWeightedBackendService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRuleRouteActionWeightedBackendService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRuleRouteActionWeightedBackendService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: _builtins.str,
                 weight: _builtins.int,
                 header_action: Optional['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction'] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the default BackendService resource. Before forwarding the
               request to backendService, the loadbalancer applies any relevant headerActions
               specified as part of this backendServiceWeight.
        :param _builtins.int weight: Specifies the fraction of traffic sent to backendService, computed as
               weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request
               has been directed to a backendService, subsequent requests will be sent to the same backendService
               as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        :param 'URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.
               Structure is documented below.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        pulumi.set(__self__, "weight", weight)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> _builtins.str:
        """
        The full or partial URL to the default BackendService resource. Before forwarding the
        request to backendService, the loadbalancer applies any relevant headerActions
        specified as part of this backendServiceWeight.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        Specifies the fraction of traffic sent to backendService, computed as
        weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request
        has been directed to a backendService, subsequent requests will be sent to the same backendService
        as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        return pulumi.get(self, "weight")

    @_builtins.property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"
        elif key == "requestHeadersToRemoves":
            suggest = "request_headers_to_removes"
        elif key == "responseHeadersToAdds":
            suggest = "response_headers_to_adds"
        elif key == "responseHeadersToRemoves":
            suggest = "response_headers_to_removes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[_builtins.str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[_builtins.str] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param Sequence['URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[_builtins.str] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header to add.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header to add.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class URLMapPathMatcherPathRuleUrlRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stripQuery":
            suggest = "strip_query"
        elif key == "hostRedirect":
            suggest = "host_redirect"
        elif key == "httpsRedirect":
            suggest = "https_redirect"
        elif key == "pathRedirect":
            suggest = "path_redirect"
        elif key == "prefixRedirect":
            suggest = "prefix_redirect"
        elif key == "redirectResponseCode":
            suggest = "redirect_response_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherPathRuleUrlRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherPathRuleUrlRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherPathRuleUrlRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 strip_query: _builtins.bool,
                 host_redirect: Optional[_builtins.str] = None,
                 https_redirect: Optional[_builtins.bool] = None,
                 path_redirect: Optional[_builtins.str] = None,
                 prefix_redirect: Optional[_builtins.str] = None,
                 redirect_response_code: Optional[_builtins.str] = None):
        """
        :param _builtins.bool strip_query: If set to true, any accompanying query portion of the original URL is removed
               prior to redirecting the request. If set to false, the query portion of the
               original URL is retained. Defaults to false.
        :param _builtins.str host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param _builtins.bool https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set
               to false, the URL scheme of the redirected request will remain the same as that
               of the request. This must only be set for UrlMaps used in TargetHttpProxys.
               Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        :param _builtins.str path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. Only one of pathRedirect or prefixRedirect must be
               specified. The value must be between 1 and 1024 characters.
        :param _builtins.str prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
        :param _builtins.str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case, the request method will be retained.
        """
        pulumi.set(__self__, "strip_query", strip_query)
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)

    @_builtins.property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> _builtins.bool:
        """
        If set to true, any accompanying query portion of the original URL is removed
        prior to redirecting the request. If set to false, the query portion of the
        original URL is retained. Defaults to false.
        """
        return pulumi.get(self, "strip_query")

    @_builtins.property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[_builtins.str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_redirect")

    @_builtins.property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[_builtins.bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set
        to false, the URL scheme of the redirected request will remain the same as that
        of the request. This must only be set for UrlMaps used in TargetHttpProxys.
        Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        """
        return pulumi.get(self, "https_redirect")

    @_builtins.property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[_builtins.str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. Only one of pathRedirect or prefixRedirect must be
        specified. The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "path_redirect")

    @_builtins.property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[_builtins.str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        """
        return pulumi.get(self, "prefix_redirect")

    @_builtins.property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[_builtins.str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case, the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")


@pulumi.output_type
class URLMapPathMatcherRouteRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customErrorResponsePolicy":
            suggest = "custom_error_response_policy"
        elif key == "headerAction":
            suggest = "header_action"
        elif key == "httpFilterConfigs":
            suggest = "http_filter_configs"
        elif key == "httpFilterMetadatas":
            suggest = "http_filter_metadatas"
        elif key == "matchRules":
            suggest = "match_rules"
        elif key == "routeAction":
            suggest = "route_action"
        elif key == "urlRedirect":
            suggest = "url_redirect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 priority: _builtins.int,
                 custom_error_response_policy: Optional['outputs.URLMapPathMatcherRouteRuleCustomErrorResponsePolicy'] = None,
                 header_action: Optional['outputs.URLMapPathMatcherRouteRuleHeaderAction'] = None,
                 http_filter_configs: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleHttpFilterConfig']] = None,
                 http_filter_metadatas: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleHttpFilterMetadata']] = None,
                 match_rules: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRule']] = None,
                 route_action: Optional['outputs.URLMapPathMatcherRouteRuleRouteAction'] = None,
                 service: Optional[_builtins.str] = None,
                 url_redirect: Optional['outputs.URLMapPathMatcherRouteRuleUrlRedirect'] = None):
        """
        :param _builtins.int priority: For routeRules within a given pathMatcher, priority determines the order
               in which load balancer will interpret routeRules. RouteRules are evaluated
               in order of priority, from the lowest to highest number. The priority of
               a rule decreases as its number increases (1, 2, 3, N+1). The first rule
               that matches the request is applied.
               You cannot configure two or more routeRules with the same priority.
               Priority for each rule must be set to a number between 0 and
               2147483647 inclusive.
               Priority numbers can have gaps, which enable you to add or remove rules
               in the future without affecting the rest of the rules. For example,
               1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
               you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
               future without any impact on existing rules.
        :param 'URLMapPathMatcherRouteRuleCustomErrorResponsePolicyArgs' custom_error_response_policy: customErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService. The headerAction specified here are applied before
               the matching pathMatchers[].headerAction and after pathMatchers[].routeRules[].r
               outeAction.weightedBackendService.backendServiceWeightAction[].headerAction
               Structure is documented below.
        :param Sequence['URLMapPathMatcherRouteRuleHttpFilterConfigArgs'] http_filter_configs: Outbound route specific configuration for networkservices.HttpFilter resources enabled by Traffic Director.
               httpFilterConfigs only applies for load balancers with loadBalancingScheme set to INTERNAL_SELF_MANAGED.
               See ForwardingRule for more details.
               Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
               Structure is documented below.
        :param Sequence['URLMapPathMatcherRouteRuleHttpFilterMetadataArgs'] http_filter_metadatas: Outbound route specific metadata supplied to networkservices.HttpFilter resources enabled by Traffic Director.
               httpFilterMetadata only applies for load balancers with loadBalancingScheme set to INTERNAL_SELF_MANAGED.
               See ForwardingRule for more details.
               Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
               Structure is documented below.
        :param Sequence['URLMapPathMatcherRouteRuleMatchRuleArgs'] match_rules: The rules for determining a match.
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionArgs' route_action: In response to a matching matchRule, the load balancer performs advanced routing
               actions like URL rewrites, header transformations, etc. prior to forwarding the
               request to the selected backend. If  routeAction specifies any
               weightedBackendServices, service must not be set. Conversely if service is set,
               routeAction cannot contain any  weightedBackendServices. Only one of routeAction
               or urlRedirect must be set.
               Structure is documented below.
        :param _builtins.str service: The backend service resource to which traffic is
               directed if this rule is matched. If routeAction is additionally specified,
               advanced routing actions like URL Rewrites, etc. take effect prior to sending
               the request to the backend. However, if service is specified, routeAction cannot
               contain any weightedBackendService s. Conversely, if routeAction specifies any
               weightedBackendServices, service must not be specified. Only one of urlRedirect,
               service or routeAction.weightedBackendService must be set.
        :param 'URLMapPathMatcherRouteRuleUrlRedirectArgs' url_redirect: When this rule is matched, the request is redirected to a URL specified by
               urlRedirect. If urlRedirect is specified, service or routeAction must not be
               set.
               Structure is documented below.
        """
        pulumi.set(__self__, "priority", priority)
        if custom_error_response_policy is not None:
            pulumi.set(__self__, "custom_error_response_policy", custom_error_response_policy)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)
        if http_filter_configs is not None:
            pulumi.set(__self__, "http_filter_configs", http_filter_configs)
        if http_filter_metadatas is not None:
            pulumi.set(__self__, "http_filter_metadatas", http_filter_metadatas)
        if match_rules is not None:
            pulumi.set(__self__, "match_rules", match_rules)
        if route_action is not None:
            pulumi.set(__self__, "route_action", route_action)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if url_redirect is not None:
            pulumi.set(__self__, "url_redirect", url_redirect)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        For routeRules within a given pathMatcher, priority determines the order
        in which load balancer will interpret routeRules. RouteRules are evaluated
        in order of priority, from the lowest to highest number. The priority of
        a rule decreases as its number increases (1, 2, 3, N+1). The first rule
        that matches the request is applied.
        You cannot configure two or more routeRules with the same priority.
        Priority for each rule must be set to a number between 0 and
        2147483647 inclusive.
        Priority numbers can have gaps, which enable you to add or remove rules
        in the future without affecting the rest of the rules. For example,
        1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
        you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
        future without any impact on existing rules.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="customErrorResponsePolicy")
    def custom_error_response_policy(self) -> Optional['outputs.URLMapPathMatcherRouteRuleCustomErrorResponsePolicy']:
        """
        customErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_error_response_policy")

    @_builtins.property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherRouteRuleHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService. The headerAction specified here are applied before
        the matching pathMatchers[].headerAction and after pathMatchers[].routeRules[].r
        outeAction.weightedBackendService.backendServiceWeightAction[].headerAction
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")

    @_builtins.property
    @pulumi.getter(name="httpFilterConfigs")
    def http_filter_configs(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleHttpFilterConfig']]:
        """
        Outbound route specific configuration for networkservices.HttpFilter resources enabled by Traffic Director.
        httpFilterConfigs only applies for load balancers with loadBalancingScheme set to INTERNAL_SELF_MANAGED.
        See ForwardingRule for more details.
        Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
        Structure is documented below.
        """
        return pulumi.get(self, "http_filter_configs")

    @_builtins.property
    @pulumi.getter(name="httpFilterMetadatas")
    def http_filter_metadatas(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleHttpFilterMetadata']]:
        """
        Outbound route specific metadata supplied to networkservices.HttpFilter resources enabled by Traffic Director.
        httpFilterMetadata only applies for load balancers with loadBalancingScheme set to INTERNAL_SELF_MANAGED.
        See ForwardingRule for more details.
        Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
        Structure is documented below.
        """
        return pulumi.get(self, "http_filter_metadatas")

    @_builtins.property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRule']]:
        """
        The rules for determining a match.
        Structure is documented below.
        """
        return pulumi.get(self, "match_rules")

    @_builtins.property
    @pulumi.getter(name="routeAction")
    def route_action(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteAction']:
        """
        In response to a matching matchRule, the load balancer performs advanced routing
        actions like URL rewrites, header transformations, etc. prior to forwarding the
        request to the selected backend. If  routeAction specifies any
        weightedBackendServices, service must not be set. Conversely if service is set,
        routeAction cannot contain any  weightedBackendServices. Only one of routeAction
        or urlRedirect must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "route_action")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        The backend service resource to which traffic is
        directed if this rule is matched. If routeAction is additionally specified,
        advanced routing actions like URL Rewrites, etc. take effect prior to sending
        the request to the backend. However, if service is specified, routeAction cannot
        contain any weightedBackendService s. Conversely, if routeAction specifies any
        weightedBackendServices, service must not be specified. Only one of urlRedirect,
        service or routeAction.weightedBackendService must be set.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="urlRedirect")
    def url_redirect(self) -> Optional['outputs.URLMapPathMatcherRouteRuleUrlRedirect']:
        """
        When this rule is matched, the request is redirected to a URL specified by
        urlRedirect. If urlRedirect is specified, service or routeAction must not be
        set.
        Structure is documented below.
        """
        return pulumi.get(self, "url_redirect")


@pulumi.output_type
class URLMapPathMatcherRouteRuleCustomErrorResponsePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorResponseRules":
            suggest = "error_response_rules"
        elif key == "errorService":
            suggest = "error_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleCustomErrorResponsePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleCustomErrorResponsePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleCustomErrorResponsePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_response_rules: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleCustomErrorResponsePolicyErrorResponseRule']] = None,
                 error_service: Optional[_builtins.str] = None):
        """
        :param Sequence['URLMapPathMatcherRouteRuleCustomErrorResponsePolicyErrorResponseRuleArgs'] error_response_rules: Specifies rules for returning error responses.
               In a given policy, if you specify rules for both a range of error codes as well as rules for specific error codes then rules with specific error codes have a higher priority.
               For example, assume that you configure a rule for 401 (Un-authorized) code, and another for all 4 series error codes (4XX).
               If the backend service returns a 401, then the rule for 401 will be applied. However if the backend service returns a 403, the rule for 4xx takes effect.
               Structure is documented below.
        :param _builtins.str error_service: The full or partial URL to the BackendBucket resource that contains the custom error content. Examples are:
               https://www.googleapis.com/compute/v1/projects/project/global/backendBuckets/myBackendBucket
               compute/v1/projects/project/global/backendBuckets/myBackendBucket
               global/backendBuckets/myBackendBucket
               If errorService is not specified at lower levels like pathMatcher, pathRule and routeRule, an errorService specified at a higher level in the UrlMap will be used. If UrlMap.defaultCustomErrorResponsePolicy contains one or more errorResponseRules[], it must specify errorService.
               If load balancer cannot reach the backendBucket, a simple Not Found Error will be returned, with the original response code (or overrideResponseCode if configured).
        """
        if error_response_rules is not None:
            pulumi.set(__self__, "error_response_rules", error_response_rules)
        if error_service is not None:
            pulumi.set(__self__, "error_service", error_service)

    @_builtins.property
    @pulumi.getter(name="errorResponseRules")
    def error_response_rules(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleCustomErrorResponsePolicyErrorResponseRule']]:
        """
        Specifies rules for returning error responses.
        In a given policy, if you specify rules for both a range of error codes as well as rules for specific error codes then rules with specific error codes have a higher priority.
        For example, assume that you configure a rule for 401 (Un-authorized) code, and another for all 4 series error codes (4XX).
        If the backend service returns a 401, then the rule for 401 will be applied. However if the backend service returns a 403, the rule for 4xx takes effect.
        Structure is documented below.
        """
        return pulumi.get(self, "error_response_rules")

    @_builtins.property
    @pulumi.getter(name="errorService")
    def error_service(self) -> Optional[_builtins.str]:
        """
        The full or partial URL to the BackendBucket resource that contains the custom error content. Examples are:
        https://www.googleapis.com/compute/v1/projects/project/global/backendBuckets/myBackendBucket
        compute/v1/projects/project/global/backendBuckets/myBackendBucket
        global/backendBuckets/myBackendBucket
        If errorService is not specified at lower levels like pathMatcher, pathRule and routeRule, an errorService specified at a higher level in the UrlMap will be used. If UrlMap.defaultCustomErrorResponsePolicy contains one or more errorResponseRules[], it must specify errorService.
        If load balancer cannot reach the backendBucket, a simple Not Found Error will be returned, with the original response code (or overrideResponseCode if configured).
        """
        return pulumi.get(self, "error_service")


@pulumi.output_type
class URLMapPathMatcherRouteRuleCustomErrorResponsePolicyErrorResponseRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchResponseCodes":
            suggest = "match_response_codes"
        elif key == "overrideResponseCode":
            suggest = "override_response_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleCustomErrorResponsePolicyErrorResponseRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleCustomErrorResponsePolicyErrorResponseRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleCustomErrorResponsePolicyErrorResponseRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_response_codes: Optional[Sequence[_builtins.str]] = None,
                 override_response_code: Optional[_builtins.int] = None,
                 path: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] match_response_codes: Valid values include:
               - A number between 400 and 599: For example 401 or 503, in which case the load balancer applies the policy if the error code exactly matches this value.
               - 5xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 500 to 599.
               - 4xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 400 to 499.
               Values must be unique within matchResponseCodes and across all errorResponseRules of CustomErrorResponsePolicy.
        :param _builtins.int override_response_code: The HTTP status code returned with the response containing the custom error content.
               If overrideResponseCode is not supplied, the same response code returned by the original backend bucket or backend service is returned to the client.
        :param _builtins.str path: The full path to a file within backendBucket. For example: /errors/defaultError.html
               path must start with a leading slash. path cannot have trailing slashes.
               If the file is not available in backendBucket or the load balancer cannot reach the BackendBucket, a simple Not Found Error is returned to the client.
               The value must be from 1 to 1024 characters.
        """
        if match_response_codes is not None:
            pulumi.set(__self__, "match_response_codes", match_response_codes)
        if override_response_code is not None:
            pulumi.set(__self__, "override_response_code", override_response_code)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="matchResponseCodes")
    def match_response_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Valid values include:
        - A number between 400 and 599: For example 401 or 503, in which case the load balancer applies the policy if the error code exactly matches this value.
        - 5xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 500 to 599.
        - 4xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 400 to 499.
        Values must be unique within matchResponseCodes and across all errorResponseRules of CustomErrorResponsePolicy.
        """
        return pulumi.get(self, "match_response_codes")

    @_builtins.property
    @pulumi.getter(name="overrideResponseCode")
    def override_response_code(self) -> Optional[_builtins.int]:
        """
        The HTTP status code returned with the response containing the custom error content.
        If overrideResponseCode is not supplied, the same response code returned by the original backend bucket or backend service is returned to the client.
        """
        return pulumi.get(self, "override_response_code")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        The full path to a file within backendBucket. For example: /errors/defaultError.html
        path must start with a leading slash. path cannot have trailing slashes.
        If the file is not available in backendBucket or the load balancer cannot reach the BackendBucket, a simple Not Found Error is returned to the client.
        The value must be from 1 to 1024 characters.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class URLMapPathMatcherRouteRuleHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"
        elif key == "requestHeadersToRemoves":
            suggest = "request_headers_to_removes"
        elif key == "responseHeadersToAdds":
            suggest = "response_headers_to_adds"
        elif key == "responseHeadersToRemoves":
            suggest = "response_headers_to_removes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[_builtins.str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[_builtins.str] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param Sequence['URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[_builtins.str] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")


@pulumi.output_type
class URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header to add.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header to add.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class URLMapPathMatcherRouteRuleHttpFilterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configTypeUrl":
            suggest = "config_type_url"
        elif key == "filterName":
            suggest = "filter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleHttpFilterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleHttpFilterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleHttpFilterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config: Optional[_builtins.str] = None,
                 config_type_url: Optional[_builtins.str] = None,
                 filter_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str config: The configuration needed to enable the networkservices.HttpFilter resource.
               The configuration must be YAML formatted and only contain fields defined in the protobuf identified in configTypeUrl
        :param _builtins.str config_type_url: The fully qualified versioned proto3 type url of the protobuf that the filter expects for its contextual settings,
               for example: type.googleapis.com/google.protobuf.Struct
        :param _builtins.str filter_name: Name of the networkservices.HttpFilter resource this configuration belongs to.
               This name must be known to the xDS client. Example: envoy.wasm
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if config_type_url is not None:
            pulumi.set(__self__, "config_type_url", config_type_url)
        if filter_name is not None:
            pulumi.set(__self__, "filter_name", filter_name)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[_builtins.str]:
        """
        The configuration needed to enable the networkservices.HttpFilter resource.
        The configuration must be YAML formatted and only contain fields defined in the protobuf identified in configTypeUrl
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter(name="configTypeUrl")
    def config_type_url(self) -> Optional[_builtins.str]:
        """
        The fully qualified versioned proto3 type url of the protobuf that the filter expects for its contextual settings,
        for example: type.googleapis.com/google.protobuf.Struct
        """
        return pulumi.get(self, "config_type_url")

    @_builtins.property
    @pulumi.getter(name="filterName")
    def filter_name(self) -> Optional[_builtins.str]:
        """
        Name of the networkservices.HttpFilter resource this configuration belongs to.
        This name must be known to the xDS client. Example: envoy.wasm
        """
        return pulumi.get(self, "filter_name")


@pulumi.output_type
class URLMapPathMatcherRouteRuleHttpFilterMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configTypeUrl":
            suggest = "config_type_url"
        elif key == "filterName":
            suggest = "filter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleHttpFilterMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleHttpFilterMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleHttpFilterMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config: Optional[_builtins.str] = None,
                 config_type_url: Optional[_builtins.str] = None,
                 filter_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str config: The configuration needed to enable the networkservices.HttpFilter resource.
               The configuration must be YAML formatted and only contain fields defined in the protobuf identified in configTypeUrl
        :param _builtins.str config_type_url: The fully qualified versioned proto3 type url of the protobuf that the filter expects for its contextual settings,
               for example: type.googleapis.com/google.protobuf.Struct
        :param _builtins.str filter_name: Name of the networkservices.HttpFilter resource this configuration belongs to.
               This name must be known to the xDS client. Example: envoy.wasm
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if config_type_url is not None:
            pulumi.set(__self__, "config_type_url", config_type_url)
        if filter_name is not None:
            pulumi.set(__self__, "filter_name", filter_name)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[_builtins.str]:
        """
        The configuration needed to enable the networkservices.HttpFilter resource.
        The configuration must be YAML formatted and only contain fields defined in the protobuf identified in configTypeUrl
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter(name="configTypeUrl")
    def config_type_url(self) -> Optional[_builtins.str]:
        """
        The fully qualified versioned proto3 type url of the protobuf that the filter expects for its contextual settings,
        for example: type.googleapis.com/google.protobuf.Struct
        """
        return pulumi.get(self, "config_type_url")

    @_builtins.property
    @pulumi.getter(name="filterName")
    def filter_name(self) -> Optional[_builtins.str]:
        """
        Name of the networkservices.HttpFilter resource this configuration belongs to.
        This name must be known to the xDS client. Example: envoy.wasm
        """
        return pulumi.get(self, "filter_name")


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullPathMatch":
            suggest = "full_path_match"
        elif key == "headerMatches":
            suggest = "header_matches"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "metadataFilters":
            suggest = "metadata_filters"
        elif key == "pathTemplateMatch":
            suggest = "path_template_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "queryParameterMatches":
            suggest = "query_parameter_matches"
        elif key == "regexMatch":
            suggest = "regex_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleMatchRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleMatchRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleMatchRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 full_path_match: Optional[_builtins.str] = None,
                 header_matches: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleHeaderMatch']] = None,
                 ignore_case: Optional[_builtins.bool] = None,
                 metadata_filters: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleMetadataFilter']] = None,
                 path_template_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 query_parameter_matches: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch']] = None,
                 regex_match: Optional[_builtins.str] = None):
        """
        :param _builtins.str full_path_match: For satisfying the matchRule condition, the path of the request must exactly
               match the value specified in fullPathMatch after removing any query parameters
               and anchor that may be part of the original URL. FullPathMatch must be between 1
               and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
               be specified.
        :param Sequence['URLMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs'] header_matches: Specifies a list of header match criteria, all of which must match corresponding
               headers in the request.
               Structure is documented below.
        :param _builtins.bool ignore_case: Specifies that prefixMatch and fullPathMatch matches are case sensitive.
               Defaults to false.
        :param Sequence['URLMapPathMatcherRouteRuleMatchRuleMetadataFilterArgs'] metadata_filters: Opaque filter criteria used by Loadbalancer to restrict routing configuration to
               a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
               clients present node metadata. If a match takes place, the relevant routing
               configuration is made available to those proxies. For each metadataFilter in
               this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
               filterLabels must match the corresponding label provided in the metadata. If its
               filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
               with corresponding labels in the provided metadata. metadataFilters specified
               here can be overrides those specified in ForwardingRule that refers to this
               UrlMap. metadataFilters only applies to Loadbalancers that have their
               loadBalancingScheme set to INTERNAL_SELF_MANAGED.
               Structure is documented below.
        :param _builtins.str path_template_match: For satisfying the matchRule condition, the path of the request
               must match the wildcard pattern specified in pathTemplateMatch
               after removing any query parameters and anchor that may be part
               of the original URL.
               pathTemplateMatch must be between 1 and 255 characters
               (inclusive).  The pattern specified by pathTemplateMatch may
               have at most 5 wildcard operators and at most 5 variable
               captures in total.
        :param _builtins.str prefix_match: For satisfying the matchRule condition, the request's path must begin with the
               specified prefixMatch. prefixMatch must begin with a /. The value must be
               between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
               regexMatch must be specified.
        :param Sequence['URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs'] query_parameter_matches: Specifies a list of query parameter match criteria, all of which must match
               corresponding query parameters in the request.
               Structure is documented below.
        :param _builtins.str regex_match: For satisfying the matchRule condition, the path of the request must satisfy the
               regular expression specified in regexMatch after removing any query parameters
               and anchor supplied with the original URL. For regular expression grammar please
               see en.cppreference.com/w/cpp/regex/ecmascript  Only one of prefixMatch,
               fullPathMatch or regexMatch must be specified.
        """
        if full_path_match is not None:
            pulumi.set(__self__, "full_path_match", full_path_match)
        if header_matches is not None:
            pulumi.set(__self__, "header_matches", header_matches)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if metadata_filters is not None:
            pulumi.set(__self__, "metadata_filters", metadata_filters)
        if path_template_match is not None:
            pulumi.set(__self__, "path_template_match", path_template_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if query_parameter_matches is not None:
            pulumi.set(__self__, "query_parameter_matches", query_parameter_matches)
        if regex_match is not None:
            pulumi.set(__self__, "regex_match", regex_match)

    @_builtins.property
    @pulumi.getter(name="fullPathMatch")
    def full_path_match(self) -> Optional[_builtins.str]:
        """
        For satisfying the matchRule condition, the path of the request must exactly
        match the value specified in fullPathMatch after removing any query parameters
        and anchor that may be part of the original URL. FullPathMatch must be between 1
        and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
        be specified.
        """
        return pulumi.get(self, "full_path_match")

    @_builtins.property
    @pulumi.getter(name="headerMatches")
    def header_matches(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleHeaderMatch']]:
        """
        Specifies a list of header match criteria, all of which must match corresponding
        headers in the request.
        Structure is documented below.
        """
        return pulumi.get(self, "header_matches")

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[_builtins.bool]:
        """
        Specifies that prefixMatch and fullPathMatch matches are case sensitive.
        Defaults to false.
        """
        return pulumi.get(self, "ignore_case")

    @_builtins.property
    @pulumi.getter(name="metadataFilters")
    def metadata_filters(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleMetadataFilter']]:
        """
        Opaque filter criteria used by Loadbalancer to restrict routing configuration to
        a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
        clients present node metadata. If a match takes place, the relevant routing
        configuration is made available to those proxies. For each metadataFilter in
        this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
        filterLabels must match the corresponding label provided in the metadata. If its
        filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
        with corresponding labels in the provided metadata. metadataFilters specified
        here can be overrides those specified in ForwardingRule that refers to this
        UrlMap. metadataFilters only applies to Loadbalancers that have their
        loadBalancingScheme set to INTERNAL_SELF_MANAGED.
        Structure is documented below.
        """
        return pulumi.get(self, "metadata_filters")

    @_builtins.property
    @pulumi.getter(name="pathTemplateMatch")
    def path_template_match(self) -> Optional[_builtins.str]:
        """
        For satisfying the matchRule condition, the path of the request
        must match the wildcard pattern specified in pathTemplateMatch
        after removing any query parameters and anchor that may be part
        of the original URL.
        pathTemplateMatch must be between 1 and 255 characters
        (inclusive).  The pattern specified by pathTemplateMatch may
        have at most 5 wildcard operators and at most 5 variable
        captures in total.
        """
        return pulumi.get(self, "path_template_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        """
        For satisfying the matchRule condition, the request's path must begin with the
        specified prefixMatch. prefixMatch must begin with a /. The value must be
        between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
        regexMatch must be specified.
        """
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="queryParameterMatches")
    def query_parameter_matches(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch']]:
        """
        Specifies a list of query parameter match criteria, all of which must match
        corresponding query parameters in the request.
        Structure is documented below.
        """
        return pulumi.get(self, "query_parameter_matches")

    @_builtins.property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[_builtins.str]:
        """
        For satisfying the matchRule condition, the path of the request must satisfy the
        regular expression specified in regexMatch after removing any query parameters
        and anchor supplied with the original URL. For regular expression grammar please
        see en.cppreference.com/w/cpp/regex/ecmascript  Only one of prefixMatch,
        fullPathMatch or regexMatch must be specified.
        """
        return pulumi.get(self, "regex_match")


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleHeaderMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "exactMatch":
            suggest = "exact_match"
        elif key == "invertMatch":
            suggest = "invert_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "presentMatch":
            suggest = "present_match"
        elif key == "rangeMatch":
            suggest = "range_match"
        elif key == "regexMatch":
            suggest = "regex_match"
        elif key == "suffixMatch":
            suggest = "suffix_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleMatchRuleHeaderMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleMatchRuleHeaderMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleMatchRuleHeaderMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 exact_match: Optional[_builtins.str] = None,
                 invert_match: Optional[_builtins.bool] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 present_match: Optional[_builtins.bool] = None,
                 range_match: Optional['outputs.URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch'] = None,
                 regex_match: Optional[_builtins.str] = None,
                 suffix_match: Optional[_builtins.str] = None):
        """
        :param _builtins.str header_name: The name of the HTTP header to match. For matching against the HTTP request's
               authority, use a headerMatch with the header name ":authority". For matching a
               request's method, use the headerName ":method".
        :param _builtins.str exact_match: The value should exactly match contents of exactMatch. Only one of exactMatch,
               prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
        :param _builtins.bool invert_match: If set to false, the headerMatch is considered a match if the match criteria
               above are met. If set to true, the headerMatch is considered a match if the
               match criteria above are NOT met. Defaults to false.
        :param _builtins.str prefix_match: The value of the header must start with the contents of prefixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        :param _builtins.bool present_match: A header with the contents of headerName must exist. The match takes place
               whether or not the request's header has a value or not. Only one of exactMatch,
               prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
        :param 'URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatchArgs' range_match: The header value must be an integer and its value must be in the range specified
               in rangeMatch. If the header does not contain an integer, number or is empty,
               the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
               not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
               Structure is documented below.
        :param _builtins.str regex_match: The value of the header must match the regular expression specified in
               regexMatch. For regular expression grammar, please see:
               en.cppreference.com/w/cpp/regex/ecmascript  For matching against a port
               specified in the HTTP request, use a headerMatch with headerName set to PORT and
               a regular expression that satisfies the RFC2616 Host header's port specifier.
               Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
               rangeMatch must be set.
        :param _builtins.str suffix_match: The value of the header must end with the contents of suffixMatch. Only one of
               exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
               must be set.
        """
        pulumi.set(__self__, "header_name", header_name)
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if invert_match is not None:
            pulumi.set(__self__, "invert_match", invert_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if present_match is not None:
            pulumi.set(__self__, "present_match", present_match)
        if range_match is not None:
            pulumi.set(__self__, "range_match", range_match)
        if regex_match is not None:
            pulumi.set(__self__, "regex_match", regex_match)
        if suffix_match is not None:
            pulumi.set(__self__, "suffix_match", suffix_match)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the HTTP header to match. For matching against the HTTP request's
        authority, use a headerMatch with the header name ":authority". For matching a
        request's method, use the headerName ":method".
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        """
        The value should exactly match contents of exactMatch. Only one of exactMatch,
        prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
        """
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="invertMatch")
    def invert_match(self) -> Optional[_builtins.bool]:
        """
        If set to false, the headerMatch is considered a match if the match criteria
        above are met. If set to true, the headerMatch is considered a match if the
        match criteria above are NOT met. Defaults to false.
        """
        return pulumi.get(self, "invert_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        """
        The value of the header must start with the contents of prefixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="presentMatch")
    def present_match(self) -> Optional[_builtins.bool]:
        """
        A header with the contents of headerName must exist. The match takes place
        whether or not the request's header has a value or not. Only one of exactMatch,
        prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
        """
        return pulumi.get(self, "present_match")

    @_builtins.property
    @pulumi.getter(name="rangeMatch")
    def range_match(self) -> Optional['outputs.URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch']:
        """
        The header value must be an integer and its value must be in the range specified
        in rangeMatch. If the header does not contain an integer, number or is empty,
        the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
        not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "range_match")

    @_builtins.property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[_builtins.str]:
        """
        The value of the header must match the regular expression specified in
        regexMatch. For regular expression grammar, please see:
        en.cppreference.com/w/cpp/regex/ecmascript  For matching against a port
        specified in the HTTP request, use a headerMatch with headerName set to PORT and
        a regular expression that satisfies the RFC2616 Host header's port specifier.
        Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
        rangeMatch must be set.
        """
        return pulumi.get(self, "regex_match")

    @_builtins.property
    @pulumi.getter(name="suffixMatch")
    def suffix_match(self) -> Optional[_builtins.str]:
        """
        The value of the header must end with the contents of suffixMatch. Only one of
        exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
        must be set.
        """
        return pulumi.get(self, "suffix_match")


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeEnd":
            suggest = "range_end"
        elif key == "rangeStart":
            suggest = "range_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_end: _builtins.int,
                 range_start: _builtins.int):
        """
        :param _builtins.int range_end: The end of the range (exclusive).
        :param _builtins.int range_start: The start of the range (inclusive).
        """
        pulumi.set(__self__, "range_end", range_end)
        pulumi.set(__self__, "range_start", range_start)

    @_builtins.property
    @pulumi.getter(name="rangeEnd")
    def range_end(self) -> _builtins.int:
        """
        The end of the range (exclusive).
        """
        return pulumi.get(self, "range_end")

    @_builtins.property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> _builtins.int:
        """
        The start of the range (inclusive).
        """
        return pulumi.get(self, "range_start")


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleMetadataFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterLabels":
            suggest = "filter_labels"
        elif key == "filterMatchCriteria":
            suggest = "filter_match_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleMatchRuleMetadataFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleMatchRuleMetadataFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleMatchRuleMetadataFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_labels: Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel'],
                 filter_match_criteria: _builtins.str):
        """
        :param Sequence['URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabelArgs'] filter_labels: The list of label value pairs that must match labels in the provided metadata
               based on filterMatchCriteria  This list must not be empty and can have at the
               most 64 entries.
               Structure is documented below.
        :param _builtins.str filter_match_criteria: Specifies how individual filterLabel matches within the list of filterLabels
               contribute towards the overall metadataFilter match. Supported values are:
               - MATCH_ANY: At least one of the filterLabels must have a matching label in the
               provided metadata.
               - MATCH_ALL: All filterLabels must have matching labels in
               the provided metadata.
               Possible values are: `MATCH_ALL`, `MATCH_ANY`.
        """
        pulumi.set(__self__, "filter_labels", filter_labels)
        pulumi.set(__self__, "filter_match_criteria", filter_match_criteria)

    @_builtins.property
    @pulumi.getter(name="filterLabels")
    def filter_labels(self) -> Sequence['outputs.URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel']:
        """
        The list of label value pairs that must match labels in the provided metadata
        based on filterMatchCriteria  This list must not be empty and can have at the
        most 64 entries.
        Structure is documented below.
        """
        return pulumi.get(self, "filter_labels")

    @_builtins.property
    @pulumi.getter(name="filterMatchCriteria")
    def filter_match_criteria(self) -> _builtins.str:
        """
        Specifies how individual filterLabel matches within the list of filterLabels
        contribute towards the overall metadataFilter match. Supported values are:
        - MATCH_ANY: At least one of the filterLabels must have a matching label in the
        provided metadata.
        - MATCH_ALL: All filterLabels must have matching labels in
        the provided metadata.
        Possible values are: `MATCH_ALL`, `MATCH_ANY`.
        """
        return pulumi.get(self, "filter_match_criteria")


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Name of metadata label. The name can have a maximum length of 1024 characters
               and must be at least 1 character long.
        :param _builtins.str value: The value of the label must match the specified value. value can have a maximum
               length of 1024 characters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of metadata label. The name can have a maximum length of 1024 characters
        and must be at least 1 character long.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the label must match the specified value. value can have a maximum
        length of 1024 characters.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "presentMatch":
            suggest = "present_match"
        elif key == "regexMatch":
            suggest = "regex_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 exact_match: Optional[_builtins.str] = None,
                 present_match: Optional[_builtins.bool] = None,
                 regex_match: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the query parameter to match. The query parameter must exist in the
               request, in the absence of which the request match fails.
        :param _builtins.str exact_match: The queryParameterMatch matches if the value of the parameter exactly matches
               the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
               must be set.
        :param _builtins.bool present_match: Specifies that the queryParameterMatch matches if the request contains the query
               parameter, irrespective of whether the parameter has a value or not. Only one of
               presentMatch, exactMatch and regexMatch must be set.
        :param _builtins.str regex_match: The queryParameterMatch matches if the value of the parameter matches the
               regular expression specified by regexMatch. For the regular expression grammar,
               please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
               exactMatch and regexMatch must be set.
        """
        pulumi.set(__self__, "name", name)
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if present_match is not None:
            pulumi.set(__self__, "present_match", present_match)
        if regex_match is not None:
            pulumi.set(__self__, "regex_match", regex_match)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the query parameter to match. The query parameter must exist in the
        request, in the absence of which the request match fails.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        """
        The queryParameterMatch matches if the value of the parameter exactly matches
        the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
        must be set.
        """
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="presentMatch")
    def present_match(self) -> Optional[_builtins.bool]:
        """
        Specifies that the queryParameterMatch matches if the request contains the query
        parameter, irrespective of whether the parameter has a value or not. Only one of
        presentMatch, exactMatch and regexMatch must be set.
        """
        return pulumi.get(self, "present_match")

    @_builtins.property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[_builtins.str]:
        """
        The queryParameterMatch matches if the value of the parameter matches the
        regular expression specified by regexMatch. For the regular expression grammar,
        please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
        exactMatch and regexMatch must be set.
        """
        return pulumi.get(self, "regex_match")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "corsPolicy":
            suggest = "cors_policy"
        elif key == "faultInjectionPolicy":
            suggest = "fault_injection_policy"
        elif key == "maxStreamDuration":
            suggest = "max_stream_duration"
        elif key == "requestMirrorPolicy":
            suggest = "request_mirror_policy"
        elif key == "retryPolicy":
            suggest = "retry_policy"
        elif key == "urlRewrite":
            suggest = "url_rewrite"
        elif key == "weightedBackendServices":
            suggest = "weighted_backend_services"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cors_policy: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionCorsPolicy'] = None,
                 fault_injection_policy: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy'] = None,
                 max_stream_duration: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionMaxStreamDuration'] = None,
                 request_mirror_policy: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy'] = None,
                 retry_policy: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRetryPolicy'] = None,
                 timeout: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionTimeout'] = None,
                 url_rewrite: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionUrlRewrite'] = None,
                 weighted_backend_services: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendService']] = None):
        """
        :param 'URLMapPathMatcherRouteRuleRouteActionCorsPolicyArgs' cors_policy: The specification for allowing client side cross-origin requests. Please see W3C
               Recommendation for Cross Origin Resource Sharing
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyArgs' fault_injection_policy: The specification for fault injection introduced into traffic to test the
               resiliency of clients to backend service failure. As part of fault injection,
               when clients send requests to a backend service, delays can be introduced by
               Loadbalancer on a percentage of requests before sending those request to the
               backend service. Similarly requests from clients can be aborted by the
               Loadbalancer for a percentage of requests. timeout and retry_policy will be
               ignored by clients that are configured with a fault_injection_policy.
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionMaxStreamDurationArgs' max_stream_duration: Specifies the maximum duration (timeout) for streams on the selected route.
               Unlike the `Timeout` field where the timeout duration starts from the time the request
               has been fully processed (known as end-of-stream), the duration in this field
               is computed from the beginning of the stream until the response has been processed,
               including all retries. A stream that does not complete in this duration is closed.
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicyArgs' request_mirror_policy: Specifies the policy on how requests intended for the route's backends are
               shadowed to a separate mirrored backend service. Loadbalancer does not wait for
               responses from the shadow service. Prior to sending traffic to the shadow
               service, the host / authority header is suffixed with -shadow.
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionRetryPolicyArgs' retry_policy: Specifies the retry policy associated with this route.
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionTimeoutArgs' timeout: Specifies the timeout for the selected route. Timeout is computed from the time
               the request is has been fully processed (i.e. end-of-stream) up until the
               response has been completely processed. Timeout includes all retries. If not
               specified, the default value is 15 seconds.
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionUrlRewriteArgs' url_rewrite: The spec to modify the URL of the request, prior to forwarding the request to
               the matched service
               Structure is documented below.
        :param Sequence['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceArgs'] weighted_backend_services: A list of weighted backend services to send traffic to when a route match
               occurs. The weights determine the fraction of traffic that flows to their
               corresponding backend service. If all traffic needs to go to a single backend
               service, there must be one  weightedBackendService with weight set to a non 0
               number. Once a backendService is identified and before forwarding the request to
               the backend service, advanced routing actions like Url rewrites and header
               transformations are applied depending on additional settings specified in this
               HttpRouteAction.
               Structure is documented below.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if fault_injection_policy is not None:
            pulumi.set(__self__, "fault_injection_policy", fault_injection_policy)
        if max_stream_duration is not None:
            pulumi.set(__self__, "max_stream_duration", max_stream_duration)
        if request_mirror_policy is not None:
            pulumi.set(__self__, "request_mirror_policy", request_mirror_policy)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)
        if weighted_backend_services is not None:
            pulumi.set(__self__, "weighted_backend_services", weighted_backend_services)

    @_builtins.property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionCorsPolicy']:
        """
        The specification for allowing client side cross-origin requests. Please see W3C
        Recommendation for Cross Origin Resource Sharing
        Structure is documented below.
        """
        return pulumi.get(self, "cors_policy")

    @_builtins.property
    @pulumi.getter(name="faultInjectionPolicy")
    def fault_injection_policy(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy']:
        """
        The specification for fault injection introduced into traffic to test the
        resiliency of clients to backend service failure. As part of fault injection,
        when clients send requests to a backend service, delays can be introduced by
        Loadbalancer on a percentage of requests before sending those request to the
        backend service. Similarly requests from clients can be aborted by the
        Loadbalancer for a percentage of requests. timeout and retry_policy will be
        ignored by clients that are configured with a fault_injection_policy.
        Structure is documented below.
        """
        return pulumi.get(self, "fault_injection_policy")

    @_builtins.property
    @pulumi.getter(name="maxStreamDuration")
    def max_stream_duration(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionMaxStreamDuration']:
        """
        Specifies the maximum duration (timeout) for streams on the selected route.
        Unlike the `Timeout` field where the timeout duration starts from the time the request
        has been fully processed (known as end-of-stream), the duration in this field
        is computed from the beginning of the stream until the response has been processed,
        including all retries. A stream that does not complete in this duration is closed.
        Structure is documented below.
        """
        return pulumi.get(self, "max_stream_duration")

    @_builtins.property
    @pulumi.getter(name="requestMirrorPolicy")
    def request_mirror_policy(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy']:
        """
        Specifies the policy on how requests intended for the route's backends are
        shadowed to a separate mirrored backend service. Loadbalancer does not wait for
        responses from the shadow service. Prior to sending traffic to the shadow
        service, the host / authority header is suffixed with -shadow.
        Structure is documented below.
        """
        return pulumi.get(self, "request_mirror_policy")

    @_builtins.property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRetryPolicy']:
        """
        Specifies the retry policy associated with this route.
        Structure is documented below.
        """
        return pulumi.get(self, "retry_policy")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionTimeout']:
        """
        Specifies the timeout for the selected route. Timeout is computed from the time
        the request is has been fully processed (i.e. end-of-stream) up until the
        response has been completely processed. Timeout includes all retries. If not
        specified, the default value is 15 seconds.
        Structure is documented below.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionUrlRewrite']:
        """
        The spec to modify the URL of the request, prior to forwarding the request to
        the matched service
        Structure is documented below.
        """
        return pulumi.get(self, "url_rewrite")

    @_builtins.property
    @pulumi.getter(name="weightedBackendServices")
    def weighted_backend_services(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendService']]:
        """
        A list of weighted backend services to send traffic to when a route match
        occurs. The weights determine the fraction of traffic that flows to their
        corresponding backend service. If all traffic needs to go to a single backend
        service, there must be one  weightedBackendService with weight set to a non 0
        number. Once a backendService is identified and before forwarding the request to
        the backend service, advanced routing actions like Url rewrites and header
        transformations are applied depending on additional settings specified in this
        HttpRouteAction.
        Structure is documented below.
        """
        return pulumi.get(self, "weighted_backend_services")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionCorsPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOriginRegexes":
            suggest = "allow_origin_regexes"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleRouteActionCorsPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleRouteActionCorsPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleRouteActionCorsPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origin_regexes: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional[Sequence[_builtins.str]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        :param _builtins.bool allow_credentials: In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
               This translates to the Access-Control-Allow-Credentials header.
        :param Sequence[_builtins.str] allow_headers: Specifies the content for the Access-Control-Allow-Headers header.
        :param Sequence[_builtins.str] allow_methods: Specifies the content for the Access-Control-Allow-Methods header.
        :param Sequence[_builtins.str] allow_origin_regexes: Specifies the regular expression patterns that match allowed origins. For regular expression grammar
               please see en.cppreference.com/w/cpp/regex/ecmascript
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param Sequence[_builtins.str] allow_origins: Specifies the list of origins that will be allowed to do CORS requests.
               An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        :param _builtins.bool disabled: If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        :param Sequence[_builtins.str] expose_headers: Specifies the content for the Access-Control-Expose-Headers header.
        :param _builtins.int max_age: Specifies how long results of a preflight request can be cached in seconds.
               This translates to the Access-Control-Max-Age header.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin_regexes is not None:
            pulumi.set(__self__, "allow_origin_regexes", allow_origin_regexes)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
        This translates to the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOriginRegexes")
    def allow_origin_regexes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the regular expression patterns that match allowed origins. For regular expression grammar
        please see en.cppreference.com/w/cpp/regex/ecmascript
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origin_regexes")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of origins that will be allowed to do CORS requests.
        An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Specifies how long results of a preflight request can be cached in seconds.
        This translates to the Access-Control-Max-Age header.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy(dict):
    def __init__(__self__, *,
                 abort: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort'] = None,
                 delay: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay'] = None):
        """
        :param 'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbortArgs' abort: The specification for how client requests are aborted as part of fault injection.
               Structure is documented below.
        :param 'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayArgs' delay: The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
               Structure is documented below.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def abort(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort']:
        """
        The specification for how client requests are aborted as part of fault injection.
        Structure is documented below.
        """
        return pulumi.get(self, "abort")

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay']:
        """
        The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
        Structure is documented below.
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpStatus":
            suggest = "http_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_status: Optional[_builtins.int] = None,
                 percentage: Optional[_builtins.float] = None):
        """
        :param _builtins.int http_status: The HTTP status code used to abort the request.
               The value must be between 200 and 599 inclusive.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if http_status is not None:
            pulumi.set(__self__, "http_status", http_status)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[_builtins.int]:
        """
        The HTTP status code used to abort the request.
        The value must be between 200 and 599 inclusive.
        """
        return pulumi.get(self, "http_status")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedDelay":
            suggest = "fixed_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_delay: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay'] = None,
                 percentage: Optional[_builtins.float] = None):
        """
        :param 'URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs' fixed_delay: Specifies the value of the fixed delay interval.
               Structure is documented below.
        :param _builtins.float percentage: The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
               The value must be between 0.0 and 100.0 inclusive.
        """
        if fixed_delay is not None:
            pulumi.set(__self__, "fixed_delay", fixed_delay)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="fixedDelay")
    def fixed_delay(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay']:
        """
        Specifies the value of the fixed delay interval.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_delay")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionMaxStreamDuration(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "mirrorPercent":
            suggest = "mirror_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: _builtins.str,
                 mirror_percent: Optional[_builtins.float] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the BackendService resource being mirrored to.
        :param _builtins.float mirror_percent: The percentage of requests to be mirrored to backendService.
               The value must be between 0.0 and 100.0 inclusive.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        if mirror_percent is not None:
            pulumi.set(__self__, "mirror_percent", mirror_percent)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> _builtins.str:
        """
        The full or partial URL to the BackendService resource being mirrored to.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter(name="mirrorPercent")
    def mirror_percent(self) -> Optional[_builtins.float]:
        """
        The percentage of requests to be mirrored to backendService.
        The value must be between 0.0 and 100.0 inclusive.
        """
        return pulumi.get(self, "mirror_percent")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionRetryPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numRetries":
            suggest = "num_retries"
        elif key == "perTryTimeout":
            suggest = "per_try_timeout"
        elif key == "retryConditions":
            suggest = "retry_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleRouteActionRetryPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleRouteActionRetryPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleRouteActionRetryPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_retries: _builtins.int,
                 per_try_timeout: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout'] = None,
                 retry_conditions: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int num_retries: Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        :param 'URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeoutArgs' per_try_timeout: Specifies a non-zero timeout per retry attempt.
               If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
               will use the largest timeout among all backend services associated with the route.
               Structure is documented below.
        :param Sequence[_builtins.str] retry_conditions: Specfies one or more conditions when this retry rule applies. Valid values are:
               * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
               or if the backend service does not respond at all, example: disconnects, reset, read timeout,
               * connection failure, and refused streams.
               * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
               * connect-failure: Loadbalancer will retry on failures connecting to backend services,
               for example due to connection timeouts.
               * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
               Currently the only retriable error supported is 409.
               * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
               This reset type indicates that it is safe to retry.
               * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
               * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
               * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
               * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        pulumi.set(__self__, "num_retries", num_retries)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_conditions is not None:
            pulumi.set(__self__, "retry_conditions", retry_conditions)

    @_builtins.property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> _builtins.int:
        """
        Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
        """
        return pulumi.get(self, "num_retries")

    @_builtins.property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout']:
        """
        Specifies a non-zero timeout per retry attempt.
        If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
        will use the largest timeout among all backend services associated with the route.
        Structure is documented below.
        """
        return pulumi.get(self, "per_try_timeout")

    @_builtins.property
    @pulumi.getter(name="retryConditions")
    def retry_conditions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specfies one or more conditions when this retry rule applies. Valid values are:
        * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
        or if the backend service does not respond at all, example: disconnects, reset, read timeout,
        * connection failure, and refused streams.
        * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
        * connect-failure: Loadbalancer will retry on failures connecting to backend services,
        for example due to connection timeouts.
        * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
        Currently the only retriable error supported is 409.
        * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
        This reset type indicates that it is safe to retry.
        * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
        * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
        * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
        * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
        """
        return pulumi.get(self, "retry_conditions")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
               represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
        represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionTimeout(dict):
    def __init__(__self__, *,
                 seconds: _builtins.str,
                 nanos: Optional[_builtins.int] = None):
        """
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
               Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        pulumi.set(__self__, "seconds", seconds)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
        Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> Optional[_builtins.int]:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionUrlRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostRewrite":
            suggest = "host_rewrite"
        elif key == "pathPrefixRewrite":
            suggest = "path_prefix_rewrite"
        elif key == "pathTemplateRewrite":
            suggest = "path_template_rewrite"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleRouteActionUrlRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleRouteActionUrlRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleRouteActionUrlRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_rewrite: Optional[_builtins.str] = None,
                 path_prefix_rewrite: Optional[_builtins.str] = None,
                 path_template_rewrite: Optional[_builtins.str] = None):
        """
        :param _builtins.str host_rewrite: Prior to forwarding the request to the selected service, the request's host header is replaced
               with contents of hostRewrite.
               The value must be between 1 and 255 characters.
        :param _builtins.str path_prefix_rewrite: Prior to forwarding the request to the selected backend service, the matching portion of the
               request's path is replaced by pathPrefixRewrite.
               The value must be between 1 and 1024 characters.
        :param _builtins.str path_template_rewrite: Prior to forwarding the request to the selected origin, if the
               request matched a pathTemplateMatch, the matching portion of the
               request's path is replaced re-written using the pattern specified
               by pathTemplateRewrite.
               pathTemplateRewrite must be between 1 and 255 characters
               (inclusive), must start with a '/', and must only use variables
               captured by the route's pathTemplate matchers.
               pathTemplateRewrite may only be used when all of a route's
               MatchRules specify pathTemplate.
               Only one of pathPrefixRewrite and pathTemplateRewrite may be
               specified.
        """
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if path_prefix_rewrite is not None:
            pulumi.set(__self__, "path_prefix_rewrite", path_prefix_rewrite)
        if path_template_rewrite is not None:
            pulumi.set(__self__, "path_template_rewrite", path_template_rewrite)

    @_builtins.property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[_builtins.str]:
        """
        Prior to forwarding the request to the selected service, the request's host header is replaced
        with contents of hostRewrite.
        The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_rewrite")

    @_builtins.property
    @pulumi.getter(name="pathPrefixRewrite")
    def path_prefix_rewrite(self) -> Optional[_builtins.str]:
        """
        Prior to forwarding the request to the selected backend service, the matching portion of the
        request's path is replaced by pathPrefixRewrite.
        The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "path_prefix_rewrite")

    @_builtins.property
    @pulumi.getter(name="pathTemplateRewrite")
    def path_template_rewrite(self) -> Optional[_builtins.str]:
        """
        Prior to forwarding the request to the selected origin, if the
        request matched a pathTemplateMatch, the matching portion of the
        request's path is replaced re-written using the pattern specified
        by pathTemplateRewrite.
        pathTemplateRewrite must be between 1 and 255 characters
        (inclusive), must start with a '/', and must only use variables
        captured by the route's pathTemplate matchers.
        pathTemplateRewrite may only be used when all of a route's
        MatchRules specify pathTemplate.
        Only one of pathPrefixRewrite and pathTemplateRewrite may be
        specified.
        """
        return pulumi.get(self, "path_template_rewrite")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendService":
            suggest = "backend_service"
        elif key == "headerAction":
            suggest = "header_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleRouteActionWeightedBackendService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleRouteActionWeightedBackendService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleRouteActionWeightedBackendService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_service: _builtins.str,
                 weight: _builtins.int,
                 header_action: Optional['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction'] = None):
        """
        :param _builtins.str backend_service: The full or partial URL to the default BackendService resource. Before forwarding the
               request to backendService, the loadbalancer applies any relevant headerActions
               specified as part of this backendServiceWeight.
        :param _builtins.int weight: Specifies the fraction of traffic sent to backendService, computed as
               weight / (sum of all weightedBackendService weights in routeAction) .
               The selection of a backend service is determined only for new traffic. Once a user's request
               has been directed to a backendService, subsequent requests will be sent to the same backendService
               as determined by the BackendService's session affinity policy.
               The value must be between 0 and 1000
        :param 'URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionArgs' header_action: Specifies changes to request and response headers that need to take effect for
               the selected backendService.
               headerAction specified here take effect before headerAction in the enclosing
               HttpRouteRule, PathMatcher and UrlMap.
               Structure is documented below.
        """
        pulumi.set(__self__, "backend_service", backend_service)
        pulumi.set(__self__, "weight", weight)
        if header_action is not None:
            pulumi.set(__self__, "header_action", header_action)

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> _builtins.str:
        """
        The full or partial URL to the default BackendService resource. Before forwarding the
        request to backendService, the loadbalancer applies any relevant headerActions
        specified as part of this backendServiceWeight.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        Specifies the fraction of traffic sent to backendService, computed as
        weight / (sum of all weightedBackendService weights in routeAction) .
        The selection of a backend service is determined only for new traffic. Once a user's request
        has been directed to a backendService, subsequent requests will be sent to the same backendService
        as determined by the BackendService's session affinity policy.
        The value must be between 0 and 1000
        """
        return pulumi.get(self, "weight")

    @_builtins.property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> Optional['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction']:
        """
        Specifies changes to request and response headers that need to take effect for
        the selected backendService.
        headerAction specified here take effect before headerAction in the enclosing
        HttpRouteRule, PathMatcher and UrlMap.
        Structure is documented below.
        """
        return pulumi.get(self, "header_action")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeadersToAdds":
            suggest = "request_headers_to_adds"
        elif key == "requestHeadersToRemoves":
            suggest = "request_headers_to_removes"
        elif key == "responseHeadersToAdds":
            suggest = "response_headers_to_adds"
        elif key == "responseHeadersToRemoves":
            suggest = "response_headers_to_removes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']] = None,
                 request_headers_to_removes: Optional[Sequence[_builtins.str]] = None,
                 response_headers_to_adds: Optional[Sequence['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']] = None,
                 response_headers_to_removes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: Headers to add to a matching request prior to forwarding the request to the backendService.
               Structure is documented below.
        :param Sequence[_builtins.str] request_headers_to_removes: A list of header names for headers that need to be removed from the request prior to
               forwarding the request to the backendService.
        :param Sequence['URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs'] response_headers_to_adds: Headers to add the response prior to sending the response back to the client.
               Structure is documented below.
        :param Sequence[_builtins.str] response_headers_to_removes: A list of header names for headers that need to be removed from the response prior to sending the
               response back to the client.
        """
        if request_headers_to_adds is not None:
            pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)
        if request_headers_to_removes is not None:
            pulumi.set(__self__, "request_headers_to_removes", request_headers_to_removes)
        if response_headers_to_adds is not None:
            pulumi.set(__self__, "response_headers_to_adds", response_headers_to_adds)
        if response_headers_to_removes is not None:
            pulumi.set(__self__, "response_headers_to_removes", response_headers_to_removes)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd']]:
        """
        Headers to add to a matching request prior to forwarding the request to the backendService.
        Structure is documented below.
        """
        return pulumi.get(self, "request_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="requestHeadersToRemoves")
    def request_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the request prior to
        forwarding the request to the backendService.
        """
        return pulumi.get(self, "request_headers_to_removes")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToAdds")
    def response_headers_to_adds(self) -> Optional[Sequence['outputs.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd']]:
        """
        Headers to add the response prior to sending the response back to the client.
        Structure is documented below.
        """
        return pulumi.get(self, "response_headers_to_adds")

    @_builtins.property
    @pulumi.getter(name="responseHeadersToRemoves")
    def response_headers_to_removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of header names for headers that need to be removed from the response prior to sending the
        response back to the client.
        """
        return pulumi.get(self, "response_headers_to_removes")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header to add.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str,
                 replace: _builtins.bool):
        """
        :param _builtins.str header_name: The name of the header to add.
        :param _builtins.str header_value: The value of the header to add.
        :param _builtins.bool replace: If false, headerValue is appended to any values that already exist for the header.
               If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header to add.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value of the header to add.
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.bool:
        """
        If false, headerValue is appended to any values that already exist for the header.
        If true, headerValue is set for the header, discarding any values that were set for that header.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class URLMapPathMatcherRouteRuleUrlRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostRedirect":
            suggest = "host_redirect"
        elif key == "httpsRedirect":
            suggest = "https_redirect"
        elif key == "pathRedirect":
            suggest = "path_redirect"
        elif key == "prefixRedirect":
            suggest = "prefix_redirect"
        elif key == "redirectResponseCode":
            suggest = "redirect_response_code"
        elif key == "stripQuery":
            suggest = "strip_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapPathMatcherRouteRuleUrlRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapPathMatcherRouteRuleUrlRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapPathMatcherRouteRuleUrlRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_redirect: Optional[_builtins.str] = None,
                 https_redirect: Optional[_builtins.bool] = None,
                 path_redirect: Optional[_builtins.str] = None,
                 prefix_redirect: Optional[_builtins.str] = None,
                 redirect_response_code: Optional[_builtins.str] = None,
                 strip_query: Optional[_builtins.bool] = None):
        """
        :param _builtins.str host_redirect: The host that will be used in the redirect response instead of the one that was
               supplied in the request. The value must be between 1 and 255 characters.
        :param _builtins.bool https_redirect: If set to true, the URL scheme in the redirected request is set to https. If set
               to false, the URL scheme of the redirected request will remain the same as that
               of the request. This must only be set for UrlMaps used in TargetHttpProxys.
               Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        :param _builtins.str path_redirect: The path that will be used in the redirect response instead of the one that was
               supplied in the request. Only one of pathRedirect or prefixRedirect must be
               specified. The value must be between 1 and 1024 characters.
        :param _builtins.str prefix_redirect: The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
               retaining the remaining portion of the URL before redirecting the request.
        :param _builtins.str redirect_response_code: The HTTP Status code to use for this RedirectAction. Supported values are:
               * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
               * FOUND, which corresponds to 302.
               * SEE_OTHER which corresponds to 303.
               * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method will be retained.
               * PERMANENT_REDIRECT, which corresponds to 308. In this case, the request method will be retained.
        :param _builtins.bool strip_query: If set to true, any accompanying query portion of the original URL is removed
               prior to redirecting the request. If set to false, the query portion of the
               original URL is retained. Defaults to false.
        """
        if host_redirect is not None:
            pulumi.set(__self__, "host_redirect", host_redirect)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if path_redirect is not None:
            pulumi.set(__self__, "path_redirect", path_redirect)
        if prefix_redirect is not None:
            pulumi.set(__self__, "prefix_redirect", prefix_redirect)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)
        if strip_query is not None:
            pulumi.set(__self__, "strip_query", strip_query)

    @_builtins.property
    @pulumi.getter(name="hostRedirect")
    def host_redirect(self) -> Optional[_builtins.str]:
        """
        The host that will be used in the redirect response instead of the one that was
        supplied in the request. The value must be between 1 and 255 characters.
        """
        return pulumi.get(self, "host_redirect")

    @_builtins.property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[_builtins.bool]:
        """
        If set to true, the URL scheme in the redirected request is set to https. If set
        to false, the URL scheme of the redirected request will remain the same as that
        of the request. This must only be set for UrlMaps used in TargetHttpProxys.
        Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
        """
        return pulumi.get(self, "https_redirect")

    @_builtins.property
    @pulumi.getter(name="pathRedirect")
    def path_redirect(self) -> Optional[_builtins.str]:
        """
        The path that will be used in the redirect response instead of the one that was
        supplied in the request. Only one of pathRedirect or prefixRedirect must be
        specified. The value must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "path_redirect")

    @_builtins.property
    @pulumi.getter(name="prefixRedirect")
    def prefix_redirect(self) -> Optional[_builtins.str]:
        """
        The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
        retaining the remaining portion of the URL before redirecting the request.
        """
        return pulumi.get(self, "prefix_redirect")

    @_builtins.property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[_builtins.str]:
        """
        The HTTP Status code to use for this RedirectAction. Supported values are:
        * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
        * FOUND, which corresponds to 302.
        * SEE_OTHER which corresponds to 303.
        * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method will be retained.
        * PERMANENT_REDIRECT, which corresponds to 308. In this case, the request method will be retained.
        """
        return pulumi.get(self, "redirect_response_code")

    @_builtins.property
    @pulumi.getter(name="stripQuery")
    def strip_query(self) -> Optional[_builtins.bool]:
        """
        If set to true, any accompanying query portion of the original URL is removed
        prior to redirecting the request. If set to false, the query portion of the
        original URL is retained. Defaults to false.
        """
        return pulumi.get(self, "strip_query")


@pulumi.output_type
class URLMapTest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedOutputUrl":
            suggest = "expected_output_url"
        elif key == "expectedRedirectResponseCode":
            suggest = "expected_redirect_response_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in URLMapTest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        URLMapTest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        URLMapTest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: _builtins.str,
                 path: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 expected_output_url: Optional[_builtins.str] = None,
                 expected_redirect_response_code: Optional[_builtins.int] = None,
                 headers: Optional[Sequence['outputs.URLMapTestHeader']] = None,
                 service: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Host portion of the URL.
        :param _builtins.str path: Path portion of the URL.
        :param _builtins.str description: Description of this test case.
        :param _builtins.str expected_output_url: The expected output URL evaluated by the load balancer containing the scheme, host, path and query parameters.
               For rules that forward requests to backends, the test passes only when expectedOutputUrl matches the request forwarded by the load balancer to backends. For rules with urlRewrite, the test verifies that the forwarded request matches hostRewrite and pathPrefixRewrite in the urlRewrite action. When service is specified, expectedOutputUrl`s scheme is ignored.
               For rules with urlRedirect, the test passes only if expectedOutputUrl matches the URL in the load balancer's redirect response. If urlRedirect specifies httpsRedirect, the test passes only if the scheme in expectedOutputUrl is also set to HTTPS. If urlRedirect specifies stripQuery, the test passes only if expectedOutputUrl does not contain any query parameters.
               expectedOutputUrl is optional when service is specified.
        :param _builtins.int expected_redirect_response_code: For rules with urlRedirect, the test passes only if expectedRedirectResponseCode matches the HTTP status code in load balancer's redirect response.
               expectedRedirectResponseCode cannot be set when service is set.
        :param Sequence['URLMapTestHeaderArgs'] headers: HTTP headers for this request.
               Structure is documented below.
        :param _builtins.str service: The backend service or backend bucket link that should be matched by this test.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "path", path)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expected_output_url is not None:
            pulumi.set(__self__, "expected_output_url", expected_output_url)
        if expected_redirect_response_code is not None:
            pulumi.set(__self__, "expected_redirect_response_code", expected_redirect_response_code)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        Host portion of the URL.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path portion of the URL.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of this test case.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="expectedOutputUrl")
    def expected_output_url(self) -> Optional[_builtins.str]:
        """
        The expected output URL evaluated by the load balancer containing the scheme, host, path and query parameters.
        For rules that forward requests to backends, the test passes only when expectedOutputUrl matches the request forwarded by the load balancer to backends. For rules with urlRewrite, the test verifies that the forwarded request matches hostRewrite and pathPrefixRewrite in the urlRewrite action. When service is specified, expectedOutputUrl`s scheme is ignored.
        For rules with urlRedirect, the test passes only if expectedOutputUrl matches the URL in the load balancer's redirect response. If urlRedirect specifies httpsRedirect, the test passes only if the scheme in expectedOutputUrl is also set to HTTPS. If urlRedirect specifies stripQuery, the test passes only if expectedOutputUrl does not contain any query parameters.
        expectedOutputUrl is optional when service is specified.
        """
        return pulumi.get(self, "expected_output_url")

    @_builtins.property
    @pulumi.getter(name="expectedRedirectResponseCode")
    def expected_redirect_response_code(self) -> Optional[_builtins.int]:
        """
        For rules with urlRedirect, the test passes only if expectedRedirectResponseCode matches the HTTP status code in load balancer's redirect response.
        expectedRedirectResponseCode cannot be set when service is set.
        """
        return pulumi.get(self, "expected_redirect_response_code")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.URLMapTestHeader']]:
        """
        HTTP headers for this request.
        Structure is documented below.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        The backend service or backend bucket link that should be matched by this test.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class URLMapTestHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Header name.
        :param _builtins.str value: Header value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Header name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Header value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VPNTunnelCipherSuite(dict):
    def __init__(__self__, *,
                 phase1: Optional['outputs.VPNTunnelCipherSuitePhase1'] = None,
                 phase2: Optional['outputs.VPNTunnelCipherSuitePhase2'] = None):
        """
        :param 'VPNTunnelCipherSuitePhase1Args' phase1: Cipher configuration for phase 1 of the IKE protocol.
               Structure is documented below.
        :param 'VPNTunnelCipherSuitePhase2Args' phase2: Cipher configuration for phase 2 of the IKE protocol.
               Structure is documented below.
               
               
               <a name="nested_cipher_suite_phase1"></a>The `phase1` block supports:
        """
        if phase1 is not None:
            pulumi.set(__self__, "phase1", phase1)
        if phase2 is not None:
            pulumi.set(__self__, "phase2", phase2)

    @_builtins.property
    @pulumi.getter
    def phase1(self) -> Optional['outputs.VPNTunnelCipherSuitePhase1']:
        """
        Cipher configuration for phase 1 of the IKE protocol.
        Structure is documented below.
        """
        return pulumi.get(self, "phase1")

    @_builtins.property
    @pulumi.getter
    def phase2(self) -> Optional['outputs.VPNTunnelCipherSuitePhase2']:
        """
        Cipher configuration for phase 2 of the IKE protocol.
        Structure is documented below.


        <a name="nested_cipher_suite_phase1"></a>The `phase1` block supports:
        """
        return pulumi.get(self, "phase2")


@pulumi.output_type
class VPNTunnelCipherSuitePhase1(dict):
    def __init__(__self__, *,
                 dhs: Optional[Sequence[_builtins.str]] = None,
                 encryptions: Optional[Sequence[_builtins.str]] = None,
                 integrities: Optional[Sequence[_builtins.str]] = None,
                 prves: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] dhs: Diffie-Hellman groups.
        :param Sequence[_builtins.str] encryptions: Encryption algorithms.
        :param Sequence[_builtins.str] integrities: Integrity algorithms.
        :param Sequence[_builtins.str] prves: Pseudo-random functions.
        """
        if dhs is not None:
            pulumi.set(__self__, "dhs", dhs)
        if encryptions is not None:
            pulumi.set(__self__, "encryptions", encryptions)
        if integrities is not None:
            pulumi.set(__self__, "integrities", integrities)
        if prves is not None:
            pulumi.set(__self__, "prves", prves)

    @_builtins.property
    @pulumi.getter
    def dhs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Diffie-Hellman groups.
        """
        return pulumi.get(self, "dhs")

    @_builtins.property
    @pulumi.getter
    def encryptions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Encryption algorithms.
        """
        return pulumi.get(self, "encryptions")

    @_builtins.property
    @pulumi.getter
    def integrities(self) -> Optional[Sequence[_builtins.str]]:
        """
        Integrity algorithms.
        """
        return pulumi.get(self, "integrities")

    @_builtins.property
    @pulumi.getter
    def prves(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pseudo-random functions.
        """
        return pulumi.get(self, "prves")


@pulumi.output_type
class VPNTunnelCipherSuitePhase2(dict):
    def __init__(__self__, *,
                 encryptions: Optional[Sequence[_builtins.str]] = None,
                 integrities: Optional[Sequence[_builtins.str]] = None,
                 pfs: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] encryptions: Encryption algorithms.
        :param Sequence[_builtins.str] integrities: Integrity algorithms.
        :param Sequence[_builtins.str] pfs: Perfect forward secrecy groups.
        """
        if encryptions is not None:
            pulumi.set(__self__, "encryptions", encryptions)
        if integrities is not None:
            pulumi.set(__self__, "integrities", integrities)
        if pfs is not None:
            pulumi.set(__self__, "pfs", pfs)

    @_builtins.property
    @pulumi.getter
    def encryptions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Encryption algorithms.
        """
        return pulumi.get(self, "encryptions")

    @_builtins.property
    @pulumi.getter
    def integrities(self) -> Optional[Sequence[_builtins.str]]:
        """
        Integrity algorithms.
        """
        return pulumi.get(self, "integrities")

    @_builtins.property
    @pulumi.getter
    def pfs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Perfect forward secrecy groups.
        """
        return pulumi.get(self, "pfs")


@pulumi.output_type
class WireGroupEndpoint(dict):
    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 interconnects: Optional[Sequence['outputs.WireGroupEndpointInterconnect']] = None):
        """
        :param _builtins.str endpoint: The identifier for this object. Format specified above.
        :param Sequence['WireGroupEndpointInterconnectArgs'] interconnects: Structure is documented below.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if interconnects is not None:
            pulumi.set(__self__, "interconnects", interconnects)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def interconnects(self) -> Optional[Sequence['outputs.WireGroupEndpointInterconnect']]:
        """
        Structure is documented below.
        """
        return pulumi.get(self, "interconnects")


@pulumi.output_type
class WireGroupEndpointInterconnect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interconnectName":
            suggest = "interconnect_name"
        elif key == "vlanTags":
            suggest = "vlan_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WireGroupEndpointInterconnect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WireGroupEndpointInterconnect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WireGroupEndpointInterconnect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interconnect_name: _builtins.str,
                 interconnect: Optional[_builtins.str] = None,
                 vlan_tags: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.str interconnect_name: The identifier for this object. Format specified above.
        :param _builtins.str interconnect: (Optional)
        :param Sequence[_builtins.int] vlan_tags: VLAN tags for the interconnect.
        """
        pulumi.set(__self__, "interconnect_name", interconnect_name)
        if interconnect is not None:
            pulumi.set(__self__, "interconnect", interconnect)
        if vlan_tags is not None:
            pulumi.set(__self__, "vlan_tags", vlan_tags)

    @_builtins.property
    @pulumi.getter(name="interconnectName")
    def interconnect_name(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "interconnect_name")

    @_builtins.property
    @pulumi.getter
    def interconnect(self) -> Optional[_builtins.str]:
        """
        (Optional)
        """
        return pulumi.get(self, "interconnect")

    @_builtins.property
    @pulumi.getter(name="vlanTags")
    def vlan_tags(self) -> Optional[Sequence[_builtins.int]]:
        """
        VLAN tags for the interconnect.
        """
        return pulumi.get(self, "vlan_tags")


@pulumi.output_type
class WireGroupTopology(dict):
    def __init__(__self__, *,
                 endpoints: Optional[Sequence['outputs.WireGroupTopologyEndpoint']] = None):
        """
        :param Sequence['WireGroupTopologyEndpointArgs'] endpoints: Endpoints grouped by location, each mapping to interconnect configurations.
               Structure is documented below.
        """
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.WireGroupTopologyEndpoint']]:
        """
        Endpoints grouped by location, each mapping to interconnect configurations.
        Structure is documented below.
        """
        return pulumi.get(self, "endpoints")


@pulumi.output_type
class WireGroupTopologyEndpoint(dict):
    def __init__(__self__, *,
                 city: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None):
        """
        :param _builtins.str city: (Output)
        :param _builtins.str label: (Output)
        """
        if city is not None:
            pulumi.set(__self__, "city", city)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        (Output)
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        (Output)
        """
        return pulumi.get(self, "label")


@pulumi.output_type
class WireGroupWire(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminEnabled":
            suggest = "admin_enabled"
        elif key == "wireProperties":
            suggest = "wire_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WireGroupWire. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WireGroupWire.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WireGroupWire.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_enabled: Optional[_builtins.bool] = None,
                 endpoints: Optional[Sequence['outputs.WireGroupWireEndpoint']] = None,
                 label: Optional[_builtins.str] = None,
                 wire_properties: Optional[Sequence['outputs.WireGroupWireWireProperty']] = None):
        """
        :param _builtins.bool admin_enabled: Indicates whether the wire group is administratively enabled.
        :param Sequence['WireGroupWireEndpointArgs'] endpoints: Endpoints grouped by location, each mapping to interconnect configurations.
               Structure is documented below.
        :param _builtins.str label: (Output)
        :param Sequence['WireGroupWireWirePropertyArgs'] wire_properties: Default properties for wires within the group.
               Structure is documented below.
        """
        if admin_enabled is not None:
            pulumi.set(__self__, "admin_enabled", admin_enabled)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if wire_properties is not None:
            pulumi.set(__self__, "wire_properties", wire_properties)

    @_builtins.property
    @pulumi.getter(name="adminEnabled")
    def admin_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the wire group is administratively enabled.
        """
        return pulumi.get(self, "admin_enabled")

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.WireGroupWireEndpoint']]:
        """
        Endpoints grouped by location, each mapping to interconnect configurations.
        Structure is documented below.
        """
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        (Output)
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="wireProperties")
    def wire_properties(self) -> Optional[Sequence['outputs.WireGroupWireWireProperty']]:
        """
        Default properties for wires within the group.
        Structure is documented below.
        """
        return pulumi.get(self, "wire_properties")


@pulumi.output_type
class WireGroupWireEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanTag":
            suggest = "vlan_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WireGroupWireEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WireGroupWireEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WireGroupWireEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interconnect: Optional[_builtins.str] = None,
                 vlan_tag: Optional[_builtins.int] = None):
        """
        :param _builtins.str interconnect: (Output)
        :param _builtins.int vlan_tag: (Output)
        """
        if interconnect is not None:
            pulumi.set(__self__, "interconnect", interconnect)
        if vlan_tag is not None:
            pulumi.set(__self__, "vlan_tag", vlan_tag)

    @_builtins.property
    @pulumi.getter
    def interconnect(self) -> Optional[_builtins.str]:
        """
        (Output)
        """
        return pulumi.get(self, "interconnect")

    @_builtins.property
    @pulumi.getter(name="vlanTag")
    def vlan_tag(self) -> Optional[_builtins.int]:
        """
        (Output)
        """
        return pulumi.get(self, "vlan_tag")


@pulumi.output_type
class WireGroupWireGroupProperties(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Type of wire group (enum).
               WIRE: a single pseudowire over two Interconnect connections   with no redundancy.
               REDUNDANT: two pseudowires over four Interconnect connections, with two connections in one metro and two connections in another metro.
               BOX_AND_CROSS: four pseudowires over four Interconnect connections, with two connections in one metro and two connections in another metro.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of wire group (enum).
        WIRE: a single pseudowire over two Interconnect connections   with no redundancy.
        REDUNDANT: two pseudowires over four Interconnect connections, with two connections in one metro and two connections in another metro.
        BOX_AND_CROSS: four pseudowires over four Interconnect connections, with two connections in one metro and two connections in another metro.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WireGroupWireProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandwidthAllocation":
            suggest = "bandwidth_allocation"
        elif key == "bandwidthUnmetered":
            suggest = "bandwidth_unmetered"
        elif key == "faultResponse":
            suggest = "fault_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WireGroupWireProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WireGroupWireProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WireGroupWireProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth_allocation: _builtins.str,
                 bandwidth_unmetered: Optional[_builtins.int] = None,
                 fault_response: Optional[_builtins.str] = None):
        """
        :param _builtins.str bandwidth_allocation: The configuration of a wire's bandwidth allocation.
               ALLOCATE_PER_WIRE: configures a separate unmetered bandwidth allocation (and associated charges) for each wire in the group.
               SHARED_WITH_WIRE_GROUP: this is the default behavior, which configures one unmetered bandwidth allocation for the wire group. The unmetered bandwidth is divided equally across each wire in the group, but dynamic
               throttling reallocates unused unmetered bandwidth from unused or underused wires to other wires in the group.
        :param _builtins.int bandwidth_unmetered: The unmetered bandwidth setting.
        :param _builtins.str fault_response: Response when a fault is detected in a pseudowire:
               NONE: default.
               DISABLE_PORT: set the port line protocol down when inline probes detect a fault. This setting is only permitted on port mode pseudowires.
        """
        pulumi.set(__self__, "bandwidth_allocation", bandwidth_allocation)
        if bandwidth_unmetered is not None:
            pulumi.set(__self__, "bandwidth_unmetered", bandwidth_unmetered)
        if fault_response is not None:
            pulumi.set(__self__, "fault_response", fault_response)

    @_builtins.property
    @pulumi.getter(name="bandwidthAllocation")
    def bandwidth_allocation(self) -> _builtins.str:
        """
        The configuration of a wire's bandwidth allocation.
        ALLOCATE_PER_WIRE: configures a separate unmetered bandwidth allocation (and associated charges) for each wire in the group.
        SHARED_WITH_WIRE_GROUP: this is the default behavior, which configures one unmetered bandwidth allocation for the wire group. The unmetered bandwidth is divided equally across each wire in the group, but dynamic
        throttling reallocates unused unmetered bandwidth from unused or underused wires to other wires in the group.
        """
        return pulumi.get(self, "bandwidth_allocation")

    @_builtins.property
    @pulumi.getter(name="bandwidthUnmetered")
    def bandwidth_unmetered(self) -> Optional[_builtins.int]:
        """
        The unmetered bandwidth setting.
        """
        return pulumi.get(self, "bandwidth_unmetered")

    @_builtins.property
    @pulumi.getter(name="faultResponse")
    def fault_response(self) -> Optional[_builtins.str]:
        """
        Response when a fault is detected in a pseudowire:
        NONE: default.
        DISABLE_PORT: set the port line protocol down when inline probes detect a fault. This setting is only permitted on port mode pseudowires.
        """
        return pulumi.get(self, "fault_response")


@pulumi.output_type
class WireGroupWireWireProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandwidthUnmetered":
            suggest = "bandwidth_unmetered"
        elif key == "faultResponse":
            suggest = "fault_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WireGroupWireWireProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WireGroupWireWireProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WireGroupWireWireProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth_unmetered: Optional[_builtins.int] = None,
                 fault_response: Optional[_builtins.str] = None):
        """
        :param _builtins.int bandwidth_unmetered: The unmetered bandwidth setting.
        :param _builtins.str fault_response: Response when a fault is detected in a pseudowire:
               NONE: default.
               DISABLE_PORT: set the port line protocol down when inline probes detect a fault. This setting is only permitted on port mode pseudowires.
        """
        if bandwidth_unmetered is not None:
            pulumi.set(__self__, "bandwidth_unmetered", bandwidth_unmetered)
        if fault_response is not None:
            pulumi.set(__self__, "fault_response", fault_response)

    @_builtins.property
    @pulumi.getter(name="bandwidthUnmetered")
    def bandwidth_unmetered(self) -> Optional[_builtins.int]:
        """
        The unmetered bandwidth setting.
        """
        return pulumi.get(self, "bandwidth_unmetered")

    @_builtins.property
    @pulumi.getter(name="faultResponse")
    def fault_response(self) -> Optional[_builtins.str]:
        """
        Response when a fault is detected in a pseudowire:
        NONE: default.
        DISABLE_PORT: set the port line protocol down when inline probes detect a fault. This setting is only permitted on port mode pseudowires.
        """
        return pulumi.get(self, "fault_response")


@pulumi.output_type
class GetAddressesAddressResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 address_type: _builtins.str,
                 description: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 name: _builtins.str,
                 region: _builtins.str,
                 self_link: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str address: The IP address (for example `1.2.3.4`).
        :param _builtins.str address_type: The IP address type, can be `EXTERNAL` or `INTERNAL`.
        :param _builtins.str description: The IP address description.
        :param Mapping[str, _builtins.str] labels: A map containing IP labels.
        :param _builtins.str name: The IP address name.
        :param _builtins.str region: Region that should be considered to search addresses.
               All regions are considered if missing.
        :param _builtins.str self_link: The URI of the created resource.
        :param _builtins.str status: Indicates if the address is used. Possible values are: RESERVED or IN_USE.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "address_type", address_type)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "self_link", self_link)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        The IP address (for example `1.2.3.4`).
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="addressType")
    def address_type(self) -> _builtins.str:
        """
        The IP address type, can be `EXTERNAL` or `INTERNAL`.
        """
        return pulumi.get(self, "address_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The IP address description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        A map containing IP labels.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The IP address name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region that should be considered to search addresses.
        All regions are considered if missing.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> _builtins.str:
        """
        The URI of the created resource.
        """
        return pulumi.get(self, "self_link")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Indicates if the address is used. Possible values are: RESERVED or IN_USE.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetBackendBucketCdnPolicyResult(dict):
    def __init__(__self__, *,
                 bypass_cache_on_request_headers: Sequence['outputs.GetBackendBucketCdnPolicyBypassCacheOnRequestHeaderResult'],
                 cache_key_policies: Sequence['outputs.GetBackendBucketCdnPolicyCacheKeyPolicyResult'],
                 cache_mode: _builtins.str,
                 client_ttl: _builtins.int,
                 default_ttl: _builtins.int,
                 max_ttl: _builtins.int,
                 negative_caching: _builtins.bool,
                 negative_caching_policies: Sequence['outputs.GetBackendBucketCdnPolicyNegativeCachingPolicyResult'],
                 request_coalescing: _builtins.bool,
                 serve_while_stale: _builtins.int,
                 signed_url_cache_max_age_sec: _builtins.int):
        """
        :param Sequence['GetBackendBucketCdnPolicyBypassCacheOnRequestHeaderArgs'] bypass_cache_on_request_headers: Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified. The cache is bypassed for all cdnPolicy.cacheMode settings.
        :param Sequence['GetBackendBucketCdnPolicyCacheKeyPolicyArgs'] cache_key_policies: The CacheKeyPolicy for this CdnPolicy.
        :param _builtins.str cache_mode: Specifies the cache setting for all responses from this backend.
               The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC Possible values: ["USE_ORIGIN_HEADERS", "FORCE_CACHE_ALL", "CACHE_ALL_STATIC"]
        :param _builtins.int client_ttl: Specifies the maximum allowed TTL for cached content served by this origin. When the
               'cache_mode' is set to "USE_ORIGIN_HEADERS", you must omit this field.
        :param _builtins.int default_ttl: Specifies the default TTL for cached content served by this origin for responses
               that do not have an existing valid TTL (max-age or s-max-age). When the 'cache_mode'
               is set to "USE_ORIGIN_HEADERS", you must omit this field.
        :param _builtins.int max_ttl: Specifies the maximum allowed TTL for cached content served by this origin. When the
               'cache_mode' is set to "USE_ORIGIN_HEADERS", you must omit this field.
        :param _builtins.bool negative_caching: Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        :param Sequence['GetBackendBucketCdnPolicyNegativeCachingPolicyArgs'] negative_caching_policies: Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
               Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
        :param _builtins.bool request_coalescing: If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests to the origin.
        :param _builtins.int serve_while_stale: Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        :param _builtins.int signed_url_cache_max_age_sec: Maximum number of seconds the response to a signed URL request will
               be considered fresh. After this time period,
               the response will be revalidated before being served.
               When serving responses to signed URL requests,
               Cloud CDN will internally behave as though
               all responses from this backend had a "Cache-Control: public,
               max-age=[TTL]" header, regardless of any existing Cache-Control
               header. The actual headers served in responses will not be altered.
        """
        pulumi.set(__self__, "bypass_cache_on_request_headers", bypass_cache_on_request_headers)
        pulumi.set(__self__, "cache_key_policies", cache_key_policies)
        pulumi.set(__self__, "cache_mode", cache_mode)
        pulumi.set(__self__, "client_ttl", client_ttl)
        pulumi.set(__self__, "default_ttl", default_ttl)
        pulumi.set(__self__, "max_ttl", max_ttl)
        pulumi.set(__self__, "negative_caching", negative_caching)
        pulumi.set(__self__, "negative_caching_policies", negative_caching_policies)
        pulumi.set(__self__, "request_coalescing", request_coalescing)
        pulumi.set(__self__, "serve_while_stale", serve_while_stale)
        pulumi.set(__self__, "signed_url_cache_max_age_sec", signed_url_cache_max_age_sec)

    @_builtins.property
    @pulumi.getter(name="bypassCacheOnRequestHeaders")
    def bypass_cache_on_request_headers(self) -> Sequence['outputs.GetBackendBucketCdnPolicyBypassCacheOnRequestHeaderResult']:
        """
        Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified. The cache is bypassed for all cdnPolicy.cacheMode settings.
        """
        return pulumi.get(self, "bypass_cache_on_request_headers")

    @_builtins.property
    @pulumi.getter(name="cacheKeyPolicies")
    def cache_key_policies(self) -> Sequence['outputs.GetBackendBucketCdnPolicyCacheKeyPolicyResult']:
        """
        The CacheKeyPolicy for this CdnPolicy.
        """
        return pulumi.get(self, "cache_key_policies")

    @_builtins.property
    @pulumi.getter(name="cacheMode")
    def cache_mode(self) -> _builtins.str:
        """
        Specifies the cache setting for all responses from this backend.
        The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC Possible values: ["USE_ORIGIN_HEADERS", "FORCE_CACHE_ALL", "CACHE_ALL_STATIC"]
        """
        return pulumi.get(self, "cache_mode")

    @_builtins.property
    @pulumi.getter(name="clientTtl")
    def client_ttl(self) -> _builtins.int:
        """
        Specifies the maximum allowed TTL for cached content served by this origin. When the
        'cache_mode' is set to "USE_ORIGIN_HEADERS", you must omit this field.
        """
        return pulumi.get(self, "client_ttl")

    @_builtins.property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> _builtins.int:
        """
        Specifies the default TTL for cached content served by this origin for responses
        that do not have an existing valid TTL (max-age or s-max-age). When the 'cache_mode'
        is set to "USE_ORIGIN_HEADERS", you must omit this field.
        """
        return pulumi.get(self, "default_ttl")

    @_builtins.property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> _builtins.int:
        """
        Specifies the maximum allowed TTL for cached content served by this origin. When the
        'cache_mode' is set to "USE_ORIGIN_HEADERS", you must omit this field.
        """
        return pulumi.get(self, "max_ttl")

    @_builtins.property
    @pulumi.getter(name="negativeCaching")
    def negative_caching(self) -> _builtins.bool:
        """
        Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        """
        return pulumi.get(self, "negative_caching")

    @_builtins.property
    @pulumi.getter(name="negativeCachingPolicies")
    def negative_caching_policies(self) -> Sequence['outputs.GetBackendBucketCdnPolicyNegativeCachingPolicyResult']:
        """
        Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
        Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
        """
        return pulumi.get(self, "negative_caching_policies")

    @_builtins.property
    @pulumi.getter(name="requestCoalescing")
    def request_coalescing(self) -> _builtins.bool:
        """
        If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests to the origin.
        """
        return pulumi.get(self, "request_coalescing")

    @_builtins.property
    @pulumi.getter(name="serveWhileStale")
    def serve_while_stale(self) -> _builtins.int:
        """
        Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        """
        return pulumi.get(self, "serve_while_stale")

    @_builtins.property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> _builtins.int:
        """
        Maximum number of seconds the response to a signed URL request will
        be considered fresh. After this time period,
        the response will be revalidated before being served.
        When serving responses to signed URL requests,
        Cloud CDN will internally behave as though
        all responses from this backend had a "Cache-Control: public,
        max-age=[TTL]" header, regardless of any existing Cache-Control
        header. The actual headers served in responses will not be altered.
        """
        return pulumi.get(self, "signed_url_cache_max_age_sec")


@pulumi.output_type
class GetBackendBucketCdnPolicyBypassCacheOnRequestHeaderResult(dict):
    def __init__(__self__, *,
                 header_name: _builtins.str):
        """
        :param _builtins.str header_name: The header field name to match on when bypassing cache. Values are case-insensitive.
        """
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The header field name to match on when bypassing cache. Values are case-insensitive.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class GetBackendBucketCdnPolicyCacheKeyPolicyResult(dict):
    def __init__(__self__, *,
                 include_http_headers: Sequence[_builtins.str],
                 query_string_whitelists: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] include_http_headers: Allows HTTP request headers (by name) to be used in the
               cache key.
        :param Sequence[_builtins.str] query_string_whitelists: Names of query string parameters to include in cache keys.
               Default parameters are always included. '&' and '=' will
               be percent encoded and not treated as delimiters.
        """
        pulumi.set(__self__, "include_http_headers", include_http_headers)
        pulumi.set(__self__, "query_string_whitelists", query_string_whitelists)

    @_builtins.property
    @pulumi.getter(name="includeHttpHeaders")
    def include_http_headers(self) -> Sequence[_builtins.str]:
        """
        Allows HTTP request headers (by name) to be used in the
        cache key.
        """
        return pulumi.get(self, "include_http_headers")

    @_builtins.property
    @pulumi.getter(name="queryStringWhitelists")
    def query_string_whitelists(self) -> Sequence[_builtins.str]:
        """
        Names of query string parameters to include in cache keys.
        Default parameters are always included. '&' and '=' will
        be percent encoded and not treated as delimiters.
        """
        return pulumi.get(self, "query_string_whitelists")


@pulumi.output_type
class GetBackendBucketCdnPolicyNegativeCachingPolicyResult(dict):
    def __init__(__self__, *,
                 code: _builtins.int,
                 ttl: _builtins.int):
        """
        :param _builtins.int code: The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
               can be specified as values, and you cannot specify a status code more than once.
        :param _builtins.int ttl: The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
               (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.int:
        """
        The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
        can be specified as values, and you cannot specify a status code more than once.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
        (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetBackendBucketParamResult(dict):
    def __init__(__self__, *,
                 resource_manager_tags: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the backend bucket. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456.
        """
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        Resource manager tags to be bound to the backend bucket. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class GetBackendServiceBackendResult(dict):
    def __init__(__self__, *,
                 balancing_mode: _builtins.str,
                 capacity_scaler: _builtins.float,
                 custom_metrics: Sequence['outputs.GetBackendServiceBackendCustomMetricResult'],
                 description: _builtins.str,
                 group: _builtins.str,
                 max_connections: _builtins.int,
                 max_connections_per_endpoint: _builtins.int,
                 max_connections_per_instance: _builtins.int,
                 max_in_flight_requests: _builtins.int,
                 max_in_flight_requests_per_endpoint: _builtins.int,
                 max_in_flight_requests_per_instance: _builtins.int,
                 max_rate: _builtins.int,
                 max_rate_per_endpoint: _builtins.float,
                 max_rate_per_instance: _builtins.float,
                 max_utilization: _builtins.float,
                 preference: _builtins.str,
                 traffic_duration: _builtins.str):
        """
        :param _builtins.str balancing_mode: Specifies the balancing mode for this backend.
               
               For global HTTP(S) or TCP/SSL load balancing, the default is
               UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S)),
               CUSTOM_METRICS (for HTTP(s)) and CONNECTION (for TCP/SSL).
               
               See the [Backend Services Overview](https://cloud.google.com/load-balancing/docs/backend-service#balancing-mode)
               for an explanation of load balancing modes. Default value: "UTILIZATION" Possible values: ["UTILIZATION", "RATE", "CONNECTION", "CUSTOM_METRICS", "IN_FLIGHT"]
        :param _builtins.float capacity_scaler: A multiplier applied to the group's maximum servicing capacity
               (based on UTILIZATION, RATE or CONNECTION).
               
               Default value is 1, which means the group will serve up to 100%
               of its configured capacity (depending on balancingMode). A
               setting of 0 means the group is completely drained, offering
               0% of its available Capacity. Valid range is [0.0,1.0].
        :param Sequence['GetBackendServiceBackendCustomMetricArgs'] custom_metrics: The set of custom metrics that are used for <code>CUSTOM_METRICS</code> BalancingMode.
        :param _builtins.str description: Textual description for the Backend Service.
        :param _builtins.str group: The fully-qualified URL of an Instance Group or Network Endpoint
               Group resource. In case of instance group this defines the list
               of instances that serve traffic. Member virtual machine
               instances from each instance group must live in the same zone as
               the instance group itself. No two backends in a backend service
               are allowed to use same Instance Group resource.
               
               For Network Endpoint Groups this defines list of endpoints. All
               endpoints of Network Endpoint Group must be hosted on instances
               located in the same zone as the Network Endpoint Group.
               
               Backend services cannot mix Instance Group and
               Network Endpoint Group backends.
               
               Note that you must specify an Instance Group or Network Endpoint
               Group resource using the fully-qualified URL, rather than a
               partial URL.
        :param _builtins.int max_connections: The max number of simultaneous connections for the group. Can
               be used with either CONNECTION or UTILIZATION balancing modes.
               
               For CONNECTION mode, either maxConnections or one
               of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
               as appropriate for group type, must be set.
        :param _builtins.int max_connections_per_endpoint: The max number of simultaneous connections that a single backend
               network endpoint can handle. This is used to calculate the
               capacity of the group. Can be used in either CONNECTION or
               UTILIZATION balancing modes.
               
               For CONNECTION mode, either
               maxConnections or maxConnectionsPerEndpoint must be set.
        :param _builtins.int max_connections_per_instance: The max number of simultaneous connections that a single
               backend instance can handle. This is used to calculate the
               capacity of the group. Can be used in either CONNECTION or
               UTILIZATION balancing modes.
               
               For CONNECTION mode, either maxConnections or
               maxConnectionsPerInstance must be set.
        :param _builtins.int max_in_flight_requests: Defines a maximum number of in-flight requests for the whole NEG
               or instance group. Not available if backend's balancingMode is RATE
               or CONNECTION.
        :param _builtins.int max_in_flight_requests_per_endpoint: Defines a maximum number of in-flight requests for a single endpoint.
               Not available if backend's balancingMode is RATE or CONNECTION.
        :param _builtins.int max_in_flight_requests_per_instance: Defines a maximum number of in-flight requests for a single VM.
               Not available if backend's balancingMode is RATE or CONNECTION.
        :param _builtins.int max_rate: The max requests per second (RPS) of the group.
               
               Can be used with either RATE or UTILIZATION balancing modes,
               but required if RATE mode. For RATE mode, either maxRate or one
               of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
               group type, must be set.
        :param _builtins.float max_rate_per_endpoint: The max requests per second (RPS) that a single backend network
               endpoint can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerEndpoint must be set.
        :param _builtins.float max_rate_per_instance: The max requests per second (RPS) that a single backend
               instance can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerInstance must be set.
        :param _builtins.float max_utilization: Used when balancingMode is UTILIZATION. This ratio defines the
               CPU utilization target for the group. Valid range is [0.0, 1.0].
        :param _builtins.str preference: This field indicates whether this backend should be fully utilized before sending traffic to backends
               with default preference. This field cannot be set when loadBalancingScheme is set to 'EXTERNAL'. The possible values are:
                 - PREFERRED: Backends with this preference level will be filled up to their capacity limits first,
                   based on RTT.
                 - DEFAULT: If preferred backends don't have enough capacity, backends in this layer would be used and
                   traffic would be assigned based on the load balancing algorithm you use. This is the default Possible values: ["PREFERRED", "DEFAULT"]
        :param _builtins.str traffic_duration: This field specifies how long a connection should be kept alive for:
               - LONG: Most of the requests are expected to take more than multiple
                 seconds to finish.
               - SHORT: Most requests are expected to finish with a sub-second latency. Possible values: ["LONG", "SHORT"]
        """
        pulumi.set(__self__, "balancing_mode", balancing_mode)
        pulumi.set(__self__, "capacity_scaler", capacity_scaler)
        pulumi.set(__self__, "custom_metrics", custom_metrics)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "max_connections", max_connections)
        pulumi.set(__self__, "max_connections_per_endpoint", max_connections_per_endpoint)
        pulumi.set(__self__, "max_connections_per_instance", max_connections_per_instance)
        pulumi.set(__self__, "max_in_flight_requests", max_in_flight_requests)
        pulumi.set(__self__, "max_in_flight_requests_per_endpoint", max_in_flight_requests_per_endpoint)
        pulumi.set(__self__, "max_in_flight_requests_per_instance", max_in_flight_requests_per_instance)
        pulumi.set(__self__, "max_rate", max_rate)
        pulumi.set(__self__, "max_rate_per_endpoint", max_rate_per_endpoint)
        pulumi.set(__self__, "max_rate_per_instance", max_rate_per_instance)
        pulumi.set(__self__, "max_utilization", max_utilization)
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "traffic_duration", traffic_duration)

    @_builtins.property
    @pulumi.getter(name="balancingMode")
    def balancing_mode(self) -> _builtins.str:
        """
        Specifies the balancing mode for this backend.

        For global HTTP(S) or TCP/SSL load balancing, the default is
        UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S)),
        CUSTOM_METRICS (for HTTP(s)) and CONNECTION (for TCP/SSL).

        See the [Backend Services Overview](https://cloud.google.com/load-balancing/docs/backend-service#balancing-mode)
        for an explanation of load balancing modes. Default value: "UTILIZATION" Possible values: ["UTILIZATION", "RATE", "CONNECTION", "CUSTOM_METRICS", "IN_FLIGHT"]
        """
        return pulumi.get(self, "balancing_mode")

    @_builtins.property
    @pulumi.getter(name="capacityScaler")
    def capacity_scaler(self) -> _builtins.float:
        """
        A multiplier applied to the group's maximum servicing capacity
        (based on UTILIZATION, RATE or CONNECTION).

        Default value is 1, which means the group will serve up to 100%
        of its configured capacity (depending on balancingMode). A
        setting of 0 means the group is completely drained, offering
        0% of its available Capacity. Valid range is [0.0,1.0].
        """
        return pulumi.get(self, "capacity_scaler")

    @_builtins.property
    @pulumi.getter(name="customMetrics")
    def custom_metrics(self) -> Sequence['outputs.GetBackendServiceBackendCustomMetricResult']:
        """
        The set of custom metrics that are used for <code>CUSTOM_METRICS</code> BalancingMode.
        """
        return pulumi.get(self, "custom_metrics")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Textual description for the Backend Service.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def group(self) -> _builtins.str:
        """
        The fully-qualified URL of an Instance Group or Network Endpoint
        Group resource. In case of instance group this defines the list
        of instances that serve traffic. Member virtual machine
        instances from each instance group must live in the same zone as
        the instance group itself. No two backends in a backend service
        are allowed to use same Instance Group resource.

        For Network Endpoint Groups this defines list of endpoints. All
        endpoints of Network Endpoint Group must be hosted on instances
        located in the same zone as the Network Endpoint Group.

        Backend services cannot mix Instance Group and
        Network Endpoint Group backends.

        Note that you must specify an Instance Group or Network Endpoint
        Group resource using the fully-qualified URL, rather than a
        partial URL.
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> _builtins.int:
        """
        The max number of simultaneous connections for the group. Can
        be used with either CONNECTION or UTILIZATION balancing modes.

        For CONNECTION mode, either maxConnections or one
        of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
        as appropriate for group type, must be set.
        """
        return pulumi.get(self, "max_connections")

    @_builtins.property
    @pulumi.getter(name="maxConnectionsPerEndpoint")
    def max_connections_per_endpoint(self) -> _builtins.int:
        """
        The max number of simultaneous connections that a single backend
        network endpoint can handle. This is used to calculate the
        capacity of the group. Can be used in either CONNECTION or
        UTILIZATION balancing modes.

        For CONNECTION mode, either
        maxConnections or maxConnectionsPerEndpoint must be set.
        """
        return pulumi.get(self, "max_connections_per_endpoint")

    @_builtins.property
    @pulumi.getter(name="maxConnectionsPerInstance")
    def max_connections_per_instance(self) -> _builtins.int:
        """
        The max number of simultaneous connections that a single
        backend instance can handle. This is used to calculate the
        capacity of the group. Can be used in either CONNECTION or
        UTILIZATION balancing modes.

        For CONNECTION mode, either maxConnections or
        maxConnectionsPerInstance must be set.
        """
        return pulumi.get(self, "max_connections_per_instance")

    @_builtins.property
    @pulumi.getter(name="maxInFlightRequests")
    def max_in_flight_requests(self) -> _builtins.int:
        """
        Defines a maximum number of in-flight requests for the whole NEG
        or instance group. Not available if backend's balancingMode is RATE
        or CONNECTION.
        """
        return pulumi.get(self, "max_in_flight_requests")

    @_builtins.property
    @pulumi.getter(name="maxInFlightRequestsPerEndpoint")
    def max_in_flight_requests_per_endpoint(self) -> _builtins.int:
        """
        Defines a maximum number of in-flight requests for a single endpoint.
        Not available if backend's balancingMode is RATE or CONNECTION.
        """
        return pulumi.get(self, "max_in_flight_requests_per_endpoint")

    @_builtins.property
    @pulumi.getter(name="maxInFlightRequestsPerInstance")
    def max_in_flight_requests_per_instance(self) -> _builtins.int:
        """
        Defines a maximum number of in-flight requests for a single VM.
        Not available if backend's balancingMode is RATE or CONNECTION.
        """
        return pulumi.get(self, "max_in_flight_requests_per_instance")

    @_builtins.property
    @pulumi.getter(name="maxRate")
    def max_rate(self) -> _builtins.int:
        """
        The max requests per second (RPS) of the group.

        Can be used with either RATE or UTILIZATION balancing modes,
        but required if RATE mode. For RATE mode, either maxRate or one
        of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
        group type, must be set.
        """
        return pulumi.get(self, "max_rate")

    @_builtins.property
    @pulumi.getter(name="maxRatePerEndpoint")
    def max_rate_per_endpoint(self) -> _builtins.float:
        """
        The max requests per second (RPS) that a single backend network
        endpoint can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerEndpoint must be set.
        """
        return pulumi.get(self, "max_rate_per_endpoint")

    @_builtins.property
    @pulumi.getter(name="maxRatePerInstance")
    def max_rate_per_instance(self) -> _builtins.float:
        """
        The max requests per second (RPS) that a single backend
        instance can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerInstance must be set.
        """
        return pulumi.get(self, "max_rate_per_instance")

    @_builtins.property
    @pulumi.getter(name="maxUtilization")
    def max_utilization(self) -> _builtins.float:
        """
        Used when balancingMode is UTILIZATION. This ratio defines the
        CPU utilization target for the group. Valid range is [0.0, 1.0].
        """
        return pulumi.get(self, "max_utilization")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.str:
        """
        This field indicates whether this backend should be fully utilized before sending traffic to backends
        with default preference. This field cannot be set when loadBalancingScheme is set to 'EXTERNAL'. The possible values are:
          - PREFERRED: Backends with this preference level will be filled up to their capacity limits first,
            based on RTT.
          - DEFAULT: If preferred backends don't have enough capacity, backends in this layer would be used and
            traffic would be assigned based on the load balancing algorithm you use. This is the default Possible values: ["PREFERRED", "DEFAULT"]
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter(name="trafficDuration")
    def traffic_duration(self) -> _builtins.str:
        """
        This field specifies how long a connection should be kept alive for:
        - LONG: Most of the requests are expected to take more than multiple
          seconds to finish.
        - SHORT: Most requests are expected to finish with a sub-second latency. Possible values: ["LONG", "SHORT"]
        """
        return pulumi.get(self, "traffic_duration")


@pulumi.output_type
class GetBackendServiceBackendCustomMetricResult(dict):
    def __init__(__self__, *,
                 dry_run: _builtins.bool,
                 max_utilization: _builtins.float,
                 name: _builtins.str):
        """
        :param _builtins.bool dry_run: If true, the metric data is collected and reported to Cloud
               Monitoring, but is not used for load balancing.
        :param _builtins.float max_utilization: Optional parameter to define a target utilization for the Custom Metrics
               balancing mode. The valid range is <code>[0.0, 1.0]</code>.
        :param _builtins.str name: The name of the Backend Service.
               
               - - -
        """
        pulumi.set(__self__, "dry_run", dry_run)
        pulumi.set(__self__, "max_utilization", max_utilization)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> _builtins.bool:
        """
        If true, the metric data is collected and reported to Cloud
        Monitoring, but is not used for load balancing.
        """
        return pulumi.get(self, "dry_run")

    @_builtins.property
    @pulumi.getter(name="maxUtilization")
    def max_utilization(self) -> _builtins.float:
        """
        Optional parameter to define a target utilization for the Custom Metrics
        balancing mode. The valid range is <code>[0.0, 1.0]</code>.
        """
        return pulumi.get(self, "max_utilization")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Backend Service.

        - - -
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetBackendServiceCdnPolicyResult(dict):
    def __init__(__self__, *,
                 bypass_cache_on_request_headers: Sequence['outputs.GetBackendServiceCdnPolicyBypassCacheOnRequestHeaderResult'],
                 cache_key_policies: Sequence['outputs.GetBackendServiceCdnPolicyCacheKeyPolicyResult'],
                 cache_mode: _builtins.str,
                 client_ttl: _builtins.int,
                 default_ttl: _builtins.int,
                 max_ttl: _builtins.int,
                 negative_caching: _builtins.bool,
                 negative_caching_policies: Sequence['outputs.GetBackendServiceCdnPolicyNegativeCachingPolicyResult'],
                 request_coalescing: _builtins.bool,
                 serve_while_stale: _builtins.int,
                 signed_url_cache_max_age_sec: _builtins.int):
        """
        :param Sequence['GetBackendServiceCdnPolicyBypassCacheOnRequestHeaderArgs'] bypass_cache_on_request_headers: Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
               The cache is bypassed for all cdnPolicy.cacheMode settings.
        :param Sequence['GetBackendServiceCdnPolicyCacheKeyPolicyArgs'] cache_key_policies: The CacheKeyPolicy for this CdnPolicy.
        :param _builtins.str cache_mode: Specifies the cache setting for all responses from this backend.
               The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC Possible values: ["USE_ORIGIN_HEADERS", "FORCE_CACHE_ALL", "CACHE_ALL_STATIC"]
        :param _builtins.int client_ttl: Specifies the maximum allowed TTL for cached content served by this origin.
        :param _builtins.int default_ttl: Specifies the default TTL for cached content served by this origin for responses
               that do not have an existing valid TTL (max-age or s-max-age).
        :param _builtins.int max_ttl: Specifies the maximum allowed TTL for cached content served by this origin.
        :param _builtins.bool negative_caching: Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        :param Sequence['GetBackendServiceCdnPolicyNegativeCachingPolicyArgs'] negative_caching_policies: Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
               Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
        :param _builtins.bool request_coalescing: If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests
               to the origin.
        :param _builtins.int serve_while_stale: Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        :param _builtins.int signed_url_cache_max_age_sec: Maximum number of seconds the response to a signed URL request
               will be considered fresh, defaults to 1hr (3600s). After this
               time period, the response will be revalidated before
               being served.
               
               When serving responses to signed URL requests, Cloud CDN will
               internally behave as though all responses from this backend had a
               "Cache-Control: public, max-age=[TTL]" header, regardless of any
               existing Cache-Control header. The actual headers served in
               responses will not be altered.
        """
        pulumi.set(__self__, "bypass_cache_on_request_headers", bypass_cache_on_request_headers)
        pulumi.set(__self__, "cache_key_policies", cache_key_policies)
        pulumi.set(__self__, "cache_mode", cache_mode)
        pulumi.set(__self__, "client_ttl", client_ttl)
        pulumi.set(__self__, "default_ttl", default_ttl)
        pulumi.set(__self__, "max_ttl", max_ttl)
        pulumi.set(__self__, "negative_caching", negative_caching)
        pulumi.set(__self__, "negative_caching_policies", negative_caching_policies)
        pulumi.set(__self__, "request_coalescing", request_coalescing)
        pulumi.set(__self__, "serve_while_stale", serve_while_stale)
        pulumi.set(__self__, "signed_url_cache_max_age_sec", signed_url_cache_max_age_sec)

    @_builtins.property
    @pulumi.getter(name="bypassCacheOnRequestHeaders")
    def bypass_cache_on_request_headers(self) -> Sequence['outputs.GetBackendServiceCdnPolicyBypassCacheOnRequestHeaderResult']:
        """
        Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
        The cache is bypassed for all cdnPolicy.cacheMode settings.
        """
        return pulumi.get(self, "bypass_cache_on_request_headers")

    @_builtins.property
    @pulumi.getter(name="cacheKeyPolicies")
    def cache_key_policies(self) -> Sequence['outputs.GetBackendServiceCdnPolicyCacheKeyPolicyResult']:
        """
        The CacheKeyPolicy for this CdnPolicy.
        """
        return pulumi.get(self, "cache_key_policies")

    @_builtins.property
    @pulumi.getter(name="cacheMode")
    def cache_mode(self) -> _builtins.str:
        """
        Specifies the cache setting for all responses from this backend.
        The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC Possible values: ["USE_ORIGIN_HEADERS", "FORCE_CACHE_ALL", "CACHE_ALL_STATIC"]
        """
        return pulumi.get(self, "cache_mode")

    @_builtins.property
    @pulumi.getter(name="clientTtl")
    def client_ttl(self) -> _builtins.int:
        """
        Specifies the maximum allowed TTL for cached content served by this origin.
        """
        return pulumi.get(self, "client_ttl")

    @_builtins.property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> _builtins.int:
        """
        Specifies the default TTL for cached content served by this origin for responses
        that do not have an existing valid TTL (max-age or s-max-age).
        """
        return pulumi.get(self, "default_ttl")

    @_builtins.property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> _builtins.int:
        """
        Specifies the maximum allowed TTL for cached content served by this origin.
        """
        return pulumi.get(self, "max_ttl")

    @_builtins.property
    @pulumi.getter(name="negativeCaching")
    def negative_caching(self) -> _builtins.bool:
        """
        Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        """
        return pulumi.get(self, "negative_caching")

    @_builtins.property
    @pulumi.getter(name="negativeCachingPolicies")
    def negative_caching_policies(self) -> Sequence['outputs.GetBackendServiceCdnPolicyNegativeCachingPolicyResult']:
        """
        Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
        Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
        """
        return pulumi.get(self, "negative_caching_policies")

    @_builtins.property
    @pulumi.getter(name="requestCoalescing")
    def request_coalescing(self) -> _builtins.bool:
        """
        If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests
        to the origin.
        """
        return pulumi.get(self, "request_coalescing")

    @_builtins.property
    @pulumi.getter(name="serveWhileStale")
    def serve_while_stale(self) -> _builtins.int:
        """
        Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        """
        return pulumi.get(self, "serve_while_stale")

    @_builtins.property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> _builtins.int:
        """
        Maximum number of seconds the response to a signed URL request
        will be considered fresh, defaults to 1hr (3600s). After this
        time period, the response will be revalidated before
        being served.

        When serving responses to signed URL requests, Cloud CDN will
        internally behave as though all responses from this backend had a
        "Cache-Control: public, max-age=[TTL]" header, regardless of any
        existing Cache-Control header. The actual headers served in
        responses will not be altered.
        """
        return pulumi.get(self, "signed_url_cache_max_age_sec")


@pulumi.output_type
class GetBackendServiceCdnPolicyBypassCacheOnRequestHeaderResult(dict):
    def __init__(__self__, *,
                 header_name: _builtins.str):
        """
        :param _builtins.str header_name: The header field name to match on when bypassing cache. Values are case-insensitive.
        """
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The header field name to match on when bypassing cache. Values are case-insensitive.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class GetBackendServiceCdnPolicyCacheKeyPolicyResult(dict):
    def __init__(__self__, *,
                 include_host: _builtins.bool,
                 include_http_headers: Sequence[_builtins.str],
                 include_named_cookies: Sequence[_builtins.str],
                 include_protocol: _builtins.bool,
                 include_query_string: _builtins.bool,
                 query_string_blacklists: Sequence[_builtins.str],
                 query_string_whitelists: Sequence[_builtins.str]):
        """
        :param _builtins.bool include_host: If true requests to different hosts will be cached separately.
        :param Sequence[_builtins.str] include_http_headers: Allows HTTP request headers (by name) to be used in the
               cache key.
        :param Sequence[_builtins.str] include_named_cookies: Names of cookies to include in cache keys.
        :param _builtins.bool include_protocol: If true, http and https requests will be cached separately.
        :param _builtins.bool include_query_string: If true, include query string parameters in the cache key
               according to query_string_whitelist and
               query_string_blacklist. If neither is set, the entire query
               string will be included.
               
               If false, the query string will be excluded from the cache
               key entirely.
        :param Sequence[_builtins.str] query_string_blacklists: Names of query string parameters to exclude in cache keys.
               
               All other parameters will be included. Either specify
               query_string_whitelist or query_string_blacklist, not both.
               '&' and '=' will be percent encoded and not treated as
               delimiters.
        :param Sequence[_builtins.str] query_string_whitelists: Names of query string parameters to include in cache keys.
               
               All other parameters will be excluded. Either specify
               query_string_whitelist or query_string_blacklist, not both.
               '&' and '=' will be percent encoded and not treated as
               delimiters.
        """
        pulumi.set(__self__, "include_host", include_host)
        pulumi.set(__self__, "include_http_headers", include_http_headers)
        pulumi.set(__self__, "include_named_cookies", include_named_cookies)
        pulumi.set(__self__, "include_protocol", include_protocol)
        pulumi.set(__self__, "include_query_string", include_query_string)
        pulumi.set(__self__, "query_string_blacklists", query_string_blacklists)
        pulumi.set(__self__, "query_string_whitelists", query_string_whitelists)

    @_builtins.property
    @pulumi.getter(name="includeHost")
    def include_host(self) -> _builtins.bool:
        """
        If true requests to different hosts will be cached separately.
        """
        return pulumi.get(self, "include_host")

    @_builtins.property
    @pulumi.getter(name="includeHttpHeaders")
    def include_http_headers(self) -> Sequence[_builtins.str]:
        """
        Allows HTTP request headers (by name) to be used in the
        cache key.
        """
        return pulumi.get(self, "include_http_headers")

    @_builtins.property
    @pulumi.getter(name="includeNamedCookies")
    def include_named_cookies(self) -> Sequence[_builtins.str]:
        """
        Names of cookies to include in cache keys.
        """
        return pulumi.get(self, "include_named_cookies")

    @_builtins.property
    @pulumi.getter(name="includeProtocol")
    def include_protocol(self) -> _builtins.bool:
        """
        If true, http and https requests will be cached separately.
        """
        return pulumi.get(self, "include_protocol")

    @_builtins.property
    @pulumi.getter(name="includeQueryString")
    def include_query_string(self) -> _builtins.bool:
        """
        If true, include query string parameters in the cache key
        according to query_string_whitelist and
        query_string_blacklist. If neither is set, the entire query
        string will be included.

        If false, the query string will be excluded from the cache
        key entirely.
        """
        return pulumi.get(self, "include_query_string")

    @_builtins.property
    @pulumi.getter(name="queryStringBlacklists")
    def query_string_blacklists(self) -> Sequence[_builtins.str]:
        """
        Names of query string parameters to exclude in cache keys.

        All other parameters will be included. Either specify
        query_string_whitelist or query_string_blacklist, not both.
        '&' and '=' will be percent encoded and not treated as
        delimiters.
        """
        return pulumi.get(self, "query_string_blacklists")

    @_builtins.property
    @pulumi.getter(name="queryStringWhitelists")
    def query_string_whitelists(self) -> Sequence[_builtins.str]:
        """
        Names of query string parameters to include in cache keys.

        All other parameters will be excluded. Either specify
        query_string_whitelist or query_string_blacklist, not both.
        '&' and '=' will be percent encoded and not treated as
        delimiters.
        """
        return pulumi.get(self, "query_string_whitelists")


@pulumi.output_type
class GetBackendServiceCdnPolicyNegativeCachingPolicyResult(dict):
    def __init__(__self__, *,
                 code: _builtins.int,
                 ttl: _builtins.int):
        """
        :param _builtins.int code: The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
               can be specified as values, and you cannot specify a status code more than once.
        :param _builtins.int ttl: The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
               (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.int:
        """
        The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
        can be specified as values, and you cannot specify a status code more than once.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
        (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetBackendServiceCircuitBreakerResult(dict):
    def __init__(__self__, *,
                 connect_timeouts: Sequence['outputs.GetBackendServiceCircuitBreakerConnectTimeoutResult'],
                 max_connections: _builtins.int,
                 max_pending_requests: _builtins.int,
                 max_requests: _builtins.int,
                 max_requests_per_connection: _builtins.int,
                 max_retries: _builtins.int):
        """
        :param Sequence['GetBackendServiceCircuitBreakerConnectTimeoutArgs'] connect_timeouts: The timeout for new network connections to hosts.
        :param _builtins.int max_connections: The maximum number of connections to the backend cluster.
               Defaults to 1024.
        :param _builtins.int max_pending_requests: The maximum number of pending requests to the backend cluster.
               Defaults to 1024.
        :param _builtins.int max_requests: The maximum number of parallel requests to the backend cluster.
               Defaults to 1024.
        :param _builtins.int max_requests_per_connection: Maximum requests for a single backend connection. This parameter
               is respected by both the HTTP/1.1 and HTTP/2 implementations. If
               not specified, there is no limit. Setting this parameter to 1
               will effectively disable keep alive.
        :param _builtins.int max_retries: The maximum number of parallel retries to the backend cluster.
               Defaults to 3.
        """
        pulumi.set(__self__, "connect_timeouts", connect_timeouts)
        pulumi.set(__self__, "max_connections", max_connections)
        pulumi.set(__self__, "max_pending_requests", max_pending_requests)
        pulumi.set(__self__, "max_requests", max_requests)
        pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        pulumi.set(__self__, "max_retries", max_retries)

    @_builtins.property
    @pulumi.getter(name="connectTimeouts")
    def connect_timeouts(self) -> Sequence['outputs.GetBackendServiceCircuitBreakerConnectTimeoutResult']:
        """
        The timeout for new network connections to hosts.
        """
        return pulumi.get(self, "connect_timeouts")

    @_builtins.property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> _builtins.int:
        """
        The maximum number of connections to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_connections")

    @_builtins.property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> _builtins.int:
        """
        The maximum number of pending requests to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_pending_requests")

    @_builtins.property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> _builtins.int:
        """
        The maximum number of parallel requests to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_requests")

    @_builtins.property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> _builtins.int:
        """
        Maximum requests for a single backend connection. This parameter
        is respected by both the HTTP/1.1 and HTTP/2 implementations. If
        not specified, there is no limit. Setting this parameter to 1
        will effectively disable keep alive.
        """
        return pulumi.get(self, "max_requests_per_connection")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> _builtins.int:
        """
        The maximum number of parallel retries to the backend cluster.
        Defaults to 3.
        """
        return pulumi.get(self, "max_retries")


@pulumi.output_type
class GetBackendServiceCircuitBreakerConnectTimeoutResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetBackendServiceConsistentHashResult(dict):
    def __init__(__self__, *,
                 http_cookies: Sequence['outputs.GetBackendServiceConsistentHashHttpCookyResult'],
                 http_header_name: _builtins.str,
                 minimum_ring_size: _builtins.int):
        """
        :param Sequence['GetBackendServiceConsistentHashHttpCookyArgs'] http_cookies: Hash is based on HTTP Cookie. This field describes a HTTP cookie
               that will be used as the hash key for the consistent hash load
               balancer. If the cookie is not present, it will be generated.
               This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
        :param _builtins.str http_header_name: The hash based on the value of the specified header field.
               This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        :param _builtins.int minimum_ring_size: The minimum number of virtual nodes to use for the hash ring.
               Larger ring sizes result in more granular load
               distributions. If the number of hosts in the load balancing pool
               is larger than the ring size, each host will be assigned a single
               virtual node.
               Defaults to 1024.
        """
        pulumi.set(__self__, "http_cookies", http_cookies)
        pulumi.set(__self__, "http_header_name", http_header_name)
        pulumi.set(__self__, "minimum_ring_size", minimum_ring_size)

    @_builtins.property
    @pulumi.getter(name="httpCookies")
    def http_cookies(self) -> Sequence['outputs.GetBackendServiceConsistentHashHttpCookyResult']:
        """
        Hash is based on HTTP Cookie. This field describes a HTTP cookie
        that will be used as the hash key for the consistent hash load
        balancer. If the cookie is not present, it will be generated.
        This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
        """
        return pulumi.get(self, "http_cookies")

    @_builtins.property
    @pulumi.getter(name="httpHeaderName")
    def http_header_name(self) -> _builtins.str:
        """
        The hash based on the value of the specified header field.
        This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        """
        return pulumi.get(self, "http_header_name")

    @_builtins.property
    @pulumi.getter(name="minimumRingSize")
    def minimum_ring_size(self) -> _builtins.int:
        """
        The minimum number of virtual nodes to use for the hash ring.
        Larger ring sizes result in more granular load
        distributions. If the number of hosts in the load balancing pool
        is larger than the ring size, each host will be assigned a single
        virtual node.
        Defaults to 1024.
        """
        return pulumi.get(self, "minimum_ring_size")


@pulumi.output_type
class GetBackendServiceConsistentHashHttpCookyResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 path: _builtins.str,
                 ttls: Sequence['outputs.GetBackendServiceConsistentHashHttpCookyTtlResult']):
        """
        :param _builtins.str name: The name of the Backend Service.
               
               - - -
        :param _builtins.str path: Path to set for the cookie.
        :param Sequence['GetBackendServiceConsistentHashHttpCookyTtlArgs'] ttls: Lifetime of the cookie.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "ttls", ttls)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Backend Service.

        - - -
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path to set for the cookie.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def ttls(self) -> Sequence['outputs.GetBackendServiceConsistentHashHttpCookyTtlResult']:
        """
        Lifetime of the cookie.
        """
        return pulumi.get(self, "ttls")


@pulumi.output_type
class GetBackendServiceConsistentHashHttpCookyTtlResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetBackendServiceCustomMetricResult(dict):
    def __init__(__self__, *,
                 dry_run: _builtins.bool,
                 name: _builtins.str):
        """
        :param _builtins.bool dry_run: If true, the metric data is not used for load balancing.
        :param _builtins.str name: The name of the Backend Service.
               
               - - -
        """
        pulumi.set(__self__, "dry_run", dry_run)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> _builtins.bool:
        """
        If true, the metric data is not used for load balancing.
        """
        return pulumi.get(self, "dry_run")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Backend Service.

        - - -
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetBackendServiceDynamicForwardingResult(dict):
    def __init__(__self__, *,
                 ip_port_selections: Sequence['outputs.GetBackendServiceDynamicForwardingIpPortSelectionResult']):
        """
        :param Sequence['GetBackendServiceDynamicForwardingIpPortSelectionArgs'] ip_port_selections: IP:PORT based dynamic forwarding configuration.
        """
        pulumi.set(__self__, "ip_port_selections", ip_port_selections)

    @_builtins.property
    @pulumi.getter(name="ipPortSelections")
    def ip_port_selections(self) -> Sequence['outputs.GetBackendServiceDynamicForwardingIpPortSelectionResult']:
        """
        IP:PORT based dynamic forwarding configuration.
        """
        return pulumi.get(self, "ip_port_selections")


@pulumi.output_type
class GetBackendServiceDynamicForwardingIpPortSelectionResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: A boolean flag enabling IP:PORT based dynamic forwarding.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        A boolean flag enabling IP:PORT based dynamic forwarding.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetBackendServiceIapResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 oauth2_client_id: _builtins.str,
                 oauth2_client_secret: _builtins.str,
                 oauth2_client_secret_sha256: _builtins.str):
        """
        :param _builtins.bool enabled: Whether the serving infrastructure will authenticate and authorize all incoming requests.
        :param _builtins.str oauth2_client_id: OAuth2 Client ID for IAP
        :param _builtins.str oauth2_client_secret: OAuth2 Client Secret for IAP
        :param _builtins.str oauth2_client_secret_sha256: OAuth2 Client Secret SHA-256 for IAP
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "oauth2_client_id", oauth2_client_id)
        pulumi.set(__self__, "oauth2_client_secret", oauth2_client_secret)
        pulumi.set(__self__, "oauth2_client_secret_sha256", oauth2_client_secret_sha256)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether the serving infrastructure will authenticate and authorize all incoming requests.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientId")
    def oauth2_client_id(self) -> _builtins.str:
        """
        OAuth2 Client ID for IAP
        """
        return pulumi.get(self, "oauth2_client_id")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientSecret")
    def oauth2_client_secret(self) -> _builtins.str:
        """
        OAuth2 Client Secret for IAP
        """
        return pulumi.get(self, "oauth2_client_secret")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientSecretSha256")
    def oauth2_client_secret_sha256(self) -> _builtins.str:
        """
        OAuth2 Client Secret SHA-256 for IAP
        """
        return pulumi.get(self, "oauth2_client_secret_sha256")


@pulumi.output_type
class GetBackendServiceLocalityLbPolicyResult(dict):
    def __init__(__self__, *,
                 custom_policies: Sequence['outputs.GetBackendServiceLocalityLbPolicyCustomPolicyResult'],
                 policies: Sequence['outputs.GetBackendServiceLocalityLbPolicyPolicyResult']):
        """
        :param Sequence['GetBackendServiceLocalityLbPolicyCustomPolicyArgs'] custom_policies: The configuration for a custom policy implemented by the user and
               deployed with the client.
        :param Sequence['GetBackendServiceLocalityLbPolicyPolicyArgs'] policies: The configuration for a built-in load balancing policy.
        """
        pulumi.set(__self__, "custom_policies", custom_policies)
        pulumi.set(__self__, "policies", policies)

    @_builtins.property
    @pulumi.getter(name="customPolicies")
    def custom_policies(self) -> Sequence['outputs.GetBackendServiceLocalityLbPolicyCustomPolicyResult']:
        """
        The configuration for a custom policy implemented by the user and
        deployed with the client.
        """
        return pulumi.get(self, "custom_policies")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetBackendServiceLocalityLbPolicyPolicyResult']:
        """
        The configuration for a built-in load balancing policy.
        """
        return pulumi.get(self, "policies")


@pulumi.output_type
class GetBackendServiceLocalityLbPolicyCustomPolicyResult(dict):
    def __init__(__self__, *,
                 data: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str data: An optional, arbitrary JSON object with configuration data, understood
               by a locally installed custom policy implementation.
        :param _builtins.str name: The name of the Backend Service.
               
               - - -
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def data(self) -> _builtins.str:
        """
        An optional, arbitrary JSON object with configuration data, understood
        by a locally installed custom policy implementation.
        """
        return pulumi.get(self, "data")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Backend Service.

        - - -
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetBackendServiceLocalityLbPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of the Backend Service.
               
               - - -
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Backend Service.

        - - -
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetBackendServiceLogConfigResult(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool,
                 optional_fields: Sequence[_builtins.str],
                 optional_mode: _builtins.str,
                 sample_rate: _builtins.float):
        """
        :param _builtins.bool enable: Whether to enable logging for the load balancer traffic served by this backend service.
        :param Sequence[_builtins.str] optional_fields: This field can only be specified if logging is enabled for this backend service and "logConfig.optionalMode"
               was set to CUSTOM. Contains a list of optional fields you want to include in the logs.
               For example: serverInstance, serverGkeDetails.cluster, serverGkeDetails.pod.podNamespace
               For example: orca_load_report, tls.protocol
        :param _builtins.str optional_mode: Specifies the optional logging mode for the load balancer traffic.
               Supported values: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM. Possible values: ["INCLUDE_ALL_OPTIONAL", "EXCLUDE_ALL_OPTIONAL", "CUSTOM"]
        :param _builtins.float sample_rate: This field can only be specified if logging is enabled for this backend service. The value of
               the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
               where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
               The default value is 1.0.
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "optional_fields", optional_fields)
        pulumi.set(__self__, "optional_mode", optional_mode)
        pulumi.set(__self__, "sample_rate", sample_rate)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Whether to enable logging for the load balancer traffic served by this backend service.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="optionalFields")
    def optional_fields(self) -> Sequence[_builtins.str]:
        """
        This field can only be specified if logging is enabled for this backend service and "logConfig.optionalMode"
        was set to CUSTOM. Contains a list of optional fields you want to include in the logs.
        For example: serverInstance, serverGkeDetails.cluster, serverGkeDetails.pod.podNamespace
        For example: orca_load_report, tls.protocol
        """
        return pulumi.get(self, "optional_fields")

    @_builtins.property
    @pulumi.getter(name="optionalMode")
    def optional_mode(self) -> _builtins.str:
        """
        Specifies the optional logging mode for the load balancer traffic.
        Supported values: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM. Possible values: ["INCLUDE_ALL_OPTIONAL", "EXCLUDE_ALL_OPTIONAL", "CUSTOM"]
        """
        return pulumi.get(self, "optional_mode")

    @_builtins.property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> _builtins.float:
        """
        This field can only be specified if logging is enabled for this backend service. The value of
        the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
        where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
        The default value is 1.0.
        """
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class GetBackendServiceMaxStreamDurationResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.str):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution.
               Durations less than one second are represented with a 0 seconds field and a positive nanos field.
               Must be from 0 to 999,999,999 inclusive.
        :param _builtins.str seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. (int64 format)
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond resolution.
        Durations less than one second are represented with a 0 seconds field and a positive nanos field.
        Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. (int64 format)
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetBackendServiceNetworkPassThroughLbTrafficPolicyResult(dict):
    def __init__(__self__, *,
                 zonal_affinities: Sequence['outputs.GetBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinityResult']):
        """
        :param Sequence['GetBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinityArgs'] zonal_affinities: When configured, new connections are load balanced across healthy backend endpoints in the local zone.
        """
        pulumi.set(__self__, "zonal_affinities", zonal_affinities)

    @_builtins.property
    @pulumi.getter(name="zonalAffinities")
    def zonal_affinities(self) -> Sequence['outputs.GetBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinityResult']:
        """
        When configured, new connections are load balanced across healthy backend endpoints in the local zone.
        """
        return pulumi.get(self, "zonal_affinities")


@pulumi.output_type
class GetBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinityResult(dict):
    def __init__(__self__, *,
                 spillover: _builtins.str,
                 spillover_ratio: _builtins.float):
        """
        :param _builtins.str spillover: This field indicates whether zonal affinity is enabled or not. Default value: "ZONAL_AFFINITY_DISABLED" Possible values: ["ZONAL_AFFINITY_DISABLED", "ZONAL_AFFINITY_SPILL_CROSS_ZONE", "ZONAL_AFFINITY_STAY_WITHIN_ZONE"]
        :param _builtins.float spillover_ratio: The value of the field must be in [0, 1]. When the ratio of the count of healthy backend endpoints in a zone
               to the count of backend endpoints in that same zone is equal to or above this threshold, the load balancer
               distributes new connections to all healthy endpoints in the local zone only. When the ratio of the count
               of healthy backend endpoints in a zone to the count of backend endpoints in that same zone is below this
               threshold, the load balancer distributes all new connections to all healthy endpoints across all zones.
        """
        pulumi.set(__self__, "spillover", spillover)
        pulumi.set(__self__, "spillover_ratio", spillover_ratio)

    @_builtins.property
    @pulumi.getter
    def spillover(self) -> _builtins.str:
        """
        This field indicates whether zonal affinity is enabled or not. Default value: "ZONAL_AFFINITY_DISABLED" Possible values: ["ZONAL_AFFINITY_DISABLED", "ZONAL_AFFINITY_SPILL_CROSS_ZONE", "ZONAL_AFFINITY_STAY_WITHIN_ZONE"]
        """
        return pulumi.get(self, "spillover")

    @_builtins.property
    @pulumi.getter(name="spilloverRatio")
    def spillover_ratio(self) -> _builtins.float:
        """
        The value of the field must be in [0, 1]. When the ratio of the count of healthy backend endpoints in a zone
        to the count of backend endpoints in that same zone is equal to or above this threshold, the load balancer
        distributes new connections to all healthy endpoints in the local zone only. When the ratio of the count
        of healthy backend endpoints in a zone to the count of backend endpoints in that same zone is below this
        threshold, the load balancer distributes all new connections to all healthy endpoints across all zones.
        """
        return pulumi.get(self, "spillover_ratio")


@pulumi.output_type
class GetBackendServiceOutlierDetectionResult(dict):
    def __init__(__self__, *,
                 base_ejection_times: Sequence['outputs.GetBackendServiceOutlierDetectionBaseEjectionTimeResult'],
                 consecutive_errors: _builtins.int,
                 consecutive_gateway_failure: _builtins.int,
                 enforcing_consecutive_errors: _builtins.int,
                 enforcing_consecutive_gateway_failure: _builtins.int,
                 enforcing_success_rate: _builtins.int,
                 intervals: Sequence['outputs.GetBackendServiceOutlierDetectionIntervalResult'],
                 max_ejection_percent: _builtins.int,
                 success_rate_minimum_hosts: _builtins.int,
                 success_rate_request_volume: _builtins.int,
                 success_rate_stdev_factor: _builtins.int):
        """
        :param Sequence['GetBackendServiceOutlierDetectionBaseEjectionTimeArgs'] base_ejection_times: The base time that a host is ejected for. The real time is equal to the base
               time multiplied by the number of times the host has been ejected. Defaults to
               30000ms or 30s.
        :param _builtins.int consecutive_errors: Number of errors before a host is ejected from the connection pool. When the
               backend host is accessed over HTTP, a 5xx return code qualifies as an error.
               Defaults to 5.
        :param _builtins.int consecutive_gateway_failure: The number of consecutive gateway failures (502, 503, 504 status or connection
               errors that are mapped to one of those status codes) before a consecutive
               gateway failure ejection occurs. Defaults to 5.
        :param _builtins.int enforcing_consecutive_errors: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive 5xx. This setting can be used to disable
               ejection or to ramp it up slowly. Defaults to 100.
        :param _builtins.int enforcing_consecutive_gateway_failure: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive gateway failures. This setting can be
               used to disable ejection or to ramp it up slowly. Defaults to 0.
        :param _builtins.int enforcing_success_rate: The percentage chance that a host will be actually ejected when an outlier
               status is detected through success rate statistics. This setting can be used to
               disable ejection or to ramp it up slowly. Defaults to 100.
        :param Sequence['GetBackendServiceOutlierDetectionIntervalArgs'] intervals: Time interval between ejection sweep analysis. This can result in both new
               ejections as well as hosts being returned to service. Defaults to 10 seconds.
        :param _builtins.int max_ejection_percent: Maximum percentage of hosts in the load balancing pool for the backend service
               that can be ejected. Defaults to 10%.
        :param _builtins.int success_rate_minimum_hosts: The number of hosts in a cluster that must have enough request volume to detect
               success rate outliers. If the number of hosts is less than this setting, outlier
               detection via success rate statistics is not performed for any host in the
               cluster. Defaults to 5.
        :param _builtins.int success_rate_request_volume: The minimum number of total requests that must be collected in one interval (as
               defined by the interval duration above) to include this host in success rate
               based outlier detection. If the volume is lower than this setting, outlier
               detection via success rate statistics is not performed for that host. Defaults
               to 100.
        :param _builtins.int success_rate_stdev_factor: This factor is used to determine the ejection threshold for success rate outlier
               ejection. The ejection threshold is the difference between the mean success
               rate, and the product of this factor and the standard deviation of the mean
               success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
               by a thousand to get a double. That is, if the desired factor is 1.9, the
               runtime value should be 1900. Defaults to 1900.
        """
        pulumi.set(__self__, "base_ejection_times", base_ejection_times)
        pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        pulumi.set(__self__, "consecutive_gateway_failure", consecutive_gateway_failure)
        pulumi.set(__self__, "enforcing_consecutive_errors", enforcing_consecutive_errors)
        pulumi.set(__self__, "enforcing_consecutive_gateway_failure", enforcing_consecutive_gateway_failure)
        pulumi.set(__self__, "enforcing_success_rate", enforcing_success_rate)
        pulumi.set(__self__, "intervals", intervals)
        pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        pulumi.set(__self__, "success_rate_minimum_hosts", success_rate_minimum_hosts)
        pulumi.set(__self__, "success_rate_request_volume", success_rate_request_volume)
        pulumi.set(__self__, "success_rate_stdev_factor", success_rate_stdev_factor)

    @_builtins.property
    @pulumi.getter(name="baseEjectionTimes")
    def base_ejection_times(self) -> Sequence['outputs.GetBackendServiceOutlierDetectionBaseEjectionTimeResult']:
        """
        The base time that a host is ejected for. The real time is equal to the base
        time multiplied by the number of times the host has been ejected. Defaults to
        30000ms or 30s.
        """
        return pulumi.get(self, "base_ejection_times")

    @_builtins.property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> _builtins.int:
        """
        Number of errors before a host is ejected from the connection pool. When the
        backend host is accessed over HTTP, a 5xx return code qualifies as an error.
        Defaults to 5.
        """
        return pulumi.get(self, "consecutive_errors")

    @_builtins.property
    @pulumi.getter(name="consecutiveGatewayFailure")
    def consecutive_gateway_failure(self) -> _builtins.int:
        """
        The number of consecutive gateway failures (502, 503, 504 status or connection
        errors that are mapped to one of those status codes) before a consecutive
        gateway failure ejection occurs. Defaults to 5.
        """
        return pulumi.get(self, "consecutive_gateway_failure")

    @_builtins.property
    @pulumi.getter(name="enforcingConsecutiveErrors")
    def enforcing_consecutive_errors(self) -> _builtins.int:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive 5xx. This setting can be used to disable
        ejection or to ramp it up slowly. Defaults to 100.
        """
        return pulumi.get(self, "enforcing_consecutive_errors")

    @_builtins.property
    @pulumi.getter(name="enforcingConsecutiveGatewayFailure")
    def enforcing_consecutive_gateway_failure(self) -> _builtins.int:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive gateway failures. This setting can be
        used to disable ejection or to ramp it up slowly. Defaults to 0.
        """
        return pulumi.get(self, "enforcing_consecutive_gateway_failure")

    @_builtins.property
    @pulumi.getter(name="enforcingSuccessRate")
    def enforcing_success_rate(self) -> _builtins.int:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through success rate statistics. This setting can be used to
        disable ejection or to ramp it up slowly. Defaults to 100.
        """
        return pulumi.get(self, "enforcing_success_rate")

    @_builtins.property
    @pulumi.getter
    def intervals(self) -> Sequence['outputs.GetBackendServiceOutlierDetectionIntervalResult']:
        """
        Time interval between ejection sweep analysis. This can result in both new
        ejections as well as hosts being returned to service. Defaults to 10 seconds.
        """
        return pulumi.get(self, "intervals")

    @_builtins.property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> _builtins.int:
        """
        Maximum percentage of hosts in the load balancing pool for the backend service
        that can be ejected. Defaults to 10%.
        """
        return pulumi.get(self, "max_ejection_percent")

    @_builtins.property
    @pulumi.getter(name="successRateMinimumHosts")
    def success_rate_minimum_hosts(self) -> _builtins.int:
        """
        The number of hosts in a cluster that must have enough request volume to detect
        success rate outliers. If the number of hosts is less than this setting, outlier
        detection via success rate statistics is not performed for any host in the
        cluster. Defaults to 5.
        """
        return pulumi.get(self, "success_rate_minimum_hosts")

    @_builtins.property
    @pulumi.getter(name="successRateRequestVolume")
    def success_rate_request_volume(self) -> _builtins.int:
        """
        The minimum number of total requests that must be collected in one interval (as
        defined by the interval duration above) to include this host in success rate
        based outlier detection. If the volume is lower than this setting, outlier
        detection via success rate statistics is not performed for that host. Defaults
        to 100.
        """
        return pulumi.get(self, "success_rate_request_volume")

    @_builtins.property
    @pulumi.getter(name="successRateStdevFactor")
    def success_rate_stdev_factor(self) -> _builtins.int:
        """
        This factor is used to determine the ejection threshold for success rate outlier
        ejection. The ejection threshold is the difference between the mean success
        rate, and the product of this factor and the standard deviation of the mean
        success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
        by a thousand to get a double. That is, if the desired factor is 1.9, the
        runtime value should be 1900. Defaults to 1900.
        """
        return pulumi.get(self, "success_rate_stdev_factor")


@pulumi.output_type
class GetBackendServiceOutlierDetectionBaseEjectionTimeResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 'seconds' field and a positive
               'nanos' field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 'seconds' field and a positive
        'nanos' field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetBackendServiceOutlierDetectionIntervalResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 'seconds' field and a positive
               'nanos' field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 'seconds' field and a positive
        'nanos' field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetBackendServiceParamResult(dict):
    def __init__(__self__, *,
                 resource_manager_tags: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the backend service. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456.
        """
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        Resource manager tags to be bound to the backend service. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class GetBackendServiceSecuritySettingResult(dict):
    def __init__(__self__, *,
                 aws_v4_authentications: Sequence['outputs.GetBackendServiceSecuritySettingAwsV4AuthenticationResult'],
                 client_tls_policy: _builtins.str,
                 subject_alt_names: Sequence[_builtins.str]):
        """
        :param Sequence['GetBackendServiceSecuritySettingAwsV4AuthenticationArgs'] aws_v4_authentications: The configuration needed to generate a signature for access to private storage buckets that support AWS's Signature Version 4 for authentication.
               Allowed only for INTERNET_IP_PORT and INTERNET_FQDN_PORT NEG backends.
        :param _builtins.str client_tls_policy: ClientTlsPolicy is a resource that specifies how a client should authenticate
               connections to backends of a service. This resource itself does not affect
               configuration unless it is attached to a backend service resource.
        :param Sequence[_builtins.str] subject_alt_names: A list of alternate names to verify the subject identity in the certificate.
               If specified, the client will verify that the server certificate's subject
               alt name matches one of the specified values.
        """
        pulumi.set(__self__, "aws_v4_authentications", aws_v4_authentications)
        pulumi.set(__self__, "client_tls_policy", client_tls_policy)
        pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @_builtins.property
    @pulumi.getter(name="awsV4Authentications")
    def aws_v4_authentications(self) -> Sequence['outputs.GetBackendServiceSecuritySettingAwsV4AuthenticationResult']:
        """
        The configuration needed to generate a signature for access to private storage buckets that support AWS's Signature Version 4 for authentication.
        Allowed only for INTERNET_IP_PORT and INTERNET_FQDN_PORT NEG backends.
        """
        return pulumi.get(self, "aws_v4_authentications")

    @_builtins.property
    @pulumi.getter(name="clientTlsPolicy")
    def client_tls_policy(self) -> _builtins.str:
        """
        ClientTlsPolicy is a resource that specifies how a client should authenticate
        connections to backends of a service. This resource itself does not affect
        configuration unless it is attached to a backend service resource.
        """
        return pulumi.get(self, "client_tls_policy")

    @_builtins.property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Sequence[_builtins.str]:
        """
        A list of alternate names to verify the subject identity in the certificate.
        If specified, the client will verify that the server certificate's subject
        alt name matches one of the specified values.
        """
        return pulumi.get(self, "subject_alt_names")


@pulumi.output_type
class GetBackendServiceSecuritySettingAwsV4AuthenticationResult(dict):
    def __init__(__self__, *,
                 access_key: _builtins.str,
                 access_key_id: _builtins.str,
                 access_key_version: _builtins.str,
                 origin_region: _builtins.str):
        """
        :param _builtins.str access_key: The access key used for s3 bucket authentication.
               Required for updating or creating a backend that uses AWS v4 signature authentication, but will not be returned as part of the configuration when queried with a REST API GET request.
        :param _builtins.str access_key_id: The identifier of an access key used for s3 bucket authentication.
        :param _builtins.str access_key_version: The optional version identifier for the access key. You can use this to keep track of different iterations of your access key.
        :param _builtins.str origin_region: The name of the cloud region of your origin. This is a free-form field with the name of the region your cloud uses to host your origin.
               For example, "us-east-1" for AWS or "us-ashburn-1" for OCI.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "access_key_version", access_key_version)
        pulumi.set(__self__, "origin_region", origin_region)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> _builtins.str:
        """
        The access key used for s3 bucket authentication.
        Required for updating or creating a backend that uses AWS v4 signature authentication, but will not be returned as part of the configuration when queried with a REST API GET request.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> _builtins.str:
        """
        The identifier of an access key used for s3 bucket authentication.
        """
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter(name="accessKeyVersion")
    def access_key_version(self) -> _builtins.str:
        """
        The optional version identifier for the access key. You can use this to keep track of different iterations of your access key.
        """
        return pulumi.get(self, "access_key_version")

    @_builtins.property
    @pulumi.getter(name="originRegion")
    def origin_region(self) -> _builtins.str:
        """
        The name of the cloud region of your origin. This is a free-form field with the name of the region your cloud uses to host your origin.
        For example, "us-east-1" for AWS or "us-ashburn-1" for OCI.
        """
        return pulumi.get(self, "origin_region")


@pulumi.output_type
class GetBackendServiceStrongSessionAffinityCookyResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 path: _builtins.str,
                 ttls: Sequence['outputs.GetBackendServiceStrongSessionAffinityCookyTtlResult']):
        """
        :param _builtins.str name: The name of the Backend Service.
               
               - - -
        :param _builtins.str path: Path to set for the cookie.
        :param Sequence['GetBackendServiceStrongSessionAffinityCookyTtlArgs'] ttls: Lifetime of the cookie.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "ttls", ttls)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Backend Service.

        - - -
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path to set for the cookie.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def ttls(self) -> Sequence['outputs.GetBackendServiceStrongSessionAffinityCookyTtlResult']:
        """
        Lifetime of the cookie.
        """
        return pulumi.get(self, "ttls")


@pulumi.output_type
class GetBackendServiceStrongSessionAffinityCookyTtlResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetBackendServiceTlsSettingResult(dict):
    def __init__(__self__, *,
                 authentication_config: _builtins.str,
                 sni: _builtins.str,
                 subject_alt_names: Sequence['outputs.GetBackendServiceTlsSettingSubjectAltNameResult']):
        """
        :param _builtins.str authentication_config: Reference to the BackendAuthenticationConfig resource from the networksecurity.googleapis.com namespace.
               Can be used in authenticating TLS connections to the backend, as specified by the authenticationMode field.
               Can only be specified if authenticationMode is not NONE.
        :param _builtins.str sni: Server Name Indication - see RFC3546 section 3.1. If set, the load balancer sends this string as the SNI hostname in the
               TLS connection to the backend, and requires that this string match a Subject Alternative Name (SAN) in the backend's
               server certificate. With a Regional Internet NEG backend, if the SNI is specified here, the load balancer uses it
               regardless of whether the Regional Internet NEG is specified with FQDN or IP address and port.
        :param Sequence['GetBackendServiceTlsSettingSubjectAltNameArgs'] subject_alt_names: A list of Subject Alternative Names (SANs) that the Load Balancer verifies during a TLS handshake with the backend.
               When the server presents its X.509 certificate to the Load Balancer, the Load Balancer inspects the certificate's SAN field,
               and requires that at least one SAN match one of the subjectAltNames in the list. This field is limited to 5 entries.
               When both sni and subjectAltNames are specified, the load balancer matches the backend certificate's SAN only to
               subjectAltNames.
        """
        pulumi.set(__self__, "authentication_config", authentication_config)
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @_builtins.property
    @pulumi.getter(name="authenticationConfig")
    def authentication_config(self) -> _builtins.str:
        """
        Reference to the BackendAuthenticationConfig resource from the networksecurity.googleapis.com namespace.
        Can be used in authenticating TLS connections to the backend, as specified by the authenticationMode field.
        Can only be specified if authenticationMode is not NONE.
        """
        return pulumi.get(self, "authentication_config")

    @_builtins.property
    @pulumi.getter
    def sni(self) -> _builtins.str:
        """
        Server Name Indication - see RFC3546 section 3.1. If set, the load balancer sends this string as the SNI hostname in the
        TLS connection to the backend, and requires that this string match a Subject Alternative Name (SAN) in the backend's
        server certificate. With a Regional Internet NEG backend, if the SNI is specified here, the load balancer uses it
        regardless of whether the Regional Internet NEG is specified with FQDN or IP address and port.
        """
        return pulumi.get(self, "sni")

    @_builtins.property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Sequence['outputs.GetBackendServiceTlsSettingSubjectAltNameResult']:
        """
        A list of Subject Alternative Names (SANs) that the Load Balancer verifies during a TLS handshake with the backend.
        When the server presents its X.509 certificate to the Load Balancer, the Load Balancer inspects the certificate's SAN field,
        and requires that at least one SAN match one of the subjectAltNames in the list. This field is limited to 5 entries.
        When both sni and subjectAltNames are specified, the load balancer matches the backend certificate's SAN only to
        subjectAltNames.
        """
        return pulumi.get(self, "subject_alt_names")


@pulumi.output_type
class GetBackendServiceTlsSettingSubjectAltNameResult(dict):
    def __init__(__self__, *,
                 dns_name: _builtins.str,
                 uniform_resource_identifier: _builtins.str):
        """
        :param _builtins.str dns_name: The SAN specified as a DNS Name.
        :param _builtins.str uniform_resource_identifier: The SAN specified as a URI.
        """
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "uniform_resource_identifier", uniform_resource_identifier)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        """
        The SAN specified as a DNS Name.
        """
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="uniformResourceIdentifier")
    def uniform_resource_identifier(self) -> _builtins.str:
        """
        The SAN specified as a URI.
        """
        return pulumi.get(self, "uniform_resource_identifier")


@pulumi.output_type
class GetDiskAsyncPrimaryDiskResult(dict):
    def __init__(__self__, *,
                 disk: _builtins.str):
        """
        :param _builtins.str disk: Primary disk for asynchronous disk replication.
        """
        pulumi.set(__self__, "disk", disk)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> _builtins.str:
        """
        Primary disk for asynchronous disk replication.
        """
        return pulumi.get(self, "disk")


@pulumi.output_type
class GetDiskDiskEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 raw_key: _builtins.str,
                 rsa_encrypted_key: _builtins.str,
                 sha256: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               ('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com') must have
               'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param _builtins.str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
               customer-supplied encryption key to either encrypt or decrypt
               this resource. You can provide either the rawKey or the rsaEncryptedKey.
        :param _builtins.str sha256: The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        ('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com') must have
        'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> _builtins.str:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
        customer-supplied encryption key to either encrypt or decrypt
        this resource. You can provide either the rawKey or the rsaEncryptedKey.
        """
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> _builtins.str:
        """
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class GetDiskGuestOsFeatureResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: URL of the disk type resource describing which disk type to use to
               create the disk.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        URL of the disk type resource describing which disk type to use to
        create the disk.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDiskParamResult(dict):
    def __init__(__self__, *,
                 resource_manager_tags: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the disk. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456.
        """
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        Resource manager tags to be bound to the disk. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class GetDiskSourceImageEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 raw_key: _builtins.str,
                 sha256: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               ('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com') must have
               'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param _builtins.str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param _builtins.str sha256: The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        ('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com') must have
        'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> _builtins.str:
        """
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class GetDiskSourceSnapshotEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 raw_key: _builtins.str,
                 sha256: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
               in the cloud console. Your project's Compute Engine System service account
               ('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com') must have
               'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this feature.
               See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        :param _builtins.str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param _builtins.str sha256: The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
        in the cloud console. Your project's Compute Engine System service account
        ('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com') must have
        'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this feature.
        See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> _builtins.str:
        """
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class GetForwardingRuleServiceDirectoryRegistrationResult(dict):
    def __init__(__self__, *,
                 namespace: _builtins.str,
                 service: _builtins.str):
        """
        :param _builtins.str namespace: Service Directory namespace to register the forwarding rule under.
        :param _builtins.str service: Service Directory service to register the forwarding rule under.
        """
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Service Directory namespace to register the forwarding rule under.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        Service Directory service to register the forwarding rule under.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetForwardingRulesRuleResult(dict):
    def __init__(__self__, *,
                 all_ports: _builtins.bool,
                 allow_global_access: _builtins.bool,
                 allow_psc_global_access: _builtins.bool,
                 backend_service: _builtins.str,
                 base_forwarding_rule: _builtins.str,
                 creation_timestamp: _builtins.str,
                 description: _builtins.str,
                 effective_labels: Mapping[str, _builtins.str],
                 forwarding_rule_id: _builtins.int,
                 ip_address: _builtins.str,
                 ip_collection: _builtins.str,
                 ip_protocol: _builtins.str,
                 ip_version: _builtins.str,
                 is_mirroring_collector: _builtins.bool,
                 label_fingerprint: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 load_balancing_scheme: _builtins.str,
                 name: _builtins.str,
                 network: _builtins.str,
                 network_tier: _builtins.str,
                 no_automate_dns_zone: _builtins.bool,
                 port_range: _builtins.str,
                 ports: Sequence[_builtins.str],
                 project: _builtins.str,
                 psc_connection_id: _builtins.str,
                 psc_connection_status: _builtins.str,
                 pulumi_labels: Mapping[str, _builtins.str],
                 recreate_closed_psc: _builtins.bool,
                 region: _builtins.str,
                 self_link: _builtins.str,
                 service_directory_registrations: Sequence['outputs.GetForwardingRulesRuleServiceDirectoryRegistrationResult'],
                 service_label: _builtins.str,
                 service_name: _builtins.str,
                 source_ip_ranges: Sequence[_builtins.str],
                 subnetwork: _builtins.str,
                 target: _builtins.str):
        """
        :param _builtins.bool all_ports: The 'ports', 'portRange', and 'allPorts' fields are mutually exclusive.
               Only packets addressed to ports in the specified range will be forwarded
               to the backends configured with this forwarding rule.
               
               The 'allPorts' field has the following limitations:
               * It requires that the forwarding rule 'IPProtocol' be TCP, UDP, SCTP, or
               L3_DEFAULT.
               * It's applicable only to the following products: internal passthrough
               Network Load Balancers, backend service-based external passthrough Network
               Load Balancers, and internal and external protocol forwarding.
               * Set this field to true to allow packets addressed to any port or packets
               lacking destination port information (for example, UDP fragments after the
               first fragment) to be forwarded to the backends configured with this
               forwarding rule. The L3_DEFAULT protocol requires 'allPorts' be set to
               true.
        :param _builtins.bool allow_global_access: This field is used along with the 'backend_service' field for
               internal load balancing or with the 'target' field for internal
               TargetInstance.
               
               If the field is set to 'TRUE', clients can access ILB from all
               regions.
               
               Otherwise only allows access from clients in the same region as the
               internal load balancer.
        :param _builtins.bool allow_psc_global_access: This is used in PSC consumer ForwardingRule to control whether the PSC endpoint can be accessed from another region.
        :param _builtins.str backend_service: Identifies the backend service to which the forwarding rule sends traffic.
               
               Required for Internal TCP/UDP Load Balancing and Network Load Balancing;
               must be omitted for all other load balancer types.
        :param _builtins.str base_forwarding_rule: [Output Only] The URL for the corresponding base Forwarding Rule. By base Forwarding Rule, we mean the Forwarding Rule that has the same IP address, protocol, and port settings with the current Forwarding Rule, but without sourceIPRanges specified. Always empty if the current Forwarding Rule does not have sourceIPRanges specified.
        :param _builtins.str creation_timestamp: Creation timestamp in RFC3339 text format.
        :param _builtins.str description: An optional description of this resource. Provide this property when
               you create the resource.
        :param _builtins.int forwarding_rule_id: The unique identifier number for the resource. This identifier is defined by the server.
        :param _builtins.str ip_address: IP address for which this forwarding rule accepts traffic. When a client
               sends traffic to this IP address, the forwarding rule directs the traffic
               to the referenced 'target' or 'backendService'.
               
               While creating a forwarding rule, specifying an 'IPAddress' is
               required under the following circumstances:
               
               * When the 'target' is set to 'targetGrpcProxy' and
               'validateForProxyless' is set to 'true', the
               'IPAddress' should be set to '0.0.0.0'.
               * When the 'target' is a Private Service Connect Google APIs
               bundle, you must specify an 'IPAddress'.
               
               Otherwise, you can optionally specify an IP address that references an
               existing static (reserved) IP address resource. When omitted, Google Cloud
               assigns an ephemeral IP address.
               
               Use one of the following formats to specify an IP address while creating a
               forwarding rule:
               
               * IP address number, as in '100.1.2.3'
               * IPv6 address range, as in '2600:1234::/96'
               * Full resource URL, as in
               'https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name'
               * Partial URL or by name, as in:
                 * 'projects/project_id/regions/region/addresses/address-name'
                 * 'regions/region/addresses/address-name'
                 * 'global/addresses/address-name'
                 * 'address-name'
               
               The forwarding rule's 'target' or 'backendService',
               and in most cases, also the 'loadBalancingScheme', determine the
               type of IP address that you can use. For detailed information, see
               [IP address
               specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
               
               When reading an 'IPAddress', the API always returns the IP
               address number.
        :param _builtins.str ip_collection: Resource reference of a PublicDelegatedPrefix. The PDP must be a sub-PDP
               in EXTERNAL_IPV6_FORWARDING_RULE_CREATION mode.
               Use one of the following formats to specify a sub-PDP when creating an
               IPv6 NetLB forwarding rule using BYOIP:
               Full resource URL, as in:
                 * 'https://www.googleapis.com/compute/v1/projects/{{projectId}}/regions/{{region}}/publicDelegatedPrefixes/{{sub-pdp-name}}'
               Partial URL, as in:
                 * 'projects/{{projectId}}/regions/region/publicDelegatedPrefixes/{{sub-pdp-name}}'
                 * 'regions/{{region}}/publicDelegatedPrefixes/{{sub-pdp-name}}'
        :param _builtins.str ip_protocol: The IP protocol to which this rule applies.
               
               For protocol forwarding, valid
               options are 'TCP', 'UDP', 'ESP',
               'AH', 'SCTP', 'ICMP' and
               'L3_DEFAULT'.
               
               The valid IP protocols are different for different load balancing products
               as described in [Load balancing
               features](https://cloud.google.com/load-balancing/docs/features#protocols_from_the_load_balancer_to_the_backends).
               
               A Forwarding Rule with protocol L3_DEFAULT can attach with target instance or
               backend service with UNSPECIFIED protocol.
               A forwarding rule with "L3_DEFAULT" IPProtocal cannot be attached to a backend service with TCP or UDP. Possible values: ["TCP", "UDP", "ESP", "AH", "SCTP", "ICMP", "L3_DEFAULT"]
        :param _builtins.str ip_version: The IP address version that will be used by this forwarding rule.
               Valid options are IPV4 and IPV6.
               
               If not set, the IPv4 address will be used by default. Possible values: ["IPV4", "IPV6"]
        :param _builtins.bool is_mirroring_collector: Indicates whether or not this load balancer can be used as a collector for
               packet mirroring. To prevent mirroring loops, instances behind this
               load balancer will not have their traffic mirrored even if a
               'PacketMirroring' rule applies to them.
               
               This can only be set to true for load balancers that have their
               'loadBalancingScheme' set to 'INTERNAL'.
        :param _builtins.str label_fingerprint: The fingerprint used for optimistic locking of this resource.  Used
               internally during updates.
        :param Mapping[str, _builtins.str] labels: Labels to apply to this forwarding rule.  A list of key->value pairs.
               
               
               **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
               Please refer to the field 'effective_labels' for all of the labels present on the resource.
        :param _builtins.str load_balancing_scheme: Specifies the forwarding rule type.
               
               Note that an empty string value ('""') is also supported for some use
               cases, for example PSC (private service connection) regional forwarding
               rules.
               
               For more information about forwarding rules, refer to
               [Forwarding rule concepts](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts). Default value: "EXTERNAL" Possible values: ["EXTERNAL", "EXTERNAL_MANAGED", "INTERNAL", "INTERNAL_MANAGED"]
        :param _builtins.str name: Name of the resource; provided by the client when the resource is created.
               The name must be 1-63 characters long, and comply with
               [RFC1035](https://www.ietf.org/rfc/rfc1035.txt).
               
               Specifically, the name must be 1-63 characters long and match the regular
               expression 'a-z?' which means the first
               character must be a lowercase letter, and all following characters must
               be a dash, lowercase letter, or digit, except the last character, which
               cannot be a dash.
               
               For Private Service Connect forwarding rules that forward traffic to Google
               APIs, the forwarding rule name must be a 1-20 characters string with
               lowercase letters and numbers and must start with a letter.
        :param _builtins.str network: This field is not used for external load balancing.
               
               For Internal TCP/UDP Load Balancing, this field identifies the network that
               the load balanced IP should belong to for this Forwarding Rule.
               If the subnetwork is specified, the network of the subnetwork will be used.
               If neither subnetwork nor this field is specified, the default network will
               be used.
               
               For Private Service Connect forwarding rules that forward traffic to Google
               APIs, a network must be provided.
        :param _builtins.str network_tier: This signifies the networking tier used for configuring
               this load balancer and can only take the following values:
               'PREMIUM', 'STANDARD'.
               
               For regional ForwardingRule, the valid values are 'PREMIUM' and
               'STANDARD'. For GlobalForwardingRule, the valid value is
               'PREMIUM'.
               
               If this field is not specified, it is assumed to be 'PREMIUM'.
               If 'IPAddress' is specified, this value must be equal to the
               networkTier of the Address. Possible values: ["PREMIUM", "STANDARD"]
        :param _builtins.bool no_automate_dns_zone: This is used in PSC consumer ForwardingRule to control whether it should try to auto-generate a DNS zone or not. Non-PSC forwarding rules do not use this field.
        :param _builtins.str port_range: The 'ports', 'portRange', and 'allPorts' fields are mutually exclusive.
               Only packets addressed to ports in the specified range will be forwarded
               to the backends configured with this forwarding rule.
               
               The 'portRange' field has the following limitations:
               * It requires that the forwarding rule 'IPProtocol' be TCP, UDP, or SCTP,
               and
               * It's applicable only to the following products: external passthrough
               Network Load Balancers, internal and external proxy Network Load
               Balancers, internal and external Application Load Balancers, external
               protocol forwarding, and Classic VPN.
               * Some products have restrictions on what ports can be used. See
               [port specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#port_specifications)
               for details.
               
               For external forwarding rules, two or more forwarding rules cannot use the
               same '[IPAddress, IPProtocol]' pair, and cannot have overlapping
               'portRange's.
               
               For internal forwarding rules within the same VPC network, two or more
               forwarding rules cannot use the same '[IPAddress, IPProtocol]' pair, and
               cannot have overlapping 'portRange's.
               
               @pattern: \\d+(?:-\\d+)?
        :param Sequence[_builtins.str] ports: The 'ports', 'portRange', and 'allPorts' fields are mutually exclusive.
               Only packets addressed to ports in the specified range will be forwarded
               to the backends configured with this forwarding rule.
               
               The 'ports' field has the following limitations:
               * It requires that the forwarding rule 'IPProtocol' be TCP, UDP, or SCTP,
               and
               * It's applicable only to the following products: internal passthrough
               Network Load Balancers, backend service-based external passthrough Network
               Load Balancers, and internal protocol forwarding.
               * You can specify a list of up to five ports by number, separated by
               commas. The ports can be contiguous or discontiguous.
               
               For external forwarding rules, two or more forwarding rules cannot use the
               same '[IPAddress, IPProtocol]' pair if they share at least one port
               number.
               
               For internal forwarding rules within the same VPC network, two or more
               forwarding rules cannot use the same '[IPAddress, IPProtocol]' pair if
               they share at least one port number.
               
               @pattern: \\d+(?:-\\d+)?
        :param _builtins.str project: The name of the project.
        :param _builtins.str psc_connection_id: The PSC connection id of the PSC Forwarding Rule.
        :param _builtins.str psc_connection_status: The PSC connection status of the PSC Forwarding Rule. Possible values: 'STATUS_UNSPECIFIED', 'PENDING', 'ACCEPTED', 'REJECTED', 'CLOSED'
        :param Mapping[str, _builtins.str] pulumi_labels: The combination of labels configured directly on the resource
                and default labels configured on the provider.
        :param _builtins.str region: The region you want to get the forwarding rules from.
               
               These arguments must be set in either the provider or the resource in order for the information to be queried.
        :param _builtins.str self_link: The URI of the resource.
        :param Sequence['GetForwardingRulesRuleServiceDirectoryRegistrationArgs'] service_directory_registrations: Service Directory resources to register this forwarding rule with.
               
               Currently, only supports a single Service Directory resource.
        :param _builtins.str service_label: An optional prefix to the service name for this Forwarding Rule.
               If specified, will be the first label of the fully qualified service
               name.
               
               The label must be 1-63 characters long, and comply with RFC1035.
               Specifically, the label must be 1-63 characters long and match the
               regular expression 'a-z?' which means the first
               character must be a lowercase letter, and all following characters
               must be a dash, lowercase letter, or digit, except the last
               character, which cannot be a dash.
               
               This field is only used for INTERNAL load balancing.
        :param _builtins.str service_name: The internal fully qualified service name for this Forwarding Rule.
               
               This field is only used for INTERNAL load balancing.
        :param Sequence[_builtins.str] source_ip_ranges: If not empty, this Forwarding Rule will only forward the traffic when the source IP address matches one of the IP addresses or CIDR ranges set here. Note that a Forwarding Rule can only have up to 64 source IP ranges, and this field can only be used with a regional Forwarding Rule whose scheme is EXTERNAL. Each sourceIpRange entry should be either an IP address (for example, 1.2.3.4) or a CIDR range (for example, 1.2.3.0/24).
        :param _builtins.str subnetwork: This field identifies the subnetwork that the load balanced IP should
               belong to for this Forwarding Rule, used in internal load balancing and
               network load balancing with IPv6.
               
               If the network specified is in auto subnet mode, this field is optional.
               However, a subnetwork must be specified if the network is in custom subnet
               mode or when creating external forwarding rule with IPv6.
        :param _builtins.str target: The URL of the target resource to receive the matched traffic.  For
               regional forwarding rules, this target must be in the same region as the
               forwarding rule. For global forwarding rules, this target must be a global
               load balancing resource.
               
               The forwarded traffic must be of a type appropriate to the target object.
               *  For load balancers, see the "Target" column in [Port specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
               
               For Private Service Connect forwarding rules that forward traffic to managed services, the target must be a service attachment.
        """
        pulumi.set(__self__, "all_ports", all_ports)
        pulumi.set(__self__, "allow_global_access", allow_global_access)
        pulumi.set(__self__, "allow_psc_global_access", allow_psc_global_access)
        pulumi.set(__self__, "backend_service", backend_service)
        pulumi.set(__self__, "base_forwarding_rule", base_forwarding_rule)
        pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "effective_labels", effective_labels)
        pulumi.set(__self__, "forwarding_rule_id", forwarding_rule_id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ip_collection", ip_collection)
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        pulumi.set(__self__, "ip_version", ip_version)
        pulumi.set(__self__, "is_mirroring_collector", is_mirroring_collector)
        pulumi.set(__self__, "label_fingerprint", label_fingerprint)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "load_balancing_scheme", load_balancing_scheme)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "network_tier", network_tier)
        pulumi.set(__self__, "no_automate_dns_zone", no_automate_dns_zone)
        pulumi.set(__self__, "port_range", port_range)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "psc_connection_id", psc_connection_id)
        pulumi.set(__self__, "psc_connection_status", psc_connection_status)
        pulumi.set(__self__, "pulumi_labels", pulumi_labels)
        pulumi.set(__self__, "recreate_closed_psc", recreate_closed_psc)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "self_link", self_link)
        pulumi.set(__self__, "service_directory_registrations", service_directory_registrations)
        pulumi.set(__self__, "service_label", service_label)
        pulumi.set(__self__, "service_name", service_name)
        pulumi.set(__self__, "source_ip_ranges", source_ip_ranges)
        pulumi.set(__self__, "subnetwork", subnetwork)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter(name="allPorts")
    def all_ports(self) -> _builtins.bool:
        """
        The 'ports', 'portRange', and 'allPorts' fields are mutually exclusive.
        Only packets addressed to ports in the specified range will be forwarded
        to the backends configured with this forwarding rule.

        The 'allPorts' field has the following limitations:
        * It requires that the forwarding rule 'IPProtocol' be TCP, UDP, SCTP, or
        L3_DEFAULT.
        * It's applicable only to the following products: internal passthrough
        Network Load Balancers, backend service-based external passthrough Network
        Load Balancers, and internal and external protocol forwarding.
        * Set this field to true to allow packets addressed to any port or packets
        lacking destination port information (for example, UDP fragments after the
        first fragment) to be forwarded to the backends configured with this
        forwarding rule. The L3_DEFAULT protocol requires 'allPorts' be set to
        true.
        """
        return pulumi.get(self, "all_ports")

    @_builtins.property
    @pulumi.getter(name="allowGlobalAccess")
    def allow_global_access(self) -> _builtins.bool:
        """
        This field is used along with the 'backend_service' field for
        internal load balancing or with the 'target' field for internal
        TargetInstance.

        If the field is set to 'TRUE', clients can access ILB from all
        regions.

        Otherwise only allows access from clients in the same region as the
        internal load balancer.
        """
        return pulumi.get(self, "allow_global_access")

    @_builtins.property
    @pulumi.getter(name="allowPscGlobalAccess")
    def allow_psc_global_access(self) -> _builtins.bool:
        """
        This is used in PSC consumer ForwardingRule to control whether the PSC endpoint can be accessed from another region.
        """
        return pulumi.get(self, "allow_psc_global_access")

    @_builtins.property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> _builtins.str:
        """
        Identifies the backend service to which the forwarding rule sends traffic.

        Required for Internal TCP/UDP Load Balancing and Network Load Balancing;
        must be omitted for all other load balancer types.
        """
        return pulumi.get(self, "backend_service")

    @_builtins.property
    @pulumi.getter(name="baseForwardingRule")
    def base_forwarding_rule(self) -> _builtins.str:
        """
        [Output Only] The URL for the corresponding base Forwarding Rule. By base Forwarding Rule, we mean the Forwarding Rule that has the same IP address, protocol, and port settings with the current Forwarding Rule, but without sourceIPRanges specified. Always empty if the current Forwarding Rule does not have sourceIPRanges specified.
        """
        return pulumi.get(self, "base_forwarding_rule")

    @_builtins.property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> _builtins.str:
        """
        Creation timestamp in RFC3339 text format.
        """
        return pulumi.get(self, "creation_timestamp")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        An optional description of this resource. Provide this property when
        you create the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="effectiveLabels")
    def effective_labels(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "effective_labels")

    @_builtins.property
    @pulumi.getter(name="forwardingRuleId")
    def forwarding_rule_id(self) -> _builtins.int:
        """
        The unique identifier number for the resource. This identifier is defined by the server.
        """
        return pulumi.get(self, "forwarding_rule_id")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        IP address for which this forwarding rule accepts traffic. When a client
        sends traffic to this IP address, the forwarding rule directs the traffic
        to the referenced 'target' or 'backendService'.

        While creating a forwarding rule, specifying an 'IPAddress' is
        required under the following circumstances:

        * When the 'target' is set to 'targetGrpcProxy' and
        'validateForProxyless' is set to 'true', the
        'IPAddress' should be set to '0.0.0.0'.
        * When the 'target' is a Private Service Connect Google APIs
        bundle, you must specify an 'IPAddress'.

        Otherwise, you can optionally specify an IP address that references an
        existing static (reserved) IP address resource. When omitted, Google Cloud
        assigns an ephemeral IP address.

        Use one of the following formats to specify an IP address while creating a
        forwarding rule:

        * IP address number, as in '100.1.2.3'
        * IPv6 address range, as in '2600:1234::/96'
        * Full resource URL, as in
        'https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name'
        * Partial URL or by name, as in:
          * 'projects/project_id/regions/region/addresses/address-name'
          * 'regions/region/addresses/address-name'
          * 'global/addresses/address-name'
          * 'address-name'

        The forwarding rule's 'target' or 'backendService',
        and in most cases, also the 'loadBalancingScheme', determine the
        type of IP address that you can use. For detailed information, see
        [IP address
        specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).

        When reading an 'IPAddress', the API always returns the IP
        address number.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="ipCollection")
    def ip_collection(self) -> _builtins.str:
        """
        Resource reference of a PublicDelegatedPrefix. The PDP must be a sub-PDP
        in EXTERNAL_IPV6_FORWARDING_RULE_CREATION mode.
        Use one of the following formats to specify a sub-PDP when creating an
        IPv6 NetLB forwarding rule using BYOIP:
        Full resource URL, as in:
          * 'https://www.googleapis.com/compute/v1/projects/{{projectId}}/regions/{{region}}/publicDelegatedPrefixes/{{sub-pdp-name}}'
        Partial URL, as in:
          * 'projects/{{projectId}}/regions/region/publicDelegatedPrefixes/{{sub-pdp-name}}'
          * 'regions/{{region}}/publicDelegatedPrefixes/{{sub-pdp-name}}'
        """
        return pulumi.get(self, "ip_collection")

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> _builtins.str:
        """
        The IP protocol to which this rule applies.

        For protocol forwarding, valid
        options are 'TCP', 'UDP', 'ESP',
        'AH', 'SCTP', 'ICMP' and
        'L3_DEFAULT'.

        The valid IP protocols are different for different load balancing products
        as described in [Load balancing
        features](https://cloud.google.com/load-balancing/docs/features#protocols_from_the_load_balancer_to_the_backends).

        A Forwarding Rule with protocol L3_DEFAULT can attach with target instance or
        backend service with UNSPECIFIED protocol.
        A forwarding rule with "L3_DEFAULT" IPProtocal cannot be attached to a backend service with TCP or UDP. Possible values: ["TCP", "UDP", "ESP", "AH", "SCTP", "ICMP", "L3_DEFAULT"]
        """
        return pulumi.get(self, "ip_protocol")

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> _builtins.str:
        """
        The IP address version that will be used by this forwarding rule.
        Valid options are IPV4 and IPV6.

        If not set, the IPv4 address will be used by default. Possible values: ["IPV4", "IPV6"]
        """
        return pulumi.get(self, "ip_version")

    @_builtins.property
    @pulumi.getter(name="isMirroringCollector")
    def is_mirroring_collector(self) -> _builtins.bool:
        """
        Indicates whether or not this load balancer can be used as a collector for
        packet mirroring. To prevent mirroring loops, instances behind this
        load balancer will not have their traffic mirrored even if a
        'PacketMirroring' rule applies to them.

        This can only be set to true for load balancers that have their
        'loadBalancingScheme' set to 'INTERNAL'.
        """
        return pulumi.get(self, "is_mirroring_collector")

    @_builtins.property
    @pulumi.getter(name="labelFingerprint")
    def label_fingerprint(self) -> _builtins.str:
        """
        The fingerprint used for optimistic locking of this resource.  Used
        internally during updates.
        """
        return pulumi.get(self, "label_fingerprint")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        Labels to apply to this forwarding rule.  A list of key->value pairs.


        **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        Please refer to the field 'effective_labels' for all of the labels present on the resource.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="loadBalancingScheme")
    def load_balancing_scheme(self) -> _builtins.str:
        """
        Specifies the forwarding rule type.

        Note that an empty string value ('""') is also supported for some use
        cases, for example PSC (private service connection) regional forwarding
        rules.

        For more information about forwarding rules, refer to
        [Forwarding rule concepts](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts). Default value: "EXTERNAL" Possible values: ["EXTERNAL", "EXTERNAL_MANAGED", "INTERNAL", "INTERNAL_MANAGED"]
        """
        return pulumi.get(self, "load_balancing_scheme")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the resource; provided by the client when the resource is created.
        The name must be 1-63 characters long, and comply with
        [RFC1035](https://www.ietf.org/rfc/rfc1035.txt).

        Specifically, the name must be 1-63 characters long and match the regular
        expression 'a-z?' which means the first
        character must be a lowercase letter, and all following characters must
        be a dash, lowercase letter, or digit, except the last character, which
        cannot be a dash.

        For Private Service Connect forwarding rules that forward traffic to Google
        APIs, the forwarding rule name must be a 1-20 characters string with
        lowercase letters and numbers and must start with a letter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        This field is not used for external load balancing.

        For Internal TCP/UDP Load Balancing, this field identifies the network that
        the load balanced IP should belong to for this Forwarding Rule.
        If the subnetwork is specified, the network of the subnetwork will be used.
        If neither subnetwork nor this field is specified, the default network will
        be used.

        For Private Service Connect forwarding rules that forward traffic to Google
        APIs, a network must be provided.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> _builtins.str:
        """
        This signifies the networking tier used for configuring
        this load balancer and can only take the following values:
        'PREMIUM', 'STANDARD'.

        For regional ForwardingRule, the valid values are 'PREMIUM' and
        'STANDARD'. For GlobalForwardingRule, the valid value is
        'PREMIUM'.

        If this field is not specified, it is assumed to be 'PREMIUM'.
        If 'IPAddress' is specified, this value must be equal to the
        networkTier of the Address. Possible values: ["PREMIUM", "STANDARD"]
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="noAutomateDnsZone")
    def no_automate_dns_zone(self) -> _builtins.bool:
        """
        This is used in PSC consumer ForwardingRule to control whether it should try to auto-generate a DNS zone or not. Non-PSC forwarding rules do not use this field.
        """
        return pulumi.get(self, "no_automate_dns_zone")

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> _builtins.str:
        """
        The 'ports', 'portRange', and 'allPorts' fields are mutually exclusive.
        Only packets addressed to ports in the specified range will be forwarded
        to the backends configured with this forwarding rule.

        The 'portRange' field has the following limitations:
        * It requires that the forwarding rule 'IPProtocol' be TCP, UDP, or SCTP,
        and
        * It's applicable only to the following products: external passthrough
        Network Load Balancers, internal and external proxy Network Load
        Balancers, internal and external Application Load Balancers, external
        protocol forwarding, and Classic VPN.
        * Some products have restrictions on what ports can be used. See
        [port specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#port_specifications)
        for details.

        For external forwarding rules, two or more forwarding rules cannot use the
        same '[IPAddress, IPProtocol]' pair, and cannot have overlapping
        'portRange's.

        For internal forwarding rules within the same VPC network, two or more
        forwarding rules cannot use the same '[IPAddress, IPProtocol]' pair, and
        cannot have overlapping 'portRange's.

        @pattern: \\d+(?:-\\d+)?
        """
        return pulumi.get(self, "port_range")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Sequence[_builtins.str]:
        """
        The 'ports', 'portRange', and 'allPorts' fields are mutually exclusive.
        Only packets addressed to ports in the specified range will be forwarded
        to the backends configured with this forwarding rule.

        The 'ports' field has the following limitations:
        * It requires that the forwarding rule 'IPProtocol' be TCP, UDP, or SCTP,
        and
        * It's applicable only to the following products: internal passthrough
        Network Load Balancers, backend service-based external passthrough Network
        Load Balancers, and internal protocol forwarding.
        * You can specify a list of up to five ports by number, separated by
        commas. The ports can be contiguous or discontiguous.

        For external forwarding rules, two or more forwarding rules cannot use the
        same '[IPAddress, IPProtocol]' pair if they share at least one port
        number.

        For internal forwarding rules within the same VPC network, two or more
        forwarding rules cannot use the same '[IPAddress, IPProtocol]' pair if
        they share at least one port number.

        @pattern: \\d+(?:-\\d+)?
        """
        return pulumi.get(self, "ports")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        The name of the project.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter(name="pscConnectionId")
    def psc_connection_id(self) -> _builtins.str:
        """
        The PSC connection id of the PSC Forwarding Rule.
        """
        return pulumi.get(self, "psc_connection_id")

    @_builtins.property
    @pulumi.getter(name="pscConnectionStatus")
    def psc_connection_status(self) -> _builtins.str:
        """
        The PSC connection status of the PSC Forwarding Rule. Possible values: 'STATUS_UNSPECIFIED', 'PENDING', 'ACCEPTED', 'REJECTED', 'CLOSED'
        """
        return pulumi.get(self, "psc_connection_status")

    @_builtins.property
    @pulumi.getter(name="pulumiLabels")
    def pulumi_labels(self) -> Mapping[str, _builtins.str]:
        """
        The combination of labels configured directly on the resource
         and default labels configured on the provider.
        """
        return pulumi.get(self, "pulumi_labels")

    @_builtins.property
    @pulumi.getter(name="recreateClosedPsc")
    def recreate_closed_psc(self) -> _builtins.bool:
        return pulumi.get(self, "recreate_closed_psc")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The region you want to get the forwarding rules from.

        These arguments must be set in either the provider or the resource in order for the information to be queried.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> _builtins.str:
        """
        The URI of the resource.
        """
        return pulumi.get(self, "self_link")

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryRegistrations")
    def service_directory_registrations(self) -> Sequence['outputs.GetForwardingRulesRuleServiceDirectoryRegistrationResult']:
        """
        Service Directory resources to register this forwarding rule with.

        Currently, only supports a single Service Directory resource.
        """
        return pulumi.get(self, "service_directory_registrations")

    @_builtins.property
    @pulumi.getter(name="serviceLabel")
    def service_label(self) -> _builtins.str:
        """
        An optional prefix to the service name for this Forwarding Rule.
        If specified, will be the first label of the fully qualified service
        name.

        The label must be 1-63 characters long, and comply with RFC1035.
        Specifically, the label must be 1-63 characters long and match the
        regular expression 'a-z?' which means the first
        character must be a lowercase letter, and all following characters
        must be a dash, lowercase letter, or digit, except the last
        character, which cannot be a dash.

        This field is only used for INTERNAL load balancing.
        """
        return pulumi.get(self, "service_label")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> _builtins.str:
        """
        The internal fully qualified service name for this Forwarding Rule.

        This field is only used for INTERNAL load balancing.
        """
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter(name="sourceIpRanges")
    def source_ip_ranges(self) -> Sequence[_builtins.str]:
        """
        If not empty, this Forwarding Rule will only forward the traffic when the source IP address matches one of the IP addresses or CIDR ranges set here. Note that a Forwarding Rule can only have up to 64 source IP ranges, and this field can only be used with a regional Forwarding Rule whose scheme is EXTERNAL. Each sourceIpRange entry should be either an IP address (for example, 1.2.3.4) or a CIDR range (for example, 1.2.3.0/24).
        """
        return pulumi.get(self, "source_ip_ranges")

    @_builtins.property
    @pulumi.getter
    def subnetwork(self) -> _builtins.str:
        """
        This field identifies the subnetwork that the load balanced IP should
        belong to for this Forwarding Rule, used in internal load balancing and
        network load balancing with IPv6.

        If the network specified is in auto subnet mode, this field is optional.
        However, a subnetwork must be specified if the network is in custom subnet
        mode or when creating external forwarding rule with IPv6.
        """
        return pulumi.get(self, "subnetwork")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        The URL of the target resource to receive the matched traffic.  For
        regional forwarding rules, this target must be in the same region as the
        forwarding rule. For global forwarding rules, this target must be a global
        load balancing resource.

        The forwarded traffic must be of a type appropriate to the target object.
        *  For load balancers, see the "Target" column in [Port specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).

        For Private Service Connect forwarding rules that forward traffic to managed services, the target must be a service attachment.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class GetForwardingRulesRuleServiceDirectoryRegistrationResult(dict):
    def __init__(__self__, *,
                 namespace: _builtins.str,
                 service: _builtins.str):
        """
        :param _builtins.str namespace: Service Directory namespace to register the forwarding rule under.
        :param _builtins.str service: Service Directory service to register the forwarding rule under.
        """
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Service Directory namespace to register the forwarding rule under.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        Service Directory service to register the forwarding rule under.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetGlobalForwardingRuleMetadataFilterResult(dict):
    def __init__(__self__, *,
                 filter_labels: Sequence['outputs.GetGlobalForwardingRuleMetadataFilterFilterLabelResult'],
                 filter_match_criteria: _builtins.str):
        """
        :param Sequence['GetGlobalForwardingRuleMetadataFilterFilterLabelArgs'] filter_labels: The list of label value pairs that must match labels in the
               provided metadata based on filterMatchCriteria
               
               This list must not be empty and can have at the most 64 entries.
        :param _builtins.str filter_match_criteria: Specifies how individual filterLabel matches within the list of
               filterLabels contribute towards the overall metadataFilter match.
               
               MATCH_ANY - At least one of the filterLabels must have a matching
               label in the provided metadata.
               MATCH_ALL - All filterLabels must have matching labels in the
               provided metadata. Possible values: ["MATCH_ANY", "MATCH_ALL"]
        """
        pulumi.set(__self__, "filter_labels", filter_labels)
        pulumi.set(__self__, "filter_match_criteria", filter_match_criteria)

    @_builtins.property
    @pulumi.getter(name="filterLabels")
    def filter_labels(self) -> Sequence['outputs.GetGlobalForwardingRuleMetadataFilterFilterLabelResult']:
        """
        The list of label value pairs that must match labels in the
        provided metadata based on filterMatchCriteria

        This list must not be empty and can have at the most 64 entries.
        """
        return pulumi.get(self, "filter_labels")

    @_builtins.property
    @pulumi.getter(name="filterMatchCriteria")
    def filter_match_criteria(self) -> _builtins.str:
        """
        Specifies how individual filterLabel matches within the list of
        filterLabels contribute towards the overall metadataFilter match.

        MATCH_ANY - At least one of the filterLabels must have a matching
        label in the provided metadata.
        MATCH_ALL - All filterLabels must have matching labels in the
        provided metadata. Possible values: ["MATCH_ANY", "MATCH_ALL"]
        """
        return pulumi.get(self, "filter_match_criteria")


@pulumi.output_type
class GetGlobalForwardingRuleMetadataFilterFilterLabelResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the global forwarding rule.
               
               - - -
        :param _builtins.str value: The value that the label must match. The value has a maximum
               length of 1024 characters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the global forwarding rule.

        - - -
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value that the label must match. The value has a maximum
        length of 1024 characters.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGlobalForwardingRuleServiceDirectoryRegistrationResult(dict):
    def __init__(__self__, *,
                 namespace: _builtins.str,
                 service_directory_region: _builtins.str):
        """
        :param _builtins.str namespace: Service Directory namespace to register the forwarding rule under.
        :param _builtins.str service_directory_region: [Optional] Service Directory region to register this global forwarding rule under.
               Default to "us-central1". Only used for PSC for Google APIs. All PSC for
               Google APIs Forwarding Rules on the same network should use the same Service
               Directory region.
        """
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "service_directory_region", service_directory_region)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Service Directory namespace to register the forwarding rule under.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryRegion")
    def service_directory_region(self) -> _builtins.str:
        """
        [Optional] Service Directory region to register this global forwarding rule under.
        Default to "us-central1". Only used for PSC for Google APIs. All PSC for
        Google APIs Forwarding Rules on the same network should use the same Service
        Directory region.
        """
        return pulumi.get(self, "service_directory_region")


@pulumi.output_type
class GetHcVpnGatewayVpnInterfaceResult(dict):
    def __init__(__self__, *,
                 id: _builtins.int,
                 interconnect_attachment: _builtins.str,
                 ip_address: _builtins.str):
        """
        :param _builtins.int id: The numeric ID of this VPN gateway interface.
        :param _builtins.str interconnect_attachment: URL of the interconnect attachment resource. When the value
               of this field is present, the VPN Gateway will be used for
               IPsec-encrypted Cloud Interconnect; all Egress or Ingress
               traffic for this VPN Gateway interface will go through the
               specified interconnect attachment resource.
               
               Not currently available publicly.
        :param _builtins.str ip_address: The external IP address for this VPN gateway interface.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "interconnect_attachment", interconnect_attachment)
        pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The numeric ID of this VPN gateway interface.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="interconnectAttachment")
    def interconnect_attachment(self) -> _builtins.str:
        """
        URL of the interconnect attachment resource. When the value
        of this field is present, the VPN Gateway will be used for
        IPsec-encrypted Cloud Interconnect; all Egress or Ingress
        traffic for this VPN Gateway interface will go through the
        specified interconnect attachment resource.

        Not currently available publicly.
        """
        return pulumi.get(self, "interconnect_attachment")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        The external IP address for this VPN gateway interface.
        """
        return pulumi.get(self, "ip_address")


@pulumi.output_type
class GetHealthCheckGrpcHealthCheckResult(dict):
    def __init__(__self__, *,
                 grpc_service_name: _builtins.str,
                 port: _builtins.int,
                 port_name: _builtins.str,
                 port_specification: _builtins.str):
        """
        :param _builtins.str grpc_service_name: The gRPC service name for the health check.
               The value of grpcServiceName has the following meanings by convention:
                 - Empty serviceName means the overall status of all services at the backend.
                 - Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
               The grpcServiceName can only be ASCII.
        :param _builtins.int port: The port number for the health check request.
               Must be specified if portName and portSpecification are not set
               or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               
                 * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
               
                 * 'USE_NAMED_PORT': The 'portName' is used for health checking.
               
                 * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
                 network endpoint is used for health checking. For other backends, the
                 port or named port specified in the Backend Service is used for health
                 checking.
               
               If not specified, gRPC health check follows behavior specified in 'port' and
               'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        """
        pulumi.set(__self__, "grpc_service_name", grpc_service_name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_name", port_name)
        pulumi.set(__self__, "port_specification", port_specification)

    @_builtins.property
    @pulumi.getter(name="grpcServiceName")
    def grpc_service_name(self) -> _builtins.str:
        """
        The gRPC service name for the health check.
        The value of grpcServiceName has the following meanings by convention:
          - Empty serviceName means the overall status of all services at the backend.
          - Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
        The grpcServiceName can only be ASCII.
        """
        return pulumi.get(self, "grpc_service_name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port number for the health check request.
        Must be specified if portName and portSpecification are not set
        or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> _builtins.str:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> _builtins.str:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:

          * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.

          * 'USE_NAMED_PORT': The 'portName' is used for health checking.

          * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
          network endpoint is used for health checking. For other backends, the
          port or named port specified in the Backend Service is used for health
          checking.

        If not specified, gRPC health check follows behavior specified in 'port' and
        'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        """
        return pulumi.get(self, "port_specification")


@pulumi.output_type
class GetHealthCheckGrpcTlsHealthCheckResult(dict):
    def __init__(__self__, *,
                 grpc_service_name: _builtins.str,
                 port: _builtins.int,
                 port_specification: _builtins.str):
        """
        :param _builtins.str grpc_service_name: The gRPC service name for the health check.
               The value of grpcServiceName has the following meanings by convention:
                 - Empty serviceName means the overall status of all services at the backend.
                 - Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
               The grpcServiceName can only be ASCII.
        :param _builtins.int port: The port number for the health check request.
               Must be specified if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               
                 * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
               
                 * 'USE_NAMED_PORT': Not supported for GRPC with TLS health checking.
               
                 * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
                 network endpoint is used for health checking. For other backends, the
                 port or named port specified in the Backend Service is used for health
                 checking.
               
               If not specified, gRPC with TLS health check follows behavior specified in the 'port' field. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        """
        pulumi.set(__self__, "grpc_service_name", grpc_service_name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_specification", port_specification)

    @_builtins.property
    @pulumi.getter(name="grpcServiceName")
    def grpc_service_name(self) -> _builtins.str:
        """
        The gRPC service name for the health check.
        The value of grpcServiceName has the following meanings by convention:
          - Empty serviceName means the overall status of all services at the backend.
          - Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
        The grpcServiceName can only be ASCII.
        """
        return pulumi.get(self, "grpc_service_name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port number for the health check request.
        Must be specified if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> _builtins.str:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:

          * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.

          * 'USE_NAMED_PORT': Not supported for GRPC with TLS health checking.

          * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
          network endpoint is used for health checking. For other backends, the
          port or named port specified in the Backend Service is used for health
          checking.

        If not specified, gRPC with TLS health check follows behavior specified in the 'port' field. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        """
        return pulumi.get(self, "port_specification")


@pulumi.output_type
class GetHealthCheckHttp2HealthCheckResult(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 port: _builtins.int,
                 port_name: _builtins.str,
                 port_specification: _builtins.str,
                 proxy_header: _builtins.str,
                 request_path: _builtins.str,
                 response: _builtins.str):
        """
        :param _builtins.str host: The value of the host header in the HTTP2 health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param _builtins.int port: The TCP port number for the HTTP2 health check request.
               The default value is 443.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               
                 * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
               
                 * 'USE_NAMED_PORT': The 'portName' is used for health checking.
               
                 * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
                 network endpoint is used for health checking. For other backends, the
                 port or named port specified in the Backend Service is used for health
                 checking.
               
               If not specified, HTTP2 health check follows behavior specified in 'port' and
               'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
        :param _builtins.str request_path: The request path of the HTTP2 health check request.
               The default value is /.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_name", port_name)
        pulumi.set(__self__, "port_specification", port_specification)
        pulumi.set(__self__, "proxy_header", proxy_header)
        pulumi.set(__self__, "request_path", request_path)
        pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The value of the host header in the HTTP2 health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The TCP port number for the HTTP2 health check request.
        The default value is 443.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> _builtins.str:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> _builtins.str:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:

          * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.

          * 'USE_NAMED_PORT': The 'portName' is used for health checking.

          * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
          network endpoint is used for health checking. For other backends, the
          port or named port specified in the Backend Service is used for health
          checking.

        If not specified, HTTP2 health check follows behavior specified in 'port' and
        'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> _builtins.str:
        """
        Specifies the type of proxy header to append before sending data to the
        backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> _builtins.str:
        """
        The request path of the HTTP2 health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @_builtins.property
    @pulumi.getter
    def response(self) -> _builtins.str:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class GetHealthCheckHttpHealthCheckResult(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 port: _builtins.int,
                 port_name: _builtins.str,
                 port_specification: _builtins.str,
                 proxy_header: _builtins.str,
                 request_path: _builtins.str,
                 response: _builtins.str):
        """
        :param _builtins.str host: The value of the host header in the HTTP health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param _builtins.int port: The TCP port number for the HTTP health check request.
               The default value is 80.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               
                 * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
               
                 * 'USE_NAMED_PORT': The 'portName' is used for health checking.
               
                 * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
                 network endpoint is used for health checking. For other backends, the
                 port or named port specified in the Backend Service is used for health
                 checking.
               
               If not specified, HTTP health check follows behavior specified in 'port' and
               'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
        :param _builtins.str request_path: The request path of the HTTP health check request.
               The default value is /.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_name", port_name)
        pulumi.set(__self__, "port_specification", port_specification)
        pulumi.set(__self__, "proxy_header", proxy_header)
        pulumi.set(__self__, "request_path", request_path)
        pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The value of the host header in the HTTP health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The TCP port number for the HTTP health check request.
        The default value is 80.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> _builtins.str:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> _builtins.str:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:

          * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.

          * 'USE_NAMED_PORT': The 'portName' is used for health checking.

          * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
          network endpoint is used for health checking. For other backends, the
          port or named port specified in the Backend Service is used for health
          checking.

        If not specified, HTTP health check follows behavior specified in 'port' and
        'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> _builtins.str:
        """
        Specifies the type of proxy header to append before sending data to the
        backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> _builtins.str:
        """
        The request path of the HTTP health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @_builtins.property
    @pulumi.getter
    def response(self) -> _builtins.str:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class GetHealthCheckHttpsHealthCheckResult(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 port: _builtins.int,
                 port_name: _builtins.str,
                 port_specification: _builtins.str,
                 proxy_header: _builtins.str,
                 request_path: _builtins.str,
                 response: _builtins.str):
        """
        :param _builtins.str host: The value of the host header in the HTTPS health check request.
               If left empty (default value), the public IP on behalf of which this health
               check is performed will be used.
        :param _builtins.int port: The TCP port number for the HTTPS health check request.
               The default value is 443.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               
                 * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
               
                 * 'USE_NAMED_PORT': The 'portName' is used for health checking.
               
                 * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
                 network endpoint is used for health checking. For other backends, the
                 port or named port specified in the Backend Service is used for health
                 checking.
               
               If not specified, HTTPS health check follows behavior specified in 'port' and
               'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
        :param _builtins.str request_path: The request path of the HTTPS health check request.
               The default value is /.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_name", port_name)
        pulumi.set(__self__, "port_specification", port_specification)
        pulumi.set(__self__, "proxy_header", proxy_header)
        pulumi.set(__self__, "request_path", request_path)
        pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The value of the host header in the HTTPS health check request.
        If left empty (default value), the public IP on behalf of which this health
        check is performed will be used.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The TCP port number for the HTTPS health check request.
        The default value is 443.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> _builtins.str:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> _builtins.str:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:

          * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.

          * 'USE_NAMED_PORT': The 'portName' is used for health checking.

          * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
          network endpoint is used for health checking. For other backends, the
          port or named port specified in the Backend Service is used for health
          checking.

        If not specified, HTTPS health check follows behavior specified in 'port' and
        'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> _builtins.str:
        """
        Specifies the type of proxy header to append before sending data to the
        backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter(name="requestPath")
    def request_path(self) -> _builtins.str:
        """
        The request path of the HTTPS health check request.
        The default value is /.
        """
        return pulumi.get(self, "request_path")

    @_builtins.property
    @pulumi.getter
    def response(self) -> _builtins.str:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class GetHealthCheckLogConfigResult(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool):
        """
        :param _builtins.bool enable: Indicates whether or not to export logs. This is false by default,
               which means no health check logging will be done.
        """
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Indicates whether or not to export logs. This is false by default,
        which means no health check logging will be done.
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class GetHealthCheckSslHealthCheckResult(dict):
    def __init__(__self__, *,
                 port: _builtins.int,
                 port_name: _builtins.str,
                 port_specification: _builtins.str,
                 proxy_header: _builtins.str,
                 request: _builtins.str,
                 response: _builtins.str):
        """
        :param _builtins.int port: The TCP port number for the SSL health check request.
               The default value is 443.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               
                 * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
               
                 * 'USE_NAMED_PORT': The 'portName' is used for health checking.
               
                 * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
                 network endpoint is used for health checking. For other backends, the
                 port or named port specified in the Backend Service is used for health
                 checking.
               
               If not specified, SSL health check follows behavior specified in 'port' and
               'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
        :param _builtins.str request: The application data to send once the SSL connection has been
               established (default value is empty). If both request and response are
               empty, the connection establishment alone will indicate health. The request
               data can only be ASCII.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_name", port_name)
        pulumi.set(__self__, "port_specification", port_specification)
        pulumi.set(__self__, "proxy_header", proxy_header)
        pulumi.set(__self__, "request", request)
        pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The TCP port number for the SSL health check request.
        The default value is 443.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> _builtins.str:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> _builtins.str:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:

          * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.

          * 'USE_NAMED_PORT': The 'portName' is used for health checking.

          * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
          network endpoint is used for health checking. For other backends, the
          port or named port specified in the Backend Service is used for health
          checking.

        If not specified, SSL health check follows behavior specified in 'port' and
        'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> _builtins.str:
        """
        Specifies the type of proxy header to append before sending data to the
        backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter
    def request(self) -> _builtins.str:
        """
        The application data to send once the SSL connection has been
        established (default value is empty). If both request and response are
        empty, the connection establishment alone will indicate health. The request
        data can only be ASCII.
        """
        return pulumi.get(self, "request")

    @_builtins.property
    @pulumi.getter
    def response(self) -> _builtins.str:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class GetHealthCheckTcpHealthCheckResult(dict):
    def __init__(__self__, *,
                 port: _builtins.int,
                 port_name: _builtins.str,
                 port_specification: _builtins.str,
                 proxy_header: _builtins.str,
                 request: _builtins.str,
                 response: _builtins.str):
        """
        :param _builtins.int port: The TCP port number for the TCP health check request.
               The default value is 443.
        :param _builtins.str port_name: Port name as defined in InstanceGroup#NamedPort#name. If both port and
               port_name are defined, port takes precedence.
        :param _builtins.str port_specification: Specifies how port is selected for health checking, can be one of the
               following values:
               
                 * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
               
                 * 'USE_NAMED_PORT': The 'portName' is used for health checking.
               
                 * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
                 network endpoint is used for health checking. For other backends, the
                 port or named port specified in the Backend Service is used for health
                 checking.
               
               If not specified, TCP health check follows behavior specified in 'port' and
               'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        :param _builtins.str proxy_header: Specifies the type of proxy header to append before sending data to the
               backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
        :param _builtins.str request: The application data to send once the TCP connection has been
               established (default value is empty). If both request and response are
               empty, the connection establishment alone will indicate health. The request
               data can only be ASCII.
        :param _builtins.str response: The bytes to match against the beginning of the response data. If left empty
               (the default value), any response will indicate health. The response data
               can only be ASCII.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_name", port_name)
        pulumi.set(__self__, "port_specification", port_specification)
        pulumi.set(__self__, "proxy_header", proxy_header)
        pulumi.set(__self__, "request", request)
        pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The TCP port number for the TCP health check request.
        The default value is 443.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> _builtins.str:
        """
        Port name as defined in InstanceGroup#NamedPort#name. If both port and
        port_name are defined, port takes precedence.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="portSpecification")
    def port_specification(self) -> _builtins.str:
        """
        Specifies how port is selected for health checking, can be one of the
        following values:

          * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.

          * 'USE_NAMED_PORT': The 'portName' is used for health checking.

          * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
          network endpoint is used for health checking. For other backends, the
          port or named port specified in the Backend Service is used for health
          checking.

        If not specified, TCP health check follows behavior specified in 'port' and
        'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
        """
        return pulumi.get(self, "port_specification")

    @_builtins.property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> _builtins.str:
        """
        Specifies the type of proxy header to append before sending data to the
        backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
        """
        return pulumi.get(self, "proxy_header")

    @_builtins.property
    @pulumi.getter
    def request(self) -> _builtins.str:
        """
        The application data to send once the TCP connection has been
        established (default value is empty). If both request and response are
        empty, the connection establishment alone will indicate health. The request
        data can only be ASCII.
        """
        return pulumi.get(self, "request")

    @_builtins.property
    @pulumi.getter
    def response(self) -> _builtins.str:
        """
        The bytes to match against the beginning of the response data. If left empty
        (the default value), any response will indicate health. The response data
        can only be ASCII.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class GetImagesImageResult(dict):
    def __init__(__self__, *,
                 archive_size_bytes: _builtins.int,
                 creation_timestamp: _builtins.str,
                 description: _builtins.str,
                 disk_size_gb: _builtins.int,
                 family: _builtins.str,
                 image_id: _builtins.int,
                 labels: Mapping[str, _builtins.str],
                 name: _builtins.str,
                 self_link: _builtins.str,
                 source_disk: _builtins.str,
                 source_disk_id: _builtins.str,
                 source_image_id: _builtins.str):
        """
        :param _builtins.int archive_size_bytes: The size of the image tar.gz archive stored in Google Cloud Storage in bytes.
        :param _builtins.str creation_timestamp: The creation timestamp in RFC3339 text format.
        :param _builtins.str description: An optional description of this image.
        :param _builtins.int disk_size_gb: The size of the image when restored onto a persistent disk in gigabytes.
        :param _builtins.str family: The family name of the image.
        :param Mapping[str, _builtins.str] labels: All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
        :param _builtins.str name: The name of the image.
        :param _builtins.str self_link: The URI of the image.
        :param _builtins.str source_disk: The URL of the source disk used to create this image.
        :param _builtins.str source_disk_id: The ID value of the disk used to create this image.
        :param _builtins.str source_image_id: The ID value of the image used to create this image.
        """
        pulumi.set(__self__, "archive_size_bytes", archive_size_bytes)
        pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "self_link", self_link)
        pulumi.set(__self__, "source_disk", source_disk)
        pulumi.set(__self__, "source_disk_id", source_disk_id)
        pulumi.set(__self__, "source_image_id", source_image_id)

    @_builtins.property
    @pulumi.getter(name="archiveSizeBytes")
    def archive_size_bytes(self) -> _builtins.int:
        """
        The size of the image tar.gz archive stored in Google Cloud Storage in bytes.
        """
        return pulumi.get(self, "archive_size_bytes")

    @_builtins.property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> _builtins.str:
        """
        The creation timestamp in RFC3339 text format.
        """
        return pulumi.get(self, "creation_timestamp")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        An optional description of this image.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.int:
        """
        The size of the image when restored onto a persistent disk in gigabytes.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter
    def family(self) -> _builtins.str:
        """
        The family name of the image.
        """
        return pulumi.get(self, "family")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> _builtins.int:
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the image.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> _builtins.str:
        """
        The URI of the image.
        """
        return pulumi.get(self, "self_link")

    @_builtins.property
    @pulumi.getter(name="sourceDisk")
    def source_disk(self) -> _builtins.str:
        """
        The URL of the source disk used to create this image.
        """
        return pulumi.get(self, "source_disk")

    @_builtins.property
    @pulumi.getter(name="sourceDiskId")
    def source_disk_id(self) -> _builtins.str:
        """
        The ID value of the disk used to create this image.
        """
        return pulumi.get(self, "source_disk_id")

    @_builtins.property
    @pulumi.getter(name="sourceImageId")
    def source_image_id(self) -> _builtins.str:
        """
        The ID value of the image used to create this image.
        """
        return pulumi.get(self, "source_image_id")


@pulumi.output_type
class GetInstanceAdvancedMachineFeatureResult(dict):
    def __init__(__self__, *,
                 enable_nested_virtualization: _builtins.bool,
                 enable_uefi_networking: _builtins.bool,
                 performance_monitoring_unit: _builtins.str,
                 threads_per_core: _builtins.int,
                 turbo_mode: _builtins.str,
                 visible_core_count: _builtins.int):
        """
        :param _builtins.bool enable_nested_virtualization: Whether to enable nested virtualization or not.
        :param _builtins.bool enable_uefi_networking: Whether to enable UEFI networking for the instance.
        :param _builtins.str performance_monitoring_unit: The PMU is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are "STANDARD", "ENHANCED", and "ARCHITECTURAL".
        :param _builtins.int threads_per_core: The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
        :param _builtins.str turbo_mode: Turbo frequency mode to use for the instance. Currently supported modes is "ALL_CORE_MAX".
        :param _builtins.int visible_core_count: The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance\\'s nominal CPU count and the underlying platform\\'s SMT width.
        """
        pulumi.set(__self__, "enable_nested_virtualization", enable_nested_virtualization)
        pulumi.set(__self__, "enable_uefi_networking", enable_uefi_networking)
        pulumi.set(__self__, "performance_monitoring_unit", performance_monitoring_unit)
        pulumi.set(__self__, "threads_per_core", threads_per_core)
        pulumi.set(__self__, "turbo_mode", turbo_mode)
        pulumi.set(__self__, "visible_core_count", visible_core_count)

    @_builtins.property
    @pulumi.getter(name="enableNestedVirtualization")
    def enable_nested_virtualization(self) -> _builtins.bool:
        """
        Whether to enable nested virtualization or not.
        """
        return pulumi.get(self, "enable_nested_virtualization")

    @_builtins.property
    @pulumi.getter(name="enableUefiNetworking")
    def enable_uefi_networking(self) -> _builtins.bool:
        """
        Whether to enable UEFI networking for the instance.
        """
        return pulumi.get(self, "enable_uefi_networking")

    @_builtins.property
    @pulumi.getter(name="performanceMonitoringUnit")
    def performance_monitoring_unit(self) -> _builtins.str:
        """
        The PMU is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are "STANDARD", "ENHANCED", and "ARCHITECTURAL".
        """
        return pulumi.get(self, "performance_monitoring_unit")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> _builtins.int:
        """
        The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
        """
        return pulumi.get(self, "threads_per_core")

    @_builtins.property
    @pulumi.getter(name="turboMode")
    def turbo_mode(self) -> _builtins.str:
        """
        Turbo frequency mode to use for the instance. Currently supported modes is "ALL_CORE_MAX".
        """
        return pulumi.get(self, "turbo_mode")

    @_builtins.property
    @pulumi.getter(name="visibleCoreCount")
    def visible_core_count(self) -> _builtins.int:
        """
        The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance\\'s nominal CPU count and the underlying platform\\'s SMT width.
        """
        return pulumi.get(self, "visible_core_count")


@pulumi.output_type
class GetInstanceAttachedDiskResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 disk_encryption_key_raw: _builtins.str,
                 disk_encryption_key_rsa: _builtins.str,
                 disk_encryption_key_sha256: _builtins.str,
                 disk_encryption_service_account: _builtins.str,
                 force_attach: _builtins.bool,
                 kms_key_self_link: _builtins.str,
                 mode: _builtins.str,
                 source: _builtins.str):
        """
        :param _builtins.str device_name: Name with which the attached disk is accessible
               under `/dev/disk/by-id/`
        :param _builtins.str disk_encryption_key_raw: A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        :param _builtins.str disk_encryption_key_rsa: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        :param _builtins.str disk_encryption_key_sha256: The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               encoded SHA-256 hash of the [customer-supplied encryption key]
               (<https://cloud.google.com/compute/docs/disks/customer-supplied-encryption>) that protects this resource.
        :param _builtins.str disk_encryption_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
        :param _builtins.bool force_attach: Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        :param _builtins.str kms_key_self_link: The self_link of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        :param _builtins.str mode: Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
        :param _builtins.str source: The self_link of the disk attached to this instance.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        pulumi.set(__self__, "disk_encryption_key_rsa", disk_encryption_key_rsa)
        pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        pulumi.set(__self__, "disk_encryption_service_account", disk_encryption_service_account)
        pulumi.set(__self__, "force_attach", force_attach)
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Name with which the attached disk is accessible
        under `/dev/disk/by-id/`
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> _builtins.str:
        """
        A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        """
        return pulumi.get(self, "disk_encryption_key_raw")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRsa")
    def disk_encryption_key_rsa(self) -> _builtins.str:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        """
        return pulumi.get(self, "disk_encryption_key_rsa")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> _builtins.str:
        """
        The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        encoded SHA-256 hash of the [customer-supplied encryption key]
        (<https://cloud.google.com/compute/docs/disks/customer-supplied-encryption>) that protects this resource.
        """
        return pulumi.get(self, "disk_encryption_key_sha256")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionServiceAccount")
    def disk_encryption_service_account(self) -> _builtins.str:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
        """
        return pulumi.get(self, "disk_encryption_service_account")

    @_builtins.property
    @pulumi.getter(name="forceAttach")
    def force_attach(self) -> _builtins.bool:
        """
        Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        """
        return pulumi.get(self, "force_attach")

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self_link of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_rsa and disk_encryption_key_raw may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The self_link of the disk attached to this instance.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class GetInstanceBootDiskResult(dict):
    def __init__(__self__, *,
                 auto_delete: _builtins.bool,
                 device_name: _builtins.str,
                 disk_encryption_key_raw: _builtins.str,
                 disk_encryption_key_rsa: _builtins.str,
                 disk_encryption_key_sha256: _builtins.str,
                 disk_encryption_service_account: _builtins.str,
                 force_attach: _builtins.bool,
                 guest_os_features: Sequence[_builtins.str],
                 initialize_params: Sequence['outputs.GetInstanceBootDiskInitializeParamResult'],
                 interface: _builtins.str,
                 kms_key_self_link: _builtins.str,
                 mode: _builtins.str,
                 source: _builtins.str):
        """
        :param _builtins.bool auto_delete: Whether the disk will be auto-deleted when the instance is deleted.
        :param _builtins.str device_name: Name with which the attached disk is accessible
               under `/dev/disk/by-id/`
        :param _builtins.str disk_encryption_key_raw: A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        :param _builtins.str disk_encryption_key_rsa: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        :param _builtins.str disk_encryption_key_sha256: The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
               encoded SHA-256 hash of the [customer-supplied encryption key]
               (<https://cloud.google.com/compute/docs/disks/customer-supplied-encryption>) that protects this resource.
        :param _builtins.str disk_encryption_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
        :param _builtins.bool force_attach: Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        :param Sequence[_builtins.str] guest_os_features: A list of features to enable on the guest operating system. Applicable only for bootable images.
        :param Sequence['GetInstanceBootDiskInitializeParamArgs'] initialize_params: Parameters with which a disk was created alongside the instance.
               Structure is documented below.
        :param _builtins.str interface: The disk interface used for attaching this disk. One of `SCSI` or `NVME`.
        :param _builtins.str kms_key_self_link: The self_link of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        :param _builtins.str mode: Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
        :param _builtins.str source: The self_link of the disk attached to this instance.
        """
        pulumi.set(__self__, "auto_delete", auto_delete)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_encryption_key_raw", disk_encryption_key_raw)
        pulumi.set(__self__, "disk_encryption_key_rsa", disk_encryption_key_rsa)
        pulumi.set(__self__, "disk_encryption_key_sha256", disk_encryption_key_sha256)
        pulumi.set(__self__, "disk_encryption_service_account", disk_encryption_service_account)
        pulumi.set(__self__, "force_attach", force_attach)
        pulumi.set(__self__, "guest_os_features", guest_os_features)
        pulumi.set(__self__, "initialize_params", initialize_params)
        pulumi.set(__self__, "interface", interface)
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> _builtins.bool:
        """
        Whether the disk will be auto-deleted when the instance is deleted.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Name with which the attached disk is accessible
        under `/dev/disk/by-id/`
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRaw")
    def disk_encryption_key_raw(self) -> _builtins.str:
        """
        A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        """
        return pulumi.get(self, "disk_encryption_key_raw")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyRsa")
    def disk_encryption_key_rsa(self) -> _builtins.str:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        """
        return pulumi.get(self, "disk_encryption_key_rsa")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeySha256")
    def disk_encryption_key_sha256(self) -> _builtins.str:
        """
        The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
        encoded SHA-256 hash of the [customer-supplied encryption key]
        (<https://cloud.google.com/compute/docs/disks/customer-supplied-encryption>) that protects this resource.
        """
        return pulumi.get(self, "disk_encryption_key_sha256")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionServiceAccount")
    def disk_encryption_service_account(self) -> _builtins.str:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
        """
        return pulumi.get(self, "disk_encryption_service_account")

    @_builtins.property
    @pulumi.getter(name="forceAttach")
    def force_attach(self) -> _builtins.bool:
        """
        Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
        """
        return pulumi.get(self, "force_attach")

    @_builtins.property
    @pulumi.getter(name="guestOsFeatures")
    def guest_os_features(self) -> Sequence[_builtins.str]:
        """
        A list of features to enable on the guest operating system. Applicable only for bootable images.
        """
        return pulumi.get(self, "guest_os_features")

    @_builtins.property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Sequence['outputs.GetInstanceBootDiskInitializeParamResult']:
        """
        Parameters with which a disk was created alongside the instance.
        Structure is documented below.
        """
        return pulumi.get(self, "initialize_params")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> _builtins.str:
        """
        The disk interface used for attaching this disk. One of `SCSI` or `NVME`.
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self_link of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, disk_encryption_key_raw and disk_encryption_key_rsa may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The self_link of the disk attached to this instance.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class GetInstanceBootDiskInitializeParamResult(dict):
    def __init__(__self__, *,
                 architecture: _builtins.str,
                 enable_confidential_compute: _builtins.bool,
                 image: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 provisioned_iops: _builtins.int,
                 provisioned_throughput: _builtins.int,
                 resource_manager_tags: Mapping[str, _builtins.str],
                 resource_policies: Sequence[_builtins.str],
                 size: _builtins.int,
                 snapshot: _builtins.str,
                 source_image_encryption_keys: Sequence['outputs.GetInstanceBootDiskInitializeParamSourceImageEncryptionKeyResult'],
                 source_snapshot_encryption_keys: Sequence['outputs.GetInstanceBootDiskInitializeParamSourceSnapshotEncryptionKeyResult'],
                 storage_pool: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str architecture: The architecture of the disk. One of "X86_64" or "ARM64".
        :param _builtins.bool enable_confidential_compute: A flag to enable confidential compute mode on boot disk
        :param _builtins.str image: The image from which this disk was initialised.
        :param Mapping[str, _builtins.str] labels: A set of key/value label pairs assigned to the disk.
        :param _builtins.int provisioned_iops: Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle.
        :param _builtins.int provisioned_throughput: Indicates how much throughput to provision for the disk. This sets the number of throughput mb per second that the disk can handle.
        :param Mapping[str, _builtins.str] resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        :param Sequence[_builtins.str] resource_policies: A list of self_links to resource policies attached to the selected `boot_disk`
        :param _builtins.int size: The size of the image in gigabytes.
        :param _builtins.str snapshot: The snapshot from which this disk was initialised.
        :param Sequence['GetInstanceBootDiskInitializeParamSourceImageEncryptionKeyArgs'] source_image_encryption_keys: The encryption key used to decrypt the source image.
        :param Sequence['GetInstanceBootDiskInitializeParamSourceSnapshotEncryptionKeyArgs'] source_snapshot_encryption_keys: The encryption key used to decrypt the source snapshot.
        :param _builtins.str storage_pool: The URL of the storage pool in which the new disk is created
        :param _builtins.str type: The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "architecture", architecture)
        pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "provisioned_iops", provisioned_iops)
        pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)
        pulumi.set(__self__, "resource_policies", resource_policies)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "snapshot", snapshot)
        pulumi.set(__self__, "source_image_encryption_keys", source_image_encryption_keys)
        pulumi.set(__self__, "source_snapshot_encryption_keys", source_snapshot_encryption_keys)
        pulumi.set(__self__, "storage_pool", storage_pool)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def architecture(self) -> _builtins.str:
        """
        The architecture of the disk. One of "X86_64" or "ARM64".
        """
        return pulumi.get(self, "architecture")

    @_builtins.property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> _builtins.bool:
        """
        A flag to enable confidential compute mode on boot disk
        """
        return pulumi.get(self, "enable_confidential_compute")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        """
        The image from which this disk was initialised.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        A set of key/value label pairs assigned to the disk.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="provisionedIops")
    def provisioned_iops(self) -> _builtins.int:
        """
        Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle.
        """
        return pulumi.get(self, "provisioned_iops")

    @_builtins.property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> _builtins.int:
        """
        Indicates how much throughput to provision for the disk. This sets the number of throughput mb per second that the disk can handle.
        """
        return pulumi.get(self, "provisioned_throughput")

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        return pulumi.get(self, "resource_manager_tags")

    @_builtins.property
    @pulumi.getter(name="resourcePolicies")
    def resource_policies(self) -> Sequence[_builtins.str]:
        """
        A list of self_links to resource policies attached to the selected `boot_disk`
        """
        return pulumi.get(self, "resource_policies")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The size of the image in gigabytes.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> _builtins.str:
        """
        The snapshot from which this disk was initialised.
        """
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter(name="sourceImageEncryptionKeys")
    def source_image_encryption_keys(self) -> Sequence['outputs.GetInstanceBootDiskInitializeParamSourceImageEncryptionKeyResult']:
        """
        The encryption key used to decrypt the source image.
        """
        return pulumi.get(self, "source_image_encryption_keys")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshotEncryptionKeys")
    def source_snapshot_encryption_keys(self) -> Sequence['outputs.GetInstanceBootDiskInitializeParamSourceSnapshotEncryptionKeyResult']:
        """
        The encryption key used to decrypt the source snapshot.
        """
        return pulumi.get(self, "source_snapshot_encryption_keys")

    @_builtins.property
    @pulumi.getter(name="storagePool")
    def storage_pool(self) -> _builtins.str:
        """
        The URL of the storage pool in which the new disk is created
        """
        return pulumi.get(self, "storage_pool")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceBootDiskInitializeParamSourceImageEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 raw_key: _builtins.str,
                 rsa_encrypted_key: _builtins.str,
                 sha256: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str sha256: The SHA256 hash of the encryption key used to encrypt this disk.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> _builtins.str:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> _builtins.str:
        """
        The SHA256 hash of the encryption key used to encrypt this disk.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class GetInstanceBootDiskInitializeParamSourceSnapshotEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 raw_key: _builtins.str,
                 rsa_encrypted_key: _builtins.str,
                 sha256: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str sha256: The SHA256 hash of the encryption key used to encrypt this disk.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> _builtins.str:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> _builtins.str:
        """
        The SHA256 hash of the encryption key used to encrypt this disk.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class GetInstanceConfidentialInstanceConfigResult(dict):
    def __init__(__self__, *,
                 confidential_instance_type: _builtins.str,
                 enable_confidential_compute: _builtins.bool):
        """
        :param _builtins.str confidential_instance_type: The confidential computing technology the instance uses.
               								SEV is an AMD feature. TDX is an Intel feature. One of the following
               								values is required: SEV, SEV_SNP, TDX. If SEV_SNP, min_cpu_platform =
               								"AMD Milan" is currently required.
        :param _builtins.bool enable_confidential_compute: Defines whether the instance should have confidential compute enabled. Field will be deprecated in a future release
        """
        pulumi.set(__self__, "confidential_instance_type", confidential_instance_type)
        pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @_builtins.property
    @pulumi.getter(name="confidentialInstanceType")
    def confidential_instance_type(self) -> _builtins.str:
        """
        The confidential computing technology the instance uses.
        								SEV is an AMD feature. TDX is an Intel feature. One of the following
        								values is required: SEV, SEV_SNP, TDX. If SEV_SNP, min_cpu_platform =
        								"AMD Milan" is currently required.
        """
        return pulumi.get(self, "confidential_instance_type")

    @_builtins.property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> _builtins.bool:
        """
        Defines whether the instance should have confidential compute enabled. Field will be deprecated in a future release
        """
        return pulumi.get(self, "enable_confidential_compute")


@pulumi.output_type
class GetInstanceGroupManagerAllInstancesConfigResult(dict):
    def __init__(__self__, *,
                 labels: Mapping[str, _builtins.str],
                 metadata: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] labels: The label key-value pairs that you want to patch onto the instance,
        :param Mapping[str, _builtins.str] metadata: The metadata key-value pairs that you want to patch onto the instance. For more information, see Project and instance metadata,
        """
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        The label key-value pairs that you want to patch onto the instance,
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Mapping[str, _builtins.str]:
        """
        The metadata key-value pairs that you want to patch onto the instance. For more information, see Project and instance metadata,
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class GetInstanceGroupManagerAutoHealingPolicyResult(dict):
    def __init__(__self__, *,
                 health_check: _builtins.str,
                 initial_delay_sec: _builtins.int):
        """
        :param _builtins.str health_check: The health check resource that signals autohealing.
        :param _builtins.int initial_delay_sec: The number of seconds that the managed instance group waits before it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        pulumi.set(__self__, "health_check", health_check)
        pulumi.set(__self__, "initial_delay_sec", initial_delay_sec)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> _builtins.str:
        """
        The health check resource that signals autohealing.
        """
        return pulumi.get(self, "health_check")

    @_builtins.property
    @pulumi.getter(name="initialDelaySec")
    def initial_delay_sec(self) -> _builtins.int:
        """
        The number of seconds that the managed instance group waits before it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        return pulumi.get(self, "initial_delay_sec")


@pulumi.output_type
class GetInstanceGroupManagerInstanceLifecyclePolicyResult(dict):
    def __init__(__self__, *,
                 default_action_on_failure: _builtins.str,
                 force_update_on_repair: _builtins.str,
                 on_failed_health_check: _builtins.str,
                 on_repairs: Sequence['outputs.GetInstanceGroupManagerInstanceLifecyclePolicyOnRepairResult']):
        """
        :param _builtins.str default_action_on_failure: Specifies the action that a MIG performs on a failed VM. If the value of the "on_failed_health_check" field is DEFAULT_ACTION, then the same action also applies to the VMs on which your application fails a health check. Valid values are: REPAIR, DO_NOTHING. If REPAIR (default), then MIG automatically repairs a failed VM by recreating it. For more information, see about repairing VMs in a MIG. If DO_NOTHING, then MIG does not repair a failed VM.
        :param _builtins.str force_update_on_repair: Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: YES, NO. If YES and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If NO (default), then updates are applied in accordance with the group's update policy type.
        :param _builtins.str on_failed_health_check: Specifies the action that a MIG performs on an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid values are: DEFAULT_ACTION, DO_NOTHING, REPAIR. If DEFAULT_ACTION (default), then MIG uses the same action configured for the  "default_action_on_failure" field. If DO_NOTHING, then MIG does not repair unhealthy VM. If REPAIR, then MIG automatically repairs an unhealthy VM by recreating it.
        :param Sequence['GetInstanceGroupManagerInstanceLifecyclePolicyOnRepairArgs'] on_repairs: Configuration for VM repairs in the MIG.
        """
        pulumi.set(__self__, "default_action_on_failure", default_action_on_failure)
        pulumi.set(__self__, "force_update_on_repair", force_update_on_repair)
        pulumi.set(__self__, "on_failed_health_check", on_failed_health_check)
        pulumi.set(__self__, "on_repairs", on_repairs)

    @_builtins.property
    @pulumi.getter(name="defaultActionOnFailure")
    def default_action_on_failure(self) -> _builtins.str:
        """
        Specifies the action that a MIG performs on a failed VM. If the value of the "on_failed_health_check" field is DEFAULT_ACTION, then the same action also applies to the VMs on which your application fails a health check. Valid values are: REPAIR, DO_NOTHING. If REPAIR (default), then MIG automatically repairs a failed VM by recreating it. For more information, see about repairing VMs in a MIG. If DO_NOTHING, then MIG does not repair a failed VM.
        """
        return pulumi.get(self, "default_action_on_failure")

    @_builtins.property
    @pulumi.getter(name="forceUpdateOnRepair")
    def force_update_on_repair(self) -> _builtins.str:
        """
        Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: YES, NO. If YES and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If NO (default), then updates are applied in accordance with the group's update policy type.
        """
        return pulumi.get(self, "force_update_on_repair")

    @_builtins.property
    @pulumi.getter(name="onFailedHealthCheck")
    def on_failed_health_check(self) -> _builtins.str:
        """
        Specifies the action that a MIG performs on an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid values are: DEFAULT_ACTION, DO_NOTHING, REPAIR. If DEFAULT_ACTION (default), then MIG uses the same action configured for the  "default_action_on_failure" field. If DO_NOTHING, then MIG does not repair unhealthy VM. If REPAIR, then MIG automatically repairs an unhealthy VM by recreating it.
        """
        return pulumi.get(self, "on_failed_health_check")

    @_builtins.property
    @pulumi.getter(name="onRepairs")
    def on_repairs(self) -> Sequence['outputs.GetInstanceGroupManagerInstanceLifecyclePolicyOnRepairResult']:
        """
        Configuration for VM repairs in the MIG.
        """
        return pulumi.get(self, "on_repairs")


@pulumi.output_type
class GetInstanceGroupManagerInstanceLifecyclePolicyOnRepairResult(dict):
    def __init__(__self__, *,
                 allow_changing_zone: _builtins.str):
        """
        :param _builtins.str allow_changing_zone: Specifies whether the MIG can change a VM's zone during a repair. If "YES", MIG can select a different zone for the VM during a repair. Else if "NO", MIG cannot change a VM's zone during a repair. The default value of allow_changing_zone is "NO".
        """
        pulumi.set(__self__, "allow_changing_zone", allow_changing_zone)

    @_builtins.property
    @pulumi.getter(name="allowChangingZone")
    def allow_changing_zone(self) -> _builtins.str:
        """
        Specifies whether the MIG can change a VM's zone during a repair. If "YES", MIG can select a different zone for the VM during a repair. Else if "NO", MIG cannot change a VM's zone during a repair. The default value of allow_changing_zone is "NO".
        """
        return pulumi.get(self, "allow_changing_zone")


@pulumi.output_type
class GetInstanceGroupManagerNamedPortResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str name: The name of the instance group. Either `name` or `self_link` must be provided.
        :param _builtins.int port: The port number.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance group. Either `name` or `self_link` must be provided.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port number.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetInstanceGroupManagerParamResult(dict):
    def __init__(__self__, *,
                 resource_manager_tags: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to bind to the managed instance group. The tags are key-value pairs. Keys must be in the format tagKeys/123 and values in the format tagValues/456.
        """
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        Resource manager tags to bind to the managed instance group. The tags are key-value pairs. Keys must be in the format tagKeys/123 and values in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class GetInstanceGroupManagerResourcePolicyResult(dict):
    def __init__(__self__, *,
                 workload_policy: _builtins.str):
        """
        :param _builtins.str workload_policy: The URL of the workload policy that is specified for this managed instance group. It can be a full or partial URL.
        """
        pulumi.set(__self__, "workload_policy", workload_policy)

    @_builtins.property
    @pulumi.getter(name="workloadPolicy")
    def workload_policy(self) -> _builtins.str:
        """
        The URL of the workload policy that is specified for this managed instance group. It can be a full or partial URL.
        """
        return pulumi.get(self, "workload_policy")


@pulumi.output_type
class GetInstanceGroupManagerStandbyPolicyResult(dict):
    def __init__(__self__, *,
                 initial_delay_sec: _builtins.int,
                 mode: _builtins.str):
        """
        :param _builtins.int initial_delay_sec: Specifies the number of seconds that the MIG should wait to suspend or stop a VM after that VM was created. The initial delay gives the initialization script the time to prepare your VM for a quick scale out. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
        :param _builtins.str mode: Defines how a MIG resumes or starts VMs from a standby pool when the group scales out. The default mode is "MANUAL".
        """
        pulumi.set(__self__, "initial_delay_sec", initial_delay_sec)
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="initialDelaySec")
    def initial_delay_sec(self) -> _builtins.int:
        """
        Specifies the number of seconds that the MIG should wait to suspend or stop a VM after that VM was created. The initial delay gives the initialization script the time to prepare your VM for a quick scale out. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
        """
        return pulumi.get(self, "initial_delay_sec")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Defines how a MIG resumes or starts VMs from a standby pool when the group scales out. The default mode is "MANUAL".
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetInstanceGroupManagerStatefulDiskResult(dict):
    def __init__(__self__, *,
                 delete_rule: _builtins.str,
                 device_name: _builtins.str):
        """
        :param _builtins.str delete_rule: A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the disk when the VM is deleted, but do not delete the disk. ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently deleted from the instance group. The default is NEVER.
        :param _builtins.str device_name: The device name of the disk to be attached.
        """
        pulumi.set(__self__, "delete_rule", delete_rule)
        pulumi.set(__self__, "device_name", device_name)

    @_builtins.property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> _builtins.str:
        """
        A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the disk when the VM is deleted, but do not delete the disk. ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently deleted from the instance group. The default is NEVER.
        """
        return pulumi.get(self, "delete_rule")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        The device name of the disk to be attached.
        """
        return pulumi.get(self, "device_name")


@pulumi.output_type
class GetInstanceGroupManagerStatefulExternalIpResult(dict):
    def __init__(__self__, *,
                 delete_rule: _builtins.str,
                 interface_name: _builtins.str):
        """
        :param _builtins.str delete_rule: A value that prescribes what should happen to an associated static Address resource when a VM instance is permanently deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the IP when the VM is deleted, but do not delete the address resource. ON_PERMANENT_INSTANCE_DELETION will delete the stateful address when the VM is permanently deleted from the instance group. The default is NEVER.
        :param _builtins.str interface_name: The network interface name
        """
        pulumi.set(__self__, "delete_rule", delete_rule)
        pulumi.set(__self__, "interface_name", interface_name)

    @_builtins.property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> _builtins.str:
        """
        A value that prescribes what should happen to an associated static Address resource when a VM instance is permanently deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the IP when the VM is deleted, but do not delete the address resource. ON_PERMANENT_INSTANCE_DELETION will delete the stateful address when the VM is permanently deleted from the instance group. The default is NEVER.
        """
        return pulumi.get(self, "delete_rule")

    @_builtins.property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> _builtins.str:
        """
        The network interface name
        """
        return pulumi.get(self, "interface_name")


@pulumi.output_type
class GetInstanceGroupManagerStatefulInternalIpResult(dict):
    def __init__(__self__, *,
                 delete_rule: _builtins.str,
                 interface_name: _builtins.str):
        """
        :param _builtins.str delete_rule: A value that prescribes what should happen to an associated static Address resource when a VM instance is permanently deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the IP when the VM is deleted, but do not delete the address resource. ON_PERMANENT_INSTANCE_DELETION will delete the stateful address when the VM is permanently deleted from the instance group. The default is NEVER.
        :param _builtins.str interface_name: The network interface name
        """
        pulumi.set(__self__, "delete_rule", delete_rule)
        pulumi.set(__self__, "interface_name", interface_name)

    @_builtins.property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> _builtins.str:
        """
        A value that prescribes what should happen to an associated static Address resource when a VM instance is permanently deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the IP when the VM is deleted, but do not delete the address resource. ON_PERMANENT_INSTANCE_DELETION will delete the stateful address when the VM is permanently deleted from the instance group. The default is NEVER.
        """
        return pulumi.get(self, "delete_rule")

    @_builtins.property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> _builtins.str:
        """
        The network interface name
        """
        return pulumi.get(self, "interface_name")


@pulumi.output_type
class GetInstanceGroupManagerStatusResult(dict):
    def __init__(__self__, *,
                 all_instances_configs: Sequence['outputs.GetInstanceGroupManagerStatusAllInstancesConfigResult'],
                 is_stable: _builtins.bool,
                 statefuls: Sequence['outputs.GetInstanceGroupManagerStatusStatefulResult'],
                 version_targets: Sequence['outputs.GetInstanceGroupManagerStatusVersionTargetResult']):
        """
        :param Sequence['GetInstanceGroupManagerStatusAllInstancesConfigArgs'] all_instances_configs: Status of all-instances configuration on the group.
        :param _builtins.bool is_stable: A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
        :param Sequence['GetInstanceGroupManagerStatusStatefulArgs'] statefuls: Stateful status of the given Instance Group Manager.
        :param Sequence['GetInstanceGroupManagerStatusVersionTargetArgs'] version_targets: A status of consistency of Instances' versions with their target version specified by version field on Instance Group Manager.
        """
        pulumi.set(__self__, "all_instances_configs", all_instances_configs)
        pulumi.set(__self__, "is_stable", is_stable)
        pulumi.set(__self__, "statefuls", statefuls)
        pulumi.set(__self__, "version_targets", version_targets)

    @_builtins.property
    @pulumi.getter(name="allInstancesConfigs")
    def all_instances_configs(self) -> Sequence['outputs.GetInstanceGroupManagerStatusAllInstancesConfigResult']:
        """
        Status of all-instances configuration on the group.
        """
        return pulumi.get(self, "all_instances_configs")

    @_builtins.property
    @pulumi.getter(name="isStable")
    def is_stable(self) -> _builtins.bool:
        """
        A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
        """
        return pulumi.get(self, "is_stable")

    @_builtins.property
    @pulumi.getter
    def statefuls(self) -> Sequence['outputs.GetInstanceGroupManagerStatusStatefulResult']:
        """
        Stateful status of the given Instance Group Manager.
        """
        return pulumi.get(self, "statefuls")

    @_builtins.property
    @pulumi.getter(name="versionTargets")
    def version_targets(self) -> Sequence['outputs.GetInstanceGroupManagerStatusVersionTargetResult']:
        """
        A status of consistency of Instances' versions with their target version specified by version field on Instance Group Manager.
        """
        return pulumi.get(self, "version_targets")


@pulumi.output_type
class GetInstanceGroupManagerStatusAllInstancesConfigResult(dict):
    def __init__(__self__, *,
                 current_revision: _builtins.str,
                 effective: _builtins.bool):
        """
        :param _builtins.str current_revision: Current all-instances configuration revision. This value is in RFC3339 text format.
        :param _builtins.bool effective: A bit indicating whether this configuration has been applied to all managed instances in the group.
        """
        pulumi.set(__self__, "current_revision", current_revision)
        pulumi.set(__self__, "effective", effective)

    @_builtins.property
    @pulumi.getter(name="currentRevision")
    def current_revision(self) -> _builtins.str:
        """
        Current all-instances configuration revision. This value is in RFC3339 text format.
        """
        return pulumi.get(self, "current_revision")

    @_builtins.property
    @pulumi.getter
    def effective(self) -> _builtins.bool:
        """
        A bit indicating whether this configuration has been applied to all managed instances in the group.
        """
        return pulumi.get(self, "effective")


@pulumi.output_type
class GetInstanceGroupManagerStatusStatefulResult(dict):
    def __init__(__self__, *,
                 has_stateful_config: _builtins.bool,
                 per_instance_configs: Sequence['outputs.GetInstanceGroupManagerStatusStatefulPerInstanceConfigResult']):
        """
        :param _builtins.bool has_stateful_config: A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
        :param Sequence['GetInstanceGroupManagerStatusStatefulPerInstanceConfigArgs'] per_instance_configs: Status of per-instance configs on the instances.
        """
        pulumi.set(__self__, "has_stateful_config", has_stateful_config)
        pulumi.set(__self__, "per_instance_configs", per_instance_configs)

    @_builtins.property
    @pulumi.getter(name="hasStatefulConfig")
    def has_stateful_config(self) -> _builtins.bool:
        """
        A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
        """
        return pulumi.get(self, "has_stateful_config")

    @_builtins.property
    @pulumi.getter(name="perInstanceConfigs")
    def per_instance_configs(self) -> Sequence['outputs.GetInstanceGroupManagerStatusStatefulPerInstanceConfigResult']:
        """
        Status of per-instance configs on the instances.
        """
        return pulumi.get(self, "per_instance_configs")


@pulumi.output_type
class GetInstanceGroupManagerStatusStatefulPerInstanceConfigResult(dict):
    def __init__(__self__, *,
                 all_effective: _builtins.bool):
        """
        :param _builtins.bool all_effective: A bit indicating if all of the group's per-instance configs (listed in the output of a listPerInstanceConfigs API call) have status EFFECTIVE or there are no per-instance-configs.
        """
        pulumi.set(__self__, "all_effective", all_effective)

    @_builtins.property
    @pulumi.getter(name="allEffective")
    def all_effective(self) -> _builtins.bool:
        """
        A bit indicating if all of the group's per-instance configs (listed in the output of a listPerInstanceConfigs API call) have status EFFECTIVE or there are no per-instance-configs.
        """
        return pulumi.get(self, "all_effective")


@pulumi.output_type
class GetInstanceGroupManagerStatusVersionTargetResult(dict):
    def __init__(__self__, *,
                 is_reached: _builtins.bool):
        """
        :param _builtins.bool is_reached: A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
        """
        pulumi.set(__self__, "is_reached", is_reached)

    @_builtins.property
    @pulumi.getter(name="isReached")
    def is_reached(self) -> _builtins.bool:
        """
        A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
        """
        return pulumi.get(self, "is_reached")


@pulumi.output_type
class GetInstanceGroupManagerUpdatePolicyResult(dict):
    def __init__(__self__, *,
                 max_surge_fixed: _builtins.int,
                 max_surge_percent: _builtins.int,
                 max_unavailable_fixed: _builtins.int,
                 max_unavailable_percent: _builtins.int,
                 min_ready_sec: _builtins.int,
                 minimal_action: _builtins.str,
                 most_disruptive_allowed_action: _builtins.str,
                 replacement_method: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.int max_surge_fixed: Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with max_surge_percent. Both cannot be 0
        :param _builtins.int max_surge_percent: Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with max_surge_fixed.
        :param _builtins.int max_unavailable_fixed: Specifies a fixed number of VM instances. This must be a positive integer.
        :param _builtins.int max_unavailable_percent: Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
        :param _builtins.int min_ready_sec: Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600].
        :param _builtins.str minimal_action: Minimal action to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to update without stopping instances, RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a REFRESH, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        :param _builtins.str most_disruptive_allowed_action: Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
        :param _builtins.str replacement_method: The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
        :param _builtins.str type: The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        """
        pulumi.set(__self__, "max_surge_fixed", max_surge_fixed)
        pulumi.set(__self__, "max_surge_percent", max_surge_percent)
        pulumi.set(__self__, "max_unavailable_fixed", max_unavailable_fixed)
        pulumi.set(__self__, "max_unavailable_percent", max_unavailable_percent)
        pulumi.set(__self__, "min_ready_sec", min_ready_sec)
        pulumi.set(__self__, "minimal_action", minimal_action)
        pulumi.set(__self__, "most_disruptive_allowed_action", most_disruptive_allowed_action)
        pulumi.set(__self__, "replacement_method", replacement_method)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="maxSurgeFixed")
    def max_surge_fixed(self) -> _builtins.int:
        """
        Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with max_surge_percent. Both cannot be 0
        """
        return pulumi.get(self, "max_surge_fixed")

    @_builtins.property
    @pulumi.getter(name="maxSurgePercent")
    def max_surge_percent(self) -> _builtins.int:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with max_surge_fixed.
        """
        return pulumi.get(self, "max_surge_percent")

    @_builtins.property
    @pulumi.getter(name="maxUnavailableFixed")
    def max_unavailable_fixed(self) -> _builtins.int:
        """
        Specifies a fixed number of VM instances. This must be a positive integer.
        """
        return pulumi.get(self, "max_unavailable_fixed")

    @_builtins.property
    @pulumi.getter(name="maxUnavailablePercent")
    def max_unavailable_percent(self) -> _builtins.int:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
        """
        return pulumi.get(self, "max_unavailable_percent")

    @_builtins.property
    @pulumi.getter(name="minReadySec")
    def min_ready_sec(self) -> _builtins.int:
        """
        Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600].
        """
        return pulumi.get(self, "min_ready_sec")

    @_builtins.property
    @pulumi.getter(name="minimalAction")
    def minimal_action(self) -> _builtins.str:
        """
        Minimal action to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to update without stopping instances, RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a REFRESH, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        """
        return pulumi.get(self, "minimal_action")

    @_builtins.property
    @pulumi.getter(name="mostDisruptiveAllowedAction")
    def most_disruptive_allowed_action(self) -> _builtins.str:
        """
        Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
        """
        return pulumi.get(self, "most_disruptive_allowed_action")

    @_builtins.property
    @pulumi.getter(name="replacementMethod")
    def replacement_method(self) -> _builtins.str:
        """
        The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
        """
        return pulumi.get(self, "replacement_method")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceGroupManagerVersionResult(dict):
    def __init__(__self__, *,
                 instance_template: _builtins.str,
                 name: _builtins.str,
                 target_sizes: Sequence['outputs.GetInstanceGroupManagerVersionTargetSizeResult']):
        """
        :param _builtins.str instance_template: The full URL to an instance template from which all new instances of this version will be created.
        :param _builtins.str name: The name of the instance group. Either `name` or `self_link` must be provided.
        :param Sequence['GetInstanceGroupManagerVersionTargetSizeArgs'] target_sizes: The number of instances calculated as a fixed number or a percentage depending on the settings.
        """
        pulumi.set(__self__, "instance_template", instance_template)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_sizes", target_sizes)

    @_builtins.property
    @pulumi.getter(name="instanceTemplate")
    def instance_template(self) -> _builtins.str:
        """
        The full URL to an instance template from which all new instances of this version will be created.
        """
        return pulumi.get(self, "instance_template")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance group. Either `name` or `self_link` must be provided.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="targetSizes")
    def target_sizes(self) -> Sequence['outputs.GetInstanceGroupManagerVersionTargetSizeResult']:
        """
        The number of instances calculated as a fixed number or a percentage depending on the settings.
        """
        return pulumi.get(self, "target_sizes")


@pulumi.output_type
class GetInstanceGroupManagerVersionTargetSizeResult(dict):
    def __init__(__self__, *,
                 fixed: _builtins.int,
                 percent: _builtins.int):
        """
        :param _builtins.int fixed: The number of instances which are managed for this version. Conflicts with percent.
        :param _builtins.int percent: The number of instances (calculated as percentage) which are managed for this version. Conflicts with fixed. Note that when using percent, rounding will be in favor of explicitly set target_size values; a managed instance group with 2 instances and 2 versions, one of which has a target_size.percent of 60 will create 2 instances of that version.
        """
        pulumi.set(__self__, "fixed", fixed)
        pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter
    def fixed(self) -> _builtins.int:
        """
        The number of instances which are managed for this version. Conflicts with percent.
        """
        return pulumi.get(self, "fixed")

    @_builtins.property
    @pulumi.getter
    def percent(self) -> _builtins.int:
        """
        The number of instances (calculated as percentage) which are managed for this version. Conflicts with fixed. Note that when using percent, rounding will be in favor of explicitly set target_size values; a managed instance group with 2 instances and 2 versions, one of which has a target_size.percent of 60 will create 2 instances of that version.
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class GetInstanceGroupNamedPortResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str name: The name of the instance group. Either `name` or `self_link` must be provided.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance group. Either `name` or `self_link` must be provided.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetInstanceGuestAcceleratorResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int count: The number of the guest accelerator cards exposed to this instance.
        :param _builtins.str type: The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceGuestAttributesQueryValueResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 namespace: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Key of the guest_attribute.
        :param _builtins.str namespace: Namespace of the guest_attribute.
        :param _builtins.str value: Value of the guest_attribute.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of the guest_attribute.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Namespace of the guest_attribute.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of the guest_attribute.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetInstanceInstanceEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 sha256: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str sha256: The SHA256 hash of the customer's encryption key.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> _builtins.str:
        """
        The SHA256 hash of the customer's encryption key.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class GetInstanceNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 access_configs: Sequence['outputs.GetInstanceNetworkInterfaceAccessConfigResult'],
                 alias_ip_ranges: Sequence['outputs.GetInstanceNetworkInterfaceAliasIpRangeResult'],
                 internal_ipv6_prefix_length: _builtins.int,
                 ipv6_access_configs: Sequence['outputs.GetInstanceNetworkInterfaceIpv6AccessConfigResult'],
                 ipv6_access_type: _builtins.str,
                 ipv6_address: _builtins.str,
                 name: _builtins.str,
                 network: _builtins.str,
                 network_attachment: _builtins.str,
                 network_ip: _builtins.str,
                 nic_type: _builtins.str,
                 queue_count: _builtins.int,
                 security_policy: _builtins.str,
                 stack_type: _builtins.str,
                 subnetwork: _builtins.str,
                 subnetwork_project: _builtins.str):
        """
        :param Sequence['GetInstanceNetworkInterfaceAccessConfigArgs'] access_configs: Access configurations, i.e. IPs via which this
               instance can be accessed via the Internet. Structure documented below.
        :param Sequence['GetInstanceNetworkInterfaceAliasIpRangeArgs'] alias_ip_ranges: An array of alias IP ranges for this network interface. Structure documented below.
        :param _builtins.int internal_ipv6_prefix_length: The prefix length of the primary internal IPv6 range.
        :param Sequence['GetInstanceNetworkInterfaceIpv6AccessConfigArgs'] ipv6_access_configs: An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
        :param _builtins.str ipv6_access_type: One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
        :param _builtins.str ipv6_address: An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        :param _builtins.str name: The name of the instance. One of `name` or `self_link` must be provided.
        :param _builtins.str network: The name or self_link of the network attached to this interface.
        :param _builtins.str network_attachment: The URL of the network attachment to this interface.
        :param _builtins.str network_ip: The internal ip address of the instance, either manually or dynamically assigned.
        :param _builtins.str nic_type: The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET, IDPF, MRDMA, and IRDMA
        :param _builtins.int queue_count: The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        :param _builtins.str security_policy: A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        :param _builtins.str stack_type: The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
        :param _builtins.str subnetwork: The name or self_link of the subnetwork attached to this interface.
        :param _builtins.str subnetwork_project: The project in which the subnetwork belongs.
        """
        pulumi.set(__self__, "access_configs", access_configs)
        pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        pulumi.set(__self__, "internal_ipv6_prefix_length", internal_ipv6_prefix_length)
        pulumi.set(__self__, "ipv6_access_configs", ipv6_access_configs)
        pulumi.set(__self__, "ipv6_access_type", ipv6_access_type)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "network_attachment", network_attachment)
        pulumi.set(__self__, "network_ip", network_ip)
        pulumi.set(__self__, "nic_type", nic_type)
        pulumi.set(__self__, "queue_count", queue_count)
        pulumi.set(__self__, "security_policy", security_policy)
        pulumi.set(__self__, "stack_type", stack_type)
        pulumi.set(__self__, "subnetwork", subnetwork)
        pulumi.set(__self__, "subnetwork_project", subnetwork_project)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Sequence['outputs.GetInstanceNetworkInterfaceAccessConfigResult']:
        """
        Access configurations, i.e. IPs via which this
        instance can be accessed via the Internet. Structure documented below.
        """
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Sequence['outputs.GetInstanceNetworkInterfaceAliasIpRangeResult']:
        """
        An array of alias IP ranges for this network interface. Structure documented below.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="internalIpv6PrefixLength")
    def internal_ipv6_prefix_length(self) -> _builtins.int:
        """
        The prefix length of the primary internal IPv6 range.
        """
        return pulumi.get(self, "internal_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessConfigs")
    def ipv6_access_configs(self) -> Sequence['outputs.GetInstanceNetworkInterfaceIpv6AccessConfigResult']:
        """
        An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
        """
        return pulumi.get(self, "ipv6_access_configs")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessType")
    def ipv6_access_type(self) -> _builtins.str:
        """
        One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
        """
        return pulumi.get(self, "ipv6_access_type")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> _builtins.str:
        """
        An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance. One of `name` or `self_link` must be provided.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The name or self_link of the network attached to this interface.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="networkAttachment")
    def network_attachment(self) -> _builtins.str:
        """
        The URL of the network attachment to this interface.
        """
        return pulumi.get(self, "network_attachment")

    @_builtins.property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> _builtins.str:
        """
        The internal ip address of the instance, either manually or dynamically assigned.
        """
        return pulumi.get(self, "network_ip")

    @_builtins.property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> _builtins.str:
        """
        The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET, IDPF, MRDMA, and IRDMA
        """
        return pulumi.get(self, "nic_type")

    @_builtins.property
    @pulumi.getter(name="queueCount")
    def queue_count(self) -> _builtins.int:
        """
        The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        """
        return pulumi.get(self, "queue_count")

    @_builtins.property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> _builtins.str:
        """
        A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        return pulumi.get(self, "security_policy")

    @_builtins.property
    @pulumi.getter(name="stackType")
    def stack_type(self) -> _builtins.str:
        """
        The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
        """
        return pulumi.get(self, "stack_type")

    @_builtins.property
    @pulumi.getter
    def subnetwork(self) -> _builtins.str:
        """
        The name or self_link of the subnetwork attached to this interface.
        """
        return pulumi.get(self, "subnetwork")

    @_builtins.property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> _builtins.str:
        """
        The project in which the subnetwork belongs.
        """
        return pulumi.get(self, "subnetwork_project")


@pulumi.output_type
class GetInstanceNetworkInterfaceAccessConfigResult(dict):
    def __init__(__self__, *,
                 nat_ip: _builtins.str,
                 network_tier: _builtins.str,
                 public_ptr_domain_name: _builtins.str,
                 security_policy: _builtins.str):
        """
        :param _builtins.str nat_ip: If the instance has an access config, either the given external ip (in the `nat_ip` field) or the ephemeral (generated) ip (if you didn't provide one).
        :param _builtins.str network_tier: The [networking tier][network-tier] used for configuring this instance. One of `PREMIUM` or `STANDARD`.
        :param _builtins.str public_ptr_domain_name: The DNS domain name for the public PTR record.
        :param _builtins.str security_policy: A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        pulumi.set(__self__, "nat_ip", nat_ip)
        pulumi.set(__self__, "network_tier", network_tier)
        pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)
        pulumi.set(__self__, "security_policy", security_policy)

    @_builtins.property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> _builtins.str:
        """
        If the instance has an access config, either the given external ip (in the `nat_ip` field) or the ephemeral (generated) ip (if you didn't provide one).
        """
        return pulumi.get(self, "nat_ip")

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> _builtins.str:
        """
        The [networking tier][network-tier] used for configuring this instance. One of `PREMIUM` or `STANDARD`.
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> _builtins.str:
        """
        The DNS domain name for the public PTR record.
        """
        return pulumi.get(self, "public_ptr_domain_name")

    @_builtins.property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> _builtins.str:
        """
        A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        return pulumi.get(self, "security_policy")


@pulumi.output_type
class GetInstanceNetworkInterfaceAliasIpRangeResult(dict):
    def __init__(__self__, *,
                 ip_cidr_range: _builtins.str,
                 subnetwork_range_name: _builtins.str):
        """
        :param _builtins.str ip_cidr_range: The IP CIDR range represented by this alias IP range.
        :param _builtins.str subnetwork_range_name: The subnetwork secondary range name specifying
               the secondary range from which to allocate the IP CIDR range for this alias IP
               range.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @_builtins.property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> _builtins.str:
        """
        The IP CIDR range represented by this alias IP range.
        """
        return pulumi.get(self, "ip_cidr_range")

    @_builtins.property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> _builtins.str:
        """
        The subnetwork secondary range name specifying
        the secondary range from which to allocate the IP CIDR range for this alias IP
        range.
        """
        return pulumi.get(self, "subnetwork_range_name")


@pulumi.output_type
class GetInstanceNetworkInterfaceIpv6AccessConfigResult(dict):
    def __init__(__self__, *,
                 external_ipv6: _builtins.str,
                 external_ipv6_prefix_length: _builtins.str,
                 name: _builtins.str,
                 network_tier: _builtins.str,
                 public_ptr_domain_name: _builtins.str,
                 security_policy: _builtins.str):
        """
        :param _builtins.str external_ipv6: The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. To use a static external IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
        :param _builtins.str external_ipv6_prefix_length: The prefix length of the external IPv6 range.
        :param _builtins.str name: The name of the instance. One of `name` or `self_link` must be provided.
        :param _builtins.str network_tier: The [networking tier][network-tier] used for configuring this instance. One of `PREMIUM` or `STANDARD`.
        :param _builtins.str public_ptr_domain_name: The DNS domain name for the public PTR record.
        :param _builtins.str security_policy: A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        pulumi.set(__self__, "external_ipv6", external_ipv6)
        pulumi.set(__self__, "external_ipv6_prefix_length", external_ipv6_prefix_length)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_tier", network_tier)
        pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)
        pulumi.set(__self__, "security_policy", security_policy)

    @_builtins.property
    @pulumi.getter(name="externalIpv6")
    def external_ipv6(self) -> _builtins.str:
        """
        The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. To use a static external IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
        """
        return pulumi.get(self, "external_ipv6")

    @_builtins.property
    @pulumi.getter(name="externalIpv6PrefixLength")
    def external_ipv6_prefix_length(self) -> _builtins.str:
        """
        The prefix length of the external IPv6 range.
        """
        return pulumi.get(self, "external_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance. One of `name` or `self_link` must be provided.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> _builtins.str:
        """
        The [networking tier][network-tier] used for configuring this instance. One of `PREMIUM` or `STANDARD`.
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> _builtins.str:
        """
        The DNS domain name for the public PTR record.
        """
        return pulumi.get(self, "public_ptr_domain_name")

    @_builtins.property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> _builtins.str:
        """
        A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
        """
        return pulumi.get(self, "security_policy")


@pulumi.output_type
class GetInstanceNetworkPerformanceConfigResult(dict):
    def __init__(__self__, *,
                 total_egress_bandwidth_tier: _builtins.str):
        """
        :param _builtins.str total_egress_bandwidth_tier: The egress bandwidth tier for the instance.
        """
        pulumi.set(__self__, "total_egress_bandwidth_tier", total_egress_bandwidth_tier)

    @_builtins.property
    @pulumi.getter(name="totalEgressBandwidthTier")
    def total_egress_bandwidth_tier(self) -> _builtins.str:
        """
        The egress bandwidth tier for the instance.
        """
        return pulumi.get(self, "total_egress_bandwidth_tier")


@pulumi.output_type
class GetInstanceParamResult(dict):
    def __init__(__self__, *,
                 resource_manager_tags: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class GetInstanceReservationAffinityResult(dict):
    def __init__(__self__, *,
                 specific_reservations: Sequence['outputs.GetInstanceReservationAffinitySpecificReservationResult'],
                 type: _builtins.str):
        """
        :param Sequence['GetInstanceReservationAffinitySpecificReservationArgs'] specific_reservations: Specifies the label selector for the reservation to use.
        :param _builtins.str type: The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "specific_reservations", specific_reservations)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="specificReservations")
    def specific_reservations(self) -> Sequence['outputs.GetInstanceReservationAffinitySpecificReservationResult']:
        """
        Specifies the label selector for the reservation to use.
        """
        return pulumi.get(self, "specific_reservations")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceReservationAffinitySpecificReservationResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
        :param Sequence[_builtins.str] values: Corresponds to the label values of a reservation resource.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Corresponds to the label values of a reservation resource.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceSchedulingResult(dict):
    def __init__(__self__, *,
                 automatic_restart: _builtins.bool,
                 availability_domain: _builtins.int,
                 graceful_shutdowns: Sequence['outputs.GetInstanceSchedulingGracefulShutdownResult'],
                 host_error_timeout_seconds: _builtins.int,
                 instance_termination_action: _builtins.str,
                 local_ssd_recovery_timeouts: Sequence['outputs.GetInstanceSchedulingLocalSsdRecoveryTimeoutResult'],
                 maintenance_interval: _builtins.str,
                 max_run_durations: Sequence['outputs.GetInstanceSchedulingMaxRunDurationResult'],
                 min_node_cpus: _builtins.int,
                 node_affinities: Sequence['outputs.GetInstanceSchedulingNodeAffinityResult'],
                 on_host_maintenance: _builtins.str,
                 on_instance_stop_actions: Sequence['outputs.GetInstanceSchedulingOnInstanceStopActionResult'],
                 preemptible: _builtins.bool,
                 provisioning_model: _builtins.str,
                 skip_guest_os_shutdown: _builtins.bool,
                 termination_time: _builtins.str):
        """
        :param _builtins.bool automatic_restart: Specifies if the instance should be
               restarted if it was terminated by Compute Engine (not a user).
        :param _builtins.int availability_domain: Specifies the availability domain, which this instance should be scheduled on.
        :param Sequence['GetInstanceSchedulingGracefulShutdownArgs'] graceful_shutdowns: Settings for the instance to perform a graceful shutdown.
        :param _builtins.int host_error_timeout_seconds: Beta Time in seconds for host error detection.
        :param _builtins.str instance_termination_action: Describe the type of termination action for `SPOT` VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
        :param Sequence['GetInstanceSchedulingLocalSsdRecoveryTimeoutArgs'] local_ssd_recovery_timeouts: Specifies the maximum amount of time a Local Ssd Vm should wait while
                 recovery of the Local Ssd state is attempted. Its value should be in
                 between 0 and 168 hours with hour granularity and the default value being 1
                 hour.
        :param _builtins.str maintenance_interval: Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
        :param Sequence['GetInstanceSchedulingMaxRunDurationArgs'] max_run_durations: The timeout for new network connections to hosts.
        :param Sequence['GetInstanceSchedulingNodeAffinityArgs'] node_affinities: Specifies node affinities or anti-affinities to determine which sole-tenant nodes your instances and managed instance groups will use as host systems.
        :param _builtins.str on_host_maintenance: Describes maintenance behavior for the
               instance. One of `MIGRATE` or `TERMINATE`, for more info, read
               [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options)
        :param Sequence['GetInstanceSchedulingOnInstanceStopActionArgs'] on_instance_stop_actions: Defines the behaviour for instances with the instance_termination_action.
        :param _builtins.bool preemptible: Whether the instance is preemptible.
        :param _builtins.str provisioning_model: Describe the type of preemptible VM.
        :param _builtins.bool skip_guest_os_shutdown: Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        :param _builtins.str termination_time: Specifies the timestamp, when the instance will be terminated,
               in RFC3339 text format. If specified, the instance termination action
               will be performed at the termination time.
        """
        pulumi.set(__self__, "automatic_restart", automatic_restart)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "graceful_shutdowns", graceful_shutdowns)
        pulumi.set(__self__, "host_error_timeout_seconds", host_error_timeout_seconds)
        pulumi.set(__self__, "instance_termination_action", instance_termination_action)
        pulumi.set(__self__, "local_ssd_recovery_timeouts", local_ssd_recovery_timeouts)
        pulumi.set(__self__, "maintenance_interval", maintenance_interval)
        pulumi.set(__self__, "max_run_durations", max_run_durations)
        pulumi.set(__self__, "min_node_cpus", min_node_cpus)
        pulumi.set(__self__, "node_affinities", node_affinities)
        pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        pulumi.set(__self__, "on_instance_stop_actions", on_instance_stop_actions)
        pulumi.set(__self__, "preemptible", preemptible)
        pulumi.set(__self__, "provisioning_model", provisioning_model)
        pulumi.set(__self__, "skip_guest_os_shutdown", skip_guest_os_shutdown)
        pulumi.set(__self__, "termination_time", termination_time)

    @_builtins.property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> _builtins.bool:
        """
        Specifies if the instance should be
        restarted if it was terminated by Compute Engine (not a user).
        """
        return pulumi.get(self, "automatic_restart")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.int:
        """
        Specifies the availability domain, which this instance should be scheduled on.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="gracefulShutdowns")
    def graceful_shutdowns(self) -> Sequence['outputs.GetInstanceSchedulingGracefulShutdownResult']:
        """
        Settings for the instance to perform a graceful shutdown.
        """
        return pulumi.get(self, "graceful_shutdowns")

    @_builtins.property
    @pulumi.getter(name="hostErrorTimeoutSeconds")
    def host_error_timeout_seconds(self) -> _builtins.int:
        """
        Beta Time in seconds for host error detection.
        """
        return pulumi.get(self, "host_error_timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="instanceTerminationAction")
    def instance_termination_action(self) -> _builtins.str:
        """
        Describe the type of termination action for `SPOT` VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
        """
        return pulumi.get(self, "instance_termination_action")

    @_builtins.property
    @pulumi.getter(name="localSsdRecoveryTimeouts")
    def local_ssd_recovery_timeouts(self) -> Sequence['outputs.GetInstanceSchedulingLocalSsdRecoveryTimeoutResult']:
        """
        Specifies the maximum amount of time a Local Ssd Vm should wait while
          recovery of the Local Ssd state is attempted. Its value should be in
          between 0 and 168 hours with hour granularity and the default value being 1
          hour.
        """
        return pulumi.get(self, "local_ssd_recovery_timeouts")

    @_builtins.property
    @pulumi.getter(name="maintenanceInterval")
    def maintenance_interval(self) -> _builtins.str:
        """
        Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
        """
        return pulumi.get(self, "maintenance_interval")

    @_builtins.property
    @pulumi.getter(name="maxRunDurations")
    def max_run_durations(self) -> Sequence['outputs.GetInstanceSchedulingMaxRunDurationResult']:
        """
        The timeout for new network connections to hosts.
        """
        return pulumi.get(self, "max_run_durations")

    @_builtins.property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> _builtins.int:
        return pulumi.get(self, "min_node_cpus")

    @_builtins.property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Sequence['outputs.GetInstanceSchedulingNodeAffinityResult']:
        """
        Specifies node affinities or anti-affinities to determine which sole-tenant nodes your instances and managed instance groups will use as host systems.
        """
        return pulumi.get(self, "node_affinities")

    @_builtins.property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> _builtins.str:
        """
        Describes maintenance behavior for the
        instance. One of `MIGRATE` or `TERMINATE`, for more info, read
        [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options)
        """
        return pulumi.get(self, "on_host_maintenance")

    @_builtins.property
    @pulumi.getter(name="onInstanceStopActions")
    def on_instance_stop_actions(self) -> Sequence['outputs.GetInstanceSchedulingOnInstanceStopActionResult']:
        """
        Defines the behaviour for instances with the instance_termination_action.
        """
        return pulumi.get(self, "on_instance_stop_actions")

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> _builtins.bool:
        """
        Whether the instance is preemptible.
        """
        return pulumi.get(self, "preemptible")

    @_builtins.property
    @pulumi.getter(name="provisioningModel")
    def provisioning_model(self) -> _builtins.str:
        """
        Describe the type of preemptible VM.
        """
        return pulumi.get(self, "provisioning_model")

    @_builtins.property
    @pulumi.getter(name="skipGuestOsShutdown")
    def skip_guest_os_shutdown(self) -> _builtins.bool:
        """
        Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        """
        return pulumi.get(self, "skip_guest_os_shutdown")

    @_builtins.property
    @pulumi.getter(name="terminationTime")
    def termination_time(self) -> _builtins.str:
        """
        Specifies the timestamp, when the instance will be terminated,
        in RFC3339 text format. If specified, the instance termination action
        will be performed at the termination time.
        """
        return pulumi.get(self, "termination_time")


@pulumi.output_type
class GetInstanceSchedulingGracefulShutdownResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 max_durations: Sequence['outputs.GetInstanceSchedulingGracefulShutdownMaxDurationResult']):
        """
        :param _builtins.bool enabled: Opts-in for graceful shutdown.
        :param Sequence['GetInstanceSchedulingGracefulShutdownMaxDurationArgs'] max_durations: The time allotted for the instance to gracefully shut down.
               										If the graceful shutdown isn't complete after this time, then the instance
               										transitions to the STOPPING state.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "max_durations", max_durations)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Opts-in for graceful shutdown.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.GetInstanceSchedulingGracefulShutdownMaxDurationResult']:
        """
        The time allotted for the instance to gracefully shut down.
        										If the graceful shutdown isn't complete after this time, then the instance
        										transitions to the STOPPING state.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class GetInstanceSchedulingGracefulShutdownMaxDurationResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               													resolution. Durations less than one second are represented
               													with a 0 seconds field and a positive nanos field. Must
               													be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               													The value must be between 1 and 3600, which is 3,600 seconds (one hour).
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        													resolution. Durations less than one second are represented
        													with a 0 seconds field and a positive nanos field. Must
        													be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        													The value must be between 1 and 3600, which is 3,600 seconds (one hour).
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetInstanceSchedulingLocalSsdRecoveryTimeoutResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetInstanceSchedulingMaxRunDurationResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetInstanceSchedulingNodeAffinityResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceSchedulingOnInstanceStopActionResult(dict):
    def __init__(__self__, *,
                 discard_local_ssd: _builtins.bool):
        """
        :param _builtins.bool discard_local_ssd: If true, the contents of any attached Local SSD disks will be discarded.
        """
        pulumi.set(__self__, "discard_local_ssd", discard_local_ssd)

    @_builtins.property
    @pulumi.getter(name="discardLocalSsd")
    def discard_local_ssd(self) -> _builtins.bool:
        """
        If true, the contents of any attached Local SSD disks will be discarded.
        """
        return pulumi.get(self, "discard_local_ssd")


@pulumi.output_type
class GetInstanceScratchDiskResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 interface: _builtins.str,
                 size: _builtins.int):
        """
        :param _builtins.str device_name: Name with which the attached disk is accessible
               under `/dev/disk/by-id/`
        :param _builtins.str interface: The disk interface used for attaching this disk. One of `SCSI` or `NVME`.
        :param _builtins.int size: The size of the image in gigabytes.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "interface", interface)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Name with which the attached disk is accessible
        under `/dev/disk/by-id/`
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> _builtins.str:
        """
        The disk interface used for attaching this disk. One of `SCSI` or `NVME`.
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The size of the image in gigabytes.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetInstanceServiceAccountResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 scopes: Sequence[_builtins.str]):
        """
        :param _builtins.str email: The service account e-mail address.
        :param Sequence[_builtins.str] scopes: A list of service scopes.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The service account e-mail address.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        """
        A list of service scopes.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class GetInstanceShieldedInstanceConfigResult(dict):
    def __init__(__self__, *,
                 enable_integrity_monitoring: _builtins.bool,
                 enable_secure_boot: _builtins.bool,
                 enable_vtpm: _builtins.bool):
        """
        :param _builtins.bool enable_integrity_monitoring: - Whether integrity monitoring is enabled for the instance.
        :param _builtins.bool enable_secure_boot: - Whether secure boot is enabled for the instance.
        :param _builtins.bool enable_vtpm: - Whether the instance uses vTPM.
        """
        pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @_builtins.property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> _builtins.bool:
        """
        - Whether integrity monitoring is enabled for the instance.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @_builtins.property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> _builtins.bool:
        """
        - Whether secure boot is enabled for the instance.
        """
        return pulumi.get(self, "enable_secure_boot")

    @_builtins.property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> _builtins.bool:
        """
        - Whether the instance uses vTPM.
        """
        return pulumi.get(self, "enable_vtpm")


@pulumi.output_type
class GetInstanceTemplateAdvancedMachineFeatureResult(dict):
    def __init__(__self__, *,
                 enable_nested_virtualization: _builtins.bool,
                 enable_uefi_networking: _builtins.bool,
                 performance_monitoring_unit: _builtins.str,
                 threads_per_core: _builtins.int,
                 turbo_mode: _builtins.str,
                 visible_core_count: _builtins.int):
        """
        :param _builtins.bool enable_nested_virtualization: Whether to enable nested virtualization or not.
        :param _builtins.bool enable_uefi_networking: Whether to enable UEFI networking or not.
        :param _builtins.str performance_monitoring_unit: The PMU is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are "STANDARD", "ENHANCED", and "ARCHITECTURAL".
        :param _builtins.int threads_per_core: The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
        :param _builtins.str turbo_mode: Turbo frequency mode to use for the instance. Currently supported modes is "ALL_CORE_MAX".
        :param _builtins.int visible_core_count: The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance\\'s nominal CPU count and the underlying platform\\'s SMT width.
        """
        pulumi.set(__self__, "enable_nested_virtualization", enable_nested_virtualization)
        pulumi.set(__self__, "enable_uefi_networking", enable_uefi_networking)
        pulumi.set(__self__, "performance_monitoring_unit", performance_monitoring_unit)
        pulumi.set(__self__, "threads_per_core", threads_per_core)
        pulumi.set(__self__, "turbo_mode", turbo_mode)
        pulumi.set(__self__, "visible_core_count", visible_core_count)

    @_builtins.property
    @pulumi.getter(name="enableNestedVirtualization")
    def enable_nested_virtualization(self) -> _builtins.bool:
        """
        Whether to enable nested virtualization or not.
        """
        return pulumi.get(self, "enable_nested_virtualization")

    @_builtins.property
    @pulumi.getter(name="enableUefiNetworking")
    def enable_uefi_networking(self) -> _builtins.bool:
        """
        Whether to enable UEFI networking or not.
        """
        return pulumi.get(self, "enable_uefi_networking")

    @_builtins.property
    @pulumi.getter(name="performanceMonitoringUnit")
    def performance_monitoring_unit(self) -> _builtins.str:
        """
        The PMU is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are "STANDARD", "ENHANCED", and "ARCHITECTURAL".
        """
        return pulumi.get(self, "performance_monitoring_unit")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> _builtins.int:
        """
        The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
        """
        return pulumi.get(self, "threads_per_core")

    @_builtins.property
    @pulumi.getter(name="turboMode")
    def turbo_mode(self) -> _builtins.str:
        """
        Turbo frequency mode to use for the instance. Currently supported modes is "ALL_CORE_MAX".
        """
        return pulumi.get(self, "turbo_mode")

    @_builtins.property
    @pulumi.getter(name="visibleCoreCount")
    def visible_core_count(self) -> _builtins.int:
        """
        The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance\\'s nominal CPU count and the underlying platform\\'s SMT width.
        """
        return pulumi.get(self, "visible_core_count")


@pulumi.output_type
class GetInstanceTemplateConfidentialInstanceConfigResult(dict):
    def __init__(__self__, *,
                 confidential_instance_type: _builtins.str,
                 enable_confidential_compute: _builtins.bool):
        """
        :param _builtins.str confidential_instance_type: The confidential computing technology the instance uses.
               								SEV is an AMD feature. TDX is an Intel feature. One of the following
               								values is required: SEV, SEV_SNP, TDX. If SEV_SNP, min_cpu_platform =
               								"AMD Milan" is currently required.
        :param _builtins.bool enable_confidential_compute: Defines whether the instance should have confidential compute enabled. `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.
        """
        pulumi.set(__self__, "confidential_instance_type", confidential_instance_type)
        pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @_builtins.property
    @pulumi.getter(name="confidentialInstanceType")
    def confidential_instance_type(self) -> _builtins.str:
        """
        The confidential computing technology the instance uses.
        								SEV is an AMD feature. TDX is an Intel feature. One of the following
        								values is required: SEV, SEV_SNP, TDX. If SEV_SNP, min_cpu_platform =
        								"AMD Milan" is currently required.
        """
        return pulumi.get(self, "confidential_instance_type")

    @_builtins.property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> _builtins.bool:
        """
        Defines whether the instance should have confidential compute enabled. `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.
        """
        return pulumi.get(self, "enable_confidential_compute")


@pulumi.output_type
class GetInstanceTemplateDiskResult(dict):
    def __init__(__self__, *,
                 architecture: _builtins.str,
                 auto_delete: _builtins.bool,
                 boot: _builtins.bool,
                 device_name: _builtins.str,
                 disk_encryption_keys: Sequence['outputs.GetInstanceTemplateDiskDiskEncryptionKeyResult'],
                 disk_name: _builtins.str,
                 disk_size_gb: _builtins.int,
                 disk_type: _builtins.str,
                 guest_os_features: Sequence[_builtins.str],
                 interface: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 mode: _builtins.str,
                 provisioned_iops: _builtins.int,
                 provisioned_throughput: _builtins.int,
                 resource_manager_tags: Mapping[str, _builtins.str],
                 resource_policies: Sequence[_builtins.str],
                 source: _builtins.str,
                 source_image: _builtins.str,
                 source_image_encryption_keys: Sequence['outputs.GetInstanceTemplateDiskSourceImageEncryptionKeyResult'],
                 source_snapshot: _builtins.str,
                 source_snapshot_encryption_keys: Sequence['outputs.GetInstanceTemplateDiskSourceSnapshotEncryptionKeyResult'],
                 type: _builtins.str):
        """
        :param _builtins.str architecture: The architecture of the image. Allowed values are ARM64 or X86_64.
        :param _builtins.bool auto_delete: Whether or not the disk should be auto-deleted.
               This defaults to true.
        :param _builtins.bool boot: Indicates that this is a boot disk.
        :param _builtins.str device_name: A unique device name that is reflected into the
               /dev/  tree of a Linux operating system running within the instance. If not
               specified, the server chooses a default device name to apply to this disk.
        :param Sequence['GetInstanceTemplateDiskDiskEncryptionKeyArgs'] disk_encryption_keys: Encrypts or decrypts a disk using a customer-supplied encryption key.
        :param _builtins.str disk_name: Name of the disk. When not provided, this defaults
               to the name of the instance.
        :param _builtins.int disk_size_gb: The size of the image in gigabytes. If not
               specified, it will inherit the size of its base image. For SCRATCH disks,
               the size must be exactly 375GB.
        :param _builtins.str disk_type: The GCE disk type. Such as `"pd-ssd"`, `"local-ssd"`,
               `"pd-balanced"` or `"pd-standard"`.
        :param Sequence[_builtins.str] guest_os_features: A list of features to enable on the guest operating system. Applicable only for bootable images.
        :param _builtins.str interface: Specifies the disk interface to use for attaching this disk,
               which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
               and the request will fail if you attempt to attach a persistent disk in any other format
               than SCSI. Local SSDs can use either NVME or SCSI.
        :param Mapping[str, _builtins.str] labels: (Optional) A set of ket/value label pairs to assign to disk created from
               this template
        :param _builtins.str mode: The mode in which to attach this disk, either READ_WRITE
               or READ_ONLY. If you are attaching or creating a boot disk, this must
               read-write mode.
        :param _builtins.int provisioned_iops: Indicates how many IOPS to provision for the disk. This
               sets the number of I/O operations per second that the disk can handle.
               Values must be between 10,000 and 120,000. For more details, see the
               [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk).
        :param _builtins.int provisioned_throughput: Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
        :param Mapping[str, _builtins.str] resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        :param Sequence[_builtins.str] resource_policies: (Optional) -- A list of short names of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
        :param _builtins.str source: The name (**not self_link**)
               of the disk (such as those managed by `compute.Disk`) to attach.
               > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param _builtins.str source_image: The image from which to
               initialize this disk. This can be one of: the image's `self_link`,
               `projects/{project}/global/images/{image}`,
               `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
               `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
               `{project}/{image}`, `{family}`, or `{image}`.
               > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param Sequence['GetInstanceTemplateDiskSourceImageEncryptionKeyArgs'] source_image_encryption_keys: The customer-supplied encryption key of the source
               image. Required if the source image is protected by a
               customer-supplied encryption key.
               
               Instance templates do not store customer-supplied
               encryption keys, so you cannot create disks for
               instances in a managed instance group if the source
               images are encrypted with your own keys.
        :param _builtins.str source_snapshot: The source snapshot to create this disk. When creating
               a new instance, one of initializeParams.sourceSnapshot,
               initializeParams.sourceImage, or disks.source is
               required except for local SSD.
        :param Sequence['GetInstanceTemplateDiskSourceSnapshotEncryptionKeyArgs'] source_snapshot_encryption_keys: The customer-supplied encryption key of the source snapshot.
        :param _builtins.str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "architecture", architecture)
        pulumi.set(__self__, "auto_delete", auto_delete)
        pulumi.set(__self__, "boot", boot)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_encryption_keys", disk_encryption_keys)
        pulumi.set(__self__, "disk_name", disk_name)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "guest_os_features", guest_os_features)
        pulumi.set(__self__, "interface", interface)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "provisioned_iops", provisioned_iops)
        pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)
        pulumi.set(__self__, "resource_policies", resource_policies)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_image", source_image)
        pulumi.set(__self__, "source_image_encryption_keys", source_image_encryption_keys)
        pulumi.set(__self__, "source_snapshot", source_snapshot)
        pulumi.set(__self__, "source_snapshot_encryption_keys", source_snapshot_encryption_keys)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def architecture(self) -> _builtins.str:
        """
        The architecture of the image. Allowed values are ARM64 or X86_64.
        """
        return pulumi.get(self, "architecture")

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> _builtins.bool:
        """
        Whether or not the disk should be auto-deleted.
        This defaults to true.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter
    def boot(self) -> _builtins.bool:
        """
        Indicates that this is a boot disk.
        """
        return pulumi.get(self, "boot")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        A unique device name that is reflected into the
        /dev/  tree of a Linux operating system running within the instance. If not
        specified, the server chooses a default device name to apply to this disk.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeys")
    def disk_encryption_keys(self) -> Sequence['outputs.GetInstanceTemplateDiskDiskEncryptionKeyResult']:
        """
        Encrypts or decrypts a disk using a customer-supplied encryption key.
        """
        return pulumi.get(self, "disk_encryption_keys")

    @_builtins.property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> _builtins.str:
        """
        Name of the disk. When not provided, this defaults
        to the name of the instance.
        """
        return pulumi.get(self, "disk_name")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.int:
        """
        The size of the image in gigabytes. If not
        specified, it will inherit the size of its base image. For SCRATCH disks,
        the size must be exactly 375GB.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> _builtins.str:
        """
        The GCE disk type. Such as `"pd-ssd"`, `"local-ssd"`,
        `"pd-balanced"` or `"pd-standard"`.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="guestOsFeatures")
    def guest_os_features(self) -> Sequence[_builtins.str]:
        """
        A list of features to enable on the guest operating system. Applicable only for bootable images.
        """
        return pulumi.get(self, "guest_os_features")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> _builtins.str:
        """
        Specifies the disk interface to use for attaching this disk,
        which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
        and the request will fail if you attempt to attach a persistent disk in any other format
        than SCSI. Local SSDs can use either NVME or SCSI.
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        (Optional) A set of ket/value label pairs to assign to disk created from
        this template
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The mode in which to attach this disk, either READ_WRITE
        or READ_ONLY. If you are attaching or creating a boot disk, this must
        read-write mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="provisionedIops")
    def provisioned_iops(self) -> _builtins.int:
        """
        Indicates how many IOPS to provision for the disk. This
        sets the number of I/O operations per second that the disk can handle.
        Values must be between 10,000 and 120,000. For more details, see the
        [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk).
        """
        return pulumi.get(self, "provisioned_iops")

    @_builtins.property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> _builtins.int:
        """
        Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
        """
        return pulumi.get(self, "provisioned_throughput")

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        return pulumi.get(self, "resource_manager_tags")

    @_builtins.property
    @pulumi.getter(name="resourcePolicies")
    def resource_policies(self) -> Sequence[_builtins.str]:
        """
        (Optional) -- A list of short names of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
        """
        return pulumi.get(self, "resource_policies")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The name (**not self_link**)
        of the disk (such as those managed by `compute.Disk`) to attach.
        > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> _builtins.str:
        """
        The image from which to
        initialize this disk. This can be one of: the image's `self_link`,
        `projects/{project}/global/images/{image}`,
        `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
        `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
        `{project}/{image}`, `{family}`, or `{image}`.
        > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        return pulumi.get(self, "source_image")

    @_builtins.property
    @pulumi.getter(name="sourceImageEncryptionKeys")
    def source_image_encryption_keys(self) -> Sequence['outputs.GetInstanceTemplateDiskSourceImageEncryptionKeyResult']:
        """
        The customer-supplied encryption key of the source
        image. Required if the source image is protected by a
        customer-supplied encryption key.

        Instance templates do not store customer-supplied
        encryption keys, so you cannot create disks for
        instances in a managed instance group if the source
        images are encrypted with your own keys.
        """
        return pulumi.get(self, "source_image_encryption_keys")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshot")
    def source_snapshot(self) -> _builtins.str:
        """
        The source snapshot to create this disk. When creating
        a new instance, one of initializeParams.sourceSnapshot,
        initializeParams.sourceImage, or disks.source is
        required except for local SSD.
        """
        return pulumi.get(self, "source_snapshot")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshotEncryptionKeys")
    def source_snapshot_encryption_keys(self) -> Sequence['outputs.GetInstanceTemplateDiskSourceSnapshotEncryptionKeyResult']:
        """
        The customer-supplied encryption key of the source snapshot.
        """
        return pulumi.get(self, "source_snapshot_encryption_keys")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceTemplateDiskDiskEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")


@pulumi.output_type
class GetInstanceTemplateDiskSourceImageEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 raw_key: _builtins.str,
                 rsa_encrypted_key: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS
        :param _builtins.str kms_key_service_account: The service account being used for the encryption
               request for the given KMS key. If absent, the Compute
               Engine default service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account being used for the encryption
        request for the given KMS key. If absent, the Compute
        Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> _builtins.str:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class GetInstanceTemplateDiskSourceSnapshotEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 raw_key: _builtins.str,
                 rsa_encrypted_key: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS
        :param _builtins.str kms_key_service_account: The service account being used for the encryption
               request for the given KMS key. If absent, the Compute
               Engine default service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account being used for the encryption
        request for the given KMS key. If absent, the Compute
        Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> _builtins.str:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class GetInstanceTemplateGuestAcceleratorResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int count: The number of the guest accelerator cards exposed to this instance.
        :param _builtins.str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceTemplateNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 access_configs: Sequence['outputs.GetInstanceTemplateNetworkInterfaceAccessConfigResult'],
                 alias_ip_ranges: Sequence['outputs.GetInstanceTemplateNetworkInterfaceAliasIpRangeResult'],
                 internal_ipv6_prefix_length: _builtins.int,
                 ipv6_access_configs: Sequence['outputs.GetInstanceTemplateNetworkInterfaceIpv6AccessConfigResult'],
                 ipv6_access_type: _builtins.str,
                 ipv6_address: _builtins.str,
                 name: _builtins.str,
                 network: _builtins.str,
                 network_attachment: _builtins.str,
                 network_ip: _builtins.str,
                 nic_type: _builtins.str,
                 queue_count: _builtins.int,
                 stack_type: _builtins.str,
                 subnetwork: _builtins.str,
                 subnetwork_project: _builtins.str):
        """
        :param Sequence['GetInstanceTemplateNetworkInterfaceAccessConfigArgs'] access_configs: Access configurations, i.e. IPs via which this
               instance can be accessed via the Internet. Omit to ensure that the instance
               is not accessible from the Internet (this means that ssh provisioners will
               not work unless you are running the provider can send traffic to the instance's
               network (e.g. via tunnel or because it is running on another cloud instance
               on that network). This block can be repeated multiple times. Structure documented below.
        :param Sequence['GetInstanceTemplateNetworkInterfaceAliasIpRangeArgs'] alias_ip_ranges: An
               array of alias IP ranges for this network interface. Can only be specified for network
               interfaces on subnet-mode networks. Structure documented below.
        :param _builtins.int internal_ipv6_prefix_length: The prefix length of the primary internal IPv6 range.
        :param Sequence['GetInstanceTemplateNetworkInterfaceIpv6AccessConfigArgs'] ipv6_access_configs: An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
        :param _builtins.str ipv6_access_type: One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
        :param _builtins.str ipv6_address: An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        :param _builtins.str name: The name of the instance template. One of `name`, `filter` or `self_link_unique` must be provided.
        :param _builtins.str network: The name or self_link of the network to attach this interface to.
               Use `network` attribute for Legacy or Auto subnetted networks and
               `subnetwork` for custom subnetted networks.
        :param _builtins.str network_attachment: The URL of the network attachment that this interface should connect to in the following format: projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}.
        :param _builtins.str network_ip: The private IP address to assign to the instance. If
               empty, the address will be automatically assigned.
        :param _builtins.str nic_type: The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET, MRDMA, and IRDMA
        :param _builtins.int queue_count: The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        :param _builtins.str stack_type: The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
        :param _builtins.str subnetwork: the name of the subnetwork to attach this interface
               to. The subnetwork must exist in the same `region` this instance will be
               created in. Either `network` or `subnetwork` must be provided.
        :param _builtins.str subnetwork_project: The ID of the project in which the subnetwork belongs.
               If it is not provided, the provider project is used.
        """
        pulumi.set(__self__, "access_configs", access_configs)
        pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        pulumi.set(__self__, "internal_ipv6_prefix_length", internal_ipv6_prefix_length)
        pulumi.set(__self__, "ipv6_access_configs", ipv6_access_configs)
        pulumi.set(__self__, "ipv6_access_type", ipv6_access_type)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "network_attachment", network_attachment)
        pulumi.set(__self__, "network_ip", network_ip)
        pulumi.set(__self__, "nic_type", nic_type)
        pulumi.set(__self__, "queue_count", queue_count)
        pulumi.set(__self__, "stack_type", stack_type)
        pulumi.set(__self__, "subnetwork", subnetwork)
        pulumi.set(__self__, "subnetwork_project", subnetwork_project)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Sequence['outputs.GetInstanceTemplateNetworkInterfaceAccessConfigResult']:
        """
        Access configurations, i.e. IPs via which this
        instance can be accessed via the Internet. Omit to ensure that the instance
        is not accessible from the Internet (this means that ssh provisioners will
        not work unless you are running the provider can send traffic to the instance's
        network (e.g. via tunnel or because it is running on another cloud instance
        on that network). This block can be repeated multiple times. Structure documented below.
        """
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Sequence['outputs.GetInstanceTemplateNetworkInterfaceAliasIpRangeResult']:
        """
        An
        array of alias IP ranges for this network interface. Can only be specified for network
        interfaces on subnet-mode networks. Structure documented below.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="internalIpv6PrefixLength")
    def internal_ipv6_prefix_length(self) -> _builtins.int:
        """
        The prefix length of the primary internal IPv6 range.
        """
        return pulumi.get(self, "internal_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessConfigs")
    def ipv6_access_configs(self) -> Sequence['outputs.GetInstanceTemplateNetworkInterfaceIpv6AccessConfigResult']:
        """
        An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
        """
        return pulumi.get(self, "ipv6_access_configs")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessType")
    def ipv6_access_type(self) -> _builtins.str:
        """
        One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
        """
        return pulumi.get(self, "ipv6_access_type")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> _builtins.str:
        """
        An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance template. One of `name`, `filter` or `self_link_unique` must be provided.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The name or self_link of the network to attach this interface to.
        Use `network` attribute for Legacy or Auto subnetted networks and
        `subnetwork` for custom subnetted networks.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="networkAttachment")
    def network_attachment(self) -> _builtins.str:
        """
        The URL of the network attachment that this interface should connect to in the following format: projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}.
        """
        return pulumi.get(self, "network_attachment")

    @_builtins.property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> _builtins.str:
        """
        The private IP address to assign to the instance. If
        empty, the address will be automatically assigned.
        """
        return pulumi.get(self, "network_ip")

    @_builtins.property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> _builtins.str:
        """
        The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET, MRDMA, and IRDMA
        """
        return pulumi.get(self, "nic_type")

    @_builtins.property
    @pulumi.getter(name="queueCount")
    def queue_count(self) -> _builtins.int:
        """
        The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        """
        return pulumi.get(self, "queue_count")

    @_builtins.property
    @pulumi.getter(name="stackType")
    def stack_type(self) -> _builtins.str:
        """
        The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
        """
        return pulumi.get(self, "stack_type")

    @_builtins.property
    @pulumi.getter
    def subnetwork(self) -> _builtins.str:
        """
        the name of the subnetwork to attach this interface
        to. The subnetwork must exist in the same `region` this instance will be
        created in. Either `network` or `subnetwork` must be provided.
        """
        return pulumi.get(self, "subnetwork")

    @_builtins.property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> _builtins.str:
        """
        The ID of the project in which the subnetwork belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "subnetwork_project")


@pulumi.output_type
class GetInstanceTemplateNetworkInterfaceAccessConfigResult(dict):
    def __init__(__self__, *,
                 nat_ip: _builtins.str,
                 network_tier: _builtins.str,
                 public_ptr_domain_name: _builtins.str):
        """
        :param _builtins.str nat_ip: The IP address that will be 1:1 mapped to the instance's
               network ip. If not given, one will be generated.
        :param _builtins.str network_tier: The [networking tier][network-tier] used for configuring
               this instance template. This field can take the following values: PREMIUM or
               STANDARD. If this field is not specified, it is assumed to be PREMIUM.
        :param _builtins.str public_ptr_domain_name: The DNS domain name for the public PTR record.The DNS domain name for the public PTR record.
        """
        pulumi.set(__self__, "nat_ip", nat_ip)
        pulumi.set(__self__, "network_tier", network_tier)
        pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)

    @_builtins.property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> _builtins.str:
        """
        The IP address that will be 1:1 mapped to the instance's
        network ip. If not given, one will be generated.
        """
        return pulumi.get(self, "nat_ip")

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> _builtins.str:
        """
        The [networking tier][network-tier] used for configuring
        this instance template. This field can take the following values: PREMIUM or
        STANDARD. If this field is not specified, it is assumed to be PREMIUM.
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> _builtins.str:
        """
        The DNS domain name for the public PTR record.The DNS domain name for the public PTR record.
        """
        return pulumi.get(self, "public_ptr_domain_name")


@pulumi.output_type
class GetInstanceTemplateNetworkInterfaceAliasIpRangeResult(dict):
    def __init__(__self__, *,
                 ip_cidr_range: _builtins.str,
                 subnetwork_range_name: _builtins.str):
        """
        :param _builtins.str ip_cidr_range: The IP CIDR range represented by this alias IP range. This IP CIDR range
               must belong to the specified subnetwork and cannot contain IP addresses reserved by
               system or used by other network interfaces. At the time of writing only a
               netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
               error.
        :param _builtins.str subnetwork_range_name: The subnetwork secondary range name specifying
               the secondary range from which to allocate the IP CIDR range for this alias IP
               range. If left unspecified, the primary range of the subnetwork will be used.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @_builtins.property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> _builtins.str:
        """
        The IP CIDR range represented by this alias IP range. This IP CIDR range
        must belong to the specified subnetwork and cannot contain IP addresses reserved by
        system or used by other network interfaces. At the time of writing only a
        netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
        error.
        """
        return pulumi.get(self, "ip_cidr_range")

    @_builtins.property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> _builtins.str:
        """
        The subnetwork secondary range name specifying
        the secondary range from which to allocate the IP CIDR range for this alias IP
        range. If left unspecified, the primary range of the subnetwork will be used.
        """
        return pulumi.get(self, "subnetwork_range_name")


@pulumi.output_type
class GetInstanceTemplateNetworkInterfaceIpv6AccessConfigResult(dict):
    def __init__(__self__, *,
                 external_ipv6: _builtins.str,
                 external_ipv6_prefix_length: _builtins.str,
                 name: _builtins.str,
                 network_tier: _builtins.str,
                 public_ptr_domain_name: _builtins.str):
        """
        :param _builtins.str external_ipv6: The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. The field is output only, an IPv6 address from a subnetwork associated with the instance will be allocated dynamically.
        :param _builtins.str external_ipv6_prefix_length: The prefix length of the external IPv6 range.
        :param _builtins.str name: The name of the instance template. One of `name`, `filter` or `self_link_unique` must be provided.
        :param _builtins.str network_tier: The [networking tier][network-tier] used for configuring
               this instance template. This field can take the following values: PREMIUM or
               STANDARD. If this field is not specified, it is assumed to be PREMIUM.
        :param _builtins.str public_ptr_domain_name: The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
        """
        pulumi.set(__self__, "external_ipv6", external_ipv6)
        pulumi.set(__self__, "external_ipv6_prefix_length", external_ipv6_prefix_length)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_tier", network_tier)
        pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)

    @_builtins.property
    @pulumi.getter(name="externalIpv6")
    def external_ipv6(self) -> _builtins.str:
        """
        The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. The field is output only, an IPv6 address from a subnetwork associated with the instance will be allocated dynamically.
        """
        return pulumi.get(self, "external_ipv6")

    @_builtins.property
    @pulumi.getter(name="externalIpv6PrefixLength")
    def external_ipv6_prefix_length(self) -> _builtins.str:
        """
        The prefix length of the external IPv6 range.
        """
        return pulumi.get(self, "external_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance template. One of `name`, `filter` or `self_link_unique` must be provided.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> _builtins.str:
        """
        The [networking tier][network-tier] used for configuring
        this instance template. This field can take the following values: PREMIUM or
        STANDARD. If this field is not specified, it is assumed to be PREMIUM.
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> _builtins.str:
        """
        The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
        """
        return pulumi.get(self, "public_ptr_domain_name")


@pulumi.output_type
class GetInstanceTemplateNetworkPerformanceConfigResult(dict):
    def __init__(__self__, *,
                 total_egress_bandwidth_tier: _builtins.str):
        """
        :param _builtins.str total_egress_bandwidth_tier: The egress bandwidth tier for the instance.
        """
        pulumi.set(__self__, "total_egress_bandwidth_tier", total_egress_bandwidth_tier)

    @_builtins.property
    @pulumi.getter(name="totalEgressBandwidthTier")
    def total_egress_bandwidth_tier(self) -> _builtins.str:
        """
        The egress bandwidth tier for the instance.
        """
        return pulumi.get(self, "total_egress_bandwidth_tier")


@pulumi.output_type
class GetInstanceTemplateReservationAffinityResult(dict):
    def __init__(__self__, *,
                 specific_reservations: Sequence['outputs.GetInstanceTemplateReservationAffinitySpecificReservationResult'],
                 type: _builtins.str):
        """
        :param Sequence['GetInstanceTemplateReservationAffinitySpecificReservationArgs'] specific_reservations: Specifies the label selector for the reservation to use.
        :param _builtins.str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "specific_reservations", specific_reservations)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="specificReservations")
    def specific_reservations(self) -> Sequence['outputs.GetInstanceTemplateReservationAffinitySpecificReservationResult']:
        """
        Specifies the label selector for the reservation to use.
        """
        return pulumi.get(self, "specific_reservations")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceTemplateReservationAffinitySpecificReservationResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key for the node affinity label.
        :param Sequence[_builtins.str] values: Corresponds to the label values of a reservation resource.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key for the node affinity label.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Corresponds to the label values of a reservation resource.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceTemplateSchedulingResult(dict):
    def __init__(__self__, *,
                 automatic_restart: _builtins.bool,
                 availability_domain: _builtins.int,
                 graceful_shutdowns: Sequence['outputs.GetInstanceTemplateSchedulingGracefulShutdownResult'],
                 host_error_timeout_seconds: _builtins.int,
                 instance_termination_action: _builtins.str,
                 local_ssd_recovery_timeouts: Sequence['outputs.GetInstanceTemplateSchedulingLocalSsdRecoveryTimeoutResult'],
                 maintenance_interval: _builtins.str,
                 max_run_durations: Sequence['outputs.GetInstanceTemplateSchedulingMaxRunDurationResult'],
                 min_node_cpus: _builtins.int,
                 node_affinities: Sequence['outputs.GetInstanceTemplateSchedulingNodeAffinityResult'],
                 on_host_maintenance: _builtins.str,
                 on_instance_stop_actions: Sequence['outputs.GetInstanceTemplateSchedulingOnInstanceStopActionResult'],
                 preemptible: _builtins.bool,
                 provisioning_model: _builtins.str,
                 skip_guest_os_shutdown: _builtins.bool,
                 termination_time: _builtins.str):
        """
        :param _builtins.bool automatic_restart: Specifies whether the instance should be
               automatically restarted if it is terminated by Compute Engine (not
               terminated by a user). This defaults to true.
        :param _builtins.int availability_domain: Specifies the availability domain, which this instance should be scheduled on.
        :param Sequence['GetInstanceTemplateSchedulingGracefulShutdownArgs'] graceful_shutdowns: Settings for the instance to perform a graceful shutdown.
        :param _builtins.int host_error_timeout_seconds: Beta Time in seconds for host error detection.
        :param _builtins.str instance_termination_action: Describe the type of termination action for `SPOT` VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
        :param Sequence['GetInstanceTemplateSchedulingLocalSsdRecoveryTimeoutArgs'] local_ssd_recovery_timeouts: Specifies the maximum amount of time a Local Ssd Vm should wait while
                 recovery of the Local Ssd state is attempted. Its value should be in
                 between 0 and 168 hours with hour granularity and the default value being 1
                 hour.
        :param _builtins.str maintenance_interval: Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
        :param Sequence['GetInstanceTemplateSchedulingMaxRunDurationArgs'] max_run_durations: The timeout for new network connections to hosts.
        :param _builtins.int min_node_cpus: Minimum number of cpus for the instance.
        :param Sequence['GetInstanceTemplateSchedulingNodeAffinityArgs'] node_affinities: Specifies node affinities or anti-affinities
               to determine which sole-tenant nodes your instances and managed instance
               groups will use as host systems. Read more on sole-tenant node creation
               [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
               Structure documented below.
        :param _builtins.str on_host_maintenance: Defines the maintenance behavior for this
               instance.
        :param Sequence['GetInstanceTemplateSchedulingOnInstanceStopActionArgs'] on_instance_stop_actions: Defines the behaviour for instances with the instance_termination_action.
        :param _builtins.bool preemptible: Allows instance to be preempted. This defaults to
               false. Read more on this
               [here](https://cloud.google.com/compute/docs/instances/preemptible).
        :param _builtins.str provisioning_model: Describe the type of preemptible VM.
        :param _builtins.bool skip_guest_os_shutdown: Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        :param _builtins.str termination_time: Specifies the timestamp, when the instance will be terminated,
               in RFC3339 text format. If specified, the instance termination action
               will be performed at the termination time.
        """
        pulumi.set(__self__, "automatic_restart", automatic_restart)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "graceful_shutdowns", graceful_shutdowns)
        pulumi.set(__self__, "host_error_timeout_seconds", host_error_timeout_seconds)
        pulumi.set(__self__, "instance_termination_action", instance_termination_action)
        pulumi.set(__self__, "local_ssd_recovery_timeouts", local_ssd_recovery_timeouts)
        pulumi.set(__self__, "maintenance_interval", maintenance_interval)
        pulumi.set(__self__, "max_run_durations", max_run_durations)
        pulumi.set(__self__, "min_node_cpus", min_node_cpus)
        pulumi.set(__self__, "node_affinities", node_affinities)
        pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        pulumi.set(__self__, "on_instance_stop_actions", on_instance_stop_actions)
        pulumi.set(__self__, "preemptible", preemptible)
        pulumi.set(__self__, "provisioning_model", provisioning_model)
        pulumi.set(__self__, "skip_guest_os_shutdown", skip_guest_os_shutdown)
        pulumi.set(__self__, "termination_time", termination_time)

    @_builtins.property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> _builtins.bool:
        """
        Specifies whether the instance should be
        automatically restarted if it is terminated by Compute Engine (not
        terminated by a user). This defaults to true.
        """
        return pulumi.get(self, "automatic_restart")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.int:
        """
        Specifies the availability domain, which this instance should be scheduled on.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="gracefulShutdowns")
    def graceful_shutdowns(self) -> Sequence['outputs.GetInstanceTemplateSchedulingGracefulShutdownResult']:
        """
        Settings for the instance to perform a graceful shutdown.
        """
        return pulumi.get(self, "graceful_shutdowns")

    @_builtins.property
    @pulumi.getter(name="hostErrorTimeoutSeconds")
    def host_error_timeout_seconds(self) -> _builtins.int:
        """
        Beta Time in seconds for host error detection.
        """
        return pulumi.get(self, "host_error_timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="instanceTerminationAction")
    def instance_termination_action(self) -> _builtins.str:
        """
        Describe the type of termination action for `SPOT` VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
        """
        return pulumi.get(self, "instance_termination_action")

    @_builtins.property
    @pulumi.getter(name="localSsdRecoveryTimeouts")
    def local_ssd_recovery_timeouts(self) -> Sequence['outputs.GetInstanceTemplateSchedulingLocalSsdRecoveryTimeoutResult']:
        """
        Specifies the maximum amount of time a Local Ssd Vm should wait while
          recovery of the Local Ssd state is attempted. Its value should be in
          between 0 and 168 hours with hour granularity and the default value being 1
          hour.
        """
        return pulumi.get(self, "local_ssd_recovery_timeouts")

    @_builtins.property
    @pulumi.getter(name="maintenanceInterval")
    def maintenance_interval(self) -> _builtins.str:
        """
        Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
        """
        return pulumi.get(self, "maintenance_interval")

    @_builtins.property
    @pulumi.getter(name="maxRunDurations")
    def max_run_durations(self) -> Sequence['outputs.GetInstanceTemplateSchedulingMaxRunDurationResult']:
        """
        The timeout for new network connections to hosts.
        """
        return pulumi.get(self, "max_run_durations")

    @_builtins.property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> _builtins.int:
        """
        Minimum number of cpus for the instance.
        """
        return pulumi.get(self, "min_node_cpus")

    @_builtins.property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Sequence['outputs.GetInstanceTemplateSchedulingNodeAffinityResult']:
        """
        Specifies node affinities or anti-affinities
        to determine which sole-tenant nodes your instances and managed instance
        groups will use as host systems. Read more on sole-tenant node creation
        [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
        Structure documented below.
        """
        return pulumi.get(self, "node_affinities")

    @_builtins.property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> _builtins.str:
        """
        Defines the maintenance behavior for this
        instance.
        """
        return pulumi.get(self, "on_host_maintenance")

    @_builtins.property
    @pulumi.getter(name="onInstanceStopActions")
    def on_instance_stop_actions(self) -> Sequence['outputs.GetInstanceTemplateSchedulingOnInstanceStopActionResult']:
        """
        Defines the behaviour for instances with the instance_termination_action.
        """
        return pulumi.get(self, "on_instance_stop_actions")

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> _builtins.bool:
        """
        Allows instance to be preempted. This defaults to
        false. Read more on this
        [here](https://cloud.google.com/compute/docs/instances/preemptible).
        """
        return pulumi.get(self, "preemptible")

    @_builtins.property
    @pulumi.getter(name="provisioningModel")
    def provisioning_model(self) -> _builtins.str:
        """
        Describe the type of preemptible VM.
        """
        return pulumi.get(self, "provisioning_model")

    @_builtins.property
    @pulumi.getter(name="skipGuestOsShutdown")
    def skip_guest_os_shutdown(self) -> _builtins.bool:
        """
        Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        """
        return pulumi.get(self, "skip_guest_os_shutdown")

    @_builtins.property
    @pulumi.getter(name="terminationTime")
    def termination_time(self) -> _builtins.str:
        """
        Specifies the timestamp, when the instance will be terminated,
        in RFC3339 text format. If specified, the instance termination action
        will be performed at the termination time.
        """
        return pulumi.get(self, "termination_time")


@pulumi.output_type
class GetInstanceTemplateSchedulingGracefulShutdownResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 max_durations: Sequence['outputs.GetInstanceTemplateSchedulingGracefulShutdownMaxDurationResult']):
        """
        :param _builtins.bool enabled: Opts-in for graceful shutdown.
        :param Sequence['GetInstanceTemplateSchedulingGracefulShutdownMaxDurationArgs'] max_durations: The time allotted for the instance to gracefully shut down.
               										If the graceful shutdown isn't complete after this time, then the instance
               										transitions to the STOPPING state.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "max_durations", max_durations)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Opts-in for graceful shutdown.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.GetInstanceTemplateSchedulingGracefulShutdownMaxDurationResult']:
        """
        The time allotted for the instance to gracefully shut down.
        										If the graceful shutdown isn't complete after this time, then the instance
        										transitions to the STOPPING state.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class GetInstanceTemplateSchedulingGracefulShutdownMaxDurationResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               													resolution. Durations less than one second are represented
               													with a 0 seconds field and a positive nanos field. Must
               													be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               													The value must be between 1 and 3600, which is 3,600 seconds (one hour).
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        													resolution. Durations less than one second are represented
        													with a 0 seconds field and a positive nanos field. Must
        													be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        													The value must be between 1 and 3600, which is 3,600 seconds (one hour).
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetInstanceTemplateSchedulingLocalSsdRecoveryTimeoutResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetInstanceTemplateSchedulingMaxRunDurationResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetInstanceTemplateSchedulingNodeAffinityResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key for the node affinity label.
        :param _builtins.str operator: The operator. Can be `IN` for node-affinities
               or `NOT_IN` for anti-affinities.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key for the node affinity label.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator. Can be `IN` for node-affinities
        or `NOT_IN` for anti-affinities.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceTemplateSchedulingOnInstanceStopActionResult(dict):
    def __init__(__self__, *,
                 discard_local_ssd: _builtins.bool):
        """
        :param _builtins.bool discard_local_ssd: If true, the contents of any attached Local SSD disks will be discarded.
        """
        pulumi.set(__self__, "discard_local_ssd", discard_local_ssd)

    @_builtins.property
    @pulumi.getter(name="discardLocalSsd")
    def discard_local_ssd(self) -> _builtins.bool:
        """
        If true, the contents of any attached Local SSD disks will be discarded.
        """
        return pulumi.get(self, "discard_local_ssd")


@pulumi.output_type
class GetInstanceTemplateServiceAccountResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 scopes: Sequence[_builtins.str]):
        """
        :param _builtins.str email: The service account e-mail address. If not given, the
               default Google Compute Engine service account is used.
        :param Sequence[_builtins.str] scopes: A list of service scopes. Both OAuth2 URLs and gcloud
               short names are supported. To allow full access to all Cloud APIs, use the
               `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The service account e-mail address. If not given, the
        default Google Compute Engine service account is used.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        """
        A list of service scopes. Both OAuth2 URLs and gcloud
        short names are supported. To allow full access to all Cloud APIs, use the
        `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class GetInstanceTemplateShieldedInstanceConfigResult(dict):
    def __init__(__self__, *,
                 enable_integrity_monitoring: _builtins.bool,
                 enable_secure_boot: _builtins.bool,
                 enable_vtpm: _builtins.bool):
        """
        :param _builtins.bool enable_integrity_monitoring: - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        :param _builtins.bool enable_secure_boot: - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        :param _builtins.bool enable_vtpm: - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        """
        pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @_builtins.property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> _builtins.bool:
        """
        - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @_builtins.property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> _builtins.bool:
        """
        - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        """
        return pulumi.get(self, "enable_secure_boot")

    @_builtins.property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> _builtins.bool:
        """
        - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        """
        return pulumi.get(self, "enable_vtpm")


@pulumi.output_type
class GetInterconnectLocationsLocationResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 availability_zone: _builtins.str,
                 available_features: Sequence[_builtins.str],
                 available_link_types: Sequence[_builtins.str],
                 city: _builtins.str,
                 continent: _builtins.str,
                 description: _builtins.str,
                 facility_provider: _builtins.str,
                 facility_provider_facility_id: _builtins.str,
                 name: _builtins.str,
                 peeringdb_facility_id: _builtins.str,
                 self_link: _builtins.str,
                 status: _builtins.str,
                 supports_pzs: _builtins.bool):
        """
        :param _builtins.str address: The postal address of the Point of Presence.
        :param _builtins.str availability_zone: The availability zone for this InterconnectLocation.
        :param Sequence[_builtins.str] available_features: A list of features available at this InterconnectLocation.
        :param Sequence[_builtins.str] available_link_types: A list of link types available at this InterconnectLocation.
        :param _builtins.str city: The city for this location.
        :param _builtins.str continent: The continent for this location.
        :param _builtins.str description: A textual description of the resource.
        :param _builtins.str facility_provider: The name of the provider for this facility.
        :param _builtins.str facility_provider_facility_id: A provider-assigned Identifier for this facility.
        :param _builtins.str peeringdb_facility_id: The PeeringDB facility ID for this facility.
        :param _builtins.str self_link: The URI of the created resource.
        :param _builtins.str status: The status of this InterconnectLocation.
        :param _builtins.bool supports_pzs: Reserved for future use.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "available_features", available_features)
        pulumi.set(__self__, "available_link_types", available_link_types)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "continent", continent)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "facility_provider", facility_provider)
        pulumi.set(__self__, "facility_provider_facility_id", facility_provider_facility_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "peeringdb_facility_id", peeringdb_facility_id)
        pulumi.set(__self__, "self_link", self_link)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "supports_pzs", supports_pzs)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        The postal address of the Point of Presence.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        """
        The availability zone for this InterconnectLocation.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="availableFeatures")
    def available_features(self) -> Sequence[_builtins.str]:
        """
        A list of features available at this InterconnectLocation.
        """
        return pulumi.get(self, "available_features")

    @_builtins.property
    @pulumi.getter(name="availableLinkTypes")
    def available_link_types(self) -> Sequence[_builtins.str]:
        """
        A list of link types available at this InterconnectLocation.
        """
        return pulumi.get(self, "available_link_types")

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        """
        The city for this location.
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter
    def continent(self) -> _builtins.str:
        """
        The continent for this location.
        """
        return pulumi.get(self, "continent")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A textual description of the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="facilityProvider")
    def facility_provider(self) -> _builtins.str:
        """
        The name of the provider for this facility.
        """
        return pulumi.get(self, "facility_provider")

    @_builtins.property
    @pulumi.getter(name="facilityProviderFacilityId")
    def facility_provider_facility_id(self) -> _builtins.str:
        """
        A provider-assigned Identifier for this facility.
        """
        return pulumi.get(self, "facility_provider_facility_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="peeringdbFacilityId")
    def peeringdb_facility_id(self) -> _builtins.str:
        """
        The PeeringDB facility ID for this facility.
        """
        return pulumi.get(self, "peeringdb_facility_id")

    @_builtins.property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> _builtins.str:
        """
        The URI of the created resource.
        """
        return pulumi.get(self, "self_link")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of this InterconnectLocation.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="supportsPzs")
    def supports_pzs(self) -> _builtins.bool:
        """
        Reserved for future use.
        """
        return pulumi.get(self, "supports_pzs")


@pulumi.output_type
class GetMachineTypesMachineTypeResult(dict):
    def __init__(__self__, *,
                 accelerators: Sequence['outputs.GetMachineTypesMachineTypeAcceleratorResult'],
                 bundled_local_ssds: Sequence['outputs.GetMachineTypesMachineTypeBundledLocalSsdResult'],
                 deprecateds: Sequence['outputs.GetMachineTypesMachineTypeDeprecatedResult'],
                 description: _builtins.str,
                 guest_cpus: _builtins.int,
                 is_shared_cpus: _builtins.bool,
                 maximum_persistent_disks: _builtins.int,
                 maximum_persistent_disks_size_gb: _builtins.int,
                 memory_mb: _builtins.int,
                 name: _builtins.str,
                 self_link: _builtins.str):
        """
        :param Sequence['GetMachineTypesMachineTypeAcceleratorArgs'] accelerators: A list of accelerator configurations assigned to this machine type. Structure is documented below.
        :param Sequence['GetMachineTypesMachineTypeBundledLocalSsdArgs'] bundled_local_ssds: The configuration of bundled local SSD for the machine type. Structure is documented below.
        :param Sequence['GetMachineTypesMachineTypeDeprecatedArgs'] deprecateds: The deprecation status associated with this machine type. Structure is documented below.
        :param _builtins.str description: A textual description of the machine type.
        :param _builtins.int guest_cpus: The number of virtual CPUs that are available to the instance.
        :param _builtins.bool is_shared_cpus: Whether this machine type has a shared CPU.
        :param _builtins.int maximum_persistent_disks: The maximum persistent disks allowed.
        :param _builtins.int maximum_persistent_disks_size_gb: The maximum total persistent disks size (GB) allowed.
        :param _builtins.int memory_mb: The amount of physical memory available to the instance, defined in MB.
        :param _builtins.str name: The name of the machine type.
        :param _builtins.str self_link: The server-defined URL for the machine type.
        """
        pulumi.set(__self__, "accelerators", accelerators)
        pulumi.set(__self__, "bundled_local_ssds", bundled_local_ssds)
        pulumi.set(__self__, "deprecateds", deprecateds)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "guest_cpus", guest_cpus)
        pulumi.set(__self__, "is_shared_cpus", is_shared_cpus)
        pulumi.set(__self__, "maximum_persistent_disks", maximum_persistent_disks)
        pulumi.set(__self__, "maximum_persistent_disks_size_gb", maximum_persistent_disks_size_gb)
        pulumi.set(__self__, "memory_mb", memory_mb)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "self_link", self_link)

    @_builtins.property
    @pulumi.getter
    def accelerators(self) -> Sequence['outputs.GetMachineTypesMachineTypeAcceleratorResult']:
        """
        A list of accelerator configurations assigned to this machine type. Structure is documented below.
        """
        return pulumi.get(self, "accelerators")

    @_builtins.property
    @pulumi.getter(name="bundledLocalSsds")
    def bundled_local_ssds(self) -> Sequence['outputs.GetMachineTypesMachineTypeBundledLocalSsdResult']:
        """
        The configuration of bundled local SSD for the machine type. Structure is documented below.
        """
        return pulumi.get(self, "bundled_local_ssds")

    @_builtins.property
    @pulumi.getter
    def deprecateds(self) -> Sequence['outputs.GetMachineTypesMachineTypeDeprecatedResult']:
        """
        The deprecation status associated with this machine type. Structure is documented below.
        """
        return pulumi.get(self, "deprecateds")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A textual description of the machine type.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="guestCpus")
    def guest_cpus(self) -> _builtins.int:
        """
        The number of virtual CPUs that are available to the instance.
        """
        return pulumi.get(self, "guest_cpus")

    @_builtins.property
    @pulumi.getter(name="isSharedCpus")
    def is_shared_cpus(self) -> _builtins.bool:
        """
        Whether this machine type has a shared CPU.
        """
        return pulumi.get(self, "is_shared_cpus")

    @_builtins.property
    @pulumi.getter(name="maximumPersistentDisks")
    def maximum_persistent_disks(self) -> _builtins.int:
        """
        The maximum persistent disks allowed.
        """
        return pulumi.get(self, "maximum_persistent_disks")

    @_builtins.property
    @pulumi.getter(name="maximumPersistentDisksSizeGb")
    def maximum_persistent_disks_size_gb(self) -> _builtins.int:
        """
        The maximum total persistent disks size (GB) allowed.
        """
        return pulumi.get(self, "maximum_persistent_disks_size_gb")

    @_builtins.property
    @pulumi.getter(name="memoryMb")
    def memory_mb(self) -> _builtins.int:
        """
        The amount of physical memory available to the instance, defined in MB.
        """
        return pulumi.get(self, "memory_mb")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the machine type.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> _builtins.str:
        """
        The server-defined URL for the machine type.
        """
        return pulumi.get(self, "self_link")


@pulumi.output_type
class GetMachineTypesMachineTypeAcceleratorResult(dict):
    def __init__(__self__, *,
                 guest_accelerator_count: _builtins.int,
                 guest_accelerator_type: _builtins.str):
        """
        :param _builtins.int guest_accelerator_count: Number of accelerator cards exposed to the guest.
        :param _builtins.str guest_accelerator_type: The accelerator type resource name, not a full URL, e.g. `nvidia-tesla-t4`.
        """
        pulumi.set(__self__, "guest_accelerator_count", guest_accelerator_count)
        pulumi.set(__self__, "guest_accelerator_type", guest_accelerator_type)

    @_builtins.property
    @pulumi.getter(name="guestAcceleratorCount")
    def guest_accelerator_count(self) -> _builtins.int:
        """
        Number of accelerator cards exposed to the guest.
        """
        return pulumi.get(self, "guest_accelerator_count")

    @_builtins.property
    @pulumi.getter(name="guestAcceleratorType")
    def guest_accelerator_type(self) -> _builtins.str:
        """
        The accelerator type resource name, not a full URL, e.g. `nvidia-tesla-t4`.
        """
        return pulumi.get(self, "guest_accelerator_type")


@pulumi.output_type
class GetMachineTypesMachineTypeBundledLocalSsdResult(dict):
    def __init__(__self__, *,
                 default_interface: _builtins.str,
                 partition_count: _builtins.int):
        """
        :param _builtins.str default_interface: The default disk interface if the interface is not specified.
        :param _builtins.int partition_count: The number of partitions.
        """
        pulumi.set(__self__, "default_interface", default_interface)
        pulumi.set(__self__, "partition_count", partition_count)

    @_builtins.property
    @pulumi.getter(name="defaultInterface")
    def default_interface(self) -> _builtins.str:
        """
        The default disk interface if the interface is not specified.
        """
        return pulumi.get(self, "default_interface")

    @_builtins.property
    @pulumi.getter(name="partitionCount")
    def partition_count(self) -> _builtins.int:
        """
        The number of partitions.
        """
        return pulumi.get(self, "partition_count")


@pulumi.output_type
class GetMachineTypesMachineTypeDeprecatedResult(dict):
    def __init__(__self__, *,
                 replacement: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str replacement: The URL of the suggested replacement for a deprecated machine type.
        :param _builtins.str state: The deprecation state of this resource. This can be `ACTIVE`, `DEPRECATED`, `OBSOLETE`, or `DELETED`.
        """
        pulumi.set(__self__, "replacement", replacement)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def replacement(self) -> _builtins.str:
        """
        The URL of the suggested replacement for a deprecated machine type.
        """
        return pulumi.get(self, "replacement")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The deprecation state of this resource. This can be `ACTIVE`, `DEPRECATED`, `OBSOLETE`, or `DELETED`.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetNetworkAttachmentConnectionEndpointResult(dict):
    def __init__(__self__, *,
                 ip_address: _builtins.str,
                 project_id_or_num: _builtins.str,
                 secondary_ip_cidr_ranges: _builtins.str,
                 status: _builtins.str,
                 subnetwork: _builtins.str):
        """
        :param _builtins.str ip_address: The IPv4 address assigned to the producer instance network interface. This value will be a range in case of Serverless.
        :param _builtins.str project_id_or_num: The project id or number of the interface to which the IP was assigned.
        :param _builtins.str secondary_ip_cidr_ranges: Alias IP ranges from the same subnetwork.
        :param _builtins.str status: The status of a connected endpoint to this network attachment.
        :param _builtins.str subnetwork: The subnetwork used to assign the IP to the producer instance network interface.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "project_id_or_num", project_id_or_num)
        pulumi.set(__self__, "secondary_ip_cidr_ranges", secondary_ip_cidr_ranges)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "subnetwork", subnetwork)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        The IPv4 address assigned to the producer instance network interface. This value will be a range in case of Serverless.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="projectIdOrNum")
    def project_id_or_num(self) -> _builtins.str:
        """
        The project id or number of the interface to which the IP was assigned.
        """
        return pulumi.get(self, "project_id_or_num")

    @_builtins.property
    @pulumi.getter(name="secondaryIpCidrRanges")
    def secondary_ip_cidr_ranges(self) -> _builtins.str:
        """
        Alias IP ranges from the same subnetwork.
        """
        return pulumi.get(self, "secondary_ip_cidr_ranges")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of a connected endpoint to this network attachment.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def subnetwork(self) -> _builtins.str:
        """
        The subnetwork used to assign the IP to the producer instance network interface.
        """
        return pulumi.get(self, "subnetwork")


@pulumi.output_type
class GetRegionBackendServiceBackendResult(dict):
    def __init__(__self__, *,
                 balancing_mode: _builtins.str,
                 capacity_scaler: _builtins.float,
                 custom_metrics: Sequence['outputs.GetRegionBackendServiceBackendCustomMetricResult'],
                 description: _builtins.str,
                 failover: _builtins.bool,
                 group: _builtins.str,
                 max_connections: _builtins.int,
                 max_connections_per_endpoint: _builtins.int,
                 max_connections_per_instance: _builtins.int,
                 max_in_flight_requests: _builtins.int,
                 max_in_flight_requests_per_endpoint: _builtins.int,
                 max_in_flight_requests_per_instance: _builtins.int,
                 max_rate: _builtins.int,
                 max_rate_per_endpoint: _builtins.float,
                 max_rate_per_instance: _builtins.float,
                 max_utilization: _builtins.float,
                 traffic_duration: _builtins.str):
        """
        :param _builtins.str balancing_mode: Specifies the balancing mode for this backend.
               
               See the [Backend Services Overview](https://cloud.google.com/load-balancing/docs/backend-service#balancing-mode)
               for an explanation of load balancing modes. Default value: "UTILIZATION" Possible values: ["UTILIZATION", "RATE", "CONNECTION", "CUSTOM_METRICS"]
        :param _builtins.float capacity_scaler: A multiplier applied to the group's maximum servicing capacity
               (based on UTILIZATION, RATE or CONNECTION).
               
               ~>**NOTE**: This field cannot be set for
               INTERNAL region backend services (default loadBalancingScheme),
               but is required for non-INTERNAL backend service. The total
               capacity_scaler for all backends must be non-zero.
               
               A setting of 0 means the group is completely drained, offering
               0% of its available Capacity. Valid range is [0.0,1.0].
        :param Sequence['GetRegionBackendServiceBackendCustomMetricArgs'] custom_metrics: The set of custom metrics that are used for <code>CUSTOM_METRICS</code> BalancingMode.
        :param _builtins.str description: An optional description of this resource.
               Provide this property when you create the resource.
        :param _builtins.bool failover: This field designates whether this is a failover backend. More
               than one failover backend can be configured for a given RegionBackendService.
        :param _builtins.str group: The fully-qualified URL of an Instance Group or Network Endpoint
               Group resource. In case of instance group this defines the list
               of instances that serve traffic. Member virtual machine
               instances from each instance group must live in the same zone as
               the instance group itself. No two backends in a backend service
               are allowed to use same Instance Group resource.
               
               For Network Endpoint Groups this defines list of endpoints. All
               endpoints of Network Endpoint Group must be hosted on instances
               located in the same zone as the Network Endpoint Group.
               
               Backend services cannot mix Instance Group and
               Network Endpoint Group backends.
               
               When the 'load_balancing_scheme' is INTERNAL, only instance groups
               are supported.
               
               Note that you must specify an Instance Group or Network Endpoint
               Group resource using the fully-qualified URL, rather than a
               partial URL.
        :param _builtins.int max_connections: The max number of simultaneous connections for the group. Can
               be used with either CONNECTION or UTILIZATION balancing modes.
               Cannot be set for INTERNAL backend services.
               
               For CONNECTION mode, either maxConnections or one
               of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
               as appropriate for group type, must be set.
        :param _builtins.int max_connections_per_endpoint: The max number of simultaneous connections that a single backend
               network endpoint can handle. Cannot be set
               for INTERNAL backend services.
               
               This is used to calculate the capacity of the group. Can be
               used in either CONNECTION or UTILIZATION balancing modes. For
               CONNECTION mode, either maxConnections or
               maxConnectionsPerEndpoint must be set.
        :param _builtins.int max_connections_per_instance: The max number of simultaneous connections that a single
               backend instance can handle. Cannot be set for INTERNAL backend
               services.
               
               This is used to calculate the capacity of the group.
               Can be used in either CONNECTION or UTILIZATION balancing modes.
               For CONNECTION mode, either maxConnections or
               maxConnectionsPerInstance must be set.
        :param _builtins.int max_in_flight_requests: Defines a maximum number of in-flight requests for the whole NEG
               or instance group. Not available if backend's balancingMode is RATE
               or CONNECTION.
        :param _builtins.int max_in_flight_requests_per_endpoint: Defines a maximum number of in-flight requests for a single endpoint.
               Not available if backend's balancingMode is RATE or CONNECTION.
        :param _builtins.int max_in_flight_requests_per_instance: Defines a maximum number of in-flight requests for a single VM.
               Not available if backend's balancingMode is RATE or CONNECTION.
        :param _builtins.int max_rate: The max requests per second (RPS) of the group. Cannot be set
               for INTERNAL backend services.
               
               Can be used with either RATE or UTILIZATION balancing modes,
               but required if RATE mode. Either maxRate or one
               of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
               group type, must be set.
        :param _builtins.float max_rate_per_endpoint: The max requests per second (RPS) that a single backend network
               endpoint can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerEndpoint must be set. Cannot be set
               for INTERNAL backend services.
        :param _builtins.float max_rate_per_instance: The max requests per second (RPS) that a single backend
               instance can handle. This is used to calculate the capacity of
               the group. Can be used in either balancing mode. For RATE mode,
               either maxRate or maxRatePerInstance must be set. Cannot be set
               for INTERNAL backend services.
        :param _builtins.float max_utilization: Used when balancingMode is UTILIZATION. This ratio defines the
               CPU utilization target for the group. Valid range is [0.0, 1.0].
               Cannot be set for INTERNAL backend services.
        :param _builtins.str traffic_duration: This field specifies how long a connection should be kept alive for:
               - LONG: Most of the requests are expected to take more than multiple
                 seconds to finish.
               - SHORT: Most requests are expected to finish with a sub-second latency. Possible values: ["LONG", "SHORT"]
        """
        pulumi.set(__self__, "balancing_mode", balancing_mode)
        pulumi.set(__self__, "capacity_scaler", capacity_scaler)
        pulumi.set(__self__, "custom_metrics", custom_metrics)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "failover", failover)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "max_connections", max_connections)
        pulumi.set(__self__, "max_connections_per_endpoint", max_connections_per_endpoint)
        pulumi.set(__self__, "max_connections_per_instance", max_connections_per_instance)
        pulumi.set(__self__, "max_in_flight_requests", max_in_flight_requests)
        pulumi.set(__self__, "max_in_flight_requests_per_endpoint", max_in_flight_requests_per_endpoint)
        pulumi.set(__self__, "max_in_flight_requests_per_instance", max_in_flight_requests_per_instance)
        pulumi.set(__self__, "max_rate", max_rate)
        pulumi.set(__self__, "max_rate_per_endpoint", max_rate_per_endpoint)
        pulumi.set(__self__, "max_rate_per_instance", max_rate_per_instance)
        pulumi.set(__self__, "max_utilization", max_utilization)
        pulumi.set(__self__, "traffic_duration", traffic_duration)

    @_builtins.property
    @pulumi.getter(name="balancingMode")
    def balancing_mode(self) -> _builtins.str:
        """
        Specifies the balancing mode for this backend.

        See the [Backend Services Overview](https://cloud.google.com/load-balancing/docs/backend-service#balancing-mode)
        for an explanation of load balancing modes. Default value: "UTILIZATION" Possible values: ["UTILIZATION", "RATE", "CONNECTION", "CUSTOM_METRICS"]
        """
        return pulumi.get(self, "balancing_mode")

    @_builtins.property
    @pulumi.getter(name="capacityScaler")
    def capacity_scaler(self) -> _builtins.float:
        """
        A multiplier applied to the group's maximum servicing capacity
        (based on UTILIZATION, RATE or CONNECTION).

        ~>**NOTE**: This field cannot be set for
        INTERNAL region backend services (default loadBalancingScheme),
        but is required for non-INTERNAL backend service. The total
        capacity_scaler for all backends must be non-zero.

        A setting of 0 means the group is completely drained, offering
        0% of its available Capacity. Valid range is [0.0,1.0].
        """
        return pulumi.get(self, "capacity_scaler")

    @_builtins.property
    @pulumi.getter(name="customMetrics")
    def custom_metrics(self) -> Sequence['outputs.GetRegionBackendServiceBackendCustomMetricResult']:
        """
        The set of custom metrics that are used for <code>CUSTOM_METRICS</code> BalancingMode.
        """
        return pulumi.get(self, "custom_metrics")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        An optional description of this resource.
        Provide this property when you create the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def failover(self) -> _builtins.bool:
        """
        This field designates whether this is a failover backend. More
        than one failover backend can be configured for a given RegionBackendService.
        """
        return pulumi.get(self, "failover")

    @_builtins.property
    @pulumi.getter
    def group(self) -> _builtins.str:
        """
        The fully-qualified URL of an Instance Group or Network Endpoint
        Group resource. In case of instance group this defines the list
        of instances that serve traffic. Member virtual machine
        instances from each instance group must live in the same zone as
        the instance group itself. No two backends in a backend service
        are allowed to use same Instance Group resource.

        For Network Endpoint Groups this defines list of endpoints. All
        endpoints of Network Endpoint Group must be hosted on instances
        located in the same zone as the Network Endpoint Group.

        Backend services cannot mix Instance Group and
        Network Endpoint Group backends.

        When the 'load_balancing_scheme' is INTERNAL, only instance groups
        are supported.

        Note that you must specify an Instance Group or Network Endpoint
        Group resource using the fully-qualified URL, rather than a
        partial URL.
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> _builtins.int:
        """
        The max number of simultaneous connections for the group. Can
        be used with either CONNECTION or UTILIZATION balancing modes.
        Cannot be set for INTERNAL backend services.

        For CONNECTION mode, either maxConnections or one
        of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
        as appropriate for group type, must be set.
        """
        return pulumi.get(self, "max_connections")

    @_builtins.property
    @pulumi.getter(name="maxConnectionsPerEndpoint")
    def max_connections_per_endpoint(self) -> _builtins.int:
        """
        The max number of simultaneous connections that a single backend
        network endpoint can handle. Cannot be set
        for INTERNAL backend services.

        This is used to calculate the capacity of the group. Can be
        used in either CONNECTION or UTILIZATION balancing modes. For
        CONNECTION mode, either maxConnections or
        maxConnectionsPerEndpoint must be set.
        """
        return pulumi.get(self, "max_connections_per_endpoint")

    @_builtins.property
    @pulumi.getter(name="maxConnectionsPerInstance")
    def max_connections_per_instance(self) -> _builtins.int:
        """
        The max number of simultaneous connections that a single
        backend instance can handle. Cannot be set for INTERNAL backend
        services.

        This is used to calculate the capacity of the group.
        Can be used in either CONNECTION or UTILIZATION balancing modes.
        For CONNECTION mode, either maxConnections or
        maxConnectionsPerInstance must be set.
        """
        return pulumi.get(self, "max_connections_per_instance")

    @_builtins.property
    @pulumi.getter(name="maxInFlightRequests")
    def max_in_flight_requests(self) -> _builtins.int:
        """
        Defines a maximum number of in-flight requests for the whole NEG
        or instance group. Not available if backend's balancingMode is RATE
        or CONNECTION.
        """
        return pulumi.get(self, "max_in_flight_requests")

    @_builtins.property
    @pulumi.getter(name="maxInFlightRequestsPerEndpoint")
    def max_in_flight_requests_per_endpoint(self) -> _builtins.int:
        """
        Defines a maximum number of in-flight requests for a single endpoint.
        Not available if backend's balancingMode is RATE or CONNECTION.
        """
        return pulumi.get(self, "max_in_flight_requests_per_endpoint")

    @_builtins.property
    @pulumi.getter(name="maxInFlightRequestsPerInstance")
    def max_in_flight_requests_per_instance(self) -> _builtins.int:
        """
        Defines a maximum number of in-flight requests for a single VM.
        Not available if backend's balancingMode is RATE or CONNECTION.
        """
        return pulumi.get(self, "max_in_flight_requests_per_instance")

    @_builtins.property
    @pulumi.getter(name="maxRate")
    def max_rate(self) -> _builtins.int:
        """
        The max requests per second (RPS) of the group. Cannot be set
        for INTERNAL backend services.

        Can be used with either RATE or UTILIZATION balancing modes,
        but required if RATE mode. Either maxRate or one
        of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
        group type, must be set.
        """
        return pulumi.get(self, "max_rate")

    @_builtins.property
    @pulumi.getter(name="maxRatePerEndpoint")
    def max_rate_per_endpoint(self) -> _builtins.float:
        """
        The max requests per second (RPS) that a single backend network
        endpoint can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerEndpoint must be set. Cannot be set
        for INTERNAL backend services.
        """
        return pulumi.get(self, "max_rate_per_endpoint")

    @_builtins.property
    @pulumi.getter(name="maxRatePerInstance")
    def max_rate_per_instance(self) -> _builtins.float:
        """
        The max requests per second (RPS) that a single backend
        instance can handle. This is used to calculate the capacity of
        the group. Can be used in either balancing mode. For RATE mode,
        either maxRate or maxRatePerInstance must be set. Cannot be set
        for INTERNAL backend services.
        """
        return pulumi.get(self, "max_rate_per_instance")

    @_builtins.property
    @pulumi.getter(name="maxUtilization")
    def max_utilization(self) -> _builtins.float:
        """
        Used when balancingMode is UTILIZATION. This ratio defines the
        CPU utilization target for the group. Valid range is [0.0, 1.0].
        Cannot be set for INTERNAL backend services.
        """
        return pulumi.get(self, "max_utilization")

    @_builtins.property
    @pulumi.getter(name="trafficDuration")
    def traffic_duration(self) -> _builtins.str:
        """
        This field specifies how long a connection should be kept alive for:
        - LONG: Most of the requests are expected to take more than multiple
          seconds to finish.
        - SHORT: Most requests are expected to finish with a sub-second latency. Possible values: ["LONG", "SHORT"]
        """
        return pulumi.get(self, "traffic_duration")


@pulumi.output_type
class GetRegionBackendServiceBackendCustomMetricResult(dict):
    def __init__(__self__, *,
                 dry_run: _builtins.bool,
                 max_utilization: _builtins.float,
                 name: _builtins.str):
        """
        :param _builtins.bool dry_run: If true, the metric data is collected and reported to Cloud
               Monitoring, but is not used for load balancing.
        :param _builtins.float max_utilization: Optional parameter to define a target utilization for the Custom Metrics
               balancing mode. The valid range is <code>[0.0, 1.0]</code>.
        :param _builtins.str name: The name of the regional backend service.
        """
        pulumi.set(__self__, "dry_run", dry_run)
        pulumi.set(__self__, "max_utilization", max_utilization)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> _builtins.bool:
        """
        If true, the metric data is collected and reported to Cloud
        Monitoring, but is not used for load balancing.
        """
        return pulumi.get(self, "dry_run")

    @_builtins.property
    @pulumi.getter(name="maxUtilization")
    def max_utilization(self) -> _builtins.float:
        """
        Optional parameter to define a target utilization for the Custom Metrics
        balancing mode. The valid range is <code>[0.0, 1.0]</code>.
        """
        return pulumi.get(self, "max_utilization")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the regional backend service.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRegionBackendServiceCdnPolicyResult(dict):
    def __init__(__self__, *,
                 cache_key_policies: Sequence['outputs.GetRegionBackendServiceCdnPolicyCacheKeyPolicyResult'],
                 cache_mode: _builtins.str,
                 client_ttl: _builtins.int,
                 default_ttl: _builtins.int,
                 max_ttl: _builtins.int,
                 negative_caching: _builtins.bool,
                 negative_caching_policies: Sequence['outputs.GetRegionBackendServiceCdnPolicyNegativeCachingPolicyResult'],
                 serve_while_stale: _builtins.int,
                 signed_url_cache_max_age_sec: _builtins.int):
        """
        :param Sequence['GetRegionBackendServiceCdnPolicyCacheKeyPolicyArgs'] cache_key_policies: The CacheKeyPolicy for this CdnPolicy.
        :param _builtins.str cache_mode: Specifies the cache setting for all responses from this backend.
               The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC Possible values: ["USE_ORIGIN_HEADERS", "FORCE_CACHE_ALL", "CACHE_ALL_STATIC"]
        :param _builtins.int client_ttl: Specifies the maximum allowed TTL for cached content served by this origin.
        :param _builtins.int default_ttl: Specifies the default TTL for cached content served by this origin for responses
               that do not have an existing valid TTL (max-age or s-max-age).
        :param _builtins.int max_ttl: Specifies the maximum allowed TTL for cached content served by this origin.
        :param _builtins.bool negative_caching: Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        :param Sequence['GetRegionBackendServiceCdnPolicyNegativeCachingPolicyArgs'] negative_caching_policies: Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
               Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
        :param _builtins.int serve_while_stale: Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        :param _builtins.int signed_url_cache_max_age_sec: Maximum number of seconds the response to a signed URL request
               will be considered fresh, defaults to 1hr (3600s). After this
               time period, the response will be revalidated before
               being served.
               
               When serving responses to signed URL requests, Cloud CDN will
               internally behave as though all responses from this backend had a
               "Cache-Control: public, max-age=[TTL]" header, regardless of any
               existing Cache-Control header. The actual headers served in
               responses will not be altered.
        """
        pulumi.set(__self__, "cache_key_policies", cache_key_policies)
        pulumi.set(__self__, "cache_mode", cache_mode)
        pulumi.set(__self__, "client_ttl", client_ttl)
        pulumi.set(__self__, "default_ttl", default_ttl)
        pulumi.set(__self__, "max_ttl", max_ttl)
        pulumi.set(__self__, "negative_caching", negative_caching)
        pulumi.set(__self__, "negative_caching_policies", negative_caching_policies)
        pulumi.set(__self__, "serve_while_stale", serve_while_stale)
        pulumi.set(__self__, "signed_url_cache_max_age_sec", signed_url_cache_max_age_sec)

    @_builtins.property
    @pulumi.getter(name="cacheKeyPolicies")
    def cache_key_policies(self) -> Sequence['outputs.GetRegionBackendServiceCdnPolicyCacheKeyPolicyResult']:
        """
        The CacheKeyPolicy for this CdnPolicy.
        """
        return pulumi.get(self, "cache_key_policies")

    @_builtins.property
    @pulumi.getter(name="cacheMode")
    def cache_mode(self) -> _builtins.str:
        """
        Specifies the cache setting for all responses from this backend.
        The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC Possible values: ["USE_ORIGIN_HEADERS", "FORCE_CACHE_ALL", "CACHE_ALL_STATIC"]
        """
        return pulumi.get(self, "cache_mode")

    @_builtins.property
    @pulumi.getter(name="clientTtl")
    def client_ttl(self) -> _builtins.int:
        """
        Specifies the maximum allowed TTL for cached content served by this origin.
        """
        return pulumi.get(self, "client_ttl")

    @_builtins.property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> _builtins.int:
        """
        Specifies the default TTL for cached content served by this origin for responses
        that do not have an existing valid TTL (max-age or s-max-age).
        """
        return pulumi.get(self, "default_ttl")

    @_builtins.property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> _builtins.int:
        """
        Specifies the maximum allowed TTL for cached content served by this origin.
        """
        return pulumi.get(self, "max_ttl")

    @_builtins.property
    @pulumi.getter(name="negativeCaching")
    def negative_caching(self) -> _builtins.bool:
        """
        Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
        """
        return pulumi.get(self, "negative_caching")

    @_builtins.property
    @pulumi.getter(name="negativeCachingPolicies")
    def negative_caching_policies(self) -> Sequence['outputs.GetRegionBackendServiceCdnPolicyNegativeCachingPolicyResult']:
        """
        Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
        Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
        """
        return pulumi.get(self, "negative_caching_policies")

    @_builtins.property
    @pulumi.getter(name="serveWhileStale")
    def serve_while_stale(self) -> _builtins.int:
        """
        Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
        """
        return pulumi.get(self, "serve_while_stale")

    @_builtins.property
    @pulumi.getter(name="signedUrlCacheMaxAgeSec")
    def signed_url_cache_max_age_sec(self) -> _builtins.int:
        """
        Maximum number of seconds the response to a signed URL request
        will be considered fresh, defaults to 1hr (3600s). After this
        time period, the response will be revalidated before
        being served.

        When serving responses to signed URL requests, Cloud CDN will
        internally behave as though all responses from this backend had a
        "Cache-Control: public, max-age=[TTL]" header, regardless of any
        existing Cache-Control header. The actual headers served in
        responses will not be altered.
        """
        return pulumi.get(self, "signed_url_cache_max_age_sec")


@pulumi.output_type
class GetRegionBackendServiceCdnPolicyCacheKeyPolicyResult(dict):
    def __init__(__self__, *,
                 include_host: _builtins.bool,
                 include_named_cookies: Sequence[_builtins.str],
                 include_protocol: _builtins.bool,
                 include_query_string: _builtins.bool,
                 query_string_blacklists: Sequence[_builtins.str],
                 query_string_whitelists: Sequence[_builtins.str]):
        """
        :param _builtins.bool include_host: If true requests to different hosts will be cached separately.
        :param Sequence[_builtins.str] include_named_cookies: Names of cookies to include in cache keys.
        :param _builtins.bool include_protocol: If true, http and https requests will be cached separately.
        :param _builtins.bool include_query_string: If true, include query string parameters in the cache key
               according to query_string_whitelist and
               query_string_blacklist. If neither is set, the entire query
               string will be included.
               
               If false, the query string will be excluded from the cache
               key entirely.
        :param Sequence[_builtins.str] query_string_blacklists: Names of query string parameters to exclude in cache keys.
               
               All other parameters will be included. Either specify
               query_string_whitelist or query_string_blacklist, not both.
               '&' and '=' will be percent encoded and not treated as
               delimiters.
        :param Sequence[_builtins.str] query_string_whitelists: Names of query string parameters to include in cache keys.
               
               All other parameters will be excluded. Either specify
               query_string_whitelist or query_string_blacklist, not both.
               '&' and '=' will be percent encoded and not treated as
               delimiters.
        """
        pulumi.set(__self__, "include_host", include_host)
        pulumi.set(__self__, "include_named_cookies", include_named_cookies)
        pulumi.set(__self__, "include_protocol", include_protocol)
        pulumi.set(__self__, "include_query_string", include_query_string)
        pulumi.set(__self__, "query_string_blacklists", query_string_blacklists)
        pulumi.set(__self__, "query_string_whitelists", query_string_whitelists)

    @_builtins.property
    @pulumi.getter(name="includeHost")
    def include_host(self) -> _builtins.bool:
        """
        If true requests to different hosts will be cached separately.
        """
        return pulumi.get(self, "include_host")

    @_builtins.property
    @pulumi.getter(name="includeNamedCookies")
    def include_named_cookies(self) -> Sequence[_builtins.str]:
        """
        Names of cookies to include in cache keys.
        """
        return pulumi.get(self, "include_named_cookies")

    @_builtins.property
    @pulumi.getter(name="includeProtocol")
    def include_protocol(self) -> _builtins.bool:
        """
        If true, http and https requests will be cached separately.
        """
        return pulumi.get(self, "include_protocol")

    @_builtins.property
    @pulumi.getter(name="includeQueryString")
    def include_query_string(self) -> _builtins.bool:
        """
        If true, include query string parameters in the cache key
        according to query_string_whitelist and
        query_string_blacklist. If neither is set, the entire query
        string will be included.

        If false, the query string will be excluded from the cache
        key entirely.
        """
        return pulumi.get(self, "include_query_string")

    @_builtins.property
    @pulumi.getter(name="queryStringBlacklists")
    def query_string_blacklists(self) -> Sequence[_builtins.str]:
        """
        Names of query string parameters to exclude in cache keys.

        All other parameters will be included. Either specify
        query_string_whitelist or query_string_blacklist, not both.
        '&' and '=' will be percent encoded and not treated as
        delimiters.
        """
        return pulumi.get(self, "query_string_blacklists")

    @_builtins.property
    @pulumi.getter(name="queryStringWhitelists")
    def query_string_whitelists(self) -> Sequence[_builtins.str]:
        """
        Names of query string parameters to include in cache keys.

        All other parameters will be excluded. Either specify
        query_string_whitelist or query_string_blacklist, not both.
        '&' and '=' will be percent encoded and not treated as
        delimiters.
        """
        return pulumi.get(self, "query_string_whitelists")


@pulumi.output_type
class GetRegionBackendServiceCdnPolicyNegativeCachingPolicyResult(dict):
    def __init__(__self__, *,
                 code: _builtins.int,
                 ttl: _builtins.int):
        """
        :param _builtins.int code: The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
               can be specified as values, and you cannot specify a status code more than once.
        :param _builtins.int ttl: The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
               (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.int:
        """
        The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
        can be specified as values, and you cannot specify a status code more than once.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
        (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetRegionBackendServiceCircuitBreakerResult(dict):
    def __init__(__self__, *,
                 connect_timeouts: Sequence['outputs.GetRegionBackendServiceCircuitBreakerConnectTimeoutResult'],
                 max_connections: _builtins.int,
                 max_pending_requests: _builtins.int,
                 max_requests: _builtins.int,
                 max_requests_per_connection: _builtins.int,
                 max_retries: _builtins.int):
        """
        :param Sequence['GetRegionBackendServiceCircuitBreakerConnectTimeoutArgs'] connect_timeouts: The timeout for new network connections to hosts.
        :param _builtins.int max_connections: The maximum number of connections to the backend cluster.
               Defaults to 1024.
        :param _builtins.int max_pending_requests: The maximum number of pending requests to the backend cluster.
               Defaults to 1024.
        :param _builtins.int max_requests: The maximum number of parallel requests to the backend cluster.
               Defaults to 1024.
        :param _builtins.int max_requests_per_connection: Maximum requests for a single backend connection. This parameter
               is respected by both the HTTP/1.1 and HTTP/2 implementations. If
               not specified, there is no limit. Setting this parameter to 1
               will effectively disable keep alive.
        :param _builtins.int max_retries: The maximum number of parallel retries to the backend cluster.
               Defaults to 3.
        """
        pulumi.set(__self__, "connect_timeouts", connect_timeouts)
        pulumi.set(__self__, "max_connections", max_connections)
        pulumi.set(__self__, "max_pending_requests", max_pending_requests)
        pulumi.set(__self__, "max_requests", max_requests)
        pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        pulumi.set(__self__, "max_retries", max_retries)

    @_builtins.property
    @pulumi.getter(name="connectTimeouts")
    def connect_timeouts(self) -> Sequence['outputs.GetRegionBackendServiceCircuitBreakerConnectTimeoutResult']:
        """
        The timeout for new network connections to hosts.
        """
        return pulumi.get(self, "connect_timeouts")

    @_builtins.property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> _builtins.int:
        """
        The maximum number of connections to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_connections")

    @_builtins.property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> _builtins.int:
        """
        The maximum number of pending requests to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_pending_requests")

    @_builtins.property
    @pulumi.getter(name="maxRequests")
    def max_requests(self) -> _builtins.int:
        """
        The maximum number of parallel requests to the backend cluster.
        Defaults to 1024.
        """
        return pulumi.get(self, "max_requests")

    @_builtins.property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> _builtins.int:
        """
        Maximum requests for a single backend connection. This parameter
        is respected by both the HTTP/1.1 and HTTP/2 implementations. If
        not specified, there is no limit. Setting this parameter to 1
        will effectively disable keep alive.
        """
        return pulumi.get(self, "max_requests_per_connection")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> _builtins.int:
        """
        The maximum number of parallel retries to the backend cluster.
        Defaults to 3.
        """
        return pulumi.get(self, "max_retries")


@pulumi.output_type
class GetRegionBackendServiceCircuitBreakerConnectTimeoutResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetRegionBackendServiceConnectionTrackingPolicyResult(dict):
    def __init__(__self__, *,
                 connection_persistence_on_unhealthy_backends: _builtins.str,
                 enable_strong_affinity: _builtins.bool,
                 idle_timeout_sec: _builtins.int,
                 tracking_mode: _builtins.str):
        """
        :param _builtins.str connection_persistence_on_unhealthy_backends: Specifies connection persistence when backends are unhealthy.
               
               If set to 'DEFAULT_FOR_PROTOCOL', the existing connections persist on
               unhealthy backends only for connection-oriented protocols (TCP and SCTP)
               and only if the Tracking Mode is PER_CONNECTION (default tracking mode)
               or the Session Affinity is configured for 5-tuple. They do not persist
               for UDP.
               
               If set to 'NEVER_PERSIST', after a backend becomes unhealthy, the existing
               connections on the unhealthy backend are never persisted on the unhealthy
               backend. They are always diverted to newly selected healthy backends
               (unless all backends are unhealthy).
               
               If set to 'ALWAYS_PERSIST', existing connections always persist on
               unhealthy backends regardless of protocol and session affinity. It is
               generally not recommended to use this mode overriding the default. Default value: "DEFAULT_FOR_PROTOCOL" Possible values: ["DEFAULT_FOR_PROTOCOL", "NEVER_PERSIST", "ALWAYS_PERSIST"]
        :param _builtins.bool enable_strong_affinity: Enable Strong Session Affinity for Network Load Balancing. This option is not available publicly.
        :param _builtins.int idle_timeout_sec: Specifies how long to keep a Connection Tracking entry while there is
               no matching traffic (in seconds).
               
               For L4 ILB the minimum(default) is 10 minutes and maximum is 16 hours.
               
               For NLB the minimum(default) is 60 seconds and the maximum is 16 hours.
        :param _builtins.str tracking_mode: Specifies the key used for connection tracking. There are two options:
               'PER_CONNECTION': The Connection Tracking is performed as per the
               Connection Key (default Hash Method) for the specific protocol.
               
               'PER_SESSION': The Connection Tracking is performed as per the
               configured Session Affinity. It matches the configured Session Affinity. Default value: "PER_CONNECTION" Possible values: ["PER_CONNECTION", "PER_SESSION"]
        """
        pulumi.set(__self__, "connection_persistence_on_unhealthy_backends", connection_persistence_on_unhealthy_backends)
        pulumi.set(__self__, "enable_strong_affinity", enable_strong_affinity)
        pulumi.set(__self__, "idle_timeout_sec", idle_timeout_sec)
        pulumi.set(__self__, "tracking_mode", tracking_mode)

    @_builtins.property
    @pulumi.getter(name="connectionPersistenceOnUnhealthyBackends")
    def connection_persistence_on_unhealthy_backends(self) -> _builtins.str:
        """
        Specifies connection persistence when backends are unhealthy.

        If set to 'DEFAULT_FOR_PROTOCOL', the existing connections persist on
        unhealthy backends only for connection-oriented protocols (TCP and SCTP)
        and only if the Tracking Mode is PER_CONNECTION (default tracking mode)
        or the Session Affinity is configured for 5-tuple. They do not persist
        for UDP.

        If set to 'NEVER_PERSIST', after a backend becomes unhealthy, the existing
        connections on the unhealthy backend are never persisted on the unhealthy
        backend. They are always diverted to newly selected healthy backends
        (unless all backends are unhealthy).

        If set to 'ALWAYS_PERSIST', existing connections always persist on
        unhealthy backends regardless of protocol and session affinity. It is
        generally not recommended to use this mode overriding the default. Default value: "DEFAULT_FOR_PROTOCOL" Possible values: ["DEFAULT_FOR_PROTOCOL", "NEVER_PERSIST", "ALWAYS_PERSIST"]
        """
        return pulumi.get(self, "connection_persistence_on_unhealthy_backends")

    @_builtins.property
    @pulumi.getter(name="enableStrongAffinity")
    def enable_strong_affinity(self) -> _builtins.bool:
        """
        Enable Strong Session Affinity for Network Load Balancing. This option is not available publicly.
        """
        return pulumi.get(self, "enable_strong_affinity")

    @_builtins.property
    @pulumi.getter(name="idleTimeoutSec")
    def idle_timeout_sec(self) -> _builtins.int:
        """
        Specifies how long to keep a Connection Tracking entry while there is
        no matching traffic (in seconds).

        For L4 ILB the minimum(default) is 10 minutes and maximum is 16 hours.

        For NLB the minimum(default) is 60 seconds and the maximum is 16 hours.
        """
        return pulumi.get(self, "idle_timeout_sec")

    @_builtins.property
    @pulumi.getter(name="trackingMode")
    def tracking_mode(self) -> _builtins.str:
        """
        Specifies the key used for connection tracking. There are two options:
        'PER_CONNECTION': The Connection Tracking is performed as per the
        Connection Key (default Hash Method) for the specific protocol.

        'PER_SESSION': The Connection Tracking is performed as per the
        configured Session Affinity. It matches the configured Session Affinity. Default value: "PER_CONNECTION" Possible values: ["PER_CONNECTION", "PER_SESSION"]
        """
        return pulumi.get(self, "tracking_mode")


@pulumi.output_type
class GetRegionBackendServiceConsistentHashResult(dict):
    def __init__(__self__, *,
                 http_cookies: Sequence['outputs.GetRegionBackendServiceConsistentHashHttpCookyResult'],
                 http_header_name: _builtins.str,
                 minimum_ring_size: _builtins.int):
        """
        :param Sequence['GetRegionBackendServiceConsistentHashHttpCookyArgs'] http_cookies: Hash is based on HTTP Cookie. This field describes a HTTP cookie
               that will be used as the hash key for the consistent hash load
               balancer. If the cookie is not present, it will be generated.
               This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
        :param _builtins.str http_header_name: The hash based on the value of the specified header field.
               This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        :param _builtins.int minimum_ring_size: The minimum number of virtual nodes to use for the hash ring.
               Larger ring sizes result in more granular load
               distributions. If the number of hosts in the load balancing pool
               is larger than the ring size, each host will be assigned a single
               virtual node.
               Defaults to 1024.
        """
        pulumi.set(__self__, "http_cookies", http_cookies)
        pulumi.set(__self__, "http_header_name", http_header_name)
        pulumi.set(__self__, "minimum_ring_size", minimum_ring_size)

    @_builtins.property
    @pulumi.getter(name="httpCookies")
    def http_cookies(self) -> Sequence['outputs.GetRegionBackendServiceConsistentHashHttpCookyResult']:
        """
        Hash is based on HTTP Cookie. This field describes a HTTP cookie
        that will be used as the hash key for the consistent hash load
        balancer. If the cookie is not present, it will be generated.
        This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
        """
        return pulumi.get(self, "http_cookies")

    @_builtins.property
    @pulumi.getter(name="httpHeaderName")
    def http_header_name(self) -> _builtins.str:
        """
        The hash based on the value of the specified header field.
        This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        """
        return pulumi.get(self, "http_header_name")

    @_builtins.property
    @pulumi.getter(name="minimumRingSize")
    def minimum_ring_size(self) -> _builtins.int:
        """
        The minimum number of virtual nodes to use for the hash ring.
        Larger ring sizes result in more granular load
        distributions. If the number of hosts in the load balancing pool
        is larger than the ring size, each host will be assigned a single
        virtual node.
        Defaults to 1024.
        """
        return pulumi.get(self, "minimum_ring_size")


@pulumi.output_type
class GetRegionBackendServiceConsistentHashHttpCookyResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 path: _builtins.str,
                 ttls: Sequence['outputs.GetRegionBackendServiceConsistentHashHttpCookyTtlResult']):
        """
        :param _builtins.str name: The name of the regional backend service.
        :param _builtins.str path: Path to set for the cookie.
        :param Sequence['GetRegionBackendServiceConsistentHashHttpCookyTtlArgs'] ttls: Lifetime of the cookie.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "ttls", ttls)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the regional backend service.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path to set for the cookie.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def ttls(self) -> Sequence['outputs.GetRegionBackendServiceConsistentHashHttpCookyTtlResult']:
        """
        Lifetime of the cookie.
        """
        return pulumi.get(self, "ttls")


@pulumi.output_type
class GetRegionBackendServiceConsistentHashHttpCookyTtlResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetRegionBackendServiceCustomMetricResult(dict):
    def __init__(__self__, *,
                 dry_run: _builtins.bool,
                 name: _builtins.str):
        """
        :param _builtins.bool dry_run: If true, the metric data is not used for load balancing.
        :param _builtins.str name: The name of the regional backend service.
        """
        pulumi.set(__self__, "dry_run", dry_run)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> _builtins.bool:
        """
        If true, the metric data is not used for load balancing.
        """
        return pulumi.get(self, "dry_run")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the regional backend service.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRegionBackendServiceDynamicForwardingResult(dict):
    def __init__(__self__, *,
                 ip_port_selections: Sequence['outputs.GetRegionBackendServiceDynamicForwardingIpPortSelectionResult']):
        """
        :param Sequence['GetRegionBackendServiceDynamicForwardingIpPortSelectionArgs'] ip_port_selections: IP:PORT based dynamic forwarding configuration.
        """
        pulumi.set(__self__, "ip_port_selections", ip_port_selections)

    @_builtins.property
    @pulumi.getter(name="ipPortSelections")
    def ip_port_selections(self) -> Sequence['outputs.GetRegionBackendServiceDynamicForwardingIpPortSelectionResult']:
        """
        IP:PORT based dynamic forwarding configuration.
        """
        return pulumi.get(self, "ip_port_selections")


@pulumi.output_type
class GetRegionBackendServiceDynamicForwardingIpPortSelectionResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: A boolean flag enabling IP:PORT based dynamic forwarding.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        A boolean flag enabling IP:PORT based dynamic forwarding.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetRegionBackendServiceFailoverPolicyResult(dict):
    def __init__(__self__, *,
                 disable_connection_drain_on_failover: _builtins.bool,
                 drop_traffic_if_unhealthy: _builtins.bool,
                 failover_ratio: _builtins.float):
        """
        :param _builtins.bool disable_connection_drain_on_failover: On failover or failback, this field indicates whether connection drain
               will be honored. Setting this to true has the following effect: connections
               to the old active pool are not drained. Connections to the new active pool
               use the timeout of 10 min (currently fixed). Setting to false has the
               following effect: both old and new connections will have a drain timeout
               of 10 min.
               This can be set to true only if the protocol is TCP.
               The default is false.
        :param _builtins.bool drop_traffic_if_unhealthy: This option is used only when no healthy VMs are detected in the primary
               and backup instance groups. When set to true, traffic is dropped. When
               set to false, new connections are sent across all VMs in the primary group.
               The default is false.
        :param _builtins.float failover_ratio: The value of the field must be in [0, 1]. If the ratio of the healthy
               VMs in the primary backend is at or below this number, traffic arriving
               at the load-balanced IP will be directed to the failover backend.
               In case where 'failoverRatio' is not set or all the VMs in the backup
               backend are unhealthy, the traffic will be directed back to the primary
               backend in the "force" mode, where traffic will be spread to the healthy
               VMs with the best effort, or to all VMs when no VM is healthy.
               This field is only used with l4 load balancing.
        """
        pulumi.set(__self__, "disable_connection_drain_on_failover", disable_connection_drain_on_failover)
        pulumi.set(__self__, "drop_traffic_if_unhealthy", drop_traffic_if_unhealthy)
        pulumi.set(__self__, "failover_ratio", failover_ratio)

    @_builtins.property
    @pulumi.getter(name="disableConnectionDrainOnFailover")
    def disable_connection_drain_on_failover(self) -> _builtins.bool:
        """
        On failover or failback, this field indicates whether connection drain
        will be honored. Setting this to true has the following effect: connections
        to the old active pool are not drained. Connections to the new active pool
        use the timeout of 10 min (currently fixed). Setting to false has the
        following effect: both old and new connections will have a drain timeout
        of 10 min.
        This can be set to true only if the protocol is TCP.
        The default is false.
        """
        return pulumi.get(self, "disable_connection_drain_on_failover")

    @_builtins.property
    @pulumi.getter(name="dropTrafficIfUnhealthy")
    def drop_traffic_if_unhealthy(self) -> _builtins.bool:
        """
        This option is used only when no healthy VMs are detected in the primary
        and backup instance groups. When set to true, traffic is dropped. When
        set to false, new connections are sent across all VMs in the primary group.
        The default is false.
        """
        return pulumi.get(self, "drop_traffic_if_unhealthy")

    @_builtins.property
    @pulumi.getter(name="failoverRatio")
    def failover_ratio(self) -> _builtins.float:
        """
        The value of the field must be in [0, 1]. If the ratio of the healthy
        VMs in the primary backend is at or below this number, traffic arriving
        at the load-balanced IP will be directed to the failover backend.
        In case where 'failoverRatio' is not set or all the VMs in the backup
        backend are unhealthy, the traffic will be directed back to the primary
        backend in the "force" mode, where traffic will be spread to the healthy
        VMs with the best effort, or to all VMs when no VM is healthy.
        This field is only used with l4 load balancing.
        """
        return pulumi.get(self, "failover_ratio")


@pulumi.output_type
class GetRegionBackendServiceHaPolicyResult(dict):
    def __init__(__self__, *,
                 fast_ip_move: _builtins.str,
                 leaders: Sequence['outputs.GetRegionBackendServiceHaPolicyLeaderResult']):
        """
        :param _builtins.str fast_ip_move: Specifies whether fast IP move is enabled, and if so, the mechanism to achieve it.
               Supported values are:
               
               * 'DISABLED': Fast IP Move is disabled. You can only use the haPolicy.leader API to
                             update the leader.
               
               * 'GARP_RA': Provides a method to very quickly define a new network endpoint as the
                            leader. This method is faster than updating the leader using the
                            haPolicy.leader API. Fast IP move works as follows: The VM hosting the
                            network endpoint that should become the new leader sends either a
                            Gratuitous ARP (GARP) packet (IPv4) or an ICMPv6 Router Advertisement(RA)
                            packet (IPv6). Google Cloud immediately but temporarily associates the
                            forwarding rule IP address with that VM, and both new and in-flight packets
                            are quickly delivered to that VM. Possible values: ["DISABLED", "GARP_RA"]
        :param Sequence['GetRegionBackendServiceHaPolicyLeaderArgs'] leaders: Selects one of the network endpoints attached to the backend NEGs of this service as the
               active endpoint (the leader) that receives all traffic.
        """
        pulumi.set(__self__, "fast_ip_move", fast_ip_move)
        pulumi.set(__self__, "leaders", leaders)

    @_builtins.property
    @pulumi.getter(name="fastIpMove")
    def fast_ip_move(self) -> _builtins.str:
        """
        Specifies whether fast IP move is enabled, and if so, the mechanism to achieve it.
        Supported values are:

        * 'DISABLED': Fast IP Move is disabled. You can only use the haPolicy.leader API to
                      update the leader.

        * 'GARP_RA': Provides a method to very quickly define a new network endpoint as the
                     leader. This method is faster than updating the leader using the
                     haPolicy.leader API. Fast IP move works as follows: The VM hosting the
                     network endpoint that should become the new leader sends either a
                     Gratuitous ARP (GARP) packet (IPv4) or an ICMPv6 Router Advertisement(RA)
                     packet (IPv6). Google Cloud immediately but temporarily associates the
                     forwarding rule IP address with that VM, and both new and in-flight packets
                     are quickly delivered to that VM. Possible values: ["DISABLED", "GARP_RA"]
        """
        return pulumi.get(self, "fast_ip_move")

    @_builtins.property
    @pulumi.getter
    def leaders(self) -> Sequence['outputs.GetRegionBackendServiceHaPolicyLeaderResult']:
        """
        Selects one of the network endpoints attached to the backend NEGs of this service as the
        active endpoint (the leader) that receives all traffic.
        """
        return pulumi.get(self, "leaders")


@pulumi.output_type
class GetRegionBackendServiceHaPolicyLeaderResult(dict):
    def __init__(__self__, *,
                 backend_group: _builtins.str,
                 network_endpoints: Sequence['outputs.GetRegionBackendServiceHaPolicyLeaderNetworkEndpointResult']):
        """
        :param _builtins.str backend_group: A fully-qualified URL of the zonal Network Endpoint Group (NEG) that the leader is
               attached to.
        :param Sequence['GetRegionBackendServiceHaPolicyLeaderNetworkEndpointArgs'] network_endpoints: The network endpoint within the leader.backendGroup that is designated as the leader.
        """
        pulumi.set(__self__, "backend_group", backend_group)
        pulumi.set(__self__, "network_endpoints", network_endpoints)

    @_builtins.property
    @pulumi.getter(name="backendGroup")
    def backend_group(self) -> _builtins.str:
        """
        A fully-qualified URL of the zonal Network Endpoint Group (NEG) that the leader is
        attached to.
        """
        return pulumi.get(self, "backend_group")

    @_builtins.property
    @pulumi.getter(name="networkEndpoints")
    def network_endpoints(self) -> Sequence['outputs.GetRegionBackendServiceHaPolicyLeaderNetworkEndpointResult']:
        """
        The network endpoint within the leader.backendGroup that is designated as the leader.
        """
        return pulumi.get(self, "network_endpoints")


@pulumi.output_type
class GetRegionBackendServiceHaPolicyLeaderNetworkEndpointResult(dict):
    def __init__(__self__, *,
                 instance: _builtins.str):
        """
        :param _builtins.str instance: The name of the VM instance of the leader network endpoint. The instance must
               already be attached to the NEG specified in the haPolicy.leader.backendGroup.
        """
        pulumi.set(__self__, "instance", instance)

    @_builtins.property
    @pulumi.getter
    def instance(self) -> _builtins.str:
        """
        The name of the VM instance of the leader network endpoint. The instance must
        already be attached to the NEG specified in the haPolicy.leader.backendGroup.
        """
        return pulumi.get(self, "instance")


@pulumi.output_type
class GetRegionBackendServiceIapResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 oauth2_client_id: _builtins.str,
                 oauth2_client_secret: _builtins.str,
                 oauth2_client_secret_sha256: _builtins.str):
        """
        :param _builtins.bool enabled: Whether the serving infrastructure will authenticate and authorize all incoming requests.
        :param _builtins.str oauth2_client_id: OAuth2 Client ID for IAP
        :param _builtins.str oauth2_client_secret: OAuth2 Client Secret for IAP
        :param _builtins.str oauth2_client_secret_sha256: OAuth2 Client Secret SHA-256 for IAP
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "oauth2_client_id", oauth2_client_id)
        pulumi.set(__self__, "oauth2_client_secret", oauth2_client_secret)
        pulumi.set(__self__, "oauth2_client_secret_sha256", oauth2_client_secret_sha256)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether the serving infrastructure will authenticate and authorize all incoming requests.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientId")
    def oauth2_client_id(self) -> _builtins.str:
        """
        OAuth2 Client ID for IAP
        """
        return pulumi.get(self, "oauth2_client_id")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientSecret")
    def oauth2_client_secret(self) -> _builtins.str:
        """
        OAuth2 Client Secret for IAP
        """
        return pulumi.get(self, "oauth2_client_secret")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientSecretSha256")
    def oauth2_client_secret_sha256(self) -> _builtins.str:
        """
        OAuth2 Client Secret SHA-256 for IAP
        """
        return pulumi.get(self, "oauth2_client_secret_sha256")


@pulumi.output_type
class GetRegionBackendServiceLogConfigResult(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool,
                 optional_fields: Sequence[_builtins.str],
                 optional_mode: _builtins.str,
                 sample_rate: _builtins.float):
        """
        :param _builtins.bool enable: Whether to enable logging for the load balancer traffic served by this backend service.
        :param Sequence[_builtins.str] optional_fields: Specifies the fields to include in logging. This field can only be specified if logging is enabled for this backend service.
        :param _builtins.str optional_mode: Specifies the optional logging mode for the load balancer traffic.
               Supported values: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM. Possible values: ["INCLUDE_ALL_OPTIONAL", "EXCLUDE_ALL_OPTIONAL", "CUSTOM"]
        :param _builtins.float sample_rate: This field can only be specified if logging is enabled for this backend service. The value of
               the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
               where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
               The default value is 1.0.
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "optional_fields", optional_fields)
        pulumi.set(__self__, "optional_mode", optional_mode)
        pulumi.set(__self__, "sample_rate", sample_rate)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Whether to enable logging for the load balancer traffic served by this backend service.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="optionalFields")
    def optional_fields(self) -> Sequence[_builtins.str]:
        """
        Specifies the fields to include in logging. This field can only be specified if logging is enabled for this backend service.
        """
        return pulumi.get(self, "optional_fields")

    @_builtins.property
    @pulumi.getter(name="optionalMode")
    def optional_mode(self) -> _builtins.str:
        """
        Specifies the optional logging mode for the load balancer traffic.
        Supported values: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM. Possible values: ["INCLUDE_ALL_OPTIONAL", "EXCLUDE_ALL_OPTIONAL", "CUSTOM"]
        """
        return pulumi.get(self, "optional_mode")

    @_builtins.property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> _builtins.float:
        """
        This field can only be specified if logging is enabled for this backend service. The value of
        the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
        where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
        The default value is 1.0.
        """
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class GetRegionBackendServiceNetworkPassThroughLbTrafficPolicyResult(dict):
    def __init__(__self__, *,
                 zonal_affinities: Sequence['outputs.GetRegionBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinityResult']):
        """
        :param Sequence['GetRegionBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinityArgs'] zonal_affinities: When configured, new connections are load balanced across healthy backend endpoints in the local zone.
        """
        pulumi.set(__self__, "zonal_affinities", zonal_affinities)

    @_builtins.property
    @pulumi.getter(name="zonalAffinities")
    def zonal_affinities(self) -> Sequence['outputs.GetRegionBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinityResult']:
        """
        When configured, new connections are load balanced across healthy backend endpoints in the local zone.
        """
        return pulumi.get(self, "zonal_affinities")


@pulumi.output_type
class GetRegionBackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinityResult(dict):
    def __init__(__self__, *,
                 spillover: _builtins.str,
                 spillover_ratio: _builtins.float):
        """
        :param _builtins.str spillover: This field indicates whether zonal affinity is enabled or not. Default value: "ZONAL_AFFINITY_DISABLED" Possible values: ["ZONAL_AFFINITY_DISABLED", "ZONAL_AFFINITY_SPILL_CROSS_ZONE", "ZONAL_AFFINITY_STAY_WITHIN_ZONE"]
        :param _builtins.float spillover_ratio: The value of the field must be in [0, 1]. When the ratio of the count of healthy backend endpoints in a zone
               to the count of backend endpoints in that same zone is equal to or above this threshold, the load balancer
               distributes new connections to all healthy endpoints in the local zone only. When the ratio of the count
               of healthy backend endpoints in a zone to the count of backend endpoints in that same zone is below this
               threshold, the load balancer distributes all new connections to all healthy endpoints across all zones.
        """
        pulumi.set(__self__, "spillover", spillover)
        pulumi.set(__self__, "spillover_ratio", spillover_ratio)

    @_builtins.property
    @pulumi.getter
    def spillover(self) -> _builtins.str:
        """
        This field indicates whether zonal affinity is enabled or not. Default value: "ZONAL_AFFINITY_DISABLED" Possible values: ["ZONAL_AFFINITY_DISABLED", "ZONAL_AFFINITY_SPILL_CROSS_ZONE", "ZONAL_AFFINITY_STAY_WITHIN_ZONE"]
        """
        return pulumi.get(self, "spillover")

    @_builtins.property
    @pulumi.getter(name="spilloverRatio")
    def spillover_ratio(self) -> _builtins.float:
        """
        The value of the field must be in [0, 1]. When the ratio of the count of healthy backend endpoints in a zone
        to the count of backend endpoints in that same zone is equal to or above this threshold, the load balancer
        distributes new connections to all healthy endpoints in the local zone only. When the ratio of the count
        of healthy backend endpoints in a zone to the count of backend endpoints in that same zone is below this
        threshold, the load balancer distributes all new connections to all healthy endpoints across all zones.
        """
        return pulumi.get(self, "spillover_ratio")


@pulumi.output_type
class GetRegionBackendServiceOutlierDetectionResult(dict):
    def __init__(__self__, *,
                 base_ejection_times: Sequence['outputs.GetRegionBackendServiceOutlierDetectionBaseEjectionTimeResult'],
                 consecutive_errors: _builtins.int,
                 consecutive_gateway_failure: _builtins.int,
                 enforcing_consecutive_errors: _builtins.int,
                 enforcing_consecutive_gateway_failure: _builtins.int,
                 enforcing_success_rate: _builtins.int,
                 intervals: Sequence['outputs.GetRegionBackendServiceOutlierDetectionIntervalResult'],
                 max_ejection_percent: _builtins.int,
                 success_rate_minimum_hosts: _builtins.int,
                 success_rate_request_volume: _builtins.int,
                 success_rate_stdev_factor: _builtins.int):
        """
        :param Sequence['GetRegionBackendServiceOutlierDetectionBaseEjectionTimeArgs'] base_ejection_times: The base time that a host is ejected for. The real time is equal to the base
               time multiplied by the number of times the host has been ejected. Defaults to
               30000ms or 30s.
        :param _builtins.int consecutive_errors: Number of errors before a host is ejected from the connection pool. When the
               backend host is accessed over HTTP, a 5xx return code qualifies as an error.
               Defaults to 5.
        :param _builtins.int consecutive_gateway_failure: The number of consecutive gateway failures (502, 503, 504 status or connection
               errors that are mapped to one of those status codes) before a consecutive
               gateway failure ejection occurs. Defaults to 5.
        :param _builtins.int enforcing_consecutive_errors: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive 5xx. This setting can be used to disable
               ejection or to ramp it up slowly. Defaults to 100.
        :param _builtins.int enforcing_consecutive_gateway_failure: The percentage chance that a host will be actually ejected when an outlier
               status is detected through consecutive gateway failures. This setting can be
               used to disable ejection or to ramp it up slowly. Defaults to 0.
        :param _builtins.int enforcing_success_rate: The percentage chance that a host will be actually ejected when an outlier
               status is detected through success rate statistics. This setting can be used to
               disable ejection or to ramp it up slowly. Defaults to 100.
        :param Sequence['GetRegionBackendServiceOutlierDetectionIntervalArgs'] intervals: Time interval between ejection sweep analysis. This can result in both new
               ejections as well as hosts being returned to service. Defaults to 10 seconds.
        :param _builtins.int max_ejection_percent: Maximum percentage of hosts in the load balancing pool for the backend service
               that can be ejected. Defaults to 10%.
        :param _builtins.int success_rate_minimum_hosts: The number of hosts in a cluster that must have enough request volume to detect
               success rate outliers. If the number of hosts is less than this setting, outlier
               detection via success rate statistics is not performed for any host in the
               cluster. Defaults to 5.
        :param _builtins.int success_rate_request_volume: The minimum number of total requests that must be collected in one interval (as
               defined by the interval duration above) to include this host in success rate
               based outlier detection. If the volume is lower than this setting, outlier
               detection via success rate statistics is not performed for that host. Defaults
               to 100.
        :param _builtins.int success_rate_stdev_factor: This factor is used to determine the ejection threshold for success rate outlier
               ejection. The ejection threshold is the difference between the mean success
               rate, and the product of this factor and the standard deviation of the mean
               success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
               by a thousand to get a double. That is, if the desired factor is 1.9, the
               runtime value should be 1900. Defaults to 1900.
        """
        pulumi.set(__self__, "base_ejection_times", base_ejection_times)
        pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        pulumi.set(__self__, "consecutive_gateway_failure", consecutive_gateway_failure)
        pulumi.set(__self__, "enforcing_consecutive_errors", enforcing_consecutive_errors)
        pulumi.set(__self__, "enforcing_consecutive_gateway_failure", enforcing_consecutive_gateway_failure)
        pulumi.set(__self__, "enforcing_success_rate", enforcing_success_rate)
        pulumi.set(__self__, "intervals", intervals)
        pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        pulumi.set(__self__, "success_rate_minimum_hosts", success_rate_minimum_hosts)
        pulumi.set(__self__, "success_rate_request_volume", success_rate_request_volume)
        pulumi.set(__self__, "success_rate_stdev_factor", success_rate_stdev_factor)

    @_builtins.property
    @pulumi.getter(name="baseEjectionTimes")
    def base_ejection_times(self) -> Sequence['outputs.GetRegionBackendServiceOutlierDetectionBaseEjectionTimeResult']:
        """
        The base time that a host is ejected for. The real time is equal to the base
        time multiplied by the number of times the host has been ejected. Defaults to
        30000ms or 30s.
        """
        return pulumi.get(self, "base_ejection_times")

    @_builtins.property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> _builtins.int:
        """
        Number of errors before a host is ejected from the connection pool. When the
        backend host is accessed over HTTP, a 5xx return code qualifies as an error.
        Defaults to 5.
        """
        return pulumi.get(self, "consecutive_errors")

    @_builtins.property
    @pulumi.getter(name="consecutiveGatewayFailure")
    def consecutive_gateway_failure(self) -> _builtins.int:
        """
        The number of consecutive gateway failures (502, 503, 504 status or connection
        errors that are mapped to one of those status codes) before a consecutive
        gateway failure ejection occurs. Defaults to 5.
        """
        return pulumi.get(self, "consecutive_gateway_failure")

    @_builtins.property
    @pulumi.getter(name="enforcingConsecutiveErrors")
    def enforcing_consecutive_errors(self) -> _builtins.int:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive 5xx. This setting can be used to disable
        ejection or to ramp it up slowly. Defaults to 100.
        """
        return pulumi.get(self, "enforcing_consecutive_errors")

    @_builtins.property
    @pulumi.getter(name="enforcingConsecutiveGatewayFailure")
    def enforcing_consecutive_gateway_failure(self) -> _builtins.int:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive gateway failures. This setting can be
        used to disable ejection or to ramp it up slowly. Defaults to 0.
        """
        return pulumi.get(self, "enforcing_consecutive_gateway_failure")

    @_builtins.property
    @pulumi.getter(name="enforcingSuccessRate")
    def enforcing_success_rate(self) -> _builtins.int:
        """
        The percentage chance that a host will be actually ejected when an outlier
        status is detected through success rate statistics. This setting can be used to
        disable ejection or to ramp it up slowly. Defaults to 100.
        """
        return pulumi.get(self, "enforcing_success_rate")

    @_builtins.property
    @pulumi.getter
    def intervals(self) -> Sequence['outputs.GetRegionBackendServiceOutlierDetectionIntervalResult']:
        """
        Time interval between ejection sweep analysis. This can result in both new
        ejections as well as hosts being returned to service. Defaults to 10 seconds.
        """
        return pulumi.get(self, "intervals")

    @_builtins.property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> _builtins.int:
        """
        Maximum percentage of hosts in the load balancing pool for the backend service
        that can be ejected. Defaults to 10%.
        """
        return pulumi.get(self, "max_ejection_percent")

    @_builtins.property
    @pulumi.getter(name="successRateMinimumHosts")
    def success_rate_minimum_hosts(self) -> _builtins.int:
        """
        The number of hosts in a cluster that must have enough request volume to detect
        success rate outliers. If the number of hosts is less than this setting, outlier
        detection via success rate statistics is not performed for any host in the
        cluster. Defaults to 5.
        """
        return pulumi.get(self, "success_rate_minimum_hosts")

    @_builtins.property
    @pulumi.getter(name="successRateRequestVolume")
    def success_rate_request_volume(self) -> _builtins.int:
        """
        The minimum number of total requests that must be collected in one interval (as
        defined by the interval duration above) to include this host in success rate
        based outlier detection. If the volume is lower than this setting, outlier
        detection via success rate statistics is not performed for that host. Defaults
        to 100.
        """
        return pulumi.get(self, "success_rate_request_volume")

    @_builtins.property
    @pulumi.getter(name="successRateStdevFactor")
    def success_rate_stdev_factor(self) -> _builtins.int:
        """
        This factor is used to determine the ejection threshold for success rate outlier
        ejection. The ejection threshold is the difference between the mean success
        rate, and the product of this factor and the standard deviation of the mean
        success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
        by a thousand to get a double. That is, if the desired factor is 1.9, the
        runtime value should be 1900. Defaults to 1900.
        """
        return pulumi.get(self, "success_rate_stdev_factor")


@pulumi.output_type
class GetRegionBackendServiceOutlierDetectionBaseEjectionTimeResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 'seconds' field and a positive
               'nanos' field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 'seconds' field and a positive
        'nanos' field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetRegionBackendServiceOutlierDetectionIntervalResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond resolution. Durations
               less than one second are represented with a 0 'seconds' field and a positive
               'nanos' field. Must be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
               inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond resolution. Durations
        less than one second are represented with a 0 'seconds' field and a positive
        'nanos' field. Must be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
        inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetRegionBackendServiceParamResult(dict):
    def __init__(__self__, *,
                 resource_manager_tags: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the region backend service. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456.
        """
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        Resource manager tags to be bound to the region backend service. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class GetRegionBackendServiceStrongSessionAffinityCookyResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 path: _builtins.str,
                 ttls: Sequence['outputs.GetRegionBackendServiceStrongSessionAffinityCookyTtlResult']):
        """
        :param _builtins.str name: The name of the regional backend service.
        :param _builtins.str path: Path to set for the cookie.
        :param Sequence['GetRegionBackendServiceStrongSessionAffinityCookyTtlArgs'] ttls: Lifetime of the cookie.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "ttls", ttls)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the regional backend service.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path to set for the cookie.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def ttls(self) -> Sequence['outputs.GetRegionBackendServiceStrongSessionAffinityCookyTtlResult']:
        """
        Lifetime of the cookie.
        """
        return pulumi.get(self, "ttls")


@pulumi.output_type
class GetRegionBackendServiceStrongSessionAffinityCookyTtlResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetRegionBackendServiceSubsettingResult(dict):
    def __init__(__self__, *,
                 policy: _builtins.str,
                 subset_size: _builtins.int):
        """
        :param _builtins.str policy: The algorithm used for subsetting. Possible values: ["CONSISTENT_HASH_SUBSETTING"]
        :param _builtins.int subset_size: The number of backends per backend group assigned to each proxy instance or each service mesh client.
               An input parameter to the CONSISTENT_HASH_SUBSETTING algorithm. Can only be set if policy is set to
               CONSISTENT_HASH_SUBSETTING. Can only be set if load balancing scheme is INTERNAL_MANAGED or INTERNAL_SELF_MANAGED.
               subsetSize is optional for Internal HTTP(S) load balancing and required for Traffic Director.
               If you do not provide this value, Cloud Load Balancing will calculate it dynamically to optimize the number
               of proxies/clients visible to each backend and vice versa.
               Must be greater than 0. If subsetSize is larger than the number of backends/endpoints, then subsetting is disabled.
        """
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "subset_size", subset_size)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        """
        The algorithm used for subsetting. Possible values: ["CONSISTENT_HASH_SUBSETTING"]
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter(name="subsetSize")
    def subset_size(self) -> _builtins.int:
        """
        The number of backends per backend group assigned to each proxy instance or each service mesh client.
        An input parameter to the CONSISTENT_HASH_SUBSETTING algorithm. Can only be set if policy is set to
        CONSISTENT_HASH_SUBSETTING. Can only be set if load balancing scheme is INTERNAL_MANAGED or INTERNAL_SELF_MANAGED.
        subsetSize is optional for Internal HTTP(S) load balancing and required for Traffic Director.
        If you do not provide this value, Cloud Load Balancing will calculate it dynamically to optimize the number
        of proxies/clients visible to each backend and vice versa.
        Must be greater than 0. If subsetSize is larger than the number of backends/endpoints, then subsetting is disabled.
        """
        return pulumi.get(self, "subset_size")


@pulumi.output_type
class GetRegionBackendServiceTlsSettingResult(dict):
    def __init__(__self__, *,
                 authentication_config: _builtins.str,
                 sni: _builtins.str,
                 subject_alt_names: Sequence['outputs.GetRegionBackendServiceTlsSettingSubjectAltNameResult']):
        """
        :param _builtins.str authentication_config: Reference to the BackendAuthenticationConfig resource from the networksecurity.googleapis.com namespace.
               Can be used in authenticating TLS connections to the backend, as specified by the authenticationMode field.
               Can only be specified if authenticationMode is not NONE.
        :param _builtins.str sni: Server Name Indication - see RFC3546 section 3.1. If set, the load balancer sends this string as the SNI hostname in the
               TLS connection to the backend, and requires that this string match a Subject Alternative Name (SAN) in the backend's
               server certificate. With a Regional Internet NEG backend, if the SNI is specified here, the load balancer uses it
               regardless of whether the Regional Internet NEG is specified with FQDN or IP address and port.
        :param Sequence['GetRegionBackendServiceTlsSettingSubjectAltNameArgs'] subject_alt_names: A list of Subject Alternative Names (SANs) that the Load Balancer verifies during a TLS handshake with the backend.
               When the server presents its X.509 certificate to the Load Balancer, the Load Balancer inspects the certificate's SAN field,
               and requires that at least one SAN match one of the subjectAltNames in the list. This field is limited to 5 entries.
               When both sni and subjectAltNames are specified, the load balancer matches the backend certificate's SAN only to
               subjectAltNames.
        """
        pulumi.set(__self__, "authentication_config", authentication_config)
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @_builtins.property
    @pulumi.getter(name="authenticationConfig")
    def authentication_config(self) -> _builtins.str:
        """
        Reference to the BackendAuthenticationConfig resource from the networksecurity.googleapis.com namespace.
        Can be used in authenticating TLS connections to the backend, as specified by the authenticationMode field.
        Can only be specified if authenticationMode is not NONE.
        """
        return pulumi.get(self, "authentication_config")

    @_builtins.property
    @pulumi.getter
    def sni(self) -> _builtins.str:
        """
        Server Name Indication - see RFC3546 section 3.1. If set, the load balancer sends this string as the SNI hostname in the
        TLS connection to the backend, and requires that this string match a Subject Alternative Name (SAN) in the backend's
        server certificate. With a Regional Internet NEG backend, if the SNI is specified here, the load balancer uses it
        regardless of whether the Regional Internet NEG is specified with FQDN or IP address and port.
        """
        return pulumi.get(self, "sni")

    @_builtins.property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Sequence['outputs.GetRegionBackendServiceTlsSettingSubjectAltNameResult']:
        """
        A list of Subject Alternative Names (SANs) that the Load Balancer verifies during a TLS handshake with the backend.
        When the server presents its X.509 certificate to the Load Balancer, the Load Balancer inspects the certificate's SAN field,
        and requires that at least one SAN match one of the subjectAltNames in the list. This field is limited to 5 entries.
        When both sni and subjectAltNames are specified, the load balancer matches the backend certificate's SAN only to
        subjectAltNames.
        """
        return pulumi.get(self, "subject_alt_names")


@pulumi.output_type
class GetRegionBackendServiceTlsSettingSubjectAltNameResult(dict):
    def __init__(__self__, *,
                 dns_name: _builtins.str,
                 uniform_resource_identifier: _builtins.str):
        """
        :param _builtins.str dns_name: The SAN specified as a DNS Name.
        :param _builtins.str uniform_resource_identifier: The SAN specified as a URI.
        """
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "uniform_resource_identifier", uniform_resource_identifier)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        """
        The SAN specified as a DNS Name.
        """
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="uniformResourceIdentifier")
    def uniform_resource_identifier(self) -> _builtins.str:
        """
        The SAN specified as a URI.
        """
        return pulumi.get(self, "uniform_resource_identifier")


@pulumi.output_type
class GetRegionDiskAsyncPrimaryDiskResult(dict):
    def __init__(__self__, *,
                 disk: _builtins.str):
        """
        :param _builtins.str disk: Primary disk for asynchronous disk replication.
        """
        pulumi.set(__self__, "disk", disk)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> _builtins.str:
        """
        Primary disk for asynchronous disk replication.
        """
        return pulumi.get(self, "disk")


@pulumi.output_type
class GetRegionDiskDiskEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_name: _builtins.str,
                 raw_key: _builtins.str,
                 rsa_encrypted_key: _builtins.str,
                 sha256: _builtins.str):
        """
        :param _builtins.str kms_key_name: The name of the encryption key that is stored in Google Cloud KMS.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
               customer-supplied encryption key to either encrypt or decrypt
               this resource. You can provide either the rawKey or the rsaEncryptedKey.
        :param _builtins.str sha256: The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        pulumi.set(__self__, "kms_key_name", kms_key_name)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> _builtins.str:
        """
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_name")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> _builtins.str:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
        customer-supplied encryption key to either encrypt or decrypt
        this resource. You can provide either the rawKey or the rsaEncryptedKey.
        """
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> _builtins.str:
        """
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class GetRegionDiskGuestOsFeatureResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options. Possible values: ["MULTI_IP_SUBNET", "SECURE_BOOT", "SEV_CAPABLE", "UEFI_COMPATIBLE", "VIRTIO_SCSI_MULTIQUEUE", "WINDOWS", "GVNIC", "SEV_LIVE_MIGRATABLE", "SEV_SNP_CAPABLE", "SUSPEND_RESUME_COMPATIBLE", "TDX_CAPABLE"]
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options. Possible values: ["MULTI_IP_SUBNET", "SECURE_BOOT", "SEV_CAPABLE", "UEFI_COMPATIBLE", "VIRTIO_SCSI_MULTIQUEUE", "WINDOWS", "GVNIC", "SEV_LIVE_MIGRATABLE", "SEV_SNP_CAPABLE", "SUSPEND_RESUME_COMPATIBLE", "TDX_CAPABLE"]
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRegionDiskSourceSnapshotEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_name: _builtins.str,
                 raw_key: _builtins.str,
                 sha256: _builtins.str):
        """
        :param _builtins.str kms_key_name: The name of the encryption key that is stored in Google Cloud KMS.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param _builtins.str sha256: The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        pulumi.set(__self__, "kms_key_name", kms_key_name)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> _builtins.str:
        """
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_name")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> _builtins.str:
        """
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class GetRegionInstanceGroupInstanceResult(dict):
    def __init__(__self__, *,
                 instance: _builtins.str,
                 named_ports: Sequence['outputs.GetRegionInstanceGroupInstanceNamedPortResult'],
                 status: _builtins.str):
        """
        :param _builtins.str instance: URL to the instance.
        :param Sequence['GetRegionInstanceGroupInstanceNamedPortArgs'] named_ports: List of named ports in the group, as a list of resources, each containing:
        :param _builtins.str status: String description of current state of the instance.
        """
        pulumi.set(__self__, "instance", instance)
        pulumi.set(__self__, "named_ports", named_ports)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def instance(self) -> _builtins.str:
        """
        URL to the instance.
        """
        return pulumi.get(self, "instance")

    @_builtins.property
    @pulumi.getter(name="namedPorts")
    def named_ports(self) -> Sequence['outputs.GetRegionInstanceGroupInstanceNamedPortResult']:
        """
        List of named ports in the group, as a list of resources, each containing:
        """
        return pulumi.get(self, "named_ports")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        String description of current state of the instance.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRegionInstanceGroupInstanceNamedPortResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str name: The name of the instance group.  One of `name` or `self_link` must be provided.
        :param _builtins.int port: Integer port number
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance group.  One of `name` or `self_link` must be provided.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Integer port number
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetRegionInstanceGroupManagerAllInstancesConfigResult(dict):
    def __init__(__self__, *,
                 labels: Mapping[str, _builtins.str],
                 metadata: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] labels: The label key-value pairs that you want to patch onto the instance,
        :param Mapping[str, _builtins.str] metadata: The metadata key-value pairs that you want to patch onto the instance. For more information, see Project and instance metadata,
        """
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        The label key-value pairs that you want to patch onto the instance,
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Mapping[str, _builtins.str]:
        """
        The metadata key-value pairs that you want to patch onto the instance. For more information, see Project and instance metadata,
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class GetRegionInstanceGroupManagerAutoHealingPolicyResult(dict):
    def __init__(__self__, *,
                 health_check: _builtins.str,
                 initial_delay_sec: _builtins.int):
        """
        :param _builtins.str health_check: The health check resource that signals autohealing.
        :param _builtins.int initial_delay_sec: The number of seconds that the managed instance group waits before it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        pulumi.set(__self__, "health_check", health_check)
        pulumi.set(__self__, "initial_delay_sec", initial_delay_sec)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> _builtins.str:
        """
        The health check resource that signals autohealing.
        """
        return pulumi.get(self, "health_check")

    @_builtins.property
    @pulumi.getter(name="initialDelaySec")
    def initial_delay_sec(self) -> _builtins.int:
        """
        The number of seconds that the managed instance group waits before it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
        """
        return pulumi.get(self, "initial_delay_sec")


@pulumi.output_type
class GetRegionInstanceGroupManagerInstanceFlexibilityPolicyResult(dict):
    def __init__(__self__, *,
                 instance_selections: Sequence['outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionResult']):
        """
        :param Sequence['GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionArgs'] instance_selections: Named instance selections configuring properties that the group will use when creating new VMs.
        """
        pulumi.set(__self__, "instance_selections", instance_selections)

    @_builtins.property
    @pulumi.getter(name="instanceSelections")
    def instance_selections(self) -> Sequence['outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionResult']:
        """
        Named instance selections configuring properties that the group will use when creating new VMs.
        """
        return pulumi.get(self, "instance_selections")


@pulumi.output_type
class GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionResult(dict):
    def __init__(__self__, *,
                 disks: Sequence['outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResult'],
                 machine_types: Sequence[_builtins.str],
                 min_cpu_platform: _builtins.str,
                 name: _builtins.str,
                 rank: _builtins.int):
        """
        :param Sequence['GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskArgs'] disks: List of disks to be attached to the instances created from this selection.
        :param Sequence[_builtins.str] machine_types: Full machine-type names, e.g. "n1-standard-16"
        :param _builtins.str min_cpu_platform: Name of the minimum CPU platform to be used by this instance selection. e.g. 'Intel Ice Lake'
        :param _builtins.str name: The name of the instance group. Either `name` or `self_link` must be provided.
        :param _builtins.int rank: Preference of this instance selection. Lower number means higher preference. MIG will first try to create a VM based on the machine-type with lowest rank and fallback to next rank based on availability. Machine types and instance selections with the same rank have the same preference.
        """
        pulumi.set(__self__, "disks", disks)
        pulumi.set(__self__, "machine_types", machine_types)
        pulumi.set(__self__, "min_cpu_platform", min_cpu_platform)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rank", rank)

    @_builtins.property
    @pulumi.getter
    def disks(self) -> Sequence['outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResult']:
        """
        List of disks to be attached to the instances created from this selection.
        """
        return pulumi.get(self, "disks")

    @_builtins.property
    @pulumi.getter(name="machineTypes")
    def machine_types(self) -> Sequence[_builtins.str]:
        """
        Full machine-type names, e.g. "n1-standard-16"
        """
        return pulumi.get(self, "machine_types")

    @_builtins.property
    @pulumi.getter(name="minCpuPlatform")
    def min_cpu_platform(self) -> _builtins.str:
        """
        Name of the minimum CPU platform to be used by this instance selection. e.g. 'Intel Ice Lake'
        """
        return pulumi.get(self, "min_cpu_platform")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance group. Either `name` or `self_link` must be provided.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def rank(self) -> _builtins.int:
        """
        Preference of this instance selection. Lower number means higher preference. MIG will first try to create a VM based on the machine-type with lowest rank and fallback to next rank based on availability. Machine types and instance selections with the same rank have the same preference.
        """
        return pulumi.get(self, "rank")


@pulumi.output_type
class GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResult(dict):
    def __init__(__self__, *,
                 architecture: _builtins.str,
                 auto_delete: _builtins.bool,
                 boot: _builtins.bool,
                 device_name: _builtins.str,
                 disk_encryption_keys: Sequence['outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKeyResult'],
                 disk_name: _builtins.str,
                 disk_size_gb: _builtins.int,
                 disk_type: _builtins.str,
                 guest_os_features: Sequence[_builtins.str],
                 interface: _builtins.str,
                 labels: Sequence['outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabelResult'],
                 mode: _builtins.str,
                 provisioned_iops: _builtins.int,
                 provisioned_throughput: _builtins.int,
                 resource_manager_tags: Sequence['outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTagResult'],
                 resource_policies: Sequence[_builtins.str],
                 source: _builtins.str,
                 source_image: _builtins.str,
                 source_image_encryption_keys: Sequence['outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKeyResult'],
                 source_snapshot: _builtins.str,
                 source_snapshot_encryption_keys: Sequence['outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKeyResult'],
                 type: _builtins.str):
        """
        :param _builtins.str architecture: The architecture of the image. Allowed values are ARM64 or X86_64.
        :param _builtins.bool auto_delete: Whether or not the disk should be auto-deleted. This defaults to true.
        :param _builtins.bool boot: Indicates that this is a boot disk. This defaults to false.
        :param _builtins.str device_name: A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance. If not specified, the server chooses a default device name to apply to this disk.
        :param Sequence['GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKeyArgs'] disk_encryption_keys: Encrypts or decrypts a disk using a customer-supplied encryption key.
        :param _builtins.str disk_name: Name of the disk. When not provided, this defaults to the name of the instance.
        :param _builtins.int disk_size_gb: The size of the image in gigabytes. If not specified, it will inherit the size of its base image. For SCRATCH disks, the size must be one of 375 or 3000 GB, with a default of 375 GB.
        :param _builtins.str disk_type: The Google Compute Engine disk type. Such as "pd-ssd", "local-ssd", "pd-balanced" or "pd-standard".
        :param Sequence[_builtins.str] guest_os_features: A list of features to enable on the guest operating system. Applicable only for bootable images.
        :param _builtins.str interface: Specifies the disk interface to use for attaching this disk.
        :param Sequence['GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabelArgs'] labels: A set of key/value label pairs to assign to disks.
        :param _builtins.str mode: The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If you are attaching or creating a boot disk, this must read-write mode.
        :param _builtins.int provisioned_iops: Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle. For more details, see the [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk) or the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks) depending on the selected disk_type.
        :param _builtins.int provisioned_throughput: Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
        :param Sequence['GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTagArgs'] resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        :param Sequence[_builtins.str] resource_policies: A list (short name or id) of resource policies to attach to this disk. Currently a max of 1 resource policy is supported.
        :param _builtins.str source: The name (not self_link) of the disk (such as those managed by google_compute_disk) to attach. > Note: Either source or source_image is required when creating a new instance except for when creating a local SSD.
        :param _builtins.str source_image: The image from which to initialize this disk. This can be one of: the image's self_link, projects/{project}/global/images/{image}, projects/{project}/global/images/family/{family}, global/images/{image}, global/images/family/{family}, family/{family}, {project}/{family}, {project}/{image}, {family}, or {image}. > Note: Either source or source_image is required when creating a new instance except for when creating a local SSD.
        :param Sequence['GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKeyArgs'] source_image_encryption_keys: The customer-supplied encryption key of the source image. Required if the source image is protected by a customer-supplied encryption key. Instance templates do not store customer-supplied encryption keys, so you cannot create disks for instances in a managed instance group if the source images are encrypted with your own keys.
        :param _builtins.str source_snapshot: The source snapshot to create this disk. When creating a new instance, one of initializeParams.sourceSnapshot, initializeParams.sourceImage, or disks.source is required except for local SSD.
        :param Sequence['GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKeyArgs'] source_snapshot_encryption_keys: The customer-supplied encryption key of the source snapshot.
        :param _builtins.str type: The type of Google Compute Engine disk, can be either "SCRATCH" or "PERSISTENT".
        """
        pulumi.set(__self__, "architecture", architecture)
        pulumi.set(__self__, "auto_delete", auto_delete)
        pulumi.set(__self__, "boot", boot)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_encryption_keys", disk_encryption_keys)
        pulumi.set(__self__, "disk_name", disk_name)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "guest_os_features", guest_os_features)
        pulumi.set(__self__, "interface", interface)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "provisioned_iops", provisioned_iops)
        pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)
        pulumi.set(__self__, "resource_policies", resource_policies)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_image", source_image)
        pulumi.set(__self__, "source_image_encryption_keys", source_image_encryption_keys)
        pulumi.set(__self__, "source_snapshot", source_snapshot)
        pulumi.set(__self__, "source_snapshot_encryption_keys", source_snapshot_encryption_keys)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def architecture(self) -> _builtins.str:
        """
        The architecture of the image. Allowed values are ARM64 or X86_64.
        """
        return pulumi.get(self, "architecture")

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> _builtins.bool:
        """
        Whether or not the disk should be auto-deleted. This defaults to true.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter
    def boot(self) -> _builtins.bool:
        """
        Indicates that this is a boot disk. This defaults to false.
        """
        return pulumi.get(self, "boot")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance. If not specified, the server chooses a default device name to apply to this disk.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeys")
    def disk_encryption_keys(self) -> Sequence['outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKeyResult']:
        """
        Encrypts or decrypts a disk using a customer-supplied encryption key.
        """
        return pulumi.get(self, "disk_encryption_keys")

    @_builtins.property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> _builtins.str:
        """
        Name of the disk. When not provided, this defaults to the name of the instance.
        """
        return pulumi.get(self, "disk_name")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.int:
        """
        The size of the image in gigabytes. If not specified, it will inherit the size of its base image. For SCRATCH disks, the size must be one of 375 or 3000 GB, with a default of 375 GB.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> _builtins.str:
        """
        The Google Compute Engine disk type. Such as "pd-ssd", "local-ssd", "pd-balanced" or "pd-standard".
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="guestOsFeatures")
    def guest_os_features(self) -> Sequence[_builtins.str]:
        """
        A list of features to enable on the guest operating system. Applicable only for bootable images.
        """
        return pulumi.get(self, "guest_os_features")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> _builtins.str:
        """
        Specifies the disk interface to use for attaching this disk.
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabelResult']:
        """
        A set of key/value label pairs to assign to disks.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If you are attaching or creating a boot disk, this must read-write mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="provisionedIops")
    def provisioned_iops(self) -> _builtins.int:
        """
        Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle. For more details, see the [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk) or the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks) depending on the selected disk_type.
        """
        return pulumi.get(self, "provisioned_iops")

    @_builtins.property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> _builtins.int:
        """
        Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
        """
        return pulumi.get(self, "provisioned_throughput")

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Sequence['outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTagResult']:
        """
        A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        return pulumi.get(self, "resource_manager_tags")

    @_builtins.property
    @pulumi.getter(name="resourcePolicies")
    def resource_policies(self) -> Sequence[_builtins.str]:
        """
        A list (short name or id) of resource policies to attach to this disk. Currently a max of 1 resource policy is supported.
        """
        return pulumi.get(self, "resource_policies")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The name (not self_link) of the disk (such as those managed by google_compute_disk) to attach. > Note: Either source or source_image is required when creating a new instance except for when creating a local SSD.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> _builtins.str:
        """
        The image from which to initialize this disk. This can be one of: the image's self_link, projects/{project}/global/images/{image}, projects/{project}/global/images/family/{family}, global/images/{image}, global/images/family/{family}, family/{family}, {project}/{family}, {project}/{image}, {family}, or {image}. > Note: Either source or source_image is required when creating a new instance except for when creating a local SSD.
        """
        return pulumi.get(self, "source_image")

    @_builtins.property
    @pulumi.getter(name="sourceImageEncryptionKeys")
    def source_image_encryption_keys(self) -> Sequence['outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKeyResult']:
        """
        The customer-supplied encryption key of the source image. Required if the source image is protected by a customer-supplied encryption key. Instance templates do not store customer-supplied encryption keys, so you cannot create disks for instances in a managed instance group if the source images are encrypted with your own keys.
        """
        return pulumi.get(self, "source_image_encryption_keys")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshot")
    def source_snapshot(self) -> _builtins.str:
        """
        The source snapshot to create this disk. When creating a new instance, one of initializeParams.sourceSnapshot, initializeParams.sourceImage, or disks.source is required except for local SSD.
        """
        return pulumi.get(self, "source_snapshot")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshotEncryptionKeys")
    def source_snapshot_encryption_keys(self) -> Sequence['outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKeyResult']:
        """
        The customer-supplied encryption key of the source snapshot.
        """
        return pulumi.get(self, "source_snapshot_encryption_keys")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Google Compute Engine disk, can be either "SCRATCH" or "PERSISTENT".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 raw_key: _builtins.str,
                 rsa_encrypted_key: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> _builtins.str:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabelResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The unique key of the label to assign to disks.
        :param _builtins.str value: The value of the label to assign to disks.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The unique key of the label to assign to disks.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the label to assign to disks.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The unique key of the resource manager tag to assign to disks. Keys must be in the format tagKeys/{tag_key_id}.
        :param _builtins.str value: The value of the resource manager tag to assign to disks. Values must be in the format tagValues/456.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The unique key of the resource manager tag to assign to disks. Keys must be in the format tagKeys/{tag_key_id}.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the resource manager tag to assign to disks. Values must be in the format tagValues/456.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 raw_key: _builtins.str,
                 rsa_encrypted_key: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> _builtins.str:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 raw_key: _builtins.str,
                 rsa_encrypted_key: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> _builtins.str:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class GetRegionInstanceGroupManagerInstanceLifecyclePolicyResult(dict):
    def __init__(__self__, *,
                 default_action_on_failure: _builtins.str,
                 force_update_on_repair: _builtins.str,
                 on_failed_health_check: _builtins.str,
                 on_repairs: Sequence['outputs.GetRegionInstanceGroupManagerInstanceLifecyclePolicyOnRepairResult']):
        """
        :param _builtins.str default_action_on_failure: Specifies the action that a MIG performs on a failed VM. If the value of the "on_failed_health_check" field is DEFAULT_ACTION, then the same action also applies to the VMs on which your application fails a health check. Valid values are: REPAIR, DO_NOTHING. If REPAIR (default), then MIG automatically repairs a failed VM by recreating it. For more information, see about repairing VMs in a MIG. If DO_NOTHING, then MIG does not repair a failed VM.
        :param _builtins.str force_update_on_repair: Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: YES, NO. If YES and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If NO (default), then updates are applied in accordance with the group's update policy type.
        :param _builtins.str on_failed_health_check: Specifies the action that a MIG performs on an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid values are: DEFAULT_ACTION, DO_NOTHING, REPAIR. If DEFAULT_ACTION (default), then MIG uses the same action configured for the  "default_action_on_failure" field. If DO_NOTHING, then MIG does not repair unhealthy VM. If REPAIR, then MIG automatically repairs an unhealthy VM by recreating it.
        :param Sequence['GetRegionInstanceGroupManagerInstanceLifecyclePolicyOnRepairArgs'] on_repairs: Configuration for VM repairs in the MIG.
        """
        pulumi.set(__self__, "default_action_on_failure", default_action_on_failure)
        pulumi.set(__self__, "force_update_on_repair", force_update_on_repair)
        pulumi.set(__self__, "on_failed_health_check", on_failed_health_check)
        pulumi.set(__self__, "on_repairs", on_repairs)

    @_builtins.property
    @pulumi.getter(name="defaultActionOnFailure")
    def default_action_on_failure(self) -> _builtins.str:
        """
        Specifies the action that a MIG performs on a failed VM. If the value of the "on_failed_health_check" field is DEFAULT_ACTION, then the same action also applies to the VMs on which your application fails a health check. Valid values are: REPAIR, DO_NOTHING. If REPAIR (default), then MIG automatically repairs a failed VM by recreating it. For more information, see about repairing VMs in a MIG. If DO_NOTHING, then MIG does not repair a failed VM.
        """
        return pulumi.get(self, "default_action_on_failure")

    @_builtins.property
    @pulumi.getter(name="forceUpdateOnRepair")
    def force_update_on_repair(self) -> _builtins.str:
        """
        Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: YES, NO. If YES and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If NO (default), then updates are applied in accordance with the group's update policy type.
        """
        return pulumi.get(self, "force_update_on_repair")

    @_builtins.property
    @pulumi.getter(name="onFailedHealthCheck")
    def on_failed_health_check(self) -> _builtins.str:
        """
        Specifies the action that a MIG performs on an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid values are: DEFAULT_ACTION, DO_NOTHING, REPAIR. If DEFAULT_ACTION (default), then MIG uses the same action configured for the  "default_action_on_failure" field. If DO_NOTHING, then MIG does not repair unhealthy VM. If REPAIR, then MIG automatically repairs an unhealthy VM by recreating it.
        """
        return pulumi.get(self, "on_failed_health_check")

    @_builtins.property
    @pulumi.getter(name="onRepairs")
    def on_repairs(self) -> Sequence['outputs.GetRegionInstanceGroupManagerInstanceLifecyclePolicyOnRepairResult']:
        """
        Configuration for VM repairs in the MIG.
        """
        return pulumi.get(self, "on_repairs")


@pulumi.output_type
class GetRegionInstanceGroupManagerInstanceLifecyclePolicyOnRepairResult(dict):
    def __init__(__self__, *,
                 allow_changing_zone: _builtins.str):
        """
        :param _builtins.str allow_changing_zone: Specifies whether the MIG can change a VM's zone during a repair. If "YES", MIG can select a different zone for the VM during a repair. Else if "NO", MIG cannot change a VM's zone during a repair. The default value of allow_changing_zone is "NO".
        """
        pulumi.set(__self__, "allow_changing_zone", allow_changing_zone)

    @_builtins.property
    @pulumi.getter(name="allowChangingZone")
    def allow_changing_zone(self) -> _builtins.str:
        """
        Specifies whether the MIG can change a VM's zone during a repair. If "YES", MIG can select a different zone for the VM during a repair. Else if "NO", MIG cannot change a VM's zone during a repair. The default value of allow_changing_zone is "NO".
        """
        return pulumi.get(self, "allow_changing_zone")


@pulumi.output_type
class GetRegionInstanceGroupManagerNamedPortResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str name: The name of the instance group. Either `name` or `self_link` must be provided.
        :param _builtins.int port: The port number.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance group. Either `name` or `self_link` must be provided.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port number.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetRegionInstanceGroupManagerParamResult(dict):
    def __init__(__self__, *,
                 resource_manager_tags: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to bind to the managed instance group. The tags are key-value pairs. Keys must be in the format tagKeys/123 and values in the format tagValues/456.
        """
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        Resource manager tags to bind to the managed instance group. The tags are key-value pairs. Keys must be in the format tagKeys/123 and values in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class GetRegionInstanceGroupManagerStandbyPolicyResult(dict):
    def __init__(__self__, *,
                 initial_delay_sec: _builtins.int,
                 mode: _builtins.str):
        """
        :param _builtins.int initial_delay_sec: Specifies the number of seconds that the MIG should wait to suspend or stop a VM after that VM was created. The initial delay gives the initialization script the time to prepare your VM for a quick scale out. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
        :param _builtins.str mode: Defines how a MIG resumes or starts VMs from a standby pool when the group scales out. The default mode is "MANUAL".
        """
        pulumi.set(__self__, "initial_delay_sec", initial_delay_sec)
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="initialDelaySec")
    def initial_delay_sec(self) -> _builtins.int:
        """
        Specifies the number of seconds that the MIG should wait to suspend or stop a VM after that VM was created. The initial delay gives the initialization script the time to prepare your VM for a quick scale out. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
        """
        return pulumi.get(self, "initial_delay_sec")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Defines how a MIG resumes or starts VMs from a standby pool when the group scales out. The default mode is "MANUAL".
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetRegionInstanceGroupManagerStatefulDiskResult(dict):
    def __init__(__self__, *,
                 delete_rule: _builtins.str,
                 device_name: _builtins.str):
        """
        :param _builtins.str delete_rule: A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the disk when the VM is deleted, but do not delete the disk. ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently deleted from the instance group. The default is NEVER.
        :param _builtins.str device_name: The device name of the disk to be attached.
        """
        pulumi.set(__self__, "delete_rule", delete_rule)
        pulumi.set(__self__, "device_name", device_name)

    @_builtins.property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> _builtins.str:
        """
        A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the disk when the VM is deleted, but do not delete the disk. ON_PERMANENT_INSTANCE_DELETION will delete the stateful disk when the VM is permanently deleted from the instance group. The default is NEVER.
        """
        return pulumi.get(self, "delete_rule")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        The device name of the disk to be attached.
        """
        return pulumi.get(self, "device_name")


@pulumi.output_type
class GetRegionInstanceGroupManagerStatefulExternalIpResult(dict):
    def __init__(__self__, *,
                 delete_rule: _builtins.str,
                 interface_name: _builtins.str):
        """
        :param _builtins.str delete_rule: A value that prescribes what should happen to an associated static Address resource when a VM instance is permanently deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the IP when the VM is deleted, but do not delete the address resource. ON_PERMANENT_INSTANCE_DELETION will delete the stateful address when the VM is permanently deleted from the instance group. The default is NEVER.
        :param _builtins.str interface_name: The network interface name
        """
        pulumi.set(__self__, "delete_rule", delete_rule)
        pulumi.set(__self__, "interface_name", interface_name)

    @_builtins.property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> _builtins.str:
        """
        A value that prescribes what should happen to an associated static Address resource when a VM instance is permanently deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the IP when the VM is deleted, but do not delete the address resource. ON_PERMANENT_INSTANCE_DELETION will delete the stateful address when the VM is permanently deleted from the instance group. The default is NEVER.
        """
        return pulumi.get(self, "delete_rule")

    @_builtins.property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> _builtins.str:
        """
        The network interface name
        """
        return pulumi.get(self, "interface_name")


@pulumi.output_type
class GetRegionInstanceGroupManagerStatefulInternalIpResult(dict):
    def __init__(__self__, *,
                 delete_rule: _builtins.str,
                 interface_name: _builtins.str):
        """
        :param _builtins.str delete_rule: A value that prescribes what should happen to an associated static Address resource when a VM instance is permanently deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the IP when the VM is deleted, but do not delete the address resource. ON_PERMANENT_INSTANCE_DELETION will delete the stateful address when the VM is permanently deleted from the instance group. The default is NEVER.
        :param _builtins.str interface_name: The network interface name
        """
        pulumi.set(__self__, "delete_rule", delete_rule)
        pulumi.set(__self__, "interface_name", interface_name)

    @_builtins.property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> _builtins.str:
        """
        A value that prescribes what should happen to an associated static Address resource when a VM instance is permanently deleted. The available options are NEVER and ON_PERMANENT_INSTANCE_DELETION. NEVER - detach the IP when the VM is deleted, but do not delete the address resource. ON_PERMANENT_INSTANCE_DELETION will delete the stateful address when the VM is permanently deleted from the instance group. The default is NEVER.
        """
        return pulumi.get(self, "delete_rule")

    @_builtins.property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> _builtins.str:
        """
        The network interface name
        """
        return pulumi.get(self, "interface_name")


@pulumi.output_type
class GetRegionInstanceGroupManagerStatusResult(dict):
    def __init__(__self__, *,
                 all_instances_configs: Sequence['outputs.GetRegionInstanceGroupManagerStatusAllInstancesConfigResult'],
                 is_stable: _builtins.bool,
                 statefuls: Sequence['outputs.GetRegionInstanceGroupManagerStatusStatefulResult'],
                 version_targets: Sequence['outputs.GetRegionInstanceGroupManagerStatusVersionTargetResult']):
        """
        :param Sequence['GetRegionInstanceGroupManagerStatusAllInstancesConfigArgs'] all_instances_configs: Status of all-instances configuration on the group.
        :param _builtins.bool is_stable: A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
        :param Sequence['GetRegionInstanceGroupManagerStatusStatefulArgs'] statefuls: Stateful status of the given Instance Group Manager.
        :param Sequence['GetRegionInstanceGroupManagerStatusVersionTargetArgs'] version_targets: A status of consistency of Instances' versions with their target version specified by version field on Instance Group Manager.
        """
        pulumi.set(__self__, "all_instances_configs", all_instances_configs)
        pulumi.set(__self__, "is_stable", is_stable)
        pulumi.set(__self__, "statefuls", statefuls)
        pulumi.set(__self__, "version_targets", version_targets)

    @_builtins.property
    @pulumi.getter(name="allInstancesConfigs")
    def all_instances_configs(self) -> Sequence['outputs.GetRegionInstanceGroupManagerStatusAllInstancesConfigResult']:
        """
        Status of all-instances configuration on the group.
        """
        return pulumi.get(self, "all_instances_configs")

    @_builtins.property
    @pulumi.getter(name="isStable")
    def is_stable(self) -> _builtins.bool:
        """
        A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
        """
        return pulumi.get(self, "is_stable")

    @_builtins.property
    @pulumi.getter
    def statefuls(self) -> Sequence['outputs.GetRegionInstanceGroupManagerStatusStatefulResult']:
        """
        Stateful status of the given Instance Group Manager.
        """
        return pulumi.get(self, "statefuls")

    @_builtins.property
    @pulumi.getter(name="versionTargets")
    def version_targets(self) -> Sequence['outputs.GetRegionInstanceGroupManagerStatusVersionTargetResult']:
        """
        A status of consistency of Instances' versions with their target version specified by version field on Instance Group Manager.
        """
        return pulumi.get(self, "version_targets")


@pulumi.output_type
class GetRegionInstanceGroupManagerStatusAllInstancesConfigResult(dict):
    def __init__(__self__, *,
                 current_revision: _builtins.str,
                 effective: _builtins.bool):
        """
        :param _builtins.str current_revision: Current all-instances configuration revision. This value is in RFC3339 text format.
        :param _builtins.bool effective: A bit indicating whether this configuration has been applied to all managed instances in the group.
        """
        pulumi.set(__self__, "current_revision", current_revision)
        pulumi.set(__self__, "effective", effective)

    @_builtins.property
    @pulumi.getter(name="currentRevision")
    def current_revision(self) -> _builtins.str:
        """
        Current all-instances configuration revision. This value is in RFC3339 text format.
        """
        return pulumi.get(self, "current_revision")

    @_builtins.property
    @pulumi.getter
    def effective(self) -> _builtins.bool:
        """
        A bit indicating whether this configuration has been applied to all managed instances in the group.
        """
        return pulumi.get(self, "effective")


@pulumi.output_type
class GetRegionInstanceGroupManagerStatusStatefulResult(dict):
    def __init__(__self__, *,
                 has_stateful_config: _builtins.bool,
                 per_instance_configs: Sequence['outputs.GetRegionInstanceGroupManagerStatusStatefulPerInstanceConfigResult']):
        """
        :param _builtins.bool has_stateful_config: A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
        :param Sequence['GetRegionInstanceGroupManagerStatusStatefulPerInstanceConfigArgs'] per_instance_configs: Status of per-instance configs on the instances.
        """
        pulumi.set(__self__, "has_stateful_config", has_stateful_config)
        pulumi.set(__self__, "per_instance_configs", per_instance_configs)

    @_builtins.property
    @pulumi.getter(name="hasStatefulConfig")
    def has_stateful_config(self) -> _builtins.bool:
        """
        A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
        """
        return pulumi.get(self, "has_stateful_config")

    @_builtins.property
    @pulumi.getter(name="perInstanceConfigs")
    def per_instance_configs(self) -> Sequence['outputs.GetRegionInstanceGroupManagerStatusStatefulPerInstanceConfigResult']:
        """
        Status of per-instance configs on the instances.
        """
        return pulumi.get(self, "per_instance_configs")


@pulumi.output_type
class GetRegionInstanceGroupManagerStatusStatefulPerInstanceConfigResult(dict):
    def __init__(__self__, *,
                 all_effective: _builtins.bool):
        """
        :param _builtins.bool all_effective: A bit indicating if all of the group's per-instance configs (listed in the output of a listPerInstanceConfigs API call) have status EFFECTIVE or there are no per-instance-configs.
        """
        pulumi.set(__self__, "all_effective", all_effective)

    @_builtins.property
    @pulumi.getter(name="allEffective")
    def all_effective(self) -> _builtins.bool:
        """
        A bit indicating if all of the group's per-instance configs (listed in the output of a listPerInstanceConfigs API call) have status EFFECTIVE or there are no per-instance-configs.
        """
        return pulumi.get(self, "all_effective")


@pulumi.output_type
class GetRegionInstanceGroupManagerStatusVersionTargetResult(dict):
    def __init__(__self__, *,
                 is_reached: _builtins.bool):
        """
        :param _builtins.bool is_reached: A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
        """
        pulumi.set(__self__, "is_reached", is_reached)

    @_builtins.property
    @pulumi.getter(name="isReached")
    def is_reached(self) -> _builtins.bool:
        """
        A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
        """
        return pulumi.get(self, "is_reached")


@pulumi.output_type
class GetRegionInstanceGroupManagerUpdatePolicyResult(dict):
    def __init__(__self__, *,
                 instance_redistribution_type: _builtins.str,
                 max_surge_fixed: _builtins.int,
                 max_surge_percent: _builtins.int,
                 max_unavailable_fixed: _builtins.int,
                 max_unavailable_percent: _builtins.int,
                 min_ready_sec: _builtins.int,
                 minimal_action: _builtins.str,
                 most_disruptive_allowed_action: _builtins.str,
                 replacement_method: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str instance_redistribution_type: The instance redistribution policy for regional managed instance groups. Valid values are: "PROACTIVE", "NONE". If PROACTIVE (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If NONE, proactive redistribution is disabled.
        :param _builtins.int max_surge_fixed: Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with max_surge_percent. Both cannot be 0
        :param _builtins.int max_surge_percent: Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with max_surge_fixed.
        :param _builtins.int max_unavailable_fixed: Specifies a fixed number of VM instances. This must be a positive integer.
        :param _builtins.int max_unavailable_percent: Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
        :param _builtins.int min_ready_sec: Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600].
        :param _builtins.str minimal_action: Minimal action to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to update without stopping instances, RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a REFRESH, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        :param _builtins.str most_disruptive_allowed_action: Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
        :param _builtins.str replacement_method: The instance replacement method for regional managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
        :param _builtins.str type: The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        """
        pulumi.set(__self__, "instance_redistribution_type", instance_redistribution_type)
        pulumi.set(__self__, "max_surge_fixed", max_surge_fixed)
        pulumi.set(__self__, "max_surge_percent", max_surge_percent)
        pulumi.set(__self__, "max_unavailable_fixed", max_unavailable_fixed)
        pulumi.set(__self__, "max_unavailable_percent", max_unavailable_percent)
        pulumi.set(__self__, "min_ready_sec", min_ready_sec)
        pulumi.set(__self__, "minimal_action", minimal_action)
        pulumi.set(__self__, "most_disruptive_allowed_action", most_disruptive_allowed_action)
        pulumi.set(__self__, "replacement_method", replacement_method)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="instanceRedistributionType")
    def instance_redistribution_type(self) -> _builtins.str:
        """
        The instance redistribution policy for regional managed instance groups. Valid values are: "PROACTIVE", "NONE". If PROACTIVE (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If NONE, proactive redistribution is disabled.
        """
        return pulumi.get(self, "instance_redistribution_type")

    @_builtins.property
    @pulumi.getter(name="maxSurgeFixed")
    def max_surge_fixed(self) -> _builtins.int:
        """
        Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with max_surge_percent. Both cannot be 0
        """
        return pulumi.get(self, "max_surge_fixed")

    @_builtins.property
    @pulumi.getter(name="maxSurgePercent")
    def max_surge_percent(self) -> _builtins.int:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with max_surge_fixed.
        """
        return pulumi.get(self, "max_surge_percent")

    @_builtins.property
    @pulumi.getter(name="maxUnavailableFixed")
    def max_unavailable_fixed(self) -> _builtins.int:
        """
        Specifies a fixed number of VM instances. This must be a positive integer.
        """
        return pulumi.get(self, "max_unavailable_fixed")

    @_builtins.property
    @pulumi.getter(name="maxUnavailablePercent")
    def max_unavailable_percent(self) -> _builtins.int:
        """
        Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
        """
        return pulumi.get(self, "max_unavailable_percent")

    @_builtins.property
    @pulumi.getter(name="minReadySec")
    def min_ready_sec(self) -> _builtins.int:
        """
        Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600].
        """
        return pulumi.get(self, "min_ready_sec")

    @_builtins.property
    @pulumi.getter(name="minimalAction")
    def minimal_action(self) -> _builtins.str:
        """
        Minimal action to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to update without stopping instances, RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a REFRESH, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
        """
        return pulumi.get(self, "minimal_action")

    @_builtins.property
    @pulumi.getter(name="mostDisruptiveAllowedAction")
    def most_disruptive_allowed_action(self) -> _builtins.str:
        """
        Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
        """
        return pulumi.get(self, "most_disruptive_allowed_action")

    @_builtins.property
    @pulumi.getter(name="replacementMethod")
    def replacement_method(self) -> _builtins.str:
        """
        The instance replacement method for regional managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.
        """
        return pulumi.get(self, "replacement_method")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRegionInstanceGroupManagerVersionResult(dict):
    def __init__(__self__, *,
                 instance_template: _builtins.str,
                 name: _builtins.str,
                 target_sizes: Sequence['outputs.GetRegionInstanceGroupManagerVersionTargetSizeResult']):
        """
        :param _builtins.str instance_template: The full URL to an instance template from which all new instances of this version will be created.
        :param _builtins.str name: The name of the instance group. Either `name` or `self_link` must be provided.
        :param Sequence['GetRegionInstanceGroupManagerVersionTargetSizeArgs'] target_sizes: The number of instances calculated as a fixed number or a percentage depending on the settings.
        """
        pulumi.set(__self__, "instance_template", instance_template)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_sizes", target_sizes)

    @_builtins.property
    @pulumi.getter(name="instanceTemplate")
    def instance_template(self) -> _builtins.str:
        """
        The full URL to an instance template from which all new instances of this version will be created.
        """
        return pulumi.get(self, "instance_template")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance group. Either `name` or `self_link` must be provided.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="targetSizes")
    def target_sizes(self) -> Sequence['outputs.GetRegionInstanceGroupManagerVersionTargetSizeResult']:
        """
        The number of instances calculated as a fixed number or a percentage depending on the settings.
        """
        return pulumi.get(self, "target_sizes")


@pulumi.output_type
class GetRegionInstanceGroupManagerVersionTargetSizeResult(dict):
    def __init__(__self__, *,
                 fixed: _builtins.int,
                 percent: _builtins.int):
        """
        :param _builtins.int fixed: The number of instances which are managed for this version. Conflicts with percent.
        :param _builtins.int percent: The number of instances (calculated as percentage) which are managed for this version. Conflicts with fixed. Note that when using percent, rounding will be in favor of explicitly set target_size values; a managed instance group with 2 instances and 2 versions, one of which has a target_size.percent of 60 will create 2 instances of that version.
        """
        pulumi.set(__self__, "fixed", fixed)
        pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter
    def fixed(self) -> _builtins.int:
        """
        The number of instances which are managed for this version. Conflicts with percent.
        """
        return pulumi.get(self, "fixed")

    @_builtins.property
    @pulumi.getter
    def percent(self) -> _builtins.int:
        """
        The number of instances (calculated as percentage) which are managed for this version. Conflicts with fixed. Note that when using percent, rounding will be in favor of explicitly set target_size values; a managed instance group with 2 instances and 2 versions, one of which has a target_size.percent of 60 will create 2 instances of that version.
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class GetRegionInstanceTemplateAdvancedMachineFeatureResult(dict):
    def __init__(__self__, *,
                 enable_nested_virtualization: _builtins.bool,
                 enable_uefi_networking: _builtins.bool,
                 performance_monitoring_unit: _builtins.str,
                 threads_per_core: _builtins.int,
                 turbo_mode: _builtins.str,
                 visible_core_count: _builtins.int):
        """
        :param _builtins.bool enable_nested_virtualization: Whether to enable nested virtualization or not.
        :param _builtins.bool enable_uefi_networking: Whether to enable UEFI networking or not.
        :param _builtins.str performance_monitoring_unit: The PMU is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are "STANDARD", "ENHANCED", and "ARCHITECTURAL".
        :param _builtins.int threads_per_core: The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
        :param _builtins.str turbo_mode: Turbo frequency mode to use for the instance. Currently supported modes is "ALL_CORE_MAX".
        :param _builtins.int visible_core_count: The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance\\'s nominal CPU count and the underlying platform\\'s SMT width.
        """
        pulumi.set(__self__, "enable_nested_virtualization", enable_nested_virtualization)
        pulumi.set(__self__, "enable_uefi_networking", enable_uefi_networking)
        pulumi.set(__self__, "performance_monitoring_unit", performance_monitoring_unit)
        pulumi.set(__self__, "threads_per_core", threads_per_core)
        pulumi.set(__self__, "turbo_mode", turbo_mode)
        pulumi.set(__self__, "visible_core_count", visible_core_count)

    @_builtins.property
    @pulumi.getter(name="enableNestedVirtualization")
    def enable_nested_virtualization(self) -> _builtins.bool:
        """
        Whether to enable nested virtualization or not.
        """
        return pulumi.get(self, "enable_nested_virtualization")

    @_builtins.property
    @pulumi.getter(name="enableUefiNetworking")
    def enable_uefi_networking(self) -> _builtins.bool:
        """
        Whether to enable UEFI networking or not.
        """
        return pulumi.get(self, "enable_uefi_networking")

    @_builtins.property
    @pulumi.getter(name="performanceMonitoringUnit")
    def performance_monitoring_unit(self) -> _builtins.str:
        """
        The PMU is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are "STANDARD", "ENHANCED", and "ARCHITECTURAL".
        """
        return pulumi.get(self, "performance_monitoring_unit")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> _builtins.int:
        """
        The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
        """
        return pulumi.get(self, "threads_per_core")

    @_builtins.property
    @pulumi.getter(name="turboMode")
    def turbo_mode(self) -> _builtins.str:
        """
        Turbo frequency mode to use for the instance. Currently supported modes is "ALL_CORE_MAX".
        """
        return pulumi.get(self, "turbo_mode")

    @_builtins.property
    @pulumi.getter(name="visibleCoreCount")
    def visible_core_count(self) -> _builtins.int:
        """
        The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance\\'s nominal CPU count and the underlying platform\\'s SMT width.
        """
        return pulumi.get(self, "visible_core_count")


@pulumi.output_type
class GetRegionInstanceTemplateConfidentialInstanceConfigResult(dict):
    def __init__(__self__, *,
                 confidential_instance_type: _builtins.str,
                 enable_confidential_compute: _builtins.bool):
        """
        :param _builtins.str confidential_instance_type: The confidential computing technology the instance uses.
               								SEV is an AMD feature. TDX is an Intel feature. One of the following
               								values is required: SEV, SEV_SNP, TDX. If SEV_SNP, min_cpu_platform =
               								"AMD Milan" is currently required.
        :param _builtins.bool enable_confidential_compute: Defines whether the instance should have confidential compute enabled. `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.
        """
        pulumi.set(__self__, "confidential_instance_type", confidential_instance_type)
        pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @_builtins.property
    @pulumi.getter(name="confidentialInstanceType")
    def confidential_instance_type(self) -> _builtins.str:
        """
        The confidential computing technology the instance uses.
        								SEV is an AMD feature. TDX is an Intel feature. One of the following
        								values is required: SEV, SEV_SNP, TDX. If SEV_SNP, min_cpu_platform =
        								"AMD Milan" is currently required.
        """
        return pulumi.get(self, "confidential_instance_type")

    @_builtins.property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> _builtins.bool:
        """
        Defines whether the instance should have confidential compute enabled. `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.
        """
        return pulumi.get(self, "enable_confidential_compute")


@pulumi.output_type
class GetRegionInstanceTemplateDiskResult(dict):
    def __init__(__self__, *,
                 architecture: _builtins.str,
                 auto_delete: _builtins.bool,
                 boot: _builtins.bool,
                 device_name: _builtins.str,
                 disk_encryption_keys: Sequence['outputs.GetRegionInstanceTemplateDiskDiskEncryptionKeyResult'],
                 disk_name: _builtins.str,
                 disk_size_gb: _builtins.int,
                 disk_type: _builtins.str,
                 guest_os_features: Sequence[_builtins.str],
                 interface: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 mode: _builtins.str,
                 provisioned_iops: _builtins.int,
                 provisioned_throughput: _builtins.int,
                 resource_manager_tags: Mapping[str, _builtins.str],
                 resource_policies: Sequence[_builtins.str],
                 source: _builtins.str,
                 source_image: _builtins.str,
                 source_image_encryption_keys: Sequence['outputs.GetRegionInstanceTemplateDiskSourceImageEncryptionKeyResult'],
                 source_snapshot: _builtins.str,
                 source_snapshot_encryption_keys: Sequence['outputs.GetRegionInstanceTemplateDiskSourceSnapshotEncryptionKeyResult'],
                 type: _builtins.str):
        """
        :param _builtins.str architecture: The architecture of the image. Allowed values are ARM64 or X86_64.
        :param _builtins.bool auto_delete: Whether or not the disk should be auto-deleted.
               This defaults to true.
        :param _builtins.bool boot: Indicates that this is a boot disk.
        :param _builtins.str device_name: A unique device name that is reflected into the
               /dev/  tree of a Linux operating system running within the instance. If not
               specified, the server chooses a default device name to apply to this disk.
        :param Sequence['GetRegionInstanceTemplateDiskDiskEncryptionKeyArgs'] disk_encryption_keys: Encrypts or decrypts a disk using a customer-supplied encryption key.
        :param _builtins.str disk_name: Name of the disk. When not provided, this defaults
               to the name of the instance.
        :param _builtins.int disk_size_gb: The size of the image in gigabytes. If not
               specified, it will inherit the size of its base image. For SCRATCH disks,
               the size must be exactly 375GB.
        :param _builtins.str disk_type: The GCE disk type. Such as `"pd-ssd"`, `"local-ssd"`,
               `"pd-balanced"` or `"pd-standard"`.
        :param Sequence[_builtins.str] guest_os_features: A list of features to enable on the guest operating system. Applicable only for bootable images.
        :param _builtins.str interface: Specifies the disk interface to use for attaching this disk,
               which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
               and the request will fail if you attempt to attach a persistent disk in any other format
               than SCSI. Local SSDs can use either NVME or SCSI.
        :param Mapping[str, _builtins.str] labels: (Optional) A set of ket/value label pairs to assign to disk created from
               this template
        :param _builtins.str mode: The mode in which to attach this disk, either READ_WRITE
               or READ_ONLY. If you are attaching or creating a boot disk, this must
               read-write mode.
        :param _builtins.int provisioned_iops: Indicates how many IOPS to provision for the disk. This
               sets the number of I/O operations per second that the disk can handle.
               Values must be between 10,000 and 120,000. For more details, see the
               [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk).
        :param _builtins.int provisioned_throughput: Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
        :param Mapping[str, _builtins.str] resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        :param Sequence[_builtins.str] resource_policies: (Optional) -- A list of short names of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
        :param _builtins.str source: The name (**not self_link**)
               of the disk (such as those managed by `compute.Disk`) to attach.
               > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param _builtins.str source_image: The image from which to
               initialize this disk. This can be one of: the image's `self_link`,
               `projects/{project}/global/images/{image}`,
               `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
               `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
               `{project}/{image}`, `{family}`, or `{image}`.
               > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        :param Sequence['GetRegionInstanceTemplateDiskSourceImageEncryptionKeyArgs'] source_image_encryption_keys: The customer-supplied encryption key of the source
               image. Required if the source image is protected by a
               customer-supplied encryption key.
               
               Instance templates do not store customer-supplied
               encryption keys, so you cannot create disks for
               instances in a managed instance group if the source
               images are encrypted with your own keys.
        :param _builtins.str source_snapshot: The source snapshot to create this disk. When creating
               a new instance, one of initializeParams.sourceSnapshot,
               initializeParams.sourceImage, or disks.source is
               required except for local SSD.
        :param Sequence['GetRegionInstanceTemplateDiskSourceSnapshotEncryptionKeyArgs'] source_snapshot_encryption_keys: The customer-supplied encryption key of the source snapshot.
        :param _builtins.str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "architecture", architecture)
        pulumi.set(__self__, "auto_delete", auto_delete)
        pulumi.set(__self__, "boot", boot)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_encryption_keys", disk_encryption_keys)
        pulumi.set(__self__, "disk_name", disk_name)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "guest_os_features", guest_os_features)
        pulumi.set(__self__, "interface", interface)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "provisioned_iops", provisioned_iops)
        pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)
        pulumi.set(__self__, "resource_policies", resource_policies)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_image", source_image)
        pulumi.set(__self__, "source_image_encryption_keys", source_image_encryption_keys)
        pulumi.set(__self__, "source_snapshot", source_snapshot)
        pulumi.set(__self__, "source_snapshot_encryption_keys", source_snapshot_encryption_keys)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def architecture(self) -> _builtins.str:
        """
        The architecture of the image. Allowed values are ARM64 or X86_64.
        """
        return pulumi.get(self, "architecture")

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> _builtins.bool:
        """
        Whether or not the disk should be auto-deleted.
        This defaults to true.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter
    def boot(self) -> _builtins.bool:
        """
        Indicates that this is a boot disk.
        """
        return pulumi.get(self, "boot")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        A unique device name that is reflected into the
        /dev/  tree of a Linux operating system running within the instance. If not
        specified, the server chooses a default device name to apply to this disk.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeys")
    def disk_encryption_keys(self) -> Sequence['outputs.GetRegionInstanceTemplateDiskDiskEncryptionKeyResult']:
        """
        Encrypts or decrypts a disk using a customer-supplied encryption key.
        """
        return pulumi.get(self, "disk_encryption_keys")

    @_builtins.property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> _builtins.str:
        """
        Name of the disk. When not provided, this defaults
        to the name of the instance.
        """
        return pulumi.get(self, "disk_name")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.int:
        """
        The size of the image in gigabytes. If not
        specified, it will inherit the size of its base image. For SCRATCH disks,
        the size must be exactly 375GB.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> _builtins.str:
        """
        The GCE disk type. Such as `"pd-ssd"`, `"local-ssd"`,
        `"pd-balanced"` or `"pd-standard"`.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="guestOsFeatures")
    def guest_os_features(self) -> Sequence[_builtins.str]:
        """
        A list of features to enable on the guest operating system. Applicable only for bootable images.
        """
        return pulumi.get(self, "guest_os_features")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> _builtins.str:
        """
        Specifies the disk interface to use for attaching this disk,
        which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
        and the request will fail if you attempt to attach a persistent disk in any other format
        than SCSI. Local SSDs can use either NVME or SCSI.
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        (Optional) A set of ket/value label pairs to assign to disk created from
        this template
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The mode in which to attach this disk, either READ_WRITE
        or READ_ONLY. If you are attaching or creating a boot disk, this must
        read-write mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="provisionedIops")
    def provisioned_iops(self) -> _builtins.int:
        """
        Indicates how many IOPS to provision for the disk. This
        sets the number of I/O operations per second that the disk can handle.
        Values must be between 10,000 and 120,000. For more details, see the
        [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk).
        """
        return pulumi.get(self, "provisioned_iops")

    @_builtins.property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> _builtins.int:
        """
        Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
        """
        return pulumi.get(self, "provisioned_throughput")

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
        """
        return pulumi.get(self, "resource_manager_tags")

    @_builtins.property
    @pulumi.getter(name="resourcePolicies")
    def resource_policies(self) -> Sequence[_builtins.str]:
        """
        (Optional) -- A list of short names of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
        """
        return pulumi.get(self, "resource_policies")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The name (**not self_link**)
        of the disk (such as those managed by `compute.Disk`) to attach.
        > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> _builtins.str:
        """
        The image from which to
        initialize this disk. This can be one of: the image's `self_link`,
        `projects/{project}/global/images/{image}`,
        `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
        `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
        `{project}/{image}`, `{family}`, or `{image}`.
        > **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
        """
        return pulumi.get(self, "source_image")

    @_builtins.property
    @pulumi.getter(name="sourceImageEncryptionKeys")
    def source_image_encryption_keys(self) -> Sequence['outputs.GetRegionInstanceTemplateDiskSourceImageEncryptionKeyResult']:
        """
        The customer-supplied encryption key of the source
        image. Required if the source image is protected by a
        customer-supplied encryption key.

        Instance templates do not store customer-supplied
        encryption keys, so you cannot create disks for
        instances in a managed instance group if the source
        images are encrypted with your own keys.
        """
        return pulumi.get(self, "source_image_encryption_keys")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshot")
    def source_snapshot(self) -> _builtins.str:
        """
        The source snapshot to create this disk. When creating
        a new instance, one of initializeParams.sourceSnapshot,
        initializeParams.sourceImage, or disks.source is
        required except for local SSD.
        """
        return pulumi.get(self, "source_snapshot")

    @_builtins.property
    @pulumi.getter(name="sourceSnapshotEncryptionKeys")
    def source_snapshot_encryption_keys(self) -> Sequence['outputs.GetRegionInstanceTemplateDiskSourceSnapshotEncryptionKeyResult']:
        """
        The customer-supplied encryption key of the source snapshot.
        """
        return pulumi.get(self, "source_snapshot_encryption_keys")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRegionInstanceTemplateDiskDiskEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS
        :param _builtins.str kms_key_service_account: The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")


@pulumi.output_type
class GetRegionInstanceTemplateDiskSourceImageEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 raw_key: _builtins.str,
                 rsa_encrypted_key: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS
        :param _builtins.str kms_key_service_account: The service account being used for the encryption
               request for the given KMS key. If absent, the Compute
               Engine default service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource.  Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource.  Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account being used for the encryption
        request for the given KMS key. If absent, the Compute
        Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource.  Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> _builtins.str:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource.  Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class GetRegionInstanceTemplateDiskSourceSnapshotEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 raw_key: _builtins.str,
                 rsa_encrypted_key: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The self link of the encryption key that is stored in Google Cloud KMS
        :param _builtins.str kms_key_service_account: The service account being used for the encryption
               request for the given KMS key. If absent, the Compute
               Engine default service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        :param _builtins.str rsa_encrypted_key: Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource.  Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The self link of the encryption key that is stored in Google Cloud KMS
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account being used for the encryption
        request for the given KMS key. If absent, the Compute
        Engine default service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> _builtins.str:
        """
        Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource.  Only one of kms_key_self_link, rsa_encrypted_key and raw_key may be set.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class GetRegionInstanceTemplateGuestAcceleratorResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int count: The number of the guest accelerator cards exposed to this instance.
        :param _builtins.str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of the guest accelerator cards exposed to this instance.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRegionInstanceTemplateNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 access_configs: Sequence['outputs.GetRegionInstanceTemplateNetworkInterfaceAccessConfigResult'],
                 alias_ip_ranges: Sequence['outputs.GetRegionInstanceTemplateNetworkInterfaceAliasIpRangeResult'],
                 internal_ipv6_prefix_length: _builtins.int,
                 ipv6_access_configs: Sequence['outputs.GetRegionInstanceTemplateNetworkInterfaceIpv6AccessConfigResult'],
                 ipv6_access_type: _builtins.str,
                 ipv6_address: _builtins.str,
                 name: _builtins.str,
                 network: _builtins.str,
                 network_ip: _builtins.str,
                 nic_type: _builtins.str,
                 queue_count: _builtins.int,
                 stack_type: _builtins.str,
                 subnetwork: _builtins.str,
                 subnetwork_project: _builtins.str):
        """
        :param Sequence['GetRegionInstanceTemplateNetworkInterfaceAliasIpRangeArgs'] alias_ip_ranges: An
               array of alias IP ranges for this network interface. Can only be specified for network
               interfaces on subnet-mode networks. Structure documented below.
        :param _builtins.int internal_ipv6_prefix_length: The prefix length of the primary internal IPv6 range.
        :param Sequence['GetRegionInstanceTemplateNetworkInterfaceIpv6AccessConfigArgs'] ipv6_access_configs: An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
        :param _builtins.str ipv6_access_type: One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
        :param _builtins.str ipv6_address: An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        :param _builtins.str name: The name of the instance template. One of `name` or `filter` must be provided.
        :param _builtins.str network: The name or self_link of the network to attach this interface to.
               Use `network` attribute for Legacy or Auto subnetted networks and
               `subnetwork` for custom subnetted networks.
        :param _builtins.str network_ip: The private IP address to assign to the instance. If
               empty, the address will be automatically assigned.
        :param _builtins.str nic_type: The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET, MRDMA, and IRDMA
        :param _builtins.int queue_count: The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        :param _builtins.str stack_type: The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
        :param _builtins.str subnetwork: the name of the subnetwork to attach this interface
               to. The subnetwork must exist in the same `region` this instance will be
               created in. Either `network` or `subnetwork` must be provided.
        :param _builtins.str subnetwork_project: The ID of the project in which the subnetwork belongs.
               If it is not provided, the provider project is used.
        """
        pulumi.set(__self__, "access_configs", access_configs)
        pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        pulumi.set(__self__, "internal_ipv6_prefix_length", internal_ipv6_prefix_length)
        pulumi.set(__self__, "ipv6_access_configs", ipv6_access_configs)
        pulumi.set(__self__, "ipv6_access_type", ipv6_access_type)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "network_ip", network_ip)
        pulumi.set(__self__, "nic_type", nic_type)
        pulumi.set(__self__, "queue_count", queue_count)
        pulumi.set(__self__, "stack_type", stack_type)
        pulumi.set(__self__, "subnetwork", subnetwork)
        pulumi.set(__self__, "subnetwork_project", subnetwork_project)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Sequence['outputs.GetRegionInstanceTemplateNetworkInterfaceAccessConfigResult']:
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Sequence['outputs.GetRegionInstanceTemplateNetworkInterfaceAliasIpRangeResult']:
        """
        An
        array of alias IP ranges for this network interface. Can only be specified for network
        interfaces on subnet-mode networks. Structure documented below.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="internalIpv6PrefixLength")
    def internal_ipv6_prefix_length(self) -> _builtins.int:
        """
        The prefix length of the primary internal IPv6 range.
        """
        return pulumi.get(self, "internal_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessConfigs")
    def ipv6_access_configs(self) -> Sequence['outputs.GetRegionInstanceTemplateNetworkInterfaceIpv6AccessConfigResult']:
        """
        An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
        """
        return pulumi.get(self, "ipv6_access_configs")

    @_builtins.property
    @pulumi.getter(name="ipv6AccessType")
    def ipv6_access_type(self) -> _builtins.str:
        """
        One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
        """
        return pulumi.get(self, "ipv6_access_type")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> _builtins.str:
        """
        An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance template. One of `name` or `filter` must be provided.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The name or self_link of the network to attach this interface to.
        Use `network` attribute for Legacy or Auto subnetted networks and
        `subnetwork` for custom subnetted networks.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="networkIp")
    def network_ip(self) -> _builtins.str:
        """
        The private IP address to assign to the instance. If
        empty, the address will be automatically assigned.
        """
        return pulumi.get(self, "network_ip")

    @_builtins.property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> _builtins.str:
        """
        The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET, MRDMA, and IRDMA
        """
        return pulumi.get(self, "nic_type")

    @_builtins.property
    @pulumi.getter(name="queueCount")
    def queue_count(self) -> _builtins.int:
        """
        The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
        """
        return pulumi.get(self, "queue_count")

    @_builtins.property
    @pulumi.getter(name="stackType")
    def stack_type(self) -> _builtins.str:
        """
        The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
        """
        return pulumi.get(self, "stack_type")

    @_builtins.property
    @pulumi.getter
    def subnetwork(self) -> _builtins.str:
        """
        the name of the subnetwork to attach this interface
        to. The subnetwork must exist in the same `region` this instance will be
        created in. Either `network` or `subnetwork` must be provided.
        """
        return pulumi.get(self, "subnetwork")

    @_builtins.property
    @pulumi.getter(name="subnetworkProject")
    def subnetwork_project(self) -> _builtins.str:
        """
        The ID of the project in which the subnetwork belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "subnetwork_project")


@pulumi.output_type
class GetRegionInstanceTemplateNetworkInterfaceAccessConfigResult(dict):
    def __init__(__self__, *,
                 nat_ip: _builtins.str,
                 network_tier: _builtins.str,
                 public_ptr_domain_name: _builtins.str):
        """
        :param _builtins.str nat_ip: The IP address that will be 1:1 mapped to the instance's
               network ip. If not given, one will be generated.
        :param _builtins.str network_tier: The [networking tier][network-tier] used for configuring
               this instance template. This field can take the following values: PREMIUM or
               STANDARD. If this field is not specified, it is assumed to be PREMIUM.
        :param _builtins.str public_ptr_domain_name: The DNS domain name for the public PTR record.The DNS domain name for the public PTR record.
        """
        pulumi.set(__self__, "nat_ip", nat_ip)
        pulumi.set(__self__, "network_tier", network_tier)
        pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)

    @_builtins.property
    @pulumi.getter(name="natIp")
    def nat_ip(self) -> _builtins.str:
        """
        The IP address that will be 1:1 mapped to the instance's
        network ip. If not given, one will be generated.
        """
        return pulumi.get(self, "nat_ip")

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> _builtins.str:
        """
        The [networking tier][network-tier] used for configuring
        this instance template. This field can take the following values: PREMIUM or
        STANDARD. If this field is not specified, it is assumed to be PREMIUM.
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> _builtins.str:
        """
        The DNS domain name for the public PTR record.The DNS domain name for the public PTR record.
        """
        return pulumi.get(self, "public_ptr_domain_name")


@pulumi.output_type
class GetRegionInstanceTemplateNetworkInterfaceAliasIpRangeResult(dict):
    def __init__(__self__, *,
                 ip_cidr_range: _builtins.str,
                 subnetwork_range_name: _builtins.str):
        """
        :param _builtins.str ip_cidr_range: The IP CIDR range represented by this alias IP range. This IP CIDR range
               must belong to the specified subnetwork and cannot contain IP addresses reserved by
               system or used by other network interfaces. At the time of writing only a
               netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
               error.
        :param _builtins.str subnetwork_range_name: The subnetwork secondary range name specifying
               the secondary range from which to allocate the IP CIDR range for this alias IP
               range. If left unspecified, the primary range of the subnetwork will be used.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @_builtins.property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> _builtins.str:
        """
        The IP CIDR range represented by this alias IP range. This IP CIDR range
        must belong to the specified subnetwork and cannot contain IP addresses reserved by
        system or used by other network interfaces. At the time of writing only a
        netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
        error.
        """
        return pulumi.get(self, "ip_cidr_range")

    @_builtins.property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> _builtins.str:
        """
        The subnetwork secondary range name specifying
        the secondary range from which to allocate the IP CIDR range for this alias IP
        range. If left unspecified, the primary range of the subnetwork will be used.
        """
        return pulumi.get(self, "subnetwork_range_name")


@pulumi.output_type
class GetRegionInstanceTemplateNetworkInterfaceIpv6AccessConfigResult(dict):
    def __init__(__self__, *,
                 external_ipv6: _builtins.str,
                 external_ipv6_prefix_length: _builtins.str,
                 name: _builtins.str,
                 network_tier: _builtins.str,
                 public_ptr_domain_name: _builtins.str):
        """
        :param _builtins.str external_ipv6: The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. The field is output only, an IPv6 address from a subnetwork associated with the instance will be allocated dynamically.
        :param _builtins.str external_ipv6_prefix_length: The prefix length of the external IPv6 range.
        :param _builtins.str name: The name of the instance template. One of `name` or `filter` must be provided.
        :param _builtins.str network_tier: The [networking tier][network-tier] used for configuring
               this instance template. This field can take the following values: PREMIUM or
               STANDARD. If this field is not specified, it is assumed to be PREMIUM.
        :param _builtins.str public_ptr_domain_name: The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
        """
        pulumi.set(__self__, "external_ipv6", external_ipv6)
        pulumi.set(__self__, "external_ipv6_prefix_length", external_ipv6_prefix_length)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_tier", network_tier)
        pulumi.set(__self__, "public_ptr_domain_name", public_ptr_domain_name)

    @_builtins.property
    @pulumi.getter(name="externalIpv6")
    def external_ipv6(self) -> _builtins.str:
        """
        The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. The field is output only, an IPv6 address from a subnetwork associated with the instance will be allocated dynamically.
        """
        return pulumi.get(self, "external_ipv6")

    @_builtins.property
    @pulumi.getter(name="externalIpv6PrefixLength")
    def external_ipv6_prefix_length(self) -> _builtins.str:
        """
        The prefix length of the external IPv6 range.
        """
        return pulumi.get(self, "external_ipv6_prefix_length")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance template. One of `name` or `filter` must be provided.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkTier")
    def network_tier(self) -> _builtins.str:
        """
        The [networking tier][network-tier] used for configuring
        this instance template. This field can take the following values: PREMIUM or
        STANDARD. If this field is not specified, it is assumed to be PREMIUM.
        """
        return pulumi.get(self, "network_tier")

    @_builtins.property
    @pulumi.getter(name="publicPtrDomainName")
    def public_ptr_domain_name(self) -> _builtins.str:
        """
        The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
        """
        return pulumi.get(self, "public_ptr_domain_name")


@pulumi.output_type
class GetRegionInstanceTemplateNetworkPerformanceConfigResult(dict):
    def __init__(__self__, *,
                 total_egress_bandwidth_tier: _builtins.str):
        """
        :param _builtins.str total_egress_bandwidth_tier: The egress bandwidth tier for the instance.
        """
        pulumi.set(__self__, "total_egress_bandwidth_tier", total_egress_bandwidth_tier)

    @_builtins.property
    @pulumi.getter(name="totalEgressBandwidthTier")
    def total_egress_bandwidth_tier(self) -> _builtins.str:
        """
        The egress bandwidth tier for the instance.
        """
        return pulumi.get(self, "total_egress_bandwidth_tier")


@pulumi.output_type
class GetRegionInstanceTemplateReservationAffinityResult(dict):
    def __init__(__self__, *,
                 specific_reservations: Sequence['outputs.GetRegionInstanceTemplateReservationAffinitySpecificReservationResult'],
                 type: _builtins.str):
        """
        :param Sequence['GetRegionInstanceTemplateReservationAffinitySpecificReservationArgs'] specific_reservations: Specifies the label selector for the reservation to use.
        :param _builtins.str type: The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        pulumi.set(__self__, "specific_reservations", specific_reservations)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="specificReservations")
    def specific_reservations(self) -> Sequence['outputs.GetRegionInstanceTemplateReservationAffinitySpecificReservationResult']:
        """
        Specifies the label selector for the reservation to use.
        """
        return pulumi.get(self, "specific_reservations")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRegionInstanceTemplateReservationAffinitySpecificReservationResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key for the node affinity label.
        :param Sequence[_builtins.str] values: Corresponds to the label values of a reservation resource.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key for the node affinity label.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Corresponds to the label values of a reservation resource.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRegionInstanceTemplateSchedulingResult(dict):
    def __init__(__self__, *,
                 automatic_restart: _builtins.bool,
                 availability_domain: _builtins.int,
                 graceful_shutdowns: Sequence['outputs.GetRegionInstanceTemplateSchedulingGracefulShutdownResult'],
                 host_error_timeout_seconds: _builtins.int,
                 instance_termination_action: _builtins.str,
                 local_ssd_recovery_timeouts: Sequence['outputs.GetRegionInstanceTemplateSchedulingLocalSsdRecoveryTimeoutResult'],
                 maintenance_interval: _builtins.str,
                 max_run_durations: Sequence['outputs.GetRegionInstanceTemplateSchedulingMaxRunDurationResult'],
                 min_node_cpus: _builtins.int,
                 node_affinities: Sequence['outputs.GetRegionInstanceTemplateSchedulingNodeAffinityResult'],
                 on_host_maintenance: _builtins.str,
                 on_instance_stop_actions: Sequence['outputs.GetRegionInstanceTemplateSchedulingOnInstanceStopActionResult'],
                 preemptible: _builtins.bool,
                 provisioning_model: _builtins.str,
                 skip_guest_os_shutdown: _builtins.bool,
                 termination_time: _builtins.str):
        """
        :param _builtins.bool automatic_restart: Specifies whether the instance should be
               automatically restarted if it is terminated by Compute Engine (not
               terminated by a user). This defaults to true.
        :param _builtins.int availability_domain: Specifies the availability domain, which this instance should be scheduled on.
        :param Sequence['GetRegionInstanceTemplateSchedulingGracefulShutdownArgs'] graceful_shutdowns: Settings for the instance to perform a graceful shutdown.
        :param _builtins.int host_error_timeout_seconds: Beta Time in seconds for host error detection.
        :param _builtins.str instance_termination_action: Describe the type of termination action for `SPOT` VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
        :param Sequence['GetRegionInstanceTemplateSchedulingLocalSsdRecoveryTimeoutArgs'] local_ssd_recovery_timeouts: Specifies the maximum amount of time a Local Ssd Vm should wait while
                 recovery of the Local Ssd state is attempted. Its value should be in
                 between 0 and 168 hours with hour granularity and the default value being 1
                 hour.
        :param _builtins.str maintenance_interval: Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
        :param Sequence['GetRegionInstanceTemplateSchedulingMaxRunDurationArgs'] max_run_durations: The timeout for new network connections to hosts.
        :param _builtins.int min_node_cpus: Minimum number of cpus for the instance.
        :param Sequence['GetRegionInstanceTemplateSchedulingNodeAffinityArgs'] node_affinities: Specifies node affinities or anti-affinities
               to determine which sole-tenant nodes your instances and managed instance
               groups will use as host systems. Read more on sole-tenant node creation
               [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
               Structure documented below.
        :param _builtins.str on_host_maintenance: Defines the maintenance behavior for this
               instance.
        :param Sequence['GetRegionInstanceTemplateSchedulingOnInstanceStopActionArgs'] on_instance_stop_actions: Defines the behaviour for instances with the instance_termination_action.
        :param _builtins.bool preemptible: Allows instance to be preempted. This defaults to
               false. Read more on this
               [here](https://cloud.google.com/compute/docs/instances/preemptible).
        :param _builtins.str provisioning_model: Describe the type of preemptible VM.
        :param _builtins.bool skip_guest_os_shutdown: Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        :param _builtins.str termination_time: Specifies the timestamp, when the instance will be terminated,
               in RFC3339 text format. If specified, the instance termination action
               will be performed at the termination time.
        """
        pulumi.set(__self__, "automatic_restart", automatic_restart)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "graceful_shutdowns", graceful_shutdowns)
        pulumi.set(__self__, "host_error_timeout_seconds", host_error_timeout_seconds)
        pulumi.set(__self__, "instance_termination_action", instance_termination_action)
        pulumi.set(__self__, "local_ssd_recovery_timeouts", local_ssd_recovery_timeouts)
        pulumi.set(__self__, "maintenance_interval", maintenance_interval)
        pulumi.set(__self__, "max_run_durations", max_run_durations)
        pulumi.set(__self__, "min_node_cpus", min_node_cpus)
        pulumi.set(__self__, "node_affinities", node_affinities)
        pulumi.set(__self__, "on_host_maintenance", on_host_maintenance)
        pulumi.set(__self__, "on_instance_stop_actions", on_instance_stop_actions)
        pulumi.set(__self__, "preemptible", preemptible)
        pulumi.set(__self__, "provisioning_model", provisioning_model)
        pulumi.set(__self__, "skip_guest_os_shutdown", skip_guest_os_shutdown)
        pulumi.set(__self__, "termination_time", termination_time)

    @_builtins.property
    @pulumi.getter(name="automaticRestart")
    def automatic_restart(self) -> _builtins.bool:
        """
        Specifies whether the instance should be
        automatically restarted if it is terminated by Compute Engine (not
        terminated by a user). This defaults to true.
        """
        return pulumi.get(self, "automatic_restart")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.int:
        """
        Specifies the availability domain, which this instance should be scheduled on.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="gracefulShutdowns")
    def graceful_shutdowns(self) -> Sequence['outputs.GetRegionInstanceTemplateSchedulingGracefulShutdownResult']:
        """
        Settings for the instance to perform a graceful shutdown.
        """
        return pulumi.get(self, "graceful_shutdowns")

    @_builtins.property
    @pulumi.getter(name="hostErrorTimeoutSeconds")
    def host_error_timeout_seconds(self) -> _builtins.int:
        """
        Beta Time in seconds for host error detection.
        """
        return pulumi.get(self, "host_error_timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="instanceTerminationAction")
    def instance_termination_action(self) -> _builtins.str:
        """
        Describe the type of termination action for `SPOT` VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
        """
        return pulumi.get(self, "instance_termination_action")

    @_builtins.property
    @pulumi.getter(name="localSsdRecoveryTimeouts")
    def local_ssd_recovery_timeouts(self) -> Sequence['outputs.GetRegionInstanceTemplateSchedulingLocalSsdRecoveryTimeoutResult']:
        """
        Specifies the maximum amount of time a Local Ssd Vm should wait while
          recovery of the Local Ssd state is attempted. Its value should be in
          between 0 and 168 hours with hour granularity and the default value being 1
          hour.
        """
        return pulumi.get(self, "local_ssd_recovery_timeouts")

    @_builtins.property
    @pulumi.getter(name="maintenanceInterval")
    def maintenance_interval(self) -> _builtins.str:
        """
        Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
        """
        return pulumi.get(self, "maintenance_interval")

    @_builtins.property
    @pulumi.getter(name="maxRunDurations")
    def max_run_durations(self) -> Sequence['outputs.GetRegionInstanceTemplateSchedulingMaxRunDurationResult']:
        """
        The timeout for new network connections to hosts.
        """
        return pulumi.get(self, "max_run_durations")

    @_builtins.property
    @pulumi.getter(name="minNodeCpus")
    def min_node_cpus(self) -> _builtins.int:
        """
        Minimum number of cpus for the instance.
        """
        return pulumi.get(self, "min_node_cpus")

    @_builtins.property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Sequence['outputs.GetRegionInstanceTemplateSchedulingNodeAffinityResult']:
        """
        Specifies node affinities or anti-affinities
        to determine which sole-tenant nodes your instances and managed instance
        groups will use as host systems. Read more on sole-tenant node creation
        [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
        Structure documented below.
        """
        return pulumi.get(self, "node_affinities")

    @_builtins.property
    @pulumi.getter(name="onHostMaintenance")
    def on_host_maintenance(self) -> _builtins.str:
        """
        Defines the maintenance behavior for this
        instance.
        """
        return pulumi.get(self, "on_host_maintenance")

    @_builtins.property
    @pulumi.getter(name="onInstanceStopActions")
    def on_instance_stop_actions(self) -> Sequence['outputs.GetRegionInstanceTemplateSchedulingOnInstanceStopActionResult']:
        """
        Defines the behaviour for instances with the instance_termination_action.
        """
        return pulumi.get(self, "on_instance_stop_actions")

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> _builtins.bool:
        """
        Allows instance to be preempted. This defaults to
        false. Read more on this
        [here](https://cloud.google.com/compute/docs/instances/preemptible).
        """
        return pulumi.get(self, "preemptible")

    @_builtins.property
    @pulumi.getter(name="provisioningModel")
    def provisioning_model(self) -> _builtins.str:
        """
        Describe the type of preemptible VM.
        """
        return pulumi.get(self, "provisioning_model")

    @_builtins.property
    @pulumi.getter(name="skipGuestOsShutdown")
    def skip_guest_os_shutdown(self) -> _builtins.bool:
        """
        Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
        """
        return pulumi.get(self, "skip_guest_os_shutdown")

    @_builtins.property
    @pulumi.getter(name="terminationTime")
    def termination_time(self) -> _builtins.str:
        """
        Specifies the timestamp, when the instance will be terminated,
        in RFC3339 text format. If specified, the instance termination action
        will be performed at the termination time.
        """
        return pulumi.get(self, "termination_time")


@pulumi.output_type
class GetRegionInstanceTemplateSchedulingGracefulShutdownResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 max_durations: Sequence['outputs.GetRegionInstanceTemplateSchedulingGracefulShutdownMaxDurationResult']):
        """
        :param _builtins.bool enabled: Opts-in for graceful shutdown.
        :param Sequence['GetRegionInstanceTemplateSchedulingGracefulShutdownMaxDurationArgs'] max_durations: The time allotted for the instance to gracefully shut down.
               										If the graceful shutdown isn't complete after this time, then the instance
               										transitions to the STOPPING state.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "max_durations", max_durations)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Opts-in for graceful shutdown.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxDurations")
    def max_durations(self) -> Sequence['outputs.GetRegionInstanceTemplateSchedulingGracefulShutdownMaxDurationResult']:
        """
        The time allotted for the instance to gracefully shut down.
        										If the graceful shutdown isn't complete after this time, then the instance
        										transitions to the STOPPING state.
        """
        return pulumi.get(self, "max_durations")


@pulumi.output_type
class GetRegionInstanceTemplateSchedulingGracefulShutdownMaxDurationResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               													resolution. Durations less than one second are represented
               													with a 0 seconds field and a positive nanos field. Must
               													be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               													The value must be between 1 and 3600, which is 3,600 seconds (one hour).
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        													resolution. Durations less than one second are represented
        													with a 0 seconds field and a positive nanos field. Must
        													be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        													The value must be between 1 and 3600, which is 3,600 seconds (one hour).
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetRegionInstanceTemplateSchedulingLocalSsdRecoveryTimeoutResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetRegionInstanceTemplateSchedulingMaxRunDurationResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.int):
        """
        :param _builtins.int nanos: Span of time that's a fraction of a second at nanosecond
               resolution. Durations less than one second are represented
               with a 0 seconds field and a positive nanos field. Must
               be from 0 to 999,999,999 inclusive.
        :param _builtins.int seconds: Span of time at a resolution of a second.
               Must be from 0 to 315,576,000,000 inclusive.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Span of time that's a fraction of a second at nanosecond
        resolution. Durations less than one second are represented
        with a 0 seconds field and a positive nanos field. Must
        be from 0 to 999,999,999 inclusive.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        """
        Span of time at a resolution of a second.
        Must be from 0 to 315,576,000,000 inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetRegionInstanceTemplateSchedulingNodeAffinityResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key for the node affinity label.
        :param _builtins.str operator: The operator. Can be `IN` for node-affinities
               or `NOT_IN` for anti-affinities.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key for the node affinity label.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator. Can be `IN` for node-affinities
        or `NOT_IN` for anti-affinities.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRegionInstanceTemplateSchedulingOnInstanceStopActionResult(dict):
    def __init__(__self__, *,
                 discard_local_ssd: _builtins.bool):
        """
        :param _builtins.bool discard_local_ssd: If true, the contents of any attached Local SSD disks will be discarded.
        """
        pulumi.set(__self__, "discard_local_ssd", discard_local_ssd)

    @_builtins.property
    @pulumi.getter(name="discardLocalSsd")
    def discard_local_ssd(self) -> _builtins.bool:
        """
        If true, the contents of any attached Local SSD disks will be discarded.
        """
        return pulumi.get(self, "discard_local_ssd")


@pulumi.output_type
class GetRegionInstanceTemplateServiceAccountResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 scopes: Sequence[_builtins.str]):
        """
        :param _builtins.str email: The service account e-mail address. If not given, the
               default Google Compute Engine service account is used.
        :param Sequence[_builtins.str] scopes: A list of service scopes. Both OAuth2 URLs and gcloud
               short names are supported. To allow full access to all Cloud APIs, use the
               `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The service account e-mail address. If not given, the
        default Google Compute Engine service account is used.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        """
        A list of service scopes. Both OAuth2 URLs and gcloud
        short names are supported. To allow full access to all Cloud APIs, use the
        `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class GetRegionInstanceTemplateShieldedInstanceConfigResult(dict):
    def __init__(__self__, *,
                 enable_integrity_monitoring: _builtins.bool,
                 enable_secure_boot: _builtins.bool,
                 enable_vtpm: _builtins.bool):
        """
        :param _builtins.bool enable_integrity_monitoring: - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        :param _builtins.bool enable_secure_boot: - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        :param _builtins.bool enable_vtpm: - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        """
        pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @_builtins.property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> _builtins.bool:
        """
        - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @_builtins.property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> _builtins.bool:
        """
        - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
        """
        return pulumi.get(self, "enable_secure_boot")

    @_builtins.property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> _builtins.bool:
        """
        - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
        """
        return pulumi.get(self, "enable_vtpm")


@pulumi.output_type
class GetRegionNetworkEndpointGroupAppEngineResult(dict):
    def __init__(__self__, *,
                 service: _builtins.str,
                 url_mask: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str service: Optional serving service.
               The service name must be 1-63 characters long, and comply with RFC1035.
               Example value: "default", "my-service".
        :param _builtins.str url_mask: A template to parse service and version fields from a request URL.
               URL mask allows for routing to multiple App Engine services without
               having to create multiple Network Endpoint Groups and backend services.
               
               For example, the request URLs "foo1-dot-appname.appspot.com/v1" and
               "foo1-dot-appname.appspot.com/v2" can be backed by the same Serverless NEG with
               URL mask "-dot-appname.appspot.com/". The URL mask will parse
               them to { service = "foo1", version = "v1" } and { service = "foo1", version = "v2" } respectively.
        :param _builtins.str version: Optional serving version.
               The version must be 1-63 characters long, and comply with RFC1035.
               Example value: "v1", "v2".
        """
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "url_mask", url_mask)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        Optional serving service.
        The service name must be 1-63 characters long, and comply with RFC1035.
        Example value: "default", "my-service".
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="urlMask")
    def url_mask(self) -> _builtins.str:
        """
        A template to parse service and version fields from a request URL.
        URL mask allows for routing to multiple App Engine services without
        having to create multiple Network Endpoint Groups and backend services.

        For example, the request URLs "foo1-dot-appname.appspot.com/v1" and
        "foo1-dot-appname.appspot.com/v2" can be backed by the same Serverless NEG with
        URL mask "-dot-appname.appspot.com/". The URL mask will parse
        them to { service = "foo1", version = "v1" } and { service = "foo1", version = "v2" } respectively.
        """
        return pulumi.get(self, "url_mask")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Optional serving version.
        The version must be 1-63 characters long, and comply with RFC1035.
        Example value: "v1", "v2".
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetRegionNetworkEndpointGroupCloudFunctionResult(dict):
    def __init__(__self__, *,
                 function: _builtins.str,
                 url_mask: _builtins.str):
        """
        :param _builtins.str function: A user-defined name of the Cloud Function.
               The function name is case-sensitive and must be 1-63 characters long.
               Example value: "func1".
        :param _builtins.str url_mask: A template to parse function field from a request URL. URL mask allows
               for routing to multiple Cloud Functions without having to create
               multiple Network Endpoint Groups and backend services.
               
               For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
               can be backed by the same Serverless NEG with URL mask "/". The URL mask
               will parse them to { function = "function1" } and { function = "function2" } respectively.
        """
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "url_mask", url_mask)

    @_builtins.property
    @pulumi.getter
    def function(self) -> _builtins.str:
        """
        A user-defined name of the Cloud Function.
        The function name is case-sensitive and must be 1-63 characters long.
        Example value: "func1".
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter(name="urlMask")
    def url_mask(self) -> _builtins.str:
        """
        A template to parse function field from a request URL. URL mask allows
        for routing to multiple Cloud Functions without having to create
        multiple Network Endpoint Groups and backend services.

        For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
        can be backed by the same Serverless NEG with URL mask "/". The URL mask
        will parse them to { function = "function1" } and { function = "function2" } respectively.
        """
        return pulumi.get(self, "url_mask")


@pulumi.output_type
class GetRegionNetworkEndpointGroupCloudRunResult(dict):
    def __init__(__self__, *,
                 service: _builtins.str,
                 tag: _builtins.str,
                 url_mask: _builtins.str):
        """
        :param _builtins.str service: Cloud Run service is the main resource of Cloud Run.
               The service must be 1-63 characters long, and comply with RFC1035.
               Example value: "run-service".
        :param _builtins.str tag: Cloud Run tag represents the "named-revision" to provide
               additional fine-grained traffic routing information.
               The tag must be 1-63 characters long, and comply with RFC1035.
               Example value: "revision-0010".
        :param _builtins.str url_mask: A template to parse service and tag fields from a request URL.
               URL mask allows for routing to multiple Run services without having
               to create multiple network endpoint groups and backend services.
               
               For example, request URLs "foo1.domain.com/bar1" and "foo1.domain.com/bar2"
               an be backed by the same Serverless Network Endpoint Group (NEG) with
               URL mask ".domain.com/". The URL mask will parse them to { service="bar1", tag="foo1" }
               and { service="bar2", tag="foo2" } respectively.
        """
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "url_mask", url_mask)

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        Cloud Run service is the main resource of Cloud Run.
        The service must be 1-63 characters long, and comply with RFC1035.
        Example value: "run-service".
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> _builtins.str:
        """
        Cloud Run tag represents the "named-revision" to provide
        additional fine-grained traffic routing information.
        The tag must be 1-63 characters long, and comply with RFC1035.
        Example value: "revision-0010".
        """
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter(name="urlMask")
    def url_mask(self) -> _builtins.str:
        """
        A template to parse service and tag fields from a request URL.
        URL mask allows for routing to multiple Run services without having
        to create multiple network endpoint groups and backend services.

        For example, request URLs "foo1.domain.com/bar1" and "foo1.domain.com/bar2"
        an be backed by the same Serverless Network Endpoint Group (NEG) with
        URL mask ".domain.com/". The URL mask will parse them to { service="bar1", tag="foo1" }
        and { service="bar2", tag="foo2" } respectively.
        """
        return pulumi.get(self, "url_mask")


@pulumi.output_type
class GetRegionNetworkEndpointGroupPscDataResult(dict):
    def __init__(__self__, *,
                 producer_port: _builtins.str):
        """
        :param _builtins.str producer_port: The PSC producer port to use when consumer PSC NEG connects to a producer. If
               this flag isn't specified for a PSC NEG with endpoint type
               private-service-connect, then PSC NEG will be connected to a first port in the
               available PSC producer port range.
        """
        pulumi.set(__self__, "producer_port", producer_port)

    @_builtins.property
    @pulumi.getter(name="producerPort")
    def producer_port(self) -> _builtins.str:
        """
        The PSC producer port to use when consumer PSC NEG connects to a producer. If
        this flag isn't specified for a PSC NEG with endpoint type
        private-service-connect, then PSC NEG will be connected to a first port in the
        available PSC producer port range.
        """
        return pulumi.get(self, "producer_port")


@pulumi.output_type
class GetRegionNetworkEndpointGroupServerlessDeploymentResult(dict):
    def __init__(__self__, *,
                 platform: _builtins.str,
                 resource: _builtins.str,
                 url_mask: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str platform: The platform of the NEG backend target(s). Possible values:
               API Gateway: apigateway.googleapis.com
        :param _builtins.str resource: The user-defined name of the workload/instance. This value must be provided explicitly or in the urlMask.
               The resource identified by this value is platform-specific and is as follows: API Gateway: The gateway ID, App Engine: The service name,
               Cloud Functions: The function name, Cloud Run: The service name
        :param _builtins.str url_mask: A template to parse platform-specific fields from a request URL. URL mask allows for routing to multiple resources
               on the same serverless platform without having to create multiple Network Endpoint Groups and backend resources.
               The fields parsed by this template are platform-specific and are as follows: API Gateway: The gateway ID,
               App Engine: The service and version, Cloud Functions: The function name, Cloud Run: The service and tag
        :param _builtins.str version: The optional resource version. The version identified by this value is platform-specific and is follows:
               API Gateway: Unused, App Engine: The service version, Cloud Functions: Unused, Cloud Run: The service tag
        """
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "url_mask", url_mask)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> _builtins.str:
        """
        The platform of the NEG backend target(s). Possible values:
        API Gateway: apigateway.googleapis.com
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter
    def resource(self) -> _builtins.str:
        """
        The user-defined name of the workload/instance. This value must be provided explicitly or in the urlMask.
        The resource identified by this value is platform-specific and is as follows: API Gateway: The gateway ID, App Engine: The service name,
        Cloud Functions: The function name, Cloud Run: The service name
        """
        return pulumi.get(self, "resource")

    @_builtins.property
    @pulumi.getter(name="urlMask")
    def url_mask(self) -> _builtins.str:
        """
        A template to parse platform-specific fields from a request URL. URL mask allows for routing to multiple resources
        on the same serverless platform without having to create multiple Network Endpoint Groups and backend resources.
        The fields parsed by this template are platform-specific and are as follows: API Gateway: The gateway ID,
        App Engine: The service and version, Cloud Functions: The function name, Cloud Run: The service and tag
        """
        return pulumi.get(self, "url_mask")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The optional resource version. The version identified by this value is platform-specific and is follows:
        API Gateway: Unused, App Engine: The service version, Cloud Functions: Unused, Cloud Run: The service tag
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetRegionSecurityPolicyAdvancedOptionsConfigResult(dict):
    def __init__(__self__, *,
                 json_custom_configs: Sequence['outputs.GetRegionSecurityPolicyAdvancedOptionsConfigJsonCustomConfigResult'],
                 json_parsing: _builtins.str,
                 log_level: _builtins.str,
                 request_body_inspection_size: _builtins.str,
                 user_ip_request_headers: Sequence[_builtins.str]):
        """
        :param Sequence['GetRegionSecurityPolicyAdvancedOptionsConfigJsonCustomConfigArgs'] json_custom_configs: Custom configuration to apply the JSON parsing. Only applicable when JSON parsing is set to STANDARD.
        :param _builtins.str json_parsing: JSON body parsing. Supported values include: "DISABLED", "STANDARD", "STANDARD_WITH_GRAPHQL". Possible values: ["DISABLED", "STANDARD", "STANDARD_WITH_GRAPHQL"]
        :param _builtins.str log_level: Logging level. Supported values include: "NORMAL", "VERBOSE". Possible values: ["NORMAL", "VERBOSE"]
        :param _builtins.str request_body_inspection_size: The maximum request size chosen by the customer with Waf enabled. Values supported are "8KB", "16KB, "32KB", "48KB" and "64KB".
               Values are case insensitive. Possible values: ["8KB", "16KB", "32KB", "48KB", "64KB"]
        :param Sequence[_builtins.str] user_ip_request_headers: An optional list of case-insensitive request header names to use for resolving the callers client IP address.
        """
        pulumi.set(__self__, "json_custom_configs", json_custom_configs)
        pulumi.set(__self__, "json_parsing", json_parsing)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "request_body_inspection_size", request_body_inspection_size)
        pulumi.set(__self__, "user_ip_request_headers", user_ip_request_headers)

    @_builtins.property
    @pulumi.getter(name="jsonCustomConfigs")
    def json_custom_configs(self) -> Sequence['outputs.GetRegionSecurityPolicyAdvancedOptionsConfigJsonCustomConfigResult']:
        """
        Custom configuration to apply the JSON parsing. Only applicable when JSON parsing is set to STANDARD.
        """
        return pulumi.get(self, "json_custom_configs")

    @_builtins.property
    @pulumi.getter(name="jsonParsing")
    def json_parsing(self) -> _builtins.str:
        """
        JSON body parsing. Supported values include: "DISABLED", "STANDARD", "STANDARD_WITH_GRAPHQL". Possible values: ["DISABLED", "STANDARD", "STANDARD_WITH_GRAPHQL"]
        """
        return pulumi.get(self, "json_parsing")

    @_builtins.property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> _builtins.str:
        """
        Logging level. Supported values include: "NORMAL", "VERBOSE". Possible values: ["NORMAL", "VERBOSE"]
        """
        return pulumi.get(self, "log_level")

    @_builtins.property
    @pulumi.getter(name="requestBodyInspectionSize")
    def request_body_inspection_size(self) -> _builtins.str:
        """
        The maximum request size chosen by the customer with Waf enabled. Values supported are "8KB", "16KB, "32KB", "48KB" and "64KB".
        Values are case insensitive. Possible values: ["8KB", "16KB", "32KB", "48KB", "64KB"]
        """
        return pulumi.get(self, "request_body_inspection_size")

    @_builtins.property
    @pulumi.getter(name="userIpRequestHeaders")
    def user_ip_request_headers(self) -> Sequence[_builtins.str]:
        """
        An optional list of case-insensitive request header names to use for resolving the callers client IP address.
        """
        return pulumi.get(self, "user_ip_request_headers")


@pulumi.output_type
class GetRegionSecurityPolicyAdvancedOptionsConfigJsonCustomConfigResult(dict):
    def __init__(__self__, *,
                 content_types: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] content_types: A list of custom Content-Type header values to apply the JSON parsing.
        """
        pulumi.set(__self__, "content_types", content_types)

    @_builtins.property
    @pulumi.getter(name="contentTypes")
    def content_types(self) -> Sequence[_builtins.str]:
        """
        A list of custom Content-Type header values to apply the JSON parsing.
        """
        return pulumi.get(self, "content_types")


@pulumi.output_type
class GetRegionSecurityPolicyDdosProtectionConfigResult(dict):
    def __init__(__self__, *,
                 ddos_protection: _builtins.str):
        """
        :param _builtins.str ddos_protection: Google Cloud Armor offers the following options to help protect systems against DDoS attacks:
               - STANDARD: basic always-on protection for network load balancers, protocol forwarding, or VMs with public IP addresses.
               - ADVANCED: additional protections for Managed Protection Plus subscribers who use network load balancers, protocol forwarding, or VMs with public IP addresses.
               - ADVANCED_PREVIEW: flag to enable the security policy in preview mode. Possible values: ["ADVANCED", "ADVANCED_PREVIEW", "STANDARD"]
        """
        pulumi.set(__self__, "ddos_protection", ddos_protection)

    @_builtins.property
    @pulumi.getter(name="ddosProtection")
    def ddos_protection(self) -> _builtins.str:
        """
        Google Cloud Armor offers the following options to help protect systems against DDoS attacks:
        - STANDARD: basic always-on protection for network load balancers, protocol forwarding, or VMs with public IP addresses.
        - ADVANCED: additional protections for Managed Protection Plus subscribers who use network load balancers, protocol forwarding, or VMs with public IP addresses.
        - ADVANCED_PREVIEW: flag to enable the security policy in preview mode. Possible values: ["ADVANCED", "ADVANCED_PREVIEW", "STANDARD"]
        """
        return pulumi.get(self, "ddos_protection")


@pulumi.output_type
class GetRegionSecurityPolicyRuleResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 description: _builtins.str,
                 matches: Sequence['outputs.GetRegionSecurityPolicyRuleMatchResult'],
                 network_matches: Sequence['outputs.GetRegionSecurityPolicyRuleNetworkMatchResult'],
                 preconfigured_waf_configs: Sequence['outputs.GetRegionSecurityPolicyRulePreconfiguredWafConfigResult'],
                 preview: _builtins.bool,
                 priority: _builtins.int,
                 rate_limit_options: Sequence['outputs.GetRegionSecurityPolicyRuleRateLimitOptionResult']):
        """
        :param _builtins.str action: The Action to perform when the rule is matched. The following are the valid actions:
               
               * allow: allow access to target.
               
               * deny(STATUS): deny access to target, returns the HTTP response code specified. Valid values for STATUS are 403, 404, and 502.
               
               * rate_based_ban: limit client traffic to the configured threshold and ban the client if the traffic exceeds the threshold. Configure parameters for this action in RateLimitOptions. Requires rateLimitOptions to be set.
               
               * redirect: redirect to a different target. This can either be an internal reCAPTCHA redirect, or an external URL-based redirect via a 302 response. Parameters for this action can be configured via redirectOptions. This action is only supported in Global Security Policies of type CLOUD_ARMOR.
               
               * throttle: limit client traffic to the configured threshold. Configure parameters for this action in rateLimitOptions. Requires rateLimitOptions to be set for this.
        :param _builtins.str description: An optional description of this resource. Provide this property when you create the resource.
        :param Sequence['GetRegionSecurityPolicyRuleMatchArgs'] matches: A match condition that incoming traffic is evaluated against.
               If it evaluates to true, the corresponding 'action' is enforced.
        :param Sequence['GetRegionSecurityPolicyRuleNetworkMatchArgs'] network_matches: A match condition that incoming packets are evaluated against for CLOUD_ARMOR_NETWORK security policies. If it matches, the corresponding 'action' is enforced.
               The match criteria for a rule consists of built-in match fields (like 'srcIpRanges') and potentially multiple user-defined match fields ('userDefinedFields').
               Field values may be extracted directly from the packet or derived from it (e.g. 'srcRegionCodes'). Some fields may not be present in every packet (e.g. 'srcPorts'). A user-defined field is only present if the base header is found in the packet and the entire field is in bounds.
               Each match field may specify which values can match it, listing one or more ranges, prefixes, or exact values that are considered a match for the field. A field value must be present in order to match a specified match field. If no match values are specified for a match field, then any field value is considered to match it, and it's not required to be present. For strings specifying '*' is also equivalent to match all.
               For a packet to match a rule, all specified match fields must match the corresponding field values derived from the packet.
               Example:
               networkMatch: srcIpRanges: - "192.0.2.0/24" - "198.51.100.0/24" userDefinedFields: - name: "ipv4_fragment_offset" values: - "1-0x1fff"
               The above match condition matches packets with a source IP in 192.0.2.0/24 or 198.51.100.0/24 and a user-defined field named "ipv4_fragment_offset" with a value between 1 and 0x1fff inclusive
        :param Sequence['GetRegionSecurityPolicyRulePreconfiguredWafConfigArgs'] preconfigured_waf_configs: Preconfigured WAF configuration to be applied for the rule.
               If the rule does not evaluate preconfigured WAF rules, i.e., if evaluatePreconfiguredWaf() is not used, this field will have no effect.
        :param _builtins.bool preview: If set to true, the specified action is not enforced.
        :param _builtins.int priority: An integer indicating the priority of a rule in the list.
               The priority must be a positive value between 0 and 2147483647.
               Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest priority.
        :param Sequence['GetRegionSecurityPolicyRuleRateLimitOptionArgs'] rate_limit_options: Must be specified if the action is "rate_based_ban" or "throttle". Cannot be specified for any other actions.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "matches", matches)
        pulumi.set(__self__, "network_matches", network_matches)
        pulumi.set(__self__, "preconfigured_waf_configs", preconfigured_waf_configs)
        pulumi.set(__self__, "preview", preview)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rate_limit_options", rate_limit_options)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The Action to perform when the rule is matched. The following are the valid actions:

        * allow: allow access to target.

        * deny(STATUS): deny access to target, returns the HTTP response code specified. Valid values for STATUS are 403, 404, and 502.

        * rate_based_ban: limit client traffic to the configured threshold and ban the client if the traffic exceeds the threshold. Configure parameters for this action in RateLimitOptions. Requires rateLimitOptions to be set.

        * redirect: redirect to a different target. This can either be an internal reCAPTCHA redirect, or an external URL-based redirect via a 302 response. Parameters for this action can be configured via redirectOptions. This action is only supported in Global Security Policies of type CLOUD_ARMOR.

        * throttle: limit client traffic to the configured threshold. Configure parameters for this action in rateLimitOptions. Requires rateLimitOptions to be set for this.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        An optional description of this resource. Provide this property when you create the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetRegionSecurityPolicyRuleMatchResult']:
        """
        A match condition that incoming traffic is evaluated against.
        If it evaluates to true, the corresponding 'action' is enforced.
        """
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter(name="networkMatches")
    def network_matches(self) -> Sequence['outputs.GetRegionSecurityPolicyRuleNetworkMatchResult']:
        """
        A match condition that incoming packets are evaluated against for CLOUD_ARMOR_NETWORK security policies. If it matches, the corresponding 'action' is enforced.
        The match criteria for a rule consists of built-in match fields (like 'srcIpRanges') and potentially multiple user-defined match fields ('userDefinedFields').
        Field values may be extracted directly from the packet or derived from it (e.g. 'srcRegionCodes'). Some fields may not be present in every packet (e.g. 'srcPorts'). A user-defined field is only present if the base header is found in the packet and the entire field is in bounds.
        Each match field may specify which values can match it, listing one or more ranges, prefixes, or exact values that are considered a match for the field. A field value must be present in order to match a specified match field. If no match values are specified for a match field, then any field value is considered to match it, and it's not required to be present. For strings specifying '*' is also equivalent to match all.
        For a packet to match a rule, all specified match fields must match the corresponding field values derived from the packet.
        Example:
        networkMatch: srcIpRanges: - "192.0.2.0/24" - "198.51.100.0/24" userDefinedFields: - name: "ipv4_fragment_offset" values: - "1-0x1fff"
        The above match condition matches packets with a source IP in 192.0.2.0/24 or 198.51.100.0/24 and a user-defined field named "ipv4_fragment_offset" with a value between 1 and 0x1fff inclusive
        """
        return pulumi.get(self, "network_matches")

    @_builtins.property
    @pulumi.getter(name="preconfiguredWafConfigs")
    def preconfigured_waf_configs(self) -> Sequence['outputs.GetRegionSecurityPolicyRulePreconfiguredWafConfigResult']:
        """
        Preconfigured WAF configuration to be applied for the rule.
        If the rule does not evaluate preconfigured WAF rules, i.e., if evaluatePreconfiguredWaf() is not used, this field will have no effect.
        """
        return pulumi.get(self, "preconfigured_waf_configs")

    @_builtins.property
    @pulumi.getter
    def preview(self) -> _builtins.bool:
        """
        If set to true, the specified action is not enforced.
        """
        return pulumi.get(self, "preview")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        An integer indicating the priority of a rule in the list.
        The priority must be a positive value between 0 and 2147483647.
        Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="rateLimitOptions")
    def rate_limit_options(self) -> Sequence['outputs.GetRegionSecurityPolicyRuleRateLimitOptionResult']:
        """
        Must be specified if the action is "rate_based_ban" or "throttle". Cannot be specified for any other actions.
        """
        return pulumi.get(self, "rate_limit_options")


@pulumi.output_type
class GetRegionSecurityPolicyRuleMatchResult(dict):
    def __init__(__self__, *,
                 configs: Sequence['outputs.GetRegionSecurityPolicyRuleMatchConfigResult'],
                 exprs: Sequence['outputs.GetRegionSecurityPolicyRuleMatchExprResult'],
                 versioned_expr: _builtins.str):
        """
        :param Sequence['GetRegionSecurityPolicyRuleMatchConfigArgs'] configs: The configuration options available when specifying versionedExpr.
               This field must be specified if versionedExpr is specified and cannot be specified if versionedExpr is not specified.
        :param Sequence['GetRegionSecurityPolicyRuleMatchExprArgs'] exprs: User defined CEVAL expression. A CEVAL expression is used to specify match criteria such as origin.ip, source.region_code and contents in the request header. See [Sample expressions](https://cloud.google.com/armor/docs/configure-security-policies#sample-expressions) for examples.
        :param _builtins.str versioned_expr: Preconfigured versioned expression. If this field is specified, config must also be specified.
               Available preconfigured expressions along with their requirements are: SRC_IPS_V1 - must specify the corresponding srcIpRange field in config. Possible values: ["SRC_IPS_V1"]
        """
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "exprs", exprs)
        pulumi.set(__self__, "versioned_expr", versioned_expr)

    @_builtins.property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.GetRegionSecurityPolicyRuleMatchConfigResult']:
        """
        The configuration options available when specifying versionedExpr.
        This field must be specified if versionedExpr is specified and cannot be specified if versionedExpr is not specified.
        """
        return pulumi.get(self, "configs")

    @_builtins.property
    @pulumi.getter
    def exprs(self) -> Sequence['outputs.GetRegionSecurityPolicyRuleMatchExprResult']:
        """
        User defined CEVAL expression. A CEVAL expression is used to specify match criteria such as origin.ip, source.region_code and contents in the request header. See [Sample expressions](https://cloud.google.com/armor/docs/configure-security-policies#sample-expressions) for examples.
        """
        return pulumi.get(self, "exprs")

    @_builtins.property
    @pulumi.getter(name="versionedExpr")
    def versioned_expr(self) -> _builtins.str:
        """
        Preconfigured versioned expression. If this field is specified, config must also be specified.
        Available preconfigured expressions along with their requirements are: SRC_IPS_V1 - must specify the corresponding srcIpRange field in config. Possible values: ["SRC_IPS_V1"]
        """
        return pulumi.get(self, "versioned_expr")


@pulumi.output_type
class GetRegionSecurityPolicyRuleMatchConfigResult(dict):
    def __init__(__self__, *,
                 src_ip_ranges: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] src_ip_ranges: CIDR IP address range. Maximum number of srcIpRanges allowed is 10.
        """
        pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Sequence[_builtins.str]:
        """
        CIDR IP address range. Maximum number of srcIpRanges allowed is 10.
        """
        return pulumi.get(self, "src_ip_ranges")


@pulumi.output_type
class GetRegionSecurityPolicyRuleMatchExprResult(dict):
    def __init__(__self__, *,
                 expression: _builtins.str):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax. The application context of the containing message determines which well-known feature set of CEL is supported.
        """
        pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax. The application context of the containing message determines which well-known feature set of CEL is supported.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class GetRegionSecurityPolicyRuleNetworkMatchResult(dict):
    def __init__(__self__, *,
                 dest_ip_ranges: Sequence[_builtins.str],
                 dest_ports: Sequence[_builtins.str],
                 ip_protocols: Sequence[_builtins.str],
                 src_asns: Sequence[_builtins.int],
                 src_ip_ranges: Sequence[_builtins.str],
                 src_ports: Sequence[_builtins.str],
                 src_region_codes: Sequence[_builtins.str],
                 user_defined_fields: Sequence['outputs.GetRegionSecurityPolicyRuleNetworkMatchUserDefinedFieldResult']):
        """
        :param Sequence[_builtins.str] dest_ip_ranges: Destination IPv4/IPv6 addresses or CIDR prefixes, in standard text format.
        :param Sequence[_builtins.str] dest_ports: Destination port numbers for TCP/UDP/SCTP. Each element can be a 16-bit unsigned decimal number (e.g. "80") or range (e.g. "0-1023").
        :param Sequence[_builtins.str] ip_protocols: IPv4 protocol / IPv6 next header (after extension headers). Each element can be an 8-bit unsigned decimal number (e.g. "6"), range (e.g. "253-254"), or one of the following protocol names: "tcp", "udp", "icmp", "esp", "ah", "ipip", or "sctp".
        :param Sequence[_builtins.int] src_asns: BGP Autonomous System Number associated with the source IP address.
        :param Sequence[_builtins.str] src_ip_ranges: Source IPv4/IPv6 addresses or CIDR prefixes, in standard text format.
        :param Sequence[_builtins.str] src_ports: Source port numbers for TCP/UDP/SCTP. Each element can be a 16-bit unsigned decimal number (e.g. "80") or range (e.g. "0-1023").
        :param Sequence[_builtins.str] src_region_codes: Two-letter ISO 3166-1 alpha-2 country code associated with the source IP address.
        :param Sequence['GetRegionSecurityPolicyRuleNetworkMatchUserDefinedFieldArgs'] user_defined_fields: User-defined fields. Each element names a defined field and lists the matching values for that field.
        """
        pulumi.set(__self__, "dest_ip_ranges", dest_ip_ranges)
        pulumi.set(__self__, "dest_ports", dest_ports)
        pulumi.set(__self__, "ip_protocols", ip_protocols)
        pulumi.set(__self__, "src_asns", src_asns)
        pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)
        pulumi.set(__self__, "src_ports", src_ports)
        pulumi.set(__self__, "src_region_codes", src_region_codes)
        pulumi.set(__self__, "user_defined_fields", user_defined_fields)

    @_builtins.property
    @pulumi.getter(name="destIpRanges")
    def dest_ip_ranges(self) -> Sequence[_builtins.str]:
        """
        Destination IPv4/IPv6 addresses or CIDR prefixes, in standard text format.
        """
        return pulumi.get(self, "dest_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="destPorts")
    def dest_ports(self) -> Sequence[_builtins.str]:
        """
        Destination port numbers for TCP/UDP/SCTP. Each element can be a 16-bit unsigned decimal number (e.g. "80") or range (e.g. "0-1023").
        """
        return pulumi.get(self, "dest_ports")

    @_builtins.property
    @pulumi.getter(name="ipProtocols")
    def ip_protocols(self) -> Sequence[_builtins.str]:
        """
        IPv4 protocol / IPv6 next header (after extension headers). Each element can be an 8-bit unsigned decimal number (e.g. "6"), range (e.g. "253-254"), or one of the following protocol names: "tcp", "udp", "icmp", "esp", "ah", "ipip", or "sctp".
        """
        return pulumi.get(self, "ip_protocols")

    @_builtins.property
    @pulumi.getter(name="srcAsns")
    def src_asns(self) -> Sequence[_builtins.int]:
        """
        BGP Autonomous System Number associated with the source IP address.
        """
        return pulumi.get(self, "src_asns")

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Sequence[_builtins.str]:
        """
        Source IPv4/IPv6 addresses or CIDR prefixes, in standard text format.
        """
        return pulumi.get(self, "src_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="srcPorts")
    def src_ports(self) -> Sequence[_builtins.str]:
        """
        Source port numbers for TCP/UDP/SCTP. Each element can be a 16-bit unsigned decimal number (e.g. "80") or range (e.g. "0-1023").
        """
        return pulumi.get(self, "src_ports")

    @_builtins.property
    @pulumi.getter(name="srcRegionCodes")
    def src_region_codes(self) -> Sequence[_builtins.str]:
        """
        Two-letter ISO 3166-1 alpha-2 country code associated with the source IP address.
        """
        return pulumi.get(self, "src_region_codes")

    @_builtins.property
    @pulumi.getter(name="userDefinedFields")
    def user_defined_fields(self) -> Sequence['outputs.GetRegionSecurityPolicyRuleNetworkMatchUserDefinedFieldResult']:
        """
        User-defined fields. Each element names a defined field and lists the matching values for that field.
        """
        return pulumi.get(self, "user_defined_fields")


@pulumi.output_type
class GetRegionSecurityPolicyRuleNetworkMatchUserDefinedFieldResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The name of the Region Security Policy.
        :param Sequence[_builtins.str] values: Matching values of the field. Each element can be a 32-bit unsigned decimal or hexadecimal (starting with "0x") number (e.g. "64") or range (e.g. "0x400-0x7ff").
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Region Security Policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Matching values of the field. Each element can be a 32-bit unsigned decimal or hexadecimal (starting with "0x") number (e.g. "64") or range (e.g. "0x400-0x7ff").
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRegionSecurityPolicyRulePreconfiguredWafConfigResult(dict):
    def __init__(__self__, *,
                 exclusions: Sequence['outputs.GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionResult']):
        """
        :param Sequence['GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionArgs'] exclusions: An exclusion to apply during preconfigured WAF evaluation.
        """
        pulumi.set(__self__, "exclusions", exclusions)

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Sequence['outputs.GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionResult']:
        """
        An exclusion to apply during preconfigured WAF evaluation.
        """
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionResult(dict):
    def __init__(__self__, *,
                 request_cookies: Sequence['outputs.GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCookyResult'],
                 request_headers: Sequence['outputs.GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeaderResult'],
                 request_query_params: Sequence['outputs.GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParamResult'],
                 request_uris: Sequence['outputs.GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUriResult'],
                 target_rule_ids: Sequence[_builtins.str],
                 target_rule_set: _builtins.str):
        """
        :param Sequence['GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCookyArgs'] request_cookies: Request cookie whose value will be excluded from inspection during preconfigured WAF evaluation.
        :param Sequence['GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeaderArgs'] request_headers: Request header whose value will be excluded from inspection during preconfigured WAF evaluation.
        :param Sequence['GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParamArgs'] request_query_params: Request query parameter whose value will be excluded from inspection during preconfigured WAF evaluation.
               Note that the parameter can be in the query string or in the POST body.
        :param Sequence['GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUriArgs'] request_uris: Request URI from the request line to be excluded from inspection during preconfigured WAF evaluation.
               When specifying this field, the query or fragment part should be excluded.
        :param Sequence[_builtins.str] target_rule_ids: A list of target rule IDs under the WAF rule set to apply the preconfigured WAF exclusion.
               If omitted, it refers to all the rule IDs under the WAF rule set.
        :param _builtins.str target_rule_set: Target WAF rule set to apply the preconfigured WAF exclusion.
        """
        pulumi.set(__self__, "request_cookies", request_cookies)
        pulumi.set(__self__, "request_headers", request_headers)
        pulumi.set(__self__, "request_query_params", request_query_params)
        pulumi.set(__self__, "request_uris", request_uris)
        pulumi.set(__self__, "target_rule_ids", target_rule_ids)
        pulumi.set(__self__, "target_rule_set", target_rule_set)

    @_builtins.property
    @pulumi.getter(name="requestCookies")
    def request_cookies(self) -> Sequence['outputs.GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCookyResult']:
        """
        Request cookie whose value will be excluded from inspection during preconfigured WAF evaluation.
        """
        return pulumi.get(self, "request_cookies")

    @_builtins.property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Sequence['outputs.GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeaderResult']:
        """
        Request header whose value will be excluded from inspection during preconfigured WAF evaluation.
        """
        return pulumi.get(self, "request_headers")

    @_builtins.property
    @pulumi.getter(name="requestQueryParams")
    def request_query_params(self) -> Sequence['outputs.GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParamResult']:
        """
        Request query parameter whose value will be excluded from inspection during preconfigured WAF evaluation.
        Note that the parameter can be in the query string or in the POST body.
        """
        return pulumi.get(self, "request_query_params")

    @_builtins.property
    @pulumi.getter(name="requestUris")
    def request_uris(self) -> Sequence['outputs.GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUriResult']:
        """
        Request URI from the request line to be excluded from inspection during preconfigured WAF evaluation.
        When specifying this field, the query or fragment part should be excluded.
        """
        return pulumi.get(self, "request_uris")

    @_builtins.property
    @pulumi.getter(name="targetRuleIds")
    def target_rule_ids(self) -> Sequence[_builtins.str]:
        """
        A list of target rule IDs under the WAF rule set to apply the preconfigured WAF exclusion.
        If omitted, it refers to all the rule IDs under the WAF rule set.
        """
        return pulumi.get(self, "target_rule_ids")

    @_builtins.property
    @pulumi.getter(name="targetRuleSet")
    def target_rule_set(self) -> _builtins.str:
        """
        Target WAF rule set to apply the preconfigured WAF exclusion.
        """
        return pulumi.get(self, "target_rule_set")


@pulumi.output_type
class GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCookyResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value.
               Available options:
               EQUALS: The operator matches if the field value equals the specified value.
               STARTS_WITH: The operator matches if the field value starts with the specified value.
               ENDS_WITH: The operator matches if the field value ends with the specified value.
               CONTAINS: The operator matches if the field value contains the specified value.
               EQUALS_ANY: The operator matches if the field value is any value. Possible values: ["CONTAINS", "ENDS_WITH", "EQUALS", "EQUALS_ANY", "STARTS_WITH"]
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
               The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value.
        Available options:
        EQUALS: The operator matches if the field value equals the specified value.
        STARTS_WITH: The operator matches if the field value starts with the specified value.
        ENDS_WITH: The operator matches if the field value ends with the specified value.
        CONTAINS: The operator matches if the field value contains the specified value.
        EQUALS_ANY: The operator matches if the field value is any value. Possible values: ["CONTAINS", "ENDS_WITH", "EQUALS", "EQUALS_ANY", "STARTS_WITH"]
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
        The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeaderResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value.
               Available options:
               EQUALS: The operator matches if the field value equals the specified value.
               STARTS_WITH: The operator matches if the field value starts with the specified value.
               ENDS_WITH: The operator matches if the field value ends with the specified value.
               CONTAINS: The operator matches if the field value contains the specified value.
               EQUALS_ANY: The operator matches if the field value is any value. Possible values: ["CONTAINS", "ENDS_WITH", "EQUALS", "EQUALS_ANY", "STARTS_WITH"]
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
               The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value.
        Available options:
        EQUALS: The operator matches if the field value equals the specified value.
        STARTS_WITH: The operator matches if the field value starts with the specified value.
        ENDS_WITH: The operator matches if the field value ends with the specified value.
        CONTAINS: The operator matches if the field value contains the specified value.
        EQUALS_ANY: The operator matches if the field value is any value. Possible values: ["CONTAINS", "ENDS_WITH", "EQUALS", "EQUALS_ANY", "STARTS_WITH"]
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
        The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParamResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value.
               Available options:
               EQUALS: The operator matches if the field value equals the specified value.
               STARTS_WITH: The operator matches if the field value starts with the specified value.
               ENDS_WITH: The operator matches if the field value ends with the specified value.
               CONTAINS: The operator matches if the field value contains the specified value.
               EQUALS_ANY: The operator matches if the field value is any value. Possible values: ["CONTAINS", "ENDS_WITH", "EQUALS", "EQUALS_ANY", "STARTS_WITH"]
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
               The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value.
        Available options:
        EQUALS: The operator matches if the field value equals the specified value.
        STARTS_WITH: The operator matches if the field value starts with the specified value.
        ENDS_WITH: The operator matches if the field value ends with the specified value.
        CONTAINS: The operator matches if the field value contains the specified value.
        EQUALS_ANY: The operator matches if the field value is any value. Possible values: ["CONTAINS", "ENDS_WITH", "EQUALS", "EQUALS_ANY", "STARTS_WITH"]
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
        The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUriResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value.
               Available options:
               EQUALS: The operator matches if the field value equals the specified value.
               STARTS_WITH: The operator matches if the field value starts with the specified value.
               ENDS_WITH: The operator matches if the field value ends with the specified value.
               CONTAINS: The operator matches if the field value contains the specified value.
               EQUALS_ANY: The operator matches if the field value is any value. Possible values: ["CONTAINS", "ENDS_WITH", "EQUALS", "EQUALS_ANY", "STARTS_WITH"]
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
               The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value.
        Available options:
        EQUALS: The operator matches if the field value equals the specified value.
        STARTS_WITH: The operator matches if the field value starts with the specified value.
        ENDS_WITH: The operator matches if the field value ends with the specified value.
        CONTAINS: The operator matches if the field value contains the specified value.
        EQUALS_ANY: The operator matches if the field value is any value. Possible values: ["CONTAINS", "ENDS_WITH", "EQUALS", "EQUALS_ANY", "STARTS_WITH"]
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
        The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRegionSecurityPolicyRuleRateLimitOptionResult(dict):
    def __init__(__self__, *,
                 ban_duration_sec: _builtins.int,
                 ban_thresholds: Sequence['outputs.GetRegionSecurityPolicyRuleRateLimitOptionBanThresholdResult'],
                 conform_action: _builtins.str,
                 enforce_on_key: _builtins.str,
                 enforce_on_key_configs: Sequence['outputs.GetRegionSecurityPolicyRuleRateLimitOptionEnforceOnKeyConfigResult'],
                 enforce_on_key_name: _builtins.str,
                 exceed_action: _builtins.str,
                 rate_limit_thresholds: Sequence['outputs.GetRegionSecurityPolicyRuleRateLimitOptionRateLimitThresholdResult']):
        """
        :param _builtins.int ban_duration_sec: Can only be specified if the action for the rule is "rate_based_ban".
               If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
        :param Sequence['GetRegionSecurityPolicyRuleRateLimitOptionBanThresholdArgs'] ban_thresholds: Can only be specified if the action for the rule is "rate_based_ban".
               If specified, the key will be banned for the configured 'banDurationSec' when the number of requests that exceed the 'rateLimitThreshold' also exceed this 'banThreshold'.
        :param _builtins.str conform_action: Action to take for requests that are under the configured rate limit threshold.
               Valid option is "allow" only.
        :param _builtins.str enforce_on_key: Determines the key to enforce the rateLimitThreshold on. Possible values are:
               * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKey" is not configured.
               * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
               * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
               * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
               * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
               * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
               * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
               * REGION_CODE: The country/region from which the request originates.
               * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
               * TLS_JA4_FINGERPRINT: JA4 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
               * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP. Possible values: ["ALL", "IP", "HTTP_HEADER", "XFF_IP", "HTTP_COOKIE", "HTTP_PATH", "SNI", "REGION_CODE", "TLS_JA3_FINGERPRINT", "TLS_JA4_FINGERPRINT", "USER_IP"]
        :param Sequence['GetRegionSecurityPolicyRuleRateLimitOptionEnforceOnKeyConfigArgs'] enforce_on_key_configs: If specified, any combination of values of enforceOnKeyType/enforceOnKeyName is treated as the key on which ratelimit threshold/action is enforced.
               You can specify up to 3 enforceOnKeyConfigs.
               If enforceOnKeyConfigs is specified, enforceOnKey must not be specified.
        :param _builtins.str enforce_on_key_name: Rate limit key name applicable only for the following key types:
               HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
               HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        :param _builtins.str exceed_action: Action to take for requests that are above the configured rate limit threshold, to deny with a specified HTTP response code.
               Valid options are deny(STATUS), where valid values for STATUS are 403, 404, 429, and 502.
        :param Sequence['GetRegionSecurityPolicyRuleRateLimitOptionRateLimitThresholdArgs'] rate_limit_thresholds: Threshold at which to begin ratelimiting.
        """
        pulumi.set(__self__, "ban_duration_sec", ban_duration_sec)
        pulumi.set(__self__, "ban_thresholds", ban_thresholds)
        pulumi.set(__self__, "conform_action", conform_action)
        pulumi.set(__self__, "enforce_on_key", enforce_on_key)
        pulumi.set(__self__, "enforce_on_key_configs", enforce_on_key_configs)
        pulumi.set(__self__, "enforce_on_key_name", enforce_on_key_name)
        pulumi.set(__self__, "exceed_action", exceed_action)
        pulumi.set(__self__, "rate_limit_thresholds", rate_limit_thresholds)

    @_builtins.property
    @pulumi.getter(name="banDurationSec")
    def ban_duration_sec(self) -> _builtins.int:
        """
        Can only be specified if the action for the rule is "rate_based_ban".
        If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
        """
        return pulumi.get(self, "ban_duration_sec")

    @_builtins.property
    @pulumi.getter(name="banThresholds")
    def ban_thresholds(self) -> Sequence['outputs.GetRegionSecurityPolicyRuleRateLimitOptionBanThresholdResult']:
        """
        Can only be specified if the action for the rule is "rate_based_ban".
        If specified, the key will be banned for the configured 'banDurationSec' when the number of requests that exceed the 'rateLimitThreshold' also exceed this 'banThreshold'.
        """
        return pulumi.get(self, "ban_thresholds")

    @_builtins.property
    @pulumi.getter(name="conformAction")
    def conform_action(self) -> _builtins.str:
        """
        Action to take for requests that are under the configured rate limit threshold.
        Valid option is "allow" only.
        """
        return pulumi.get(self, "conform_action")

    @_builtins.property
    @pulumi.getter(name="enforceOnKey")
    def enforce_on_key(self) -> _builtins.str:
        """
        Determines the key to enforce the rateLimitThreshold on. Possible values are:
        * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKey" is not configured.
        * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
        * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
        * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
        * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
        * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
        * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
        * REGION_CODE: The country/region from which the request originates.
        * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
        * TLS_JA4_FINGERPRINT: JA4 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
        * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP. Possible values: ["ALL", "IP", "HTTP_HEADER", "XFF_IP", "HTTP_COOKIE", "HTTP_PATH", "SNI", "REGION_CODE", "TLS_JA3_FINGERPRINT", "TLS_JA4_FINGERPRINT", "USER_IP"]
        """
        return pulumi.get(self, "enforce_on_key")

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyConfigs")
    def enforce_on_key_configs(self) -> Sequence['outputs.GetRegionSecurityPolicyRuleRateLimitOptionEnforceOnKeyConfigResult']:
        """
        If specified, any combination of values of enforceOnKeyType/enforceOnKeyName is treated as the key on which ratelimit threshold/action is enforced.
        You can specify up to 3 enforceOnKeyConfigs.
        If enforceOnKeyConfigs is specified, enforceOnKey must not be specified.
        """
        return pulumi.get(self, "enforce_on_key_configs")

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyName")
    def enforce_on_key_name(self) -> _builtins.str:
        """
        Rate limit key name applicable only for the following key types:
        HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
        HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        """
        return pulumi.get(self, "enforce_on_key_name")

    @_builtins.property
    @pulumi.getter(name="exceedAction")
    def exceed_action(self) -> _builtins.str:
        """
        Action to take for requests that are above the configured rate limit threshold, to deny with a specified HTTP response code.
        Valid options are deny(STATUS), where valid values for STATUS are 403, 404, 429, and 502.
        """
        return pulumi.get(self, "exceed_action")

    @_builtins.property
    @pulumi.getter(name="rateLimitThresholds")
    def rate_limit_thresholds(self) -> Sequence['outputs.GetRegionSecurityPolicyRuleRateLimitOptionRateLimitThresholdResult']:
        """
        Threshold at which to begin ratelimiting.
        """
        return pulumi.get(self, "rate_limit_thresholds")


@pulumi.output_type
class GetRegionSecurityPolicyRuleRateLimitOptionBanThresholdResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 interval_sec: _builtins.int):
        """
        :param _builtins.int count: Number of HTTP(S) requests for calculating the threshold.
        :param _builtins.int interval_sec: Interval over which the threshold is computed.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval_sec", interval_sec)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        Number of HTTP(S) requests for calculating the threshold.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="intervalSec")
    def interval_sec(self) -> _builtins.int:
        """
        Interval over which the threshold is computed.
        """
        return pulumi.get(self, "interval_sec")


@pulumi.output_type
class GetRegionSecurityPolicyRuleRateLimitOptionEnforceOnKeyConfigResult(dict):
    def __init__(__self__, *,
                 enforce_on_key_name: _builtins.str,
                 enforce_on_key_type: _builtins.str):
        """
        :param _builtins.str enforce_on_key_name: Rate limit key name applicable only for the following key types:
               HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
               HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        :param _builtins.str enforce_on_key_type: Determines the key to enforce the rateLimitThreshold on. Possible values are:
               * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKeyConfigs" is not configured.
               * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
               * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
               * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
               * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
               * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
               * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
               * REGION_CODE: The country/region from which the request originates.
               * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
               * TLS_JA4_FINGERPRINT: JA4 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
               * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP. Possible values: ["ALL", "IP", "HTTP_HEADER", "XFF_IP", "HTTP_COOKIE", "HTTP_PATH", "SNI", "REGION_CODE", "TLS_JA3_FINGERPRINT", "TLS_JA4_FINGERPRINT", "USER_IP"]
        """
        pulumi.set(__self__, "enforce_on_key_name", enforce_on_key_name)
        pulumi.set(__self__, "enforce_on_key_type", enforce_on_key_type)

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyName")
    def enforce_on_key_name(self) -> _builtins.str:
        """
        Rate limit key name applicable only for the following key types:
        HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
        HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        """
        return pulumi.get(self, "enforce_on_key_name")

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyType")
    def enforce_on_key_type(self) -> _builtins.str:
        """
        Determines the key to enforce the rateLimitThreshold on. Possible values are:
        * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKeyConfigs" is not configured.
        * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
        * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
        * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
        * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
        * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
        * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
        * REGION_CODE: The country/region from which the request originates.
        * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
        * TLS_JA4_FINGERPRINT: JA4 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
        * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP. Possible values: ["ALL", "IP", "HTTP_HEADER", "XFF_IP", "HTTP_COOKIE", "HTTP_PATH", "SNI", "REGION_CODE", "TLS_JA3_FINGERPRINT", "TLS_JA4_FINGERPRINT", "USER_IP"]
        """
        return pulumi.get(self, "enforce_on_key_type")


@pulumi.output_type
class GetRegionSecurityPolicyRuleRateLimitOptionRateLimitThresholdResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 interval_sec: _builtins.int):
        """
        :param _builtins.int count: Number of HTTP(S) requests for calculating the threshold.
        :param _builtins.int interval_sec: Interval over which the threshold is computed.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval_sec", interval_sec)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        Number of HTTP(S) requests for calculating the threshold.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="intervalSec")
    def interval_sec(self) -> _builtins.int:
        """
        Interval over which the threshold is computed.
        """
        return pulumi.get(self, "interval_sec")


@pulumi.output_type
class GetRegionSecurityPolicyUserDefinedFieldResult(dict):
    def __init__(__self__, *,
                 base: _builtins.str,
                 mask: _builtins.str,
                 name: _builtins.str,
                 offset: _builtins.int,
                 size: _builtins.int):
        """
        :param _builtins.str base: The base relative to which 'offset' is measured. Possible values are:
               - IPV4: Points to the beginning of the IPv4 header.
               - IPV6: Points to the beginning of the IPv6 header.
               - TCP: Points to the beginning of the TCP header, skipping over any IPv4 options or IPv6 extension headers. Not present for non-first fragments.
               - UDP: Points to the beginning of the UDP header, skipping over any IPv4 options or IPv6 extension headers. Not present for non-first fragments. Possible values: ["IPV4", "IPV6", "TCP", "UDP"]
        :param _builtins.str mask: If specified, apply this mask (bitwise AND) to the field to ignore bits before matching.
               Encoded as a hexadecimal number (starting with "0x").
               The last byte of the field (in network byte order) corresponds to the least significant byte of the mask.
        :param _builtins.str name: The name of the Region Security Policy.
        :param _builtins.int offset: Offset of the first byte of the field (in network byte order) relative to 'base'.
        :param _builtins.int size: Size of the field in bytes. Valid values: 1-4.
        """
        pulumi.set(__self__, "base", base)
        pulumi.set(__self__, "mask", mask)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def base(self) -> _builtins.str:
        """
        The base relative to which 'offset' is measured. Possible values are:
        - IPV4: Points to the beginning of the IPv4 header.
        - IPV6: Points to the beginning of the IPv6 header.
        - TCP: Points to the beginning of the TCP header, skipping over any IPv4 options or IPv6 extension headers. Not present for non-first fragments.
        - UDP: Points to the beginning of the UDP header, skipping over any IPv4 options or IPv6 extension headers. Not present for non-first fragments. Possible values: ["IPV4", "IPV6", "TCP", "UDP"]
        """
        return pulumi.get(self, "base")

    @_builtins.property
    @pulumi.getter
    def mask(self) -> _builtins.str:
        """
        If specified, apply this mask (bitwise AND) to the field to ignore bits before matching.
        Encoded as a hexadecimal number (starting with "0x").
        The last byte of the field (in network byte order) corresponds to the least significant byte of the mask.
        """
        return pulumi.get(self, "mask")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Region Security Policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.int:
        """
        Offset of the first byte of the field (in network byte order) relative to 'base'.
        """
        return pulumi.get(self, "offset")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Size of the field in bytes. Valid values: 1-4.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetReservationBlockHealthInfoResult(dict):
    def __init__(__self__, *,
                 degraded_sub_block_count: _builtins.int,
                 health_status: _builtins.str,
                 healthy_sub_block_count: _builtins.int):
        """
        :param _builtins.int degraded_sub_block_count: The number of sub-blocks that are degraded.
        :param _builtins.str health_status: The health status of the reservation block.
        :param _builtins.int healthy_sub_block_count: The number of sub-blocks that are healthy.
        """
        pulumi.set(__self__, "degraded_sub_block_count", degraded_sub_block_count)
        pulumi.set(__self__, "health_status", health_status)
        pulumi.set(__self__, "healthy_sub_block_count", healthy_sub_block_count)

    @_builtins.property
    @pulumi.getter(name="degradedSubBlockCount")
    def degraded_sub_block_count(self) -> _builtins.int:
        """
        The number of sub-blocks that are degraded.
        """
        return pulumi.get(self, "degraded_sub_block_count")

    @_builtins.property
    @pulumi.getter(name="healthStatus")
    def health_status(self) -> _builtins.str:
        """
        The health status of the reservation block.
        """
        return pulumi.get(self, "health_status")

    @_builtins.property
    @pulumi.getter(name="healthySubBlockCount")
    def healthy_sub_block_count(self) -> _builtins.int:
        """
        The number of sub-blocks that are healthy.
        """
        return pulumi.get(self, "healthy_sub_block_count")


@pulumi.output_type
class GetReservationBlockPhysicalTopologyResult(dict):
    def __init__(__self__, *,
                 block: _builtins.str,
                 cluster: _builtins.str):
        """
        :param _builtins.str block: The hash of the capacity block within the cluster.
        :param _builtins.str cluster: The cluster name of the reservation block.
        """
        pulumi.set(__self__, "block", block)
        pulumi.set(__self__, "cluster", cluster)

    @_builtins.property
    @pulumi.getter
    def block(self) -> _builtins.str:
        """
        The hash of the capacity block within the cluster.
        """
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> _builtins.str:
        """
        The cluster name of the reservation block.
        """
        return pulumi.get(self, "cluster")


@pulumi.output_type
class GetReservationBlockReservationMaintenanceResult(dict):
    def __init__(__self__, *,
                 instance_maintenance_ongoing_count: _builtins.int,
                 instance_maintenance_pending_count: _builtins.int,
                 maintenance_ongoing_count: _builtins.int,
                 maintenance_pending_count: _builtins.int,
                 scheduling_type: _builtins.str,
                 subblock_infra_maintenance_ongoing_count: _builtins.int,
                 subblock_infra_maintenance_pending_count: _builtins.int):
        """
        :param _builtins.int instance_maintenance_ongoing_count: Number of instances that have ongoing maintenance.
        :param _builtins.int instance_maintenance_pending_count: Number of instances that have pending maintenance.
        :param _builtins.int maintenance_ongoing_count: Number of hosts in the block that have ongoing maintenance.
        :param _builtins.int maintenance_pending_count: Number of hosts in the block that have pending maintenance.
        :param _builtins.str scheduling_type: The type of maintenance for the reservation.
        :param _builtins.int subblock_infra_maintenance_ongoing_count: Number of sub-block infrastructure that has ongoing maintenance.
        :param _builtins.int subblock_infra_maintenance_pending_count: Number of sub-block infrastructure that has pending maintenance.
        """
        pulumi.set(__self__, "instance_maintenance_ongoing_count", instance_maintenance_ongoing_count)
        pulumi.set(__self__, "instance_maintenance_pending_count", instance_maintenance_pending_count)
        pulumi.set(__self__, "maintenance_ongoing_count", maintenance_ongoing_count)
        pulumi.set(__self__, "maintenance_pending_count", maintenance_pending_count)
        pulumi.set(__self__, "scheduling_type", scheduling_type)
        pulumi.set(__self__, "subblock_infra_maintenance_ongoing_count", subblock_infra_maintenance_ongoing_count)
        pulumi.set(__self__, "subblock_infra_maintenance_pending_count", subblock_infra_maintenance_pending_count)

    @_builtins.property
    @pulumi.getter(name="instanceMaintenanceOngoingCount")
    def instance_maintenance_ongoing_count(self) -> _builtins.int:
        """
        Number of instances that have ongoing maintenance.
        """
        return pulumi.get(self, "instance_maintenance_ongoing_count")

    @_builtins.property
    @pulumi.getter(name="instanceMaintenancePendingCount")
    def instance_maintenance_pending_count(self) -> _builtins.int:
        """
        Number of instances that have pending maintenance.
        """
        return pulumi.get(self, "instance_maintenance_pending_count")

    @_builtins.property
    @pulumi.getter(name="maintenanceOngoingCount")
    def maintenance_ongoing_count(self) -> _builtins.int:
        """
        Number of hosts in the block that have ongoing maintenance.
        """
        return pulumi.get(self, "maintenance_ongoing_count")

    @_builtins.property
    @pulumi.getter(name="maintenancePendingCount")
    def maintenance_pending_count(self) -> _builtins.int:
        """
        Number of hosts in the block that have pending maintenance.
        """
        return pulumi.get(self, "maintenance_pending_count")

    @_builtins.property
    @pulumi.getter(name="schedulingType")
    def scheduling_type(self) -> _builtins.str:
        """
        The type of maintenance for the reservation.
        """
        return pulumi.get(self, "scheduling_type")

    @_builtins.property
    @pulumi.getter(name="subblockInfraMaintenanceOngoingCount")
    def subblock_infra_maintenance_ongoing_count(self) -> _builtins.int:
        """
        Number of sub-block infrastructure that has ongoing maintenance.
        """
        return pulumi.get(self, "subblock_infra_maintenance_ongoing_count")

    @_builtins.property
    @pulumi.getter(name="subblockInfraMaintenancePendingCount")
    def subblock_infra_maintenance_pending_count(self) -> _builtins.int:
        """
        Number of sub-block infrastructure that has pending maintenance.
        """
        return pulumi.get(self, "subblock_infra_maintenance_pending_count")


@pulumi.output_type
class GetReservationDeleteAfterDurationResult(dict):
    def __init__(__self__, *,
                 nanos: _builtins.int,
                 seconds: _builtins.str):
        """
        :param _builtins.int nanos: Number of nanoseconds for the auto-delete duration.
        :param _builtins.str seconds: Number of seconds for the auto-delete duration.
        """
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> _builtins.int:
        """
        Number of nanoseconds for the auto-delete duration.
        """
        return pulumi.get(self, "nanos")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.str:
        """
        Number of seconds for the auto-delete duration.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetReservationReservationSharingPolicyResult(dict):
    def __init__(__self__, *,
                 service_share_type: _builtins.str):
        """
        :param _builtins.str service_share_type: Sharing config for all Google Cloud services. Possible values: ["ALLOW_ALL", "DISALLOW_ALL"]
        """
        pulumi.set(__self__, "service_share_type", service_share_type)

    @_builtins.property
    @pulumi.getter(name="serviceShareType")
    def service_share_type(self) -> _builtins.str:
        """
        Sharing config for all Google Cloud services. Possible values: ["ALLOW_ALL", "DISALLOW_ALL"]
        """
        return pulumi.get(self, "service_share_type")


@pulumi.output_type
class GetReservationResourceStatusResult(dict):
    def __init__(__self__, *,
                 health_infos: Sequence['outputs.GetReservationResourceStatusHealthInfoResult'],
                 reservation_block_count: _builtins.int,
                 reservation_maintenances: Sequence['outputs.GetReservationResourceStatusReservationMaintenanceResult'],
                 specific_sku_allocations: Sequence['outputs.GetReservationResourceStatusSpecificSkuAllocationResult']):
        """
        :param Sequence['GetReservationResourceStatusHealthInfoArgs'] health_infos: Health information for the reservation.
        :param _builtins.int reservation_block_count: The number of reservation blocks associated with this reservation.
        :param Sequence['GetReservationResourceStatusReservationMaintenanceArgs'] reservation_maintenances: Maintenance information for this reservation
        :param Sequence['GetReservationResourceStatusSpecificSkuAllocationArgs'] specific_sku_allocations: Allocation Properties of this reservation.
        """
        pulumi.set(__self__, "health_infos", health_infos)
        pulumi.set(__self__, "reservation_block_count", reservation_block_count)
        pulumi.set(__self__, "reservation_maintenances", reservation_maintenances)
        pulumi.set(__self__, "specific_sku_allocations", specific_sku_allocations)

    @_builtins.property
    @pulumi.getter(name="healthInfos")
    def health_infos(self) -> Sequence['outputs.GetReservationResourceStatusHealthInfoResult']:
        """
        Health information for the reservation.
        """
        return pulumi.get(self, "health_infos")

    @_builtins.property
    @pulumi.getter(name="reservationBlockCount")
    def reservation_block_count(self) -> _builtins.int:
        """
        The number of reservation blocks associated with this reservation.
        """
        return pulumi.get(self, "reservation_block_count")

    @_builtins.property
    @pulumi.getter(name="reservationMaintenances")
    def reservation_maintenances(self) -> Sequence['outputs.GetReservationResourceStatusReservationMaintenanceResult']:
        """
        Maintenance information for this reservation
        """
        return pulumi.get(self, "reservation_maintenances")

    @_builtins.property
    @pulumi.getter(name="specificSkuAllocations")
    def specific_sku_allocations(self) -> Sequence['outputs.GetReservationResourceStatusSpecificSkuAllocationResult']:
        """
        Allocation Properties of this reservation.
        """
        return pulumi.get(self, "specific_sku_allocations")


@pulumi.output_type
class GetReservationResourceStatusHealthInfoResult(dict):
    def __init__(__self__, *,
                 degraded_block_count: _builtins.int,
                 health_status: _builtins.str,
                 healthy_block_count: _builtins.int):
        """
        :param _builtins.int degraded_block_count: The number of reservation blocks that are degraded.
        :param _builtins.str health_status: The health status of the reservation.
        :param _builtins.int healthy_block_count: The number of reservation blocks that are healthy.
        """
        pulumi.set(__self__, "degraded_block_count", degraded_block_count)
        pulumi.set(__self__, "health_status", health_status)
        pulumi.set(__self__, "healthy_block_count", healthy_block_count)

    @_builtins.property
    @pulumi.getter(name="degradedBlockCount")
    def degraded_block_count(self) -> _builtins.int:
        """
        The number of reservation blocks that are degraded.
        """
        return pulumi.get(self, "degraded_block_count")

    @_builtins.property
    @pulumi.getter(name="healthStatus")
    def health_status(self) -> _builtins.str:
        """
        The health status of the reservation.
        """
        return pulumi.get(self, "health_status")

    @_builtins.property
    @pulumi.getter(name="healthyBlockCount")
    def healthy_block_count(self) -> _builtins.int:
        """
        The number of reservation blocks that are healthy.
        """
        return pulumi.get(self, "healthy_block_count")


@pulumi.output_type
class GetReservationResourceStatusReservationMaintenanceResult(dict):
    def __init__(__self__, *,
                 instance_maintenance_ongoing_count: _builtins.int,
                 instance_maintenance_pending_count: _builtins.int,
                 maintenance_ongoing_count: _builtins.int,
                 maintenance_pending_count: _builtins.int,
                 scheduling_type: _builtins.str,
                 subblock_infra_maintenance_ongoing_count: _builtins.int,
                 subblock_infra_maintenance_pending_count: _builtins.int,
                 upcoming_group_maintenances: Sequence['outputs.GetReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceResult']):
        """
        :param _builtins.int instance_maintenance_ongoing_count: Describes number of instances that have ongoing maintenance.
        :param _builtins.int instance_maintenance_pending_count: Describes number of instances that have pending maintenance.
        :param _builtins.int maintenance_ongoing_count: Progress for ongoing maintenance for this group of VMs/hosts. Describes number of hosts in the block that have ongoing maintenance.
        :param _builtins.int maintenance_pending_count: Progress for ongoing maintenance for this group of VMs/hosts. Describes number of hosts in the block that have pending maintenance.
        :param _builtins.str scheduling_type: The type of maintenance for the reservation.
        :param _builtins.int subblock_infra_maintenance_ongoing_count: Describes number of subblock Infrastructure that has ongoing maintenance. Here, Subblock Infrastructure Maintenance pertains to upstream hardware contained in the Subblock that is necessary for a VM Family(e.g. NVLink Domains). Not all VM Families will support this field.
        :param _builtins.int subblock_infra_maintenance_pending_count: Describes number of subblock Infrastructure that has pending maintenance. Here, Subblock Infrastructure Maintenance pertains to upstream hardware contained in the Subblock that is necessary for a VM Family (e.g. NVLink Domains). Not all VM Families will support this field.
        :param Sequence['GetReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceArgs'] upcoming_group_maintenances: Maintenance information on this group of VMs.
        """
        pulumi.set(__self__, "instance_maintenance_ongoing_count", instance_maintenance_ongoing_count)
        pulumi.set(__self__, "instance_maintenance_pending_count", instance_maintenance_pending_count)
        pulumi.set(__self__, "maintenance_ongoing_count", maintenance_ongoing_count)
        pulumi.set(__self__, "maintenance_pending_count", maintenance_pending_count)
        pulumi.set(__self__, "scheduling_type", scheduling_type)
        pulumi.set(__self__, "subblock_infra_maintenance_ongoing_count", subblock_infra_maintenance_ongoing_count)
        pulumi.set(__self__, "subblock_infra_maintenance_pending_count", subblock_infra_maintenance_pending_count)
        pulumi.set(__self__, "upcoming_group_maintenances", upcoming_group_maintenances)

    @_builtins.property
    @pulumi.getter(name="instanceMaintenanceOngoingCount")
    def instance_maintenance_ongoing_count(self) -> _builtins.int:
        """
        Describes number of instances that have ongoing maintenance.
        """
        return pulumi.get(self, "instance_maintenance_ongoing_count")

    @_builtins.property
    @pulumi.getter(name="instanceMaintenancePendingCount")
    def instance_maintenance_pending_count(self) -> _builtins.int:
        """
        Describes number of instances that have pending maintenance.
        """
        return pulumi.get(self, "instance_maintenance_pending_count")

    @_builtins.property
    @pulumi.getter(name="maintenanceOngoingCount")
    def maintenance_ongoing_count(self) -> _builtins.int:
        """
        Progress for ongoing maintenance for this group of VMs/hosts. Describes number of hosts in the block that have ongoing maintenance.
        """
        return pulumi.get(self, "maintenance_ongoing_count")

    @_builtins.property
    @pulumi.getter(name="maintenancePendingCount")
    def maintenance_pending_count(self) -> _builtins.int:
        """
        Progress for ongoing maintenance for this group of VMs/hosts. Describes number of hosts in the block that have pending maintenance.
        """
        return pulumi.get(self, "maintenance_pending_count")

    @_builtins.property
    @pulumi.getter(name="schedulingType")
    def scheduling_type(self) -> _builtins.str:
        """
        The type of maintenance for the reservation.
        """
        return pulumi.get(self, "scheduling_type")

    @_builtins.property
    @pulumi.getter(name="subblockInfraMaintenanceOngoingCount")
    def subblock_infra_maintenance_ongoing_count(self) -> _builtins.int:
        """
        Describes number of subblock Infrastructure that has ongoing maintenance. Here, Subblock Infrastructure Maintenance pertains to upstream hardware contained in the Subblock that is necessary for a VM Family(e.g. NVLink Domains). Not all VM Families will support this field.
        """
        return pulumi.get(self, "subblock_infra_maintenance_ongoing_count")

    @_builtins.property
    @pulumi.getter(name="subblockInfraMaintenancePendingCount")
    def subblock_infra_maintenance_pending_count(self) -> _builtins.int:
        """
        Describes number of subblock Infrastructure that has pending maintenance. Here, Subblock Infrastructure Maintenance pertains to upstream hardware contained in the Subblock that is necessary for a VM Family (e.g. NVLink Domains). Not all VM Families will support this field.
        """
        return pulumi.get(self, "subblock_infra_maintenance_pending_count")

    @_builtins.property
    @pulumi.getter(name="upcomingGroupMaintenances")
    def upcoming_group_maintenances(self) -> Sequence['outputs.GetReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceResult']:
        """
        Maintenance information on this group of VMs.
        """
        return pulumi.get(self, "upcoming_group_maintenances")


@pulumi.output_type
class GetReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceResult(dict):
    def __init__(__self__, *,
                 can_reschedule: _builtins.bool,
                 latest_window_start_time: _builtins.str,
                 maintenance_on_shutdown: _builtins.bool,
                 maintenance_reasons: Sequence[_builtins.str],
                 maintenance_status: _builtins.str,
                 type: _builtins.str,
                 window_end_time: _builtins.str,
                 window_start_time: _builtins.str):
        """
        :param _builtins.bool can_reschedule: Indicates if the maintenance can be customer triggered.
        :param _builtins.str latest_window_start_time: The latest time for the planned maintenance window to start. This timestamp value is in RFC3339 text format.
        :param _builtins.bool maintenance_on_shutdown: Indicates whether the UpcomingMaintenance will be triggered on VM shutdown.
        :param Sequence[_builtins.str] maintenance_reasons: The reasons for the maintenance. Only valid for vms.
        :param _builtins.str maintenance_status: Status of the maintenance.
        :param _builtins.str type: Defines the type of maintenance.
        :param _builtins.str window_end_time: The time by which the maintenance disruption will be completed. This timestamp value is in RFC3339 text format.
        :param _builtins.str window_start_time: The current start time of the maintenance window. This timestamp value is in RFC3339 text format.
        """
        pulumi.set(__self__, "can_reschedule", can_reschedule)
        pulumi.set(__self__, "latest_window_start_time", latest_window_start_time)
        pulumi.set(__self__, "maintenance_on_shutdown", maintenance_on_shutdown)
        pulumi.set(__self__, "maintenance_reasons", maintenance_reasons)
        pulumi.set(__self__, "maintenance_status", maintenance_status)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "window_end_time", window_end_time)
        pulumi.set(__self__, "window_start_time", window_start_time)

    @_builtins.property
    @pulumi.getter(name="canReschedule")
    def can_reschedule(self) -> _builtins.bool:
        """
        Indicates if the maintenance can be customer triggered.
        """
        return pulumi.get(self, "can_reschedule")

    @_builtins.property
    @pulumi.getter(name="latestWindowStartTime")
    def latest_window_start_time(self) -> _builtins.str:
        """
        The latest time for the planned maintenance window to start. This timestamp value is in RFC3339 text format.
        """
        return pulumi.get(self, "latest_window_start_time")

    @_builtins.property
    @pulumi.getter(name="maintenanceOnShutdown")
    def maintenance_on_shutdown(self) -> _builtins.bool:
        """
        Indicates whether the UpcomingMaintenance will be triggered on VM shutdown.
        """
        return pulumi.get(self, "maintenance_on_shutdown")

    @_builtins.property
    @pulumi.getter(name="maintenanceReasons")
    def maintenance_reasons(self) -> Sequence[_builtins.str]:
        """
        The reasons for the maintenance. Only valid for vms.
        """
        return pulumi.get(self, "maintenance_reasons")

    @_builtins.property
    @pulumi.getter(name="maintenanceStatus")
    def maintenance_status(self) -> _builtins.str:
        """
        Status of the maintenance.
        """
        return pulumi.get(self, "maintenance_status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Defines the type of maintenance.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="windowEndTime")
    def window_end_time(self) -> _builtins.str:
        """
        The time by which the maintenance disruption will be completed. This timestamp value is in RFC3339 text format.
        """
        return pulumi.get(self, "window_end_time")

    @_builtins.property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> _builtins.str:
        """
        The current start time of the maintenance window. This timestamp value is in RFC3339 text format.
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class GetReservationResourceStatusSpecificSkuAllocationResult(dict):
    def __init__(__self__, *,
                 source_instance_template_id: _builtins.str,
                 utilizations: Mapping[str, _builtins.str]):
        """
        :param _builtins.str source_instance_template_id: ID of the instance template used to populate reservation properties.
        :param Mapping[str, _builtins.str] utilizations: Per service utilization breakdown. The Key is the Google Cloud managed service name.
        """
        pulumi.set(__self__, "source_instance_template_id", source_instance_template_id)
        pulumi.set(__self__, "utilizations", utilizations)

    @_builtins.property
    @pulumi.getter(name="sourceInstanceTemplateId")
    def source_instance_template_id(self) -> _builtins.str:
        """
        ID of the instance template used to populate reservation properties.
        """
        return pulumi.get(self, "source_instance_template_id")

    @_builtins.property
    @pulumi.getter
    def utilizations(self) -> Mapping[str, _builtins.str]:
        """
        Per service utilization breakdown. The Key is the Google Cloud managed service name.
        """
        return pulumi.get(self, "utilizations")


@pulumi.output_type
class GetReservationShareSettingResult(dict):
    def __init__(__self__, *,
                 project_maps: Sequence['outputs.GetReservationShareSettingProjectMapResult'],
                 projects: Sequence[_builtins.str],
                 share_type: _builtins.str):
        """
        :param Sequence['GetReservationShareSettingProjectMapArgs'] project_maps: A map of project number and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.
        :param Sequence[_builtins.str] projects: List of project IDs with which the reservation is shared.
        :param _builtins.str share_type: Type of sharing for this shared-reservation Possible values: ["LOCAL", "SPECIFIC_PROJECTS"]
        """
        pulumi.set(__self__, "project_maps", project_maps)
        pulumi.set(__self__, "projects", projects)
        pulumi.set(__self__, "share_type", share_type)

    @_builtins.property
    @pulumi.getter(name="projectMaps")
    def project_maps(self) -> Sequence['outputs.GetReservationShareSettingProjectMapResult']:
        """
        A map of project number and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.
        """
        return pulumi.get(self, "project_maps")

    @_builtins.property
    @pulumi.getter
    def projects(self) -> Sequence[_builtins.str]:
        """
        List of project IDs with which the reservation is shared.
        """
        return pulumi.get(self, "projects")

    @_builtins.property
    @pulumi.getter(name="shareType")
    def share_type(self) -> _builtins.str:
        """
        Type of sharing for this shared-reservation Possible values: ["LOCAL", "SPECIFIC_PROJECTS"]
        """
        return pulumi.get(self, "share_type")


@pulumi.output_type
class GetReservationShareSettingProjectMapResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 project_id: _builtins.str):
        """
        :param _builtins.str project_id: The project id/number, should be same as the key of this project config in the project map.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The project id/number, should be same as the key of this project config in the project map.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class GetReservationSpecificReservationResult(dict):
    def __init__(__self__, *,
                 assured_count: _builtins.int,
                 count: _builtins.int,
                 in_use_count: _builtins.int,
                 instance_properties: Sequence['outputs.GetReservationSpecificReservationInstancePropertyResult'],
                 source_instance_template: _builtins.str):
        """
        :param _builtins.int assured_count: Indicates how many instances are actually usable currently.
        :param _builtins.int count: The number of resources that are allocated.
        :param _builtins.int in_use_count: How many instances are in use.
        :param Sequence['GetReservationSpecificReservationInstancePropertyArgs'] instance_properties: The instance properties for the reservation.
        :param _builtins.str source_instance_template: Specifies the instance template to create the reservation. If you use this field, you must exclude the
               instanceProperties field.
        """
        pulumi.set(__self__, "assured_count", assured_count)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "in_use_count", in_use_count)
        pulumi.set(__self__, "instance_properties", instance_properties)
        pulumi.set(__self__, "source_instance_template", source_instance_template)

    @_builtins.property
    @pulumi.getter(name="assuredCount")
    def assured_count(self) -> _builtins.int:
        """
        Indicates how many instances are actually usable currently.
        """
        return pulumi.get(self, "assured_count")

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of resources that are allocated.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="inUseCount")
    def in_use_count(self) -> _builtins.int:
        """
        How many instances are in use.
        """
        return pulumi.get(self, "in_use_count")

    @_builtins.property
    @pulumi.getter(name="instanceProperties")
    def instance_properties(self) -> Sequence['outputs.GetReservationSpecificReservationInstancePropertyResult']:
        """
        The instance properties for the reservation.
        """
        return pulumi.get(self, "instance_properties")

    @_builtins.property
    @pulumi.getter(name="sourceInstanceTemplate")
    def source_instance_template(self) -> _builtins.str:
        """
        Specifies the instance template to create the reservation. If you use this field, you must exclude the
        instanceProperties field.
        """
        return pulumi.get(self, "source_instance_template")


@pulumi.output_type
class GetReservationSpecificReservationInstancePropertyResult(dict):
    def __init__(__self__, *,
                 guest_accelerators: Sequence['outputs.GetReservationSpecificReservationInstancePropertyGuestAcceleratorResult'],
                 local_ssds: Sequence['outputs.GetReservationSpecificReservationInstancePropertyLocalSsdResult'],
                 location_hint: _builtins.str,
                 machine_type: _builtins.str,
                 maintenance_interval: _builtins.str,
                 min_cpu_platform: _builtins.str):
        """
        :param Sequence['GetReservationSpecificReservationInstancePropertyGuestAcceleratorArgs'] guest_accelerators: Guest accelerator type and count.
        :param Sequence['GetReservationSpecificReservationInstancePropertyLocalSsdArgs'] local_ssds: The amount of local ssd to reserve with each instance. This
               reserves disks of type 'local-ssd'.
        :param _builtins.str location_hint: An opaque location hint used to place the allocation close to other resources. This field is for use by internal tools that use the public API.
        :param _builtins.str machine_type: The name of the machine type to reserve.
        :param _builtins.str maintenance_interval: Specifies the frequency of planned maintenance events. Possible values: ["AS_NEEDED", "PERIODIC", "RECURRENT"]
        :param _builtins.str min_cpu_platform: The minimum CPU platform for the reservation. For example,
               '"Intel Skylake"'. See
               the CPU platform availability reference](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform#availablezones)
               for information on available CPU platforms.
        """
        pulumi.set(__self__, "guest_accelerators", guest_accelerators)
        pulumi.set(__self__, "local_ssds", local_ssds)
        pulumi.set(__self__, "location_hint", location_hint)
        pulumi.set(__self__, "machine_type", machine_type)
        pulumi.set(__self__, "maintenance_interval", maintenance_interval)
        pulumi.set(__self__, "min_cpu_platform", min_cpu_platform)

    @_builtins.property
    @pulumi.getter(name="guestAccelerators")
    def guest_accelerators(self) -> Sequence['outputs.GetReservationSpecificReservationInstancePropertyGuestAcceleratorResult']:
        """
        Guest accelerator type and count.
        """
        return pulumi.get(self, "guest_accelerators")

    @_builtins.property
    @pulumi.getter(name="localSsds")
    def local_ssds(self) -> Sequence['outputs.GetReservationSpecificReservationInstancePropertyLocalSsdResult']:
        """
        The amount of local ssd to reserve with each instance. This
        reserves disks of type 'local-ssd'.
        """
        return pulumi.get(self, "local_ssds")

    @_builtins.property
    @pulumi.getter(name="locationHint")
    def location_hint(self) -> _builtins.str:
        """
        An opaque location hint used to place the allocation close to other resources. This field is for use by internal tools that use the public API.
        """
        return pulumi.get(self, "location_hint")

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> _builtins.str:
        """
        The name of the machine type to reserve.
        """
        return pulumi.get(self, "machine_type")

    @_builtins.property
    @pulumi.getter(name="maintenanceInterval")
    def maintenance_interval(self) -> _builtins.str:
        """
        Specifies the frequency of planned maintenance events. Possible values: ["AS_NEEDED", "PERIODIC", "RECURRENT"]
        """
        return pulumi.get(self, "maintenance_interval")

    @_builtins.property
    @pulumi.getter(name="minCpuPlatform")
    def min_cpu_platform(self) -> _builtins.str:
        """
        The minimum CPU platform for the reservation. For example,
        '"Intel Skylake"'. See
        the CPU platform availability reference](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform#availablezones)
        for information on available CPU platforms.
        """
        return pulumi.get(self, "min_cpu_platform")


@pulumi.output_type
class GetReservationSpecificReservationInstancePropertyGuestAcceleratorResult(dict):
    def __init__(__self__, *,
                 accelerator_count: _builtins.int,
                 accelerator_type: _builtins.str):
        """
        :param _builtins.int accelerator_count: The number of the guest accelerator cards exposed to
               this instance.
        :param _builtins.str accelerator_type: The full or partial URL of the accelerator type to
               attach to this instance. For example:
               'projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100'
               
               If you are creating an instance template, specify only the accelerator name.
        """
        pulumi.set(__self__, "accelerator_count", accelerator_count)
        pulumi.set(__self__, "accelerator_type", accelerator_type)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> _builtins.int:
        """
        The number of the guest accelerator cards exposed to
        this instance.
        """
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> _builtins.str:
        """
        The full or partial URL of the accelerator type to
        attach to this instance. For example:
        'projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100'

        If you are creating an instance template, specify only the accelerator name.
        """
        return pulumi.get(self, "accelerator_type")


@pulumi.output_type
class GetReservationSpecificReservationInstancePropertyLocalSsdResult(dict):
    def __init__(__self__, *,
                 disk_size_gb: _builtins.int,
                 interface: _builtins.str):
        """
        :param _builtins.int disk_size_gb: The size of the disk in base-2 GB.
        :param _builtins.str interface: The disk interface to use for attaching this disk. Default value: "SCSI" Possible values: ["SCSI", "NVME"]
        """
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "interface", interface)

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.int:
        """
        The size of the disk in base-2 GB.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> _builtins.str:
        """
        The disk interface to use for attaching this disk. Default value: "SCSI" Possible values: ["SCSI", "NVME"]
        """
        return pulumi.get(self, "interface")


@pulumi.output_type
class GetReservationSubBlockHealthInfoResult(dict):
    def __init__(__self__, *,
                 degraded_host_count: _builtins.int,
                 degraded_infra_count: _builtins.int,
                 health_status: _builtins.str,
                 healthy_host_count: _builtins.int,
                 healthy_infra_count: _builtins.int):
        """
        :param _builtins.int degraded_host_count: The number of degraded hosts in the reservation sub-block.
        :param _builtins.int degraded_infra_count: The number of degraded infrastructure (e.g. NVLink domain) in the reservation sub-block.
        :param _builtins.str health_status: The health status of the reservation sub-block.
        :param _builtins.int healthy_host_count: The number of healthy hosts in the reservation sub-block.
        :param _builtins.int healthy_infra_count: The number of healthy infrastructure (e.g. NVLink domain) in the reservation sub-block.
        """
        pulumi.set(__self__, "degraded_host_count", degraded_host_count)
        pulumi.set(__self__, "degraded_infra_count", degraded_infra_count)
        pulumi.set(__self__, "health_status", health_status)
        pulumi.set(__self__, "healthy_host_count", healthy_host_count)
        pulumi.set(__self__, "healthy_infra_count", healthy_infra_count)

    @_builtins.property
    @pulumi.getter(name="degradedHostCount")
    def degraded_host_count(self) -> _builtins.int:
        """
        The number of degraded hosts in the reservation sub-block.
        """
        return pulumi.get(self, "degraded_host_count")

    @_builtins.property
    @pulumi.getter(name="degradedInfraCount")
    def degraded_infra_count(self) -> _builtins.int:
        """
        The number of degraded infrastructure (e.g. NVLink domain) in the reservation sub-block.
        """
        return pulumi.get(self, "degraded_infra_count")

    @_builtins.property
    @pulumi.getter(name="healthStatus")
    def health_status(self) -> _builtins.str:
        """
        The health status of the reservation sub-block.
        """
        return pulumi.get(self, "health_status")

    @_builtins.property
    @pulumi.getter(name="healthyHostCount")
    def healthy_host_count(self) -> _builtins.int:
        """
        The number of healthy hosts in the reservation sub-block.
        """
        return pulumi.get(self, "healthy_host_count")

    @_builtins.property
    @pulumi.getter(name="healthyInfraCount")
    def healthy_infra_count(self) -> _builtins.int:
        """
        The number of healthy infrastructure (e.g. NVLink domain) in the reservation sub-block.
        """
        return pulumi.get(self, "healthy_infra_count")


@pulumi.output_type
class GetReservationSubBlockPhysicalTopologyResult(dict):
    def __init__(__self__, *,
                 block: _builtins.str,
                 cluster: _builtins.str,
                 sub_block: _builtins.str):
        """
        :param _builtins.str block: The hash of the capacity block within the cluster.
        :param _builtins.str cluster: The cluster name of the reservation sub-block.
        :param _builtins.str sub_block: The hash of the capacity sub-block within the capacity block.
        """
        pulumi.set(__self__, "block", block)
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "sub_block", sub_block)

    @_builtins.property
    @pulumi.getter
    def block(self) -> _builtins.str:
        """
        The hash of the capacity block within the cluster.
        """
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> _builtins.str:
        """
        The cluster name of the reservation sub-block.
        """
        return pulumi.get(self, "cluster")

    @_builtins.property
    @pulumi.getter(name="subBlock")
    def sub_block(self) -> _builtins.str:
        """
        The hash of the capacity sub-block within the capacity block.
        """
        return pulumi.get(self, "sub_block")


@pulumi.output_type
class GetReservationSubBlockReservationSubBlockMaintenanceResult(dict):
    def __init__(__self__, *,
                 instance_maintenance_ongoing_count: _builtins.int,
                 instance_maintenance_pending_count: _builtins.int,
                 maintenance_ongoing_count: _builtins.int,
                 maintenance_pending_count: _builtins.int,
                 scheduling_type: _builtins.str,
                 subblock_infra_maintenance_ongoing_count: _builtins.int,
                 subblock_infra_maintenance_pending_count: _builtins.int):
        """
        :param _builtins.int instance_maintenance_ongoing_count: Number of instances that have ongoing maintenance.
        :param _builtins.int instance_maintenance_pending_count: Number of instances that have pending maintenance.
        :param _builtins.int maintenance_ongoing_count: Number of hosts in the sub-block that have ongoing maintenance.
        :param _builtins.int maintenance_pending_count: Number of hosts in the sub-block that have pending maintenance.
        :param _builtins.str scheduling_type: The type of maintenance for the reservation.
        :param _builtins.int subblock_infra_maintenance_ongoing_count: Number of sub-block infrastructure that has ongoing maintenance.
        :param _builtins.int subblock_infra_maintenance_pending_count: Number of sub-block infrastructure that has pending maintenance.
        """
        pulumi.set(__self__, "instance_maintenance_ongoing_count", instance_maintenance_ongoing_count)
        pulumi.set(__self__, "instance_maintenance_pending_count", instance_maintenance_pending_count)
        pulumi.set(__self__, "maintenance_ongoing_count", maintenance_ongoing_count)
        pulumi.set(__self__, "maintenance_pending_count", maintenance_pending_count)
        pulumi.set(__self__, "scheduling_type", scheduling_type)
        pulumi.set(__self__, "subblock_infra_maintenance_ongoing_count", subblock_infra_maintenance_ongoing_count)
        pulumi.set(__self__, "subblock_infra_maintenance_pending_count", subblock_infra_maintenance_pending_count)

    @_builtins.property
    @pulumi.getter(name="instanceMaintenanceOngoingCount")
    def instance_maintenance_ongoing_count(self) -> _builtins.int:
        """
        Number of instances that have ongoing maintenance.
        """
        return pulumi.get(self, "instance_maintenance_ongoing_count")

    @_builtins.property
    @pulumi.getter(name="instanceMaintenancePendingCount")
    def instance_maintenance_pending_count(self) -> _builtins.int:
        """
        Number of instances that have pending maintenance.
        """
        return pulumi.get(self, "instance_maintenance_pending_count")

    @_builtins.property
    @pulumi.getter(name="maintenanceOngoingCount")
    def maintenance_ongoing_count(self) -> _builtins.int:
        """
        Number of hosts in the sub-block that have ongoing maintenance.
        """
        return pulumi.get(self, "maintenance_ongoing_count")

    @_builtins.property
    @pulumi.getter(name="maintenancePendingCount")
    def maintenance_pending_count(self) -> _builtins.int:
        """
        Number of hosts in the sub-block that have pending maintenance.
        """
        return pulumi.get(self, "maintenance_pending_count")

    @_builtins.property
    @pulumi.getter(name="schedulingType")
    def scheduling_type(self) -> _builtins.str:
        """
        The type of maintenance for the reservation.
        """
        return pulumi.get(self, "scheduling_type")

    @_builtins.property
    @pulumi.getter(name="subblockInfraMaintenanceOngoingCount")
    def subblock_infra_maintenance_ongoing_count(self) -> _builtins.int:
        """
        Number of sub-block infrastructure that has ongoing maintenance.
        """
        return pulumi.get(self, "subblock_infra_maintenance_ongoing_count")

    @_builtins.property
    @pulumi.getter(name="subblockInfraMaintenancePendingCount")
    def subblock_infra_maintenance_pending_count(self) -> _builtins.int:
        """
        Number of sub-block infrastructure that has pending maintenance.
        """
        return pulumi.get(self, "subblock_infra_maintenance_pending_count")


@pulumi.output_type
class GetResourcePolicyDiskConsistencyGroupPolicyResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Enable disk consistency on the resource policy.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable disk consistency on the resource policy.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetResourcePolicyGroupPlacementPolicyResult(dict):
    def __init__(__self__, *,
                 availability_domain_count: _builtins.int,
                 collocation: _builtins.str,
                 gpu_topology: _builtins.str,
                 max_distance: _builtins.int,
                 tpu_topology: _builtins.str,
                 vm_count: _builtins.int):
        """
        :param _builtins.int availability_domain_count: The number of availability domains instances will be spread across. If two instances are in different
               availability domain, they will not be put in the same low latency network
        :param _builtins.str collocation: Collocation specifies whether to place VMs inside the same availability domain on the same low-latency network.
               Specify 'COLLOCATED' to enable collocation. Can only be specified with 'vm_count'. If compute instances are created
               with a COLLOCATED policy, then exactly 'vm_count' instances must be created at the same time with the resource policy
               attached. Possible values: ["COLLOCATED"]
        :param _builtins.str gpu_topology: Specifies the shape of the GPU slice, in slice based GPU families eg. A4X.
        :param _builtins.int max_distance: Specifies the number of max logical switches.
        :param _builtins.str tpu_topology: Specifies the shape of the TPU slice.
        :param _builtins.int vm_count: Number of VMs in this placement group. Google does not recommend that you use this field
               unless you use a compact policy and you want your policy to work only if it contains this
               exact number of VMs.
        """
        pulumi.set(__self__, "availability_domain_count", availability_domain_count)
        pulumi.set(__self__, "collocation", collocation)
        pulumi.set(__self__, "gpu_topology", gpu_topology)
        pulumi.set(__self__, "max_distance", max_distance)
        pulumi.set(__self__, "tpu_topology", tpu_topology)
        pulumi.set(__self__, "vm_count", vm_count)

    @_builtins.property
    @pulumi.getter(name="availabilityDomainCount")
    def availability_domain_count(self) -> _builtins.int:
        """
        The number of availability domains instances will be spread across. If two instances are in different
        availability domain, they will not be put in the same low latency network
        """
        return pulumi.get(self, "availability_domain_count")

    @_builtins.property
    @pulumi.getter
    def collocation(self) -> _builtins.str:
        """
        Collocation specifies whether to place VMs inside the same availability domain on the same low-latency network.
        Specify 'COLLOCATED' to enable collocation. Can only be specified with 'vm_count'. If compute instances are created
        with a COLLOCATED policy, then exactly 'vm_count' instances must be created at the same time with the resource policy
        attached. Possible values: ["COLLOCATED"]
        """
        return pulumi.get(self, "collocation")

    @_builtins.property
    @pulumi.getter(name="gpuTopology")
    def gpu_topology(self) -> _builtins.str:
        """
        Specifies the shape of the GPU slice, in slice based GPU families eg. A4X.
        """
        return pulumi.get(self, "gpu_topology")

    @_builtins.property
    @pulumi.getter(name="maxDistance")
    def max_distance(self) -> _builtins.int:
        """
        Specifies the number of max logical switches.
        """
        return pulumi.get(self, "max_distance")

    @_builtins.property
    @pulumi.getter(name="tpuTopology")
    def tpu_topology(self) -> _builtins.str:
        """
        Specifies the shape of the TPU slice.
        """
        return pulumi.get(self, "tpu_topology")

    @_builtins.property
    @pulumi.getter(name="vmCount")
    def vm_count(self) -> _builtins.int:
        """
        Number of VMs in this placement group. Google does not recommend that you use this field
        unless you use a compact policy and you want your policy to work only if it contains this
        exact number of VMs.
        """
        return pulumi.get(self, "vm_count")


@pulumi.output_type
class GetResourcePolicyInstanceSchedulePolicyResult(dict):
    def __init__(__self__, *,
                 expiration_time: _builtins.str,
                 start_time: _builtins.str,
                 time_zone: _builtins.str,
                 vm_start_schedules: Sequence['outputs.GetResourcePolicyInstanceSchedulePolicyVmStartScheduleResult'],
                 vm_stop_schedules: Sequence['outputs.GetResourcePolicyInstanceSchedulePolicyVmStopScheduleResult']):
        """
        :param _builtins.str expiration_time: The expiration time of the schedule. The timestamp is an RFC3339 string.
        :param _builtins.str start_time: The start time of the schedule. The timestamp is an RFC3339 string.
        :param _builtins.str time_zone: Specifies the time zone to be used in interpreting the schedule. The value of this field must be a time zone name
               from the tz database: http://en.wikipedia.org/wiki/Tz_database.
        :param Sequence['GetResourcePolicyInstanceSchedulePolicyVmStartScheduleArgs'] vm_start_schedules: Specifies the schedule for starting instances.
        :param Sequence['GetResourcePolicyInstanceSchedulePolicyVmStopScheduleArgs'] vm_stop_schedules: Specifies the schedule for stopping instances.
        """
        pulumi.set(__self__, "expiration_time", expiration_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "vm_start_schedules", vm_start_schedules)
        pulumi.set(__self__, "vm_stop_schedules", vm_stop_schedules)

    @_builtins.property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> _builtins.str:
        """
        The expiration time of the schedule. The timestamp is an RFC3339 string.
        """
        return pulumi.get(self, "expiration_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time of the schedule. The timestamp is an RFC3339 string.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        Specifies the time zone to be used in interpreting the schedule. The value of this field must be a time zone name
        from the tz database: http://en.wikipedia.org/wiki/Tz_database.
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter(name="vmStartSchedules")
    def vm_start_schedules(self) -> Sequence['outputs.GetResourcePolicyInstanceSchedulePolicyVmStartScheduleResult']:
        """
        Specifies the schedule for starting instances.
        """
        return pulumi.get(self, "vm_start_schedules")

    @_builtins.property
    @pulumi.getter(name="vmStopSchedules")
    def vm_stop_schedules(self) -> Sequence['outputs.GetResourcePolicyInstanceSchedulePolicyVmStopScheduleResult']:
        """
        Specifies the schedule for stopping instances.
        """
        return pulumi.get(self, "vm_stop_schedules")


@pulumi.output_type
class GetResourcePolicyInstanceSchedulePolicyVmStartScheduleResult(dict):
    def __init__(__self__, *,
                 schedule: _builtins.str):
        """
        :param _builtins.str schedule: Specifies the frequency for the operation, using the unix-cron format.
        """
        pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> _builtins.str:
        """
        Specifies the frequency for the operation, using the unix-cron format.
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class GetResourcePolicyInstanceSchedulePolicyVmStopScheduleResult(dict):
    def __init__(__self__, *,
                 schedule: _builtins.str):
        """
        :param _builtins.str schedule: Specifies the frequency for the operation, using the unix-cron format.
        """
        pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> _builtins.str:
        """
        Specifies the frequency for the operation, using the unix-cron format.
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicyResult(dict):
    def __init__(__self__, *,
                 retention_policies: Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyRetentionPolicyResult'],
                 schedules: Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleResult'],
                 snapshot_properties: Sequence['outputs.GetResourcePolicySnapshotSchedulePolicySnapshotPropertyResult']):
        """
        :param Sequence['GetResourcePolicySnapshotSchedulePolicyRetentionPolicyArgs'] retention_policies: Retention policy applied to snapshots created by this resource policy.
        :param Sequence['GetResourcePolicySnapshotSchedulePolicyScheduleArgs'] schedules: Contains one of an 'hourlySchedule', 'dailySchedule', or 'weeklySchedule'.
        :param Sequence['GetResourcePolicySnapshotSchedulePolicySnapshotPropertyArgs'] snapshot_properties: Properties with which the snapshots are created, such as labels.
        """
        pulumi.set(__self__, "retention_policies", retention_policies)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "snapshot_properties", snapshot_properties)

    @_builtins.property
    @pulumi.getter(name="retentionPolicies")
    def retention_policies(self) -> Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyRetentionPolicyResult']:
        """
        Retention policy applied to snapshots created by this resource policy.
        """
        return pulumi.get(self, "retention_policies")

    @_builtins.property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleResult']:
        """
        Contains one of an 'hourlySchedule', 'dailySchedule', or 'weeklySchedule'.
        """
        return pulumi.get(self, "schedules")

    @_builtins.property
    @pulumi.getter(name="snapshotProperties")
    def snapshot_properties(self) -> Sequence['outputs.GetResourcePolicySnapshotSchedulePolicySnapshotPropertyResult']:
        """
        Properties with which the snapshots are created, such as labels.
        """
        return pulumi.get(self, "snapshot_properties")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicyRetentionPolicyResult(dict):
    def __init__(__self__, *,
                 max_retention_days: _builtins.int,
                 on_source_disk_delete: _builtins.str):
        """
        :param _builtins.int max_retention_days: Maximum age of the snapshot that is allowed to be kept.
        :param _builtins.str on_source_disk_delete: Specifies the behavior to apply to scheduled snapshots when
               the source disk is deleted. Default value: "KEEP_AUTO_SNAPSHOTS" Possible values: ["KEEP_AUTO_SNAPSHOTS", "APPLY_RETENTION_POLICY"]
        """
        pulumi.set(__self__, "max_retention_days", max_retention_days)
        pulumi.set(__self__, "on_source_disk_delete", on_source_disk_delete)

    @_builtins.property
    @pulumi.getter(name="maxRetentionDays")
    def max_retention_days(self) -> _builtins.int:
        """
        Maximum age of the snapshot that is allowed to be kept.
        """
        return pulumi.get(self, "max_retention_days")

    @_builtins.property
    @pulumi.getter(name="onSourceDiskDelete")
    def on_source_disk_delete(self) -> _builtins.str:
        """
        Specifies the behavior to apply to scheduled snapshots when
        the source disk is deleted. Default value: "KEEP_AUTO_SNAPSHOTS" Possible values: ["KEEP_AUTO_SNAPSHOTS", "APPLY_RETENTION_POLICY"]
        """
        return pulumi.get(self, "on_source_disk_delete")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicyScheduleResult(dict):
    def __init__(__self__, *,
                 daily_schedules: Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleResult'],
                 hourly_schedules: Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleResult'],
                 weekly_schedules: Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleResult']):
        """
        :param Sequence['GetResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleArgs'] daily_schedules: The policy will execute every nth day at the specified time.
        :param Sequence['GetResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleArgs'] hourly_schedules: The policy will execute every nth hour starting at the specified time.
        :param Sequence['GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleArgs'] weekly_schedules: Allows specifying a snapshot time for each day of the week.
        """
        pulumi.set(__self__, "daily_schedules", daily_schedules)
        pulumi.set(__self__, "hourly_schedules", hourly_schedules)
        pulumi.set(__self__, "weekly_schedules", weekly_schedules)

    @_builtins.property
    @pulumi.getter(name="dailySchedules")
    def daily_schedules(self) -> Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleResult']:
        """
        The policy will execute every nth day at the specified time.
        """
        return pulumi.get(self, "daily_schedules")

    @_builtins.property
    @pulumi.getter(name="hourlySchedules")
    def hourly_schedules(self) -> Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleResult']:
        """
        The policy will execute every nth hour starting at the specified time.
        """
        return pulumi.get(self, "hourly_schedules")

    @_builtins.property
    @pulumi.getter(name="weeklySchedules")
    def weekly_schedules(self) -> Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleResult']:
        """
        Allows specifying a snapshot time for each day of the week.
        """
        return pulumi.get(self, "weekly_schedules")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicyScheduleDailyScheduleResult(dict):
    def __init__(__self__, *,
                 days_in_cycle: _builtins.int,
                 start_time: _builtins.str):
        """
        :param _builtins.int days_in_cycle: Defines a schedule with units measured in days. The value determines how many days pass between the start of each cycle. Days in cycle for snapshot schedule policy must be 1.
        :param _builtins.str start_time: This must be in UTC format that resolves to one of
               00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example,
               both 13:00-5 and 08:00 are valid.
        """
        pulumi.set(__self__, "days_in_cycle", days_in_cycle)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="daysInCycle")
    def days_in_cycle(self) -> _builtins.int:
        """
        Defines a schedule with units measured in days. The value determines how many days pass between the start of each cycle. Days in cycle for snapshot schedule policy must be 1.
        """
        return pulumi.get(self, "days_in_cycle")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        This must be in UTC format that resolves to one of
        00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example,
        both 13:00-5 and 08:00 are valid.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicyScheduleHourlyScheduleResult(dict):
    def __init__(__self__, *,
                 hours_in_cycle: _builtins.int,
                 start_time: _builtins.str):
        """
        :param _builtins.int hours_in_cycle: The number of hours between snapshots.
        :param _builtins.str start_time: Time within the window to start the operations.
               It must be in an hourly format "HH:MM",
               where HH : [00-23] and MM : [00] GMT. eg: 21:00
        """
        pulumi.set(__self__, "hours_in_cycle", hours_in_cycle)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="hoursInCycle")
    def hours_in_cycle(self) -> _builtins.int:
        """
        The number of hours between snapshots.
        """
        return pulumi.get(self, "hours_in_cycle")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Time within the window to start the operations.
        It must be in an hourly format "HH:MM",
        where HH : [00-23] and MM : [00] GMT. eg: 21:00
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleResult(dict):
    def __init__(__self__, *,
                 day_of_weeks: Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekResult']):
        """
        :param Sequence['GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekArgs'] day_of_weeks: May contain up to seven (one for each day of the week) snapshot times.
        """
        pulumi.set(__self__, "day_of_weeks", day_of_weeks)

    @_builtins.property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> Sequence['outputs.GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekResult']:
        """
        May contain up to seven (one for each day of the week) snapshot times.
        """
        return pulumi.get(self, "day_of_weeks")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeekResult(dict):
    def __init__(__self__, *,
                 day: _builtins.str,
                 start_time: _builtins.str):
        """
        :param _builtins.str day: The day of the week to create the snapshot. e.g. MONDAY Possible values: ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]
        :param _builtins.str start_time: Time within the window to start the operations.
               It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def day(self) -> _builtins.str:
        """
        The day of the week to create the snapshot. e.g. MONDAY Possible values: ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Time within the window to start the operations.
        It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetResourcePolicySnapshotSchedulePolicySnapshotPropertyResult(dict):
    def __init__(__self__, *,
                 chain_name: _builtins.str,
                 guest_flush: _builtins.bool,
                 labels: Mapping[str, _builtins.str],
                 storage_locations: Sequence[_builtins.str]):
        """
        :param _builtins.str chain_name: Creates the new snapshot in the snapshot chain labeled with the
               specified name. The chain name must be 1-63 characters long and comply
               with RFC1035.
        :param _builtins.bool guest_flush: Whether to perform a 'guest aware' snapshot.
        :param Mapping[str, _builtins.str] labels: A set of key-value pairs.
        :param Sequence[_builtins.str] storage_locations: Cloud Storage bucket location to store the auto snapshot
               (regional or multi-regional)
        """
        pulumi.set(__self__, "chain_name", chain_name)
        pulumi.set(__self__, "guest_flush", guest_flush)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "storage_locations", storage_locations)

    @_builtins.property
    @pulumi.getter(name="chainName")
    def chain_name(self) -> _builtins.str:
        """
        Creates the new snapshot in the snapshot chain labeled with the
        specified name. The chain name must be 1-63 characters long and comply
        with RFC1035.
        """
        return pulumi.get(self, "chain_name")

    @_builtins.property
    @pulumi.getter(name="guestFlush")
    def guest_flush(self) -> _builtins.bool:
        """
        Whether to perform a 'guest aware' snapshot.
        """
        return pulumi.get(self, "guest_flush")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        A set of key-value pairs.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="storageLocations")
    def storage_locations(self) -> Sequence[_builtins.str]:
        """
        Cloud Storage bucket location to store the auto snapshot
        (regional or multi-regional)
        """
        return pulumi.get(self, "storage_locations")


@pulumi.output_type
class GetResourcePolicyWorkloadPolicyResult(dict):
    def __init__(__self__, *,
                 accelerator_topology: _builtins.str,
                 max_topology_distance: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str accelerator_topology: The accelerator topology. This field can be set only when the workload policy type is HIGH_THROUGHPUT
               and cannot be set if max topology distance is set.
        :param _builtins.str max_topology_distance: The maximum topology distance. This field can be set only when the workload policy type is HIGH_THROUGHPUT
               and cannot be set if accelerator topology is set. Possible values: ["BLOCK", "CLUSTER", "SUBBLOCK"]
        :param _builtins.str type: The type of workload policy. Possible values: ["HIGH_AVAILABILITY", "HIGH_THROUGHPUT"]
        """
        pulumi.set(__self__, "accelerator_topology", accelerator_topology)
        pulumi.set(__self__, "max_topology_distance", max_topology_distance)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="acceleratorTopology")
    def accelerator_topology(self) -> _builtins.str:
        """
        The accelerator topology. This field can be set only when the workload policy type is HIGH_THROUGHPUT
        and cannot be set if max topology distance is set.
        """
        return pulumi.get(self, "accelerator_topology")

    @_builtins.property
    @pulumi.getter(name="maxTopologyDistance")
    def max_topology_distance(self) -> _builtins.str:
        """
        The maximum topology distance. This field can be set only when the workload policy type is HIGH_THROUGHPUT
        and cannot be set if accelerator topology is set. Possible values: ["BLOCK", "CLUSTER", "SUBBLOCK"]
        """
        return pulumi.get(self, "max_topology_distance")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of workload policy. Possible values: ["HIGH_AVAILABILITY", "HIGH_THROUGHPUT"]
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRouterBgpResult(dict):
    def __init__(__self__, *,
                 advertise_mode: _builtins.str,
                 advertised_groups: Sequence[_builtins.str],
                 advertised_ip_ranges: Sequence['outputs.GetRouterBgpAdvertisedIpRangeResult'],
                 asn: _builtins.int,
                 identifier_range: _builtins.str,
                 keepalive_interval: _builtins.int):
        """
        :param _builtins.str advertise_mode: User-specified flag to indicate which mode to use for advertisement. Default value: "DEFAULT" Possible values: ["DEFAULT", "CUSTOM"]
        :param Sequence[_builtins.str] advertised_groups: User-specified list of prefix groups to advertise in custom mode.
               This field can only be populated if advertiseMode is CUSTOM and
               is advertised to all peers of the router. These groups will be
               advertised in addition to any specified prefixes. Leave this field
               blank to advertise no custom groups.
               
               This enum field has the one valid value: ALL_SUBNETS
        :param Sequence['GetRouterBgpAdvertisedIpRangeArgs'] advertised_ip_ranges: User-specified list of individual IP ranges to advertise in
               custom mode. This field can only be populated if advertiseMode
               is CUSTOM and is advertised to all peers of the router. These IP
               ranges will be advertised in addition to any specified groups.
               Leave this field blank to advertise no custom IP ranges.
        :param _builtins.int asn: Local BGP Autonomous System Number (ASN). Must be an RFC6996
               private ASN, either 16-bit or 32-bit. The value will be fixed for
               this router resource. All VPN tunnels that link to this router
               will have the same local ASN.
        :param _builtins.str identifier_range: Explicitly specifies a range of valid BGP Identifiers for this Router.
               It is provided as a link-local IPv4 range (from 169.254.0.0/16), of
               size at least /30, even if the BGP sessions are over IPv6. It must
               not overlap with any IPv4 BGP session ranges. Other vendors commonly
               call this router ID.
        :param _builtins.int keepalive_interval: The interval in seconds between BGP keepalive messages that are sent
               to the peer. Hold time is three times the interval at which keepalive
               messages are sent, and the hold time is the maximum number of seconds
               allowed to elapse between successive keepalive messages that BGP
               receives from a peer.
               
               BGP will use the smaller of either the local hold time value or the
               peer's hold time value as the hold time for the BGP connection
               between the two peers. If set, this value must be between 20 and 60.
               The default is 20.
        """
        pulumi.set(__self__, "advertise_mode", advertise_mode)
        pulumi.set(__self__, "advertised_groups", advertised_groups)
        pulumi.set(__self__, "advertised_ip_ranges", advertised_ip_ranges)
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "identifier_range", identifier_range)
        pulumi.set(__self__, "keepalive_interval", keepalive_interval)

    @_builtins.property
    @pulumi.getter(name="advertiseMode")
    def advertise_mode(self) -> _builtins.str:
        """
        User-specified flag to indicate which mode to use for advertisement. Default value: "DEFAULT" Possible values: ["DEFAULT", "CUSTOM"]
        """
        return pulumi.get(self, "advertise_mode")

    @_builtins.property
    @pulumi.getter(name="advertisedGroups")
    def advertised_groups(self) -> Sequence[_builtins.str]:
        """
        User-specified list of prefix groups to advertise in custom mode.
        This field can only be populated if advertiseMode is CUSTOM and
        is advertised to all peers of the router. These groups will be
        advertised in addition to any specified prefixes. Leave this field
        blank to advertise no custom groups.

        This enum field has the one valid value: ALL_SUBNETS
        """
        return pulumi.get(self, "advertised_groups")

    @_builtins.property
    @pulumi.getter(name="advertisedIpRanges")
    def advertised_ip_ranges(self) -> Sequence['outputs.GetRouterBgpAdvertisedIpRangeResult']:
        """
        User-specified list of individual IP ranges to advertise in
        custom mode. This field can only be populated if advertiseMode
        is CUSTOM and is advertised to all peers of the router. These IP
        ranges will be advertised in addition to any specified groups.
        Leave this field blank to advertise no custom IP ranges.
        """
        return pulumi.get(self, "advertised_ip_ranges")

    @_builtins.property
    @pulumi.getter
    def asn(self) -> _builtins.int:
        """
        Local BGP Autonomous System Number (ASN). Must be an RFC6996
        private ASN, either 16-bit or 32-bit. The value will be fixed for
        this router resource. All VPN tunnels that link to this router
        will have the same local ASN.
        """
        return pulumi.get(self, "asn")

    @_builtins.property
    @pulumi.getter(name="identifierRange")
    def identifier_range(self) -> _builtins.str:
        """
        Explicitly specifies a range of valid BGP Identifiers for this Router.
        It is provided as a link-local IPv4 range (from 169.254.0.0/16), of
        size at least /30, even if the BGP sessions are over IPv6. It must
        not overlap with any IPv4 BGP session ranges. Other vendors commonly
        call this router ID.
        """
        return pulumi.get(self, "identifier_range")

    @_builtins.property
    @pulumi.getter(name="keepaliveInterval")
    def keepalive_interval(self) -> _builtins.int:
        """
        The interval in seconds between BGP keepalive messages that are sent
        to the peer. Hold time is three times the interval at which keepalive
        messages are sent, and the hold time is the maximum number of seconds
        allowed to elapse between successive keepalive messages that BGP
        receives from a peer.

        BGP will use the smaller of either the local hold time value or the
        peer's hold time value as the hold time for the BGP connection
        between the two peers. If set, this value must be between 20 and 60.
        The default is 20.
        """
        return pulumi.get(self, "keepalive_interval")


@pulumi.output_type
class GetRouterBgpAdvertisedIpRangeResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 range: _builtins.str):
        """
        :param _builtins.str description: User-specified description for the IP range.
        :param _builtins.str range: The IP range to advertise. The value must be a
               CIDR-formatted string.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "range", range)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        User-specified description for the IP range.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def range(self) -> _builtins.str:
        """
        The IP range to advertise. The value must be a
        CIDR-formatted string.
        """
        return pulumi.get(self, "range")


@pulumi.output_type
class GetRouterMd5AuthenticationKeyResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str key: Value of the key used for MD5 authentication.
        :param _builtins.str name: The name of the router.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Value of the key used for MD5 authentication.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the router.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRouterNatLogConfigResult(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool,
                 filter: _builtins.str):
        """
        :param _builtins.bool enable: Indicates whether or not to export logs.
        :param _builtins.str filter: Specifies the desired filtering of logs on this NAT. Possible values: ["ERRORS_ONLY", "TRANSLATIONS_ONLY", "ALL"]
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Indicates whether or not to export logs.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> _builtins.str:
        """
        Specifies the desired filtering of logs on this NAT. Possible values: ["ERRORS_ONLY", "TRANSLATIONS_ONLY", "ALL"]
        """
        return pulumi.get(self, "filter")


@pulumi.output_type
class GetRouterNatNat64SubnetworkResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the NAT service. The name must be 1-63 characters long and
               comply with RFC1035.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the NAT service. The name must be 1-63 characters long and
        comply with RFC1035.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRouterNatRuleResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetRouterNatRuleActionResult'],
                 description: _builtins.str,
                 match: _builtins.str,
                 rule_number: _builtins.int):
        """
        :param Sequence['GetRouterNatRuleActionArgs'] actions: The action to be enforced for traffic that matches this rule.
        :param _builtins.str description: An optional description of this rule.
        :param _builtins.str match: CEL expression that specifies the match condition that egress traffic from a VM is evaluated against.
               If it evaluates to true, the corresponding action is enforced.
               
               The following examples are valid match expressions for public NAT:
               
               "inIpRange(destination.ip, '1.1.0.0/16') || inIpRange(destination.ip, '2.2.0.0/16')"
               
               "destination.ip == '1.1.0.1' || destination.ip == '8.8.8.8'"
               
               The following example is a valid match expression for private NAT:
               
               "nexthop.hub == 'https://networkconnectivity.googleapis.com/v1alpha1/projects/my-project/global/hub/hub-1'"
        :param _builtins.int rule_number: An integer uniquely identifying a rule in the list.
               The rule number must be a positive value between 0 and 65000, and must be unique among rules within a NAT.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetRouterNatRuleActionResult']:
        """
        The action to be enforced for traffic that matches this rule.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        An optional description of this rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        CEL expression that specifies the match condition that egress traffic from a VM is evaluated against.
        If it evaluates to true, the corresponding action is enforced.

        The following examples are valid match expressions for public NAT:

        "inIpRange(destination.ip, '1.1.0.0/16') || inIpRange(destination.ip, '2.2.0.0/16')"

        "destination.ip == '1.1.0.1' || destination.ip == '8.8.8.8'"

        The following example is a valid match expression for private NAT:

        "nexthop.hub == 'https://networkconnectivity.googleapis.com/v1alpha1/projects/my-project/global/hub/hub-1'"
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> _builtins.int:
        """
        An integer uniquely identifying a rule in the list.
        The rule number must be a positive value between 0 and 65000, and must be unique among rules within a NAT.
        """
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class GetRouterNatRuleActionResult(dict):
    def __init__(__self__, *,
                 source_nat_active_ips: Sequence[_builtins.str],
                 source_nat_active_ranges: Sequence[_builtins.str],
                 source_nat_drain_ips: Sequence[_builtins.str],
                 source_nat_drain_ranges: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] source_nat_active_ips: A list of URLs of the IP resources used for this NAT rule.
               These IP addresses must be valid static external IP addresses assigned to the project.
               This field is used for public NAT.
        :param Sequence[_builtins.str] source_nat_active_ranges: A list of URLs of the subnetworks used as source ranges for this NAT Rule.
               These subnetworks must have purpose set to PRIVATE_NAT.
               This field is used for private NAT.
        :param Sequence[_builtins.str] source_nat_drain_ips: A list of URLs of the IP resources to be drained.
               These IPs must be valid static external IPs that have been assigned to the NAT.
               These IPs should be used for updating/patching a NAT rule only.
               This field is used for public NAT.
        :param Sequence[_builtins.str] source_nat_drain_ranges: A list of URLs of subnetworks representing source ranges to be drained.
               This is only supported on patch/update, and these subnetworks must have previously been used as active ranges in this NAT Rule.
               This field is used for private NAT.
        """
        pulumi.set(__self__, "source_nat_active_ips", source_nat_active_ips)
        pulumi.set(__self__, "source_nat_active_ranges", source_nat_active_ranges)
        pulumi.set(__self__, "source_nat_drain_ips", source_nat_drain_ips)
        pulumi.set(__self__, "source_nat_drain_ranges", source_nat_drain_ranges)

    @_builtins.property
    @pulumi.getter(name="sourceNatActiveIps")
    def source_nat_active_ips(self) -> Sequence[_builtins.str]:
        """
        A list of URLs of the IP resources used for this NAT rule.
        These IP addresses must be valid static external IP addresses assigned to the project.
        This field is used for public NAT.
        """
        return pulumi.get(self, "source_nat_active_ips")

    @_builtins.property
    @pulumi.getter(name="sourceNatActiveRanges")
    def source_nat_active_ranges(self) -> Sequence[_builtins.str]:
        """
        A list of URLs of the subnetworks used as source ranges for this NAT Rule.
        These subnetworks must have purpose set to PRIVATE_NAT.
        This field is used for private NAT.
        """
        return pulumi.get(self, "source_nat_active_ranges")

    @_builtins.property
    @pulumi.getter(name="sourceNatDrainIps")
    def source_nat_drain_ips(self) -> Sequence[_builtins.str]:
        """
        A list of URLs of the IP resources to be drained.
        These IPs must be valid static external IPs that have been assigned to the NAT.
        These IPs should be used for updating/patching a NAT rule only.
        This field is used for public NAT.
        """
        return pulumi.get(self, "source_nat_drain_ips")

    @_builtins.property
    @pulumi.getter(name="sourceNatDrainRanges")
    def source_nat_drain_ranges(self) -> Sequence[_builtins.str]:
        """
        A list of URLs of subnetworks representing source ranges to be drained.
        This is only supported on patch/update, and these subnetworks must have previously been used as active ranges in this NAT Rule.
        This field is used for private NAT.
        """
        return pulumi.get(self, "source_nat_drain_ranges")


@pulumi.output_type
class GetRouterNatSubnetworkResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 secondary_ip_range_names: Sequence[_builtins.str],
                 source_ip_ranges_to_nats: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the NAT service. The name must be 1-63 characters long and
               comply with RFC1035.
        :param Sequence[_builtins.str] secondary_ip_range_names: List of the secondary ranges of the subnetwork that are allowed
               to use NAT. This can be populated only if
               'LIST_OF_SECONDARY_IP_RANGES' is one of the values in
               sourceIpRangesToNat
        :param Sequence[_builtins.str] source_ip_ranges_to_nats: List of options for which source IPs in the subnetwork
               should have NAT enabled. Supported values include:
               'ALL_IP_RANGES', 'LIST_OF_SECONDARY_IP_RANGES',
               'PRIMARY_IP_RANGE'.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secondary_ip_range_names", secondary_ip_range_names)
        pulumi.set(__self__, "source_ip_ranges_to_nats", source_ip_ranges_to_nats)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the NAT service. The name must be 1-63 characters long and
        comply with RFC1035.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secondaryIpRangeNames")
    def secondary_ip_range_names(self) -> Sequence[_builtins.str]:
        """
        List of the secondary ranges of the subnetwork that are allowed
        to use NAT. This can be populated only if
        'LIST_OF_SECONDARY_IP_RANGES' is one of the values in
        sourceIpRangesToNat
        """
        return pulumi.get(self, "secondary_ip_range_names")

    @_builtins.property
    @pulumi.getter(name="sourceIpRangesToNats")
    def source_ip_ranges_to_nats(self) -> Sequence[_builtins.str]:
        """
        List of options for which source IPs in the subnetwork
        should have NAT enabled. Supported values include:
        'ALL_IP_RANGES', 'LIST_OF_SECONDARY_IP_RANGES',
        'PRIMARY_IP_RANGE'.
        """
        return pulumi.get(self, "source_ip_ranges_to_nats")


@pulumi.output_type
class GetRouterParamResult(dict):
    def __init__(__self__, *,
                 resource_manager_tags: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the router. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456.
        """
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        Resource manager tags to be bound to the router. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class GetRouterStatusBestRouteResult(dict):
    def __init__(__self__, *,
                 as_paths: Sequence['outputs.GetRouterStatusBestRouteAsPathResult'],
                 creation_timestamp: _builtins.str,
                 description: _builtins.str,
                 dest_range: _builtins.str,
                 name: _builtins.str,
                 network: _builtins.str,
                 next_hop_gateway: _builtins.str,
                 next_hop_hub: _builtins.str,
                 next_hop_ilb: _builtins.str,
                 next_hop_instance: _builtins.str,
                 next_hop_instance_zone: _builtins.str,
                 next_hop_inter_region_cost: _builtins.str,
                 next_hop_ip: _builtins.str,
                 next_hop_med: _builtins.str,
                 next_hop_network: _builtins.str,
                 next_hop_origin: _builtins.str,
                 next_hop_peering: _builtins.str,
                 next_hop_vpn_tunnel: _builtins.str,
                 params: Sequence['outputs.GetRouterStatusBestRouteParamResult'],
                 priority: _builtins.int,
                 project: _builtins.str,
                 route_status: _builtins.str,
                 route_type: _builtins.str,
                 self_link: _builtins.str,
                 tags: Sequence[_builtins.str],
                 warnings: Sequence['outputs.GetRouterStatusBestRouteWarningResult']):
        """
        :param _builtins.str creation_timestamp: Creation timestamp in RFC3339 text format.
        :param _builtins.str description: An optional description of this resource. Provide this property
               when you create the resource.
        :param _builtins.str dest_range: The destination range of outgoing packets that this route applies to.
               Only IPv4 is supported.
        :param _builtins.str name: The name of the router.
        :param _builtins.str network: The network name or resource link to the parent
               network of this subnetwork.
        :param _builtins.str next_hop_gateway: URL to a gateway that should handle matching packets.
               Currently, you can only specify the internet gateway, using a full or
               partial valid URL:
               * 'https://www.googleapis.com/compute/v1/projects/project/global/gateways/default-internet-gateway'
               * 'projects/project/global/gateways/default-internet-gateway'
               * 'global/gateways/default-internet-gateway'
               * The string 'default-internet-gateway'.
        :param _builtins.str next_hop_hub: The hub network that should handle matching packets, which should conform to RFC1035.
        :param _builtins.str next_hop_ilb: The IP address or URL to a forwarding rule of type
               loadBalancingScheme=INTERNAL that should handle matching
               packets.
               
               With the GA provider you can only specify the forwarding
               rule as a partial or full URL. For example, the following
               are all valid values:
               * 10.128.0.56
               * https://www.googleapis.com/compute/v1/projects/project/regions/region/forwardingRules/forwardingRule
               * regions/region/forwardingRules/forwardingRule
               
               When the beta provider, you can also specify the IP address
               of a forwarding rule from the same VPC or any peered VPC.
               
               Note that this can only be used when the destinationRange is
               a public (non-RFC 1918) IP CIDR range.
        :param _builtins.str next_hop_instance: URL to an instance that should handle matching packets.
               You can specify this as a full or partial URL. For example:
               * 'https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance'
               * 'projects/project/zones/zone/instances/instance'
               * 'zones/zone/instances/instance'
               * Just the instance name, with the zone in 'next_hop_instance_zone'.
        :param _builtins.str next_hop_instance_zone: The zone of the instance specified in next_hop_instance. Omit if next_hop_instance is specified as a URL.
        :param _builtins.str next_hop_inter_region_cost: Internal fixed region-to-region cost that Google Cloud calculates based on factors such as network performance, distance, and available bandwidth between regions.
        :param _builtins.str next_hop_ip: Network IP address of an instance that should handle matching packets.
        :param _builtins.str next_hop_med: Multi-Exit Discriminator, a BGP route metric that indicates the desirability of a particular route in a network.
        :param _builtins.str next_hop_network: URL to a Network that should handle matching packets.
        :param _builtins.str next_hop_origin: Indicates the origin of the route. Can be IGP (Interior Gateway Protocol), EGP (Exterior Gateway Protocol), or INCOMPLETE.
        :param _builtins.str next_hop_peering: The network peering name that should handle matching packets, which should conform to RFC1035.
        :param _builtins.str next_hop_vpn_tunnel: URL to a VpnTunnel that should handle matching packets.
        :param Sequence['GetRouterStatusBestRouteParamArgs'] params: Additional params passed with the request, but not persisted as part of resource payload
        :param _builtins.int priority: The priority of this route. Priority is used to break ties in cases
               where there is more than one matching route of equal prefix length.
               
               In the case of two routes with equal prefix length, the one with the
               lowest-numbered priority value wins.
               
               Default value is 1000. Valid range is 0 through 65535.
        :param _builtins.str project: The ID of the project in which the resource
               belongs. If it is not provided, the provider project is used.
        :param _builtins.str route_status: The status of the route, which can be one of the following values:
               - 'ACTIVE' for an active route
               - 'INACTIVE' for an inactive route
        :param _builtins.str route_type: The type of this route, which can be one of the following values:
               - 'TRANSIT' for a transit route that this router learned from another Cloud Router and will readvertise to one of its BGP peers
               - 'SUBNET' for a route from a subnet of the VPC
               - 'BGP' for a route learned from a BGP peer of this router
               - 'STATIC' for a static route
        :param Sequence[_builtins.str] tags: A list of instance tags to which this route applies.
        :param Sequence['GetRouterStatusBestRouteWarningArgs'] warnings: If potential misconfigurations are detected for this route, this field will be populated with warning messages.
        """
        pulumi.set(__self__, "as_paths", as_paths)
        pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dest_range", dest_range)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "next_hop_gateway", next_hop_gateway)
        pulumi.set(__self__, "next_hop_hub", next_hop_hub)
        pulumi.set(__self__, "next_hop_ilb", next_hop_ilb)
        pulumi.set(__self__, "next_hop_instance", next_hop_instance)
        pulumi.set(__self__, "next_hop_instance_zone", next_hop_instance_zone)
        pulumi.set(__self__, "next_hop_inter_region_cost", next_hop_inter_region_cost)
        pulumi.set(__self__, "next_hop_ip", next_hop_ip)
        pulumi.set(__self__, "next_hop_med", next_hop_med)
        pulumi.set(__self__, "next_hop_network", next_hop_network)
        pulumi.set(__self__, "next_hop_origin", next_hop_origin)
        pulumi.set(__self__, "next_hop_peering", next_hop_peering)
        pulumi.set(__self__, "next_hop_vpn_tunnel", next_hop_vpn_tunnel)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "route_status", route_status)
        pulumi.set(__self__, "route_type", route_type)
        pulumi.set(__self__, "self_link", self_link)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "warnings", warnings)

    @_builtins.property
    @pulumi.getter(name="asPaths")
    def as_paths(self) -> Sequence['outputs.GetRouterStatusBestRouteAsPathResult']:
        return pulumi.get(self, "as_paths")

    @_builtins.property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> _builtins.str:
        """
        Creation timestamp in RFC3339 text format.
        """
        return pulumi.get(self, "creation_timestamp")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        An optional description of this resource. Provide this property
        when you create the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="destRange")
    def dest_range(self) -> _builtins.str:
        """
        The destination range of outgoing packets that this route applies to.
        Only IPv4 is supported.
        """
        return pulumi.get(self, "dest_range")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the router.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The network name or resource link to the parent
        network of this subnetwork.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="nextHopGateway")
    def next_hop_gateway(self) -> _builtins.str:
        """
        URL to a gateway that should handle matching packets.
        Currently, you can only specify the internet gateway, using a full or
        partial valid URL:
        * 'https://www.googleapis.com/compute/v1/projects/project/global/gateways/default-internet-gateway'
        * 'projects/project/global/gateways/default-internet-gateway'
        * 'global/gateways/default-internet-gateway'
        * The string 'default-internet-gateway'.
        """
        return pulumi.get(self, "next_hop_gateway")

    @_builtins.property
    @pulumi.getter(name="nextHopHub")
    def next_hop_hub(self) -> _builtins.str:
        """
        The hub network that should handle matching packets, which should conform to RFC1035.
        """
        return pulumi.get(self, "next_hop_hub")

    @_builtins.property
    @pulumi.getter(name="nextHopIlb")
    def next_hop_ilb(self) -> _builtins.str:
        """
        The IP address or URL to a forwarding rule of type
        loadBalancingScheme=INTERNAL that should handle matching
        packets.

        With the GA provider you can only specify the forwarding
        rule as a partial or full URL. For example, the following
        are all valid values:
        * 10.128.0.56
        * https://www.googleapis.com/compute/v1/projects/project/regions/region/forwardingRules/forwardingRule
        * regions/region/forwardingRules/forwardingRule

        When the beta provider, you can also specify the IP address
        of a forwarding rule from the same VPC or any peered VPC.

        Note that this can only be used when the destinationRange is
        a public (non-RFC 1918) IP CIDR range.
        """
        return pulumi.get(self, "next_hop_ilb")

    @_builtins.property
    @pulumi.getter(name="nextHopInstance")
    def next_hop_instance(self) -> _builtins.str:
        """
        URL to an instance that should handle matching packets.
        You can specify this as a full or partial URL. For example:
        * 'https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance'
        * 'projects/project/zones/zone/instances/instance'
        * 'zones/zone/instances/instance'
        * Just the instance name, with the zone in 'next_hop_instance_zone'.
        """
        return pulumi.get(self, "next_hop_instance")

    @_builtins.property
    @pulumi.getter(name="nextHopInstanceZone")
    def next_hop_instance_zone(self) -> _builtins.str:
        """
        The zone of the instance specified in next_hop_instance. Omit if next_hop_instance is specified as a URL.
        """
        return pulumi.get(self, "next_hop_instance_zone")

    @_builtins.property
    @pulumi.getter(name="nextHopInterRegionCost")
    def next_hop_inter_region_cost(self) -> _builtins.str:
        """
        Internal fixed region-to-region cost that Google Cloud calculates based on factors such as network performance, distance, and available bandwidth between regions.
        """
        return pulumi.get(self, "next_hop_inter_region_cost")

    @_builtins.property
    @pulumi.getter(name="nextHopIp")
    def next_hop_ip(self) -> _builtins.str:
        """
        Network IP address of an instance that should handle matching packets.
        """
        return pulumi.get(self, "next_hop_ip")

    @_builtins.property
    @pulumi.getter(name="nextHopMed")
    def next_hop_med(self) -> _builtins.str:
        """
        Multi-Exit Discriminator, a BGP route metric that indicates the desirability of a particular route in a network.
        """
        return pulumi.get(self, "next_hop_med")

    @_builtins.property
    @pulumi.getter(name="nextHopNetwork")
    def next_hop_network(self) -> _builtins.str:
        """
        URL to a Network that should handle matching packets.
        """
        return pulumi.get(self, "next_hop_network")

    @_builtins.property
    @pulumi.getter(name="nextHopOrigin")
    def next_hop_origin(self) -> _builtins.str:
        """
        Indicates the origin of the route. Can be IGP (Interior Gateway Protocol), EGP (Exterior Gateway Protocol), or INCOMPLETE.
        """
        return pulumi.get(self, "next_hop_origin")

    @_builtins.property
    @pulumi.getter(name="nextHopPeering")
    def next_hop_peering(self) -> _builtins.str:
        """
        The network peering name that should handle matching packets, which should conform to RFC1035.
        """
        return pulumi.get(self, "next_hop_peering")

    @_builtins.property
    @pulumi.getter(name="nextHopVpnTunnel")
    def next_hop_vpn_tunnel(self) -> _builtins.str:
        """
        URL to a VpnTunnel that should handle matching packets.
        """
        return pulumi.get(self, "next_hop_vpn_tunnel")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Sequence['outputs.GetRouterStatusBestRouteParamResult']:
        """
        Additional params passed with the request, but not persisted as part of resource payload
        """
        return pulumi.get(self, "params")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        The priority of this route. Priority is used to break ties in cases
        where there is more than one matching route of equal prefix length.

        In the case of two routes with equal prefix length, the one with the
        lowest-numbered priority value wins.

        Default value is 1000. Valid range is 0 through 65535.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        The ID of the project in which the resource
        belongs. If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter(name="routeStatus")
    def route_status(self) -> _builtins.str:
        """
        The status of the route, which can be one of the following values:
        - 'ACTIVE' for an active route
        - 'INACTIVE' for an inactive route
        """
        return pulumi.get(self, "route_status")

    @_builtins.property
    @pulumi.getter(name="routeType")
    def route_type(self) -> _builtins.str:
        """
        The type of this route, which can be one of the following values:
        - 'TRANSIT' for a transit route that this router learned from another Cloud Router and will readvertise to one of its BGP peers
        - 'SUBNET' for a route from a subnet of the VPC
        - 'BGP' for a route learned from a BGP peer of this router
        - 'STATIC' for a static route
        """
        return pulumi.get(self, "route_type")

    @_builtins.property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> _builtins.str:
        return pulumi.get(self, "self_link")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        A list of instance tags to which this route applies.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def warnings(self) -> Sequence['outputs.GetRouterStatusBestRouteWarningResult']:
        """
        If potential misconfigurations are detected for this route, this field will be populated with warning messages.
        """
        return pulumi.get(self, "warnings")


@pulumi.output_type
class GetRouterStatusBestRouteAsPathResult(dict):
    def __init__(__self__, *,
                 as_lists: Sequence[_builtins.int],
                 path_segment_type: _builtins.str):
        """
        :param Sequence[_builtins.int] as_lists: The AS numbers of the AS Path.
        :param _builtins.str path_segment_type: The type of the AS Path, which can be one of the following values:
               - 'AS_SET': unordered set of autonomous systems that the route in has traversed
               - 'AS_SEQUENCE': ordered set of autonomous systems that the route has traversed
               - 'AS_CONFED_SEQUENCE': ordered set of Member Autonomous Systems in the local confederation that the route has traversed
               - 'AS_CONFED_SET': unordered set of Member Autonomous Systems in the local confederation that the route has traversed
        """
        pulumi.set(__self__, "as_lists", as_lists)
        pulumi.set(__self__, "path_segment_type", path_segment_type)

    @_builtins.property
    @pulumi.getter(name="asLists")
    def as_lists(self) -> Sequence[_builtins.int]:
        """
        The AS numbers of the AS Path.
        """
        return pulumi.get(self, "as_lists")

    @_builtins.property
    @pulumi.getter(name="pathSegmentType")
    def path_segment_type(self) -> _builtins.str:
        """
        The type of the AS Path, which can be one of the following values:
        - 'AS_SET': unordered set of autonomous systems that the route in has traversed
        - 'AS_SEQUENCE': ordered set of autonomous systems that the route has traversed
        - 'AS_CONFED_SEQUENCE': ordered set of Member Autonomous Systems in the local confederation that the route has traversed
        - 'AS_CONFED_SET': unordered set of Member Autonomous Systems in the local confederation that the route has traversed
        """
        return pulumi.get(self, "path_segment_type")


@pulumi.output_type
class GetRouterStatusBestRouteParamResult(dict):
    def __init__(__self__, *,
                 resource_manager_tags: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the route. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456. The field is ignored when empty.
               The field is immutable and causes resource replacement when mutated. This field is only
               set at create time and modifying this field after creation will trigger recreation.
               To apply tags to an existing resource, see the tags.TagBinding resource.
        """
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        Resource manager tags to be bound to the route. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456. The field is ignored when empty.
        The field is immutable and causes resource replacement when mutated. This field is only
        set at create time and modifying this field after creation will trigger recreation.
        To apply tags to an existing resource, see the tags.TagBinding resource.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class GetRouterStatusBestRouteWarningResult(dict):
    def __init__(__self__, *,
                 code: _builtins.str,
                 datas: Sequence['outputs.GetRouterStatusBestRouteWarningDataResult'],
                 message: _builtins.str):
        """
        :param _builtins.str code: A warning code, if applicable. For example, Compute Engine returns
               NO_RESULTS_ON_PAGE if there are no results in the response.
        :param Sequence['GetRouterStatusBestRouteWarningDataArgs'] datas: Metadata about this warning in key: value format. For example:
               "data": [  {  "key": "scope",  "value": "zones/us-east1-d"  }
        :param _builtins.str message: A human-readable description of the warning code.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "datas", datas)
        pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        A warning code, if applicable. For example, Compute Engine returns
        NO_RESULTS_ON_PAGE if there are no results in the response.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def datas(self) -> Sequence['outputs.GetRouterStatusBestRouteWarningDataResult']:
        """
        Metadata about this warning in key: value format. For example:
        "data": [  {  "key": "scope",  "value": "zones/us-east1-d"  }
        """
        return pulumi.get(self, "datas")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        A human-readable description of the warning code.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class GetRouterStatusBestRouteWarningDataResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
        :param _builtins.str value: A warning data value corresponding to the key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A warning data value corresponding to the key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRouterStatusBestRoutesForRouterResult(dict):
    def __init__(__self__, *,
                 as_paths: Sequence['outputs.GetRouterStatusBestRoutesForRouterAsPathResult'],
                 creation_timestamp: _builtins.str,
                 description: _builtins.str,
                 dest_range: _builtins.str,
                 name: _builtins.str,
                 network: _builtins.str,
                 next_hop_gateway: _builtins.str,
                 next_hop_hub: _builtins.str,
                 next_hop_ilb: _builtins.str,
                 next_hop_instance: _builtins.str,
                 next_hop_instance_zone: _builtins.str,
                 next_hop_inter_region_cost: _builtins.str,
                 next_hop_ip: _builtins.str,
                 next_hop_med: _builtins.str,
                 next_hop_network: _builtins.str,
                 next_hop_origin: _builtins.str,
                 next_hop_peering: _builtins.str,
                 next_hop_vpn_tunnel: _builtins.str,
                 params: Sequence['outputs.GetRouterStatusBestRoutesForRouterParamResult'],
                 priority: _builtins.int,
                 project: _builtins.str,
                 route_status: _builtins.str,
                 route_type: _builtins.str,
                 self_link: _builtins.str,
                 tags: Sequence[_builtins.str],
                 warnings: Sequence['outputs.GetRouterStatusBestRoutesForRouterWarningResult']):
        """
        :param _builtins.str creation_timestamp: Creation timestamp in RFC3339 text format.
        :param _builtins.str description: An optional description of this resource. Provide this property
               when you create the resource.
        :param _builtins.str dest_range: The destination range of outgoing packets that this route applies to.
               Only IPv4 is supported.
        :param _builtins.str name: The name of the router.
        :param _builtins.str network: The network name or resource link to the parent
               network of this subnetwork.
        :param _builtins.str next_hop_gateway: URL to a gateway that should handle matching packets.
               Currently, you can only specify the internet gateway, using a full or
               partial valid URL:
               * 'https://www.googleapis.com/compute/v1/projects/project/global/gateways/default-internet-gateway'
               * 'projects/project/global/gateways/default-internet-gateway'
               * 'global/gateways/default-internet-gateway'
               * The string 'default-internet-gateway'.
        :param _builtins.str next_hop_hub: The hub network that should handle matching packets, which should conform to RFC1035.
        :param _builtins.str next_hop_ilb: The IP address or URL to a forwarding rule of type
               loadBalancingScheme=INTERNAL that should handle matching
               packets.
               
               With the GA provider you can only specify the forwarding
               rule as a partial or full URL. For example, the following
               are all valid values:
               * 10.128.0.56
               * https://www.googleapis.com/compute/v1/projects/project/regions/region/forwardingRules/forwardingRule
               * regions/region/forwardingRules/forwardingRule
               
               When the beta provider, you can also specify the IP address
               of a forwarding rule from the same VPC or any peered VPC.
               
               Note that this can only be used when the destinationRange is
               a public (non-RFC 1918) IP CIDR range.
        :param _builtins.str next_hop_instance: URL to an instance that should handle matching packets.
               You can specify this as a full or partial URL. For example:
               * 'https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance'
               * 'projects/project/zones/zone/instances/instance'
               * 'zones/zone/instances/instance'
               * Just the instance name, with the zone in 'next_hop_instance_zone'.
        :param _builtins.str next_hop_instance_zone: The zone of the instance specified in next_hop_instance. Omit if next_hop_instance is specified as a URL.
        :param _builtins.str next_hop_inter_region_cost: Internal fixed region-to-region cost that Google Cloud calculates based on factors such as network performance, distance, and available bandwidth between regions.
        :param _builtins.str next_hop_ip: Network IP address of an instance that should handle matching packets.
        :param _builtins.str next_hop_med: Multi-Exit Discriminator, a BGP route metric that indicates the desirability of a particular route in a network.
        :param _builtins.str next_hop_network: URL to a Network that should handle matching packets.
        :param _builtins.str next_hop_origin: Indicates the origin of the route. Can be IGP (Interior Gateway Protocol), EGP (Exterior Gateway Protocol), or INCOMPLETE.
        :param _builtins.str next_hop_peering: The network peering name that should handle matching packets, which should conform to RFC1035.
        :param _builtins.str next_hop_vpn_tunnel: URL to a VpnTunnel that should handle matching packets.
        :param Sequence['GetRouterStatusBestRoutesForRouterParamArgs'] params: Additional params passed with the request, but not persisted as part of resource payload
        :param _builtins.int priority: The priority of this route. Priority is used to break ties in cases
               where there is more than one matching route of equal prefix length.
               
               In the case of two routes with equal prefix length, the one with the
               lowest-numbered priority value wins.
               
               Default value is 1000. Valid range is 0 through 65535.
        :param _builtins.str project: The ID of the project in which the resource
               belongs. If it is not provided, the provider project is used.
        :param _builtins.str route_status: The status of the route, which can be one of the following values:
               - 'ACTIVE' for an active route
               - 'INACTIVE' for an inactive route
        :param _builtins.str route_type: The type of this route, which can be one of the following values:
               - 'TRANSIT' for a transit route that this router learned from another Cloud Router and will readvertise to one of its BGP peers
               - 'SUBNET' for a route from a subnet of the VPC
               - 'BGP' for a route learned from a BGP peer of this router
               - 'STATIC' for a static route
        :param Sequence[_builtins.str] tags: A list of instance tags to which this route applies.
        :param Sequence['GetRouterStatusBestRoutesForRouterWarningArgs'] warnings: If potential misconfigurations are detected for this route, this field will be populated with warning messages.
        """
        pulumi.set(__self__, "as_paths", as_paths)
        pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dest_range", dest_range)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "next_hop_gateway", next_hop_gateway)
        pulumi.set(__self__, "next_hop_hub", next_hop_hub)
        pulumi.set(__self__, "next_hop_ilb", next_hop_ilb)
        pulumi.set(__self__, "next_hop_instance", next_hop_instance)
        pulumi.set(__self__, "next_hop_instance_zone", next_hop_instance_zone)
        pulumi.set(__self__, "next_hop_inter_region_cost", next_hop_inter_region_cost)
        pulumi.set(__self__, "next_hop_ip", next_hop_ip)
        pulumi.set(__self__, "next_hop_med", next_hop_med)
        pulumi.set(__self__, "next_hop_network", next_hop_network)
        pulumi.set(__self__, "next_hop_origin", next_hop_origin)
        pulumi.set(__self__, "next_hop_peering", next_hop_peering)
        pulumi.set(__self__, "next_hop_vpn_tunnel", next_hop_vpn_tunnel)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "route_status", route_status)
        pulumi.set(__self__, "route_type", route_type)
        pulumi.set(__self__, "self_link", self_link)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "warnings", warnings)

    @_builtins.property
    @pulumi.getter(name="asPaths")
    def as_paths(self) -> Sequence['outputs.GetRouterStatusBestRoutesForRouterAsPathResult']:
        return pulumi.get(self, "as_paths")

    @_builtins.property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> _builtins.str:
        """
        Creation timestamp in RFC3339 text format.
        """
        return pulumi.get(self, "creation_timestamp")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        An optional description of this resource. Provide this property
        when you create the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="destRange")
    def dest_range(self) -> _builtins.str:
        """
        The destination range of outgoing packets that this route applies to.
        Only IPv4 is supported.
        """
        return pulumi.get(self, "dest_range")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the router.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The network name or resource link to the parent
        network of this subnetwork.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="nextHopGateway")
    def next_hop_gateway(self) -> _builtins.str:
        """
        URL to a gateway that should handle matching packets.
        Currently, you can only specify the internet gateway, using a full or
        partial valid URL:
        * 'https://www.googleapis.com/compute/v1/projects/project/global/gateways/default-internet-gateway'
        * 'projects/project/global/gateways/default-internet-gateway'
        * 'global/gateways/default-internet-gateway'
        * The string 'default-internet-gateway'.
        """
        return pulumi.get(self, "next_hop_gateway")

    @_builtins.property
    @pulumi.getter(name="nextHopHub")
    def next_hop_hub(self) -> _builtins.str:
        """
        The hub network that should handle matching packets, which should conform to RFC1035.
        """
        return pulumi.get(self, "next_hop_hub")

    @_builtins.property
    @pulumi.getter(name="nextHopIlb")
    def next_hop_ilb(self) -> _builtins.str:
        """
        The IP address or URL to a forwarding rule of type
        loadBalancingScheme=INTERNAL that should handle matching
        packets.

        With the GA provider you can only specify the forwarding
        rule as a partial or full URL. For example, the following
        are all valid values:
        * 10.128.0.56
        * https://www.googleapis.com/compute/v1/projects/project/regions/region/forwardingRules/forwardingRule
        * regions/region/forwardingRules/forwardingRule

        When the beta provider, you can also specify the IP address
        of a forwarding rule from the same VPC or any peered VPC.

        Note that this can only be used when the destinationRange is
        a public (non-RFC 1918) IP CIDR range.
        """
        return pulumi.get(self, "next_hop_ilb")

    @_builtins.property
    @pulumi.getter(name="nextHopInstance")
    def next_hop_instance(self) -> _builtins.str:
        """
        URL to an instance that should handle matching packets.
        You can specify this as a full or partial URL. For example:
        * 'https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance'
        * 'projects/project/zones/zone/instances/instance'
        * 'zones/zone/instances/instance'
        * Just the instance name, with the zone in 'next_hop_instance_zone'.
        """
        return pulumi.get(self, "next_hop_instance")

    @_builtins.property
    @pulumi.getter(name="nextHopInstanceZone")
    def next_hop_instance_zone(self) -> _builtins.str:
        """
        The zone of the instance specified in next_hop_instance. Omit if next_hop_instance is specified as a URL.
        """
        return pulumi.get(self, "next_hop_instance_zone")

    @_builtins.property
    @pulumi.getter(name="nextHopInterRegionCost")
    def next_hop_inter_region_cost(self) -> _builtins.str:
        """
        Internal fixed region-to-region cost that Google Cloud calculates based on factors such as network performance, distance, and available bandwidth between regions.
        """
        return pulumi.get(self, "next_hop_inter_region_cost")

    @_builtins.property
    @pulumi.getter(name="nextHopIp")
    def next_hop_ip(self) -> _builtins.str:
        """
        Network IP address of an instance that should handle matching packets.
        """
        return pulumi.get(self, "next_hop_ip")

    @_builtins.property
    @pulumi.getter(name="nextHopMed")
    def next_hop_med(self) -> _builtins.str:
        """
        Multi-Exit Discriminator, a BGP route metric that indicates the desirability of a particular route in a network.
        """
        return pulumi.get(self, "next_hop_med")

    @_builtins.property
    @pulumi.getter(name="nextHopNetwork")
    def next_hop_network(self) -> _builtins.str:
        """
        URL to a Network that should handle matching packets.
        """
        return pulumi.get(self, "next_hop_network")

    @_builtins.property
    @pulumi.getter(name="nextHopOrigin")
    def next_hop_origin(self) -> _builtins.str:
        """
        Indicates the origin of the route. Can be IGP (Interior Gateway Protocol), EGP (Exterior Gateway Protocol), or INCOMPLETE.
        """
        return pulumi.get(self, "next_hop_origin")

    @_builtins.property
    @pulumi.getter(name="nextHopPeering")
    def next_hop_peering(self) -> _builtins.str:
        """
        The network peering name that should handle matching packets, which should conform to RFC1035.
        """
        return pulumi.get(self, "next_hop_peering")

    @_builtins.property
    @pulumi.getter(name="nextHopVpnTunnel")
    def next_hop_vpn_tunnel(self) -> _builtins.str:
        """
        URL to a VpnTunnel that should handle matching packets.
        """
        return pulumi.get(self, "next_hop_vpn_tunnel")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Sequence['outputs.GetRouterStatusBestRoutesForRouterParamResult']:
        """
        Additional params passed with the request, but not persisted as part of resource payload
        """
        return pulumi.get(self, "params")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        The priority of this route. Priority is used to break ties in cases
        where there is more than one matching route of equal prefix length.

        In the case of two routes with equal prefix length, the one with the
        lowest-numbered priority value wins.

        Default value is 1000. Valid range is 0 through 65535.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        The ID of the project in which the resource
        belongs. If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter(name="routeStatus")
    def route_status(self) -> _builtins.str:
        """
        The status of the route, which can be one of the following values:
        - 'ACTIVE' for an active route
        - 'INACTIVE' for an inactive route
        """
        return pulumi.get(self, "route_status")

    @_builtins.property
    @pulumi.getter(name="routeType")
    def route_type(self) -> _builtins.str:
        """
        The type of this route, which can be one of the following values:
        - 'TRANSIT' for a transit route that this router learned from another Cloud Router and will readvertise to one of its BGP peers
        - 'SUBNET' for a route from a subnet of the VPC
        - 'BGP' for a route learned from a BGP peer of this router
        - 'STATIC' for a static route
        """
        return pulumi.get(self, "route_type")

    @_builtins.property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> _builtins.str:
        return pulumi.get(self, "self_link")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        A list of instance tags to which this route applies.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def warnings(self) -> Sequence['outputs.GetRouterStatusBestRoutesForRouterWarningResult']:
        """
        If potential misconfigurations are detected for this route, this field will be populated with warning messages.
        """
        return pulumi.get(self, "warnings")


@pulumi.output_type
class GetRouterStatusBestRoutesForRouterAsPathResult(dict):
    def __init__(__self__, *,
                 as_lists: Sequence[_builtins.int],
                 path_segment_type: _builtins.str):
        """
        :param Sequence[_builtins.int] as_lists: The AS numbers of the AS Path.
        :param _builtins.str path_segment_type: The type of the AS Path, which can be one of the following values:
               - 'AS_SET': unordered set of autonomous systems that the route in has traversed
               - 'AS_SEQUENCE': ordered set of autonomous systems that the route has traversed
               - 'AS_CONFED_SEQUENCE': ordered set of Member Autonomous Systems in the local confederation that the route has traversed
               - 'AS_CONFED_SET': unordered set of Member Autonomous Systems in the local confederation that the route has traversed
        """
        pulumi.set(__self__, "as_lists", as_lists)
        pulumi.set(__self__, "path_segment_type", path_segment_type)

    @_builtins.property
    @pulumi.getter(name="asLists")
    def as_lists(self) -> Sequence[_builtins.int]:
        """
        The AS numbers of the AS Path.
        """
        return pulumi.get(self, "as_lists")

    @_builtins.property
    @pulumi.getter(name="pathSegmentType")
    def path_segment_type(self) -> _builtins.str:
        """
        The type of the AS Path, which can be one of the following values:
        - 'AS_SET': unordered set of autonomous systems that the route in has traversed
        - 'AS_SEQUENCE': ordered set of autonomous systems that the route has traversed
        - 'AS_CONFED_SEQUENCE': ordered set of Member Autonomous Systems in the local confederation that the route has traversed
        - 'AS_CONFED_SET': unordered set of Member Autonomous Systems in the local confederation that the route has traversed
        """
        return pulumi.get(self, "path_segment_type")


@pulumi.output_type
class GetRouterStatusBestRoutesForRouterParamResult(dict):
    def __init__(__self__, *,
                 resource_manager_tags: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] resource_manager_tags: Resource manager tags to be bound to the route. Tag keys and values have the
               same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
               and values are in the format tagValues/456. The field is ignored when empty.
               The field is immutable and causes resource replacement when mutated. This field is only
               set at create time and modifying this field after creation will trigger recreation.
               To apply tags to an existing resource, see the tags.TagBinding resource.
        """
        pulumi.set(__self__, "resource_manager_tags", resource_manager_tags)

    @_builtins.property
    @pulumi.getter(name="resourceManagerTags")
    def resource_manager_tags(self) -> Mapping[str, _builtins.str]:
        """
        Resource manager tags to be bound to the route. Tag keys and values have the
        same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
        and values are in the format tagValues/456. The field is ignored when empty.
        The field is immutable and causes resource replacement when mutated. This field is only
        set at create time and modifying this field after creation will trigger recreation.
        To apply tags to an existing resource, see the tags.TagBinding resource.
        """
        return pulumi.get(self, "resource_manager_tags")


@pulumi.output_type
class GetRouterStatusBestRoutesForRouterWarningResult(dict):
    def __init__(__self__, *,
                 code: _builtins.str,
                 datas: Sequence['outputs.GetRouterStatusBestRoutesForRouterWarningDataResult'],
                 message: _builtins.str):
        """
        :param _builtins.str code: A warning code, if applicable. For example, Compute Engine returns
               NO_RESULTS_ON_PAGE if there are no results in the response.
        :param Sequence['GetRouterStatusBestRoutesForRouterWarningDataArgs'] datas: Metadata about this warning in key: value format. For example:
               "data": [  {  "key": "scope",  "value": "zones/us-east1-d"  }
        :param _builtins.str message: A human-readable description of the warning code.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "datas", datas)
        pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        A warning code, if applicable. For example, Compute Engine returns
        NO_RESULTS_ON_PAGE if there are no results in the response.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def datas(self) -> Sequence['outputs.GetRouterStatusBestRoutesForRouterWarningDataResult']:
        """
        Metadata about this warning in key: value format. For example:
        "data": [  {  "key": "scope",  "value": "zones/us-east1-d"  }
        """
        return pulumi.get(self, "datas")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        A human-readable description of the warning code.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class GetRouterStatusBestRoutesForRouterWarningDataResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
        :param _builtins.str value: A warning data value corresponding to the key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A warning data value corresponding to the key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSecurityPolicyAdaptiveProtectionConfigResult(dict):
    def __init__(__self__, *,
                 auto_deploy_configs: Sequence['outputs.GetSecurityPolicyAdaptiveProtectionConfigAutoDeployConfigResult'],
                 layer7_ddos_defense_configs: Sequence['outputs.GetSecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigResult']):
        """
        :param Sequence['GetSecurityPolicyAdaptiveProtectionConfigAutoDeployConfigArgs'] auto_deploy_configs: Auto Deploy Config of this security policy
        :param Sequence['GetSecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigArgs'] layer7_ddos_defense_configs: Layer 7 DDoS Defense Config of this security policy
        """
        pulumi.set(__self__, "auto_deploy_configs", auto_deploy_configs)
        pulumi.set(__self__, "layer7_ddos_defense_configs", layer7_ddos_defense_configs)

    @_builtins.property
    @pulumi.getter(name="autoDeployConfigs")
    def auto_deploy_configs(self) -> Sequence['outputs.GetSecurityPolicyAdaptiveProtectionConfigAutoDeployConfigResult']:
        """
        Auto Deploy Config of this security policy
        """
        return pulumi.get(self, "auto_deploy_configs")

    @_builtins.property
    @pulumi.getter(name="layer7DdosDefenseConfigs")
    def layer7_ddos_defense_configs(self) -> Sequence['outputs.GetSecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigResult']:
        """
        Layer 7 DDoS Defense Config of this security policy
        """
        return pulumi.get(self, "layer7_ddos_defense_configs")


@pulumi.output_type
class GetSecurityPolicyAdaptiveProtectionConfigAutoDeployConfigResult(dict):
    def __init__(__self__, *,
                 confidence_threshold: _builtins.float,
                 expiration_sec: _builtins.int,
                 impacted_baseline_threshold: _builtins.float,
                 load_threshold: _builtins.float):
        """
        :param _builtins.float confidence_threshold: Rules are only automatically deployed for alerts on potential attacks with confidence scores greater than this threshold.
        :param _builtins.int expiration_sec: Google Cloud Armor stops applying the action in the automatically deployed rule to an identified attacker after this duration. The rule continues to operate against new requests.
        :param _builtins.float impacted_baseline_threshold: Rules are only automatically deployed when the estimated impact to baseline traffic from the suggested mitigation is below this threshold.
        :param _builtins.float load_threshold: Identifies new attackers only when the load to the backend service that is under attack exceeds this threshold.
        """
        pulumi.set(__self__, "confidence_threshold", confidence_threshold)
        pulumi.set(__self__, "expiration_sec", expiration_sec)
        pulumi.set(__self__, "impacted_baseline_threshold", impacted_baseline_threshold)
        pulumi.set(__self__, "load_threshold", load_threshold)

    @_builtins.property
    @pulumi.getter(name="confidenceThreshold")
    def confidence_threshold(self) -> _builtins.float:
        """
        Rules are only automatically deployed for alerts on potential attacks with confidence scores greater than this threshold.
        """
        return pulumi.get(self, "confidence_threshold")

    @_builtins.property
    @pulumi.getter(name="expirationSec")
    def expiration_sec(self) -> _builtins.int:
        """
        Google Cloud Armor stops applying the action in the automatically deployed rule to an identified attacker after this duration. The rule continues to operate against new requests.
        """
        return pulumi.get(self, "expiration_sec")

    @_builtins.property
    @pulumi.getter(name="impactedBaselineThreshold")
    def impacted_baseline_threshold(self) -> _builtins.float:
        """
        Rules are only automatically deployed when the estimated impact to baseline traffic from the suggested mitigation is below this threshold.
        """
        return pulumi.get(self, "impacted_baseline_threshold")

    @_builtins.property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> _builtins.float:
        """
        Identifies new attackers only when the load to the backend service that is under attack exceeds this threshold.
        """
        return pulumi.get(self, "load_threshold")


@pulumi.output_type
class GetSecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigResult(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool,
                 rule_visibility: _builtins.str,
                 threshold_configs: Sequence['outputs.GetSecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigResult']):
        """
        :param _builtins.bool enable: If set to true, enables CAAP for L7 DDoS detection.
        :param _builtins.str rule_visibility: Rule visibility. Supported values include: "STANDARD", "PREMIUM".
        :param Sequence['GetSecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigArgs'] threshold_configs: Configuration options for layer7 adaptive protection for various customizable thresholds.
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "rule_visibility", rule_visibility)
        pulumi.set(__self__, "threshold_configs", threshold_configs)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        If set to true, enables CAAP for L7 DDoS detection.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="ruleVisibility")
    def rule_visibility(self) -> _builtins.str:
        """
        Rule visibility. Supported values include: "STANDARD", "PREMIUM".
        """
        return pulumi.get(self, "rule_visibility")

    @_builtins.property
    @pulumi.getter(name="thresholdConfigs")
    def threshold_configs(self) -> Sequence['outputs.GetSecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigResult']:
        """
        Configuration options for layer7 adaptive protection for various customizable thresholds.
        """
        return pulumi.get(self, "threshold_configs")


@pulumi.output_type
class GetSecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigResult(dict):
    def __init__(__self__, *,
                 auto_deploy_confidence_threshold: _builtins.float,
                 auto_deploy_expiration_sec: _builtins.int,
                 auto_deploy_impacted_baseline_threshold: _builtins.float,
                 auto_deploy_load_threshold: _builtins.float,
                 detection_absolute_qps: _builtins.float,
                 detection_load_threshold: _builtins.float,
                 detection_relative_to_baseline_qps: _builtins.float,
                 name: _builtins.str,
                 traffic_granularity_configs: Sequence['outputs.GetSecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfigResult']):
        """
        :param _builtins.str name: The name of the security policy. Provide either this or a `self_link`.
        """
        pulumi.set(__self__, "auto_deploy_confidence_threshold", auto_deploy_confidence_threshold)
        pulumi.set(__self__, "auto_deploy_expiration_sec", auto_deploy_expiration_sec)
        pulumi.set(__self__, "auto_deploy_impacted_baseline_threshold", auto_deploy_impacted_baseline_threshold)
        pulumi.set(__self__, "auto_deploy_load_threshold", auto_deploy_load_threshold)
        pulumi.set(__self__, "detection_absolute_qps", detection_absolute_qps)
        pulumi.set(__self__, "detection_load_threshold", detection_load_threshold)
        pulumi.set(__self__, "detection_relative_to_baseline_qps", detection_relative_to_baseline_qps)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "traffic_granularity_configs", traffic_granularity_configs)

    @_builtins.property
    @pulumi.getter(name="autoDeployConfidenceThreshold")
    def auto_deploy_confidence_threshold(self) -> _builtins.float:
        return pulumi.get(self, "auto_deploy_confidence_threshold")

    @_builtins.property
    @pulumi.getter(name="autoDeployExpirationSec")
    def auto_deploy_expiration_sec(self) -> _builtins.int:
        return pulumi.get(self, "auto_deploy_expiration_sec")

    @_builtins.property
    @pulumi.getter(name="autoDeployImpactedBaselineThreshold")
    def auto_deploy_impacted_baseline_threshold(self) -> _builtins.float:
        return pulumi.get(self, "auto_deploy_impacted_baseline_threshold")

    @_builtins.property
    @pulumi.getter(name="autoDeployLoadThreshold")
    def auto_deploy_load_threshold(self) -> _builtins.float:
        return pulumi.get(self, "auto_deploy_load_threshold")

    @_builtins.property
    @pulumi.getter(name="detectionAbsoluteQps")
    def detection_absolute_qps(self) -> _builtins.float:
        return pulumi.get(self, "detection_absolute_qps")

    @_builtins.property
    @pulumi.getter(name="detectionLoadThreshold")
    def detection_load_threshold(self) -> _builtins.float:
        return pulumi.get(self, "detection_load_threshold")

    @_builtins.property
    @pulumi.getter(name="detectionRelativeToBaselineQps")
    def detection_relative_to_baseline_qps(self) -> _builtins.float:
        return pulumi.get(self, "detection_relative_to_baseline_qps")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the security policy. Provide either this or a `self_link`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="trafficGranularityConfigs")
    def traffic_granularity_configs(self) -> Sequence['outputs.GetSecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfigResult']:
        return pulumi.get(self, "traffic_granularity_configs")


@pulumi.output_type
class GetSecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfigResult(dict):
    def __init__(__self__, *,
                 enable_each_unique_value: _builtins.bool,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.bool enable_each_unique_value: If enabled, traffic matching each unique value for the specified type constitutes a separate traffic unit. It can only be set to true if value is empty.
        :param _builtins.str type: Type of this configuration.
        :param _builtins.str value: Requests that match this value constitute a granular traffic unit.
        """
        pulumi.set(__self__, "enable_each_unique_value", enable_each_unique_value)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="enableEachUniqueValue")
    def enable_each_unique_value(self) -> _builtins.bool:
        """
        If enabled, traffic matching each unique value for the specified type constitutes a separate traffic unit. It can only be set to true if value is empty.
        """
        return pulumi.get(self, "enable_each_unique_value")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of this configuration.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Requests that match this value constitute a granular traffic unit.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSecurityPolicyAdvancedOptionsConfigResult(dict):
    def __init__(__self__, *,
                 json_custom_configs: Sequence['outputs.GetSecurityPolicyAdvancedOptionsConfigJsonCustomConfigResult'],
                 json_parsing: _builtins.str,
                 log_level: _builtins.str,
                 request_body_inspection_size: _builtins.str,
                 user_ip_request_headers: Sequence[_builtins.str]):
        """
        :param Sequence['GetSecurityPolicyAdvancedOptionsConfigJsonCustomConfigArgs'] json_custom_configs: Custom configuration to apply the JSON parsing. Only applicable when JSON parsing is set to STANDARD.
        :param _builtins.str json_parsing: JSON body parsing. Supported values include: "DISABLED", "STANDARD".
        :param _builtins.str log_level: Logging level. Supported values include: "NORMAL", "VERBOSE".
        :param _builtins.str request_body_inspection_size: The maximum request size chosen by the customer with Waf enabled. Values supported are "8KB", "16KB, "32KB", "48KB" and "64KB". Values are case insensitive.
        :param Sequence[_builtins.str] user_ip_request_headers: An optional list of case-insensitive request header names to use for resolving the callers client IP address.
        """
        pulumi.set(__self__, "json_custom_configs", json_custom_configs)
        pulumi.set(__self__, "json_parsing", json_parsing)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "request_body_inspection_size", request_body_inspection_size)
        pulumi.set(__self__, "user_ip_request_headers", user_ip_request_headers)

    @_builtins.property
    @pulumi.getter(name="jsonCustomConfigs")
    def json_custom_configs(self) -> Sequence['outputs.GetSecurityPolicyAdvancedOptionsConfigJsonCustomConfigResult']:
        """
        Custom configuration to apply the JSON parsing. Only applicable when JSON parsing is set to STANDARD.
        """
        return pulumi.get(self, "json_custom_configs")

    @_builtins.property
    @pulumi.getter(name="jsonParsing")
    def json_parsing(self) -> _builtins.str:
        """
        JSON body parsing. Supported values include: "DISABLED", "STANDARD".
        """
        return pulumi.get(self, "json_parsing")

    @_builtins.property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> _builtins.str:
        """
        Logging level. Supported values include: "NORMAL", "VERBOSE".
        """
        return pulumi.get(self, "log_level")

    @_builtins.property
    @pulumi.getter(name="requestBodyInspectionSize")
    def request_body_inspection_size(self) -> _builtins.str:
        """
        The maximum request size chosen by the customer with Waf enabled. Values supported are "8KB", "16KB, "32KB", "48KB" and "64KB". Values are case insensitive.
        """
        return pulumi.get(self, "request_body_inspection_size")

    @_builtins.property
    @pulumi.getter(name="userIpRequestHeaders")
    def user_ip_request_headers(self) -> Sequence[_builtins.str]:
        """
        An optional list of case-insensitive request header names to use for resolving the callers client IP address.
        """
        return pulumi.get(self, "user_ip_request_headers")


@pulumi.output_type
class GetSecurityPolicyAdvancedOptionsConfigJsonCustomConfigResult(dict):
    def __init__(__self__, *,
                 content_types: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] content_types: A list of custom Content-Type header values to apply the JSON parsing.
        """
        pulumi.set(__self__, "content_types", content_types)

    @_builtins.property
    @pulumi.getter(name="contentTypes")
    def content_types(self) -> Sequence[_builtins.str]:
        """
        A list of custom Content-Type header values to apply the JSON parsing.
        """
        return pulumi.get(self, "content_types")


@pulumi.output_type
class GetSecurityPolicyRecaptchaOptionsConfigResult(dict):
    def __init__(__self__, *,
                 redirect_site_key: _builtins.str):
        """
        :param _builtins.str redirect_site_key: A field to supply a reCAPTCHA site key to be used for all the rules using the redirect action with the type of GOOGLE_RECAPTCHA under the security policy. The specified site key needs to be created from the reCAPTCHA API. The user is responsible for the validity of the specified site key. If not specified, a Google-managed site key is used.
        """
        pulumi.set(__self__, "redirect_site_key", redirect_site_key)

    @_builtins.property
    @pulumi.getter(name="redirectSiteKey")
    def redirect_site_key(self) -> _builtins.str:
        """
        A field to supply a reCAPTCHA site key to be used for all the rules using the redirect action with the type of GOOGLE_RECAPTCHA under the security policy. The specified site key needs to be created from the reCAPTCHA API. The user is responsible for the validity of the specified site key. If not specified, a Google-managed site key is used.
        """
        return pulumi.get(self, "redirect_site_key")


@pulumi.output_type
class GetSecurityPolicyRuleResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 description: _builtins.str,
                 header_actions: Sequence['outputs.GetSecurityPolicyRuleHeaderActionResult'],
                 matches: Sequence['outputs.GetSecurityPolicyRuleMatchResult'],
                 preconfigured_waf_configs: Sequence['outputs.GetSecurityPolicyRulePreconfiguredWafConfigResult'],
                 preview: _builtins.bool,
                 priority: _builtins.int,
                 rate_limit_options: Sequence['outputs.GetSecurityPolicyRuleRateLimitOptionResult'],
                 redirect_options: Sequence['outputs.GetSecurityPolicyRuleRedirectOptionResult']):
        """
        :param _builtins.str action: Action to take when match matches the request.
        :param _builtins.str description: An optional description of this rule. Max size is 64.
        :param Sequence['GetSecurityPolicyRuleHeaderActionArgs'] header_actions: Additional actions that are performed on headers.
        :param Sequence['GetSecurityPolicyRuleMatchArgs'] matches: A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding action is enforced.
        :param Sequence['GetSecurityPolicyRulePreconfiguredWafConfigArgs'] preconfigured_waf_configs: Preconfigured WAF configuration to be applied for the rule. If the rule does not evaluate preconfigured WAF rules, i.e., if evaluatePreconfiguredWaf() is not used, this field will have no effect.
        :param _builtins.bool preview: When set to true, the action specified above is not enforced. Stackdriver logs for requests that trigger a preview action are annotated as such.
        :param _builtins.int priority: An unique positive integer indicating the priority of evaluation for a rule. Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
        :param Sequence['GetSecurityPolicyRuleRateLimitOptionArgs'] rate_limit_options: Rate limit threshold for this security policy. Must be specified if the action is "rate_based_ban" or "throttle". Cannot be specified for any other actions.
        :param Sequence['GetSecurityPolicyRuleRedirectOptionArgs'] redirect_options: Parameters defining the redirect action. Cannot be specified for any other actions.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "header_actions", header_actions)
        pulumi.set(__self__, "matches", matches)
        pulumi.set(__self__, "preconfigured_waf_configs", preconfigured_waf_configs)
        pulumi.set(__self__, "preview", preview)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rate_limit_options", rate_limit_options)
        pulumi.set(__self__, "redirect_options", redirect_options)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Action to take when match matches the request.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        An optional description of this rule. Max size is 64.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="headerActions")
    def header_actions(self) -> Sequence['outputs.GetSecurityPolicyRuleHeaderActionResult']:
        """
        Additional actions that are performed on headers.
        """
        return pulumi.get(self, "header_actions")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetSecurityPolicyRuleMatchResult']:
        """
        A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding action is enforced.
        """
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter(name="preconfiguredWafConfigs")
    def preconfigured_waf_configs(self) -> Sequence['outputs.GetSecurityPolicyRulePreconfiguredWafConfigResult']:
        """
        Preconfigured WAF configuration to be applied for the rule. If the rule does not evaluate preconfigured WAF rules, i.e., if evaluatePreconfiguredWaf() is not used, this field will have no effect.
        """
        return pulumi.get(self, "preconfigured_waf_configs")

    @_builtins.property
    @pulumi.getter
    def preview(self) -> _builtins.bool:
        """
        When set to true, the action specified above is not enforced. Stackdriver logs for requests that trigger a preview action are annotated as such.
        """
        return pulumi.get(self, "preview")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        An unique positive integer indicating the priority of evaluation for a rule. Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="rateLimitOptions")
    def rate_limit_options(self) -> Sequence['outputs.GetSecurityPolicyRuleRateLimitOptionResult']:
        """
        Rate limit threshold for this security policy. Must be specified if the action is "rate_based_ban" or "throttle". Cannot be specified for any other actions.
        """
        return pulumi.get(self, "rate_limit_options")

    @_builtins.property
    @pulumi.getter(name="redirectOptions")
    def redirect_options(self) -> Sequence['outputs.GetSecurityPolicyRuleRedirectOptionResult']:
        """
        Parameters defining the redirect action. Cannot be specified for any other actions.
        """
        return pulumi.get(self, "redirect_options")


@pulumi.output_type
class GetSecurityPolicyRuleHeaderActionResult(dict):
    def __init__(__self__, *,
                 request_headers_to_adds: Sequence['outputs.GetSecurityPolicyRuleHeaderActionRequestHeadersToAddResult']):
        """
        :param Sequence['GetSecurityPolicyRuleHeaderActionRequestHeadersToAddArgs'] request_headers_to_adds: The list of request headers to add or overwrite if they're already present.
        """
        pulumi.set(__self__, "request_headers_to_adds", request_headers_to_adds)

    @_builtins.property
    @pulumi.getter(name="requestHeadersToAdds")
    def request_headers_to_adds(self) -> Sequence['outputs.GetSecurityPolicyRuleHeaderActionRequestHeadersToAddResult']:
        """
        The list of request headers to add or overwrite if they're already present.
        """
        return pulumi.get(self, "request_headers_to_adds")


@pulumi.output_type
class GetSecurityPolicyRuleHeaderActionRequestHeadersToAddResult(dict):
    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str):
        """
        :param _builtins.str header_name: The name of the header to set.
        :param _builtins.str header_value: The value to set the named header to.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the header to set.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        """
        The value to set the named header to.
        """
        return pulumi.get(self, "header_value")


@pulumi.output_type
class GetSecurityPolicyRuleMatchResult(dict):
    def __init__(__self__, *,
                 configs: Sequence['outputs.GetSecurityPolicyRuleMatchConfigResult'],
                 expr_options: Sequence['outputs.GetSecurityPolicyRuleMatchExprOptionResult'],
                 exprs: Sequence['outputs.GetSecurityPolicyRuleMatchExprResult'],
                 versioned_expr: _builtins.str):
        """
        :param Sequence['GetSecurityPolicyRuleMatchConfigArgs'] configs: The configuration options available when specifying versioned_expr. This field must be specified if versioned_expr is specified and cannot be specified if versioned_expr is not specified.
        :param Sequence['GetSecurityPolicyRuleMatchExprOptionArgs'] expr_options: The configuration options available when specifying a user defined CEVAL expression (i.e., 'expr').
        :param Sequence['GetSecurityPolicyRuleMatchExprArgs'] exprs: User defined CEVAL expression. A CEVAL expression is used to specify match criteria such as origin.ip, source.region_code and contents in the request header.
        :param _builtins.str versioned_expr: Predefined rule expression. If this field is specified, config must also be specified. Available options:   SRC_IPS_V1: Must specify the corresponding src_ip_ranges field in config.
        """
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "expr_options", expr_options)
        pulumi.set(__self__, "exprs", exprs)
        pulumi.set(__self__, "versioned_expr", versioned_expr)

    @_builtins.property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.GetSecurityPolicyRuleMatchConfigResult']:
        """
        The configuration options available when specifying versioned_expr. This field must be specified if versioned_expr is specified and cannot be specified if versioned_expr is not specified.
        """
        return pulumi.get(self, "configs")

    @_builtins.property
    @pulumi.getter(name="exprOptions")
    def expr_options(self) -> Sequence['outputs.GetSecurityPolicyRuleMatchExprOptionResult']:
        """
        The configuration options available when specifying a user defined CEVAL expression (i.e., 'expr').
        """
        return pulumi.get(self, "expr_options")

    @_builtins.property
    @pulumi.getter
    def exprs(self) -> Sequence['outputs.GetSecurityPolicyRuleMatchExprResult']:
        """
        User defined CEVAL expression. A CEVAL expression is used to specify match criteria such as origin.ip, source.region_code and contents in the request header.
        """
        return pulumi.get(self, "exprs")

    @_builtins.property
    @pulumi.getter(name="versionedExpr")
    def versioned_expr(self) -> _builtins.str:
        """
        Predefined rule expression. If this field is specified, config must also be specified. Available options:   SRC_IPS_V1: Must specify the corresponding src_ip_ranges field in config.
        """
        return pulumi.get(self, "versioned_expr")


@pulumi.output_type
class GetSecurityPolicyRuleMatchConfigResult(dict):
    def __init__(__self__, *,
                 src_ip_ranges: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] src_ip_ranges: Set of IP addresses or ranges (IPV4 or IPV6) in CIDR notation to match against inbound traffic. There is a limit of 10 IP ranges per rule. A value of '*' matches all IPs (can be used to override the default behavior).
        """
        pulumi.set(__self__, "src_ip_ranges", src_ip_ranges)

    @_builtins.property
    @pulumi.getter(name="srcIpRanges")
    def src_ip_ranges(self) -> Sequence[_builtins.str]:
        """
        Set of IP addresses or ranges (IPV4 or IPV6) in CIDR notation to match against inbound traffic. There is a limit of 10 IP ranges per rule. A value of '*' matches all IPs (can be used to override the default behavior).
        """
        return pulumi.get(self, "src_ip_ranges")


@pulumi.output_type
class GetSecurityPolicyRuleMatchExprResult(dict):
    def __init__(__self__, *,
                 expression: _builtins.str):
        """
        :param _builtins.str expression: Textual representation of an expression in Common Expression Language syntax. The application context of the containing message determines which well-known feature set of CEL is supported.
        """
        pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Textual representation of an expression in Common Expression Language syntax. The application context of the containing message determines which well-known feature set of CEL is supported.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class GetSecurityPolicyRuleMatchExprOptionResult(dict):
    def __init__(__self__, *,
                 recaptcha_options: Sequence['outputs.GetSecurityPolicyRuleMatchExprOptionRecaptchaOptionResult']):
        """
        :param Sequence['GetSecurityPolicyRuleMatchExprOptionRecaptchaOptionArgs'] recaptcha_options: reCAPTCHA configuration options to be applied for the rule. If the rule does not evaluate reCAPTCHA tokens, this field has no effect.
        """
        pulumi.set(__self__, "recaptcha_options", recaptcha_options)

    @_builtins.property
    @pulumi.getter(name="recaptchaOptions")
    def recaptcha_options(self) -> Sequence['outputs.GetSecurityPolicyRuleMatchExprOptionRecaptchaOptionResult']:
        """
        reCAPTCHA configuration options to be applied for the rule. If the rule does not evaluate reCAPTCHA tokens, this field has no effect.
        """
        return pulumi.get(self, "recaptcha_options")


@pulumi.output_type
class GetSecurityPolicyRuleMatchExprOptionRecaptchaOptionResult(dict):
    def __init__(__self__, *,
                 action_token_site_keys: Sequence[_builtins.str],
                 session_token_site_keys: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] action_token_site_keys: A list of site keys to be used during the validation of reCAPTCHA action-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created
        :param Sequence[_builtins.str] session_token_site_keys: A list of site keys to be used during the validation of reCAPTCHA session-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
        """
        pulumi.set(__self__, "action_token_site_keys", action_token_site_keys)
        pulumi.set(__self__, "session_token_site_keys", session_token_site_keys)

    @_builtins.property
    @pulumi.getter(name="actionTokenSiteKeys")
    def action_token_site_keys(self) -> Sequence[_builtins.str]:
        """
        A list of site keys to be used during the validation of reCAPTCHA action-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created
        """
        return pulumi.get(self, "action_token_site_keys")

    @_builtins.property
    @pulumi.getter(name="sessionTokenSiteKeys")
    def session_token_site_keys(self) -> Sequence[_builtins.str]:
        """
        A list of site keys to be used during the validation of reCAPTCHA session-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
        """
        return pulumi.get(self, "session_token_site_keys")


@pulumi.output_type
class GetSecurityPolicyRulePreconfiguredWafConfigResult(dict):
    def __init__(__self__, *,
                 exclusions: Sequence['outputs.GetSecurityPolicyRulePreconfiguredWafConfigExclusionResult']):
        """
        :param Sequence['GetSecurityPolicyRulePreconfiguredWafConfigExclusionArgs'] exclusions: An exclusion to apply during preconfigured WAF evaluation.
        """
        pulumi.set(__self__, "exclusions", exclusions)

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Sequence['outputs.GetSecurityPolicyRulePreconfiguredWafConfigExclusionResult']:
        """
        An exclusion to apply during preconfigured WAF evaluation.
        """
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class GetSecurityPolicyRulePreconfiguredWafConfigExclusionResult(dict):
    def __init__(__self__, *,
                 request_cookies: Sequence['outputs.GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCookyResult'],
                 request_headers: Sequence['outputs.GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeaderResult'],
                 request_query_params: Sequence['outputs.GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParamResult'],
                 request_uris: Sequence['outputs.GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUriResult'],
                 target_rule_ids: Sequence[_builtins.str],
                 target_rule_set: _builtins.str):
        """
        :param Sequence['GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCookyArgs'] request_cookies: Request cookie whose value will be excluded from inspection during preconfigured WAF evaluation.
        :param Sequence['GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeaderArgs'] request_headers: Request header whose value will be excluded from inspection during preconfigured WAF evaluation.
        :param Sequence['GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParamArgs'] request_query_params: Request query parameter whose value will be excluded from inspection during preconfigured WAF evaluation.  Note that the parameter can be in the query string or in the POST body.
        :param Sequence['GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUriArgs'] request_uris: Request URI from the request line to be excluded from inspection during preconfigured WAF evaluation. When specifying this field, the query or fragment part should be excluded.
        :param Sequence[_builtins.str] target_rule_ids: A list of target rule IDs under the WAF rule set to apply the preconfigured WAF exclusion. If omitted, it refers to all the rule IDs under the WAF rule set.
        :param _builtins.str target_rule_set: Target WAF rule set to apply the preconfigured WAF exclusion.
        """
        pulumi.set(__self__, "request_cookies", request_cookies)
        pulumi.set(__self__, "request_headers", request_headers)
        pulumi.set(__self__, "request_query_params", request_query_params)
        pulumi.set(__self__, "request_uris", request_uris)
        pulumi.set(__self__, "target_rule_ids", target_rule_ids)
        pulumi.set(__self__, "target_rule_set", target_rule_set)

    @_builtins.property
    @pulumi.getter(name="requestCookies")
    def request_cookies(self) -> Sequence['outputs.GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCookyResult']:
        """
        Request cookie whose value will be excluded from inspection during preconfigured WAF evaluation.
        """
        return pulumi.get(self, "request_cookies")

    @_builtins.property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Sequence['outputs.GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeaderResult']:
        """
        Request header whose value will be excluded from inspection during preconfigured WAF evaluation.
        """
        return pulumi.get(self, "request_headers")

    @_builtins.property
    @pulumi.getter(name="requestQueryParams")
    def request_query_params(self) -> Sequence['outputs.GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParamResult']:
        """
        Request query parameter whose value will be excluded from inspection during preconfigured WAF evaluation.  Note that the parameter can be in the query string or in the POST body.
        """
        return pulumi.get(self, "request_query_params")

    @_builtins.property
    @pulumi.getter(name="requestUris")
    def request_uris(self) -> Sequence['outputs.GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUriResult']:
        """
        Request URI from the request line to be excluded from inspection during preconfigured WAF evaluation. When specifying this field, the query or fragment part should be excluded.
        """
        return pulumi.get(self, "request_uris")

    @_builtins.property
    @pulumi.getter(name="targetRuleIds")
    def target_rule_ids(self) -> Sequence[_builtins.str]:
        """
        A list of target rule IDs under the WAF rule set to apply the preconfigured WAF exclusion. If omitted, it refers to all the rule IDs under the WAF rule set.
        """
        return pulumi.get(self, "target_rule_ids")

    @_builtins.property
    @pulumi.getter(name="targetRuleSet")
    def target_rule_set(self) -> _builtins.str:
        """
        Target WAF rule set to apply the preconfigured WAF exclusion.
        """
        return pulumi.get(self, "target_rule_set")


@pulumi.output_type
class GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCookyResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value. Available options: EQUALS: The operator matches if the field value equals the specified value. STARTS_WITH: The operator matches if the field value starts with the specified value. ENDS_WITH: The operator matches if the field value ends with the specified value. CONTAINS: The operator matches if the field value contains the specified value. EQUALS_ANY: The operator matches if the field value is any value.
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation. The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value. Available options: EQUALS: The operator matches if the field value equals the specified value. STARTS_WITH: The operator matches if the field value starts with the specified value. ENDS_WITH: The operator matches if the field value ends with the specified value. CONTAINS: The operator matches if the field value contains the specified value. EQUALS_ANY: The operator matches if the field value is any value.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation. The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeaderResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value. Available options: EQUALS: The operator matches if the field value equals the specified value. STARTS_WITH: The operator matches if the field value starts with the specified value. ENDS_WITH: The operator matches if the field value ends with the specified value. CONTAINS: The operator matches if the field value contains the specified value. EQUALS_ANY: The operator matches if the field value is any value.
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation. The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value. Available options: EQUALS: The operator matches if the field value equals the specified value. STARTS_WITH: The operator matches if the field value starts with the specified value. ENDS_WITH: The operator matches if the field value ends with the specified value. CONTAINS: The operator matches if the field value contains the specified value. EQUALS_ANY: The operator matches if the field value is any value.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation. The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParamResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value. Available options: EQUALS: The operator matches if the field value equals the specified value. STARTS_WITH: The operator matches if the field value starts with the specified value. ENDS_WITH: The operator matches if the field value ends with the specified value. CONTAINS: The operator matches if the field value contains the specified value. EQUALS_ANY: The operator matches if the field value is any value.
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation. The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value. Available options: EQUALS: The operator matches if the field value equals the specified value. STARTS_WITH: The operator matches if the field value starts with the specified value. ENDS_WITH: The operator matches if the field value ends with the specified value. CONTAINS: The operator matches if the field value contains the specified value. EQUALS_ANY: The operator matches if the field value is any value.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation. The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUriResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str operator: You can specify an exact match or a partial match by using a field operator and a field value. Available options: EQUALS: The operator matches if the field value equals the specified value. STARTS_WITH: The operator matches if the field value starts with the specified value. ENDS_WITH: The operator matches if the field value ends with the specified value. CONTAINS: The operator matches if the field value contains the specified value. EQUALS_ANY: The operator matches if the field value is any value.
        :param _builtins.str value: A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation. The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        You can specify an exact match or a partial match by using a field operator and a field value. Available options: EQUALS: The operator matches if the field value equals the specified value. STARTS_WITH: The operator matches if the field value starts with the specified value. ENDS_WITH: The operator matches if the field value ends with the specified value. CONTAINS: The operator matches if the field value contains the specified value. EQUALS_ANY: The operator matches if the field value is any value.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation. The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSecurityPolicyRuleRateLimitOptionResult(dict):
    def __init__(__self__, *,
                 ban_duration_sec: _builtins.int,
                 ban_thresholds: Sequence['outputs.GetSecurityPolicyRuleRateLimitOptionBanThresholdResult'],
                 conform_action: _builtins.str,
                 enforce_on_key: _builtins.str,
                 enforce_on_key_configs: Sequence['outputs.GetSecurityPolicyRuleRateLimitOptionEnforceOnKeyConfigResult'],
                 enforce_on_key_name: _builtins.str,
                 exceed_action: _builtins.str,
                 exceed_redirect_options: Sequence['outputs.GetSecurityPolicyRuleRateLimitOptionExceedRedirectOptionResult'],
                 rate_limit_thresholds: Sequence['outputs.GetSecurityPolicyRuleRateLimitOptionRateLimitThresholdResult']):
        """
        :param _builtins.int ban_duration_sec: Can only be specified if the action for the rule is "rate_based_ban". If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
        :param Sequence['GetSecurityPolicyRuleRateLimitOptionBanThresholdArgs'] ban_thresholds: Can only be specified if the action for the rule is "rate_based_ban". If specified, the key will be banned for the configured 'banDurationSec' when the number of requests that exceed the 'rateLimitThreshold' also exceed this 'banThreshold'.
        :param _builtins.str conform_action: Action to take for requests that are under the configured rate limit threshold. Valid option is "allow" only.
        :param _builtins.str enforce_on_key: Determines the key to enforce the rateLimitThreshold on
        :param Sequence['GetSecurityPolicyRuleRateLimitOptionEnforceOnKeyConfigArgs'] enforce_on_key_configs: Enforce On Key Config of this security policy
        :param _builtins.str enforce_on_key_name: Rate limit key name applicable only for the following key types: HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value. HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        :param _builtins.str exceed_action: Action to take for requests that are above the configured rate limit threshold, to either deny with a specified HTTP response code, or redirect to a different endpoint. Valid options are "deny()" where valid values for status are 403, 404, 429, and 502, and "redirect" where the redirect parameters come from exceedRedirectOptions below.
        :param Sequence['GetSecurityPolicyRuleRateLimitOptionExceedRedirectOptionArgs'] exceed_redirect_options: Parameters defining the redirect action that is used as the exceed action. Cannot be specified if the exceed action is not redirect.
        :param Sequence['GetSecurityPolicyRuleRateLimitOptionRateLimitThresholdArgs'] rate_limit_thresholds: Threshold at which to begin ratelimiting.
        """
        pulumi.set(__self__, "ban_duration_sec", ban_duration_sec)
        pulumi.set(__self__, "ban_thresholds", ban_thresholds)
        pulumi.set(__self__, "conform_action", conform_action)
        pulumi.set(__self__, "enforce_on_key", enforce_on_key)
        pulumi.set(__self__, "enforce_on_key_configs", enforce_on_key_configs)
        pulumi.set(__self__, "enforce_on_key_name", enforce_on_key_name)
        pulumi.set(__self__, "exceed_action", exceed_action)
        pulumi.set(__self__, "exceed_redirect_options", exceed_redirect_options)
        pulumi.set(__self__, "rate_limit_thresholds", rate_limit_thresholds)

    @_builtins.property
    @pulumi.getter(name="banDurationSec")
    def ban_duration_sec(self) -> _builtins.int:
        """
        Can only be specified if the action for the rule is "rate_based_ban". If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
        """
        return pulumi.get(self, "ban_duration_sec")

    @_builtins.property
    @pulumi.getter(name="banThresholds")
    def ban_thresholds(self) -> Sequence['outputs.GetSecurityPolicyRuleRateLimitOptionBanThresholdResult']:
        """
        Can only be specified if the action for the rule is "rate_based_ban". If specified, the key will be banned for the configured 'banDurationSec' when the number of requests that exceed the 'rateLimitThreshold' also exceed this 'banThreshold'.
        """
        return pulumi.get(self, "ban_thresholds")

    @_builtins.property
    @pulumi.getter(name="conformAction")
    def conform_action(self) -> _builtins.str:
        """
        Action to take for requests that are under the configured rate limit threshold. Valid option is "allow" only.
        """
        return pulumi.get(self, "conform_action")

    @_builtins.property
    @pulumi.getter(name="enforceOnKey")
    def enforce_on_key(self) -> _builtins.str:
        """
        Determines the key to enforce the rateLimitThreshold on
        """
        return pulumi.get(self, "enforce_on_key")

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyConfigs")
    def enforce_on_key_configs(self) -> Sequence['outputs.GetSecurityPolicyRuleRateLimitOptionEnforceOnKeyConfigResult']:
        """
        Enforce On Key Config of this security policy
        """
        return pulumi.get(self, "enforce_on_key_configs")

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyName")
    def enforce_on_key_name(self) -> _builtins.str:
        """
        Rate limit key name applicable only for the following key types: HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value. HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        """
        return pulumi.get(self, "enforce_on_key_name")

    @_builtins.property
    @pulumi.getter(name="exceedAction")
    def exceed_action(self) -> _builtins.str:
        """
        Action to take for requests that are above the configured rate limit threshold, to either deny with a specified HTTP response code, or redirect to a different endpoint. Valid options are "deny()" where valid values for status are 403, 404, 429, and 502, and "redirect" where the redirect parameters come from exceedRedirectOptions below.
        """
        return pulumi.get(self, "exceed_action")

    @_builtins.property
    @pulumi.getter(name="exceedRedirectOptions")
    def exceed_redirect_options(self) -> Sequence['outputs.GetSecurityPolicyRuleRateLimitOptionExceedRedirectOptionResult']:
        """
        Parameters defining the redirect action that is used as the exceed action. Cannot be specified if the exceed action is not redirect.
        """
        return pulumi.get(self, "exceed_redirect_options")

    @_builtins.property
    @pulumi.getter(name="rateLimitThresholds")
    def rate_limit_thresholds(self) -> Sequence['outputs.GetSecurityPolicyRuleRateLimitOptionRateLimitThresholdResult']:
        """
        Threshold at which to begin ratelimiting.
        """
        return pulumi.get(self, "rate_limit_thresholds")


@pulumi.output_type
class GetSecurityPolicyRuleRateLimitOptionBanThresholdResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 interval_sec: _builtins.int):
        """
        :param _builtins.int count: Number of HTTP(S) requests for calculating the threshold.
        :param _builtins.int interval_sec: Interval over which the threshold is computed.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval_sec", interval_sec)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        Number of HTTP(S) requests for calculating the threshold.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="intervalSec")
    def interval_sec(self) -> _builtins.int:
        """
        Interval over which the threshold is computed.
        """
        return pulumi.get(self, "interval_sec")


@pulumi.output_type
class GetSecurityPolicyRuleRateLimitOptionEnforceOnKeyConfigResult(dict):
    def __init__(__self__, *,
                 enforce_on_key_name: _builtins.str,
                 enforce_on_key_type: _builtins.str):
        """
        :param _builtins.str enforce_on_key_name: Rate limit key name applicable only for the following key types: HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value. HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        :param _builtins.str enforce_on_key_type: Determines the key to enforce the rate_limit_threshold on
        """
        pulumi.set(__self__, "enforce_on_key_name", enforce_on_key_name)
        pulumi.set(__self__, "enforce_on_key_type", enforce_on_key_type)

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyName")
    def enforce_on_key_name(self) -> _builtins.str:
        """
        Rate limit key name applicable only for the following key types: HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value. HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
        """
        return pulumi.get(self, "enforce_on_key_name")

    @_builtins.property
    @pulumi.getter(name="enforceOnKeyType")
    def enforce_on_key_type(self) -> _builtins.str:
        """
        Determines the key to enforce the rate_limit_threshold on
        """
        return pulumi.get(self, "enforce_on_key_type")


@pulumi.output_type
class GetSecurityPolicyRuleRateLimitOptionExceedRedirectOptionResult(dict):
    def __init__(__self__, *,
                 target: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str target: Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
        :param _builtins.str type: Type of the redirect action.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the redirect action.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSecurityPolicyRuleRateLimitOptionRateLimitThresholdResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 interval_sec: _builtins.int):
        """
        :param _builtins.int count: Number of HTTP(S) requests for calculating the threshold.
        :param _builtins.int interval_sec: Interval over which the threshold is computed.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval_sec", interval_sec)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        Number of HTTP(S) requests for calculating the threshold.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="intervalSec")
    def interval_sec(self) -> _builtins.int:
        """
        Interval over which the threshold is computed.
        """
        return pulumi.get(self, "interval_sec")


@pulumi.output_type
class GetSecurityPolicyRuleRedirectOptionResult(dict):
    def __init__(__self__, *,
                 target: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str target: Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
        :param _builtins.str type: Type of the redirect action. Available options: EXTERNAL_302: Must specify the corresponding target field in config. GOOGLE_RECAPTCHA: Cannot specify target field in config.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the redirect action. Available options: EXTERNAL_302: Must specify the corresponding target field in config. GOOGLE_RECAPTCHA: Cannot specify target field in config.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSnapshotSnapshotEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 raw_key: _builtins.str,
                 rsa_encrypted_key: _builtins.str,
                 sha256: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The name of the encryption key that is stored in Google Cloud KMS.
        :param _builtins.str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param _builtins.str rsa_encrypted_key: Specifies an encryption key stored in Google Cloud KMS, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param _builtins.str sha256: The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
               encryption key that protects this resource.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)
        pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> _builtins.str:
        """
        Specifies an encryption key stored in Google Cloud KMS, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "rsa_encrypted_key")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> _builtins.str:
        """
        The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
        encryption key that protects this resource.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class GetSnapshotSourceDiskEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 kms_key_self_link: _builtins.str,
                 kms_key_service_account: _builtins.str,
                 raw_key: _builtins.str,
                 rsa_encrypted_key: _builtins.str):
        """
        :param _builtins.str kms_key_self_link: The name of the encryption key that is stored in Google Cloud KMS.
        :param _builtins.str kms_key_service_account: The service account used for the encryption request for the given KMS key.
               If absent, the Compute Engine Service Agent service account is used.
        :param _builtins.str raw_key: Specifies a 256-bit customer-supplied encryption key, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        :param _builtins.str rsa_encrypted_key: Specifies an encryption key stored in Google Cloud KMS, encoded in
               RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        pulumi.set(__self__, "kms_key_self_link", kms_key_self_link)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)
        pulumi.set(__self__, "raw_key", raw_key)
        pulumi.set(__self__, "rsa_encrypted_key", rsa_encrypted_key)

    @_builtins.property
    @pulumi.getter(name="kmsKeySelfLink")
    def kms_key_self_link(self) -> _builtins.str:
        """
        The name of the encryption key that is stored in Google Cloud KMS.
        """
        return pulumi.get(self, "kms_key_self_link")

    @_builtins.property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> _builtins.str:
        """
        The service account used for the encryption request for the given KMS key.
        If absent, the Compute Engine Service Agent service account is used.
        """
        return pulumi.get(self, "kms_key_service_account")

    @_builtins.property
    @pulumi.getter(name="rawKey")
    def raw_key(self) -> _builtins.str:
        """
        Specifies a 256-bit customer-supplied encryption key, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "raw_key")

    @_builtins.property
    @pulumi.getter(name="rsaEncryptedKey")
    def rsa_encrypted_key(self) -> _builtins.str:
        """
        Specifies an encryption key stored in Google Cloud KMS, encoded in
        RFC 4648 base64 to either encrypt or decrypt this resource.
        """
        return pulumi.get(self, "rsa_encrypted_key")


@pulumi.output_type
class GetStoragePoolResourceStatusResult(dict):
    def __init__(__self__, *,
                 disk_count: _builtins.str,
                 last_resize_timestamp: _builtins.str,
                 max_total_provisioned_disk_capacity_gb: _builtins.str,
                 pool_used_capacity_bytes: _builtins.str,
                 pool_used_iops: _builtins.str,
                 pool_used_throughput: _builtins.str,
                 pool_user_written_bytes: _builtins.str,
                 total_provisioned_disk_capacity_gb: _builtins.str,
                 total_provisioned_disk_iops: _builtins.str,
                 total_provisioned_disk_throughput: _builtins.str):
        """
        :param _builtins.str disk_count: Number of disks used.
        :param _builtins.str last_resize_timestamp: Timestamp of the last successful resize in RFC3339 text format.
        :param _builtins.str max_total_provisioned_disk_capacity_gb: Maximum allowed aggregate disk size in gigabytes.
        :param _builtins.str pool_used_capacity_bytes: Space used by data stored in disks within the storage pool (in bytes).
               This will reflect the total number of bytes written to the disks in the pool,
               in contrast to the capacity of those disks.
        :param _builtins.str pool_used_iops: Sum of all the disks' provisioned IOPS, minus some amount
               that is allowed per disk that is not counted towards pool's IOPS capacity.
               For more information, see https://cloud.google.com/compute/docs/disks/storage-pools.
        :param _builtins.str pool_used_throughput: Sum of all the disks' provisioned throughput in MB/s.
        :param _builtins.str pool_user_written_bytes: Amount of data written into the pool, before it is compacted.
        :param _builtins.str total_provisioned_disk_capacity_gb: Sum of all the capacity provisioned in disks in this storage pool.
               A disk's provisioned capacity is the same as its total capacity.
        :param _builtins.str total_provisioned_disk_iops: Sum of all the disks' provisioned IOPS.
        :param _builtins.str total_provisioned_disk_throughput: Sum of all the disks' provisioned throughput in MB/s,
               minus some amount that is allowed per disk that is not counted towards pool's throughput capacity.
        """
        pulumi.set(__self__, "disk_count", disk_count)
        pulumi.set(__self__, "last_resize_timestamp", last_resize_timestamp)
        pulumi.set(__self__, "max_total_provisioned_disk_capacity_gb", max_total_provisioned_disk_capacity_gb)
        pulumi.set(__self__, "pool_used_capacity_bytes", pool_used_capacity_bytes)
        pulumi.set(__self__, "pool_used_iops", pool_used_iops)
        pulumi.set(__self__, "pool_used_throughput", pool_used_throughput)
        pulumi.set(__self__, "pool_user_written_bytes", pool_user_written_bytes)
        pulumi.set(__self__, "total_provisioned_disk_capacity_gb", total_provisioned_disk_capacity_gb)
        pulumi.set(__self__, "total_provisioned_disk_iops", total_provisioned_disk_iops)
        pulumi.set(__self__, "total_provisioned_disk_throughput", total_provisioned_disk_throughput)

    @_builtins.property
    @pulumi.getter(name="diskCount")
    def disk_count(self) -> _builtins.str:
        """
        Number of disks used.
        """
        return pulumi.get(self, "disk_count")

    @_builtins.property
    @pulumi.getter(name="lastResizeTimestamp")
    def last_resize_timestamp(self) -> _builtins.str:
        """
        Timestamp of the last successful resize in RFC3339 text format.
        """
        return pulumi.get(self, "last_resize_timestamp")

    @_builtins.property
    @pulumi.getter(name="maxTotalProvisionedDiskCapacityGb")
    def max_total_provisioned_disk_capacity_gb(self) -> _builtins.str:
        """
        Maximum allowed aggregate disk size in gigabytes.
        """
        return pulumi.get(self, "max_total_provisioned_disk_capacity_gb")

    @_builtins.property
    @pulumi.getter(name="poolUsedCapacityBytes")
    def pool_used_capacity_bytes(self) -> _builtins.str:
        """
        Space used by data stored in disks within the storage pool (in bytes).
        This will reflect the total number of bytes written to the disks in the pool,
        in contrast to the capacity of those disks.
        """
        return pulumi.get(self, "pool_used_capacity_bytes")

    @_builtins.property
    @pulumi.getter(name="poolUsedIops")
    def pool_used_iops(self) -> _builtins.str:
        """
        Sum of all the disks' provisioned IOPS, minus some amount
        that is allowed per disk that is not counted towards pool's IOPS capacity.
        For more information, see https://cloud.google.com/compute/docs/disks/storage-pools.
        """
        return pulumi.get(self, "pool_used_iops")

    @_builtins.property
    @pulumi.getter(name="poolUsedThroughput")
    def pool_used_throughput(self) -> _builtins.str:
        """
        Sum of all the disks' provisioned throughput in MB/s.
        """
        return pulumi.get(self, "pool_used_throughput")

    @_builtins.property
    @pulumi.getter(name="poolUserWrittenBytes")
    def pool_user_written_bytes(self) -> _builtins.str:
        """
        Amount of data written into the pool, before it is compacted.
        """
        return pulumi.get(self, "pool_user_written_bytes")

    @_builtins.property
    @pulumi.getter(name="totalProvisionedDiskCapacityGb")
    def total_provisioned_disk_capacity_gb(self) -> _builtins.str:
        """
        Sum of all the capacity provisioned in disks in this storage pool.
        A disk's provisioned capacity is the same as its total capacity.
        """
        return pulumi.get(self, "total_provisioned_disk_capacity_gb")

    @_builtins.property
    @pulumi.getter(name="totalProvisionedDiskIops")
    def total_provisioned_disk_iops(self) -> _builtins.str:
        """
        Sum of all the disks' provisioned IOPS.
        """
        return pulumi.get(self, "total_provisioned_disk_iops")

    @_builtins.property
    @pulumi.getter(name="totalProvisionedDiskThroughput")
    def total_provisioned_disk_throughput(self) -> _builtins.str:
        """
        Sum of all the disks' provisioned throughput in MB/s,
        minus some amount that is allowed per disk that is not counted towards pool's throughput capacity.
        """
        return pulumi.get(self, "total_provisioned_disk_throughput")


@pulumi.output_type
class GetStoragePoolStatusResult(dict):
    def __init__(__self__, *,
                 disk_count: _builtins.str,
                 last_resize_timestamp: _builtins.str,
                 max_total_provisioned_disk_capacity_gb: _builtins.str,
                 pool_used_capacity_bytes: _builtins.str,
                 pool_used_iops: _builtins.str,
                 pool_used_throughput: _builtins.str,
                 pool_user_written_bytes: _builtins.str,
                 total_provisioned_disk_capacity_gb: _builtins.str,
                 total_provisioned_disk_iops: _builtins.str,
                 total_provisioned_disk_throughput: _builtins.str):
        """
        :param _builtins.str disk_count: Number of disks used.
        :param _builtins.str last_resize_timestamp: Timestamp of the last successful resize in RFC3339 text format.
        :param _builtins.str max_total_provisioned_disk_capacity_gb: Maximum allowed aggregate disk size in gigabytes.
        :param _builtins.str pool_used_capacity_bytes: Space used by data stored in disks within the storage pool (in bytes).
               This will reflect the total number of bytes written to the disks in the pool, in contrast to the capacity of those disks.
        :param _builtins.str pool_used_iops: Sum of all the disks' provisioned IOPS, minus some amount that is allowed per disk that is not counted towards pool's IOPS capacity. For more information, see https://cloud.google.com/compute/docs/disks/storage-pools.
        :param _builtins.str pool_used_throughput: Sum of all the disks' provisioned throughput in MB/s.
        :param _builtins.str pool_user_written_bytes: Amount of data written into the pool, before it is compacted.
        :param _builtins.str total_provisioned_disk_capacity_gb: Sum of all the capacity provisioned in disks in this storage pool.
               A disk's provisioned capacity is the same as its total capacity.
        :param _builtins.str total_provisioned_disk_iops: Sum of all the disks' provisioned IOPS.
        :param _builtins.str total_provisioned_disk_throughput: Sum of all the disks' provisioned throughput in MB/s,
               minus some amount that is allowed per disk that is not counted towards pool's throughput capacity.
        """
        pulumi.set(__self__, "disk_count", disk_count)
        pulumi.set(__self__, "last_resize_timestamp", last_resize_timestamp)
        pulumi.set(__self__, "max_total_provisioned_disk_capacity_gb", max_total_provisioned_disk_capacity_gb)
        pulumi.set(__self__, "pool_used_capacity_bytes", pool_used_capacity_bytes)
        pulumi.set(__self__, "pool_used_iops", pool_used_iops)
        pulumi.set(__self__, "pool_used_throughput", pool_used_throughput)
        pulumi.set(__self__, "pool_user_written_bytes", pool_user_written_bytes)
        pulumi.set(__self__, "total_provisioned_disk_capacity_gb", total_provisioned_disk_capacity_gb)
        pulumi.set(__self__, "total_provisioned_disk_iops", total_provisioned_disk_iops)
        pulumi.set(__self__, "total_provisioned_disk_throughput", total_provisioned_disk_throughput)

    @_builtins.property
    @pulumi.getter(name="diskCount")
    def disk_count(self) -> _builtins.str:
        """
        Number of disks used.
        """
        return pulumi.get(self, "disk_count")

    @_builtins.property
    @pulumi.getter(name="lastResizeTimestamp")
    def last_resize_timestamp(self) -> _builtins.str:
        """
        Timestamp of the last successful resize in RFC3339 text format.
        """
        return pulumi.get(self, "last_resize_timestamp")

    @_builtins.property
    @pulumi.getter(name="maxTotalProvisionedDiskCapacityGb")
    def max_total_provisioned_disk_capacity_gb(self) -> _builtins.str:
        """
        Maximum allowed aggregate disk size in gigabytes.
        """
        return pulumi.get(self, "max_total_provisioned_disk_capacity_gb")

    @_builtins.property
    @pulumi.getter(name="poolUsedCapacityBytes")
    def pool_used_capacity_bytes(self) -> _builtins.str:
        """
        Space used by data stored in disks within the storage pool (in bytes).
        This will reflect the total number of bytes written to the disks in the pool, in contrast to the capacity of those disks.
        """
        return pulumi.get(self, "pool_used_capacity_bytes")

    @_builtins.property
    @pulumi.getter(name="poolUsedIops")
    def pool_used_iops(self) -> _builtins.str:
        """
        Sum of all the disks' provisioned IOPS, minus some amount that is allowed per disk that is not counted towards pool's IOPS capacity. For more information, see https://cloud.google.com/compute/docs/disks/storage-pools.
        """
        return pulumi.get(self, "pool_used_iops")

    @_builtins.property
    @pulumi.getter(name="poolUsedThroughput")
    def pool_used_throughput(self) -> _builtins.str:
        """
        Sum of all the disks' provisioned throughput in MB/s.
        """
        return pulumi.get(self, "pool_used_throughput")

    @_builtins.property
    @pulumi.getter(name="poolUserWrittenBytes")
    def pool_user_written_bytes(self) -> _builtins.str:
        """
        Amount of data written into the pool, before it is compacted.
        """
        return pulumi.get(self, "pool_user_written_bytes")

    @_builtins.property
    @pulumi.getter(name="totalProvisionedDiskCapacityGb")
    def total_provisioned_disk_capacity_gb(self) -> _builtins.str:
        """
        Sum of all the capacity provisioned in disks in this storage pool.
        A disk's provisioned capacity is the same as its total capacity.
        """
        return pulumi.get(self, "total_provisioned_disk_capacity_gb")

    @_builtins.property
    @pulumi.getter(name="totalProvisionedDiskIops")
    def total_provisioned_disk_iops(self) -> _builtins.str:
        """
        Sum of all the disks' provisioned IOPS.
        """
        return pulumi.get(self, "total_provisioned_disk_iops")

    @_builtins.property
    @pulumi.getter(name="totalProvisionedDiskThroughput")
    def total_provisioned_disk_throughput(self) -> _builtins.str:
        """
        Sum of all the disks' provisioned throughput in MB/s,
        minus some amount that is allowed per disk that is not counted towards pool's throughput capacity.
        """
        return pulumi.get(self, "total_provisioned_disk_throughput")


@pulumi.output_type
class GetStoragePoolTypesDeprecatedResult(dict):
    def __init__(__self__, *,
                 deleted: _builtins.str,
                 deprecated: _builtins.str,
                 obsolete: _builtins.str,
                 replacement: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str deleted: An optional RFC3339 timestamp on or after which the state of this resource is intended to change to DELETED.
               This is only informational and the status will not change unless the client explicitly changes it.
        :param _builtins.str deprecated: An optional RFC3339 timestamp on or after which the state of this resource is intended to change to DEPRECATED.
               This is only informational and the status will not change unless the client explicitly changes it.
        :param _builtins.str obsolete: An optional RFC3339 timestamp on or after which the state of this resource is intended to change to OBSOLETE.
               This is only informational and the status will not change unless the client explicitly changes it.
        :param _builtins.str replacement: The URL of the suggested replacement for a deprecated resource.
               The suggested replacement resource must be the same kind of resource as the deprecated resource.
        :param _builtins.str state: The deprecation state of this resource. This can be ACTIVE, DEPRECATED, OBSOLETE, or DELETED.
               Operations which communicate the end of life date for an image, can use ACTIVE.
               Operations which create a new resource using a DEPRECATED resource will return successfully,
               but with a warning indicating the deprecated resource and recommending its replacement.
               Operations which use OBSOLETE or DELETED resources will be rejected and result in an error.
        """
        pulumi.set(__self__, "deleted", deleted)
        pulumi.set(__self__, "deprecated", deprecated)
        pulumi.set(__self__, "obsolete", obsolete)
        pulumi.set(__self__, "replacement", replacement)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def deleted(self) -> _builtins.str:
        """
        An optional RFC3339 timestamp on or after which the state of this resource is intended to change to DELETED.
        This is only informational and the status will not change unless the client explicitly changes it.
        """
        return pulumi.get(self, "deleted")

    @_builtins.property
    @pulumi.getter
    def deprecated(self) -> _builtins.str:
        """
        An optional RFC3339 timestamp on or after which the state of this resource is intended to change to DEPRECATED.
        This is only informational and the status will not change unless the client explicitly changes it.
        """
        return pulumi.get(self, "deprecated")

    @_builtins.property
    @pulumi.getter
    def obsolete(self) -> _builtins.str:
        """
        An optional RFC3339 timestamp on or after which the state of this resource is intended to change to OBSOLETE.
        This is only informational and the status will not change unless the client explicitly changes it.
        """
        return pulumi.get(self, "obsolete")

    @_builtins.property
    @pulumi.getter
    def replacement(self) -> _builtins.str:
        """
        The URL of the suggested replacement for a deprecated resource.
        The suggested replacement resource must be the same kind of resource as the deprecated resource.
        """
        return pulumi.get(self, "replacement")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The deprecation state of this resource. This can be ACTIVE, DEPRECATED, OBSOLETE, or DELETED.
        Operations which communicate the end of life date for an image, can use ACTIVE.
        Operations which create a new resource using a DEPRECATED resource will return successfully,
        but with a warning indicating the deprecated resource and recommending its replacement.
        Operations which use OBSOLETE or DELETED resources will be rejected and result in an error.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetSubnetworkSecondaryIpRangeResult(dict):
    def __init__(__self__, *,
                 ip_cidr_range: _builtins.str,
                 range_name: _builtins.str):
        """
        :param _builtins.str ip_cidr_range: The range of IP addresses belonging to this subnetwork
               secondary range.
        :param _builtins.str range_name: The name associated with this subnetwork secondary range, used
               when adding an alias IP range to a VM instance.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        pulumi.set(__self__, "range_name", range_name)

    @_builtins.property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> _builtins.str:
        """
        The range of IP addresses belonging to this subnetwork
        secondary range.
        """
        return pulumi.get(self, "ip_cidr_range")

    @_builtins.property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> _builtins.str:
        """
        The name associated with this subnetwork secondary range, used
        when adding an alias IP range to a VM instance.
        """
        return pulumi.get(self, "range_name")


@pulumi.output_type
class GetSubnetworksSubnetworkResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 ip_cidr_range: _builtins.str,
                 name: _builtins.str,
                 network: _builtins.str,
                 network_name: _builtins.str,
                 network_self_link: _builtins.str,
                 private_ip_google_access: _builtins.bool,
                 self_link: _builtins.str):
        """
        :param _builtins.str description: Description of the subnetwork.
        :param _builtins.str ip_cidr_range: The IP address range represented as a CIDR block.
        :param _builtins.str name: The name of the subnetwork.
        :param _builtins.str network: The self link of the parent network.
        :param _builtins.str network_name: The name of the parent network computed from `network` attribute.
        :param _builtins.str network_self_link: (Deprecated) The name of the parent network computed from `network` attribute. (deprecated and will be removed in a future major release. Use `network_name` instead.)
        :param _builtins.bool private_ip_google_access: Whether the VMs in the subnet can access Google services without assigned external IP addresses.
        :param _builtins.str self_link: The self link of the subnetwork.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "network_self_link", network_self_link)
        pulumi.set(__self__, "private_ip_google_access", private_ip_google_access)
        pulumi.set(__self__, "self_link", self_link)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the subnetwork.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> _builtins.str:
        """
        The IP address range represented as a CIDR block.
        """
        return pulumi.get(self, "ip_cidr_range")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the subnetwork.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The self link of the parent network.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> _builtins.str:
        """
        The name of the parent network computed from `network` attribute.
        """
        return pulumi.get(self, "network_name")

    @_builtins.property
    @pulumi.getter(name="networkSelfLink")
    @_utilities.deprecated("""Use `network_name` instead. This field will be removed in a future major release.""")
    def network_self_link(self) -> _builtins.str:
        """
        (Deprecated) The name of the parent network computed from `network` attribute. (deprecated and will be removed in a future major release. Use `network_name` instead.)
        """
        return pulumi.get(self, "network_self_link")

    @_builtins.property
    @pulumi.getter(name="privateIpGoogleAccess")
    def private_ip_google_access(self) -> _builtins.bool:
        """
        Whether the VMs in the subnet can access Google services without assigned external IP addresses.
        """
        return pulumi.get(self, "private_ip_google_access")

    @_builtins.property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> _builtins.str:
        """
        The self link of the subnetwork.
        """
        return pulumi.get(self, "self_link")


