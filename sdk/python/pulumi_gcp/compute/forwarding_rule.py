# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import pulumi
import pulumi.runtime

class ForwardingRule(pulumi.CustomResource):
    """
    Manages a Forwarding Rule within GCE. This binds an ip and port range to a target pool. For more
    information see [the official
    documentation](https://cloud.google.com/compute/docs/load-balancing/network/forwarding-rules) and
    [API](https://cloud.google.com/compute/docs/reference/latest/forwardingRules).
    """
    def __init__(__self__, __name__, __opts__=None, backend_service=None, description=None, ip_address=None, ip_protocol=None, load_balancing_scheme=None, name=None, network=None, port_range=None, ports=None, project=None, region=None, subnetwork=None, target=None):
        """Create a ForwardingRule resource with the given unique name, props, and options."""
        if not __name__:
            raise TypeError('Missing resource name argument (for URN creation)')
        if not isinstance(__name__, basestring):
            raise TypeError('Expected resource name to be a string')
        if __opts__ and not isinstance(__opts__, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')

        __props__ = dict()

        if backend_service and not isinstance(backend_service, basestring):
            raise TypeError('Expected property backend_service to be a basestring')
        __self__.backend_service = backend_service
        """
        BackendService resource to receive the
        matched traffic. Only used for internal load balancing.
        """
        __props__['backendService'] = backend_service

        if description and not isinstance(description, basestring):
            raise TypeError('Expected property description to be a basestring')
        __self__.description = description
        """
        Textual description field.
        """
        __props__['description'] = description

        if ip_address and not isinstance(ip_address, basestring):
            raise TypeError('Expected property ip_address to be a basestring')
        __self__.ip_address = ip_address
        """
        The static IP. (if not set, an ephemeral IP is
        used).
        """
        __props__['ipAddress'] = ip_address

        if ip_protocol and not isinstance(ip_protocol, basestring):
            raise TypeError('Expected property ip_protocol to be a basestring')
        __self__.ip_protocol = ip_protocol
        """
        The IP protocol to route, one of "TCP" "UDP" "AH"
        "ESP" or "SCTP" for external load balancing, "TCP" or "UDP" for internal
        (default "TCP").
        """
        __props__['ipProtocol'] = ip_protocol

        if load_balancing_scheme and not isinstance(load_balancing_scheme, basestring):
            raise TypeError('Expected property load_balancing_scheme to be a basestring')
        __self__.load_balancing_scheme = load_balancing_scheme
        """
        Type of load balancing to use. Can be
        set to "INTERNAL" or "EXTERNAL" (default "EXTERNAL").
        """
        __props__['loadBalancingScheme'] = load_balancing_scheme

        if name and not isinstance(name, basestring):
            raise TypeError('Expected property name to be a basestring')
        __self__.name = name
        """
        A unique name for the resource, required by GCE. Changing
        this forces a new resource to be created.
        """
        __props__['name'] = name

        if network and not isinstance(network, basestring):
            raise TypeError('Expected property network to be a basestring')
        __self__.network = network
        """
        Network name or self_link that the load balanced IP
        should belong to. Only used for internal load balancing. If it is not
        provided, the default network is used.
        """
        __props__['network'] = network

        if port_range and not isinstance(port_range, basestring):
            raise TypeError('Expected property port_range to be a basestring')
        __self__.port_range = port_range
        """
        A range e.g. "1024-2048" or a single port "1024"
        (defaults to all ports!). Only used for external load balancing.
        Some types of forwarding targets have constraints on the acceptable ports:
        * Target HTTP proxy: 80, 8080
        * Target HTTPS proxy: 443
        * Target TCP proxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1883, 5222
        * Target SSL proxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1883, 5222
        * Target VPN gateway: 500, 4500
        """
        __props__['portRange'] = port_range

        if ports and not isinstance(ports, list):
            raise TypeError('Expected property ports to be a list')
        __self__.ports = ports
        """
        A list of ports (maximum of 5) to use for internal load
        balancing. Packets addressed to these ports will be forwarded to the backends
        configured with this forwarding rule. Required for internal load balancing.
        """
        __props__['ports'] = ports

        if project and not isinstance(project, basestring):
            raise TypeError('Expected property project to be a basestring')
        __self__.project = project
        """
        The ID of project in which the resource belongs. If it
        is not provided, the provider project is used.
        """
        __props__['project'] = project

        if region and not isinstance(region, basestring):
            raise TypeError('Expected property region to be a basestring')
        __self__.region = region
        """
        The Region in which the created address should reside.
        If it is not provided, the provider region is used.
        """
        __props__['region'] = region

        if subnetwork and not isinstance(subnetwork, basestring):
            raise TypeError('Expected property subnetwork to be a basestring')
        __self__.subnetwork = subnetwork
        """
        Subnetwork that the load balanced IP should belong
        to. Only used for internal load balancing. Must be specified if the network
        is in custom subnet mode.
        """
        __props__['subnetwork'] = subnetwork

        if target and not isinstance(target, basestring):
            raise TypeError('Expected property target to be a basestring')
        __self__.target = target
        """
        URL of target pool. Required for external load
        balancing.
        """
        __props__['target'] = target

        __self__.self_link = pulumi.runtime.UNKNOWN
        """
        The URI of the created resource.
        """

        super(ForwardingRule, __self__).__init__(
            'gcp:compute/forwardingRule:ForwardingRule',
            __name__,
            __props__,
            __opts__)

    def set_outputs(self, outs):
        if 'backendService' in outs:
            self.backend_service = outs['backendService']
        if 'description' in outs:
            self.description = outs['description']
        if 'ipAddress' in outs:
            self.ip_address = outs['ipAddress']
        if 'ipProtocol' in outs:
            self.ip_protocol = outs['ipProtocol']
        if 'loadBalancingScheme' in outs:
            self.load_balancing_scheme = outs['loadBalancingScheme']
        if 'name' in outs:
            self.name = outs['name']
        if 'network' in outs:
            self.network = outs['network']
        if 'portRange' in outs:
            self.port_range = outs['portRange']
        if 'ports' in outs:
            self.ports = outs['ports']
        if 'project' in outs:
            self.project = outs['project']
        if 'region' in outs:
            self.region = outs['region']
        if 'selfLink' in outs:
            self.self_link = outs['selfLink']
        if 'subnetwork' in outs:
            self.subnetwork = outs['subnetwork']
        if 'target' in outs:
            self.target = outs['target']
