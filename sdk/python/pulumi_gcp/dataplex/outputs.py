# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AspectTypeIamBindingCondition',
    'AspectTypeIamMemberCondition',
    'AssetDiscoverySpec',
    'AssetDiscoverySpecCsvOptions',
    'AssetDiscoverySpecJsonOptions',
    'AssetDiscoveryStatus',
    'AssetDiscoveryStatusStat',
    'AssetIamBindingCondition',
    'AssetIamMemberCondition',
    'AssetResourceSpec',
    'AssetResourceStatus',
    'AssetSecurityStatus',
    'DatascanData',
    'DatascanDataDiscoverySpec',
    'DatascanDataDiscoverySpecBigqueryPublishingConfig',
    'DatascanDataDiscoverySpecStorageConfig',
    'DatascanDataDiscoverySpecStorageConfigCsvOptions',
    'DatascanDataDiscoverySpecStorageConfigJsonOptions',
    'DatascanDataProfileSpec',
    'DatascanDataProfileSpecExcludeFields',
    'DatascanDataProfileSpecIncludeFields',
    'DatascanDataProfileSpecPostScanActions',
    'DatascanDataProfileSpecPostScanActionsBigqueryExport',
    'DatascanDataQualitySpec',
    'DatascanDataQualitySpecPostScanActions',
    'DatascanDataQualitySpecPostScanActionsBigqueryExport',
    'DatascanDataQualitySpecPostScanActionsNotificationReport',
    'DatascanDataQualitySpecPostScanActionsNotificationReportJobEndTrigger',
    'DatascanDataQualitySpecPostScanActionsNotificationReportJobFailureTrigger',
    'DatascanDataQualitySpecPostScanActionsNotificationReportRecipients',
    'DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger',
    'DatascanDataQualitySpecRule',
    'DatascanDataQualitySpecRuleNonNullExpectation',
    'DatascanDataQualitySpecRuleRangeExpectation',
    'DatascanDataQualitySpecRuleRegexExpectation',
    'DatascanDataQualitySpecRuleRowConditionExpectation',
    'DatascanDataQualitySpecRuleSetExpectation',
    'DatascanDataQualitySpecRuleSqlAssertion',
    'DatascanDataQualitySpecRuleStatisticRangeExpectation',
    'DatascanDataQualitySpecRuleTableConditionExpectation',
    'DatascanDataQualitySpecRuleUniquenessExpectation',
    'DatascanExecutionSpec',
    'DatascanExecutionSpecTrigger',
    'DatascanExecutionSpecTriggerOnDemand',
    'DatascanExecutionSpecTriggerSchedule',
    'DatascanExecutionStatus',
    'DatascanIamBindingCondition',
    'DatascanIamMemberCondition',
    'EntryAspect',
    'EntryAspectAspect',
    'EntryEntrySource',
    'EntryEntrySourceAncestor',
    'EntryGroupIamBindingCondition',
    'EntryGroupIamMemberCondition',
    'EntryTypeIamBindingCondition',
    'EntryTypeIamMemberCondition',
    'EntryTypeRequiredAspect',
    'GlossaryIamBindingCondition',
    'GlossaryIamMemberCondition',
    'LakeAssetStatus',
    'LakeIamBindingCondition',
    'LakeIamMemberCondition',
    'LakeMetastore',
    'LakeMetastoreStatus',
    'TaskExecutionSpec',
    'TaskExecutionStatus',
    'TaskExecutionStatusLatestJob',
    'TaskIamBindingCondition',
    'TaskIamMemberCondition',
    'TaskNotebook',
    'TaskNotebookInfrastructureSpec',
    'TaskNotebookInfrastructureSpecBatch',
    'TaskNotebookInfrastructureSpecContainerImage',
    'TaskNotebookInfrastructureSpecVpcNetwork',
    'TaskSpark',
    'TaskSparkInfrastructureSpec',
    'TaskSparkInfrastructureSpecBatch',
    'TaskSparkInfrastructureSpecContainerImage',
    'TaskSparkInfrastructureSpecVpcNetwork',
    'TaskTriggerSpec',
    'ZoneAssetStatus',
    'ZoneDiscoverySpec',
    'ZoneDiscoverySpecCsvOptions',
    'ZoneDiscoverySpecJsonOptions',
    'ZoneIamBindingCondition',
    'ZoneIamMemberCondition',
    'ZoneResourceSpec',
    'GetDataQualityRulesRuleResult',
    'GetDataQualityRulesRuleNonNullExpectationResult',
    'GetDataQualityRulesRuleRangeExpectationResult',
    'GetDataQualityRulesRuleRegexExpectationResult',
    'GetDataQualityRulesRuleRowConditionExpectationResult',
    'GetDataQualityRulesRuleSetExpectationResult',
    'GetDataQualityRulesRuleSqlAssertionResult',
    'GetDataQualityRulesRuleStatisticRangeExpectationResult',
    'GetDataQualityRulesRuleTableConditionExpectationResult',
    'GetDataQualityRulesRuleUniquenessExpectationResult',
]

@pulumi.output_type
class AspectTypeIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class AspectTypeIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class AssetDiscoverySpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "csvOptions":
            suggest = "csv_options"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"
        elif key == "jsonOptions":
            suggest = "json_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetDiscoverySpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetDiscoverySpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetDiscoverySpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 csv_options: Optional['outputs.AssetDiscoverySpecCsvOptions'] = None,
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None,
                 json_options: Optional['outputs.AssetDiscoverySpecJsonOptions'] = None,
                 schedule: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Required. Whether discovery is enabled.
        :param 'AssetDiscoverySpecCsvOptionsArgs' csv_options: Optional. Configuration for CSV data.
        :param Sequence[_builtins.str] exclude_patterns: Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param Sequence[_builtins.str] include_patterns: Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param 'AssetDiscoverySpecJsonOptionsArgs' json_options: Optional. Configuration for Json data.
        :param _builtins.str schedule: Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        pulumi.set(__self__, "enabled", enabled)
        if csv_options is not None:
            pulumi.set(__self__, "csv_options", csv_options)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if json_options is not None:
            pulumi.set(__self__, "json_options", json_options)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Required. Whether discovery is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="csvOptions")
    def csv_options(self) -> Optional['outputs.AssetDiscoverySpecCsvOptions']:
        """
        Optional. Configuration for CSV data.
        """
        return pulumi.get(self, "csv_options")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "include_patterns")

    @_builtins.property
    @pulumi.getter(name="jsonOptions")
    def json_options(self) -> Optional['outputs.AssetDiscoverySpecJsonOptions']:
        """
        Optional. Configuration for Json data.
        """
        return pulumi.get(self, "json_options")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional[_builtins.str]:
        """
        Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class AssetDiscoverySpecCsvOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableTypeInference":
            suggest = "disable_type_inference"
        elif key == "headerRows":
            suggest = "header_rows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetDiscoverySpecCsvOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetDiscoverySpecCsvOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetDiscoverySpecCsvOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[_builtins.str] = None,
                 disable_type_inference: Optional[_builtins.bool] = None,
                 encoding: Optional[_builtins.str] = None,
                 header_rows: Optional[_builtins.int] = None):
        """
        :param _builtins.str delimiter: Optional. The delimiter being used to separate values. This defaults to ','.
        :param _builtins.bool disable_type_inference: Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        :param _builtins.str encoding: Optional. The character encoding of the data. The default is UTF-8.
        :param _builtins.int header_rows: Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if header_rows is not None:
            pulumi.set(__self__, "header_rows", header_rows)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[_builtins.str]:
        """
        Optional. The delimiter being used to separate values. This defaults to ','.
        """
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[_builtins.bool]:
        """
        Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        """
        return pulumi.get(self, "disable_type_inference")

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> Optional[_builtins.str]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @_builtins.property
    @pulumi.getter(name="headerRows")
    def header_rows(self) -> Optional[_builtins.int]:
        """
        Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        return pulumi.get(self, "header_rows")


@pulumi.output_type
class AssetDiscoverySpecJsonOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableTypeInference":
            suggest = "disable_type_inference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetDiscoverySpecJsonOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetDiscoverySpecJsonOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetDiscoverySpecJsonOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_type_inference: Optional[_builtins.bool] = None,
                 encoding: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disable_type_inference: Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        :param _builtins.str encoding: Optional. The character encoding of the data. The default is UTF-8.
        """
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @_builtins.property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[_builtins.bool]:
        """
        Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        """
        return pulumi.get(self, "disable_type_inference")

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> Optional[_builtins.str]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")


@pulumi.output_type
class AssetDiscoveryStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastRunDuration":
            suggest = "last_run_duration"
        elif key == "lastRunTime":
            suggest = "last_run_time"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetDiscoveryStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetDiscoveryStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetDiscoveryStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_run_duration: Optional[_builtins.str] = None,
                 last_run_time: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 stats: Optional[Sequence['outputs.AssetDiscoveryStatusStat']] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str last_run_duration: The duration of the last discovery run.
        :param _builtins.str last_run_time: The start time of the last discovery run.
        :param _builtins.str message: Additional information about the current state.
        :param _builtins.str state: Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param Sequence['AssetDiscoveryStatusStatArgs'] stats: Data Stats of the asset reported by discovery.
        :param _builtins.str update_time: Output only. The time when the asset was last updated.
        """
        if last_run_duration is not None:
            pulumi.set(__self__, "last_run_duration", last_run_duration)
        if last_run_time is not None:
            pulumi.set(__self__, "last_run_time", last_run_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if stats is not None:
            pulumi.set(__self__, "stats", stats)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="lastRunDuration")
    def last_run_duration(self) -> Optional[_builtins.str]:
        """
        The duration of the last discovery run.
        """
        return pulumi.get(self, "last_run_duration")

    @_builtins.property
    @pulumi.getter(name="lastRunTime")
    def last_run_time(self) -> Optional[_builtins.str]:
        """
        The start time of the last discovery run.
        """
        return pulumi.get(self, "last_run_time")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Additional information about the current state.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def stats(self) -> Optional[Sequence['outputs.AssetDiscoveryStatusStat']]:
        """
        Data Stats of the asset reported by discovery.
        """
        return pulumi.get(self, "stats")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        Output only. The time when the asset was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class AssetDiscoveryStatusStat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataItems":
            suggest = "data_items"
        elif key == "dataSize":
            suggest = "data_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetDiscoveryStatusStat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetDiscoveryStatusStat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetDiscoveryStatusStat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_items: Optional[_builtins.int] = None,
                 data_size: Optional[_builtins.int] = None,
                 filesets: Optional[_builtins.int] = None,
                 tables: Optional[_builtins.int] = None):
        """
        :param _builtins.int data_items: The count of data items within the referenced resource.
        :param _builtins.int data_size: The number of stored data bytes within the referenced resource.
        :param _builtins.int filesets: The count of fileset entities within the referenced resource.
        :param _builtins.int tables: The count of table entities within the referenced resource.
        """
        if data_items is not None:
            pulumi.set(__self__, "data_items", data_items)
        if data_size is not None:
            pulumi.set(__self__, "data_size", data_size)
        if filesets is not None:
            pulumi.set(__self__, "filesets", filesets)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter(name="dataItems")
    def data_items(self) -> Optional[_builtins.int]:
        """
        The count of data items within the referenced resource.
        """
        return pulumi.get(self, "data_items")

    @_builtins.property
    @pulumi.getter(name="dataSize")
    def data_size(self) -> Optional[_builtins.int]:
        """
        The number of stored data bytes within the referenced resource.
        """
        return pulumi.get(self, "data_size")

    @_builtins.property
    @pulumi.getter
    def filesets(self) -> Optional[_builtins.int]:
        """
        The count of fileset entities within the referenced resource.
        """
        return pulumi.get(self, "filesets")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[_builtins.int]:
        """
        The count of table entities within the referenced resource.
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class AssetIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class AssetIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class AssetResourceSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readAccessMode":
            suggest = "read_access_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetResourceSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetResourceSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetResourceSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 read_access_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Required. Immutable. Type of resource. Possible values: STORAGE_BUCKET, BIGQUERY_DATASET
               
               - - -
        :param _builtins.str name: Immutable. Relative name of the cloud resource that contains the data that is being managed within a lake. For example: `projects/{project_number}/buckets/{bucket_id}` `projects/{project_number}/datasets/{dataset_id}`
        :param _builtins.str read_access_mode: Optional. Determines how read permissions are handled for each asset and their associated tables. Only available to storage buckets assets. Possible values: DIRECT, MANAGED
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if read_access_mode is not None:
            pulumi.set(__self__, "read_access_mode", read_access_mode)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Required. Immutable. Type of resource. Possible values: STORAGE_BUCKET, BIGQUERY_DATASET

        - - -
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Immutable. Relative name of the cloud resource that contains the data that is being managed within a lake. For example: `projects/{project_number}/buckets/{bucket_id}` `projects/{project_number}/datasets/{dataset_id}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="readAccessMode")
    def read_access_mode(self) -> Optional[_builtins.str]:
        """
        Optional. Determines how read permissions are handled for each asset and their associated tables. Only available to storage buckets assets. Possible values: DIRECT, MANAGED
        """
        return pulumi.get(self, "read_access_mode")


@pulumi.output_type
class AssetResourceStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetResourceStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetResourceStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetResourceStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str message: Additional information about the current state.
        :param _builtins.str state: Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param _builtins.str update_time: Output only. The time when the asset was last updated.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Additional information about the current state.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        Output only. The time when the asset was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class AssetSecurityStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetSecurityStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetSecurityStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetSecurityStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str message: Additional information about the current state.
        :param _builtins.str state: Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param _builtins.str update_time: Output only. The time when the asset was last updated.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Additional information about the current state.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        Output only. The time when the asset was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class DatascanData(dict):
    def __init__(__self__, *,
                 entity: Optional[_builtins.str] = None,
                 resource: Optional[_builtins.str] = None):
        """
        :param _builtins.str entity: The Dataplex entity that represents the data source(e.g. BigQuery table) for Datascan.
        :param _builtins.str resource: The service-qualified full resource name of the cloud resource for a DataScan job to scan against. The field could be:
               Cloud Storage bucket (//storage.googleapis.com/projects/PROJECT_ID/buckets/BUCKET_ID) for DataDiscoveryScan OR BigQuery table of type "TABLE" (/bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID) for DataProfileScan/DataQualityScan.
        """
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @_builtins.property
    @pulumi.getter
    def entity(self) -> Optional[_builtins.str]:
        """
        The Dataplex entity that represents the data source(e.g. BigQuery table) for Datascan.
        """
        return pulumi.get(self, "entity")

    @_builtins.property
    @pulumi.getter
    def resource(self) -> Optional[_builtins.str]:
        """
        The service-qualified full resource name of the cloud resource for a DataScan job to scan against. The field could be:
        Cloud Storage bucket (//storage.googleapis.com/projects/PROJECT_ID/buckets/BUCKET_ID) for DataDiscoveryScan OR BigQuery table of type "TABLE" (/bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID) for DataProfileScan/DataQualityScan.
        """
        return pulumi.get(self, "resource")


@pulumi.output_type
class DatascanDataDiscoverySpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bigqueryPublishingConfig":
            suggest = "bigquery_publishing_config"
        elif key == "storageConfig":
            suggest = "storage_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataDiscoverySpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataDiscoverySpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataDiscoverySpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bigquery_publishing_config: Optional['outputs.DatascanDataDiscoverySpecBigqueryPublishingConfig'] = None,
                 storage_config: Optional['outputs.DatascanDataDiscoverySpecStorageConfig'] = None):
        """
        :param 'DatascanDataDiscoverySpecBigqueryPublishingConfigArgs' bigquery_publishing_config: Configuration for metadata publishing.
               Structure is documented below.
        :param 'DatascanDataDiscoverySpecStorageConfigArgs' storage_config: Configurations related to Cloud Storage as the data source.
               Structure is documented below.
        """
        if bigquery_publishing_config is not None:
            pulumi.set(__self__, "bigquery_publishing_config", bigquery_publishing_config)
        if storage_config is not None:
            pulumi.set(__self__, "storage_config", storage_config)

    @_builtins.property
    @pulumi.getter(name="bigqueryPublishingConfig")
    def bigquery_publishing_config(self) -> Optional['outputs.DatascanDataDiscoverySpecBigqueryPublishingConfig']:
        """
        Configuration for metadata publishing.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_publishing_config")

    @_builtins.property
    @pulumi.getter(name="storageConfig")
    def storage_config(self) -> Optional['outputs.DatascanDataDiscoverySpecStorageConfig']:
        """
        Configurations related to Cloud Storage as the data source.
        Structure is documented below.
        """
        return pulumi.get(self, "storage_config")


@pulumi.output_type
class DatascanDataDiscoverySpecBigqueryPublishingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableType":
            suggest = "table_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataDiscoverySpecBigqueryPublishingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataDiscoverySpecBigqueryPublishingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataDiscoverySpecBigqueryPublishingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 project: Optional[_builtins.str] = None,
                 table_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str connection: The BigQuery connection used to create BigLake tables. Must be in the form `projects/{projectId}/locations/{locationId}/connections/{connection_id}`.
        :param _builtins.str location: The location of the BigQuery dataset to publish BigLake external or non-BigLake external tables to.
        :param _builtins.str project: The project of the BigQuery dataset to publish BigLake external or non-BigLake external tables to. If not specified, the project of the Cloud Storage bucket will be used. The format is "projects/{project_id_or_number}".
        :param _builtins.str table_type: Determines whether to publish discovered tables as BigLake external tables or non-BigLake external tables.
               Possible values are: `TABLE_TYPE_UNSPECIFIED`, `EXTERNAL`, `BIGLAKE`.
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if table_type is not None:
            pulumi.set(__self__, "table_type", table_type)

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional[_builtins.str]:
        """
        The BigQuery connection used to create BigLake tables. Must be in the form `projects/{projectId}/locations/{locationId}/connections/{connection_id}`.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        The location of the BigQuery dataset to publish BigLake external or non-BigLake external tables to.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional[_builtins.str]:
        """
        The project of the BigQuery dataset to publish BigLake external or non-BigLake external tables to. If not specified, the project of the Cloud Storage bucket will be used. The format is "projects/{project_id_or_number}".
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter(name="tableType")
    def table_type(self) -> Optional[_builtins.str]:
        """
        Determines whether to publish discovered tables as BigLake external tables or non-BigLake external tables.
        Possible values are: `TABLE_TYPE_UNSPECIFIED`, `EXTERNAL`, `BIGLAKE`.
        """
        return pulumi.get(self, "table_type")


@pulumi.output_type
class DatascanDataDiscoverySpecStorageConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "csvOptions":
            suggest = "csv_options"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"
        elif key == "jsonOptions":
            suggest = "json_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataDiscoverySpecStorageConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataDiscoverySpecStorageConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataDiscoverySpecStorageConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 csv_options: Optional['outputs.DatascanDataDiscoverySpecStorageConfigCsvOptions'] = None,
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None,
                 json_options: Optional['outputs.DatascanDataDiscoverySpecStorageConfigJsonOptions'] = None):
        """
        :param 'DatascanDataDiscoverySpecStorageConfigCsvOptionsArgs' csv_options: Configuration for CSV data.
               Structure is documented below.
        :param Sequence[_builtins.str] exclude_patterns: Defines the data to exclude during discovery. Provide a list of patterns that identify the data to exclude. For Cloud Storage bucket assets, these patterns are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these patterns are interpreted as patterns to match table names.
        :param Sequence[_builtins.str] include_patterns: Defines the data to include during discovery when only a subset of the data should be considered. Provide a list of patterns that identify the data to include. For Cloud Storage bucket assets, these patterns are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these patterns are interpreted as patterns to match table names.
        :param 'DatascanDataDiscoverySpecStorageConfigJsonOptionsArgs' json_options: Configuration for JSON data.
               Structure is documented below.
        """
        if csv_options is not None:
            pulumi.set(__self__, "csv_options", csv_options)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if json_options is not None:
            pulumi.set(__self__, "json_options", json_options)

    @_builtins.property
    @pulumi.getter(name="csvOptions")
    def csv_options(self) -> Optional['outputs.DatascanDataDiscoverySpecStorageConfigCsvOptions']:
        """
        Configuration for CSV data.
        Structure is documented below.
        """
        return pulumi.get(self, "csv_options")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Defines the data to exclude during discovery. Provide a list of patterns that identify the data to exclude. For Cloud Storage bucket assets, these patterns are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these patterns are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Defines the data to include during discovery when only a subset of the data should be considered. Provide a list of patterns that identify the data to include. For Cloud Storage bucket assets, these patterns are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these patterns are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "include_patterns")

    @_builtins.property
    @pulumi.getter(name="jsonOptions")
    def json_options(self) -> Optional['outputs.DatascanDataDiscoverySpecStorageConfigJsonOptions']:
        """
        Configuration for JSON data.
        Structure is documented below.
        """
        return pulumi.get(self, "json_options")


@pulumi.output_type
class DatascanDataDiscoverySpecStorageConfigCsvOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerRows":
            suggest = "header_rows"
        elif key == "typeInferenceDisabled":
            suggest = "type_inference_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataDiscoverySpecStorageConfigCsvOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataDiscoverySpecStorageConfigCsvOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataDiscoverySpecStorageConfigCsvOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[_builtins.str] = None,
                 encoding: Optional[_builtins.str] = None,
                 header_rows: Optional[_builtins.int] = None,
                 quote: Optional[_builtins.str] = None,
                 type_inference_disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str delimiter: The delimiter that is used to separate values. The default is `,` (comma).
        :param _builtins.str encoding: The character encoding of the data. The default is UTF-8.
        :param _builtins.int header_rows: The number of rows to interpret as header rows that should be skipped when reading data rows.
        :param _builtins.str quote: The character used to quote column values. Accepts `"` (double quotation mark) or `'` (single quotation mark). If unspecified, defaults to `"` (double quotation mark).
        :param _builtins.bool type_inference_disabled: Whether to disable the inference of data types for CSV data. If true, all columns are registered as strings.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if header_rows is not None:
            pulumi.set(__self__, "header_rows", header_rows)
        if quote is not None:
            pulumi.set(__self__, "quote", quote)
        if type_inference_disabled is not None:
            pulumi.set(__self__, "type_inference_disabled", type_inference_disabled)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[_builtins.str]:
        """
        The delimiter that is used to separate values. The default is `,` (comma).
        """
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> Optional[_builtins.str]:
        """
        The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @_builtins.property
    @pulumi.getter(name="headerRows")
    def header_rows(self) -> Optional[_builtins.int]:
        """
        The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        return pulumi.get(self, "header_rows")

    @_builtins.property
    @pulumi.getter
    def quote(self) -> Optional[_builtins.str]:
        """
        The character used to quote column values. Accepts `"` (double quotation mark) or `'` (single quotation mark). If unspecified, defaults to `"` (double quotation mark).
        """
        return pulumi.get(self, "quote")

    @_builtins.property
    @pulumi.getter(name="typeInferenceDisabled")
    def type_inference_disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the inference of data types for CSV data. If true, all columns are registered as strings.
        """
        return pulumi.get(self, "type_inference_disabled")


@pulumi.output_type
class DatascanDataDiscoverySpecStorageConfigJsonOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeInferenceDisabled":
            suggest = "type_inference_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataDiscoverySpecStorageConfigJsonOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataDiscoverySpecStorageConfigJsonOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataDiscoverySpecStorageConfigJsonOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encoding: Optional[_builtins.str] = None,
                 type_inference_disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str encoding: The character encoding of the data. The default is UTF-8.
        :param _builtins.bool type_inference_disabled: Whether to disable the inference of data types for JSON data. If true, all columns are registered as their primitive types (strings, number, or boolean).
        """
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if type_inference_disabled is not None:
            pulumi.set(__self__, "type_inference_disabled", type_inference_disabled)

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> Optional[_builtins.str]:
        """
        The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @_builtins.property
    @pulumi.getter(name="typeInferenceDisabled")
    def type_inference_disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the inference of data types for JSON data. If true, all columns are registered as their primitive types (strings, number, or boolean).
        """
        return pulumi.get(self, "type_inference_disabled")


@pulumi.output_type
class DatascanDataProfileSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeFields":
            suggest = "exclude_fields"
        elif key == "includeFields":
            suggest = "include_fields"
        elif key == "postScanActions":
            suggest = "post_scan_actions"
        elif key == "rowFilter":
            suggest = "row_filter"
        elif key == "samplingPercent":
            suggest = "sampling_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataProfileSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataProfileSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataProfileSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_fields: Optional['outputs.DatascanDataProfileSpecExcludeFields'] = None,
                 include_fields: Optional['outputs.DatascanDataProfileSpecIncludeFields'] = None,
                 post_scan_actions: Optional['outputs.DatascanDataProfileSpecPostScanActions'] = None,
                 row_filter: Optional[_builtins.str] = None,
                 sampling_percent: Optional[_builtins.float] = None):
        """
        :param 'DatascanDataProfileSpecExcludeFieldsArgs' exclude_fields: The fields to exclude from data profile.
               If specified, the fields will be excluded from data profile, regardless of `include_fields` value.
               Structure is documented below.
        :param 'DatascanDataProfileSpecIncludeFieldsArgs' include_fields: The fields to include in data profile.
               If not specified, all fields at the time of profile scan job execution are included, except for ones listed in `exclude_fields`.
               Structure is documented below.
        :param 'DatascanDataProfileSpecPostScanActionsArgs' post_scan_actions: Actions to take upon job completion.
               Structure is documented below.
        :param _builtins.str row_filter: A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        :param _builtins.float sampling_percent: The percentage of the records to be selected from the dataset for DataScan.
               Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
               Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        if exclude_fields is not None:
            pulumi.set(__self__, "exclude_fields", exclude_fields)
        if include_fields is not None:
            pulumi.set(__self__, "include_fields", include_fields)
        if post_scan_actions is not None:
            pulumi.set(__self__, "post_scan_actions", post_scan_actions)
        if row_filter is not None:
            pulumi.set(__self__, "row_filter", row_filter)
        if sampling_percent is not None:
            pulumi.set(__self__, "sampling_percent", sampling_percent)

    @_builtins.property
    @pulumi.getter(name="excludeFields")
    def exclude_fields(self) -> Optional['outputs.DatascanDataProfileSpecExcludeFields']:
        """
        The fields to exclude from data profile.
        If specified, the fields will be excluded from data profile, regardless of `include_fields` value.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_fields")

    @_builtins.property
    @pulumi.getter(name="includeFields")
    def include_fields(self) -> Optional['outputs.DatascanDataProfileSpecIncludeFields']:
        """
        The fields to include in data profile.
        If not specified, all fields at the time of profile scan job execution are included, except for ones listed in `exclude_fields`.
        Structure is documented below.
        """
        return pulumi.get(self, "include_fields")

    @_builtins.property
    @pulumi.getter(name="postScanActions")
    def post_scan_actions(self) -> Optional['outputs.DatascanDataProfileSpecPostScanActions']:
        """
        Actions to take upon job completion.
        Structure is documented below.
        """
        return pulumi.get(self, "post_scan_actions")

    @_builtins.property
    @pulumi.getter(name="rowFilter")
    def row_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        """
        return pulumi.get(self, "row_filter")

    @_builtins.property
    @pulumi.getter(name="samplingPercent")
    def sampling_percent(self) -> Optional[_builtins.float]:
        """
        The percentage of the records to be selected from the dataset for DataScan.
        Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
        Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        return pulumi.get(self, "sampling_percent")


@pulumi.output_type
class DatascanDataProfileSpecExcludeFields(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldNames":
            suggest = "field_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataProfileSpecExcludeFields. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataProfileSpecExcludeFields.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataProfileSpecExcludeFields.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] field_names: Expected input is a list of fully qualified names of fields as in the schema.
               Only top-level field names for nested fields are supported.
               For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)

    @_builtins.property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Expected input is a list of fully qualified names of fields as in the schema.
        Only top-level field names for nested fields are supported.
        For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        return pulumi.get(self, "field_names")


@pulumi.output_type
class DatascanDataProfileSpecIncludeFields(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldNames":
            suggest = "field_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataProfileSpecIncludeFields. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataProfileSpecIncludeFields.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataProfileSpecIncludeFields.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] field_names: Expected input is a list of fully qualified names of fields as in the schema.
               Only top-level field names for nested fields are supported.
               For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)

    @_builtins.property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Expected input is a list of fully qualified names of fields as in the schema.
        Only top-level field names for nested fields are supported.
        For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        return pulumi.get(self, "field_names")


@pulumi.output_type
class DatascanDataProfileSpecPostScanActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bigqueryExport":
            suggest = "bigquery_export"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataProfileSpecPostScanActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataProfileSpecPostScanActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataProfileSpecPostScanActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bigquery_export: Optional['outputs.DatascanDataProfileSpecPostScanActionsBigqueryExport'] = None):
        """
        :param 'DatascanDataProfileSpecPostScanActionsBigqueryExportArgs' bigquery_export: If set, results will be exported to the provided BigQuery table.
               Structure is documented below.
        """
        if bigquery_export is not None:
            pulumi.set(__self__, "bigquery_export", bigquery_export)

    @_builtins.property
    @pulumi.getter(name="bigqueryExport")
    def bigquery_export(self) -> Optional['outputs.DatascanDataProfileSpecPostScanActionsBigqueryExport']:
        """
        If set, results will be exported to the provided BigQuery table.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_export")


@pulumi.output_type
class DatascanDataProfileSpecPostScanActionsBigqueryExport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultsTable":
            suggest = "results_table"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataProfileSpecPostScanActionsBigqueryExport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataProfileSpecPostScanActionsBigqueryExport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataProfileSpecPostScanActionsBigqueryExport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 results_table: Optional[_builtins.str] = None):
        """
        :param _builtins.str results_table: The BigQuery table to export DataProfileScan results to.
               Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        if results_table is not None:
            pulumi.set(__self__, "results_table", results_table)

    @_builtins.property
    @pulumi.getter(name="resultsTable")
    def results_table(self) -> Optional[_builtins.str]:
        """
        The BigQuery table to export DataProfileScan results to.
        Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        return pulumi.get(self, "results_table")


@pulumi.output_type
class DatascanDataQualitySpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogPublishingEnabled":
            suggest = "catalog_publishing_enabled"
        elif key == "postScanActions":
            suggest = "post_scan_actions"
        elif key == "rowFilter":
            suggest = "row_filter"
        elif key == "samplingPercent":
            suggest = "sampling_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_publishing_enabled: Optional[_builtins.bool] = None,
                 post_scan_actions: Optional['outputs.DatascanDataQualitySpecPostScanActions'] = None,
                 row_filter: Optional[_builtins.str] = None,
                 rules: Optional[Sequence['outputs.DatascanDataQualitySpecRule']] = None,
                 sampling_percent: Optional[_builtins.float] = None):
        """
        :param _builtins.bool catalog_publishing_enabled: If set, the latest DataScan job result will be published to Dataplex Catalog.
        :param 'DatascanDataQualitySpecPostScanActionsArgs' post_scan_actions: Actions to take upon job completion.
               Structure is documented below.
        :param _builtins.str row_filter: A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        :param Sequence['DatascanDataQualitySpecRuleArgs'] rules: The list of rules to evaluate against a data source. At least one rule is required.
               Structure is documented below.
        :param _builtins.float sampling_percent: The percentage of the records to be selected from the dataset for DataScan.
               Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
               Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        if catalog_publishing_enabled is not None:
            pulumi.set(__self__, "catalog_publishing_enabled", catalog_publishing_enabled)
        if post_scan_actions is not None:
            pulumi.set(__self__, "post_scan_actions", post_scan_actions)
        if row_filter is not None:
            pulumi.set(__self__, "row_filter", row_filter)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if sampling_percent is not None:
            pulumi.set(__self__, "sampling_percent", sampling_percent)

    @_builtins.property
    @pulumi.getter(name="catalogPublishingEnabled")
    def catalog_publishing_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, the latest DataScan job result will be published to Dataplex Catalog.
        """
        return pulumi.get(self, "catalog_publishing_enabled")

    @_builtins.property
    @pulumi.getter(name="postScanActions")
    def post_scan_actions(self) -> Optional['outputs.DatascanDataQualitySpecPostScanActions']:
        """
        Actions to take upon job completion.
        Structure is documented below.
        """
        return pulumi.get(self, "post_scan_actions")

    @_builtins.property
    @pulumi.getter(name="rowFilter")
    def row_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        """
        return pulumi.get(self, "row_filter")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.DatascanDataQualitySpecRule']]:
        """
        The list of rules to evaluate against a data source. At least one rule is required.
        Structure is documented below.
        """
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter(name="samplingPercent")
    def sampling_percent(self) -> Optional[_builtins.float]:
        """
        The percentage of the records to be selected from the dataset for DataScan.
        Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
        Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        return pulumi.get(self, "sampling_percent")


@pulumi.output_type
class DatascanDataQualitySpecPostScanActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bigqueryExport":
            suggest = "bigquery_export"
        elif key == "notificationReport":
            suggest = "notification_report"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecPostScanActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecPostScanActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecPostScanActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bigquery_export: Optional['outputs.DatascanDataQualitySpecPostScanActionsBigqueryExport'] = None,
                 notification_report: Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReport'] = None):
        """
        :param 'DatascanDataQualitySpecPostScanActionsBigqueryExportArgs' bigquery_export: If set, results will be exported to the provided BigQuery table.
               Structure is documented below.
        :param 'DatascanDataQualitySpecPostScanActionsNotificationReportArgs' notification_report: The configuration of notification report post scan action.
               Structure is documented below.
        """
        if bigquery_export is not None:
            pulumi.set(__self__, "bigquery_export", bigquery_export)
        if notification_report is not None:
            pulumi.set(__self__, "notification_report", notification_report)

    @_builtins.property
    @pulumi.getter(name="bigqueryExport")
    def bigquery_export(self) -> Optional['outputs.DatascanDataQualitySpecPostScanActionsBigqueryExport']:
        """
        If set, results will be exported to the provided BigQuery table.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_export")

    @_builtins.property
    @pulumi.getter(name="notificationReport")
    def notification_report(self) -> Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReport']:
        """
        The configuration of notification report post scan action.
        Structure is documented below.
        """
        return pulumi.get(self, "notification_report")


@pulumi.output_type
class DatascanDataQualitySpecPostScanActionsBigqueryExport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultsTable":
            suggest = "results_table"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecPostScanActionsBigqueryExport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecPostScanActionsBigqueryExport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecPostScanActionsBigqueryExport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 results_table: Optional[_builtins.str] = None):
        """
        :param _builtins.str results_table: The BigQuery table to export DataProfileScan results to.
               Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        if results_table is not None:
            pulumi.set(__self__, "results_table", results_table)

    @_builtins.property
    @pulumi.getter(name="resultsTable")
    def results_table(self) -> Optional[_builtins.str]:
        """
        The BigQuery table to export DataProfileScan results to.
        Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        return pulumi.get(self, "results_table")


@pulumi.output_type
class DatascanDataQualitySpecPostScanActionsNotificationReport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobEndTrigger":
            suggest = "job_end_trigger"
        elif key == "jobFailureTrigger":
            suggest = "job_failure_trigger"
        elif key == "scoreThresholdTrigger":
            suggest = "score_threshold_trigger"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecPostScanActionsNotificationReport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecPostScanActionsNotificationReport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecPostScanActionsNotificationReport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recipients: 'outputs.DatascanDataQualitySpecPostScanActionsNotificationReportRecipients',
                 job_end_trigger: Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReportJobEndTrigger'] = None,
                 job_failure_trigger: Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReportJobFailureTrigger'] = None,
                 score_threshold_trigger: Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger'] = None):
        """
        :param 'DatascanDataQualitySpecPostScanActionsNotificationReportRecipientsArgs' recipients: The individuals or groups who are designated to receive notifications upon triggers.
               Structure is documented below.
        :param 'DatascanDataQualitySpecPostScanActionsNotificationReportJobEndTriggerArgs' job_end_trigger: This trigger is triggered whenever a scan job run ends, regardless of the result.
        :param 'DatascanDataQualitySpecPostScanActionsNotificationReportJobFailureTriggerArgs' job_failure_trigger: This trigger is triggered when the scan job itself fails, regardless of the result.
        :param 'DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTriggerArgs' score_threshold_trigger: This trigger is triggered when the DQ score in the job result is less than a specified input score.
               Structure is documented below.
        """
        pulumi.set(__self__, "recipients", recipients)
        if job_end_trigger is not None:
            pulumi.set(__self__, "job_end_trigger", job_end_trigger)
        if job_failure_trigger is not None:
            pulumi.set(__self__, "job_failure_trigger", job_failure_trigger)
        if score_threshold_trigger is not None:
            pulumi.set(__self__, "score_threshold_trigger", score_threshold_trigger)

    @_builtins.property
    @pulumi.getter
    def recipients(self) -> 'outputs.DatascanDataQualitySpecPostScanActionsNotificationReportRecipients':
        """
        The individuals or groups who are designated to receive notifications upon triggers.
        Structure is documented below.
        """
        return pulumi.get(self, "recipients")

    @_builtins.property
    @pulumi.getter(name="jobEndTrigger")
    def job_end_trigger(self) -> Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReportJobEndTrigger']:
        """
        This trigger is triggered whenever a scan job run ends, regardless of the result.
        """
        return pulumi.get(self, "job_end_trigger")

    @_builtins.property
    @pulumi.getter(name="jobFailureTrigger")
    def job_failure_trigger(self) -> Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReportJobFailureTrigger']:
        """
        This trigger is triggered when the scan job itself fails, regardless of the result.
        """
        return pulumi.get(self, "job_failure_trigger")

    @_builtins.property
    @pulumi.getter(name="scoreThresholdTrigger")
    def score_threshold_trigger(self) -> Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger']:
        """
        This trigger is triggered when the DQ score in the job result is less than a specified input score.
        Structure is documented below.
        """
        return pulumi.get(self, "score_threshold_trigger")


@pulumi.output_type
class DatascanDataQualitySpecPostScanActionsNotificationReportJobEndTrigger(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatascanDataQualitySpecPostScanActionsNotificationReportJobFailureTrigger(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatascanDataQualitySpecPostScanActionsNotificationReportRecipients(dict):
    def __init__(__self__, *,
                 emails: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] emails: The email recipients who will receive the DataQualityScan results report.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        The email recipients who will receive the DataQualityScan results report.
        """
        return pulumi.get(self, "emails")


@pulumi.output_type
class DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scoreThreshold":
            suggest = "score_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 score_threshold: Optional[_builtins.float] = None):
        """
        :param _builtins.float score_threshold: The score range is in [0,100].
        """
        if score_threshold is not None:
            pulumi.set(__self__, "score_threshold", score_threshold)

    @_builtins.property
    @pulumi.getter(name="scoreThreshold")
    def score_threshold(self) -> Optional[_builtins.float]:
        """
        The score range is in [0,100].
        """
        return pulumi.get(self, "score_threshold")


@pulumi.output_type
class DatascanDataQualitySpecRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreNull":
            suggest = "ignore_null"
        elif key == "nonNullExpectation":
            suggest = "non_null_expectation"
        elif key == "rangeExpectation":
            suggest = "range_expectation"
        elif key == "regexExpectation":
            suggest = "regex_expectation"
        elif key == "rowConditionExpectation":
            suggest = "row_condition_expectation"
        elif key == "setExpectation":
            suggest = "set_expectation"
        elif key == "sqlAssertion":
            suggest = "sql_assertion"
        elif key == "statisticRangeExpectation":
            suggest = "statistic_range_expectation"
        elif key == "tableConditionExpectation":
            suggest = "table_condition_expectation"
        elif key == "uniquenessExpectation":
            suggest = "uniqueness_expectation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension: _builtins.str,
                 column: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 ignore_null: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 non_null_expectation: Optional['outputs.DatascanDataQualitySpecRuleNonNullExpectation'] = None,
                 range_expectation: Optional['outputs.DatascanDataQualitySpecRuleRangeExpectation'] = None,
                 regex_expectation: Optional['outputs.DatascanDataQualitySpecRuleRegexExpectation'] = None,
                 row_condition_expectation: Optional['outputs.DatascanDataQualitySpecRuleRowConditionExpectation'] = None,
                 set_expectation: Optional['outputs.DatascanDataQualitySpecRuleSetExpectation'] = None,
                 sql_assertion: Optional['outputs.DatascanDataQualitySpecRuleSqlAssertion'] = None,
                 statistic_range_expectation: Optional['outputs.DatascanDataQualitySpecRuleStatisticRangeExpectation'] = None,
                 suspended: Optional[_builtins.bool] = None,
                 table_condition_expectation: Optional['outputs.DatascanDataQualitySpecRuleTableConditionExpectation'] = None,
                 threshold: Optional[_builtins.float] = None,
                 uniqueness_expectation: Optional['outputs.DatascanDataQualitySpecRuleUniquenessExpectation'] = None):
        """
        :param _builtins.str dimension: The dimension name a rule belongs to. Custom dimension name is supported with all uppercase letters and maximum length of 30 characters.
        :param _builtins.str column: The unnested column which this rule is evaluated against.
        :param _builtins.str description: Description of the rule.
               The maximum length is 1,024 characters.
        :param _builtins.bool ignore_null: Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
        :param _builtins.str name: A mutable name for the rule.
               The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
               The maximum length is 63 characters.
               Must start with a letter.
               Must end with a number or a letter.
        :param 'DatascanDataQualitySpecRuleNonNullExpectationArgs' non_null_expectation: ColumnMap rule which evaluates whether each column value is null.
        :param 'DatascanDataQualitySpecRuleRangeExpectationArgs' range_expectation: ColumnMap rule which evaluates whether each column value lies between a specified range.
               Structure is documented below.
        :param 'DatascanDataQualitySpecRuleRegexExpectationArgs' regex_expectation: ColumnMap rule which evaluates whether each column value matches a specified regex.
               Structure is documented below.
        :param 'DatascanDataQualitySpecRuleRowConditionExpectationArgs' row_condition_expectation: Table rule which evaluates whether each row passes the specified condition.
               Structure is documented below.
        :param 'DatascanDataQualitySpecRuleSetExpectationArgs' set_expectation: ColumnMap rule which evaluates whether each column value is contained by a specified set.
               Structure is documented below.
        :param 'DatascanDataQualitySpecRuleSqlAssertionArgs' sql_assertion: Table rule which evaluates whether any row matches invalid state.
               Structure is documented below.
        :param 'DatascanDataQualitySpecRuleStatisticRangeExpectationArgs' statistic_range_expectation: ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
               Structure is documented below.
        :param _builtins.bool suspended: Whether the Rule is active or suspended. Default = false.
        :param 'DatascanDataQualitySpecRuleTableConditionExpectationArgs' table_condition_expectation: Table rule which evaluates whether the provided expression is true.
               Structure is documented below.
        :param _builtins.float threshold: The minimum ratio of passing_rows / total_rows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0).
        :param 'DatascanDataQualitySpecRuleUniquenessExpectationArgs' uniqueness_expectation: Row-level rule which evaluates whether each column value is unique.
        """
        pulumi.set(__self__, "dimension", dimension)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ignore_null is not None:
            pulumi.set(__self__, "ignore_null", ignore_null)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if non_null_expectation is not None:
            pulumi.set(__self__, "non_null_expectation", non_null_expectation)
        if range_expectation is not None:
            pulumi.set(__self__, "range_expectation", range_expectation)
        if regex_expectation is not None:
            pulumi.set(__self__, "regex_expectation", regex_expectation)
        if row_condition_expectation is not None:
            pulumi.set(__self__, "row_condition_expectation", row_condition_expectation)
        if set_expectation is not None:
            pulumi.set(__self__, "set_expectation", set_expectation)
        if sql_assertion is not None:
            pulumi.set(__self__, "sql_assertion", sql_assertion)
        if statistic_range_expectation is not None:
            pulumi.set(__self__, "statistic_range_expectation", statistic_range_expectation)
        if suspended is not None:
            pulumi.set(__self__, "suspended", suspended)
        if table_condition_expectation is not None:
            pulumi.set(__self__, "table_condition_expectation", table_condition_expectation)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if uniqueness_expectation is not None:
            pulumi.set(__self__, "uniqueness_expectation", uniqueness_expectation)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> _builtins.str:
        """
        The dimension name a rule belongs to. Custom dimension name is supported with all uppercase letters and maximum length of 30 characters.
        """
        return pulumi.get(self, "dimension")

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.str]:
        """
        The unnested column which this rule is evaluated against.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the rule.
        The maximum length is 1,024 characters.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ignoreNull")
    def ignore_null(self) -> Optional[_builtins.bool]:
        """
        Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
        """
        return pulumi.get(self, "ignore_null")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A mutable name for the rule.
        The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
        The maximum length is 63 characters.
        Must start with a letter.
        Must end with a number or a letter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nonNullExpectation")
    def non_null_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleNonNullExpectation']:
        """
        ColumnMap rule which evaluates whether each column value is null.
        """
        return pulumi.get(self, "non_null_expectation")

    @_builtins.property
    @pulumi.getter(name="rangeExpectation")
    def range_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleRangeExpectation']:
        """
        ColumnMap rule which evaluates whether each column value lies between a specified range.
        Structure is documented below.
        """
        return pulumi.get(self, "range_expectation")

    @_builtins.property
    @pulumi.getter(name="regexExpectation")
    def regex_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleRegexExpectation']:
        """
        ColumnMap rule which evaluates whether each column value matches a specified regex.
        Structure is documented below.
        """
        return pulumi.get(self, "regex_expectation")

    @_builtins.property
    @pulumi.getter(name="rowConditionExpectation")
    def row_condition_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleRowConditionExpectation']:
        """
        Table rule which evaluates whether each row passes the specified condition.
        Structure is documented below.
        """
        return pulumi.get(self, "row_condition_expectation")

    @_builtins.property
    @pulumi.getter(name="setExpectation")
    def set_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleSetExpectation']:
        """
        ColumnMap rule which evaluates whether each column value is contained by a specified set.
        Structure is documented below.
        """
        return pulumi.get(self, "set_expectation")

    @_builtins.property
    @pulumi.getter(name="sqlAssertion")
    def sql_assertion(self) -> Optional['outputs.DatascanDataQualitySpecRuleSqlAssertion']:
        """
        Table rule which evaluates whether any row matches invalid state.
        Structure is documented below.
        """
        return pulumi.get(self, "sql_assertion")

    @_builtins.property
    @pulumi.getter(name="statisticRangeExpectation")
    def statistic_range_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleStatisticRangeExpectation']:
        """
        ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
        Structure is documented below.
        """
        return pulumi.get(self, "statistic_range_expectation")

    @_builtins.property
    @pulumi.getter
    def suspended(self) -> Optional[_builtins.bool]:
        """
        Whether the Rule is active or suspended. Default = false.
        """
        return pulumi.get(self, "suspended")

    @_builtins.property
    @pulumi.getter(name="tableConditionExpectation")
    def table_condition_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleTableConditionExpectation']:
        """
        Table rule which evaluates whether the provided expression is true.
        Structure is documented below.
        """
        return pulumi.get(self, "table_condition_expectation")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.float]:
        """
        The minimum ratio of passing_rows / total_rows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0).
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter(name="uniquenessExpectation")
    def uniqueness_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleUniquenessExpectation']:
        """
        Row-level rule which evaluates whether each column value is unique.
        """
        return pulumi.get(self, "uniqueness_expectation")


@pulumi.output_type
class DatascanDataQualitySpecRuleNonNullExpectation(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatascanDataQualitySpecRuleRangeExpectation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxValue":
            suggest = "max_value"
        elif key == "minValue":
            suggest = "min_value"
        elif key == "strictMaxEnabled":
            suggest = "strict_max_enabled"
        elif key == "strictMinEnabled":
            suggest = "strict_min_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecRuleRangeExpectation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecRuleRangeExpectation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecRuleRangeExpectation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_value: Optional[_builtins.str] = None,
                 min_value: Optional[_builtins.str] = None,
                 strict_max_enabled: Optional[_builtins.bool] = None,
                 strict_min_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str max_value: The maximum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        :param _builtins.str min_value: The minimum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        :param _builtins.bool strict_max_enabled: Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
               Only relevant if a maxValue has been defined. Default = false.
        :param _builtins.bool strict_min_enabled: Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
               Only relevant if a minValue has been defined. Default = false.
        """
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if strict_max_enabled is not None:
            pulumi.set(__self__, "strict_max_enabled", strict_max_enabled)
        if strict_min_enabled is not None:
            pulumi.set(__self__, "strict_min_enabled", strict_min_enabled)

    @_builtins.property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[_builtins.str]:
        """
        The maximum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "max_value")

    @_builtins.property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[_builtins.str]:
        """
        The minimum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "min_value")

    @_builtins.property
    @pulumi.getter(name="strictMaxEnabled")
    def strict_max_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        Only relevant if a maxValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_max_enabled")

    @_builtins.property
    @pulumi.getter(name="strictMinEnabled")
    def strict_min_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        Only relevant if a minValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_min_enabled")


@pulumi.output_type
class DatascanDataQualitySpecRuleRegexExpectation(dict):
    def __init__(__self__, *,
                 regex: _builtins.str):
        """
        :param _builtins.str regex: A regular expression the column value is expected to match.
        """
        pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        A regular expression the column value is expected to match.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class DatascanDataQualitySpecRuleRowConditionExpectation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sqlExpression":
            suggest = "sql_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecRuleRowConditionExpectation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecRuleRowConditionExpectation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecRuleRowConditionExpectation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sql_expression: _builtins.str):
        """
        :param _builtins.str sql_expression: The SQL expression.
        """
        pulumi.set(__self__, "sql_expression", sql_expression)

    @_builtins.property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> _builtins.str:
        """
        The SQL expression.
        """
        return pulumi.get(self, "sql_expression")


@pulumi.output_type
class DatascanDataQualitySpecRuleSetExpectation(dict):
    def __init__(__self__, *,
                 values: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] values: Expected values for the column value.
        """
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Expected values for the column value.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class DatascanDataQualitySpecRuleSqlAssertion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sqlStatement":
            suggest = "sql_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecRuleSqlAssertion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecRuleSqlAssertion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecRuleSqlAssertion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sql_statement: _builtins.str):
        """
        :param _builtins.str sql_statement: The SQL statement.
        """
        pulumi.set(__self__, "sql_statement", sql_statement)

    @_builtins.property
    @pulumi.getter(name="sqlStatement")
    def sql_statement(self) -> _builtins.str:
        """
        The SQL statement.
        """
        return pulumi.get(self, "sql_statement")


@pulumi.output_type
class DatascanDataQualitySpecRuleStatisticRangeExpectation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxValue":
            suggest = "max_value"
        elif key == "minValue":
            suggest = "min_value"
        elif key == "strictMaxEnabled":
            suggest = "strict_max_enabled"
        elif key == "strictMinEnabled":
            suggest = "strict_min_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecRuleStatisticRangeExpectation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecRuleStatisticRangeExpectation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecRuleStatisticRangeExpectation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 statistic: _builtins.str,
                 max_value: Optional[_builtins.str] = None,
                 min_value: Optional[_builtins.str] = None,
                 strict_max_enabled: Optional[_builtins.bool] = None,
                 strict_min_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str statistic: column statistics.
               Possible values are: `STATISTIC_UNDEFINED`, `MEAN`, `MIN`, `MAX`.
        :param _builtins.str max_value: The maximum column statistic value allowed for a row to pass this validation.
               At least one of minValue and maxValue need to be provided.
        :param _builtins.str min_value: The minimum column statistic value allowed for a row to pass this validation.
               At least one of minValue and maxValue need to be provided.
        :param _builtins.bool strict_max_enabled: Whether column statistic needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
               Only relevant if a maxValue has been defined. Default = false.
        :param _builtins.bool strict_min_enabled: Whether column statistic needs to be strictly greater than ('>') the minimum, or if equality is allowed.
               Only relevant if a minValue has been defined. Default = false.
        """
        pulumi.set(__self__, "statistic", statistic)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if strict_max_enabled is not None:
            pulumi.set(__self__, "strict_max_enabled", strict_max_enabled)
        if strict_min_enabled is not None:
            pulumi.set(__self__, "strict_min_enabled", strict_min_enabled)

    @_builtins.property
    @pulumi.getter
    def statistic(self) -> _builtins.str:
        """
        column statistics.
        Possible values are: `STATISTIC_UNDEFINED`, `MEAN`, `MIN`, `MAX`.
        """
        return pulumi.get(self, "statistic")

    @_builtins.property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[_builtins.str]:
        """
        The maximum column statistic value allowed for a row to pass this validation.
        At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "max_value")

    @_builtins.property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[_builtins.str]:
        """
        The minimum column statistic value allowed for a row to pass this validation.
        At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "min_value")

    @_builtins.property
    @pulumi.getter(name="strictMaxEnabled")
    def strict_max_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether column statistic needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        Only relevant if a maxValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_max_enabled")

    @_builtins.property
    @pulumi.getter(name="strictMinEnabled")
    def strict_min_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether column statistic needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        Only relevant if a minValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_min_enabled")


@pulumi.output_type
class DatascanDataQualitySpecRuleTableConditionExpectation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sqlExpression":
            suggest = "sql_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecRuleTableConditionExpectation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecRuleTableConditionExpectation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecRuleTableConditionExpectation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sql_expression: _builtins.str):
        """
        :param _builtins.str sql_expression: The SQL expression.
        """
        pulumi.set(__self__, "sql_expression", sql_expression)

    @_builtins.property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> _builtins.str:
        """
        The SQL expression.
        """
        return pulumi.get(self, "sql_expression")


@pulumi.output_type
class DatascanDataQualitySpecRuleUniquenessExpectation(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatascanExecutionSpec(dict):
    def __init__(__self__, *,
                 trigger: 'outputs.DatascanExecutionSpecTrigger',
                 field: Optional[_builtins.str] = None):
        """
        :param 'DatascanExecutionSpecTriggerArgs' trigger: Spec related to how often and when a scan should be triggered.
               Structure is documented below.
        :param _builtins.str field: The unnested field (of type Date or Timestamp) that contains values which monotonically increase over time. If not specified, a data scan will run for all data in the table.
        """
        pulumi.set(__self__, "trigger", trigger)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter
    def trigger(self) -> 'outputs.DatascanExecutionSpecTrigger':
        """
        Spec related to how often and when a scan should be triggered.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger")

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[_builtins.str]:
        """
        The unnested field (of type Date or Timestamp) that contains values which monotonically increase over time. If not specified, a data scan will run for all data in the table.
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class DatascanExecutionSpecTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDemand":
            suggest = "on_demand"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanExecutionSpecTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanExecutionSpecTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanExecutionSpecTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_demand: Optional['outputs.DatascanExecutionSpecTriggerOnDemand'] = None,
                 schedule: Optional['outputs.DatascanExecutionSpecTriggerSchedule'] = None):
        """
        :param 'DatascanExecutionSpecTriggerOnDemandArgs' on_demand: The scan runs once via dataScans.run API.
        :param 'DatascanExecutionSpecTriggerScheduleArgs' schedule: The scan is scheduled to run periodically.
               Structure is documented below.
        """
        if on_demand is not None:
            pulumi.set(__self__, "on_demand", on_demand)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter(name="onDemand")
    def on_demand(self) -> Optional['outputs.DatascanExecutionSpecTriggerOnDemand']:
        """
        The scan runs once via dataScans.run API.
        """
        return pulumi.get(self, "on_demand")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.DatascanExecutionSpecTriggerSchedule']:
        """
        The scan is scheduled to run periodically.
        Structure is documented below.
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class DatascanExecutionSpecTriggerOnDemand(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatascanExecutionSpecTriggerSchedule(dict):
    def __init__(__self__, *,
                 cron: _builtins.str):
        """
        :param _builtins.str cron: Cron schedule for running scans periodically. This field is required for Schedule scans.
        """
        pulumi.set(__self__, "cron", cron)

    @_builtins.property
    @pulumi.getter
    def cron(self) -> _builtins.str:
        """
        Cron schedule for running scans periodically. This field is required for Schedule scans.
        """
        return pulumi.get(self, "cron")


@pulumi.output_type
class DatascanExecutionStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestJobEndTime":
            suggest = "latest_job_end_time"
        elif key == "latestJobStartTime":
            suggest = "latest_job_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanExecutionStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanExecutionStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanExecutionStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_job_end_time: Optional[_builtins.str] = None,
                 latest_job_start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str latest_job_end_time: (Output)
               The time when the latest DataScanJob started.
        :param _builtins.str latest_job_start_time: (Output)
               The time when the latest DataScanJob ended.
        """
        if latest_job_end_time is not None:
            pulumi.set(__self__, "latest_job_end_time", latest_job_end_time)
        if latest_job_start_time is not None:
            pulumi.set(__self__, "latest_job_start_time", latest_job_start_time)

    @_builtins.property
    @pulumi.getter(name="latestJobEndTime")
    def latest_job_end_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        The time when the latest DataScanJob started.
        """
        return pulumi.get(self, "latest_job_end_time")

    @_builtins.property
    @pulumi.getter(name="latestJobStartTime")
    def latest_job_start_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        The time when the latest DataScanJob ended.
        """
        return pulumi.get(self, "latest_job_start_time")


@pulumi.output_type
class DatascanIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class DatascanIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class EntryAspect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aspectKey":
            suggest = "aspect_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntryAspect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntryAspect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntryAspect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aspect: 'outputs.EntryAspectAspect',
                 aspect_key: _builtins.str):
        """
        :param 'EntryAspectAspectArgs' aspect: A nested object resource.
               Structure is documented below.
        :param _builtins.str aspect_key: Depending on how the aspect is attached to the entry, the format of the aspect key can be one of the following:
               If the aspect is attached directly to the entry: {project_number}.{locationId}.{aspectTypeId}
               If the aspect is attached to an entry's path: {project_number}.{locationId}.{aspectTypeId}@{path}
        """
        pulumi.set(__self__, "aspect", aspect)
        pulumi.set(__self__, "aspect_key", aspect_key)

    @_builtins.property
    @pulumi.getter
    def aspect(self) -> 'outputs.EntryAspectAspect':
        """
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "aspect")

    @_builtins.property
    @pulumi.getter(name="aspectKey")
    def aspect_key(self) -> _builtins.str:
        """
        Depending on how the aspect is attached to the entry, the format of the aspect key can be one of the following:
        If the aspect is attached directly to the entry: {project_number}.{locationId}.{aspectTypeId}
        If the aspect is attached to an entry's path: {project_number}.{locationId}.{aspectTypeId}@{path}
        """
        return pulumi.get(self, "aspect_key")


@pulumi.output_type
class EntryAspectAspect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aspectType":
            suggest = "aspect_type"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntryAspectAspect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntryAspectAspect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntryAspectAspect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data: _builtins.str,
                 aspect_type: Optional[_builtins.str] = None,
                 create_time: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str data: The content of the aspect in JSON form, according to its aspect type schema. The maximum size of the field is 120KB (encoded as UTF-8).
        :param _builtins.str aspect_type: (Output)
               The resource name of the type used to create this Aspect.
        :param _builtins.str create_time: (Output)
               The time when the Aspect was created.
        :param _builtins.str path: (Output)
               The path in the entry under which the aspect is attached.
        :param _builtins.str update_time: (Output)
               The time when the Aspect was last modified.
        """
        pulumi.set(__self__, "data", data)
        if aspect_type is not None:
            pulumi.set(__self__, "aspect_type", aspect_type)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def data(self) -> _builtins.str:
        """
        The content of the aspect in JSON form, according to its aspect type schema. The maximum size of the field is 120KB (encoded as UTF-8).
        """
        return pulumi.get(self, "data")

    @_builtins.property
    @pulumi.getter(name="aspectType")
    def aspect_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The resource name of the type used to create this Aspect.
        """
        return pulumi.get(self, "aspect_type")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        The time when the Aspect was created.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        (Output)
        The path in the entry under which the aspect is attached.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        The time when the Aspect was last modified.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class EntryEntrySource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntryEntrySource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntryEntrySource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntryEntrySource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ancestors: Optional[Sequence['outputs.EntryEntrySourceAncestor']] = None,
                 create_time: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 location: Optional[_builtins.str] = None,
                 platform: Optional[_builtins.str] = None,
                 resource: Optional[_builtins.str] = None,
                 system: Optional[_builtins.str] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param Sequence['EntryEntrySourceAncestorArgs'] ancestors: Structure is documented below.
        :param _builtins.str create_time: The time when the resource was created in the source system.
        :param _builtins.str description: A description of the data resource. Maximum length is 2,000 characters.
        :param _builtins.str display_name: A user-friendly display name. Maximum length is 500 characters.
        :param Mapping[str, _builtins.str] labels: User-defined labels. The maximum size of keys and values is 128 characters each.
               An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param _builtins.str location: (Output)
               Location of the resource in the source system. You can search the entry by this location.
               By default, this should match the location of the entry group containing this entry.
               A different value allows capturing the source location for data external to Google Cloud.
        :param _builtins.str platform: The platform containing the source system. Maximum length is 64 characters.
        :param _builtins.str resource: The name of the resource in the source system. Maximum length is 4,000 characters.
        :param _builtins.str system: The name of the source system. Maximum length is 64 characters.
        :param _builtins.str update_time: The time when the resource was last updated in the source system.
               If the entry exists in the system and its EntrySource has updateTime populated,
               further updates to the EntrySource of the entry must provide incremental updates to its updateTime.
        """
        if ancestors is not None:
            pulumi.set(__self__, "ancestors", ancestors)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if system is not None:
            pulumi.set(__self__, "system", system)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def ancestors(self) -> Optional[Sequence['outputs.EntryEntrySourceAncestor']]:
        """
        Structure is documented below.
        """
        return pulumi.get(self, "ancestors")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        The time when the resource was created in the source system.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of the data resource. Maximum length is 2,000 characters.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        A user-friendly display name. Maximum length is 500 characters.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        User-defined labels. The maximum size of keys and values is 128 characters each.
        An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        (Output)
        Location of the resource in the source system. You can search the entry by this location.
        By default, this should match the location of the entry group containing this entry.
        A different value allows capturing the source location for data external to Google Cloud.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def platform(self) -> Optional[_builtins.str]:
        """
        The platform containing the source system. Maximum length is 64 characters.
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter
    def resource(self) -> Optional[_builtins.str]:
        """
        The name of the resource in the source system. Maximum length is 4,000 characters.
        """
        return pulumi.get(self, "resource")

    @_builtins.property
    @pulumi.getter
    def system(self) -> Optional[_builtins.str]:
        """
        The name of the source system. Maximum length is 64 characters.
        """
        return pulumi.get(self, "system")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        The time when the resource was last updated in the source system.
        If the entry exists in the system and its EntrySource has updateTime populated,
        further updates to the EntrySource of the entry must provide incremental updates to its updateTime.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class EntryEntrySourceAncestor(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the ancestor resource.
        :param _builtins.str type: The type of the ancestor resource.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the ancestor resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the ancestor resource.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EntryGroupIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class EntryGroupIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class EntryTypeIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class EntryTypeIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class EntryTypeRequiredAspect(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Required aspect type for the entry type.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Required aspect type for the entry type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GlossaryIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class GlossaryIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class LakeAssetStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeAssets":
            suggest = "active_assets"
        elif key == "securityPolicyApplyingAssets":
            suggest = "security_policy_applying_assets"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LakeAssetStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LakeAssetStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LakeAssetStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_assets: Optional[_builtins.int] = None,
                 security_policy_applying_assets: Optional[_builtins.int] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.int active_assets: Number of active assets.
        :param _builtins.int security_policy_applying_assets: Number of assets that are in process of updating the security policy on attached resources.
        :param _builtins.str update_time: Output only. The time when the lake was last updated.
        """
        if active_assets is not None:
            pulumi.set(__self__, "active_assets", active_assets)
        if security_policy_applying_assets is not None:
            pulumi.set(__self__, "security_policy_applying_assets", security_policy_applying_assets)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="activeAssets")
    def active_assets(self) -> Optional[_builtins.int]:
        """
        Number of active assets.
        """
        return pulumi.get(self, "active_assets")

    @_builtins.property
    @pulumi.getter(name="securityPolicyApplyingAssets")
    def security_policy_applying_assets(self) -> Optional[_builtins.int]:
        """
        Number of assets that are in process of updating the security policy on attached resources.
        """
        return pulumi.get(self, "security_policy_applying_assets")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        Output only. The time when the lake was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class LakeIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class LakeIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class LakeMetastore(dict):
    def __init__(__self__, *,
                 service: Optional[_builtins.str] = None):
        """
        :param _builtins.str service: Optional. A relative reference to the Dataproc Metastore (https://cloud.google.com/dataproc-metastore/docs) service associated with the lake: `projects/{project_id}/locations/{location_id}/services/{service_id}`
        """
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Optional. A relative reference to the Dataproc Metastore (https://cloud.google.com/dataproc-metastore/docs) service associated with the lake: `projects/{project_id}/locations/{location_id}/services/{service_id}`
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class LakeMetastoreStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LakeMetastoreStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LakeMetastoreStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LakeMetastoreStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str endpoint: The URI of the endpoint used to access the Metastore service.
        :param _builtins.str message: Additional information about the current status.
        :param _builtins.str state: Output only. Current state of the lake. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param _builtins.str update_time: Output only. The time when the lake was last updated.
        """
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The URI of the endpoint used to access the Metastore service.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Additional information about the current status.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Output only. Current state of the lake. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        Output only. The time when the lake was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class TaskExecutionSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccount":
            suggest = "service_account"
        elif key == "kmsKey":
            suggest = "kms_key"
        elif key == "maxJobExecutionLifetime":
            suggest = "max_job_execution_lifetime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskExecutionSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskExecutionSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskExecutionSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account: _builtins.str,
                 args: Optional[Mapping[str, _builtins.str]] = None,
                 kms_key: Optional[_builtins.str] = None,
                 max_job_execution_lifetime: Optional[_builtins.str] = None,
                 project: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_account: Service account to use to execute a task. If not provided, the default Compute service account for the project is used.
        :param Mapping[str, _builtins.str] args: The arguments to pass to the task. The args can use placeholders of the format ${placeholder} as part of key/value string. These will be interpolated before passing the args to the driver. Currently supported placeholders: - ${taskId} - ${job_time} To pass positional args, set the key as TASK_ARGS. The value should be a comma-separated string of all the positional arguments. To use a delimiter other than comma, refer to https://cloud.google.com/sdk/gcloud/reference/topic/escaping. In case of other keys being present in the args, then TASK_ARGS will be passed as the last argument. An object containing a list of 'key': value pairs. Example: { 'name': 'wrench', 'mass': '1.3kg', 'count': '3' }.
        :param _builtins.str kms_key: The Cloud KMS key to use for encryption, of the form: projects/{project_number}/locations/{locationId}/keyRings/{key-ring-name}/cryptoKeys/{key-name}.
        :param _builtins.str max_job_execution_lifetime: The maximum duration after which the job execution is expired. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'.
        :param _builtins.str project: The project in which jobs are run. By default, the project containing the Lake is used. If a project is provided, the ExecutionSpec.service_account must belong to this project.
        """
        pulumi.set(__self__, "service_account", service_account)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if max_job_execution_lifetime is not None:
            pulumi.set(__self__, "max_job_execution_lifetime", max_job_execution_lifetime)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> _builtins.str:
        """
        Service account to use to execute a task. If not provided, the default Compute service account for the project is used.
        """
        return pulumi.get(self, "service_account")

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The arguments to pass to the task. The args can use placeholders of the format ${placeholder} as part of key/value string. These will be interpolated before passing the args to the driver. Currently supported placeholders: - ${taskId} - ${job_time} To pass positional args, set the key as TASK_ARGS. The value should be a comma-separated string of all the positional arguments. To use a delimiter other than comma, refer to https://cloud.google.com/sdk/gcloud/reference/topic/escaping. In case of other keys being present in the args, then TASK_ARGS will be passed as the last argument. An object containing a list of 'key': value pairs. Example: { 'name': 'wrench', 'mass': '1.3kg', 'count': '3' }.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        """
        The Cloud KMS key to use for encryption, of the form: projects/{project_number}/locations/{locationId}/keyRings/{key-ring-name}/cryptoKeys/{key-name}.
        """
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter(name="maxJobExecutionLifetime")
    def max_job_execution_lifetime(self) -> Optional[_builtins.str]:
        """
        The maximum duration after which the job execution is expired. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'.
        """
        return pulumi.get(self, "max_job_execution_lifetime")

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional[_builtins.str]:
        """
        The project in which jobs are run. By default, the project containing the Lake is used. If a project is provided, the ExecutionSpec.service_account must belong to this project.
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class TaskExecutionStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestJobs":
            suggest = "latest_jobs"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskExecutionStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskExecutionStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskExecutionStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_jobs: Optional[Sequence['outputs.TaskExecutionStatusLatestJob']] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param Sequence['TaskExecutionStatusLatestJobArgs'] latest_jobs: (Output)
               latest job execution.
               Structure is documented below.
        :param _builtins.str update_time: (Output)
               Last update time of the status.
        """
        if latest_jobs is not None:
            pulumi.set(__self__, "latest_jobs", latest_jobs)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="latestJobs")
    def latest_jobs(self) -> Optional[Sequence['outputs.TaskExecutionStatusLatestJob']]:
        """
        (Output)
        latest job execution.
        Structure is documented below.
        """
        return pulumi.get(self, "latest_jobs")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Last update time of the status.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class TaskExecutionStatusLatestJob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "retryCount":
            suggest = "retry_count"
        elif key == "serviceJob":
            suggest = "service_job"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskExecutionStatusLatestJob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskExecutionStatusLatestJob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskExecutionStatusLatestJob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 retry_count: Optional[_builtins.int] = None,
                 service: Optional[_builtins.str] = None,
                 service_job: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str end_time: (Output)
               The time when the job ended.
        :param _builtins.str message: (Output)
               Additional information about the current state.
        :param _builtins.str name: (Output)
               The relative resource name of the job, of the form: projects/{project_number}/locations/{locationId}/lakes/{lakeId}/tasks/{taskId}/jobs/{jobId}.
        :param _builtins.int retry_count: (Output)
               The number of times the job has been retried (excluding the initial attempt).
        :param _builtins.str service: (Output)
               The underlying service running a job.
        :param _builtins.str service_job: (Output)
               The full resource name for the job run under a particular service.
        :param _builtins.str start_time: (Output)
               The time when the job was started.
        :param _builtins.str state: (Output)
               Execution state for the job.
        :param _builtins.str uid: (Output)
               System generated globally unique ID for the job.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if service_job is not None:
            pulumi.set(__self__, "service_job", service_job)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        The time when the job ended.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        (Output)
        Additional information about the current state.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The relative resource name of the job, of the form: projects/{project_number}/locations/{locationId}/lakes/{lakeId}/tasks/{taskId}/jobs/{jobId}.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[_builtins.int]:
        """
        (Output)
        The number of times the job has been retried (excluding the initial attempt).
        """
        return pulumi.get(self, "retry_count")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        (Output)
        The underlying service running a job.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="serviceJob")
    def service_job(self) -> Optional[_builtins.str]:
        """
        (Output)
        The full resource name for the job run under a particular service.
        """
        return pulumi.get(self, "service_job")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        The time when the job was started.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        Execution state for the job.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        (Output)
        System generated globally unique ID for the job.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class TaskIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class TaskIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class TaskNotebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archiveUris":
            suggest = "archive_uris"
        elif key == "fileUris":
            suggest = "file_uris"
        elif key == "infrastructureSpec":
            suggest = "infrastructure_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskNotebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskNotebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskNotebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notebook: _builtins.str,
                 archive_uris: Optional[Sequence[_builtins.str]] = None,
                 file_uris: Optional[Sequence[_builtins.str]] = None,
                 infrastructure_spec: Optional['outputs.TaskNotebookInfrastructureSpec'] = None):
        """
        :param _builtins.str notebook: Path to input notebook. This can be the Cloud Storage URI of the notebook file or the path to a Notebook Content. The execution args are accessible as environment variables (TASK_key=value).
        :param Sequence[_builtins.str] archive_uris: Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        :param Sequence[_builtins.str] file_uris: Cloud Storage URIs of files to be placed in the working directory of each executor.
        :param 'TaskNotebookInfrastructureSpecArgs' infrastructure_spec: Infrastructure specification for the execution.
               Structure is documented below.
        """
        pulumi.set(__self__, "notebook", notebook)
        if archive_uris is not None:
            pulumi.set(__self__, "archive_uris", archive_uris)
        if file_uris is not None:
            pulumi.set(__self__, "file_uris", file_uris)
        if infrastructure_spec is not None:
            pulumi.set(__self__, "infrastructure_spec", infrastructure_spec)

    @_builtins.property
    @pulumi.getter
    def notebook(self) -> _builtins.str:
        """
        Path to input notebook. This can be the Cloud Storage URI of the notebook file or the path to a Notebook Content. The execution args are accessible as environment variables (TASK_key=value).
        """
        return pulumi.get(self, "notebook")

    @_builtins.property
    @pulumi.getter(name="archiveUris")
    def archive_uris(self) -> Optional[Sequence[_builtins.str]]:
        """
        Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        """
        return pulumi.get(self, "archive_uris")

    @_builtins.property
    @pulumi.getter(name="fileUris")
    def file_uris(self) -> Optional[Sequence[_builtins.str]]:
        """
        Cloud Storage URIs of files to be placed in the working directory of each executor.
        """
        return pulumi.get(self, "file_uris")

    @_builtins.property
    @pulumi.getter(name="infrastructureSpec")
    def infrastructure_spec(self) -> Optional['outputs.TaskNotebookInfrastructureSpec']:
        """
        Infrastructure specification for the execution.
        Structure is documented below.
        """
        return pulumi.get(self, "infrastructure_spec")


@pulumi.output_type
class TaskNotebookInfrastructureSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerImage":
            suggest = "container_image"
        elif key == "vpcNetwork":
            suggest = "vpc_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskNotebookInfrastructureSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskNotebookInfrastructureSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskNotebookInfrastructureSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch: Optional['outputs.TaskNotebookInfrastructureSpecBatch'] = None,
                 container_image: Optional['outputs.TaskNotebookInfrastructureSpecContainerImage'] = None,
                 vpc_network: Optional['outputs.TaskNotebookInfrastructureSpecVpcNetwork'] = None):
        """
        :param 'TaskNotebookInfrastructureSpecBatchArgs' batch: Compute resources needed for a Task when using Dataproc Serverless.
               Structure is documented below.
        :param 'TaskNotebookInfrastructureSpecContainerImageArgs' container_image: Container Image Runtime Configuration.
               Structure is documented below.
        :param 'TaskNotebookInfrastructureSpecVpcNetworkArgs' vpc_network: Vpc network.
               Structure is documented below.
        """
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if container_image is not None:
            pulumi.set(__self__, "container_image", container_image)
        if vpc_network is not None:
            pulumi.set(__self__, "vpc_network", vpc_network)

    @_builtins.property
    @pulumi.getter
    def batch(self) -> Optional['outputs.TaskNotebookInfrastructureSpecBatch']:
        """
        Compute resources needed for a Task when using Dataproc Serverless.
        Structure is documented below.
        """
        return pulumi.get(self, "batch")

    @_builtins.property
    @pulumi.getter(name="containerImage")
    def container_image(self) -> Optional['outputs.TaskNotebookInfrastructureSpecContainerImage']:
        """
        Container Image Runtime Configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "container_image")

    @_builtins.property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> Optional['outputs.TaskNotebookInfrastructureSpecVpcNetwork']:
        """
        Vpc network.
        Structure is documented below.
        """
        return pulumi.get(self, "vpc_network")


@pulumi.output_type
class TaskNotebookInfrastructureSpecBatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executorsCount":
            suggest = "executors_count"
        elif key == "maxExecutorsCount":
            suggest = "max_executors_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskNotebookInfrastructureSpecBatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskNotebookInfrastructureSpecBatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskNotebookInfrastructureSpecBatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 executors_count: Optional[_builtins.int] = None,
                 max_executors_count: Optional[_builtins.int] = None):
        """
        :param _builtins.int executors_count: Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        :param _builtins.int max_executors_count: Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        if executors_count is not None:
            pulumi.set(__self__, "executors_count", executors_count)
        if max_executors_count is not None:
            pulumi.set(__self__, "max_executors_count", max_executors_count)

    @_builtins.property
    @pulumi.getter(name="executorsCount")
    def executors_count(self) -> Optional[_builtins.int]:
        """
        Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        """
        return pulumi.get(self, "executors_count")

    @_builtins.property
    @pulumi.getter(name="maxExecutorsCount")
    def max_executors_count(self) -> Optional[_builtins.int]:
        """
        Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        return pulumi.get(self, "max_executors_count")


@pulumi.output_type
class TaskNotebookInfrastructureSpecContainerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "javaJars":
            suggest = "java_jars"
        elif key == "pythonPackages":
            suggest = "python_packages"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskNotebookInfrastructureSpecContainerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskNotebookInfrastructureSpecContainerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskNotebookInfrastructureSpecContainerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: Optional[_builtins.str] = None,
                 java_jars: Optional[Sequence[_builtins.str]] = None,
                 properties: Optional[Mapping[str, _builtins.str]] = None,
                 python_packages: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str image: Container image to use.
        :param Sequence[_builtins.str] java_jars: A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        :param Mapping[str, _builtins.str] properties: Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        :param Sequence[_builtins.str] python_packages: A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if java_jars is not None:
            pulumi.set(__self__, "java_jars", java_jars)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if python_packages is not None:
            pulumi.set(__self__, "python_packages", python_packages)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Container image to use.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="javaJars")
    def java_jars(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        """
        return pulumi.get(self, "java_jars")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="pythonPackages")
    def python_packages(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        return pulumi.get(self, "python_packages")


@pulumi.output_type
class TaskNotebookInfrastructureSpecVpcNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkTags":
            suggest = "network_tags"
        elif key == "subNetwork":
            suggest = "sub_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskNotebookInfrastructureSpecVpcNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskNotebookInfrastructureSpecVpcNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskNotebookInfrastructureSpecVpcNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network: Optional[_builtins.str] = None,
                 network_tags: Optional[Sequence[_builtins.str]] = None,
                 sub_network: Optional[_builtins.str] = None):
        """
        :param _builtins.str network: The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        :param Sequence[_builtins.str] network_tags: List of network tags to apply to the job.
        :param _builtins.str sub_network: The Cloud VPC sub-network in which the job is run.
        """
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_tags is not None:
            pulumi.set(__self__, "network_tags", network_tags)
        if sub_network is not None:
            pulumi.set(__self__, "sub_network", sub_network)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="networkTags")
    def network_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of network tags to apply to the job.
        """
        return pulumi.get(self, "network_tags")

    @_builtins.property
    @pulumi.getter(name="subNetwork")
    def sub_network(self) -> Optional[_builtins.str]:
        """
        The Cloud VPC sub-network in which the job is run.
        """
        return pulumi.get(self, "sub_network")


@pulumi.output_type
class TaskSpark(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archiveUris":
            suggest = "archive_uris"
        elif key == "fileUris":
            suggest = "file_uris"
        elif key == "infrastructureSpec":
            suggest = "infrastructure_spec"
        elif key == "mainClass":
            suggest = "main_class"
        elif key == "mainJarFileUri":
            suggest = "main_jar_file_uri"
        elif key == "pythonScriptFile":
            suggest = "python_script_file"
        elif key == "sqlScript":
            suggest = "sql_script"
        elif key == "sqlScriptFile":
            suggest = "sql_script_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskSpark. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskSpark.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskSpark.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive_uris: Optional[Sequence[_builtins.str]] = None,
                 file_uris: Optional[Sequence[_builtins.str]] = None,
                 infrastructure_spec: Optional['outputs.TaskSparkInfrastructureSpec'] = None,
                 main_class: Optional[_builtins.str] = None,
                 main_jar_file_uri: Optional[_builtins.str] = None,
                 python_script_file: Optional[_builtins.str] = None,
                 sql_script: Optional[_builtins.str] = None,
                 sql_script_file: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] archive_uris: Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        :param Sequence[_builtins.str] file_uris: Cloud Storage URIs of files to be placed in the working directory of each executor.
        :param 'TaskSparkInfrastructureSpecArgs' infrastructure_spec: Infrastructure specification for the execution.
               Structure is documented below.
        :param _builtins.str main_class: The name of the driver's main class. The jar file that contains the class must be in the default CLASSPATH or specified in jar_file_uris. The execution args are passed in as a sequence of named process arguments (--key=value).
        :param _builtins.str main_jar_file_uri: The Cloud Storage URI of the jar file that contains the main class. The execution args are passed in as a sequence of named process arguments (--key=value).
        :param _builtins.str python_script_file: The Gcloud Storage URI of the main Python file to use as the driver. Must be a .py file. The execution args are passed in as a sequence of named process arguments (--key=value).
        :param _builtins.str sql_script: The query text. The execution args are used to declare a set of script variables (set key='value';).
        :param _builtins.str sql_script_file: A reference to a query file. This can be the Cloud Storage URI of the query file or it can the path to a SqlScript Content. The execution args are used to declare a set of script variables (set key='value';).
        """
        if archive_uris is not None:
            pulumi.set(__self__, "archive_uris", archive_uris)
        if file_uris is not None:
            pulumi.set(__self__, "file_uris", file_uris)
        if infrastructure_spec is not None:
            pulumi.set(__self__, "infrastructure_spec", infrastructure_spec)
        if main_class is not None:
            pulumi.set(__self__, "main_class", main_class)
        if main_jar_file_uri is not None:
            pulumi.set(__self__, "main_jar_file_uri", main_jar_file_uri)
        if python_script_file is not None:
            pulumi.set(__self__, "python_script_file", python_script_file)
        if sql_script is not None:
            pulumi.set(__self__, "sql_script", sql_script)
        if sql_script_file is not None:
            pulumi.set(__self__, "sql_script_file", sql_script_file)

    @_builtins.property
    @pulumi.getter(name="archiveUris")
    def archive_uris(self) -> Optional[Sequence[_builtins.str]]:
        """
        Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        """
        return pulumi.get(self, "archive_uris")

    @_builtins.property
    @pulumi.getter(name="fileUris")
    def file_uris(self) -> Optional[Sequence[_builtins.str]]:
        """
        Cloud Storage URIs of files to be placed in the working directory of each executor.
        """
        return pulumi.get(self, "file_uris")

    @_builtins.property
    @pulumi.getter(name="infrastructureSpec")
    def infrastructure_spec(self) -> Optional['outputs.TaskSparkInfrastructureSpec']:
        """
        Infrastructure specification for the execution.
        Structure is documented below.
        """
        return pulumi.get(self, "infrastructure_spec")

    @_builtins.property
    @pulumi.getter(name="mainClass")
    def main_class(self) -> Optional[_builtins.str]:
        """
        The name of the driver's main class. The jar file that contains the class must be in the default CLASSPATH or specified in jar_file_uris. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        return pulumi.get(self, "main_class")

    @_builtins.property
    @pulumi.getter(name="mainJarFileUri")
    def main_jar_file_uri(self) -> Optional[_builtins.str]:
        """
        The Cloud Storage URI of the jar file that contains the main class. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        return pulumi.get(self, "main_jar_file_uri")

    @_builtins.property
    @pulumi.getter(name="pythonScriptFile")
    def python_script_file(self) -> Optional[_builtins.str]:
        """
        The Gcloud Storage URI of the main Python file to use as the driver. Must be a .py file. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        return pulumi.get(self, "python_script_file")

    @_builtins.property
    @pulumi.getter(name="sqlScript")
    def sql_script(self) -> Optional[_builtins.str]:
        """
        The query text. The execution args are used to declare a set of script variables (set key='value';).
        """
        return pulumi.get(self, "sql_script")

    @_builtins.property
    @pulumi.getter(name="sqlScriptFile")
    def sql_script_file(self) -> Optional[_builtins.str]:
        """
        A reference to a query file. This can be the Cloud Storage URI of the query file or it can the path to a SqlScript Content. The execution args are used to declare a set of script variables (set key='value';).
        """
        return pulumi.get(self, "sql_script_file")


@pulumi.output_type
class TaskSparkInfrastructureSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerImage":
            suggest = "container_image"
        elif key == "vpcNetwork":
            suggest = "vpc_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskSparkInfrastructureSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskSparkInfrastructureSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskSparkInfrastructureSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch: Optional['outputs.TaskSparkInfrastructureSpecBatch'] = None,
                 container_image: Optional['outputs.TaskSparkInfrastructureSpecContainerImage'] = None,
                 vpc_network: Optional['outputs.TaskSparkInfrastructureSpecVpcNetwork'] = None):
        """
        :param 'TaskSparkInfrastructureSpecBatchArgs' batch: Compute resources needed for a Task when using Dataproc Serverless.
               Structure is documented below.
        :param 'TaskSparkInfrastructureSpecContainerImageArgs' container_image: Container Image Runtime Configuration.
               Structure is documented below.
        :param 'TaskSparkInfrastructureSpecVpcNetworkArgs' vpc_network: Vpc network.
               Structure is documented below.
        """
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if container_image is not None:
            pulumi.set(__self__, "container_image", container_image)
        if vpc_network is not None:
            pulumi.set(__self__, "vpc_network", vpc_network)

    @_builtins.property
    @pulumi.getter
    def batch(self) -> Optional['outputs.TaskSparkInfrastructureSpecBatch']:
        """
        Compute resources needed for a Task when using Dataproc Serverless.
        Structure is documented below.
        """
        return pulumi.get(self, "batch")

    @_builtins.property
    @pulumi.getter(name="containerImage")
    def container_image(self) -> Optional['outputs.TaskSparkInfrastructureSpecContainerImage']:
        """
        Container Image Runtime Configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "container_image")

    @_builtins.property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> Optional['outputs.TaskSparkInfrastructureSpecVpcNetwork']:
        """
        Vpc network.
        Structure is documented below.
        """
        return pulumi.get(self, "vpc_network")


@pulumi.output_type
class TaskSparkInfrastructureSpecBatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executorsCount":
            suggest = "executors_count"
        elif key == "maxExecutorsCount":
            suggest = "max_executors_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskSparkInfrastructureSpecBatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskSparkInfrastructureSpecBatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskSparkInfrastructureSpecBatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 executors_count: Optional[_builtins.int] = None,
                 max_executors_count: Optional[_builtins.int] = None):
        """
        :param _builtins.int executors_count: Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        :param _builtins.int max_executors_count: Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        if executors_count is not None:
            pulumi.set(__self__, "executors_count", executors_count)
        if max_executors_count is not None:
            pulumi.set(__self__, "max_executors_count", max_executors_count)

    @_builtins.property
    @pulumi.getter(name="executorsCount")
    def executors_count(self) -> Optional[_builtins.int]:
        """
        Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        """
        return pulumi.get(self, "executors_count")

    @_builtins.property
    @pulumi.getter(name="maxExecutorsCount")
    def max_executors_count(self) -> Optional[_builtins.int]:
        """
        Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        return pulumi.get(self, "max_executors_count")


@pulumi.output_type
class TaskSparkInfrastructureSpecContainerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "javaJars":
            suggest = "java_jars"
        elif key == "pythonPackages":
            suggest = "python_packages"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskSparkInfrastructureSpecContainerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskSparkInfrastructureSpecContainerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskSparkInfrastructureSpecContainerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: Optional[_builtins.str] = None,
                 java_jars: Optional[Sequence[_builtins.str]] = None,
                 properties: Optional[Mapping[str, _builtins.str]] = None,
                 python_packages: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str image: Container image to use.
        :param Sequence[_builtins.str] java_jars: A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        :param Mapping[str, _builtins.str] properties: Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        :param Sequence[_builtins.str] python_packages: A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if java_jars is not None:
            pulumi.set(__self__, "java_jars", java_jars)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if python_packages is not None:
            pulumi.set(__self__, "python_packages", python_packages)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Container image to use.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="javaJars")
    def java_jars(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        """
        return pulumi.get(self, "java_jars")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="pythonPackages")
    def python_packages(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        return pulumi.get(self, "python_packages")


@pulumi.output_type
class TaskSparkInfrastructureSpecVpcNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkTags":
            suggest = "network_tags"
        elif key == "subNetwork":
            suggest = "sub_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskSparkInfrastructureSpecVpcNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskSparkInfrastructureSpecVpcNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskSparkInfrastructureSpecVpcNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network: Optional[_builtins.str] = None,
                 network_tags: Optional[Sequence[_builtins.str]] = None,
                 sub_network: Optional[_builtins.str] = None):
        """
        :param _builtins.str network: The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        :param Sequence[_builtins.str] network_tags: List of network tags to apply to the job.
        :param _builtins.str sub_network: The Cloud VPC sub-network in which the job is run.
        """
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_tags is not None:
            pulumi.set(__self__, "network_tags", network_tags)
        if sub_network is not None:
            pulumi.set(__self__, "sub_network", sub_network)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="networkTags")
    def network_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of network tags to apply to the job.
        """
        return pulumi.get(self, "network_tags")

    @_builtins.property
    @pulumi.getter(name="subNetwork")
    def sub_network(self) -> Optional[_builtins.str]:
        """
        The Cloud VPC sub-network in which the job is run.
        """
        return pulumi.get(self, "sub_network")


@pulumi.output_type
class TaskTriggerSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRetries":
            suggest = "max_retries"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskTriggerSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskTriggerSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskTriggerSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 max_retries: Optional[_builtins.int] = None,
                 schedule: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Trigger type of the user-specified Task
               Possible values are: `ON_DEMAND`, `RECURRING`.
        :param _builtins.bool disabled: Prevent the task from executing. This does not cancel already running tasks. It is intended to temporarily disable RECURRING tasks.
        :param _builtins.int max_retries: Number of retry attempts before aborting. Set to zero to never attempt to retry a failed task.
        :param _builtins.str schedule: Cron schedule (https://en.wikipedia.org/wiki/Cron) for running tasks periodically. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: 'CRON_TZ=${IANA_TIME_ZONE}' or 'TZ=${IANA_TIME_ZONE}'. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, CRON_TZ=America/New_York 1 * * * *, or TZ=America/New_York 1 * * * *. This field is required for RECURRING tasks.
        :param _builtins.str start_time: The first run of the task will be after this time. If not specified, the task will run shortly after being submitted if ON_DEMAND and based on the schedule if RECURRING.
        """
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Trigger type of the user-specified Task
        Possible values are: `ON_DEMAND`, `RECURRING`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Prevent the task from executing. This does not cancel already running tasks. It is intended to temporarily disable RECURRING tasks.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        """
        Number of retry attempts before aborting. Set to zero to never attempt to retry a failed task.
        """
        return pulumi.get(self, "max_retries")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional[_builtins.str]:
        """
        Cron schedule (https://en.wikipedia.org/wiki/Cron) for running tasks periodically. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: 'CRON_TZ=${IANA_TIME_ZONE}' or 'TZ=${IANA_TIME_ZONE}'. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, CRON_TZ=America/New_York 1 * * * *, or TZ=America/New_York 1 * * * *. This field is required for RECURRING tasks.
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        The first run of the task will be after this time. If not specified, the task will run shortly after being submitted if ON_DEMAND and based on the schedule if RECURRING.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ZoneAssetStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeAssets":
            suggest = "active_assets"
        elif key == "securityPolicyApplyingAssets":
            suggest = "security_policy_applying_assets"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneAssetStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneAssetStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneAssetStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_assets: Optional[_builtins.int] = None,
                 security_policy_applying_assets: Optional[_builtins.int] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.int active_assets: Number of active assets.
        :param _builtins.int security_policy_applying_assets: Number of assets that are in process of updating the security policy on attached resources.
        :param _builtins.str update_time: Output only. The time when the zone was last updated.
        """
        if active_assets is not None:
            pulumi.set(__self__, "active_assets", active_assets)
        if security_policy_applying_assets is not None:
            pulumi.set(__self__, "security_policy_applying_assets", security_policy_applying_assets)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="activeAssets")
    def active_assets(self) -> Optional[_builtins.int]:
        """
        Number of active assets.
        """
        return pulumi.get(self, "active_assets")

    @_builtins.property
    @pulumi.getter(name="securityPolicyApplyingAssets")
    def security_policy_applying_assets(self) -> Optional[_builtins.int]:
        """
        Number of assets that are in process of updating the security policy on attached resources.
        """
        return pulumi.get(self, "security_policy_applying_assets")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        Output only. The time when the zone was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class ZoneDiscoverySpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "csvOptions":
            suggest = "csv_options"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"
        elif key == "jsonOptions":
            suggest = "json_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneDiscoverySpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneDiscoverySpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneDiscoverySpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 csv_options: Optional['outputs.ZoneDiscoverySpecCsvOptions'] = None,
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None,
                 json_options: Optional['outputs.ZoneDiscoverySpecJsonOptions'] = None,
                 schedule: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Required. Whether discovery is enabled.
        :param 'ZoneDiscoverySpecCsvOptionsArgs' csv_options: Optional. Configuration for CSV data.
        :param Sequence[_builtins.str] exclude_patterns: Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param Sequence[_builtins.str] include_patterns: Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param 'ZoneDiscoverySpecJsonOptionsArgs' json_options: Optional. Configuration for Json data.
        :param _builtins.str schedule: Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        pulumi.set(__self__, "enabled", enabled)
        if csv_options is not None:
            pulumi.set(__self__, "csv_options", csv_options)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if json_options is not None:
            pulumi.set(__self__, "json_options", json_options)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Required. Whether discovery is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="csvOptions")
    def csv_options(self) -> Optional['outputs.ZoneDiscoverySpecCsvOptions']:
        """
        Optional. Configuration for CSV data.
        """
        return pulumi.get(self, "csv_options")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "include_patterns")

    @_builtins.property
    @pulumi.getter(name="jsonOptions")
    def json_options(self) -> Optional['outputs.ZoneDiscoverySpecJsonOptions']:
        """
        Optional. Configuration for Json data.
        """
        return pulumi.get(self, "json_options")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional[_builtins.str]:
        """
        Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class ZoneDiscoverySpecCsvOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableTypeInference":
            suggest = "disable_type_inference"
        elif key == "headerRows":
            suggest = "header_rows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneDiscoverySpecCsvOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneDiscoverySpecCsvOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneDiscoverySpecCsvOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[_builtins.str] = None,
                 disable_type_inference: Optional[_builtins.bool] = None,
                 encoding: Optional[_builtins.str] = None,
                 header_rows: Optional[_builtins.int] = None):
        """
        :param _builtins.str delimiter: Optional. The delimiter being used to separate values. This defaults to ','.
        :param _builtins.bool disable_type_inference: Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        :param _builtins.str encoding: Optional. The character encoding of the data. The default is UTF-8.
        :param _builtins.int header_rows: Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if header_rows is not None:
            pulumi.set(__self__, "header_rows", header_rows)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[_builtins.str]:
        """
        Optional. The delimiter being used to separate values. This defaults to ','.
        """
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[_builtins.bool]:
        """
        Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        """
        return pulumi.get(self, "disable_type_inference")

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> Optional[_builtins.str]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @_builtins.property
    @pulumi.getter(name="headerRows")
    def header_rows(self) -> Optional[_builtins.int]:
        """
        Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        return pulumi.get(self, "header_rows")


@pulumi.output_type
class ZoneDiscoverySpecJsonOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableTypeInference":
            suggest = "disable_type_inference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneDiscoverySpecJsonOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneDiscoverySpecJsonOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneDiscoverySpecJsonOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_type_inference: Optional[_builtins.bool] = None,
                 encoding: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disable_type_inference: Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        :param _builtins.str encoding: Optional. The character encoding of the data. The default is UTF-8.
        """
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @_builtins.property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[_builtins.bool]:
        """
        Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        """
        return pulumi.get(self, "disable_type_inference")

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> Optional[_builtins.str]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")


@pulumi.output_type
class ZoneIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class ZoneIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class ZoneResourceSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "locationType":
            suggest = "location_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneResourceSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneResourceSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneResourceSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location_type: _builtins.str):
        """
        :param _builtins.str location_type: Required. Immutable. The location type of the resources that are allowed to be attached to the assets within this zone. Possible values: LOCATION_TYPE_UNSPECIFIED, SINGLE_REGION, MULTI_REGION
               
               - - -
        """
        pulumi.set(__self__, "location_type", location_type)

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> _builtins.str:
        """
        Required. Immutable. The location type of the resources that are allowed to be attached to the assets within this zone. Possible values: LOCATION_TYPE_UNSPECIFIED, SINGLE_REGION, MULTI_REGION

        - - -
        """
        return pulumi.get(self, "location_type")


@pulumi.output_type
class GetDataQualityRulesRuleResult(dict):
    def __init__(__self__, *,
                 column: _builtins.str,
                 description: _builtins.str,
                 dimension: _builtins.str,
                 ignore_null: _builtins.bool,
                 name: _builtins.str,
                 non_null_expectations: Sequence['outputs.GetDataQualityRulesRuleNonNullExpectationResult'],
                 range_expectations: Sequence['outputs.GetDataQualityRulesRuleRangeExpectationResult'],
                 regex_expectations: Sequence['outputs.GetDataQualityRulesRuleRegexExpectationResult'],
                 row_condition_expectations: Sequence['outputs.GetDataQualityRulesRuleRowConditionExpectationResult'],
                 set_expectations: Sequence['outputs.GetDataQualityRulesRuleSetExpectationResult'],
                 sql_assertions: Sequence['outputs.GetDataQualityRulesRuleSqlAssertionResult'],
                 statistic_range_expectations: Sequence['outputs.GetDataQualityRulesRuleStatisticRangeExpectationResult'],
                 suspended: _builtins.bool,
                 table_condition_expectations: Sequence['outputs.GetDataQualityRulesRuleTableConditionExpectationResult'],
                 threshold: _builtins.float,
                 uniqueness_expectations: Sequence['outputs.GetDataQualityRulesRuleUniquenessExpectationResult']):
        """
        :param _builtins.str column: The unnested column which this rule is evaluated against.
        :param _builtins.str description: Description of the rule. (The maximum length is 1,024 characters.)
        :param _builtins.str dimension: The dimension a rule belongs to. Supported dimensions are "COMPLETENESS", "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "FRESHNESS", "VOLUME"
        :param _builtins.bool ignore_null: Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. 
               											This field is only valid for the following type of rules: RangeExpectation, RegexExpectation, SetExpectation, UniquenessExpectation
        :param _builtins.str name: A mutable name for the rule. 
               											The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
               											The maximum length is 63 characters.
               											Must start with a letter.
               											Must end with a number or a letter.
        :param Sequence['GetDataQualityRulesRuleNonNullExpectationArgs'] non_null_expectations: Row-level rule which evaluates whether each column value is null.
        :param Sequence['GetDataQualityRulesRuleRangeExpectationArgs'] range_expectations: Row-level rule which evaluates whether each column value lies between a specified range.
        :param Sequence['GetDataQualityRulesRuleRegexExpectationArgs'] regex_expectations: Row-level rule which evaluates whether each column value matches a specified regex.
        :param Sequence['GetDataQualityRulesRuleRowConditionExpectationArgs'] row_condition_expectations: Row-level rule which evaluates whether each row in a table passes the specified condition.
        :param Sequence['GetDataQualityRulesRuleSetExpectationArgs'] set_expectations: Row-level rule which evaluates whether each column value is contained by a specified set.
        :param Sequence['GetDataQualityRulesRuleSqlAssertionArgs'] sql_assertions: Aggregate rule which evaluates the number of rows returned for the provided statement. If any rows are returned, this rule fails.
        :param Sequence['GetDataQualityRulesRuleStatisticRangeExpectationArgs'] statistic_range_expectations: Aggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
        :param _builtins.bool suspended: Whether the Rule is active or suspended. Default is false.
        :param Sequence['GetDataQualityRulesRuleTableConditionExpectationArgs'] table_condition_expectations: Aggregate rule which evaluates whether the provided expression is true for a table.
        :param _builtins.float threshold: The minimum ratio of passing_rows / total_rows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0). This field is only valid for row-level type rules.
        :param Sequence['GetDataQualityRulesRuleUniquenessExpectationArgs'] uniqueness_expectations: Row-level rule which evaluates whether each column value is unique.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "ignore_null", ignore_null)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "non_null_expectations", non_null_expectations)
        pulumi.set(__self__, "range_expectations", range_expectations)
        pulumi.set(__self__, "regex_expectations", regex_expectations)
        pulumi.set(__self__, "row_condition_expectations", row_condition_expectations)
        pulumi.set(__self__, "set_expectations", set_expectations)
        pulumi.set(__self__, "sql_assertions", sql_assertions)
        pulumi.set(__self__, "statistic_range_expectations", statistic_range_expectations)
        pulumi.set(__self__, "suspended", suspended)
        pulumi.set(__self__, "table_condition_expectations", table_condition_expectations)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "uniqueness_expectations", uniqueness_expectations)

    @_builtins.property
    @pulumi.getter
    def column(self) -> _builtins.str:
        """
        The unnested column which this rule is evaluated against.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the rule. (The maximum length is 1,024 characters.)
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> _builtins.str:
        """
        The dimension a rule belongs to. Supported dimensions are "COMPLETENESS", "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "FRESHNESS", "VOLUME"
        """
        return pulumi.get(self, "dimension")

    @_builtins.property
    @pulumi.getter(name="ignoreNull")
    def ignore_null(self) -> _builtins.bool:
        """
        Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. 
        											This field is only valid for the following type of rules: RangeExpectation, RegexExpectation, SetExpectation, UniquenessExpectation
        """
        return pulumi.get(self, "ignore_null")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A mutable name for the rule. 
        											The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
        											The maximum length is 63 characters.
        											Must start with a letter.
        											Must end with a number or a letter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nonNullExpectations")
    def non_null_expectations(self) -> Sequence['outputs.GetDataQualityRulesRuleNonNullExpectationResult']:
        """
        Row-level rule which evaluates whether each column value is null.
        """
        return pulumi.get(self, "non_null_expectations")

    @_builtins.property
    @pulumi.getter(name="rangeExpectations")
    def range_expectations(self) -> Sequence['outputs.GetDataQualityRulesRuleRangeExpectationResult']:
        """
        Row-level rule which evaluates whether each column value lies between a specified range.
        """
        return pulumi.get(self, "range_expectations")

    @_builtins.property
    @pulumi.getter(name="regexExpectations")
    def regex_expectations(self) -> Sequence['outputs.GetDataQualityRulesRuleRegexExpectationResult']:
        """
        Row-level rule which evaluates whether each column value matches a specified regex.
        """
        return pulumi.get(self, "regex_expectations")

    @_builtins.property
    @pulumi.getter(name="rowConditionExpectations")
    def row_condition_expectations(self) -> Sequence['outputs.GetDataQualityRulesRuleRowConditionExpectationResult']:
        """
        Row-level rule which evaluates whether each row in a table passes the specified condition.
        """
        return pulumi.get(self, "row_condition_expectations")

    @_builtins.property
    @pulumi.getter(name="setExpectations")
    def set_expectations(self) -> Sequence['outputs.GetDataQualityRulesRuleSetExpectationResult']:
        """
        Row-level rule which evaluates whether each column value is contained by a specified set.
        """
        return pulumi.get(self, "set_expectations")

    @_builtins.property
    @pulumi.getter(name="sqlAssertions")
    def sql_assertions(self) -> Sequence['outputs.GetDataQualityRulesRuleSqlAssertionResult']:
        """
        Aggregate rule which evaluates the number of rows returned for the provided statement. If any rows are returned, this rule fails.
        """
        return pulumi.get(self, "sql_assertions")

    @_builtins.property
    @pulumi.getter(name="statisticRangeExpectations")
    def statistic_range_expectations(self) -> Sequence['outputs.GetDataQualityRulesRuleStatisticRangeExpectationResult']:
        """
        Aggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
        """
        return pulumi.get(self, "statistic_range_expectations")

    @_builtins.property
    @pulumi.getter
    def suspended(self) -> _builtins.bool:
        """
        Whether the Rule is active or suspended. Default is false.
        """
        return pulumi.get(self, "suspended")

    @_builtins.property
    @pulumi.getter(name="tableConditionExpectations")
    def table_condition_expectations(self) -> Sequence['outputs.GetDataQualityRulesRuleTableConditionExpectationResult']:
        """
        Aggregate rule which evaluates whether the provided expression is true for a table.
        """
        return pulumi.get(self, "table_condition_expectations")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.float:
        """
        The minimum ratio of passing_rows / total_rows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0). This field is only valid for row-level type rules.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter(name="uniquenessExpectations")
    def uniqueness_expectations(self) -> Sequence['outputs.GetDataQualityRulesRuleUniquenessExpectationResult']:
        """
        Row-level rule which evaluates whether each column value is unique.
        """
        return pulumi.get(self, "uniqueness_expectations")


@pulumi.output_type
class GetDataQualityRulesRuleNonNullExpectationResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetDataQualityRulesRuleRangeExpectationResult(dict):
    def __init__(__self__, *,
                 max_value: _builtins.str,
                 min_value: _builtins.str,
                 strict_max_enabled: _builtins.bool,
                 strict_min_enabled: _builtins.bool):
        """
        :param _builtins.str max_value: The maximum column value allowed for a row to pass this validation.
        :param _builtins.str min_value: The minimum column value allowed for a row to pass this validation.
        :param _builtins.bool strict_max_enabled: Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        :param _builtins.bool strict_min_enabled: Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        """
        pulumi.set(__self__, "max_value", max_value)
        pulumi.set(__self__, "min_value", min_value)
        pulumi.set(__self__, "strict_max_enabled", strict_max_enabled)
        pulumi.set(__self__, "strict_min_enabled", strict_min_enabled)

    @_builtins.property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> _builtins.str:
        """
        The maximum column value allowed for a row to pass this validation.
        """
        return pulumi.get(self, "max_value")

    @_builtins.property
    @pulumi.getter(name="minValue")
    def min_value(self) -> _builtins.str:
        """
        The minimum column value allowed for a row to pass this validation.
        """
        return pulumi.get(self, "min_value")

    @_builtins.property
    @pulumi.getter(name="strictMaxEnabled")
    def strict_max_enabled(self) -> _builtins.bool:
        """
        Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        """
        return pulumi.get(self, "strict_max_enabled")

    @_builtins.property
    @pulumi.getter(name="strictMinEnabled")
    def strict_min_enabled(self) -> _builtins.bool:
        """
        Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        """
        return pulumi.get(self, "strict_min_enabled")


@pulumi.output_type
class GetDataQualityRulesRuleRegexExpectationResult(dict):
    def __init__(__self__, *,
                 regex: _builtins.str):
        """
        :param _builtins.str regex: A regular expression the column value is expected to match.
        """
        pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        A regular expression the column value is expected to match.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDataQualityRulesRuleRowConditionExpectationResult(dict):
    def __init__(__self__, *,
                 sql_expression: _builtins.str):
        """
        :param _builtins.str sql_expression: The SQL expression.
        """
        pulumi.set(__self__, "sql_expression", sql_expression)

    @_builtins.property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> _builtins.str:
        """
        The SQL expression.
        """
        return pulumi.get(self, "sql_expression")


@pulumi.output_type
class GetDataQualityRulesRuleSetExpectationResult(dict):
    def __init__(__self__, *,
                 values: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] values: Expected values for the column value.
        """
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Expected values for the column value.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDataQualityRulesRuleSqlAssertionResult(dict):
    def __init__(__self__, *,
                 sql_statement: _builtins.str):
        """
        :param _builtins.str sql_statement: The SQL expression.
        """
        pulumi.set(__self__, "sql_statement", sql_statement)

    @_builtins.property
    @pulumi.getter(name="sqlStatement")
    def sql_statement(self) -> _builtins.str:
        """
        The SQL expression.
        """
        return pulumi.get(self, "sql_statement")


@pulumi.output_type
class GetDataQualityRulesRuleStatisticRangeExpectationResult(dict):
    def __init__(__self__, *,
                 max_value: _builtins.str,
                 min_value: _builtins.str,
                 statistic: _builtins.str,
                 strict_max_enabled: _builtins.bool,
                 strict_min_enabled: _builtins.bool):
        """
        :param _builtins.str max_value: The maximum column value allowed for a row to pass this validation.
        :param _builtins.str min_value: The minimum column value allowed for a row to pass this validation.
        :param _builtins.str statistic: The list of aggregate metrics a rule can be evaluated against. 
               																	Possible values: ["STATISTIC_UNDEFINED", "MEAN", "MIN", "MAX"]
        :param _builtins.bool strict_max_enabled: Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        :param _builtins.bool strict_min_enabled: Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        """
        pulumi.set(__self__, "max_value", max_value)
        pulumi.set(__self__, "min_value", min_value)
        pulumi.set(__self__, "statistic", statistic)
        pulumi.set(__self__, "strict_max_enabled", strict_max_enabled)
        pulumi.set(__self__, "strict_min_enabled", strict_min_enabled)

    @_builtins.property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> _builtins.str:
        """
        The maximum column value allowed for a row to pass this validation.
        """
        return pulumi.get(self, "max_value")

    @_builtins.property
    @pulumi.getter(name="minValue")
    def min_value(self) -> _builtins.str:
        """
        The minimum column value allowed for a row to pass this validation.
        """
        return pulumi.get(self, "min_value")

    @_builtins.property
    @pulumi.getter
    def statistic(self) -> _builtins.str:
        """
        The list of aggregate metrics a rule can be evaluated against. 
        																	Possible values: ["STATISTIC_UNDEFINED", "MEAN", "MIN", "MAX"]
        """
        return pulumi.get(self, "statistic")

    @_builtins.property
    @pulumi.getter(name="strictMaxEnabled")
    def strict_max_enabled(self) -> _builtins.bool:
        """
        Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        """
        return pulumi.get(self, "strict_max_enabled")

    @_builtins.property
    @pulumi.getter(name="strictMinEnabled")
    def strict_min_enabled(self) -> _builtins.bool:
        """
        Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        """
        return pulumi.get(self, "strict_min_enabled")


@pulumi.output_type
class GetDataQualityRulesRuleTableConditionExpectationResult(dict):
    def __init__(__self__, *,
                 sql_expression: _builtins.str):
        """
        :param _builtins.str sql_expression: The SQL expression.
        """
        pulumi.set(__self__, "sql_expression", sql_expression)

    @_builtins.property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> _builtins.str:
        """
        The SQL expression.
        """
        return pulumi.get(self, "sql_expression")


@pulumi.output_type
class GetDataQualityRulesRuleUniquenessExpectationResult(dict):
    def __init__(__self__):
        pass


