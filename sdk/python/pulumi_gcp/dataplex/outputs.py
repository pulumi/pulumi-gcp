# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AspectTypeIamBindingCondition',
    'AspectTypeIamMemberCondition',
    'AssetDiscoverySpec',
    'AssetDiscoverySpecCsvOptions',
    'AssetDiscoverySpecJsonOptions',
    'AssetDiscoveryStatus',
    'AssetDiscoveryStatusStat',
    'AssetIamBindingCondition',
    'AssetIamMemberCondition',
    'AssetResourceSpec',
    'AssetResourceStatus',
    'AssetSecurityStatus',
    'DatascanData',
    'DatascanDataProfileSpec',
    'DatascanDataProfileSpecExcludeFields',
    'DatascanDataProfileSpecIncludeFields',
    'DatascanDataProfileSpecPostScanActions',
    'DatascanDataProfileSpecPostScanActionsBigqueryExport',
    'DatascanDataQualitySpec',
    'DatascanDataQualitySpecPostScanActions',
    'DatascanDataQualitySpecPostScanActionsBigqueryExport',
    'DatascanDataQualitySpecPostScanActionsNotificationReport',
    'DatascanDataQualitySpecPostScanActionsNotificationReportJobEndTrigger',
    'DatascanDataQualitySpecPostScanActionsNotificationReportJobFailureTrigger',
    'DatascanDataQualitySpecPostScanActionsNotificationReportRecipients',
    'DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger',
    'DatascanDataQualitySpecRule',
    'DatascanDataQualitySpecRuleNonNullExpectation',
    'DatascanDataQualitySpecRuleRangeExpectation',
    'DatascanDataQualitySpecRuleRegexExpectation',
    'DatascanDataQualitySpecRuleRowConditionExpectation',
    'DatascanDataQualitySpecRuleSetExpectation',
    'DatascanDataQualitySpecRuleSqlAssertion',
    'DatascanDataQualitySpecRuleStatisticRangeExpectation',
    'DatascanDataQualitySpecRuleTableConditionExpectation',
    'DatascanDataQualitySpecRuleUniquenessExpectation',
    'DatascanExecutionSpec',
    'DatascanExecutionSpecTrigger',
    'DatascanExecutionSpecTriggerOnDemand',
    'DatascanExecutionSpecTriggerSchedule',
    'DatascanExecutionStatus',
    'DatascanIamBindingCondition',
    'DatascanIamMemberCondition',
    'EntryGroupIamBindingCondition',
    'EntryGroupIamMemberCondition',
    'EntryTypeIamBindingCondition',
    'EntryTypeIamMemberCondition',
    'EntryTypeRequiredAspect',
    'GlossaryIamBindingCondition',
    'GlossaryIamMemberCondition',
    'LakeAssetStatus',
    'LakeIamBindingCondition',
    'LakeIamMemberCondition',
    'LakeMetastore',
    'LakeMetastoreStatus',
    'TaskExecutionSpec',
    'TaskExecutionStatus',
    'TaskExecutionStatusLatestJob',
    'TaskIamBindingCondition',
    'TaskIamMemberCondition',
    'TaskNotebook',
    'TaskNotebookInfrastructureSpec',
    'TaskNotebookInfrastructureSpecBatch',
    'TaskNotebookInfrastructureSpecContainerImage',
    'TaskNotebookInfrastructureSpecVpcNetwork',
    'TaskSpark',
    'TaskSparkInfrastructureSpec',
    'TaskSparkInfrastructureSpecBatch',
    'TaskSparkInfrastructureSpecContainerImage',
    'TaskSparkInfrastructureSpecVpcNetwork',
    'TaskTriggerSpec',
    'ZoneAssetStatus',
    'ZoneDiscoverySpec',
    'ZoneDiscoverySpecCsvOptions',
    'ZoneDiscoverySpecJsonOptions',
    'ZoneIamBindingCondition',
    'ZoneIamMemberCondition',
    'ZoneResourceSpec',
]

@pulumi.output_type
class AspectTypeIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class AspectTypeIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class AssetDiscoverySpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "csvOptions":
            suggest = "csv_options"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"
        elif key == "jsonOptions":
            suggest = "json_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetDiscoverySpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetDiscoverySpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetDiscoverySpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 csv_options: Optional['outputs.AssetDiscoverySpecCsvOptions'] = None,
                 exclude_patterns: Optional[Sequence[builtins.str]] = None,
                 include_patterns: Optional[Sequence[builtins.str]] = None,
                 json_options: Optional['outputs.AssetDiscoverySpecJsonOptions'] = None,
                 schedule: Optional[builtins.str] = None):
        """
        :param builtins.bool enabled: Required. Whether discovery is enabled.
        :param 'AssetDiscoverySpecCsvOptionsArgs' csv_options: Optional. Configuration for CSV data.
        :param Sequence[builtins.str] exclude_patterns: Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param Sequence[builtins.str] include_patterns: Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param 'AssetDiscoverySpecJsonOptionsArgs' json_options: Optional. Configuration for Json data.
        :param builtins.str schedule: Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        pulumi.set(__self__, "enabled", enabled)
        if csv_options is not None:
            pulumi.set(__self__, "csv_options", csv_options)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if json_options is not None:
            pulumi.set(__self__, "json_options", json_options)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Required. Whether discovery is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="csvOptions")
    def csv_options(self) -> Optional['outputs.AssetDiscoverySpecCsvOptions']:
        """
        Optional. Configuration for CSV data.
        """
        return pulumi.get(self, "csv_options")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "include_patterns")

    @property
    @pulumi.getter(name="jsonOptions")
    def json_options(self) -> Optional['outputs.AssetDiscoverySpecJsonOptions']:
        """
        Optional. Configuration for Json data.
        """
        return pulumi.get(self, "json_options")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[builtins.str]:
        """
        Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class AssetDiscoverySpecCsvOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableTypeInference":
            suggest = "disable_type_inference"
        elif key == "headerRows":
            suggest = "header_rows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetDiscoverySpecCsvOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetDiscoverySpecCsvOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetDiscoverySpecCsvOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[builtins.str] = None,
                 disable_type_inference: Optional[builtins.bool] = None,
                 encoding: Optional[builtins.str] = None,
                 header_rows: Optional[builtins.int] = None):
        """
        :param builtins.str delimiter: Optional. The delimiter being used to separate values. This defaults to ','.
        :param builtins.bool disable_type_inference: Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        :param builtins.str encoding: Optional. The character encoding of the data. The default is UTF-8.
        :param builtins.int header_rows: Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if header_rows is not None:
            pulumi.set(__self__, "header_rows", header_rows)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[builtins.str]:
        """
        Optional. The delimiter being used to separate values. This defaults to ','.
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[builtins.bool]:
        """
        Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        """
        return pulumi.get(self, "disable_type_inference")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[builtins.str]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="headerRows")
    def header_rows(self) -> Optional[builtins.int]:
        """
        Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        return pulumi.get(self, "header_rows")


@pulumi.output_type
class AssetDiscoverySpecJsonOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableTypeInference":
            suggest = "disable_type_inference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetDiscoverySpecJsonOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetDiscoverySpecJsonOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetDiscoverySpecJsonOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_type_inference: Optional[builtins.bool] = None,
                 encoding: Optional[builtins.str] = None):
        """
        :param builtins.bool disable_type_inference: Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        :param builtins.str encoding: Optional. The character encoding of the data. The default is UTF-8.
        """
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[builtins.bool]:
        """
        Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        """
        return pulumi.get(self, "disable_type_inference")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[builtins.str]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")


@pulumi.output_type
class AssetDiscoveryStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastRunDuration":
            suggest = "last_run_duration"
        elif key == "lastRunTime":
            suggest = "last_run_time"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetDiscoveryStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetDiscoveryStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetDiscoveryStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_run_duration: Optional[builtins.str] = None,
                 last_run_time: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 stats: Optional[Sequence['outputs.AssetDiscoveryStatusStat']] = None,
                 update_time: Optional[builtins.str] = None):
        """
        :param builtins.str last_run_duration: The duration of the last discovery run.
        :param builtins.str last_run_time: The start time of the last discovery run.
        :param builtins.str message: Additional information about the current state.
        :param builtins.str state: Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param Sequence['AssetDiscoveryStatusStatArgs'] stats: Data Stats of the asset reported by discovery.
        :param builtins.str update_time: Output only. The time when the asset was last updated.
        """
        if last_run_duration is not None:
            pulumi.set(__self__, "last_run_duration", last_run_duration)
        if last_run_time is not None:
            pulumi.set(__self__, "last_run_time", last_run_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if stats is not None:
            pulumi.set(__self__, "stats", stats)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="lastRunDuration")
    def last_run_duration(self) -> Optional[builtins.str]:
        """
        The duration of the last discovery run.
        """
        return pulumi.get(self, "last_run_duration")

    @property
    @pulumi.getter(name="lastRunTime")
    def last_run_time(self) -> Optional[builtins.str]:
        """
        The start time of the last discovery run.
        """
        return pulumi.get(self, "last_run_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Additional information about the current state.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def stats(self) -> Optional[Sequence['outputs.AssetDiscoveryStatusStat']]:
        """
        Data Stats of the asset reported by discovery.
        """
        return pulumi.get(self, "stats")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[builtins.str]:
        """
        Output only. The time when the asset was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class AssetDiscoveryStatusStat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataItems":
            suggest = "data_items"
        elif key == "dataSize":
            suggest = "data_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetDiscoveryStatusStat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetDiscoveryStatusStat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetDiscoveryStatusStat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_items: Optional[builtins.int] = None,
                 data_size: Optional[builtins.int] = None,
                 filesets: Optional[builtins.int] = None,
                 tables: Optional[builtins.int] = None):
        """
        :param builtins.int data_items: The count of data items within the referenced resource.
        :param builtins.int data_size: The number of stored data bytes within the referenced resource.
        :param builtins.int filesets: The count of fileset entities within the referenced resource.
        :param builtins.int tables: The count of table entities within the referenced resource.
        """
        if data_items is not None:
            pulumi.set(__self__, "data_items", data_items)
        if data_size is not None:
            pulumi.set(__self__, "data_size", data_size)
        if filesets is not None:
            pulumi.set(__self__, "filesets", filesets)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter(name="dataItems")
    def data_items(self) -> Optional[builtins.int]:
        """
        The count of data items within the referenced resource.
        """
        return pulumi.get(self, "data_items")

    @property
    @pulumi.getter(name="dataSize")
    def data_size(self) -> Optional[builtins.int]:
        """
        The number of stored data bytes within the referenced resource.
        """
        return pulumi.get(self, "data_size")

    @property
    @pulumi.getter
    def filesets(self) -> Optional[builtins.int]:
        """
        The count of fileset entities within the referenced resource.
        """
        return pulumi.get(self, "filesets")

    @property
    @pulumi.getter
    def tables(self) -> Optional[builtins.int]:
        """
        The count of table entities within the referenced resource.
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class AssetIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class AssetIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class AssetResourceSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readAccessMode":
            suggest = "read_access_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetResourceSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetResourceSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetResourceSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 name: Optional[builtins.str] = None,
                 read_access_mode: Optional[builtins.str] = None):
        """
        :param builtins.str type: Required. Immutable. Type of resource. Possible values: STORAGE_BUCKET, BIGQUERY_DATASET
               
               - - -
        :param builtins.str name: Immutable. Relative name of the cloud resource that contains the data that is being managed within a lake. For example: `projects/{project_number}/buckets/{bucket_id}` `projects/{project_number}/datasets/{dataset_id}`
        :param builtins.str read_access_mode: Optional. Determines how read permissions are handled for each asset and their associated tables. Only available to storage buckets assets. Possible values: DIRECT, MANAGED
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if read_access_mode is not None:
            pulumi.set(__self__, "read_access_mode", read_access_mode)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Required. Immutable. Type of resource. Possible values: STORAGE_BUCKET, BIGQUERY_DATASET

        - - -
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Immutable. Relative name of the cloud resource that contains the data that is being managed within a lake. For example: `projects/{project_number}/buckets/{bucket_id}` `projects/{project_number}/datasets/{dataset_id}`
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="readAccessMode")
    def read_access_mode(self) -> Optional[builtins.str]:
        """
        Optional. Determines how read permissions are handled for each asset and their associated tables. Only available to storage buckets assets. Possible values: DIRECT, MANAGED
        """
        return pulumi.get(self, "read_access_mode")


@pulumi.output_type
class AssetResourceStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetResourceStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetResourceStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetResourceStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 update_time: Optional[builtins.str] = None):
        """
        :param builtins.str message: Additional information about the current state.
        :param builtins.str state: Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param builtins.str update_time: Output only. The time when the asset was last updated.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Additional information about the current state.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[builtins.str]:
        """
        Output only. The time when the asset was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class AssetSecurityStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetSecurityStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetSecurityStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetSecurityStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 update_time: Optional[builtins.str] = None):
        """
        :param builtins.str message: Additional information about the current state.
        :param builtins.str state: Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param builtins.str update_time: Output only. The time when the asset was last updated.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Additional information about the current state.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[builtins.str]:
        """
        Output only. The time when the asset was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class DatascanData(dict):
    def __init__(__self__, *,
                 entity: Optional[builtins.str] = None,
                 resource: Optional[builtins.str] = None):
        """
        :param builtins.str entity: The Dataplex entity that represents the data source(e.g. BigQuery table) for Datascan.
        :param builtins.str resource: The service-qualified full resource name of the cloud resource for a DataScan job to scan against. The field could be:
               (Cloud Storage bucket for DataDiscoveryScan)BigQuery table of type "TABLE" for DataProfileScan/DataQualityScan.
        """
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def entity(self) -> Optional[builtins.str]:
        """
        The Dataplex entity that represents the data source(e.g. BigQuery table) for Datascan.
        """
        return pulumi.get(self, "entity")

    @property
    @pulumi.getter
    def resource(self) -> Optional[builtins.str]:
        """
        The service-qualified full resource name of the cloud resource for a DataScan job to scan against. The field could be:
        (Cloud Storage bucket for DataDiscoveryScan)BigQuery table of type "TABLE" for DataProfileScan/DataQualityScan.
        """
        return pulumi.get(self, "resource")


@pulumi.output_type
class DatascanDataProfileSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeFields":
            suggest = "exclude_fields"
        elif key == "includeFields":
            suggest = "include_fields"
        elif key == "postScanActions":
            suggest = "post_scan_actions"
        elif key == "rowFilter":
            suggest = "row_filter"
        elif key == "samplingPercent":
            suggest = "sampling_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataProfileSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataProfileSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataProfileSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_fields: Optional['outputs.DatascanDataProfileSpecExcludeFields'] = None,
                 include_fields: Optional['outputs.DatascanDataProfileSpecIncludeFields'] = None,
                 post_scan_actions: Optional['outputs.DatascanDataProfileSpecPostScanActions'] = None,
                 row_filter: Optional[builtins.str] = None,
                 sampling_percent: Optional[builtins.float] = None):
        """
        :param 'DatascanDataProfileSpecExcludeFieldsArgs' exclude_fields: The fields to exclude from data profile.
               If specified, the fields will be excluded from data profile, regardless of `include_fields` value.
               Structure is documented below.
        :param 'DatascanDataProfileSpecIncludeFieldsArgs' include_fields: The fields to include in data profile.
               If not specified, all fields at the time of profile scan job execution are included, except for ones listed in `exclude_fields`.
               Structure is documented below.
        :param 'DatascanDataProfileSpecPostScanActionsArgs' post_scan_actions: Actions to take upon job completion.
               Structure is documented below.
        :param builtins.str row_filter: A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        :param builtins.float sampling_percent: The percentage of the records to be selected from the dataset for DataScan.
               Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
               Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        if exclude_fields is not None:
            pulumi.set(__self__, "exclude_fields", exclude_fields)
        if include_fields is not None:
            pulumi.set(__self__, "include_fields", include_fields)
        if post_scan_actions is not None:
            pulumi.set(__self__, "post_scan_actions", post_scan_actions)
        if row_filter is not None:
            pulumi.set(__self__, "row_filter", row_filter)
        if sampling_percent is not None:
            pulumi.set(__self__, "sampling_percent", sampling_percent)

    @property
    @pulumi.getter(name="excludeFields")
    def exclude_fields(self) -> Optional['outputs.DatascanDataProfileSpecExcludeFields']:
        """
        The fields to exclude from data profile.
        If specified, the fields will be excluded from data profile, regardless of `include_fields` value.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_fields")

    @property
    @pulumi.getter(name="includeFields")
    def include_fields(self) -> Optional['outputs.DatascanDataProfileSpecIncludeFields']:
        """
        The fields to include in data profile.
        If not specified, all fields at the time of profile scan job execution are included, except for ones listed in `exclude_fields`.
        Structure is documented below.
        """
        return pulumi.get(self, "include_fields")

    @property
    @pulumi.getter(name="postScanActions")
    def post_scan_actions(self) -> Optional['outputs.DatascanDataProfileSpecPostScanActions']:
        """
        Actions to take upon job completion.
        Structure is documented below.
        """
        return pulumi.get(self, "post_scan_actions")

    @property
    @pulumi.getter(name="rowFilter")
    def row_filter(self) -> Optional[builtins.str]:
        """
        A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        """
        return pulumi.get(self, "row_filter")

    @property
    @pulumi.getter(name="samplingPercent")
    def sampling_percent(self) -> Optional[builtins.float]:
        """
        The percentage of the records to be selected from the dataset for DataScan.
        Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
        Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        return pulumi.get(self, "sampling_percent")


@pulumi.output_type
class DatascanDataProfileSpecExcludeFields(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldNames":
            suggest = "field_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataProfileSpecExcludeFields. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataProfileSpecExcludeFields.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataProfileSpecExcludeFields.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_names: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] field_names: Expected input is a list of fully qualified names of fields as in the schema.
               Only top-level field names for nested fields are supported.
               For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Expected input is a list of fully qualified names of fields as in the schema.
        Only top-level field names for nested fields are supported.
        For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        return pulumi.get(self, "field_names")


@pulumi.output_type
class DatascanDataProfileSpecIncludeFields(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldNames":
            suggest = "field_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataProfileSpecIncludeFields. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataProfileSpecIncludeFields.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataProfileSpecIncludeFields.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_names: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] field_names: Expected input is a list of fully qualified names of fields as in the schema.
               Only top-level field names for nested fields are supported.
               For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Expected input is a list of fully qualified names of fields as in the schema.
        Only top-level field names for nested fields are supported.
        For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        return pulumi.get(self, "field_names")


@pulumi.output_type
class DatascanDataProfileSpecPostScanActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bigqueryExport":
            suggest = "bigquery_export"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataProfileSpecPostScanActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataProfileSpecPostScanActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataProfileSpecPostScanActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bigquery_export: Optional['outputs.DatascanDataProfileSpecPostScanActionsBigqueryExport'] = None):
        """
        :param 'DatascanDataProfileSpecPostScanActionsBigqueryExportArgs' bigquery_export: If set, results will be exported to the provided BigQuery table.
               Structure is documented below.
        """
        if bigquery_export is not None:
            pulumi.set(__self__, "bigquery_export", bigquery_export)

    @property
    @pulumi.getter(name="bigqueryExport")
    def bigquery_export(self) -> Optional['outputs.DatascanDataProfileSpecPostScanActionsBigqueryExport']:
        """
        If set, results will be exported to the provided BigQuery table.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_export")


@pulumi.output_type
class DatascanDataProfileSpecPostScanActionsBigqueryExport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultsTable":
            suggest = "results_table"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataProfileSpecPostScanActionsBigqueryExport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataProfileSpecPostScanActionsBigqueryExport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataProfileSpecPostScanActionsBigqueryExport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 results_table: Optional[builtins.str] = None):
        """
        :param builtins.str results_table: The BigQuery table to export DataProfileScan results to.
               Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        if results_table is not None:
            pulumi.set(__self__, "results_table", results_table)

    @property
    @pulumi.getter(name="resultsTable")
    def results_table(self) -> Optional[builtins.str]:
        """
        The BigQuery table to export DataProfileScan results to.
        Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        return pulumi.get(self, "results_table")


@pulumi.output_type
class DatascanDataQualitySpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postScanActions":
            suggest = "post_scan_actions"
        elif key == "rowFilter":
            suggest = "row_filter"
        elif key == "samplingPercent":
            suggest = "sampling_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 post_scan_actions: Optional['outputs.DatascanDataQualitySpecPostScanActions'] = None,
                 row_filter: Optional[builtins.str] = None,
                 rules: Optional[Sequence['outputs.DatascanDataQualitySpecRule']] = None,
                 sampling_percent: Optional[builtins.float] = None):
        """
        :param 'DatascanDataQualitySpecPostScanActionsArgs' post_scan_actions: Actions to take upon job completion.
               Structure is documented below.
        :param builtins.str row_filter: A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        :param Sequence['DatascanDataQualitySpecRuleArgs'] rules: The list of rules to evaluate against a data source. At least one rule is required.
               Structure is documented below.
        :param builtins.float sampling_percent: The percentage of the records to be selected from the dataset for DataScan.
               Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
               Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        if post_scan_actions is not None:
            pulumi.set(__self__, "post_scan_actions", post_scan_actions)
        if row_filter is not None:
            pulumi.set(__self__, "row_filter", row_filter)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if sampling_percent is not None:
            pulumi.set(__self__, "sampling_percent", sampling_percent)

    @property
    @pulumi.getter(name="postScanActions")
    def post_scan_actions(self) -> Optional['outputs.DatascanDataQualitySpecPostScanActions']:
        """
        Actions to take upon job completion.
        Structure is documented below.
        """
        return pulumi.get(self, "post_scan_actions")

    @property
    @pulumi.getter(name="rowFilter")
    def row_filter(self) -> Optional[builtins.str]:
        """
        A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        """
        return pulumi.get(self, "row_filter")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.DatascanDataQualitySpecRule']]:
        """
        The list of rules to evaluate against a data source. At least one rule is required.
        Structure is documented below.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="samplingPercent")
    def sampling_percent(self) -> Optional[builtins.float]:
        """
        The percentage of the records to be selected from the dataset for DataScan.
        Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
        Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        return pulumi.get(self, "sampling_percent")


@pulumi.output_type
class DatascanDataQualitySpecPostScanActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bigqueryExport":
            suggest = "bigquery_export"
        elif key == "notificationReport":
            suggest = "notification_report"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecPostScanActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecPostScanActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecPostScanActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bigquery_export: Optional['outputs.DatascanDataQualitySpecPostScanActionsBigqueryExport'] = None,
                 notification_report: Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReport'] = None):
        """
        :param 'DatascanDataQualitySpecPostScanActionsBigqueryExportArgs' bigquery_export: If set, results will be exported to the provided BigQuery table.
               Structure is documented below.
        :param 'DatascanDataQualitySpecPostScanActionsNotificationReportArgs' notification_report: The configuration of notification report post scan action.
               Structure is documented below.
        """
        if bigquery_export is not None:
            pulumi.set(__self__, "bigquery_export", bigquery_export)
        if notification_report is not None:
            pulumi.set(__self__, "notification_report", notification_report)

    @property
    @pulumi.getter(name="bigqueryExport")
    def bigquery_export(self) -> Optional['outputs.DatascanDataQualitySpecPostScanActionsBigqueryExport']:
        """
        If set, results will be exported to the provided BigQuery table.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_export")

    @property
    @pulumi.getter(name="notificationReport")
    def notification_report(self) -> Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReport']:
        """
        The configuration of notification report post scan action.
        Structure is documented below.
        """
        return pulumi.get(self, "notification_report")


@pulumi.output_type
class DatascanDataQualitySpecPostScanActionsBigqueryExport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultsTable":
            suggest = "results_table"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecPostScanActionsBigqueryExport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecPostScanActionsBigqueryExport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecPostScanActionsBigqueryExport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 results_table: Optional[builtins.str] = None):
        """
        :param builtins.str results_table: The BigQuery table to export DataProfileScan results to.
               Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        if results_table is not None:
            pulumi.set(__self__, "results_table", results_table)

    @property
    @pulumi.getter(name="resultsTable")
    def results_table(self) -> Optional[builtins.str]:
        """
        The BigQuery table to export DataProfileScan results to.
        Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        return pulumi.get(self, "results_table")


@pulumi.output_type
class DatascanDataQualitySpecPostScanActionsNotificationReport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobEndTrigger":
            suggest = "job_end_trigger"
        elif key == "jobFailureTrigger":
            suggest = "job_failure_trigger"
        elif key == "scoreThresholdTrigger":
            suggest = "score_threshold_trigger"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecPostScanActionsNotificationReport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecPostScanActionsNotificationReport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecPostScanActionsNotificationReport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recipients: 'outputs.DatascanDataQualitySpecPostScanActionsNotificationReportRecipients',
                 job_end_trigger: Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReportJobEndTrigger'] = None,
                 job_failure_trigger: Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReportJobFailureTrigger'] = None,
                 score_threshold_trigger: Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger'] = None):
        """
        :param 'DatascanDataQualitySpecPostScanActionsNotificationReportRecipientsArgs' recipients: The individuals or groups who are designated to receive notifications upon triggers.
               Structure is documented below.
        :param 'DatascanDataQualitySpecPostScanActionsNotificationReportJobEndTriggerArgs' job_end_trigger: This trigger is triggered whenever a scan job run ends, regardless of the result.
        :param 'DatascanDataQualitySpecPostScanActionsNotificationReportJobFailureTriggerArgs' job_failure_trigger: This trigger is triggered when the scan job itself fails, regardless of the result.
        :param 'DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTriggerArgs' score_threshold_trigger: This trigger is triggered when the DQ score in the job result is less than a specified input score.
               Structure is documented below.
        """
        pulumi.set(__self__, "recipients", recipients)
        if job_end_trigger is not None:
            pulumi.set(__self__, "job_end_trigger", job_end_trigger)
        if job_failure_trigger is not None:
            pulumi.set(__self__, "job_failure_trigger", job_failure_trigger)
        if score_threshold_trigger is not None:
            pulumi.set(__self__, "score_threshold_trigger", score_threshold_trigger)

    @property
    @pulumi.getter
    def recipients(self) -> 'outputs.DatascanDataQualitySpecPostScanActionsNotificationReportRecipients':
        """
        The individuals or groups who are designated to receive notifications upon triggers.
        Structure is documented below.
        """
        return pulumi.get(self, "recipients")

    @property
    @pulumi.getter(name="jobEndTrigger")
    def job_end_trigger(self) -> Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReportJobEndTrigger']:
        """
        This trigger is triggered whenever a scan job run ends, regardless of the result.
        """
        return pulumi.get(self, "job_end_trigger")

    @property
    @pulumi.getter(name="jobFailureTrigger")
    def job_failure_trigger(self) -> Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReportJobFailureTrigger']:
        """
        This trigger is triggered when the scan job itself fails, regardless of the result.
        """
        return pulumi.get(self, "job_failure_trigger")

    @property
    @pulumi.getter(name="scoreThresholdTrigger")
    def score_threshold_trigger(self) -> Optional['outputs.DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger']:
        """
        This trigger is triggered when the DQ score in the job result is less than a specified input score.
        Structure is documented below.
        """
        return pulumi.get(self, "score_threshold_trigger")


@pulumi.output_type
class DatascanDataQualitySpecPostScanActionsNotificationReportJobEndTrigger(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatascanDataQualitySpecPostScanActionsNotificationReportJobFailureTrigger(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatascanDataQualitySpecPostScanActionsNotificationReportRecipients(dict):
    def __init__(__self__, *,
                 emails: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] emails: The email recipients who will receive the DataQualityScan results report.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        The email recipients who will receive the DataQualityScan results report.
        """
        return pulumi.get(self, "emails")


@pulumi.output_type
class DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scoreThreshold":
            suggest = "score_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 score_threshold: Optional[builtins.float] = None):
        """
        :param builtins.float score_threshold: The score range is in [0,100].
        """
        if score_threshold is not None:
            pulumi.set(__self__, "score_threshold", score_threshold)

    @property
    @pulumi.getter(name="scoreThreshold")
    def score_threshold(self) -> Optional[builtins.float]:
        """
        The score range is in [0,100].
        """
        return pulumi.get(self, "score_threshold")


@pulumi.output_type
class DatascanDataQualitySpecRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreNull":
            suggest = "ignore_null"
        elif key == "nonNullExpectation":
            suggest = "non_null_expectation"
        elif key == "rangeExpectation":
            suggest = "range_expectation"
        elif key == "regexExpectation":
            suggest = "regex_expectation"
        elif key == "rowConditionExpectation":
            suggest = "row_condition_expectation"
        elif key == "setExpectation":
            suggest = "set_expectation"
        elif key == "sqlAssertion":
            suggest = "sql_assertion"
        elif key == "statisticRangeExpectation":
            suggest = "statistic_range_expectation"
        elif key == "tableConditionExpectation":
            suggest = "table_condition_expectation"
        elif key == "uniquenessExpectation":
            suggest = "uniqueness_expectation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension: builtins.str,
                 column: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 ignore_null: Optional[builtins.bool] = None,
                 name: Optional[builtins.str] = None,
                 non_null_expectation: Optional['outputs.DatascanDataQualitySpecRuleNonNullExpectation'] = None,
                 range_expectation: Optional['outputs.DatascanDataQualitySpecRuleRangeExpectation'] = None,
                 regex_expectation: Optional['outputs.DatascanDataQualitySpecRuleRegexExpectation'] = None,
                 row_condition_expectation: Optional['outputs.DatascanDataQualitySpecRuleRowConditionExpectation'] = None,
                 set_expectation: Optional['outputs.DatascanDataQualitySpecRuleSetExpectation'] = None,
                 sql_assertion: Optional['outputs.DatascanDataQualitySpecRuleSqlAssertion'] = None,
                 statistic_range_expectation: Optional['outputs.DatascanDataQualitySpecRuleStatisticRangeExpectation'] = None,
                 table_condition_expectation: Optional['outputs.DatascanDataQualitySpecRuleTableConditionExpectation'] = None,
                 threshold: Optional[builtins.float] = None,
                 uniqueness_expectation: Optional['outputs.DatascanDataQualitySpecRuleUniquenessExpectation'] = None):
        """
        :param builtins.str dimension: The dimension a rule belongs to. Results are also aggregated at the dimension level. Supported dimensions are ["COMPLETENESS", "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "INTEGRITY"]
        :param builtins.str column: The unnested column which this rule is evaluated against.
        :param builtins.str description: Description of the rule.
               The maximum length is 1,024 characters.
        :param builtins.bool ignore_null: Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
        :param builtins.str name: A mutable name for the rule.
               The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
               The maximum length is 63 characters.
               Must start with a letter.
               Must end with a number or a letter.
        :param 'DatascanDataQualitySpecRuleNonNullExpectationArgs' non_null_expectation: ColumnMap rule which evaluates whether each column value is null.
        :param 'DatascanDataQualitySpecRuleRangeExpectationArgs' range_expectation: ColumnMap rule which evaluates whether each column value lies between a specified range.
               Structure is documented below.
        :param 'DatascanDataQualitySpecRuleRegexExpectationArgs' regex_expectation: ColumnMap rule which evaluates whether each column value matches a specified regex.
               Structure is documented below.
        :param 'DatascanDataQualitySpecRuleRowConditionExpectationArgs' row_condition_expectation: Table rule which evaluates whether each row passes the specified condition.
               Structure is documented below.
        :param 'DatascanDataQualitySpecRuleSetExpectationArgs' set_expectation: ColumnMap rule which evaluates whether each column value is contained by a specified set.
               Structure is documented below.
        :param 'DatascanDataQualitySpecRuleSqlAssertionArgs' sql_assertion: Table rule which evaluates whether any row matches invalid state.
               Structure is documented below.
        :param 'DatascanDataQualitySpecRuleStatisticRangeExpectationArgs' statistic_range_expectation: ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
               Structure is documented below.
        :param 'DatascanDataQualitySpecRuleTableConditionExpectationArgs' table_condition_expectation: Table rule which evaluates whether the provided expression is true.
               Structure is documented below.
        :param builtins.float threshold: The minimum ratio of passing_rows / total_rows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0).
        :param 'DatascanDataQualitySpecRuleUniquenessExpectationArgs' uniqueness_expectation: Row-level rule which evaluates whether each column value is unique.
        """
        pulumi.set(__self__, "dimension", dimension)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ignore_null is not None:
            pulumi.set(__self__, "ignore_null", ignore_null)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if non_null_expectation is not None:
            pulumi.set(__self__, "non_null_expectation", non_null_expectation)
        if range_expectation is not None:
            pulumi.set(__self__, "range_expectation", range_expectation)
        if regex_expectation is not None:
            pulumi.set(__self__, "regex_expectation", regex_expectation)
        if row_condition_expectation is not None:
            pulumi.set(__self__, "row_condition_expectation", row_condition_expectation)
        if set_expectation is not None:
            pulumi.set(__self__, "set_expectation", set_expectation)
        if sql_assertion is not None:
            pulumi.set(__self__, "sql_assertion", sql_assertion)
        if statistic_range_expectation is not None:
            pulumi.set(__self__, "statistic_range_expectation", statistic_range_expectation)
        if table_condition_expectation is not None:
            pulumi.set(__self__, "table_condition_expectation", table_condition_expectation)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if uniqueness_expectation is not None:
            pulumi.set(__self__, "uniqueness_expectation", uniqueness_expectation)

    @property
    @pulumi.getter
    def dimension(self) -> builtins.str:
        """
        The dimension a rule belongs to. Results are also aggregated at the dimension level. Supported dimensions are ["COMPLETENESS", "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "INTEGRITY"]
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def column(self) -> Optional[builtins.str]:
        """
        The unnested column which this rule is evaluated against.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the rule.
        The maximum length is 1,024 characters.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ignoreNull")
    def ignore_null(self) -> Optional[builtins.bool]:
        """
        Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
        """
        return pulumi.get(self, "ignore_null")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        A mutable name for the rule.
        The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
        The maximum length is 63 characters.
        Must start with a letter.
        Must end with a number or a letter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nonNullExpectation")
    def non_null_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleNonNullExpectation']:
        """
        ColumnMap rule which evaluates whether each column value is null.
        """
        return pulumi.get(self, "non_null_expectation")

    @property
    @pulumi.getter(name="rangeExpectation")
    def range_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleRangeExpectation']:
        """
        ColumnMap rule which evaluates whether each column value lies between a specified range.
        Structure is documented below.
        """
        return pulumi.get(self, "range_expectation")

    @property
    @pulumi.getter(name="regexExpectation")
    def regex_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleRegexExpectation']:
        """
        ColumnMap rule which evaluates whether each column value matches a specified regex.
        Structure is documented below.
        """
        return pulumi.get(self, "regex_expectation")

    @property
    @pulumi.getter(name="rowConditionExpectation")
    def row_condition_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleRowConditionExpectation']:
        """
        Table rule which evaluates whether each row passes the specified condition.
        Structure is documented below.
        """
        return pulumi.get(self, "row_condition_expectation")

    @property
    @pulumi.getter(name="setExpectation")
    def set_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleSetExpectation']:
        """
        ColumnMap rule which evaluates whether each column value is contained by a specified set.
        Structure is documented below.
        """
        return pulumi.get(self, "set_expectation")

    @property
    @pulumi.getter(name="sqlAssertion")
    def sql_assertion(self) -> Optional['outputs.DatascanDataQualitySpecRuleSqlAssertion']:
        """
        Table rule which evaluates whether any row matches invalid state.
        Structure is documented below.
        """
        return pulumi.get(self, "sql_assertion")

    @property
    @pulumi.getter(name="statisticRangeExpectation")
    def statistic_range_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleStatisticRangeExpectation']:
        """
        ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
        Structure is documented below.
        """
        return pulumi.get(self, "statistic_range_expectation")

    @property
    @pulumi.getter(name="tableConditionExpectation")
    def table_condition_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleTableConditionExpectation']:
        """
        Table rule which evaluates whether the provided expression is true.
        Structure is documented below.
        """
        return pulumi.get(self, "table_condition_expectation")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        """
        The minimum ratio of passing_rows / total_rows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0).
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="uniquenessExpectation")
    def uniqueness_expectation(self) -> Optional['outputs.DatascanDataQualitySpecRuleUniquenessExpectation']:
        """
        Row-level rule which evaluates whether each column value is unique.
        """
        return pulumi.get(self, "uniqueness_expectation")


@pulumi.output_type
class DatascanDataQualitySpecRuleNonNullExpectation(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatascanDataQualitySpecRuleRangeExpectation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxValue":
            suggest = "max_value"
        elif key == "minValue":
            suggest = "min_value"
        elif key == "strictMaxEnabled":
            suggest = "strict_max_enabled"
        elif key == "strictMinEnabled":
            suggest = "strict_min_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecRuleRangeExpectation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecRuleRangeExpectation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecRuleRangeExpectation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_value: Optional[builtins.str] = None,
                 min_value: Optional[builtins.str] = None,
                 strict_max_enabled: Optional[builtins.bool] = None,
                 strict_min_enabled: Optional[builtins.bool] = None):
        """
        :param builtins.str max_value: The maximum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        :param builtins.str min_value: The minimum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        :param builtins.bool strict_max_enabled: Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
               Only relevant if a maxValue has been defined. Default = false.
        :param builtins.bool strict_min_enabled: Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
               Only relevant if a minValue has been defined. Default = false.
        """
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if strict_max_enabled is not None:
            pulumi.set(__self__, "strict_max_enabled", strict_max_enabled)
        if strict_min_enabled is not None:
            pulumi.set(__self__, "strict_min_enabled", strict_min_enabled)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[builtins.str]:
        """
        The maximum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "max_value")

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[builtins.str]:
        """
        The minimum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "min_value")

    @property
    @pulumi.getter(name="strictMaxEnabled")
    def strict_max_enabled(self) -> Optional[builtins.bool]:
        """
        Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        Only relevant if a maxValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_max_enabled")

    @property
    @pulumi.getter(name="strictMinEnabled")
    def strict_min_enabled(self) -> Optional[builtins.bool]:
        """
        Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        Only relevant if a minValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_min_enabled")


@pulumi.output_type
class DatascanDataQualitySpecRuleRegexExpectation(dict):
    def __init__(__self__, *,
                 regex: builtins.str):
        """
        :param builtins.str regex: A regular expression the column value is expected to match.
        """
        pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def regex(self) -> builtins.str:
        """
        A regular expression the column value is expected to match.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class DatascanDataQualitySpecRuleRowConditionExpectation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sqlExpression":
            suggest = "sql_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecRuleRowConditionExpectation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecRuleRowConditionExpectation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecRuleRowConditionExpectation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sql_expression: builtins.str):
        """
        :param builtins.str sql_expression: The SQL expression.
        """
        pulumi.set(__self__, "sql_expression", sql_expression)

    @property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> builtins.str:
        """
        The SQL expression.
        """
        return pulumi.get(self, "sql_expression")


@pulumi.output_type
class DatascanDataQualitySpecRuleSetExpectation(dict):
    def __init__(__self__, *,
                 values: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] values: Expected values for the column value.
        """
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        """
        Expected values for the column value.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class DatascanDataQualitySpecRuleSqlAssertion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sqlStatement":
            suggest = "sql_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecRuleSqlAssertion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecRuleSqlAssertion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecRuleSqlAssertion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sql_statement: builtins.str):
        """
        :param builtins.str sql_statement: The SQL statement.
        """
        pulumi.set(__self__, "sql_statement", sql_statement)

    @property
    @pulumi.getter(name="sqlStatement")
    def sql_statement(self) -> builtins.str:
        """
        The SQL statement.
        """
        return pulumi.get(self, "sql_statement")


@pulumi.output_type
class DatascanDataQualitySpecRuleStatisticRangeExpectation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxValue":
            suggest = "max_value"
        elif key == "minValue":
            suggest = "min_value"
        elif key == "strictMaxEnabled":
            suggest = "strict_max_enabled"
        elif key == "strictMinEnabled":
            suggest = "strict_min_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecRuleStatisticRangeExpectation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecRuleStatisticRangeExpectation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecRuleStatisticRangeExpectation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 statistic: builtins.str,
                 max_value: Optional[builtins.str] = None,
                 min_value: Optional[builtins.str] = None,
                 strict_max_enabled: Optional[builtins.bool] = None,
                 strict_min_enabled: Optional[builtins.bool] = None):
        """
        :param builtins.str statistic: column statistics.
               Possible values are: `STATISTIC_UNDEFINED`, `MEAN`, `MIN`, `MAX`.
        :param builtins.str max_value: The maximum column statistic value allowed for a row to pass this validation.
               At least one of minValue and maxValue need to be provided.
        :param builtins.str min_value: The minimum column statistic value allowed for a row to pass this validation.
               At least one of minValue and maxValue need to be provided.
        :param builtins.bool strict_max_enabled: Whether column statistic needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
               Only relevant if a maxValue has been defined. Default = false.
        :param builtins.bool strict_min_enabled: Whether column statistic needs to be strictly greater than ('>') the minimum, or if equality is allowed.
               Only relevant if a minValue has been defined. Default = false.
        """
        pulumi.set(__self__, "statistic", statistic)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if strict_max_enabled is not None:
            pulumi.set(__self__, "strict_max_enabled", strict_max_enabled)
        if strict_min_enabled is not None:
            pulumi.set(__self__, "strict_min_enabled", strict_min_enabled)

    @property
    @pulumi.getter
    def statistic(self) -> builtins.str:
        """
        column statistics.
        Possible values are: `STATISTIC_UNDEFINED`, `MEAN`, `MIN`, `MAX`.
        """
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[builtins.str]:
        """
        The maximum column statistic value allowed for a row to pass this validation.
        At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "max_value")

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[builtins.str]:
        """
        The minimum column statistic value allowed for a row to pass this validation.
        At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "min_value")

    @property
    @pulumi.getter(name="strictMaxEnabled")
    def strict_max_enabled(self) -> Optional[builtins.bool]:
        """
        Whether column statistic needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        Only relevant if a maxValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_max_enabled")

    @property
    @pulumi.getter(name="strictMinEnabled")
    def strict_min_enabled(self) -> Optional[builtins.bool]:
        """
        Whether column statistic needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        Only relevant if a minValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_min_enabled")


@pulumi.output_type
class DatascanDataQualitySpecRuleTableConditionExpectation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sqlExpression":
            suggest = "sql_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanDataQualitySpecRuleTableConditionExpectation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanDataQualitySpecRuleTableConditionExpectation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanDataQualitySpecRuleTableConditionExpectation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sql_expression: builtins.str):
        """
        :param builtins.str sql_expression: The SQL expression.
        """
        pulumi.set(__self__, "sql_expression", sql_expression)

    @property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> builtins.str:
        """
        The SQL expression.
        """
        return pulumi.get(self, "sql_expression")


@pulumi.output_type
class DatascanDataQualitySpecRuleUniquenessExpectation(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatascanExecutionSpec(dict):
    def __init__(__self__, *,
                 trigger: 'outputs.DatascanExecutionSpecTrigger',
                 field: Optional[builtins.str] = None):
        """
        :param 'DatascanExecutionSpecTriggerArgs' trigger: Spec related to how often and when a scan should be triggered.
               Structure is documented below.
        :param builtins.str field: The unnested field (of type Date or Timestamp) that contains values which monotonically increase over time. If not specified, a data scan will run for all data in the table.
        """
        pulumi.set(__self__, "trigger", trigger)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @property
    @pulumi.getter
    def trigger(self) -> 'outputs.DatascanExecutionSpecTrigger':
        """
        Spec related to how often and when a scan should be triggered.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger")

    @property
    @pulumi.getter
    def field(self) -> Optional[builtins.str]:
        """
        The unnested field (of type Date or Timestamp) that contains values which monotonically increase over time. If not specified, a data scan will run for all data in the table.
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class DatascanExecutionSpecTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDemand":
            suggest = "on_demand"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanExecutionSpecTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanExecutionSpecTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanExecutionSpecTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_demand: Optional['outputs.DatascanExecutionSpecTriggerOnDemand'] = None,
                 schedule: Optional['outputs.DatascanExecutionSpecTriggerSchedule'] = None):
        """
        :param 'DatascanExecutionSpecTriggerOnDemandArgs' on_demand: The scan runs once via dataScans.run API.
        :param 'DatascanExecutionSpecTriggerScheduleArgs' schedule: The scan is scheduled to run periodically.
               Structure is documented below.
        """
        if on_demand is not None:
            pulumi.set(__self__, "on_demand", on_demand)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter(name="onDemand")
    def on_demand(self) -> Optional['outputs.DatascanExecutionSpecTriggerOnDemand']:
        """
        The scan runs once via dataScans.run API.
        """
        return pulumi.get(self, "on_demand")

    @property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.DatascanExecutionSpecTriggerSchedule']:
        """
        The scan is scheduled to run periodically.
        Structure is documented below.
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class DatascanExecutionSpecTriggerOnDemand(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatascanExecutionSpecTriggerSchedule(dict):
    def __init__(__self__, *,
                 cron: builtins.str):
        """
        :param builtins.str cron: Cron schedule for running scans periodically. This field is required for Schedule scans.
               
               - - -
        """
        pulumi.set(__self__, "cron", cron)

    @property
    @pulumi.getter
    def cron(self) -> builtins.str:
        """
        Cron schedule for running scans periodically. This field is required for Schedule scans.

        - - -
        """
        return pulumi.get(self, "cron")


@pulumi.output_type
class DatascanExecutionStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestJobEndTime":
            suggest = "latest_job_end_time"
        elif key == "latestJobStartTime":
            suggest = "latest_job_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatascanExecutionStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatascanExecutionStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatascanExecutionStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_job_end_time: Optional[builtins.str] = None,
                 latest_job_start_time: Optional[builtins.str] = None):
        """
        :param builtins.str latest_job_end_time: (Output)
               The time when the latest DataScanJob started.
        :param builtins.str latest_job_start_time: (Output)
               The time when the latest DataScanJob ended.
        """
        if latest_job_end_time is not None:
            pulumi.set(__self__, "latest_job_end_time", latest_job_end_time)
        if latest_job_start_time is not None:
            pulumi.set(__self__, "latest_job_start_time", latest_job_start_time)

    @property
    @pulumi.getter(name="latestJobEndTime")
    def latest_job_end_time(self) -> Optional[builtins.str]:
        """
        (Output)
        The time when the latest DataScanJob started.
        """
        return pulumi.get(self, "latest_job_end_time")

    @property
    @pulumi.getter(name="latestJobStartTime")
    def latest_job_start_time(self) -> Optional[builtins.str]:
        """
        (Output)
        The time when the latest DataScanJob ended.
        """
        return pulumi.get(self, "latest_job_start_time")


@pulumi.output_type
class DatascanIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class DatascanIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class EntryGroupIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class EntryGroupIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class EntryTypeIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class EntryTypeIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class EntryTypeRequiredAspect(dict):
    def __init__(__self__, *,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str type: Required aspect type for the entry type.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Required aspect type for the entry type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GlossaryIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class GlossaryIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class LakeAssetStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeAssets":
            suggest = "active_assets"
        elif key == "securityPolicyApplyingAssets":
            suggest = "security_policy_applying_assets"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LakeAssetStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LakeAssetStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LakeAssetStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_assets: Optional[builtins.int] = None,
                 security_policy_applying_assets: Optional[builtins.int] = None,
                 update_time: Optional[builtins.str] = None):
        """
        :param builtins.int active_assets: Number of active assets.
        :param builtins.int security_policy_applying_assets: Number of assets that are in process of updating the security policy on attached resources.
        :param builtins.str update_time: Output only. The time when the lake was last updated.
        """
        if active_assets is not None:
            pulumi.set(__self__, "active_assets", active_assets)
        if security_policy_applying_assets is not None:
            pulumi.set(__self__, "security_policy_applying_assets", security_policy_applying_assets)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="activeAssets")
    def active_assets(self) -> Optional[builtins.int]:
        """
        Number of active assets.
        """
        return pulumi.get(self, "active_assets")

    @property
    @pulumi.getter(name="securityPolicyApplyingAssets")
    def security_policy_applying_assets(self) -> Optional[builtins.int]:
        """
        Number of assets that are in process of updating the security policy on attached resources.
        """
        return pulumi.get(self, "security_policy_applying_assets")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[builtins.str]:
        """
        Output only. The time when the lake was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class LakeIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class LakeIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class LakeMetastore(dict):
    def __init__(__self__, *,
                 service: Optional[builtins.str] = None):
        """
        :param builtins.str service: Optional. A relative reference to the Dataproc Metastore (https://cloud.google.com/dataproc-metastore/docs) service associated with the lake: `projects/{project_id}/locations/{location_id}/services/{service_id}`
        """
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def service(self) -> Optional[builtins.str]:
        """
        Optional. A relative reference to the Dataproc Metastore (https://cloud.google.com/dataproc-metastore/docs) service associated with the lake: `projects/{project_id}/locations/{location_id}/services/{service_id}`
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class LakeMetastoreStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LakeMetastoreStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LakeMetastoreStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LakeMetastoreStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 update_time: Optional[builtins.str] = None):
        """
        :param builtins.str endpoint: The URI of the endpoint used to access the Metastore service.
        :param builtins.str message: Additional information about the current status.
        :param builtins.str state: Output only. Current state of the lake. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param builtins.str update_time: Output only. The time when the lake was last updated.
        """
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[builtins.str]:
        """
        The URI of the endpoint used to access the Metastore service.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Additional information about the current status.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        Output only. Current state of the lake. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[builtins.str]:
        """
        Output only. The time when the lake was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class TaskExecutionSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccount":
            suggest = "service_account"
        elif key == "kmsKey":
            suggest = "kms_key"
        elif key == "maxJobExecutionLifetime":
            suggest = "max_job_execution_lifetime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskExecutionSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskExecutionSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskExecutionSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account: builtins.str,
                 args: Optional[Mapping[str, builtins.str]] = None,
                 kms_key: Optional[builtins.str] = None,
                 max_job_execution_lifetime: Optional[builtins.str] = None,
                 project: Optional[builtins.str] = None):
        """
        :param builtins.str service_account: Service account to use to execute a task. If not provided, the default Compute service account for the project is used.
        :param Mapping[str, builtins.str] args: The arguments to pass to the task. The args can use placeholders of the format ${placeholder} as part of key/value string. These will be interpolated before passing the args to the driver. Currently supported placeholders: - ${taskId} - ${job_time} To pass positional args, set the key as TASK_ARGS. The value should be a comma-separated string of all the positional arguments. To use a delimiter other than comma, refer to https://cloud.google.com/sdk/gcloud/reference/topic/escaping. In case of other keys being present in the args, then TASK_ARGS will be passed as the last argument. An object containing a list of 'key': value pairs. Example: { 'name': 'wrench', 'mass': '1.3kg', 'count': '3' }.
        :param builtins.str kms_key: The Cloud KMS key to use for encryption, of the form: projects/{project_number}/locations/{locationId}/keyRings/{key-ring-name}/cryptoKeys/{key-name}.
               
               - - -
        :param builtins.str max_job_execution_lifetime: The maximum duration after which the job execution is expired. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'.
        :param builtins.str project: The ID of the project in which the resource belongs.
               If it is not provided, the provider project is used.
        """
        pulumi.set(__self__, "service_account", service_account)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if max_job_execution_lifetime is not None:
            pulumi.set(__self__, "max_job_execution_lifetime", max_job_execution_lifetime)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> builtins.str:
        """
        Service account to use to execute a task. If not provided, the default Compute service account for the project is used.
        """
        return pulumi.get(self, "service_account")

    @property
    @pulumi.getter
    def args(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The arguments to pass to the task. The args can use placeholders of the format ${placeholder} as part of key/value string. These will be interpolated before passing the args to the driver. Currently supported placeholders: - ${taskId} - ${job_time} To pass positional args, set the key as TASK_ARGS. The value should be a comma-separated string of all the positional arguments. To use a delimiter other than comma, refer to https://cloud.google.com/sdk/gcloud/reference/topic/escaping. In case of other keys being present in the args, then TASK_ARGS will be passed as the last argument. An object containing a list of 'key': value pairs. Example: { 'name': 'wrench', 'mass': '1.3kg', 'count': '3' }.
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[builtins.str]:
        """
        The Cloud KMS key to use for encryption, of the form: projects/{project_number}/locations/{locationId}/keyRings/{key-ring-name}/cryptoKeys/{key-name}.

        - - -
        """
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter(name="maxJobExecutionLifetime")
    def max_job_execution_lifetime(self) -> Optional[builtins.str]:
        """
        The maximum duration after which the job execution is expired. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'.
        """
        return pulumi.get(self, "max_job_execution_lifetime")

    @property
    @pulumi.getter
    def project(self) -> Optional[builtins.str]:
        """
        The ID of the project in which the resource belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class TaskExecutionStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestJobs":
            suggest = "latest_jobs"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskExecutionStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskExecutionStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskExecutionStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_jobs: Optional[Sequence['outputs.TaskExecutionStatusLatestJob']] = None,
                 update_time: Optional[builtins.str] = None):
        """
        :param Sequence['TaskExecutionStatusLatestJobArgs'] latest_jobs: (Output)
               latest job execution.
               Structure is documented below.
        :param builtins.str update_time: (Output)
               Last update time of the status.
        """
        if latest_jobs is not None:
            pulumi.set(__self__, "latest_jobs", latest_jobs)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="latestJobs")
    def latest_jobs(self) -> Optional[Sequence['outputs.TaskExecutionStatusLatestJob']]:
        """
        (Output)
        latest job execution.
        Structure is documented below.
        """
        return pulumi.get(self, "latest_jobs")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[builtins.str]:
        """
        (Output)
        Last update time of the status.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class TaskExecutionStatusLatestJob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "retryCount":
            suggest = "retry_count"
        elif key == "serviceJob":
            suggest = "service_job"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskExecutionStatusLatestJob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskExecutionStatusLatestJob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskExecutionStatusLatestJob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 retry_count: Optional[builtins.int] = None,
                 service: Optional[builtins.str] = None,
                 service_job: Optional[builtins.str] = None,
                 start_time: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 uid: Optional[builtins.str] = None):
        """
        :param builtins.str end_time: (Output)
               The time when the job ended.
        :param builtins.str message: (Output)
               Additional information about the current state.
        :param builtins.str name: (Output)
               The relative resource name of the job, of the form: projects/{project_number}/locations/{locationId}/lakes/{lakeId}/tasks/{taskId}/jobs/{jobId}.
        :param builtins.int retry_count: (Output)
               The number of times the job has been retried (excluding the initial attempt).
        :param builtins.str service: (Output)
               The underlying service running a job.
        :param builtins.str service_job: (Output)
               The full resource name for the job run under a particular service.
        :param builtins.str start_time: (Output)
               The time when the job was started.
        :param builtins.str state: (Output)
               Execution state for the job.
        :param builtins.str uid: (Output)
               System generated globally unique ID for the job.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if service_job is not None:
            pulumi.set(__self__, "service_job", service_job)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[builtins.str]:
        """
        (Output)
        The time when the job ended.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        (Output)
        Additional information about the current state.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        (Output)
        The relative resource name of the job, of the form: projects/{project_number}/locations/{locationId}/lakes/{lakeId}/tasks/{taskId}/jobs/{jobId}.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[builtins.int]:
        """
        (Output)
        The number of times the job has been retried (excluding the initial attempt).
        """
        return pulumi.get(self, "retry_count")

    @property
    @pulumi.getter
    def service(self) -> Optional[builtins.str]:
        """
        (Output)
        The underlying service running a job.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="serviceJob")
    def service_job(self) -> Optional[builtins.str]:
        """
        (Output)
        The full resource name for the job run under a particular service.
        """
        return pulumi.get(self, "service_job")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[builtins.str]:
        """
        (Output)
        The time when the job was started.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        (Output)
        Execution state for the job.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def uid(self) -> Optional[builtins.str]:
        """
        (Output)
        System generated globally unique ID for the job.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class TaskIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class TaskIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class TaskNotebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archiveUris":
            suggest = "archive_uris"
        elif key == "fileUris":
            suggest = "file_uris"
        elif key == "infrastructureSpec":
            suggest = "infrastructure_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskNotebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskNotebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskNotebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notebook: builtins.str,
                 archive_uris: Optional[Sequence[builtins.str]] = None,
                 file_uris: Optional[Sequence[builtins.str]] = None,
                 infrastructure_spec: Optional['outputs.TaskNotebookInfrastructureSpec'] = None):
        """
        :param builtins.str notebook: Path to input notebook. This can be the Cloud Storage URI of the notebook file or the path to a Notebook Content. The execution args are accessible as environment variables (TASK_key=value).
        :param Sequence[builtins.str] archive_uris: Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        :param Sequence[builtins.str] file_uris: Cloud Storage URIs of files to be placed in the working directory of each executor.
        :param 'TaskNotebookInfrastructureSpecArgs' infrastructure_spec: Infrastructure specification for the execution.
               Structure is documented below.
        """
        pulumi.set(__self__, "notebook", notebook)
        if archive_uris is not None:
            pulumi.set(__self__, "archive_uris", archive_uris)
        if file_uris is not None:
            pulumi.set(__self__, "file_uris", file_uris)
        if infrastructure_spec is not None:
            pulumi.set(__self__, "infrastructure_spec", infrastructure_spec)

    @property
    @pulumi.getter
    def notebook(self) -> builtins.str:
        """
        Path to input notebook. This can be the Cloud Storage URI of the notebook file or the path to a Notebook Content. The execution args are accessible as environment variables (TASK_key=value).
        """
        return pulumi.get(self, "notebook")

    @property
    @pulumi.getter(name="archiveUris")
    def archive_uris(self) -> Optional[Sequence[builtins.str]]:
        """
        Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        """
        return pulumi.get(self, "archive_uris")

    @property
    @pulumi.getter(name="fileUris")
    def file_uris(self) -> Optional[Sequence[builtins.str]]:
        """
        Cloud Storage URIs of files to be placed in the working directory of each executor.
        """
        return pulumi.get(self, "file_uris")

    @property
    @pulumi.getter(name="infrastructureSpec")
    def infrastructure_spec(self) -> Optional['outputs.TaskNotebookInfrastructureSpec']:
        """
        Infrastructure specification for the execution.
        Structure is documented below.
        """
        return pulumi.get(self, "infrastructure_spec")


@pulumi.output_type
class TaskNotebookInfrastructureSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerImage":
            suggest = "container_image"
        elif key == "vpcNetwork":
            suggest = "vpc_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskNotebookInfrastructureSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskNotebookInfrastructureSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskNotebookInfrastructureSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch: Optional['outputs.TaskNotebookInfrastructureSpecBatch'] = None,
                 container_image: Optional['outputs.TaskNotebookInfrastructureSpecContainerImage'] = None,
                 vpc_network: Optional['outputs.TaskNotebookInfrastructureSpecVpcNetwork'] = None):
        """
        :param 'TaskNotebookInfrastructureSpecBatchArgs' batch: Compute resources needed for a Task when using Dataproc Serverless.
               Structure is documented below.
        :param 'TaskNotebookInfrastructureSpecContainerImageArgs' container_image: Container Image Runtime Configuration.
               Structure is documented below.
        :param 'TaskNotebookInfrastructureSpecVpcNetworkArgs' vpc_network: Vpc network.
               Structure is documented below.
        """
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if container_image is not None:
            pulumi.set(__self__, "container_image", container_image)
        if vpc_network is not None:
            pulumi.set(__self__, "vpc_network", vpc_network)

    @property
    @pulumi.getter
    def batch(self) -> Optional['outputs.TaskNotebookInfrastructureSpecBatch']:
        """
        Compute resources needed for a Task when using Dataproc Serverless.
        Structure is documented below.
        """
        return pulumi.get(self, "batch")

    @property
    @pulumi.getter(name="containerImage")
    def container_image(self) -> Optional['outputs.TaskNotebookInfrastructureSpecContainerImage']:
        """
        Container Image Runtime Configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "container_image")

    @property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> Optional['outputs.TaskNotebookInfrastructureSpecVpcNetwork']:
        """
        Vpc network.
        Structure is documented below.
        """
        return pulumi.get(self, "vpc_network")


@pulumi.output_type
class TaskNotebookInfrastructureSpecBatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executorsCount":
            suggest = "executors_count"
        elif key == "maxExecutorsCount":
            suggest = "max_executors_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskNotebookInfrastructureSpecBatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskNotebookInfrastructureSpecBatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskNotebookInfrastructureSpecBatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 executors_count: Optional[builtins.int] = None,
                 max_executors_count: Optional[builtins.int] = None):
        """
        :param builtins.int executors_count: Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        :param builtins.int max_executors_count: Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        if executors_count is not None:
            pulumi.set(__self__, "executors_count", executors_count)
        if max_executors_count is not None:
            pulumi.set(__self__, "max_executors_count", max_executors_count)

    @property
    @pulumi.getter(name="executorsCount")
    def executors_count(self) -> Optional[builtins.int]:
        """
        Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        """
        return pulumi.get(self, "executors_count")

    @property
    @pulumi.getter(name="maxExecutorsCount")
    def max_executors_count(self) -> Optional[builtins.int]:
        """
        Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        return pulumi.get(self, "max_executors_count")


@pulumi.output_type
class TaskNotebookInfrastructureSpecContainerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "javaJars":
            suggest = "java_jars"
        elif key == "pythonPackages":
            suggest = "python_packages"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskNotebookInfrastructureSpecContainerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskNotebookInfrastructureSpecContainerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskNotebookInfrastructureSpecContainerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: Optional[builtins.str] = None,
                 java_jars: Optional[Sequence[builtins.str]] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 python_packages: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str image: Container image to use.
        :param Sequence[builtins.str] java_jars: A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        :param Mapping[str, builtins.str] properties: Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        :param Sequence[builtins.str] python_packages: A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if java_jars is not None:
            pulumi.set(__self__, "java_jars", java_jars)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if python_packages is not None:
            pulumi.set(__self__, "python_packages", python_packages)

    @property
    @pulumi.getter
    def image(self) -> Optional[builtins.str]:
        """
        Container image to use.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="javaJars")
    def java_jars(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        """
        return pulumi.get(self, "java_jars")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="pythonPackages")
    def python_packages(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        return pulumi.get(self, "python_packages")


@pulumi.output_type
class TaskNotebookInfrastructureSpecVpcNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkTags":
            suggest = "network_tags"
        elif key == "subNetwork":
            suggest = "sub_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskNotebookInfrastructureSpecVpcNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskNotebookInfrastructureSpecVpcNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskNotebookInfrastructureSpecVpcNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network: Optional[builtins.str] = None,
                 network_tags: Optional[Sequence[builtins.str]] = None,
                 sub_network: Optional[builtins.str] = None):
        """
        :param builtins.str network: The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        :param Sequence[builtins.str] network_tags: List of network tags to apply to the job.
        :param builtins.str sub_network: The Cloud VPC sub-network in which the job is run.
        """
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_tags is not None:
            pulumi.set(__self__, "network_tags", network_tags)
        if sub_network is not None:
            pulumi.set(__self__, "sub_network", sub_network)

    @property
    @pulumi.getter
    def network(self) -> Optional[builtins.str]:
        """
        The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="networkTags")
    def network_tags(self) -> Optional[Sequence[builtins.str]]:
        """
        List of network tags to apply to the job.
        """
        return pulumi.get(self, "network_tags")

    @property
    @pulumi.getter(name="subNetwork")
    def sub_network(self) -> Optional[builtins.str]:
        """
        The Cloud VPC sub-network in which the job is run.
        """
        return pulumi.get(self, "sub_network")


@pulumi.output_type
class TaskSpark(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archiveUris":
            suggest = "archive_uris"
        elif key == "fileUris":
            suggest = "file_uris"
        elif key == "infrastructureSpec":
            suggest = "infrastructure_spec"
        elif key == "mainClass":
            suggest = "main_class"
        elif key == "mainJarFileUri":
            suggest = "main_jar_file_uri"
        elif key == "pythonScriptFile":
            suggest = "python_script_file"
        elif key == "sqlScript":
            suggest = "sql_script"
        elif key == "sqlScriptFile":
            suggest = "sql_script_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskSpark. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskSpark.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskSpark.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive_uris: Optional[Sequence[builtins.str]] = None,
                 file_uris: Optional[Sequence[builtins.str]] = None,
                 infrastructure_spec: Optional['outputs.TaskSparkInfrastructureSpec'] = None,
                 main_class: Optional[builtins.str] = None,
                 main_jar_file_uri: Optional[builtins.str] = None,
                 python_script_file: Optional[builtins.str] = None,
                 sql_script: Optional[builtins.str] = None,
                 sql_script_file: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] archive_uris: Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        :param Sequence[builtins.str] file_uris: Cloud Storage URIs of files to be placed in the working directory of each executor.
        :param 'TaskSparkInfrastructureSpecArgs' infrastructure_spec: Infrastructure specification for the execution.
               Structure is documented below.
        :param builtins.str main_class: The name of the driver's main class. The jar file that contains the class must be in the default CLASSPATH or specified in jar_file_uris. The execution args are passed in as a sequence of named process arguments (--key=value).
        :param builtins.str main_jar_file_uri: The Cloud Storage URI of the jar file that contains the main class. The execution args are passed in as a sequence of named process arguments (--key=value).
        :param builtins.str python_script_file: The Gcloud Storage URI of the main Python file to use as the driver. Must be a .py file. The execution args are passed in as a sequence of named process arguments (--key=value).
        :param builtins.str sql_script: The query text. The execution args are used to declare a set of script variables (set key='value';).
        :param builtins.str sql_script_file: A reference to a query file. This can be the Cloud Storage URI of the query file or it can the path to a SqlScript Content. The execution args are used to declare a set of script variables (set key='value';).
        """
        if archive_uris is not None:
            pulumi.set(__self__, "archive_uris", archive_uris)
        if file_uris is not None:
            pulumi.set(__self__, "file_uris", file_uris)
        if infrastructure_spec is not None:
            pulumi.set(__self__, "infrastructure_spec", infrastructure_spec)
        if main_class is not None:
            pulumi.set(__self__, "main_class", main_class)
        if main_jar_file_uri is not None:
            pulumi.set(__self__, "main_jar_file_uri", main_jar_file_uri)
        if python_script_file is not None:
            pulumi.set(__self__, "python_script_file", python_script_file)
        if sql_script is not None:
            pulumi.set(__self__, "sql_script", sql_script)
        if sql_script_file is not None:
            pulumi.set(__self__, "sql_script_file", sql_script_file)

    @property
    @pulumi.getter(name="archiveUris")
    def archive_uris(self) -> Optional[Sequence[builtins.str]]:
        """
        Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        """
        return pulumi.get(self, "archive_uris")

    @property
    @pulumi.getter(name="fileUris")
    def file_uris(self) -> Optional[Sequence[builtins.str]]:
        """
        Cloud Storage URIs of files to be placed in the working directory of each executor.
        """
        return pulumi.get(self, "file_uris")

    @property
    @pulumi.getter(name="infrastructureSpec")
    def infrastructure_spec(self) -> Optional['outputs.TaskSparkInfrastructureSpec']:
        """
        Infrastructure specification for the execution.
        Structure is documented below.
        """
        return pulumi.get(self, "infrastructure_spec")

    @property
    @pulumi.getter(name="mainClass")
    def main_class(self) -> Optional[builtins.str]:
        """
        The name of the driver's main class. The jar file that contains the class must be in the default CLASSPATH or specified in jar_file_uris. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        return pulumi.get(self, "main_class")

    @property
    @pulumi.getter(name="mainJarFileUri")
    def main_jar_file_uri(self) -> Optional[builtins.str]:
        """
        The Cloud Storage URI of the jar file that contains the main class. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        return pulumi.get(self, "main_jar_file_uri")

    @property
    @pulumi.getter(name="pythonScriptFile")
    def python_script_file(self) -> Optional[builtins.str]:
        """
        The Gcloud Storage URI of the main Python file to use as the driver. Must be a .py file. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        return pulumi.get(self, "python_script_file")

    @property
    @pulumi.getter(name="sqlScript")
    def sql_script(self) -> Optional[builtins.str]:
        """
        The query text. The execution args are used to declare a set of script variables (set key='value';).
        """
        return pulumi.get(self, "sql_script")

    @property
    @pulumi.getter(name="sqlScriptFile")
    def sql_script_file(self) -> Optional[builtins.str]:
        """
        A reference to a query file. This can be the Cloud Storage URI of the query file or it can the path to a SqlScript Content. The execution args are used to declare a set of script variables (set key='value';).
        """
        return pulumi.get(self, "sql_script_file")


@pulumi.output_type
class TaskSparkInfrastructureSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerImage":
            suggest = "container_image"
        elif key == "vpcNetwork":
            suggest = "vpc_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskSparkInfrastructureSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskSparkInfrastructureSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskSparkInfrastructureSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch: Optional['outputs.TaskSparkInfrastructureSpecBatch'] = None,
                 container_image: Optional['outputs.TaskSparkInfrastructureSpecContainerImage'] = None,
                 vpc_network: Optional['outputs.TaskSparkInfrastructureSpecVpcNetwork'] = None):
        """
        :param 'TaskSparkInfrastructureSpecBatchArgs' batch: Compute resources needed for a Task when using Dataproc Serverless.
               Structure is documented below.
        :param 'TaskSparkInfrastructureSpecContainerImageArgs' container_image: Container Image Runtime Configuration.
               Structure is documented below.
        :param 'TaskSparkInfrastructureSpecVpcNetworkArgs' vpc_network: Vpc network.
               Structure is documented below.
        """
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if container_image is not None:
            pulumi.set(__self__, "container_image", container_image)
        if vpc_network is not None:
            pulumi.set(__self__, "vpc_network", vpc_network)

    @property
    @pulumi.getter
    def batch(self) -> Optional['outputs.TaskSparkInfrastructureSpecBatch']:
        """
        Compute resources needed for a Task when using Dataproc Serverless.
        Structure is documented below.
        """
        return pulumi.get(self, "batch")

    @property
    @pulumi.getter(name="containerImage")
    def container_image(self) -> Optional['outputs.TaskSparkInfrastructureSpecContainerImage']:
        """
        Container Image Runtime Configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "container_image")

    @property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> Optional['outputs.TaskSparkInfrastructureSpecVpcNetwork']:
        """
        Vpc network.
        Structure is documented below.
        """
        return pulumi.get(self, "vpc_network")


@pulumi.output_type
class TaskSparkInfrastructureSpecBatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executorsCount":
            suggest = "executors_count"
        elif key == "maxExecutorsCount":
            suggest = "max_executors_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskSparkInfrastructureSpecBatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskSparkInfrastructureSpecBatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskSparkInfrastructureSpecBatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 executors_count: Optional[builtins.int] = None,
                 max_executors_count: Optional[builtins.int] = None):
        """
        :param builtins.int executors_count: Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        :param builtins.int max_executors_count: Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        if executors_count is not None:
            pulumi.set(__self__, "executors_count", executors_count)
        if max_executors_count is not None:
            pulumi.set(__self__, "max_executors_count", max_executors_count)

    @property
    @pulumi.getter(name="executorsCount")
    def executors_count(self) -> Optional[builtins.int]:
        """
        Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        """
        return pulumi.get(self, "executors_count")

    @property
    @pulumi.getter(name="maxExecutorsCount")
    def max_executors_count(self) -> Optional[builtins.int]:
        """
        Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        return pulumi.get(self, "max_executors_count")


@pulumi.output_type
class TaskSparkInfrastructureSpecContainerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "javaJars":
            suggest = "java_jars"
        elif key == "pythonPackages":
            suggest = "python_packages"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskSparkInfrastructureSpecContainerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskSparkInfrastructureSpecContainerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskSparkInfrastructureSpecContainerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: Optional[builtins.str] = None,
                 java_jars: Optional[Sequence[builtins.str]] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 python_packages: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str image: Container image to use.
        :param Sequence[builtins.str] java_jars: A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        :param Mapping[str, builtins.str] properties: Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        :param Sequence[builtins.str] python_packages: A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if java_jars is not None:
            pulumi.set(__self__, "java_jars", java_jars)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if python_packages is not None:
            pulumi.set(__self__, "python_packages", python_packages)

    @property
    @pulumi.getter
    def image(self) -> Optional[builtins.str]:
        """
        Container image to use.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="javaJars")
    def java_jars(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        """
        return pulumi.get(self, "java_jars")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="pythonPackages")
    def python_packages(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        return pulumi.get(self, "python_packages")


@pulumi.output_type
class TaskSparkInfrastructureSpecVpcNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkTags":
            suggest = "network_tags"
        elif key == "subNetwork":
            suggest = "sub_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskSparkInfrastructureSpecVpcNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskSparkInfrastructureSpecVpcNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskSparkInfrastructureSpecVpcNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network: Optional[builtins.str] = None,
                 network_tags: Optional[Sequence[builtins.str]] = None,
                 sub_network: Optional[builtins.str] = None):
        """
        :param builtins.str network: The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        :param Sequence[builtins.str] network_tags: List of network tags to apply to the job.
        :param builtins.str sub_network: The Cloud VPC sub-network in which the job is run.
        """
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_tags is not None:
            pulumi.set(__self__, "network_tags", network_tags)
        if sub_network is not None:
            pulumi.set(__self__, "sub_network", sub_network)

    @property
    @pulumi.getter
    def network(self) -> Optional[builtins.str]:
        """
        The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="networkTags")
    def network_tags(self) -> Optional[Sequence[builtins.str]]:
        """
        List of network tags to apply to the job.
        """
        return pulumi.get(self, "network_tags")

    @property
    @pulumi.getter(name="subNetwork")
    def sub_network(self) -> Optional[builtins.str]:
        """
        The Cloud VPC sub-network in which the job is run.
        """
        return pulumi.get(self, "sub_network")


@pulumi.output_type
class TaskTriggerSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRetries":
            suggest = "max_retries"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskTriggerSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskTriggerSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskTriggerSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 disabled: Optional[builtins.bool] = None,
                 max_retries: Optional[builtins.int] = None,
                 schedule: Optional[builtins.str] = None,
                 start_time: Optional[builtins.str] = None):
        """
        :param builtins.str type: Trigger type of the user-specified Task
               Possible values are: `ON_DEMAND`, `RECURRING`.
        :param builtins.bool disabled: Prevent the task from executing. This does not cancel already running tasks. It is intended to temporarily disable RECURRING tasks.
        :param builtins.int max_retries: Number of retry attempts before aborting. Set to zero to never attempt to retry a failed task.
        :param builtins.str schedule: Cron schedule (https://en.wikipedia.org/wiki/Cron) for running tasks periodically. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: 'CRON_TZ=${IANA_TIME_ZONE}' or 'TZ=${IANA_TIME_ZONE}'. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, CRON_TZ=America/New_York 1 * * * *, or TZ=America/New_York 1 * * * *. This field is required for RECURRING tasks.
        :param builtins.str start_time: The first run of the task will be after this time. If not specified, the task will run shortly after being submitted if ON_DEMAND and based on the schedule if RECURRING.
        """
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Trigger type of the user-specified Task
        Possible values are: `ON_DEMAND`, `RECURRING`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[builtins.bool]:
        """
        Prevent the task from executing. This does not cancel already running tasks. It is intended to temporarily disable RECURRING tasks.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[builtins.int]:
        """
        Number of retry attempts before aborting. Set to zero to never attempt to retry a failed task.
        """
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[builtins.str]:
        """
        Cron schedule (https://en.wikipedia.org/wiki/Cron) for running tasks periodically. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: 'CRON_TZ=${IANA_TIME_ZONE}' or 'TZ=${IANA_TIME_ZONE}'. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, CRON_TZ=America/New_York 1 * * * *, or TZ=America/New_York 1 * * * *. This field is required for RECURRING tasks.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[builtins.str]:
        """
        The first run of the task will be after this time. If not specified, the task will run shortly after being submitted if ON_DEMAND and based on the schedule if RECURRING.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ZoneAssetStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeAssets":
            suggest = "active_assets"
        elif key == "securityPolicyApplyingAssets":
            suggest = "security_policy_applying_assets"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneAssetStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneAssetStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneAssetStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_assets: Optional[builtins.int] = None,
                 security_policy_applying_assets: Optional[builtins.int] = None,
                 update_time: Optional[builtins.str] = None):
        """
        :param builtins.int active_assets: Number of active assets.
        :param builtins.int security_policy_applying_assets: Number of assets that are in process of updating the security policy on attached resources.
        :param builtins.str update_time: Output only. The time when the zone was last updated.
        """
        if active_assets is not None:
            pulumi.set(__self__, "active_assets", active_assets)
        if security_policy_applying_assets is not None:
            pulumi.set(__self__, "security_policy_applying_assets", security_policy_applying_assets)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="activeAssets")
    def active_assets(self) -> Optional[builtins.int]:
        """
        Number of active assets.
        """
        return pulumi.get(self, "active_assets")

    @property
    @pulumi.getter(name="securityPolicyApplyingAssets")
    def security_policy_applying_assets(self) -> Optional[builtins.int]:
        """
        Number of assets that are in process of updating the security policy on attached resources.
        """
        return pulumi.get(self, "security_policy_applying_assets")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[builtins.str]:
        """
        Output only. The time when the zone was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class ZoneDiscoverySpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "csvOptions":
            suggest = "csv_options"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"
        elif key == "jsonOptions":
            suggest = "json_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneDiscoverySpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneDiscoverySpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneDiscoverySpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 csv_options: Optional['outputs.ZoneDiscoverySpecCsvOptions'] = None,
                 exclude_patterns: Optional[Sequence[builtins.str]] = None,
                 include_patterns: Optional[Sequence[builtins.str]] = None,
                 json_options: Optional['outputs.ZoneDiscoverySpecJsonOptions'] = None,
                 schedule: Optional[builtins.str] = None):
        """
        :param builtins.bool enabled: Required. Whether discovery is enabled.
        :param 'ZoneDiscoverySpecCsvOptionsArgs' csv_options: Optional. Configuration for CSV data.
        :param Sequence[builtins.str] exclude_patterns: Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param Sequence[builtins.str] include_patterns: Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param 'ZoneDiscoverySpecJsonOptionsArgs' json_options: Optional. Configuration for Json data.
        :param builtins.str schedule: Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        pulumi.set(__self__, "enabled", enabled)
        if csv_options is not None:
            pulumi.set(__self__, "csv_options", csv_options)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if json_options is not None:
            pulumi.set(__self__, "json_options", json_options)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Required. Whether discovery is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="csvOptions")
    def csv_options(self) -> Optional['outputs.ZoneDiscoverySpecCsvOptions']:
        """
        Optional. Configuration for CSV data.
        """
        return pulumi.get(self, "csv_options")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "include_patterns")

    @property
    @pulumi.getter(name="jsonOptions")
    def json_options(self) -> Optional['outputs.ZoneDiscoverySpecJsonOptions']:
        """
        Optional. Configuration for Json data.
        """
        return pulumi.get(self, "json_options")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[builtins.str]:
        """
        Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class ZoneDiscoverySpecCsvOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableTypeInference":
            suggest = "disable_type_inference"
        elif key == "headerRows":
            suggest = "header_rows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneDiscoverySpecCsvOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneDiscoverySpecCsvOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneDiscoverySpecCsvOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[builtins.str] = None,
                 disable_type_inference: Optional[builtins.bool] = None,
                 encoding: Optional[builtins.str] = None,
                 header_rows: Optional[builtins.int] = None):
        """
        :param builtins.str delimiter: Optional. The delimiter being used to separate values. This defaults to ','.
        :param builtins.bool disable_type_inference: Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        :param builtins.str encoding: Optional. The character encoding of the data. The default is UTF-8.
        :param builtins.int header_rows: Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if header_rows is not None:
            pulumi.set(__self__, "header_rows", header_rows)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[builtins.str]:
        """
        Optional. The delimiter being used to separate values. This defaults to ','.
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[builtins.bool]:
        """
        Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        """
        return pulumi.get(self, "disable_type_inference")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[builtins.str]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="headerRows")
    def header_rows(self) -> Optional[builtins.int]:
        """
        Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        return pulumi.get(self, "header_rows")


@pulumi.output_type
class ZoneDiscoverySpecJsonOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableTypeInference":
            suggest = "disable_type_inference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneDiscoverySpecJsonOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneDiscoverySpecJsonOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneDiscoverySpecJsonOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_type_inference: Optional[builtins.bool] = None,
                 encoding: Optional[builtins.str] = None):
        """
        :param builtins.bool disable_type_inference: Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        :param builtins.str encoding: Optional. The character encoding of the data. The default is UTF-8.
        """
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[builtins.bool]:
        """
        Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        """
        return pulumi.get(self, "disable_type_inference")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[builtins.str]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")


@pulumi.output_type
class ZoneIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class ZoneIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class ZoneResourceSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "locationType":
            suggest = "location_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneResourceSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneResourceSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneResourceSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location_type: builtins.str):
        """
        :param builtins.str location_type: Required. Immutable. The location type of the resources that are allowed to be attached to the assets within this zone. Possible values: LOCATION_TYPE_UNSPECIFIED, SINGLE_REGION, MULTI_REGION
               
               - - -
        """
        pulumi.set(__self__, "location_type", location_type)

    @property
    @pulumi.getter(name="locationType")
    def location_type(self) -> builtins.str:
        """
        Required. Immutable. The location type of the resources that are allowed to be attached to the assets within this zone. Possible values: LOCATION_TYPE_UNSPECIFIED, SINGLE_REGION, MULTI_REGION

        - - -
        """
        return pulumi.get(self, "location_type")


