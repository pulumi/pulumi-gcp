# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AspectTypeIamBindingConditionArgs',
    'AspectTypeIamBindingConditionArgsDict',
    'AspectTypeIamMemberConditionArgs',
    'AspectTypeIamMemberConditionArgsDict',
    'AssetDiscoverySpecArgs',
    'AssetDiscoverySpecArgsDict',
    'AssetDiscoverySpecCsvOptionsArgs',
    'AssetDiscoverySpecCsvOptionsArgsDict',
    'AssetDiscoverySpecJsonOptionsArgs',
    'AssetDiscoverySpecJsonOptionsArgsDict',
    'AssetDiscoveryStatusArgs',
    'AssetDiscoveryStatusArgsDict',
    'AssetDiscoveryStatusStatArgs',
    'AssetDiscoveryStatusStatArgsDict',
    'AssetIamBindingConditionArgs',
    'AssetIamBindingConditionArgsDict',
    'AssetIamMemberConditionArgs',
    'AssetIamMemberConditionArgsDict',
    'AssetResourceSpecArgs',
    'AssetResourceSpecArgsDict',
    'AssetResourceStatusArgs',
    'AssetResourceStatusArgsDict',
    'AssetSecurityStatusArgs',
    'AssetSecurityStatusArgsDict',
    'DatascanDataArgs',
    'DatascanDataArgsDict',
    'DatascanDataProfileSpecArgs',
    'DatascanDataProfileSpecArgsDict',
    'DatascanDataProfileSpecExcludeFieldsArgs',
    'DatascanDataProfileSpecExcludeFieldsArgsDict',
    'DatascanDataProfileSpecIncludeFieldsArgs',
    'DatascanDataProfileSpecIncludeFieldsArgsDict',
    'DatascanDataProfileSpecPostScanActionsArgs',
    'DatascanDataProfileSpecPostScanActionsArgsDict',
    'DatascanDataProfileSpecPostScanActionsBigqueryExportArgs',
    'DatascanDataProfileSpecPostScanActionsBigqueryExportArgsDict',
    'DatascanDataQualitySpecArgs',
    'DatascanDataQualitySpecArgsDict',
    'DatascanDataQualitySpecPostScanActionsArgs',
    'DatascanDataQualitySpecPostScanActionsArgsDict',
    'DatascanDataQualitySpecPostScanActionsBigqueryExportArgs',
    'DatascanDataQualitySpecPostScanActionsBigqueryExportArgsDict',
    'DatascanDataQualitySpecRuleArgs',
    'DatascanDataQualitySpecRuleArgsDict',
    'DatascanDataQualitySpecRuleNonNullExpectationArgs',
    'DatascanDataQualitySpecRuleNonNullExpectationArgsDict',
    'DatascanDataQualitySpecRuleRangeExpectationArgs',
    'DatascanDataQualitySpecRuleRangeExpectationArgsDict',
    'DatascanDataQualitySpecRuleRegexExpectationArgs',
    'DatascanDataQualitySpecRuleRegexExpectationArgsDict',
    'DatascanDataQualitySpecRuleRowConditionExpectationArgs',
    'DatascanDataQualitySpecRuleRowConditionExpectationArgsDict',
    'DatascanDataQualitySpecRuleSetExpectationArgs',
    'DatascanDataQualitySpecRuleSetExpectationArgsDict',
    'DatascanDataQualitySpecRuleStatisticRangeExpectationArgs',
    'DatascanDataQualitySpecRuleStatisticRangeExpectationArgsDict',
    'DatascanDataQualitySpecRuleTableConditionExpectationArgs',
    'DatascanDataQualitySpecRuleTableConditionExpectationArgsDict',
    'DatascanDataQualitySpecRuleUniquenessExpectationArgs',
    'DatascanDataQualitySpecRuleUniquenessExpectationArgsDict',
    'DatascanExecutionSpecArgs',
    'DatascanExecutionSpecArgsDict',
    'DatascanExecutionSpecTriggerArgs',
    'DatascanExecutionSpecTriggerArgsDict',
    'DatascanExecutionSpecTriggerOnDemandArgs',
    'DatascanExecutionSpecTriggerOnDemandArgsDict',
    'DatascanExecutionSpecTriggerScheduleArgs',
    'DatascanExecutionSpecTriggerScheduleArgsDict',
    'DatascanExecutionStatusArgs',
    'DatascanExecutionStatusArgsDict',
    'DatascanIamBindingConditionArgs',
    'DatascanIamBindingConditionArgsDict',
    'DatascanIamMemberConditionArgs',
    'DatascanIamMemberConditionArgsDict',
    'EntryGroupIamBindingConditionArgs',
    'EntryGroupIamBindingConditionArgsDict',
    'EntryGroupIamMemberConditionArgs',
    'EntryGroupIamMemberConditionArgsDict',
    'EntryTypeIamBindingConditionArgs',
    'EntryTypeIamBindingConditionArgsDict',
    'EntryTypeIamMemberConditionArgs',
    'EntryTypeIamMemberConditionArgsDict',
    'EntryTypeRequiredAspectArgs',
    'EntryTypeRequiredAspectArgsDict',
    'LakeAssetStatusArgs',
    'LakeAssetStatusArgsDict',
    'LakeIamBindingConditionArgs',
    'LakeIamBindingConditionArgsDict',
    'LakeIamMemberConditionArgs',
    'LakeIamMemberConditionArgsDict',
    'LakeMetastoreArgs',
    'LakeMetastoreArgsDict',
    'LakeMetastoreStatusArgs',
    'LakeMetastoreStatusArgsDict',
    'TaskExecutionSpecArgs',
    'TaskExecutionSpecArgsDict',
    'TaskExecutionStatusArgs',
    'TaskExecutionStatusArgsDict',
    'TaskExecutionStatusLatestJobArgs',
    'TaskExecutionStatusLatestJobArgsDict',
    'TaskIamBindingConditionArgs',
    'TaskIamBindingConditionArgsDict',
    'TaskIamMemberConditionArgs',
    'TaskIamMemberConditionArgsDict',
    'TaskNotebookArgs',
    'TaskNotebookArgsDict',
    'TaskNotebookInfrastructureSpecArgs',
    'TaskNotebookInfrastructureSpecArgsDict',
    'TaskNotebookInfrastructureSpecBatchArgs',
    'TaskNotebookInfrastructureSpecBatchArgsDict',
    'TaskNotebookInfrastructureSpecContainerImageArgs',
    'TaskNotebookInfrastructureSpecContainerImageArgsDict',
    'TaskNotebookInfrastructureSpecVpcNetworkArgs',
    'TaskNotebookInfrastructureSpecVpcNetworkArgsDict',
    'TaskSparkArgs',
    'TaskSparkArgsDict',
    'TaskSparkInfrastructureSpecArgs',
    'TaskSparkInfrastructureSpecArgsDict',
    'TaskSparkInfrastructureSpecBatchArgs',
    'TaskSparkInfrastructureSpecBatchArgsDict',
    'TaskSparkInfrastructureSpecContainerImageArgs',
    'TaskSparkInfrastructureSpecContainerImageArgsDict',
    'TaskSparkInfrastructureSpecVpcNetworkArgs',
    'TaskSparkInfrastructureSpecVpcNetworkArgsDict',
    'TaskTriggerSpecArgs',
    'TaskTriggerSpecArgsDict',
    'ZoneAssetStatusArgs',
    'ZoneAssetStatusArgsDict',
    'ZoneDiscoverySpecArgs',
    'ZoneDiscoverySpecArgsDict',
    'ZoneDiscoverySpecCsvOptionsArgs',
    'ZoneDiscoverySpecCsvOptionsArgsDict',
    'ZoneDiscoverySpecJsonOptionsArgs',
    'ZoneDiscoverySpecJsonOptionsArgsDict',
    'ZoneIamBindingConditionArgs',
    'ZoneIamBindingConditionArgsDict',
    'ZoneIamMemberConditionArgs',
    'ZoneIamMemberConditionArgsDict',
    'ZoneResourceSpecArgs',
    'ZoneResourceSpecArgsDict',
]

MYPY = False

if not MYPY:
    class AspectTypeIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    AspectTypeIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AspectTypeIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class AspectTypeIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    AspectTypeIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AspectTypeIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class AssetDiscoverySpecArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Required. Whether discovery is enabled.
        """
        csv_options: NotRequired[pulumi.Input['AssetDiscoverySpecCsvOptionsArgsDict']]
        """
        Optional. Configuration for CSV data.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        json_options: NotRequired[pulumi.Input['AssetDiscoverySpecJsonOptionsArgsDict']]
        """
        Optional. Configuration for Json data.
        """
        schedule: NotRequired[pulumi.Input[str]]
        """
        Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
elif False:
    AssetDiscoverySpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssetDiscoverySpecArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 csv_options: Optional[pulumi.Input['AssetDiscoverySpecCsvOptionsArgs']] = None,
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 json_options: Optional[pulumi.Input['AssetDiscoverySpecJsonOptionsArgs']] = None,
                 schedule: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Required. Whether discovery is enabled.
        :param pulumi.Input['AssetDiscoverySpecCsvOptionsArgs'] csv_options: Optional. Configuration for CSV data.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param pulumi.Input['AssetDiscoverySpecJsonOptionsArgs'] json_options: Optional. Configuration for Json data.
        :param pulumi.Input[str] schedule: Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        pulumi.set(__self__, "enabled", enabled)
        if csv_options is not None:
            pulumi.set(__self__, "csv_options", csv_options)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if json_options is not None:
            pulumi.set(__self__, "json_options", json_options)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Required. Whether discovery is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="csvOptions")
    def csv_options(self) -> Optional[pulumi.Input['AssetDiscoverySpecCsvOptionsArgs']]:
        """
        Optional. Configuration for CSV data.
        """
        return pulumi.get(self, "csv_options")

    @csv_options.setter
    def csv_options(self, value: Optional[pulumi.Input['AssetDiscoverySpecCsvOptionsArgs']]):
        pulumi.set(self, "csv_options", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)

    @property
    @pulumi.getter(name="jsonOptions")
    def json_options(self) -> Optional[pulumi.Input['AssetDiscoverySpecJsonOptionsArgs']]:
        """
        Optional. Configuration for Json data.
        """
        return pulumi.get(self, "json_options")

    @json_options.setter
    def json_options(self, value: Optional[pulumi.Input['AssetDiscoverySpecJsonOptionsArgs']]):
        pulumi.set(self, "json_options", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class AssetDiscoverySpecCsvOptionsArgsDict(TypedDict):
        delimiter: NotRequired[pulumi.Input[str]]
        """
        Optional. The delimiter being used to separate values. This defaults to ','.
        """
        disable_type_inference: NotRequired[pulumi.Input[bool]]
        """
        Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        """
        encoding: NotRequired[pulumi.Input[str]]
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        header_rows: NotRequired[pulumi.Input[int]]
        """
        Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
elif False:
    AssetDiscoverySpecCsvOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssetDiscoverySpecCsvOptionsArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 disable_type_inference: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 header_rows: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] delimiter: Optional. The delimiter being used to separate values. This defaults to ','.
        :param pulumi.Input[bool] disable_type_inference: Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        :param pulumi.Input[str] encoding: Optional. The character encoding of the data. The default is UTF-8.
        :param pulumi.Input[int] header_rows: Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if header_rows is not None:
            pulumi.set(__self__, "header_rows", header_rows)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The delimiter being used to separate values. This defaults to ','.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        """
        return pulumi.get(self, "disable_type_inference")

    @disable_type_inference.setter
    def disable_type_inference(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_type_inference", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="headerRows")
    def header_rows(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        return pulumi.get(self, "header_rows")

    @header_rows.setter
    def header_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "header_rows", value)


if not MYPY:
    class AssetDiscoverySpecJsonOptionsArgsDict(TypedDict):
        disable_type_inference: NotRequired[pulumi.Input[bool]]
        """
        Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        """
        encoding: NotRequired[pulumi.Input[str]]
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
elif False:
    AssetDiscoverySpecJsonOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssetDiscoverySpecJsonOptionsArgs:
    def __init__(__self__, *,
                 disable_type_inference: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable_type_inference: Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        :param pulumi.Input[str] encoding: Optional. The character encoding of the data. The default is UTF-8.
        """
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        """
        return pulumi.get(self, "disable_type_inference")

    @disable_type_inference.setter
    def disable_type_inference(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_type_inference", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)


if not MYPY:
    class AssetDiscoveryStatusArgsDict(TypedDict):
        last_run_duration: NotRequired[pulumi.Input[str]]
        """
        The duration of the last discovery run.
        """
        last_run_time: NotRequired[pulumi.Input[str]]
        """
        The start time of the last discovery run.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Additional information about the current state.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        stats: NotRequired[pulumi.Input[Sequence[pulumi.Input['AssetDiscoveryStatusStatArgsDict']]]]
        """
        Data Stats of the asset reported by discovery.
        """
        update_time: NotRequired[pulumi.Input[str]]
        """
        Output only. The time when the asset was last updated.
        """
elif False:
    AssetDiscoveryStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssetDiscoveryStatusArgs:
    def __init__(__self__, *,
                 last_run_duration: Optional[pulumi.Input[str]] = None,
                 last_run_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 stats: Optional[pulumi.Input[Sequence[pulumi.Input['AssetDiscoveryStatusStatArgs']]]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_run_duration: The duration of the last discovery run.
        :param pulumi.Input[str] last_run_time: The start time of the last discovery run.
        :param pulumi.Input[str] message: Additional information about the current state.
        :param pulumi.Input[str] state: Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param pulumi.Input[Sequence[pulumi.Input['AssetDiscoveryStatusStatArgs']]] stats: Data Stats of the asset reported by discovery.
        :param pulumi.Input[str] update_time: Output only. The time when the asset was last updated.
        """
        if last_run_duration is not None:
            pulumi.set(__self__, "last_run_duration", last_run_duration)
        if last_run_time is not None:
            pulumi.set(__self__, "last_run_time", last_run_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if stats is not None:
            pulumi.set(__self__, "stats", stats)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="lastRunDuration")
    def last_run_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The duration of the last discovery run.
        """
        return pulumi.get(self, "last_run_duration")

    @last_run_duration.setter
    def last_run_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_run_duration", value)

    @property
    @pulumi.getter(name="lastRunTime")
    def last_run_time(self) -> Optional[pulumi.Input[str]]:
        """
        The start time of the last discovery run.
        """
        return pulumi.get(self, "last_run_time")

    @last_run_time.setter
    def last_run_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_run_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current state.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def stats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AssetDiscoveryStatusStatArgs']]]]:
        """
        Data Stats of the asset reported by discovery.
        """
        return pulumi.get(self, "stats")

    @stats.setter
    def stats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AssetDiscoveryStatusStatArgs']]]]):
        pulumi.set(self, "stats", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. The time when the asset was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class AssetDiscoveryStatusStatArgsDict(TypedDict):
        data_items: NotRequired[pulumi.Input[int]]
        """
        The count of data items within the referenced resource.
        """
        data_size: NotRequired[pulumi.Input[int]]
        """
        The number of stored data bytes within the referenced resource.
        """
        filesets: NotRequired[pulumi.Input[int]]
        """
        The count of fileset entities within the referenced resource.
        """
        tables: NotRequired[pulumi.Input[int]]
        """
        The count of table entities within the referenced resource.
        """
elif False:
    AssetDiscoveryStatusStatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssetDiscoveryStatusStatArgs:
    def __init__(__self__, *,
                 data_items: Optional[pulumi.Input[int]] = None,
                 data_size: Optional[pulumi.Input[int]] = None,
                 filesets: Optional[pulumi.Input[int]] = None,
                 tables: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] data_items: The count of data items within the referenced resource.
        :param pulumi.Input[int] data_size: The number of stored data bytes within the referenced resource.
        :param pulumi.Input[int] filesets: The count of fileset entities within the referenced resource.
        :param pulumi.Input[int] tables: The count of table entities within the referenced resource.
        """
        if data_items is not None:
            pulumi.set(__self__, "data_items", data_items)
        if data_size is not None:
            pulumi.set(__self__, "data_size", data_size)
        if filesets is not None:
            pulumi.set(__self__, "filesets", filesets)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter(name="dataItems")
    def data_items(self) -> Optional[pulumi.Input[int]]:
        """
        The count of data items within the referenced resource.
        """
        return pulumi.get(self, "data_items")

    @data_items.setter
    def data_items(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "data_items", value)

    @property
    @pulumi.getter(name="dataSize")
    def data_size(self) -> Optional[pulumi.Input[int]]:
        """
        The number of stored data bytes within the referenced resource.
        """
        return pulumi.get(self, "data_size")

    @data_size.setter
    def data_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "data_size", value)

    @property
    @pulumi.getter
    def filesets(self) -> Optional[pulumi.Input[int]]:
        """
        The count of fileset entities within the referenced resource.
        """
        return pulumi.get(self, "filesets")

    @filesets.setter
    def filesets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "filesets", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input[int]]:
        """
        The count of table entities within the referenced resource.
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class AssetIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    AssetIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssetIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class AssetIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    AssetIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssetIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class AssetResourceSpecArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Required. Immutable. Type of resource. Possible values: STORAGE_BUCKET, BIGQUERY_DATASET

        - - -
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Immutable. Relative name of the cloud resource that contains the data that is being managed within a lake. For example: `projects/{project_number}/buckets/{bucket_id}` `projects/{project_number}/datasets/{dataset_id}`
        """
        read_access_mode: NotRequired[pulumi.Input[str]]
        """
        Optional. Determines how read permissions are handled for each asset and their associated tables. Only available to storage buckets assets. Possible values: DIRECT, MANAGED
        """
elif False:
    AssetResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssetResourceSpecArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 read_access_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Required. Immutable. Type of resource. Possible values: STORAGE_BUCKET, BIGQUERY_DATASET
               
               - - -
        :param pulumi.Input[str] name: Immutable. Relative name of the cloud resource that contains the data that is being managed within a lake. For example: `projects/{project_number}/buckets/{bucket_id}` `projects/{project_number}/datasets/{dataset_id}`
        :param pulumi.Input[str] read_access_mode: Optional. Determines how read permissions are handled for each asset and their associated tables. Only available to storage buckets assets. Possible values: DIRECT, MANAGED
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if read_access_mode is not None:
            pulumi.set(__self__, "read_access_mode", read_access_mode)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Required. Immutable. Type of resource. Possible values: STORAGE_BUCKET, BIGQUERY_DATASET

        - - -
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Immutable. Relative name of the cloud resource that contains the data that is being managed within a lake. For example: `projects/{project_number}/buckets/{bucket_id}` `projects/{project_number}/datasets/{dataset_id}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="readAccessMode")
    def read_access_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Determines how read permissions are handled for each asset and their associated tables. Only available to storage buckets assets. Possible values: DIRECT, MANAGED
        """
        return pulumi.get(self, "read_access_mode")

    @read_access_mode.setter
    def read_access_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read_access_mode", value)


if not MYPY:
    class AssetResourceStatusArgsDict(TypedDict):
        message: NotRequired[pulumi.Input[str]]
        """
        Additional information about the current state.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        update_time: NotRequired[pulumi.Input[str]]
        """
        Output only. The time when the asset was last updated.
        """
elif False:
    AssetResourceStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssetResourceStatusArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] message: Additional information about the current state.
        :param pulumi.Input[str] state: Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param pulumi.Input[str] update_time: Output only. The time when the asset was last updated.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current state.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. The time when the asset was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class AssetSecurityStatusArgsDict(TypedDict):
        message: NotRequired[pulumi.Input[str]]
        """
        Additional information about the current state.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        update_time: NotRequired[pulumi.Input[str]]
        """
        Output only. The time when the asset was last updated.
        """
elif False:
    AssetSecurityStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssetSecurityStatusArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] message: Additional information about the current state.
        :param pulumi.Input[str] state: Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param pulumi.Input[str] update_time: Output only. The time when the asset was last updated.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current state.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. The time when the asset was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class DatascanDataArgsDict(TypedDict):
        entity: NotRequired[pulumi.Input[str]]
        """
        The Dataplex entity that represents the data source(e.g. BigQuery table) for Datascan.
        """
        resource: NotRequired[pulumi.Input[str]]
        """
        The service-qualified full resource name of the cloud resource for a DataScan job to scan against. The field could be:
        (Cloud Storage bucket for DataDiscoveryScan)BigQuery table of type "TABLE" for DataProfileScan/DataQualityScan.
        """
elif False:
    DatascanDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataArgs:
    def __init__(__self__, *,
                 entity: Optional[pulumi.Input[str]] = None,
                 resource: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] entity: The Dataplex entity that represents the data source(e.g. BigQuery table) for Datascan.
        :param pulumi.Input[str] resource: The service-qualified full resource name of the cloud resource for a DataScan job to scan against. The field could be:
               (Cloud Storage bucket for DataDiscoveryScan)BigQuery table of type "TABLE" for DataProfileScan/DataQualityScan.
        """
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def entity(self) -> Optional[pulumi.Input[str]]:
        """
        The Dataplex entity that represents the data source(e.g. BigQuery table) for Datascan.
        """
        return pulumi.get(self, "entity")

    @entity.setter
    def entity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[str]]:
        """
        The service-qualified full resource name of the cloud resource for a DataScan job to scan against. The field could be:
        (Cloud Storage bucket for DataDiscoveryScan)BigQuery table of type "TABLE" for DataProfileScan/DataQualityScan.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource", value)


if not MYPY:
    class DatascanDataProfileSpecArgsDict(TypedDict):
        exclude_fields: NotRequired[pulumi.Input['DatascanDataProfileSpecExcludeFieldsArgsDict']]
        """
        The fields to exclude from data profile.
        If specified, the fields will be excluded from data profile, regardless of `include_fields` value.
        Structure is documented below.
        """
        include_fields: NotRequired[pulumi.Input['DatascanDataProfileSpecIncludeFieldsArgsDict']]
        """
        The fields to include in data profile.
        If not specified, all fields at the time of profile scan job execution are included, except for ones listed in `exclude_fields`.
        Structure is documented below.
        """
        post_scan_actions: NotRequired[pulumi.Input['DatascanDataProfileSpecPostScanActionsArgsDict']]
        """
        Actions to take upon job completion.
        Structure is documented below.
        """
        row_filter: NotRequired[pulumi.Input[str]]
        """
        A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        """
        sampling_percent: NotRequired[pulumi.Input[float]]
        """
        The percentage of the records to be selected from the dataset for DataScan.
        Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
        Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
elif False:
    DatascanDataProfileSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataProfileSpecArgs:
    def __init__(__self__, *,
                 exclude_fields: Optional[pulumi.Input['DatascanDataProfileSpecExcludeFieldsArgs']] = None,
                 include_fields: Optional[pulumi.Input['DatascanDataProfileSpecIncludeFieldsArgs']] = None,
                 post_scan_actions: Optional[pulumi.Input['DatascanDataProfileSpecPostScanActionsArgs']] = None,
                 row_filter: Optional[pulumi.Input[str]] = None,
                 sampling_percent: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input['DatascanDataProfileSpecExcludeFieldsArgs'] exclude_fields: The fields to exclude from data profile.
               If specified, the fields will be excluded from data profile, regardless of `include_fields` value.
               Structure is documented below.
        :param pulumi.Input['DatascanDataProfileSpecIncludeFieldsArgs'] include_fields: The fields to include in data profile.
               If not specified, all fields at the time of profile scan job execution are included, except for ones listed in `exclude_fields`.
               Structure is documented below.
        :param pulumi.Input['DatascanDataProfileSpecPostScanActionsArgs'] post_scan_actions: Actions to take upon job completion.
               Structure is documented below.
        :param pulumi.Input[str] row_filter: A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        :param pulumi.Input[float] sampling_percent: The percentage of the records to be selected from the dataset for DataScan.
               Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
               Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        if exclude_fields is not None:
            pulumi.set(__self__, "exclude_fields", exclude_fields)
        if include_fields is not None:
            pulumi.set(__self__, "include_fields", include_fields)
        if post_scan_actions is not None:
            pulumi.set(__self__, "post_scan_actions", post_scan_actions)
        if row_filter is not None:
            pulumi.set(__self__, "row_filter", row_filter)
        if sampling_percent is not None:
            pulumi.set(__self__, "sampling_percent", sampling_percent)

    @property
    @pulumi.getter(name="excludeFields")
    def exclude_fields(self) -> Optional[pulumi.Input['DatascanDataProfileSpecExcludeFieldsArgs']]:
        """
        The fields to exclude from data profile.
        If specified, the fields will be excluded from data profile, regardless of `include_fields` value.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_fields")

    @exclude_fields.setter
    def exclude_fields(self, value: Optional[pulumi.Input['DatascanDataProfileSpecExcludeFieldsArgs']]):
        pulumi.set(self, "exclude_fields", value)

    @property
    @pulumi.getter(name="includeFields")
    def include_fields(self) -> Optional[pulumi.Input['DatascanDataProfileSpecIncludeFieldsArgs']]:
        """
        The fields to include in data profile.
        If not specified, all fields at the time of profile scan job execution are included, except for ones listed in `exclude_fields`.
        Structure is documented below.
        """
        return pulumi.get(self, "include_fields")

    @include_fields.setter
    def include_fields(self, value: Optional[pulumi.Input['DatascanDataProfileSpecIncludeFieldsArgs']]):
        pulumi.set(self, "include_fields", value)

    @property
    @pulumi.getter(name="postScanActions")
    def post_scan_actions(self) -> Optional[pulumi.Input['DatascanDataProfileSpecPostScanActionsArgs']]:
        """
        Actions to take upon job completion.
        Structure is documented below.
        """
        return pulumi.get(self, "post_scan_actions")

    @post_scan_actions.setter
    def post_scan_actions(self, value: Optional[pulumi.Input['DatascanDataProfileSpecPostScanActionsArgs']]):
        pulumi.set(self, "post_scan_actions", value)

    @property
    @pulumi.getter(name="rowFilter")
    def row_filter(self) -> Optional[pulumi.Input[str]]:
        """
        A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        """
        return pulumi.get(self, "row_filter")

    @row_filter.setter
    def row_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "row_filter", value)

    @property
    @pulumi.getter(name="samplingPercent")
    def sampling_percent(self) -> Optional[pulumi.Input[float]]:
        """
        The percentage of the records to be selected from the dataset for DataScan.
        Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
        Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        return pulumi.get(self, "sampling_percent")

    @sampling_percent.setter
    def sampling_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sampling_percent", value)


if not MYPY:
    class DatascanDataProfileSpecExcludeFieldsArgsDict(TypedDict):
        field_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Expected input is a list of fully qualified names of fields as in the schema.
        Only top-level field names for nested fields are supported.
        For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
elif False:
    DatascanDataProfileSpecExcludeFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataProfileSpecExcludeFieldsArgs:
    def __init__(__self__, *,
                 field_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] field_names: Expected input is a list of fully qualified names of fields as in the schema.
               Only top-level field names for nested fields are supported.
               For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Expected input is a list of fully qualified names of fields as in the schema.
        Only top-level field names for nested fields are supported.
        For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        return pulumi.get(self, "field_names")

    @field_names.setter
    def field_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "field_names", value)


if not MYPY:
    class DatascanDataProfileSpecIncludeFieldsArgsDict(TypedDict):
        field_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Expected input is a list of fully qualified names of fields as in the schema.
        Only top-level field names for nested fields are supported.
        For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
elif False:
    DatascanDataProfileSpecIncludeFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataProfileSpecIncludeFieldsArgs:
    def __init__(__self__, *,
                 field_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] field_names: Expected input is a list of fully qualified names of fields as in the schema.
               Only top-level field names for nested fields are supported.
               For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Expected input is a list of fully qualified names of fields as in the schema.
        Only top-level field names for nested fields are supported.
        For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        return pulumi.get(self, "field_names")

    @field_names.setter
    def field_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "field_names", value)


if not MYPY:
    class DatascanDataProfileSpecPostScanActionsArgsDict(TypedDict):
        bigquery_export: NotRequired[pulumi.Input['DatascanDataProfileSpecPostScanActionsBigqueryExportArgsDict']]
        """
        If set, results will be exported to the provided BigQuery table.
        Structure is documented below.
        """
elif False:
    DatascanDataProfileSpecPostScanActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataProfileSpecPostScanActionsArgs:
    def __init__(__self__, *,
                 bigquery_export: Optional[pulumi.Input['DatascanDataProfileSpecPostScanActionsBigqueryExportArgs']] = None):
        """
        :param pulumi.Input['DatascanDataProfileSpecPostScanActionsBigqueryExportArgs'] bigquery_export: If set, results will be exported to the provided BigQuery table.
               Structure is documented below.
        """
        if bigquery_export is not None:
            pulumi.set(__self__, "bigquery_export", bigquery_export)

    @property
    @pulumi.getter(name="bigqueryExport")
    def bigquery_export(self) -> Optional[pulumi.Input['DatascanDataProfileSpecPostScanActionsBigqueryExportArgs']]:
        """
        If set, results will be exported to the provided BigQuery table.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_export")

    @bigquery_export.setter
    def bigquery_export(self, value: Optional[pulumi.Input['DatascanDataProfileSpecPostScanActionsBigqueryExportArgs']]):
        pulumi.set(self, "bigquery_export", value)


if not MYPY:
    class DatascanDataProfileSpecPostScanActionsBigqueryExportArgsDict(TypedDict):
        results_table: NotRequired[pulumi.Input[str]]
        """
        The BigQuery table to export DataProfileScan results to.
        Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
elif False:
    DatascanDataProfileSpecPostScanActionsBigqueryExportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataProfileSpecPostScanActionsBigqueryExportArgs:
    def __init__(__self__, *,
                 results_table: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] results_table: The BigQuery table to export DataProfileScan results to.
               Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        if results_table is not None:
            pulumi.set(__self__, "results_table", results_table)

    @property
    @pulumi.getter(name="resultsTable")
    def results_table(self) -> Optional[pulumi.Input[str]]:
        """
        The BigQuery table to export DataProfileScan results to.
        Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        return pulumi.get(self, "results_table")

    @results_table.setter
    def results_table(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "results_table", value)


if not MYPY:
    class DatascanDataQualitySpecArgsDict(TypedDict):
        post_scan_actions: NotRequired[pulumi.Input['DatascanDataQualitySpecPostScanActionsArgsDict']]
        """
        Actions to take upon job completion.
        Structure is documented below.
        """
        row_filter: NotRequired[pulumi.Input[str]]
        """
        A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualitySpecRuleArgsDict']]]]
        """
        The list of rules to evaluate against a data source. At least one rule is required.
        Structure is documented below.
        """
        sampling_percent: NotRequired[pulumi.Input[float]]
        """
        The percentage of the records to be selected from the dataset for DataScan.
        Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
        Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
elif False:
    DatascanDataQualitySpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataQualitySpecArgs:
    def __init__(__self__, *,
                 post_scan_actions: Optional[pulumi.Input['DatascanDataQualitySpecPostScanActionsArgs']] = None,
                 row_filter: Optional[pulumi.Input[str]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualitySpecRuleArgs']]]] = None,
                 sampling_percent: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input['DatascanDataQualitySpecPostScanActionsArgs'] post_scan_actions: Actions to take upon job completion.
               Structure is documented below.
        :param pulumi.Input[str] row_filter: A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataQualitySpecRuleArgs']]] rules: The list of rules to evaluate against a data source. At least one rule is required.
               Structure is documented below.
        :param pulumi.Input[float] sampling_percent: The percentage of the records to be selected from the dataset for DataScan.
               Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
               Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        if post_scan_actions is not None:
            pulumi.set(__self__, "post_scan_actions", post_scan_actions)
        if row_filter is not None:
            pulumi.set(__self__, "row_filter", row_filter)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if sampling_percent is not None:
            pulumi.set(__self__, "sampling_percent", sampling_percent)

    @property
    @pulumi.getter(name="postScanActions")
    def post_scan_actions(self) -> Optional[pulumi.Input['DatascanDataQualitySpecPostScanActionsArgs']]:
        """
        Actions to take upon job completion.
        Structure is documented below.
        """
        return pulumi.get(self, "post_scan_actions")

    @post_scan_actions.setter
    def post_scan_actions(self, value: Optional[pulumi.Input['DatascanDataQualitySpecPostScanActionsArgs']]):
        pulumi.set(self, "post_scan_actions", value)

    @property
    @pulumi.getter(name="rowFilter")
    def row_filter(self) -> Optional[pulumi.Input[str]]:
        """
        A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        """
        return pulumi.get(self, "row_filter")

    @row_filter.setter
    def row_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "row_filter", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualitySpecRuleArgs']]]]:
        """
        The list of rules to evaluate against a data source. At least one rule is required.
        Structure is documented below.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualitySpecRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter(name="samplingPercent")
    def sampling_percent(self) -> Optional[pulumi.Input[float]]:
        """
        The percentage of the records to be selected from the dataset for DataScan.
        Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
        Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        return pulumi.get(self, "sampling_percent")

    @sampling_percent.setter
    def sampling_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sampling_percent", value)


if not MYPY:
    class DatascanDataQualitySpecPostScanActionsArgsDict(TypedDict):
        bigquery_export: NotRequired[pulumi.Input['DatascanDataQualitySpecPostScanActionsBigqueryExportArgsDict']]
        """
        If set, results will be exported to the provided BigQuery table.
        Structure is documented below.
        """
elif False:
    DatascanDataQualitySpecPostScanActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataQualitySpecPostScanActionsArgs:
    def __init__(__self__, *,
                 bigquery_export: Optional[pulumi.Input['DatascanDataQualitySpecPostScanActionsBigqueryExportArgs']] = None):
        """
        :param pulumi.Input['DatascanDataQualitySpecPostScanActionsBigqueryExportArgs'] bigquery_export: If set, results will be exported to the provided BigQuery table.
               Structure is documented below.
        """
        if bigquery_export is not None:
            pulumi.set(__self__, "bigquery_export", bigquery_export)

    @property
    @pulumi.getter(name="bigqueryExport")
    def bigquery_export(self) -> Optional[pulumi.Input['DatascanDataQualitySpecPostScanActionsBigqueryExportArgs']]:
        """
        If set, results will be exported to the provided BigQuery table.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_export")

    @bigquery_export.setter
    def bigquery_export(self, value: Optional[pulumi.Input['DatascanDataQualitySpecPostScanActionsBigqueryExportArgs']]):
        pulumi.set(self, "bigquery_export", value)


if not MYPY:
    class DatascanDataQualitySpecPostScanActionsBigqueryExportArgsDict(TypedDict):
        results_table: NotRequired[pulumi.Input[str]]
        """
        The BigQuery table to export DataProfileScan results to.
        Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
elif False:
    DatascanDataQualitySpecPostScanActionsBigqueryExportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataQualitySpecPostScanActionsBigqueryExportArgs:
    def __init__(__self__, *,
                 results_table: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] results_table: The BigQuery table to export DataProfileScan results to.
               Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        if results_table is not None:
            pulumi.set(__self__, "results_table", results_table)

    @property
    @pulumi.getter(name="resultsTable")
    def results_table(self) -> Optional[pulumi.Input[str]]:
        """
        The BigQuery table to export DataProfileScan results to.
        Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        return pulumi.get(self, "results_table")

    @results_table.setter
    def results_table(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "results_table", value)


if not MYPY:
    class DatascanDataQualitySpecRuleArgsDict(TypedDict):
        dimension: pulumi.Input[str]
        """
        The dimension a rule belongs to. Results are also aggregated at the dimension level. Supported dimensions are ["COMPLETENESS", "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "INTEGRITY"]
        """
        column: NotRequired[pulumi.Input[str]]
        """
        The unnested column which this rule is evaluated against.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the rule.
        The maximum length is 1,024 characters.
        """
        ignore_null: NotRequired[pulumi.Input[bool]]
        """
        Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A mutable name for the rule.
        The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
        The maximum length is 63 characters.
        Must start with a letter.
        Must end with a number or a letter.
        """
        non_null_expectation: NotRequired[pulumi.Input['DatascanDataQualitySpecRuleNonNullExpectationArgsDict']]
        """
        ColumnMap rule which evaluates whether each column value is null.
        """
        range_expectation: NotRequired[pulumi.Input['DatascanDataQualitySpecRuleRangeExpectationArgsDict']]
        """
        ColumnMap rule which evaluates whether each column value lies between a specified range.
        Structure is documented below.
        """
        regex_expectation: NotRequired[pulumi.Input['DatascanDataQualitySpecRuleRegexExpectationArgsDict']]
        """
        ColumnMap rule which evaluates whether each column value matches a specified regex.
        Structure is documented below.
        """
        row_condition_expectation: NotRequired[pulumi.Input['DatascanDataQualitySpecRuleRowConditionExpectationArgsDict']]
        """
        Table rule which evaluates whether each row passes the specified condition.
        Structure is documented below.
        """
        set_expectation: NotRequired[pulumi.Input['DatascanDataQualitySpecRuleSetExpectationArgsDict']]
        """
        ColumnMap rule which evaluates whether each column value is contained by a specified set.
        Structure is documented below.
        """
        statistic_range_expectation: NotRequired[pulumi.Input['DatascanDataQualitySpecRuleStatisticRangeExpectationArgsDict']]
        """
        ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
        Structure is documented below.
        """
        table_condition_expectation: NotRequired[pulumi.Input['DatascanDataQualitySpecRuleTableConditionExpectationArgsDict']]
        """
        Table rule which evaluates whether the provided expression is true.
        Structure is documented below.
        """
        threshold: NotRequired[pulumi.Input[float]]
        """
        The minimum ratio of passing_rows / total_rows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0).
        """
        uniqueness_expectation: NotRequired[pulumi.Input['DatascanDataQualitySpecRuleUniquenessExpectationArgsDict']]
        """
        Row-level rule which evaluates whether each column value is unique.
        """
elif False:
    DatascanDataQualitySpecRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataQualitySpecRuleArgs:
    def __init__(__self__, *,
                 dimension: pulumi.Input[str],
                 column: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ignore_null: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 non_null_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleNonNullExpectationArgs']] = None,
                 range_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleRangeExpectationArgs']] = None,
                 regex_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleRegexExpectationArgs']] = None,
                 row_condition_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleRowConditionExpectationArgs']] = None,
                 set_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleSetExpectationArgs']] = None,
                 statistic_range_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleStatisticRangeExpectationArgs']] = None,
                 table_condition_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleTableConditionExpectationArgs']] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 uniqueness_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleUniquenessExpectationArgs']] = None):
        """
        :param pulumi.Input[str] dimension: The dimension a rule belongs to. Results are also aggregated at the dimension level. Supported dimensions are ["COMPLETENESS", "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "INTEGRITY"]
        :param pulumi.Input[str] column: The unnested column which this rule is evaluated against.
        :param pulumi.Input[str] description: Description of the rule.
               The maximum length is 1,024 characters.
        :param pulumi.Input[bool] ignore_null: Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
        :param pulumi.Input[str] name: A mutable name for the rule.
               The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
               The maximum length is 63 characters.
               Must start with a letter.
               Must end with a number or a letter.
        :param pulumi.Input['DatascanDataQualitySpecRuleNonNullExpectationArgs'] non_null_expectation: ColumnMap rule which evaluates whether each column value is null.
        :param pulumi.Input['DatascanDataQualitySpecRuleRangeExpectationArgs'] range_expectation: ColumnMap rule which evaluates whether each column value lies between a specified range.
               Structure is documented below.
        :param pulumi.Input['DatascanDataQualitySpecRuleRegexExpectationArgs'] regex_expectation: ColumnMap rule which evaluates whether each column value matches a specified regex.
               Structure is documented below.
        :param pulumi.Input['DatascanDataQualitySpecRuleRowConditionExpectationArgs'] row_condition_expectation: Table rule which evaluates whether each row passes the specified condition.
               Structure is documented below.
        :param pulumi.Input['DatascanDataQualitySpecRuleSetExpectationArgs'] set_expectation: ColumnMap rule which evaluates whether each column value is contained by a specified set.
               Structure is documented below.
        :param pulumi.Input['DatascanDataQualitySpecRuleStatisticRangeExpectationArgs'] statistic_range_expectation: ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
               Structure is documented below.
        :param pulumi.Input['DatascanDataQualitySpecRuleTableConditionExpectationArgs'] table_condition_expectation: Table rule which evaluates whether the provided expression is true.
               Structure is documented below.
        :param pulumi.Input[float] threshold: The minimum ratio of passing_rows / total_rows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0).
        :param pulumi.Input['DatascanDataQualitySpecRuleUniquenessExpectationArgs'] uniqueness_expectation: Row-level rule which evaluates whether each column value is unique.
        """
        pulumi.set(__self__, "dimension", dimension)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ignore_null is not None:
            pulumi.set(__self__, "ignore_null", ignore_null)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if non_null_expectation is not None:
            pulumi.set(__self__, "non_null_expectation", non_null_expectation)
        if range_expectation is not None:
            pulumi.set(__self__, "range_expectation", range_expectation)
        if regex_expectation is not None:
            pulumi.set(__self__, "regex_expectation", regex_expectation)
        if row_condition_expectation is not None:
            pulumi.set(__self__, "row_condition_expectation", row_condition_expectation)
        if set_expectation is not None:
            pulumi.set(__self__, "set_expectation", set_expectation)
        if statistic_range_expectation is not None:
            pulumi.set(__self__, "statistic_range_expectation", statistic_range_expectation)
        if table_condition_expectation is not None:
            pulumi.set(__self__, "table_condition_expectation", table_condition_expectation)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if uniqueness_expectation is not None:
            pulumi.set(__self__, "uniqueness_expectation", uniqueness_expectation)

    @property
    @pulumi.getter
    def dimension(self) -> pulumi.Input[str]:
        """
        The dimension a rule belongs to. Results are also aggregated at the dimension level. Supported dimensions are ["COMPLETENESS", "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "INTEGRITY"]
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: pulumi.Input[str]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        The unnested column which this rule is evaluated against.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the rule.
        The maximum length is 1,024 characters.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="ignoreNull")
    def ignore_null(self) -> Optional[pulumi.Input[bool]]:
        """
        Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
        """
        return pulumi.get(self, "ignore_null")

    @ignore_null.setter
    def ignore_null(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_null", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A mutable name for the rule.
        The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
        The maximum length is 63 characters.
        Must start with a letter.
        Must end with a number or a letter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nonNullExpectation")
    def non_null_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleNonNullExpectationArgs']]:
        """
        ColumnMap rule which evaluates whether each column value is null.
        """
        return pulumi.get(self, "non_null_expectation")

    @non_null_expectation.setter
    def non_null_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleNonNullExpectationArgs']]):
        pulumi.set(self, "non_null_expectation", value)

    @property
    @pulumi.getter(name="rangeExpectation")
    def range_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleRangeExpectationArgs']]:
        """
        ColumnMap rule which evaluates whether each column value lies between a specified range.
        Structure is documented below.
        """
        return pulumi.get(self, "range_expectation")

    @range_expectation.setter
    def range_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleRangeExpectationArgs']]):
        pulumi.set(self, "range_expectation", value)

    @property
    @pulumi.getter(name="regexExpectation")
    def regex_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleRegexExpectationArgs']]:
        """
        ColumnMap rule which evaluates whether each column value matches a specified regex.
        Structure is documented below.
        """
        return pulumi.get(self, "regex_expectation")

    @regex_expectation.setter
    def regex_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleRegexExpectationArgs']]):
        pulumi.set(self, "regex_expectation", value)

    @property
    @pulumi.getter(name="rowConditionExpectation")
    def row_condition_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleRowConditionExpectationArgs']]:
        """
        Table rule which evaluates whether each row passes the specified condition.
        Structure is documented below.
        """
        return pulumi.get(self, "row_condition_expectation")

    @row_condition_expectation.setter
    def row_condition_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleRowConditionExpectationArgs']]):
        pulumi.set(self, "row_condition_expectation", value)

    @property
    @pulumi.getter(name="setExpectation")
    def set_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleSetExpectationArgs']]:
        """
        ColumnMap rule which evaluates whether each column value is contained by a specified set.
        Structure is documented below.
        """
        return pulumi.get(self, "set_expectation")

    @set_expectation.setter
    def set_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleSetExpectationArgs']]):
        pulumi.set(self, "set_expectation", value)

    @property
    @pulumi.getter(name="statisticRangeExpectation")
    def statistic_range_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleStatisticRangeExpectationArgs']]:
        """
        ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
        Structure is documented below.
        """
        return pulumi.get(self, "statistic_range_expectation")

    @statistic_range_expectation.setter
    def statistic_range_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleStatisticRangeExpectationArgs']]):
        pulumi.set(self, "statistic_range_expectation", value)

    @property
    @pulumi.getter(name="tableConditionExpectation")
    def table_condition_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleTableConditionExpectationArgs']]:
        """
        Table rule which evaluates whether the provided expression is true.
        Structure is documented below.
        """
        return pulumi.get(self, "table_condition_expectation")

    @table_condition_expectation.setter
    def table_condition_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleTableConditionExpectationArgs']]):
        pulumi.set(self, "table_condition_expectation", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The minimum ratio of passing_rows / total_rows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0).
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="uniquenessExpectation")
    def uniqueness_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleUniquenessExpectationArgs']]:
        """
        Row-level rule which evaluates whether each column value is unique.
        """
        return pulumi.get(self, "uniqueness_expectation")

    @uniqueness_expectation.setter
    def uniqueness_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleUniquenessExpectationArgs']]):
        pulumi.set(self, "uniqueness_expectation", value)


if not MYPY:
    class DatascanDataQualitySpecRuleNonNullExpectationArgsDict(TypedDict):
        pass
elif False:
    DatascanDataQualitySpecRuleNonNullExpectationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataQualitySpecRuleNonNullExpectationArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatascanDataQualitySpecRuleRangeExpectationArgsDict(TypedDict):
        max_value: NotRequired[pulumi.Input[str]]
        """
        The maximum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        """
        min_value: NotRequired[pulumi.Input[str]]
        """
        The minimum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        """
        strict_max_enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        Only relevant if a maxValue has been defined. Default = false.
        """
        strict_min_enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        Only relevant if a minValue has been defined. Default = false.
        """
elif False:
    DatascanDataQualitySpecRuleRangeExpectationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataQualitySpecRuleRangeExpectationArgs:
    def __init__(__self__, *,
                 max_value: Optional[pulumi.Input[str]] = None,
                 min_value: Optional[pulumi.Input[str]] = None,
                 strict_max_enabled: Optional[pulumi.Input[bool]] = None,
                 strict_min_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] max_value: The maximum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        :param pulumi.Input[str] min_value: The minimum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        :param pulumi.Input[bool] strict_max_enabled: Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
               Only relevant if a maxValue has been defined. Default = false.
        :param pulumi.Input[bool] strict_min_enabled: Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
               Only relevant if a minValue has been defined. Default = false.
        """
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if strict_max_enabled is not None:
            pulumi.set(__self__, "strict_max_enabled", strict_max_enabled)
        if strict_min_enabled is not None:
            pulumi.set(__self__, "strict_min_enabled", strict_min_enabled)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_value", value)

    @property
    @pulumi.getter(name="strictMaxEnabled")
    def strict_max_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        Only relevant if a maxValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_max_enabled")

    @strict_max_enabled.setter
    def strict_max_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_max_enabled", value)

    @property
    @pulumi.getter(name="strictMinEnabled")
    def strict_min_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        Only relevant if a minValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_min_enabled")

    @strict_min_enabled.setter
    def strict_min_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_min_enabled", value)


if not MYPY:
    class DatascanDataQualitySpecRuleRegexExpectationArgsDict(TypedDict):
        regex: pulumi.Input[str]
        """
        A regular expression the column value is expected to match.
        """
elif False:
    DatascanDataQualitySpecRuleRegexExpectationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataQualitySpecRuleRegexExpectationArgs:
    def __init__(__self__, *,
                 regex: pulumi.Input[str]):
        """
        :param pulumi.Input[str] regex: A regular expression the column value is expected to match.
        """
        pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def regex(self) -> pulumi.Input[str]:
        """
        A regular expression the column value is expected to match.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class DatascanDataQualitySpecRuleRowConditionExpectationArgsDict(TypedDict):
        sql_expression: pulumi.Input[str]
        """
        The SQL expression.
        """
elif False:
    DatascanDataQualitySpecRuleRowConditionExpectationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataQualitySpecRuleRowConditionExpectationArgs:
    def __init__(__self__, *,
                 sql_expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] sql_expression: The SQL expression.
        """
        pulumi.set(__self__, "sql_expression", sql_expression)

    @property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> pulumi.Input[str]:
        """
        The SQL expression.
        """
        return pulumi.get(self, "sql_expression")

    @sql_expression.setter
    def sql_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "sql_expression", value)


if not MYPY:
    class DatascanDataQualitySpecRuleSetExpectationArgsDict(TypedDict):
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Expected values for the column value.
        """
elif False:
    DatascanDataQualitySpecRuleSetExpectationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataQualitySpecRuleSetExpectationArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Expected values for the column value.
        """
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Expected values for the column value.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DatascanDataQualitySpecRuleStatisticRangeExpectationArgsDict(TypedDict):
        statistic: pulumi.Input[str]
        """
        column statistics.
        Possible values are: `STATISTIC_UNDEFINED`, `MEAN`, `MIN`, `MAX`.
        """
        max_value: NotRequired[pulumi.Input[str]]
        """
        The maximum column statistic value allowed for a row to pass this validation.
        At least one of minValue and maxValue need to be provided.
        """
        min_value: NotRequired[pulumi.Input[str]]
        """
        The minimum column statistic value allowed for a row to pass this validation.
        At least one of minValue and maxValue need to be provided.
        """
        strict_max_enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether column statistic needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        Only relevant if a maxValue has been defined. Default = false.
        """
        strict_min_enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether column statistic needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        Only relevant if a minValue has been defined. Default = false.
        """
elif False:
    DatascanDataQualitySpecRuleStatisticRangeExpectationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataQualitySpecRuleStatisticRangeExpectationArgs:
    def __init__(__self__, *,
                 statistic: pulumi.Input[str],
                 max_value: Optional[pulumi.Input[str]] = None,
                 min_value: Optional[pulumi.Input[str]] = None,
                 strict_max_enabled: Optional[pulumi.Input[bool]] = None,
                 strict_min_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] statistic: column statistics.
               Possible values are: `STATISTIC_UNDEFINED`, `MEAN`, `MIN`, `MAX`.
        :param pulumi.Input[str] max_value: The maximum column statistic value allowed for a row to pass this validation.
               At least one of minValue and maxValue need to be provided.
        :param pulumi.Input[str] min_value: The minimum column statistic value allowed for a row to pass this validation.
               At least one of minValue and maxValue need to be provided.
        :param pulumi.Input[bool] strict_max_enabled: Whether column statistic needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
               Only relevant if a maxValue has been defined. Default = false.
        :param pulumi.Input[bool] strict_min_enabled: Whether column statistic needs to be strictly greater than ('>') the minimum, or if equality is allowed.
               Only relevant if a minValue has been defined. Default = false.
        """
        pulumi.set(__self__, "statistic", statistic)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if strict_max_enabled is not None:
            pulumi.set(__self__, "strict_max_enabled", strict_max_enabled)
        if strict_min_enabled is not None:
            pulumi.set(__self__, "strict_min_enabled", strict_min_enabled)

    @property
    @pulumi.getter
    def statistic(self) -> pulumi.Input[str]:
        """
        column statistics.
        Possible values are: `STATISTIC_UNDEFINED`, `MEAN`, `MIN`, `MAX`.
        """
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: pulumi.Input[str]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum column statistic value allowed for a row to pass this validation.
        At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum column statistic value allowed for a row to pass this validation.
        At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_value", value)

    @property
    @pulumi.getter(name="strictMaxEnabled")
    def strict_max_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether column statistic needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        Only relevant if a maxValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_max_enabled")

    @strict_max_enabled.setter
    def strict_max_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_max_enabled", value)

    @property
    @pulumi.getter(name="strictMinEnabled")
    def strict_min_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether column statistic needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        Only relevant if a minValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_min_enabled")

    @strict_min_enabled.setter
    def strict_min_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_min_enabled", value)


if not MYPY:
    class DatascanDataQualitySpecRuleTableConditionExpectationArgsDict(TypedDict):
        sql_expression: pulumi.Input[str]
        """
        The SQL expression.
        """
elif False:
    DatascanDataQualitySpecRuleTableConditionExpectationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataQualitySpecRuleTableConditionExpectationArgs:
    def __init__(__self__, *,
                 sql_expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] sql_expression: The SQL expression.
        """
        pulumi.set(__self__, "sql_expression", sql_expression)

    @property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> pulumi.Input[str]:
        """
        The SQL expression.
        """
        return pulumi.get(self, "sql_expression")

    @sql_expression.setter
    def sql_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "sql_expression", value)


if not MYPY:
    class DatascanDataQualitySpecRuleUniquenessExpectationArgsDict(TypedDict):
        pass
elif False:
    DatascanDataQualitySpecRuleUniquenessExpectationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanDataQualitySpecRuleUniquenessExpectationArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatascanExecutionSpecArgsDict(TypedDict):
        trigger: pulumi.Input['DatascanExecutionSpecTriggerArgsDict']
        """
        Spec related to how often and when a scan should be triggered.
        Structure is documented below.
        """
        field: NotRequired[pulumi.Input[str]]
        """
        The unnested field (of type Date or Timestamp) that contains values which monotonically increase over time. If not specified, a data scan will run for all data in the table.
        """
elif False:
    DatascanExecutionSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanExecutionSpecArgs:
    def __init__(__self__, *,
                 trigger: pulumi.Input['DatascanExecutionSpecTriggerArgs'],
                 field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DatascanExecutionSpecTriggerArgs'] trigger: Spec related to how often and when a scan should be triggered.
               Structure is documented below.
        :param pulumi.Input[str] field: The unnested field (of type Date or Timestamp) that contains values which monotonically increase over time. If not specified, a data scan will run for all data in the table.
        """
        pulumi.set(__self__, "trigger", trigger)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @property
    @pulumi.getter
    def trigger(self) -> pulumi.Input['DatascanExecutionSpecTriggerArgs']:
        """
        Spec related to how often and when a scan should be triggered.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: pulumi.Input['DatascanExecutionSpecTriggerArgs']):
        pulumi.set(self, "trigger", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        The unnested field (of type Date or Timestamp) that contains values which monotonically increase over time. If not specified, a data scan will run for all data in the table.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)


if not MYPY:
    class DatascanExecutionSpecTriggerArgsDict(TypedDict):
        on_demand: NotRequired[pulumi.Input['DatascanExecutionSpecTriggerOnDemandArgsDict']]
        """
        The scan runs once via dataScans.run API.
        """
        schedule: NotRequired[pulumi.Input['DatascanExecutionSpecTriggerScheduleArgsDict']]
        """
        The scan is scheduled to run periodically.
        Structure is documented below.
        """
elif False:
    DatascanExecutionSpecTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanExecutionSpecTriggerArgs:
    def __init__(__self__, *,
                 on_demand: Optional[pulumi.Input['DatascanExecutionSpecTriggerOnDemandArgs']] = None,
                 schedule: Optional[pulumi.Input['DatascanExecutionSpecTriggerScheduleArgs']] = None):
        """
        :param pulumi.Input['DatascanExecutionSpecTriggerOnDemandArgs'] on_demand: The scan runs once via dataScans.run API.
        :param pulumi.Input['DatascanExecutionSpecTriggerScheduleArgs'] schedule: The scan is scheduled to run periodically.
               Structure is documented below.
        """
        if on_demand is not None:
            pulumi.set(__self__, "on_demand", on_demand)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter(name="onDemand")
    def on_demand(self) -> Optional[pulumi.Input['DatascanExecutionSpecTriggerOnDemandArgs']]:
        """
        The scan runs once via dataScans.run API.
        """
        return pulumi.get(self, "on_demand")

    @on_demand.setter
    def on_demand(self, value: Optional[pulumi.Input['DatascanExecutionSpecTriggerOnDemandArgs']]):
        pulumi.set(self, "on_demand", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['DatascanExecutionSpecTriggerScheduleArgs']]:
        """
        The scan is scheduled to run periodically.
        Structure is documented below.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['DatascanExecutionSpecTriggerScheduleArgs']]):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class DatascanExecutionSpecTriggerOnDemandArgsDict(TypedDict):
        pass
elif False:
    DatascanExecutionSpecTriggerOnDemandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanExecutionSpecTriggerOnDemandArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatascanExecutionSpecTriggerScheduleArgsDict(TypedDict):
        cron: pulumi.Input[str]
        """
        Cron schedule for running scans periodically. This field is required for Schedule scans.

        - - -
        """
elif False:
    DatascanExecutionSpecTriggerScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanExecutionSpecTriggerScheduleArgs:
    def __init__(__self__, *,
                 cron: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cron: Cron schedule for running scans periodically. This field is required for Schedule scans.
               
               - - -
        """
        pulumi.set(__self__, "cron", cron)

    @property
    @pulumi.getter
    def cron(self) -> pulumi.Input[str]:
        """
        Cron schedule for running scans periodically. This field is required for Schedule scans.

        - - -
        """
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron", value)


if not MYPY:
    class DatascanExecutionStatusArgsDict(TypedDict):
        latest_job_end_time: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The time when the latest DataScanJob started.
        """
        latest_job_start_time: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The time when the latest DataScanJob ended.
        """
elif False:
    DatascanExecutionStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanExecutionStatusArgs:
    def __init__(__self__, *,
                 latest_job_end_time: Optional[pulumi.Input[str]] = None,
                 latest_job_start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] latest_job_end_time: (Output)
               The time when the latest DataScanJob started.
        :param pulumi.Input[str] latest_job_start_time: (Output)
               The time when the latest DataScanJob ended.
        """
        if latest_job_end_time is not None:
            pulumi.set(__self__, "latest_job_end_time", latest_job_end_time)
        if latest_job_start_time is not None:
            pulumi.set(__self__, "latest_job_start_time", latest_job_start_time)

    @property
    @pulumi.getter(name="latestJobEndTime")
    def latest_job_end_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The time when the latest DataScanJob started.
        """
        return pulumi.get(self, "latest_job_end_time")

    @latest_job_end_time.setter
    def latest_job_end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "latest_job_end_time", value)

    @property
    @pulumi.getter(name="latestJobStartTime")
    def latest_job_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The time when the latest DataScanJob ended.
        """
        return pulumi.get(self, "latest_job_start_time")

    @latest_job_start_time.setter
    def latest_job_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "latest_job_start_time", value)


if not MYPY:
    class DatascanIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    DatascanIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class DatascanIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    DatascanIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatascanIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class EntryGroupIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    EntryGroupIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntryGroupIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class EntryGroupIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    EntryGroupIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntryGroupIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class EntryTypeIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    EntryTypeIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntryTypeIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class EntryTypeIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    EntryTypeIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntryTypeIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class EntryTypeRequiredAspectArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        Required aspect type for the entry type.
        """
elif False:
    EntryTypeRequiredAspectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntryTypeRequiredAspectArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Required aspect type for the entry type.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Required aspect type for the entry type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LakeAssetStatusArgsDict(TypedDict):
        active_assets: NotRequired[pulumi.Input[int]]
        """
        Number of active assets.
        """
        security_policy_applying_assets: NotRequired[pulumi.Input[int]]
        """
        Number of assets that are in process of updating the security policy on attached resources.
        """
        update_time: NotRequired[pulumi.Input[str]]
        """
        Output only. The time when the lake was last updated.
        """
elif False:
    LakeAssetStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LakeAssetStatusArgs:
    def __init__(__self__, *,
                 active_assets: Optional[pulumi.Input[int]] = None,
                 security_policy_applying_assets: Optional[pulumi.Input[int]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] active_assets: Number of active assets.
        :param pulumi.Input[int] security_policy_applying_assets: Number of assets that are in process of updating the security policy on attached resources.
        :param pulumi.Input[str] update_time: Output only. The time when the lake was last updated.
        """
        if active_assets is not None:
            pulumi.set(__self__, "active_assets", active_assets)
        if security_policy_applying_assets is not None:
            pulumi.set(__self__, "security_policy_applying_assets", security_policy_applying_assets)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="activeAssets")
    def active_assets(self) -> Optional[pulumi.Input[int]]:
        """
        Number of active assets.
        """
        return pulumi.get(self, "active_assets")

    @active_assets.setter
    def active_assets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "active_assets", value)

    @property
    @pulumi.getter(name="securityPolicyApplyingAssets")
    def security_policy_applying_assets(self) -> Optional[pulumi.Input[int]]:
        """
        Number of assets that are in process of updating the security policy on attached resources.
        """
        return pulumi.get(self, "security_policy_applying_assets")

    @security_policy_applying_assets.setter
    def security_policy_applying_assets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "security_policy_applying_assets", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. The time when the lake was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class LakeIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    LakeIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LakeIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class LakeIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    LakeIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LakeIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class LakeMetastoreArgsDict(TypedDict):
        service: NotRequired[pulumi.Input[str]]
        """
        Optional. A relative reference to the Dataproc Metastore (https://cloud.google.com/dataproc-metastore/docs) service associated with the lake: `projects/{project_id}/locations/{location_id}/services/{service_id}`
        """
elif False:
    LakeMetastoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LakeMetastoreArgs:
    def __init__(__self__, *,
                 service: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service: Optional. A relative reference to the Dataproc Metastore (https://cloud.google.com/dataproc-metastore/docs) service associated with the lake: `projects/{project_id}/locations/{location_id}/services/{service_id}`
        """
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. A relative reference to the Dataproc Metastore (https://cloud.google.com/dataproc-metastore/docs) service associated with the lake: `projects/{project_id}/locations/{location_id}/services/{service_id}`
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class LakeMetastoreStatusArgsDict(TypedDict):
        endpoint: NotRequired[pulumi.Input[str]]
        """
        The URI of the endpoint used to access the Metastore service.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Additional information about the current status.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        Output only. Current state of the lake. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        update_time: NotRequired[pulumi.Input[str]]
        """
        Output only. The time when the lake was last updated.
        """
elif False:
    LakeMetastoreStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LakeMetastoreStatusArgs:
    def __init__(__self__, *,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] endpoint: The URI of the endpoint used to access the Metastore service.
        :param pulumi.Input[str] message: Additional information about the current status.
        :param pulumi.Input[str] state: Output only. Current state of the lake. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param pulumi.Input[str] update_time: Output only. The time when the lake was last updated.
        """
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The URI of the endpoint used to access the Metastore service.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current status.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. Current state of the lake. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. The time when the lake was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class TaskExecutionSpecArgsDict(TypedDict):
        service_account: pulumi.Input[str]
        """
        Service account to use to execute a task. If not provided, the default Compute service account for the project is used.
        """
        args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The arguments to pass to the task. The args can use placeholders of the format ${placeholder} as part of key/value string. These will be interpolated before passing the args to the driver. Currently supported placeholders: - ${taskId} - ${job_time} To pass positional args, set the key as TASK_ARGS. The value should be a comma-separated string of all the positional arguments. To use a delimiter other than comma, refer to https://cloud.google.com/sdk/gcloud/reference/topic/escaping. In case of other keys being present in the args, then TASK_ARGS will be passed as the last argument. An object containing a list of 'key': value pairs. Example: { 'name': 'wrench', 'mass': '1.3kg', 'count': '3' }.
        """
        kms_key: NotRequired[pulumi.Input[str]]
        """
        The Cloud KMS key to use for encryption, of the form: projects/{project_number}/locations/{locationId}/keyRings/{key-ring-name}/cryptoKeys/{key-name}.

        - - -
        """
        max_job_execution_lifetime: NotRequired[pulumi.Input[str]]
        """
        The maximum duration after which the job execution is expired. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'.
        """
        project: NotRequired[pulumi.Input[str]]
        """
        The ID of the project in which the resource belongs.
        If it is not provided, the provider project is used.
        """
elif False:
    TaskExecutionSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskExecutionSpecArgs:
    def __init__(__self__, *,
                 service_account: pulumi.Input[str],
                 args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 max_job_execution_lifetime: Optional[pulumi.Input[str]] = None,
                 project: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_account: Service account to use to execute a task. If not provided, the default Compute service account for the project is used.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] args: The arguments to pass to the task. The args can use placeholders of the format ${placeholder} as part of key/value string. These will be interpolated before passing the args to the driver. Currently supported placeholders: - ${taskId} - ${job_time} To pass positional args, set the key as TASK_ARGS. The value should be a comma-separated string of all the positional arguments. To use a delimiter other than comma, refer to https://cloud.google.com/sdk/gcloud/reference/topic/escaping. In case of other keys being present in the args, then TASK_ARGS will be passed as the last argument. An object containing a list of 'key': value pairs. Example: { 'name': 'wrench', 'mass': '1.3kg', 'count': '3' }.
        :param pulumi.Input[str] kms_key: The Cloud KMS key to use for encryption, of the form: projects/{project_number}/locations/{locationId}/keyRings/{key-ring-name}/cryptoKeys/{key-name}.
               
               - - -
        :param pulumi.Input[str] max_job_execution_lifetime: The maximum duration after which the job execution is expired. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'.
        :param pulumi.Input[str] project: The ID of the project in which the resource belongs.
               If it is not provided, the provider project is used.
        """
        pulumi.set(__self__, "service_account", service_account)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if max_job_execution_lifetime is not None:
            pulumi.set(__self__, "max_job_execution_lifetime", max_job_execution_lifetime)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> pulumi.Input[str]:
        """
        Service account to use to execute a task. If not provided, the default Compute service account for the project is used.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The arguments to pass to the task. The args can use placeholders of the format ${placeholder} as part of key/value string. These will be interpolated before passing the args to the driver. Currently supported placeholders: - ${taskId} - ${job_time} To pass positional args, set the key as TASK_ARGS. The value should be a comma-separated string of all the positional arguments. To use a delimiter other than comma, refer to https://cloud.google.com/sdk/gcloud/reference/topic/escaping. In case of other keys being present in the args, then TASK_ARGS will be passed as the last argument. An object containing a list of 'key': value pairs. Example: { 'name': 'wrench', 'mass': '1.3kg', 'count': '3' }.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloud KMS key to use for encryption, of the form: projects/{project_number}/locations/{locationId}/keyRings/{key-ring-name}/cryptoKeys/{key-name}.

        - - -
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter(name="maxJobExecutionLifetime")
    def max_job_execution_lifetime(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum duration after which the job execution is expired. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'.
        """
        return pulumi.get(self, "max_job_execution_lifetime")

    @max_job_execution_lifetime.setter
    def max_job_execution_lifetime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_job_execution_lifetime", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the project in which the resource belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project", value)


if not MYPY:
    class TaskExecutionStatusArgsDict(TypedDict):
        latest_jobs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskExecutionStatusLatestJobArgsDict']]]]
        """
        (Output)
        latest job execution.
        Structure is documented below.
        """
        update_time: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Last update time of the status.
        """
elif False:
    TaskExecutionStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskExecutionStatusArgs:
    def __init__(__self__, *,
                 latest_jobs: Optional[pulumi.Input[Sequence[pulumi.Input['TaskExecutionStatusLatestJobArgs']]]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TaskExecutionStatusLatestJobArgs']]] latest_jobs: (Output)
               latest job execution.
               Structure is documented below.
        :param pulumi.Input[str] update_time: (Output)
               Last update time of the status.
        """
        if latest_jobs is not None:
            pulumi.set(__self__, "latest_jobs", latest_jobs)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="latestJobs")
    def latest_jobs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskExecutionStatusLatestJobArgs']]]]:
        """
        (Output)
        latest job execution.
        Structure is documented below.
        """
        return pulumi.get(self, "latest_jobs")

    @latest_jobs.setter
    def latest_jobs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskExecutionStatusLatestJobArgs']]]]):
        pulumi.set(self, "latest_jobs", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Last update time of the status.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class TaskExecutionStatusLatestJobArgsDict(TypedDict):
        end_time: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The time when the job ended.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Additional information about the current state.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The relative resource name of the job, of the form: projects/{project_number}/locations/{locationId}/lakes/{lakeId}/tasks/{taskId}/jobs/{jobId}.
        """
        retry_count: NotRequired[pulumi.Input[int]]
        """
        (Output)
        The number of times the job has been retried (excluding the initial attempt).
        """
        service: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The underlying service running a job.
        """
        service_job: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The full resource name for the job run under a particular service.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The time when the job was started.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Execution state for the job.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        (Output)
        System generated globally unique ID for the job.
        """
elif False:
    TaskExecutionStatusLatestJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskExecutionStatusLatestJobArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 retry_count: Optional[pulumi.Input[int]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 service_job: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] end_time: (Output)
               The time when the job ended.
        :param pulumi.Input[str] message: (Output)
               Additional information about the current state.
        :param pulumi.Input[str] name: (Output)
               The relative resource name of the job, of the form: projects/{project_number}/locations/{locationId}/lakes/{lakeId}/tasks/{taskId}/jobs/{jobId}.
        :param pulumi.Input[int] retry_count: (Output)
               The number of times the job has been retried (excluding the initial attempt).
        :param pulumi.Input[str] service: (Output)
               The underlying service running a job.
        :param pulumi.Input[str] service_job: (Output)
               The full resource name for the job run under a particular service.
        :param pulumi.Input[str] start_time: (Output)
               The time when the job was started.
        :param pulumi.Input[str] state: (Output)
               Execution state for the job.
        :param pulumi.Input[str] uid: (Output)
               System generated globally unique ID for the job.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if service_job is not None:
            pulumi.set(__self__, "service_job", service_job)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The time when the job ended.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Additional information about the current state.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The relative resource name of the job, of the form: projects/{project_number}/locations/{locationId}/lakes/{lakeId}/tasks/{taskId}/jobs/{jobId}.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        The number of times the job has been retried (excluding the initial attempt).
        """
        return pulumi.get(self, "retry_count")

    @retry_count.setter
    def retry_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retry_count", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The underlying service running a job.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="serviceJob")
    def service_job(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The full resource name for the job run under a particular service.
        """
        return pulumi.get(self, "service_job")

    @service_job.setter
    def service_job(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_job", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The time when the job was started.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Execution state for the job.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        System generated globally unique ID for the job.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class TaskIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    TaskIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class TaskIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    TaskIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class TaskNotebookArgsDict(TypedDict):
        notebook: pulumi.Input[str]
        """
        Path to input notebook. This can be the Cloud Storage URI of the notebook file or the path to a Notebook Content. The execution args are accessible as environment variables (TASK_key=value).
        """
        archive_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        """
        file_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Cloud Storage URIs of files to be placed in the working directory of each executor.
        """
        infrastructure_spec: NotRequired[pulumi.Input['TaskNotebookInfrastructureSpecArgsDict']]
        """
        Infrastructure specification for the execution.
        Structure is documented below.
        """
elif False:
    TaskNotebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskNotebookArgs:
    def __init__(__self__, *,
                 notebook: pulumi.Input[str],
                 archive_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 file_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 infrastructure_spec: Optional[pulumi.Input['TaskNotebookInfrastructureSpecArgs']] = None):
        """
        :param pulumi.Input[str] notebook: Path to input notebook. This can be the Cloud Storage URI of the notebook file or the path to a Notebook Content. The execution args are accessible as environment variables (TASK_key=value).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] archive_uris: Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_uris: Cloud Storage URIs of files to be placed in the working directory of each executor.
        :param pulumi.Input['TaskNotebookInfrastructureSpecArgs'] infrastructure_spec: Infrastructure specification for the execution.
               Structure is documented below.
        """
        pulumi.set(__self__, "notebook", notebook)
        if archive_uris is not None:
            pulumi.set(__self__, "archive_uris", archive_uris)
        if file_uris is not None:
            pulumi.set(__self__, "file_uris", file_uris)
        if infrastructure_spec is not None:
            pulumi.set(__self__, "infrastructure_spec", infrastructure_spec)

    @property
    @pulumi.getter
    def notebook(self) -> pulumi.Input[str]:
        """
        Path to input notebook. This can be the Cloud Storage URI of the notebook file or the path to a Notebook Content. The execution args are accessible as environment variables (TASK_key=value).
        """
        return pulumi.get(self, "notebook")

    @notebook.setter
    def notebook(self, value: pulumi.Input[str]):
        pulumi.set(self, "notebook", value)

    @property
    @pulumi.getter(name="archiveUris")
    def archive_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        """
        return pulumi.get(self, "archive_uris")

    @archive_uris.setter
    def archive_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "archive_uris", value)

    @property
    @pulumi.getter(name="fileUris")
    def file_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Cloud Storage URIs of files to be placed in the working directory of each executor.
        """
        return pulumi.get(self, "file_uris")

    @file_uris.setter
    def file_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "file_uris", value)

    @property
    @pulumi.getter(name="infrastructureSpec")
    def infrastructure_spec(self) -> Optional[pulumi.Input['TaskNotebookInfrastructureSpecArgs']]:
        """
        Infrastructure specification for the execution.
        Structure is documented below.
        """
        return pulumi.get(self, "infrastructure_spec")

    @infrastructure_spec.setter
    def infrastructure_spec(self, value: Optional[pulumi.Input['TaskNotebookInfrastructureSpecArgs']]):
        pulumi.set(self, "infrastructure_spec", value)


if not MYPY:
    class TaskNotebookInfrastructureSpecArgsDict(TypedDict):
        batch: NotRequired[pulumi.Input['TaskNotebookInfrastructureSpecBatchArgsDict']]
        """
        Compute resources needed for a Task when using Dataproc Serverless.
        Structure is documented below.
        """
        container_image: NotRequired[pulumi.Input['TaskNotebookInfrastructureSpecContainerImageArgsDict']]
        """
        Container Image Runtime Configuration.
        Structure is documented below.
        """
        vpc_network: NotRequired[pulumi.Input['TaskNotebookInfrastructureSpecVpcNetworkArgsDict']]
        """
        Vpc network.
        Structure is documented below.
        """
elif False:
    TaskNotebookInfrastructureSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskNotebookInfrastructureSpecArgs:
    def __init__(__self__, *,
                 batch: Optional[pulumi.Input['TaskNotebookInfrastructureSpecBatchArgs']] = None,
                 container_image: Optional[pulumi.Input['TaskNotebookInfrastructureSpecContainerImageArgs']] = None,
                 vpc_network: Optional[pulumi.Input['TaskNotebookInfrastructureSpecVpcNetworkArgs']] = None):
        """
        :param pulumi.Input['TaskNotebookInfrastructureSpecBatchArgs'] batch: Compute resources needed for a Task when using Dataproc Serverless.
               Structure is documented below.
        :param pulumi.Input['TaskNotebookInfrastructureSpecContainerImageArgs'] container_image: Container Image Runtime Configuration.
               Structure is documented below.
        :param pulumi.Input['TaskNotebookInfrastructureSpecVpcNetworkArgs'] vpc_network: Vpc network.
               Structure is documented below.
        """
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if container_image is not None:
            pulumi.set(__self__, "container_image", container_image)
        if vpc_network is not None:
            pulumi.set(__self__, "vpc_network", vpc_network)

    @property
    @pulumi.getter
    def batch(self) -> Optional[pulumi.Input['TaskNotebookInfrastructureSpecBatchArgs']]:
        """
        Compute resources needed for a Task when using Dataproc Serverless.
        Structure is documented below.
        """
        return pulumi.get(self, "batch")

    @batch.setter
    def batch(self, value: Optional[pulumi.Input['TaskNotebookInfrastructureSpecBatchArgs']]):
        pulumi.set(self, "batch", value)

    @property
    @pulumi.getter(name="containerImage")
    def container_image(self) -> Optional[pulumi.Input['TaskNotebookInfrastructureSpecContainerImageArgs']]:
        """
        Container Image Runtime Configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "container_image")

    @container_image.setter
    def container_image(self, value: Optional[pulumi.Input['TaskNotebookInfrastructureSpecContainerImageArgs']]):
        pulumi.set(self, "container_image", value)

    @property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> Optional[pulumi.Input['TaskNotebookInfrastructureSpecVpcNetworkArgs']]:
        """
        Vpc network.
        Structure is documented below.
        """
        return pulumi.get(self, "vpc_network")

    @vpc_network.setter
    def vpc_network(self, value: Optional[pulumi.Input['TaskNotebookInfrastructureSpecVpcNetworkArgs']]):
        pulumi.set(self, "vpc_network", value)


if not MYPY:
    class TaskNotebookInfrastructureSpecBatchArgsDict(TypedDict):
        executors_count: NotRequired[pulumi.Input[int]]
        """
        Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        """
        max_executors_count: NotRequired[pulumi.Input[int]]
        """
        Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
elif False:
    TaskNotebookInfrastructureSpecBatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskNotebookInfrastructureSpecBatchArgs:
    def __init__(__self__, *,
                 executors_count: Optional[pulumi.Input[int]] = None,
                 max_executors_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] executors_count: Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        :param pulumi.Input[int] max_executors_count: Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        if executors_count is not None:
            pulumi.set(__self__, "executors_count", executors_count)
        if max_executors_count is not None:
            pulumi.set(__self__, "max_executors_count", max_executors_count)

    @property
    @pulumi.getter(name="executorsCount")
    def executors_count(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        """
        return pulumi.get(self, "executors_count")

    @executors_count.setter
    def executors_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "executors_count", value)

    @property
    @pulumi.getter(name="maxExecutorsCount")
    def max_executors_count(self) -> Optional[pulumi.Input[int]]:
        """
        Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        return pulumi.get(self, "max_executors_count")

    @max_executors_count.setter
    def max_executors_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_executors_count", value)


if not MYPY:
    class TaskNotebookInfrastructureSpecContainerImageArgsDict(TypedDict):
        image: NotRequired[pulumi.Input[str]]
        """
        Container image to use.
        """
        java_jars: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        """
        python_packages: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
elif False:
    TaskNotebookInfrastructureSpecContainerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskNotebookInfrastructureSpecContainerImageArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input[str]] = None,
                 java_jars: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 python_packages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] image: Container image to use.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] java_jars: A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] python_packages: A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if java_jars is not None:
            pulumi.set(__self__, "java_jars", java_jars)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if python_packages is not None:
            pulumi.set(__self__, "python_packages", python_packages)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Container image to use.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="javaJars")
    def java_jars(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        """
        return pulumi.get(self, "java_jars")

    @java_jars.setter
    def java_jars(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "java_jars", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="pythonPackages")
    def python_packages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        return pulumi.get(self, "python_packages")

    @python_packages.setter
    def python_packages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "python_packages", value)


if not MYPY:
    class TaskNotebookInfrastructureSpecVpcNetworkArgsDict(TypedDict):
        network: NotRequired[pulumi.Input[str]]
        """
        The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        """
        network_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of network tags to apply to the job.
        """
        sub_network: NotRequired[pulumi.Input[str]]
        """
        The Cloud VPC sub-network in which the job is run.
        """
elif False:
    TaskNotebookInfrastructureSpecVpcNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskNotebookInfrastructureSpecVpcNetworkArgs:
    def __init__(__self__, *,
                 network: Optional[pulumi.Input[str]] = None,
                 network_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sub_network: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network: The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] network_tags: List of network tags to apply to the job.
        :param pulumi.Input[str] sub_network: The Cloud VPC sub-network in which the job is run.
        """
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_tags is not None:
            pulumi.set(__self__, "network_tags", network_tags)
        if sub_network is not None:
            pulumi.set(__self__, "sub_network", sub_network)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="networkTags")
    def network_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of network tags to apply to the job.
        """
        return pulumi.get(self, "network_tags")

    @network_tags.setter
    def network_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "network_tags", value)

    @property
    @pulumi.getter(name="subNetwork")
    def sub_network(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloud VPC sub-network in which the job is run.
        """
        return pulumi.get(self, "sub_network")

    @sub_network.setter
    def sub_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sub_network", value)


if not MYPY:
    class TaskSparkArgsDict(TypedDict):
        archive_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        """
        file_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Cloud Storage URIs of files to be placed in the working directory of each executor.
        """
        infrastructure_spec: NotRequired[pulumi.Input['TaskSparkInfrastructureSpecArgsDict']]
        """
        Infrastructure specification for the execution.
        Structure is documented below.
        """
        main_class: NotRequired[pulumi.Input[str]]
        """
        The name of the driver's main class. The jar file that contains the class must be in the default CLASSPATH or specified in jar_file_uris. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        main_jar_file_uri: NotRequired[pulumi.Input[str]]
        """
        The Cloud Storage URI of the jar file that contains the main class. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        python_script_file: NotRequired[pulumi.Input[str]]
        """
        The Gcloud Storage URI of the main Python file to use as the driver. Must be a .py file. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        sql_script: NotRequired[pulumi.Input[str]]
        """
        The query text. The execution args are used to declare a set of script variables (set key='value';).
        """
        sql_script_file: NotRequired[pulumi.Input[str]]
        """
        A reference to a query file. This can be the Cloud Storage URI of the query file or it can the path to a SqlScript Content. The execution args are used to declare a set of script variables (set key='value';).
        """
elif False:
    TaskSparkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskSparkArgs:
    def __init__(__self__, *,
                 archive_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 file_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 infrastructure_spec: Optional[pulumi.Input['TaskSparkInfrastructureSpecArgs']] = None,
                 main_class: Optional[pulumi.Input[str]] = None,
                 main_jar_file_uri: Optional[pulumi.Input[str]] = None,
                 python_script_file: Optional[pulumi.Input[str]] = None,
                 sql_script: Optional[pulumi.Input[str]] = None,
                 sql_script_file: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] archive_uris: Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_uris: Cloud Storage URIs of files to be placed in the working directory of each executor.
        :param pulumi.Input['TaskSparkInfrastructureSpecArgs'] infrastructure_spec: Infrastructure specification for the execution.
               Structure is documented below.
        :param pulumi.Input[str] main_class: The name of the driver's main class. The jar file that contains the class must be in the default CLASSPATH or specified in jar_file_uris. The execution args are passed in as a sequence of named process arguments (--key=value).
        :param pulumi.Input[str] main_jar_file_uri: The Cloud Storage URI of the jar file that contains the main class. The execution args are passed in as a sequence of named process arguments (--key=value).
        :param pulumi.Input[str] python_script_file: The Gcloud Storage URI of the main Python file to use as the driver. Must be a .py file. The execution args are passed in as a sequence of named process arguments (--key=value).
        :param pulumi.Input[str] sql_script: The query text. The execution args are used to declare a set of script variables (set key='value';).
        :param pulumi.Input[str] sql_script_file: A reference to a query file. This can be the Cloud Storage URI of the query file or it can the path to a SqlScript Content. The execution args are used to declare a set of script variables (set key='value';).
        """
        if archive_uris is not None:
            pulumi.set(__self__, "archive_uris", archive_uris)
        if file_uris is not None:
            pulumi.set(__self__, "file_uris", file_uris)
        if infrastructure_spec is not None:
            pulumi.set(__self__, "infrastructure_spec", infrastructure_spec)
        if main_class is not None:
            pulumi.set(__self__, "main_class", main_class)
        if main_jar_file_uri is not None:
            pulumi.set(__self__, "main_jar_file_uri", main_jar_file_uri)
        if python_script_file is not None:
            pulumi.set(__self__, "python_script_file", python_script_file)
        if sql_script is not None:
            pulumi.set(__self__, "sql_script", sql_script)
        if sql_script_file is not None:
            pulumi.set(__self__, "sql_script_file", sql_script_file)

    @property
    @pulumi.getter(name="archiveUris")
    def archive_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        """
        return pulumi.get(self, "archive_uris")

    @archive_uris.setter
    def archive_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "archive_uris", value)

    @property
    @pulumi.getter(name="fileUris")
    def file_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Cloud Storage URIs of files to be placed in the working directory of each executor.
        """
        return pulumi.get(self, "file_uris")

    @file_uris.setter
    def file_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "file_uris", value)

    @property
    @pulumi.getter(name="infrastructureSpec")
    def infrastructure_spec(self) -> Optional[pulumi.Input['TaskSparkInfrastructureSpecArgs']]:
        """
        Infrastructure specification for the execution.
        Structure is documented below.
        """
        return pulumi.get(self, "infrastructure_spec")

    @infrastructure_spec.setter
    def infrastructure_spec(self, value: Optional[pulumi.Input['TaskSparkInfrastructureSpecArgs']]):
        pulumi.set(self, "infrastructure_spec", value)

    @property
    @pulumi.getter(name="mainClass")
    def main_class(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the driver's main class. The jar file that contains the class must be in the default CLASSPATH or specified in jar_file_uris. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        return pulumi.get(self, "main_class")

    @main_class.setter
    def main_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "main_class", value)

    @property
    @pulumi.getter(name="mainJarFileUri")
    def main_jar_file_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloud Storage URI of the jar file that contains the main class. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        return pulumi.get(self, "main_jar_file_uri")

    @main_jar_file_uri.setter
    def main_jar_file_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "main_jar_file_uri", value)

    @property
    @pulumi.getter(name="pythonScriptFile")
    def python_script_file(self) -> Optional[pulumi.Input[str]]:
        """
        The Gcloud Storage URI of the main Python file to use as the driver. Must be a .py file. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        return pulumi.get(self, "python_script_file")

    @python_script_file.setter
    def python_script_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "python_script_file", value)

    @property
    @pulumi.getter(name="sqlScript")
    def sql_script(self) -> Optional[pulumi.Input[str]]:
        """
        The query text. The execution args are used to declare a set of script variables (set key='value';).
        """
        return pulumi.get(self, "sql_script")

    @sql_script.setter
    def sql_script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_script", value)

    @property
    @pulumi.getter(name="sqlScriptFile")
    def sql_script_file(self) -> Optional[pulumi.Input[str]]:
        """
        A reference to a query file. This can be the Cloud Storage URI of the query file or it can the path to a SqlScript Content. The execution args are used to declare a set of script variables (set key='value';).
        """
        return pulumi.get(self, "sql_script_file")

    @sql_script_file.setter
    def sql_script_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_script_file", value)


if not MYPY:
    class TaskSparkInfrastructureSpecArgsDict(TypedDict):
        batch: NotRequired[pulumi.Input['TaskSparkInfrastructureSpecBatchArgsDict']]
        """
        Compute resources needed for a Task when using Dataproc Serverless.
        Structure is documented below.
        """
        container_image: NotRequired[pulumi.Input['TaskSparkInfrastructureSpecContainerImageArgsDict']]
        """
        Container Image Runtime Configuration.
        Structure is documented below.
        """
        vpc_network: NotRequired[pulumi.Input['TaskSparkInfrastructureSpecVpcNetworkArgsDict']]
        """
        Vpc network.
        Structure is documented below.
        """
elif False:
    TaskSparkInfrastructureSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskSparkInfrastructureSpecArgs:
    def __init__(__self__, *,
                 batch: Optional[pulumi.Input['TaskSparkInfrastructureSpecBatchArgs']] = None,
                 container_image: Optional[pulumi.Input['TaskSparkInfrastructureSpecContainerImageArgs']] = None,
                 vpc_network: Optional[pulumi.Input['TaskSparkInfrastructureSpecVpcNetworkArgs']] = None):
        """
        :param pulumi.Input['TaskSparkInfrastructureSpecBatchArgs'] batch: Compute resources needed for a Task when using Dataproc Serverless.
               Structure is documented below.
        :param pulumi.Input['TaskSparkInfrastructureSpecContainerImageArgs'] container_image: Container Image Runtime Configuration.
               Structure is documented below.
        :param pulumi.Input['TaskSparkInfrastructureSpecVpcNetworkArgs'] vpc_network: Vpc network.
               Structure is documented below.
        """
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if container_image is not None:
            pulumi.set(__self__, "container_image", container_image)
        if vpc_network is not None:
            pulumi.set(__self__, "vpc_network", vpc_network)

    @property
    @pulumi.getter
    def batch(self) -> Optional[pulumi.Input['TaskSparkInfrastructureSpecBatchArgs']]:
        """
        Compute resources needed for a Task when using Dataproc Serverless.
        Structure is documented below.
        """
        return pulumi.get(self, "batch")

    @batch.setter
    def batch(self, value: Optional[pulumi.Input['TaskSparkInfrastructureSpecBatchArgs']]):
        pulumi.set(self, "batch", value)

    @property
    @pulumi.getter(name="containerImage")
    def container_image(self) -> Optional[pulumi.Input['TaskSparkInfrastructureSpecContainerImageArgs']]:
        """
        Container Image Runtime Configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "container_image")

    @container_image.setter
    def container_image(self, value: Optional[pulumi.Input['TaskSparkInfrastructureSpecContainerImageArgs']]):
        pulumi.set(self, "container_image", value)

    @property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> Optional[pulumi.Input['TaskSparkInfrastructureSpecVpcNetworkArgs']]:
        """
        Vpc network.
        Structure is documented below.
        """
        return pulumi.get(self, "vpc_network")

    @vpc_network.setter
    def vpc_network(self, value: Optional[pulumi.Input['TaskSparkInfrastructureSpecVpcNetworkArgs']]):
        pulumi.set(self, "vpc_network", value)


if not MYPY:
    class TaskSparkInfrastructureSpecBatchArgsDict(TypedDict):
        executors_count: NotRequired[pulumi.Input[int]]
        """
        Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        """
        max_executors_count: NotRequired[pulumi.Input[int]]
        """
        Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
elif False:
    TaskSparkInfrastructureSpecBatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskSparkInfrastructureSpecBatchArgs:
    def __init__(__self__, *,
                 executors_count: Optional[pulumi.Input[int]] = None,
                 max_executors_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] executors_count: Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        :param pulumi.Input[int] max_executors_count: Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        if executors_count is not None:
            pulumi.set(__self__, "executors_count", executors_count)
        if max_executors_count is not None:
            pulumi.set(__self__, "max_executors_count", max_executors_count)

    @property
    @pulumi.getter(name="executorsCount")
    def executors_count(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        """
        return pulumi.get(self, "executors_count")

    @executors_count.setter
    def executors_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "executors_count", value)

    @property
    @pulumi.getter(name="maxExecutorsCount")
    def max_executors_count(self) -> Optional[pulumi.Input[int]]:
        """
        Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        return pulumi.get(self, "max_executors_count")

    @max_executors_count.setter
    def max_executors_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_executors_count", value)


if not MYPY:
    class TaskSparkInfrastructureSpecContainerImageArgsDict(TypedDict):
        image: NotRequired[pulumi.Input[str]]
        """
        Container image to use.
        """
        java_jars: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        """
        python_packages: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
elif False:
    TaskSparkInfrastructureSpecContainerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskSparkInfrastructureSpecContainerImageArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input[str]] = None,
                 java_jars: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 python_packages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] image: Container image to use.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] java_jars: A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] python_packages: A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if java_jars is not None:
            pulumi.set(__self__, "java_jars", java_jars)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if python_packages is not None:
            pulumi.set(__self__, "python_packages", python_packages)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Container image to use.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="javaJars")
    def java_jars(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        """
        return pulumi.get(self, "java_jars")

    @java_jars.setter
    def java_jars(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "java_jars", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="pythonPackages")
    def python_packages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        return pulumi.get(self, "python_packages")

    @python_packages.setter
    def python_packages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "python_packages", value)


if not MYPY:
    class TaskSparkInfrastructureSpecVpcNetworkArgsDict(TypedDict):
        network: NotRequired[pulumi.Input[str]]
        """
        The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        """
        network_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of network tags to apply to the job.
        """
        sub_network: NotRequired[pulumi.Input[str]]
        """
        The Cloud VPC sub-network in which the job is run.
        """
elif False:
    TaskSparkInfrastructureSpecVpcNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskSparkInfrastructureSpecVpcNetworkArgs:
    def __init__(__self__, *,
                 network: Optional[pulumi.Input[str]] = None,
                 network_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sub_network: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network: The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] network_tags: List of network tags to apply to the job.
        :param pulumi.Input[str] sub_network: The Cloud VPC sub-network in which the job is run.
        """
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_tags is not None:
            pulumi.set(__self__, "network_tags", network_tags)
        if sub_network is not None:
            pulumi.set(__self__, "sub_network", sub_network)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="networkTags")
    def network_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of network tags to apply to the job.
        """
        return pulumi.get(self, "network_tags")

    @network_tags.setter
    def network_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "network_tags", value)

    @property
    @pulumi.getter(name="subNetwork")
    def sub_network(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloud VPC sub-network in which the job is run.
        """
        return pulumi.get(self, "sub_network")

    @sub_network.setter
    def sub_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sub_network", value)


if not MYPY:
    class TaskTriggerSpecArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Trigger type of the user-specified Task
        Possible values are: `ON_DEMAND`, `RECURRING`.
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Prevent the task from executing. This does not cancel already running tasks. It is intended to temporarily disable RECURRING tasks.
        """
        max_retries: NotRequired[pulumi.Input[int]]
        """
        Number of retry attempts before aborting. Set to zero to never attempt to retry a failed task.
        """
        schedule: NotRequired[pulumi.Input[str]]
        """
        Cron schedule (https://en.wikipedia.org/wiki/Cron) for running tasks periodically. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: 'CRON_TZ=${IANA_TIME_ZONE}' or 'TZ=${IANA_TIME_ZONE}'. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, CRON_TZ=America/New_York 1 * * * *, or TZ=America/New_York 1 * * * *. This field is required for RECURRING tasks.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        The first run of the task will be after this time. If not specified, the task will run shortly after being submitted if ON_DEMAND and based on the schedule if RECURRING.
        """
elif False:
    TaskTriggerSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTriggerSpecArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disabled: Optional[pulumi.Input[bool]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 schedule: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Trigger type of the user-specified Task
               Possible values are: `ON_DEMAND`, `RECURRING`.
        :param pulumi.Input[bool] disabled: Prevent the task from executing. This does not cancel already running tasks. It is intended to temporarily disable RECURRING tasks.
        :param pulumi.Input[int] max_retries: Number of retry attempts before aborting. Set to zero to never attempt to retry a failed task.
        :param pulumi.Input[str] schedule: Cron schedule (https://en.wikipedia.org/wiki/Cron) for running tasks periodically. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: 'CRON_TZ=${IANA_TIME_ZONE}' or 'TZ=${IANA_TIME_ZONE}'. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, CRON_TZ=America/New_York 1 * * * *, or TZ=America/New_York 1 * * * *. This field is required for RECURRING tasks.
        :param pulumi.Input[str] start_time: The first run of the task will be after this time. If not specified, the task will run shortly after being submitted if ON_DEMAND and based on the schedule if RECURRING.
        """
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Trigger type of the user-specified Task
        Possible values are: `ON_DEMAND`, `RECURRING`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Prevent the task from executing. This does not cancel already running tasks. It is intended to temporarily disable RECURRING tasks.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retry attempts before aborting. Set to zero to never attempt to retry a failed task.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input[str]]:
        """
        Cron schedule (https://en.wikipedia.org/wiki/Cron) for running tasks periodically. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: 'CRON_TZ=${IANA_TIME_ZONE}' or 'TZ=${IANA_TIME_ZONE}'. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, CRON_TZ=America/New_York 1 * * * *, or TZ=America/New_York 1 * * * *. This field is required for RECURRING tasks.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The first run of the task will be after this time. If not specified, the task will run shortly after being submitted if ON_DEMAND and based on the schedule if RECURRING.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class ZoneAssetStatusArgsDict(TypedDict):
        active_assets: NotRequired[pulumi.Input[int]]
        """
        Number of active assets.
        """
        security_policy_applying_assets: NotRequired[pulumi.Input[int]]
        """
        Number of assets that are in process of updating the security policy on attached resources.
        """
        update_time: NotRequired[pulumi.Input[str]]
        """
        Output only. The time when the zone was last updated.
        """
elif False:
    ZoneAssetStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneAssetStatusArgs:
    def __init__(__self__, *,
                 active_assets: Optional[pulumi.Input[int]] = None,
                 security_policy_applying_assets: Optional[pulumi.Input[int]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] active_assets: Number of active assets.
        :param pulumi.Input[int] security_policy_applying_assets: Number of assets that are in process of updating the security policy on attached resources.
        :param pulumi.Input[str] update_time: Output only. The time when the zone was last updated.
        """
        if active_assets is not None:
            pulumi.set(__self__, "active_assets", active_assets)
        if security_policy_applying_assets is not None:
            pulumi.set(__self__, "security_policy_applying_assets", security_policy_applying_assets)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="activeAssets")
    def active_assets(self) -> Optional[pulumi.Input[int]]:
        """
        Number of active assets.
        """
        return pulumi.get(self, "active_assets")

    @active_assets.setter
    def active_assets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "active_assets", value)

    @property
    @pulumi.getter(name="securityPolicyApplyingAssets")
    def security_policy_applying_assets(self) -> Optional[pulumi.Input[int]]:
        """
        Number of assets that are in process of updating the security policy on attached resources.
        """
        return pulumi.get(self, "security_policy_applying_assets")

    @security_policy_applying_assets.setter
    def security_policy_applying_assets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "security_policy_applying_assets", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. The time when the zone was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class ZoneDiscoverySpecArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Required. Whether discovery is enabled.
        """
        csv_options: NotRequired[pulumi.Input['ZoneDiscoverySpecCsvOptionsArgsDict']]
        """
        Optional. Configuration for CSV data.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        json_options: NotRequired[pulumi.Input['ZoneDiscoverySpecJsonOptionsArgsDict']]
        """
        Optional. Configuration for Json data.
        """
        schedule: NotRequired[pulumi.Input[str]]
        """
        Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
elif False:
    ZoneDiscoverySpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneDiscoverySpecArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 csv_options: Optional[pulumi.Input['ZoneDiscoverySpecCsvOptionsArgs']] = None,
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 json_options: Optional[pulumi.Input['ZoneDiscoverySpecJsonOptionsArgs']] = None,
                 schedule: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Required. Whether discovery is enabled.
        :param pulumi.Input['ZoneDiscoverySpecCsvOptionsArgs'] csv_options: Optional. Configuration for CSV data.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param pulumi.Input['ZoneDiscoverySpecJsonOptionsArgs'] json_options: Optional. Configuration for Json data.
        :param pulumi.Input[str] schedule: Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        pulumi.set(__self__, "enabled", enabled)
        if csv_options is not None:
            pulumi.set(__self__, "csv_options", csv_options)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if json_options is not None:
            pulumi.set(__self__, "json_options", json_options)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Required. Whether discovery is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="csvOptions")
    def csv_options(self) -> Optional[pulumi.Input['ZoneDiscoverySpecCsvOptionsArgs']]:
        """
        Optional. Configuration for CSV data.
        """
        return pulumi.get(self, "csv_options")

    @csv_options.setter
    def csv_options(self, value: Optional[pulumi.Input['ZoneDiscoverySpecCsvOptionsArgs']]):
        pulumi.set(self, "csv_options", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)

    @property
    @pulumi.getter(name="jsonOptions")
    def json_options(self) -> Optional[pulumi.Input['ZoneDiscoverySpecJsonOptionsArgs']]:
        """
        Optional. Configuration for Json data.
        """
        return pulumi.get(self, "json_options")

    @json_options.setter
    def json_options(self, value: Optional[pulumi.Input['ZoneDiscoverySpecJsonOptionsArgs']]):
        pulumi.set(self, "json_options", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class ZoneDiscoverySpecCsvOptionsArgsDict(TypedDict):
        delimiter: NotRequired[pulumi.Input[str]]
        """
        Optional. The delimiter being used to separate values. This defaults to ','.
        """
        disable_type_inference: NotRequired[pulumi.Input[bool]]
        """
        Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        """
        encoding: NotRequired[pulumi.Input[str]]
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        header_rows: NotRequired[pulumi.Input[int]]
        """
        Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
elif False:
    ZoneDiscoverySpecCsvOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneDiscoverySpecCsvOptionsArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 disable_type_inference: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 header_rows: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] delimiter: Optional. The delimiter being used to separate values. This defaults to ','.
        :param pulumi.Input[bool] disable_type_inference: Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        :param pulumi.Input[str] encoding: Optional. The character encoding of the data. The default is UTF-8.
        :param pulumi.Input[int] header_rows: Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if header_rows is not None:
            pulumi.set(__self__, "header_rows", header_rows)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The delimiter being used to separate values. This defaults to ','.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        """
        return pulumi.get(self, "disable_type_inference")

    @disable_type_inference.setter
    def disable_type_inference(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_type_inference", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="headerRows")
    def header_rows(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        return pulumi.get(self, "header_rows")

    @header_rows.setter
    def header_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "header_rows", value)


if not MYPY:
    class ZoneDiscoverySpecJsonOptionsArgsDict(TypedDict):
        disable_type_inference: NotRequired[pulumi.Input[bool]]
        """
        Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        """
        encoding: NotRequired[pulumi.Input[str]]
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
elif False:
    ZoneDiscoverySpecJsonOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneDiscoverySpecJsonOptionsArgs:
    def __init__(__self__, *,
                 disable_type_inference: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable_type_inference: Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        :param pulumi.Input[str] encoding: Optional. The character encoding of the data. The default is UTF-8.
        """
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        """
        return pulumi.get(self, "disable_type_inference")

    @disable_type_inference.setter
    def disable_type_inference(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_type_inference", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)


if not MYPY:
    class ZoneIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    ZoneIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class ZoneIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    ZoneIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class ZoneResourceSpecArgsDict(TypedDict):
        location_type: pulumi.Input[str]
        """
        Required. Immutable. The location type of the resources that are allowed to be attached to the assets within this zone. Possible values: LOCATION_TYPE_UNSPECIFIED, SINGLE_REGION, MULTI_REGION

        - - -
        """
elif False:
    ZoneResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneResourceSpecArgs:
    def __init__(__self__, *,
                 location_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] location_type: Required. Immutable. The location type of the resources that are allowed to be attached to the assets within this zone. Possible values: LOCATION_TYPE_UNSPECIFIED, SINGLE_REGION, MULTI_REGION
               
               - - -
        """
        pulumi.set(__self__, "location_type", location_type)

    @property
    @pulumi.getter(name="locationType")
    def location_type(self) -> pulumi.Input[str]:
        """
        Required. Immutable. The location type of the resources that are allowed to be attached to the assets within this zone. Possible values: LOCATION_TYPE_UNSPECIFIED, SINGLE_REGION, MULTI_REGION

        - - -
        """
        return pulumi.get(self, "location_type")

    @location_type.setter
    def location_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "location_type", value)


