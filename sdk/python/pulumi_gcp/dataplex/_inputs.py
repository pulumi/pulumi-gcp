# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'AssetDiscoverySpecArgs',
    'AssetDiscoverySpecCsvOptionsArgs',
    'AssetDiscoverySpecJsonOptionsArgs',
    'AssetDiscoveryStatusArgs',
    'AssetDiscoveryStatusStatArgs',
    'AssetIamBindingConditionArgs',
    'AssetIamMemberConditionArgs',
    'AssetResourceSpecArgs',
    'AssetResourceStatusArgs',
    'AssetSecurityStatusArgs',
    'DatascanDataArgs',
    'DatascanDataProfileResultArgs',
    'DatascanDataProfileResultProfileArgs',
    'DatascanDataProfileResultProfileFieldArgs',
    'DatascanDataProfileResultProfileFieldProfileArgs',
    'DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs',
    'DatascanDataProfileResultProfileFieldProfileIntegerProfileArgs',
    'DatascanDataProfileResultProfileFieldProfileStringProfileArgs',
    'DatascanDataProfileResultProfileFieldProfileTopNValuesArgs',
    'DatascanDataProfileResultScannedDataArgs',
    'DatascanDataProfileResultScannedDataIncrementalFieldArgs',
    'DatascanDataProfileSpecArgs',
    'DatascanDataProfileSpecExcludeFieldsArgs',
    'DatascanDataProfileSpecIncludeFieldsArgs',
    'DatascanDataProfileSpecPostScanActionsArgs',
    'DatascanDataProfileSpecPostScanActionsBigqueryExportArgs',
    'DatascanDataQualityResultArgs',
    'DatascanDataQualityResultDimensionArgs',
    'DatascanDataQualityResultRuleArgs',
    'DatascanDataQualityResultRuleRuleArgs',
    'DatascanDataQualityResultRuleRuleNonNullExpectationArgs',
    'DatascanDataQualityResultRuleRuleRangeExpectationArgs',
    'DatascanDataQualityResultRuleRuleRegexExpectationArgs',
    'DatascanDataQualityResultRuleRuleRowConditionExpectationArgs',
    'DatascanDataQualityResultRuleRuleSetExpectationArgs',
    'DatascanDataQualityResultRuleRuleStatisticRangeExpectationArgs',
    'DatascanDataQualityResultRuleRuleTableConditionExpectationArgs',
    'DatascanDataQualityResultRuleRuleUniquenessExpectationArgs',
    'DatascanDataQualityResultScannedDataArgs',
    'DatascanDataQualityResultScannedDataIncrementalFieldArgs',
    'DatascanDataQualitySpecArgs',
    'DatascanDataQualitySpecPostScanActionsArgs',
    'DatascanDataQualitySpecPostScanActionsBigqueryExportArgs',
    'DatascanDataQualitySpecRuleArgs',
    'DatascanDataQualitySpecRuleNonNullExpectationArgs',
    'DatascanDataQualitySpecRuleRangeExpectationArgs',
    'DatascanDataQualitySpecRuleRegexExpectationArgs',
    'DatascanDataQualitySpecRuleRowConditionExpectationArgs',
    'DatascanDataQualitySpecRuleSetExpectationArgs',
    'DatascanDataQualitySpecRuleStatisticRangeExpectationArgs',
    'DatascanDataQualitySpecRuleTableConditionExpectationArgs',
    'DatascanDataQualitySpecRuleUniquenessExpectationArgs',
    'DatascanExecutionSpecArgs',
    'DatascanExecutionSpecTriggerArgs',
    'DatascanExecutionSpecTriggerOnDemandArgs',
    'DatascanExecutionSpecTriggerScheduleArgs',
    'DatascanExecutionStatusArgs',
    'DatascanIamBindingConditionArgs',
    'DatascanIamMemberConditionArgs',
    'LakeAssetStatusArgs',
    'LakeIamBindingConditionArgs',
    'LakeIamMemberConditionArgs',
    'LakeMetastoreArgs',
    'LakeMetastoreStatusArgs',
    'TaskExecutionSpecArgs',
    'TaskExecutionStatusArgs',
    'TaskExecutionStatusLatestJobArgs',
    'TaskIamBindingConditionArgs',
    'TaskIamMemberConditionArgs',
    'TaskNotebookArgs',
    'TaskNotebookInfrastructureSpecArgs',
    'TaskNotebookInfrastructureSpecBatchArgs',
    'TaskNotebookInfrastructureSpecContainerImageArgs',
    'TaskNotebookInfrastructureSpecVpcNetworkArgs',
    'TaskSparkArgs',
    'TaskSparkInfrastructureSpecArgs',
    'TaskSparkInfrastructureSpecBatchArgs',
    'TaskSparkInfrastructureSpecContainerImageArgs',
    'TaskSparkInfrastructureSpecVpcNetworkArgs',
    'TaskTriggerSpecArgs',
    'ZoneAssetStatusArgs',
    'ZoneDiscoverySpecArgs',
    'ZoneDiscoverySpecCsvOptionsArgs',
    'ZoneDiscoverySpecJsonOptionsArgs',
    'ZoneIamBindingConditionArgs',
    'ZoneIamMemberConditionArgs',
    'ZoneResourceSpecArgs',
]

@pulumi.input_type
class AssetDiscoverySpecArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 csv_options: Optional[pulumi.Input['AssetDiscoverySpecCsvOptionsArgs']] = None,
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 json_options: Optional[pulumi.Input['AssetDiscoverySpecJsonOptionsArgs']] = None,
                 schedule: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Required. Whether discovery is enabled.
        :param pulumi.Input['AssetDiscoverySpecCsvOptionsArgs'] csv_options: Optional. Configuration for CSV data.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param pulumi.Input['AssetDiscoverySpecJsonOptionsArgs'] json_options: Optional. Configuration for Json data.
        :param pulumi.Input[str] schedule: Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        pulumi.set(__self__, "enabled", enabled)
        if csv_options is not None:
            pulumi.set(__self__, "csv_options", csv_options)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if json_options is not None:
            pulumi.set(__self__, "json_options", json_options)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Required. Whether discovery is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="csvOptions")
    def csv_options(self) -> Optional[pulumi.Input['AssetDiscoverySpecCsvOptionsArgs']]:
        """
        Optional. Configuration for CSV data.
        """
        return pulumi.get(self, "csv_options")

    @csv_options.setter
    def csv_options(self, value: Optional[pulumi.Input['AssetDiscoverySpecCsvOptionsArgs']]):
        pulumi.set(self, "csv_options", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)

    @property
    @pulumi.getter(name="jsonOptions")
    def json_options(self) -> Optional[pulumi.Input['AssetDiscoverySpecJsonOptionsArgs']]:
        """
        Optional. Configuration for Json data.
        """
        return pulumi.get(self, "json_options")

    @json_options.setter
    def json_options(self, value: Optional[pulumi.Input['AssetDiscoverySpecJsonOptionsArgs']]):
        pulumi.set(self, "json_options", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule", value)


@pulumi.input_type
class AssetDiscoverySpecCsvOptionsArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 disable_type_inference: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 header_rows: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] delimiter: Optional. The delimiter being used to separate values. This defaults to ','.
        :param pulumi.Input[bool] disable_type_inference: Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        :param pulumi.Input[str] encoding: Optional. The character encoding of the data. The default is UTF-8.
        :param pulumi.Input[int] header_rows: Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if header_rows is not None:
            pulumi.set(__self__, "header_rows", header_rows)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The delimiter being used to separate values. This defaults to ','.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        """
        return pulumi.get(self, "disable_type_inference")

    @disable_type_inference.setter
    def disable_type_inference(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_type_inference", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="headerRows")
    def header_rows(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        return pulumi.get(self, "header_rows")

    @header_rows.setter
    def header_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "header_rows", value)


@pulumi.input_type
class AssetDiscoverySpecJsonOptionsArgs:
    def __init__(__self__, *,
                 disable_type_inference: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable_type_inference: Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        :param pulumi.Input[str] encoding: Optional. The character encoding of the data. The default is UTF-8.
        """
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        """
        return pulumi.get(self, "disable_type_inference")

    @disable_type_inference.setter
    def disable_type_inference(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_type_inference", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)


@pulumi.input_type
class AssetDiscoveryStatusArgs:
    def __init__(__self__, *,
                 last_run_duration: Optional[pulumi.Input[str]] = None,
                 last_run_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 stats: Optional[pulumi.Input[Sequence[pulumi.Input['AssetDiscoveryStatusStatArgs']]]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] state: Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param pulumi.Input[str] update_time: Output only. The time when the asset was last updated.
        """
        if last_run_duration is not None:
            pulumi.set(__self__, "last_run_duration", last_run_duration)
        if last_run_time is not None:
            pulumi.set(__self__, "last_run_time", last_run_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if stats is not None:
            pulumi.set(__self__, "stats", stats)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="lastRunDuration")
    def last_run_duration(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_run_duration")

    @last_run_duration.setter
    def last_run_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_run_duration", value)

    @property
    @pulumi.getter(name="lastRunTime")
    def last_run_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_run_time")

    @last_run_time.setter
    def last_run_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_run_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def stats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AssetDiscoveryStatusStatArgs']]]]:
        return pulumi.get(self, "stats")

    @stats.setter
    def stats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AssetDiscoveryStatusStatArgs']]]]):
        pulumi.set(self, "stats", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. The time when the asset was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


@pulumi.input_type
class AssetDiscoveryStatusStatArgs:
    def __init__(__self__, *,
                 data_items: Optional[pulumi.Input[int]] = None,
                 data_size: Optional[pulumi.Input[int]] = None,
                 filesets: Optional[pulumi.Input[int]] = None,
                 tables: Optional[pulumi.Input[int]] = None):
        if data_items is not None:
            pulumi.set(__self__, "data_items", data_items)
        if data_size is not None:
            pulumi.set(__self__, "data_size", data_size)
        if filesets is not None:
            pulumi.set(__self__, "filesets", filesets)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter(name="dataItems")
    def data_items(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "data_items")

    @data_items.setter
    def data_items(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "data_items", value)

    @property
    @pulumi.getter(name="dataSize")
    def data_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "data_size")

    @data_size.setter
    def data_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "data_size", value)

    @property
    @pulumi.getter
    def filesets(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "filesets")

    @filesets.setter
    def filesets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "filesets", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tables", value)


@pulumi.input_type
class AssetIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class AssetIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class AssetResourceSpecArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 read_access_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Required. Immutable. Type of resource. Possible values: STORAGE_BUCKET, BIGQUERY_DATASET
               
               - - -
        :param pulumi.Input[str] name: Immutable. Relative name of the cloud resource that contains the data that is being managed within a lake. For example: `projects/{project_number}/buckets/{bucket_id}` `projects/{project_number}/datasets/{dataset_id}`
        :param pulumi.Input[str] read_access_mode: Optional. Determines how read permissions are handled for each asset and their associated tables. Only available to storage buckets assets. Possible values: DIRECT, MANAGED
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if read_access_mode is not None:
            pulumi.set(__self__, "read_access_mode", read_access_mode)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Required. Immutable. Type of resource. Possible values: STORAGE_BUCKET, BIGQUERY_DATASET

        - - -
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Immutable. Relative name of the cloud resource that contains the data that is being managed within a lake. For example: `projects/{project_number}/buckets/{bucket_id}` `projects/{project_number}/datasets/{dataset_id}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="readAccessMode")
    def read_access_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Determines how read permissions are handled for each asset and their associated tables. Only available to storage buckets assets. Possible values: DIRECT, MANAGED
        """
        return pulumi.get(self, "read_access_mode")

    @read_access_mode.setter
    def read_access_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read_access_mode", value)


@pulumi.input_type
class AssetResourceStatusArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] state: Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param pulumi.Input[str] update_time: Output only. The time when the asset was last updated.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. The time when the asset was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


@pulumi.input_type
class AssetSecurityStatusArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] state: Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param pulumi.Input[str] update_time: Output only. The time when the asset was last updated.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. The time when the asset was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


@pulumi.input_type
class DatascanDataArgs:
    def __init__(__self__, *,
                 entity: Optional[pulumi.Input[str]] = None,
                 resource: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] entity: The Dataplex entity that represents the data source(e.g. BigQuery table) for Datascan.
        :param pulumi.Input[str] resource: The service-qualified full resource name of the cloud resource for a DataScan job to scan against. The field could be:
               (Cloud Storage bucket for DataDiscoveryScan)BigQuery table of type "TABLE" for DataProfileScan/DataQualityScan.
        """
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def entity(self) -> Optional[pulumi.Input[str]]:
        """
        The Dataplex entity that represents the data source(e.g. BigQuery table) for Datascan.
        """
        return pulumi.get(self, "entity")

    @entity.setter
    def entity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[str]]:
        """
        The service-qualified full resource name of the cloud resource for a DataScan job to scan against. The field could be:
        (Cloud Storage bucket for DataDiscoveryScan)BigQuery table of type "TABLE" for DataProfileScan/DataQualityScan.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource", value)


@pulumi.input_type
class DatascanDataProfileResultArgs:
    def __init__(__self__, *,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileArgs']]]] = None,
                 row_count: Optional[pulumi.Input[str]] = None,
                 scanned_datas: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultScannedDataArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileArgs']]] profiles: Profile information for the corresponding field.
               Structure is documented below.
        :param pulumi.Input[str] row_count: The count of rows scanned.
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultScannedDataArgs']]] scanned_datas: (Output)
               The data scanned for this result.
               Structure is documented below.
        """
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if row_count is not None:
            pulumi.set(__self__, "row_count", row_count)
        if scanned_datas is not None:
            pulumi.set(__self__, "scanned_datas", scanned_datas)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileArgs']]]]:
        """
        Profile information for the corresponding field.
        Structure is documented below.
        """
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileArgs']]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter(name="rowCount")
    def row_count(self) -> Optional[pulumi.Input[str]]:
        """
        The count of rows scanned.
        """
        return pulumi.get(self, "row_count")

    @row_count.setter
    def row_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "row_count", value)

    @property
    @pulumi.getter(name="scannedDatas")
    def scanned_datas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultScannedDataArgs']]]]:
        """
        (Output)
        The data scanned for this result.
        Structure is documented below.
        """
        return pulumi.get(self, "scanned_datas")

    @scanned_datas.setter
    def scanned_datas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultScannedDataArgs']]]]):
        pulumi.set(self, "scanned_datas", value)


@pulumi.input_type
class DatascanDataProfileResultProfileArgs:
    def __init__(__self__, *,
                 fields: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldArgs']]] fields: List of fields with structural and profile information for each field.
               Structure is documented below.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldArgs']]]]:
        """
        List of fields with structural and profile information for each field.
        Structure is documented below.
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldArgs']]]]):
        pulumi.set(self, "fields", value)


@pulumi.input_type
class DatascanDataProfileResultProfileFieldArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 profile: Optional[pulumi.Input['DatascanDataProfileResultProfileFieldProfileArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: The mode of the field. Possible values include:
               1. REQUIRED, if it is a required field.
               2. NULLABLE, if it is an optional field.
               3. REPEATED, if it is a repeated field.
        :param pulumi.Input[str] name: A mutable name for the rule.
               The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
               The maximum length is 63 characters.
               Must start with a letter.
               Must end with a number or a letter.
        :param pulumi.Input['DatascanDataProfileResultProfileFieldProfileArgs'] profile: Profile information for the corresponding field.
               Structure is documented below.
        :param pulumi.Input[str] type: The field data type.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        The mode of the field. Possible values include:
        1. REQUIRED, if it is a required field.
        2. NULLABLE, if it is an optional field.
        3. REPEATED, if it is a repeated field.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A mutable name for the rule.
        The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
        The maximum length is 63 characters.
        Must start with a letter.
        Must end with a number or a letter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input['DatascanDataProfileResultProfileFieldProfileArgs']]:
        """
        Profile information for the corresponding field.
        Structure is documented below.
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input['DatascanDataProfileResultProfileFieldProfileArgs']]):
        pulumi.set(self, "profile", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The field data type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DatascanDataProfileResultProfileFieldProfileArgs:
    def __init__(__self__, *,
                 distinct_ratio: Optional[pulumi.Input[int]] = None,
                 double_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs']]]] = None,
                 integer_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldProfileIntegerProfileArgs']]]] = None,
                 null_ratio: Optional[pulumi.Input[int]] = None,
                 string_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldProfileStringProfileArgs']]]] = None,
                 top_n_values: Optional[pulumi.Input['DatascanDataProfileResultProfileFieldProfileTopNValuesArgs']] = None):
        """
        :param pulumi.Input[int] distinct_ratio: Ratio of rows with distinct values against total scanned rows. Not available for complex non-groupable field type RECORD and fields with REPEATABLE mode.
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs']]] double_profiles: (Output)
               Double type field information.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldProfileIntegerProfileArgs']]] integer_profiles: (Output)
               Integer type field information.
               Structure is documented below.
        :param pulumi.Input[int] null_ratio: (Output)
               Ratio of rows with null value against total scanned rows.
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldProfileStringProfileArgs']]] string_profiles: (Output)
               String type field information.
               Structure is documented below.
        :param pulumi.Input['DatascanDataProfileResultProfileFieldProfileTopNValuesArgs'] top_n_values: The list of top N non-null values and number of times they occur in the scanned data. N is 10 or equal to the number of distinct values in the field, whichever is smaller. Not available for complex non-groupable field type RECORD and fields with REPEATABLE mode.
               Structure is documented below.
        """
        if distinct_ratio is not None:
            pulumi.set(__self__, "distinct_ratio", distinct_ratio)
        if double_profiles is not None:
            pulumi.set(__self__, "double_profiles", double_profiles)
        if integer_profiles is not None:
            pulumi.set(__self__, "integer_profiles", integer_profiles)
        if null_ratio is not None:
            pulumi.set(__self__, "null_ratio", null_ratio)
        if string_profiles is not None:
            pulumi.set(__self__, "string_profiles", string_profiles)
        if top_n_values is not None:
            pulumi.set(__self__, "top_n_values", top_n_values)

    @property
    @pulumi.getter(name="distinctRatio")
    def distinct_ratio(self) -> Optional[pulumi.Input[int]]:
        """
        Ratio of rows with distinct values against total scanned rows. Not available for complex non-groupable field type RECORD and fields with REPEATABLE mode.
        """
        return pulumi.get(self, "distinct_ratio")

    @distinct_ratio.setter
    def distinct_ratio(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "distinct_ratio", value)

    @property
    @pulumi.getter(name="doubleProfiles")
    def double_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs']]]]:
        """
        (Output)
        Double type field information.
        Structure is documented below.
        """
        return pulumi.get(self, "double_profiles")

    @double_profiles.setter
    def double_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs']]]]):
        pulumi.set(self, "double_profiles", value)

    @property
    @pulumi.getter(name="integerProfiles")
    def integer_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldProfileIntegerProfileArgs']]]]:
        """
        (Output)
        Integer type field information.
        Structure is documented below.
        """
        return pulumi.get(self, "integer_profiles")

    @integer_profiles.setter
    def integer_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldProfileIntegerProfileArgs']]]]):
        pulumi.set(self, "integer_profiles", value)

    @property
    @pulumi.getter(name="nullRatio")
    def null_ratio(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Ratio of rows with null value against total scanned rows.
        """
        return pulumi.get(self, "null_ratio")

    @null_ratio.setter
    def null_ratio(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "null_ratio", value)

    @property
    @pulumi.getter(name="stringProfiles")
    def string_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldProfileStringProfileArgs']]]]:
        """
        (Output)
        String type field information.
        Structure is documented below.
        """
        return pulumi.get(self, "string_profiles")

    @string_profiles.setter
    def string_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataProfileResultProfileFieldProfileStringProfileArgs']]]]):
        pulumi.set(self, "string_profiles", value)

    @property
    @pulumi.getter(name="topNValues")
    def top_n_values(self) -> Optional[pulumi.Input['DatascanDataProfileResultProfileFieldProfileTopNValuesArgs']]:
        """
        The list of top N non-null values and number of times they occur in the scanned data. N is 10 or equal to the number of distinct values in the field, whichever is smaller. Not available for complex non-groupable field type RECORD and fields with REPEATABLE mode.
        Structure is documented below.
        """
        return pulumi.get(self, "top_n_values")

    @top_n_values.setter
    def top_n_values(self, value: Optional[pulumi.Input['DatascanDataProfileResultProfileFieldProfileTopNValuesArgs']]):
        pulumi.set(self, "top_n_values", value)


@pulumi.input_type
class DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs:
    def __init__(__self__, *,
                 average: Optional[pulumi.Input[int]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 quartiles: Optional[pulumi.Input[str]] = None,
                 standard_deviation: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] average: Average of non-null values in the scanned data. NaN, if the field has a NaN.
        :param pulumi.Input[str] max: Maximum of non-null values in the scanned data. NaN, if the field has a NaN.
        :param pulumi.Input[str] min: Minimum of non-null values in the scanned data. NaN, if the field has a NaN.
        :param pulumi.Input[str] quartiles: A quartile divides the number of data points into four parts, or quarters, of more-or-less equal size. Three main quartiles used are: The first quartile (Q1) splits off the lowest 25% of data from the highest 75%. It is also known as the lower or 25th empirical quartile, as 25% of the data is below this point. The second quartile (Q2) is the median of a data set. So, 50% of the data lies below this point. The third quartile (Q3) splits off the highest 25% of data from the lowest 75%. It is known as the upper or 75th empirical quartile, as 75% of the data lies below this point. Here, the quartiles is provided as an ordered list of quartile values for the scanned data, occurring in order Q1, median, Q3.
        :param pulumi.Input[int] standard_deviation: Standard deviation of non-null values in the scanned data. NaN, if the field has a NaN.
        """
        if average is not None:
            pulumi.set(__self__, "average", average)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if quartiles is not None:
            pulumi.set(__self__, "quartiles", quartiles)
        if standard_deviation is not None:
            pulumi.set(__self__, "standard_deviation", standard_deviation)

    @property
    @pulumi.getter
    def average(self) -> Optional[pulumi.Input[int]]:
        """
        Average of non-null values in the scanned data. NaN, if the field has a NaN.
        """
        return pulumi.get(self, "average")

    @average.setter
    def average(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "average", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum of non-null values in the scanned data. NaN, if the field has a NaN.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum of non-null values in the scanned data. NaN, if the field has a NaN.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def quartiles(self) -> Optional[pulumi.Input[str]]:
        """
        A quartile divides the number of data points into four parts, or quarters, of more-or-less equal size. Three main quartiles used are: The first quartile (Q1) splits off the lowest 25% of data from the highest 75%. It is also known as the lower or 25th empirical quartile, as 25% of the data is below this point. The second quartile (Q2) is the median of a data set. So, 50% of the data lies below this point. The third quartile (Q3) splits off the highest 25% of data from the lowest 75%. It is known as the upper or 75th empirical quartile, as 75% of the data lies below this point. Here, the quartiles is provided as an ordered list of quartile values for the scanned data, occurring in order Q1, median, Q3.
        """
        return pulumi.get(self, "quartiles")

    @quartiles.setter
    def quartiles(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quartiles", value)

    @property
    @pulumi.getter(name="standardDeviation")
    def standard_deviation(self) -> Optional[pulumi.Input[int]]:
        """
        Standard deviation of non-null values in the scanned data. NaN, if the field has a NaN.
        """
        return pulumi.get(self, "standard_deviation")

    @standard_deviation.setter
    def standard_deviation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "standard_deviation", value)


@pulumi.input_type
class DatascanDataProfileResultProfileFieldProfileIntegerProfileArgs:
    def __init__(__self__, *,
                 average: Optional[pulumi.Input[int]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 quartiles: Optional[pulumi.Input[str]] = None,
                 standard_deviation: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] average: Average of non-null values in the scanned data. NaN, if the field has a NaN.
        :param pulumi.Input[str] max: Maximum of non-null values in the scanned data. NaN, if the field has a NaN.
        :param pulumi.Input[str] min: Minimum of non-null values in the scanned data. NaN, if the field has a NaN.
        :param pulumi.Input[str] quartiles: A quartile divides the number of data points into four parts, or quarters, of more-or-less equal size. Three main quartiles used are: The first quartile (Q1) splits off the lowest 25% of data from the highest 75%. It is also known as the lower or 25th empirical quartile, as 25% of the data is below this point. The second quartile (Q2) is the median of a data set. So, 50% of the data lies below this point. The third quartile (Q3) splits off the highest 25% of data from the lowest 75%. It is known as the upper or 75th empirical quartile, as 75% of the data lies below this point. Here, the quartiles is provided as an ordered list of quartile values for the scanned data, occurring in order Q1, median, Q3.
        :param pulumi.Input[int] standard_deviation: Standard deviation of non-null values in the scanned data. NaN, if the field has a NaN.
        """
        if average is not None:
            pulumi.set(__self__, "average", average)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if quartiles is not None:
            pulumi.set(__self__, "quartiles", quartiles)
        if standard_deviation is not None:
            pulumi.set(__self__, "standard_deviation", standard_deviation)

    @property
    @pulumi.getter
    def average(self) -> Optional[pulumi.Input[int]]:
        """
        Average of non-null values in the scanned data. NaN, if the field has a NaN.
        """
        return pulumi.get(self, "average")

    @average.setter
    def average(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "average", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum of non-null values in the scanned data. NaN, if the field has a NaN.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum of non-null values in the scanned data. NaN, if the field has a NaN.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def quartiles(self) -> Optional[pulumi.Input[str]]:
        """
        A quartile divides the number of data points into four parts, or quarters, of more-or-less equal size. Three main quartiles used are: The first quartile (Q1) splits off the lowest 25% of data from the highest 75%. It is also known as the lower or 25th empirical quartile, as 25% of the data is below this point. The second quartile (Q2) is the median of a data set. So, 50% of the data lies below this point. The third quartile (Q3) splits off the highest 25% of data from the lowest 75%. It is known as the upper or 75th empirical quartile, as 75% of the data lies below this point. Here, the quartiles is provided as an ordered list of quartile values for the scanned data, occurring in order Q1, median, Q3.
        """
        return pulumi.get(self, "quartiles")

    @quartiles.setter
    def quartiles(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quartiles", value)

    @property
    @pulumi.getter(name="standardDeviation")
    def standard_deviation(self) -> Optional[pulumi.Input[int]]:
        """
        Standard deviation of non-null values in the scanned data. NaN, if the field has a NaN.
        """
        return pulumi.get(self, "standard_deviation")

    @standard_deviation.setter
    def standard_deviation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "standard_deviation", value)


@pulumi.input_type
class DatascanDataProfileResultProfileFieldProfileStringProfileArgs:
    def __init__(__self__, *,
                 average_length: Optional[pulumi.Input[int]] = None,
                 max_length: Optional[pulumi.Input[str]] = None,
                 min_length: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] average_length: Average length of non-null values in the scanned data.
        :param pulumi.Input[str] max_length: Maximum length of non-null values in the scanned data.
        :param pulumi.Input[str] min_length: Minimum length of non-null values in the scanned data.
        """
        if average_length is not None:
            pulumi.set(__self__, "average_length", average_length)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)

    @property
    @pulumi.getter(name="averageLength")
    def average_length(self) -> Optional[pulumi.Input[int]]:
        """
        Average length of non-null values in the scanned data.
        """
        return pulumi.get(self, "average_length")

    @average_length.setter
    def average_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "average_length", value)

    @property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum length of non-null values in the scanned data.
        """
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_length", value)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum length of non-null values in the scanned data.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_length", value)


@pulumi.input_type
class DatascanDataProfileResultProfileFieldProfileTopNValuesArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] count: Count of the corresponding value in the scanned data.
        :param pulumi.Input[str] value: String value of a top N non-null value.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[str]]:
        """
        Count of the corresponding value in the scanned data.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        String value of a top N non-null value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DatascanDataProfileResultScannedDataArgs:
    def __init__(__self__, *,
                 incremental_field: Optional[pulumi.Input['DatascanDataProfileResultScannedDataIncrementalFieldArgs']] = None):
        """
        :param pulumi.Input['DatascanDataProfileResultScannedDataIncrementalFieldArgs'] incremental_field: The range denoted by values of an incremental field
               Structure is documented below.
        """
        if incremental_field is not None:
            pulumi.set(__self__, "incremental_field", incremental_field)

    @property
    @pulumi.getter(name="incrementalField")
    def incremental_field(self) -> Optional[pulumi.Input['DatascanDataProfileResultScannedDataIncrementalFieldArgs']]:
        """
        The range denoted by values of an incremental field
        Structure is documented below.
        """
        return pulumi.get(self, "incremental_field")

    @incremental_field.setter
    def incremental_field(self, value: Optional[pulumi.Input['DatascanDataProfileResultScannedDataIncrementalFieldArgs']]):
        pulumi.set(self, "incremental_field", value)


@pulumi.input_type
class DatascanDataProfileResultScannedDataIncrementalFieldArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[str]] = None,
                 field: Optional[pulumi.Input[str]] = None,
                 start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] end: Value that marks the end of the range.
        :param pulumi.Input[str] field: The unnested field (of type Date or Timestamp) that contains values which monotonically increase over time. If not specified, a data scan will run for all data in the table.
        :param pulumi.Input[str] start: Value that marks the start of the range.
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[str]]:
        """
        Value that marks the end of the range.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        The unnested field (of type Date or Timestamp) that contains values which monotonically increase over time. If not specified, a data scan will run for all data in the table.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[str]]:
        """
        Value that marks the start of the range.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class DatascanDataProfileSpecArgs:
    def __init__(__self__, *,
                 exclude_fields: Optional[pulumi.Input['DatascanDataProfileSpecExcludeFieldsArgs']] = None,
                 include_fields: Optional[pulumi.Input['DatascanDataProfileSpecIncludeFieldsArgs']] = None,
                 post_scan_actions: Optional[pulumi.Input['DatascanDataProfileSpecPostScanActionsArgs']] = None,
                 row_filter: Optional[pulumi.Input[str]] = None,
                 sampling_percent: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input['DatascanDataProfileSpecExcludeFieldsArgs'] exclude_fields: The fields to exclude from data profile.
               If specified, the fields will be excluded from data profile, regardless of `include_fields` value.
               Structure is documented below.
        :param pulumi.Input['DatascanDataProfileSpecIncludeFieldsArgs'] include_fields: The fields to include in data profile.
               If not specified, all fields at the time of profile scan job execution are included, except for ones listed in `exclude_fields`.
               Structure is documented below.
        :param pulumi.Input['DatascanDataProfileSpecPostScanActionsArgs'] post_scan_actions: Actions to take upon job completion.
               Structure is documented below.
        :param pulumi.Input[str] row_filter: A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        :param pulumi.Input[float] sampling_percent: The percentage of the records to be selected from the dataset for DataScan.
               Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
               Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        if exclude_fields is not None:
            pulumi.set(__self__, "exclude_fields", exclude_fields)
        if include_fields is not None:
            pulumi.set(__self__, "include_fields", include_fields)
        if post_scan_actions is not None:
            pulumi.set(__self__, "post_scan_actions", post_scan_actions)
        if row_filter is not None:
            pulumi.set(__self__, "row_filter", row_filter)
        if sampling_percent is not None:
            pulumi.set(__self__, "sampling_percent", sampling_percent)

    @property
    @pulumi.getter(name="excludeFields")
    def exclude_fields(self) -> Optional[pulumi.Input['DatascanDataProfileSpecExcludeFieldsArgs']]:
        """
        The fields to exclude from data profile.
        If specified, the fields will be excluded from data profile, regardless of `include_fields` value.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_fields")

    @exclude_fields.setter
    def exclude_fields(self, value: Optional[pulumi.Input['DatascanDataProfileSpecExcludeFieldsArgs']]):
        pulumi.set(self, "exclude_fields", value)

    @property
    @pulumi.getter(name="includeFields")
    def include_fields(self) -> Optional[pulumi.Input['DatascanDataProfileSpecIncludeFieldsArgs']]:
        """
        The fields to include in data profile.
        If not specified, all fields at the time of profile scan job execution are included, except for ones listed in `exclude_fields`.
        Structure is documented below.
        """
        return pulumi.get(self, "include_fields")

    @include_fields.setter
    def include_fields(self, value: Optional[pulumi.Input['DatascanDataProfileSpecIncludeFieldsArgs']]):
        pulumi.set(self, "include_fields", value)

    @property
    @pulumi.getter(name="postScanActions")
    def post_scan_actions(self) -> Optional[pulumi.Input['DatascanDataProfileSpecPostScanActionsArgs']]:
        """
        Actions to take upon job completion.
        Structure is documented below.
        """
        return pulumi.get(self, "post_scan_actions")

    @post_scan_actions.setter
    def post_scan_actions(self, value: Optional[pulumi.Input['DatascanDataProfileSpecPostScanActionsArgs']]):
        pulumi.set(self, "post_scan_actions", value)

    @property
    @pulumi.getter(name="rowFilter")
    def row_filter(self) -> Optional[pulumi.Input[str]]:
        """
        A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        """
        return pulumi.get(self, "row_filter")

    @row_filter.setter
    def row_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "row_filter", value)

    @property
    @pulumi.getter(name="samplingPercent")
    def sampling_percent(self) -> Optional[pulumi.Input[float]]:
        """
        The percentage of the records to be selected from the dataset for DataScan.
        Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
        Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        return pulumi.get(self, "sampling_percent")

    @sampling_percent.setter
    def sampling_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sampling_percent", value)


@pulumi.input_type
class DatascanDataProfileSpecExcludeFieldsArgs:
    def __init__(__self__, *,
                 field_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] field_names: Expected input is a list of fully qualified names of fields as in the schema.
               Only top-level field names for nested fields are supported.
               For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Expected input is a list of fully qualified names of fields as in the schema.
        Only top-level field names for nested fields are supported.
        For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        return pulumi.get(self, "field_names")

    @field_names.setter
    def field_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "field_names", value)


@pulumi.input_type
class DatascanDataProfileSpecIncludeFieldsArgs:
    def __init__(__self__, *,
                 field_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] field_names: Expected input is a list of fully qualified names of fields as in the schema.
               Only top-level field names for nested fields are supported.
               For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Expected input is a list of fully qualified names of fields as in the schema.
        Only top-level field names for nested fields are supported.
        For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
        """
        return pulumi.get(self, "field_names")

    @field_names.setter
    def field_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "field_names", value)


@pulumi.input_type
class DatascanDataProfileSpecPostScanActionsArgs:
    def __init__(__self__, *,
                 bigquery_export: Optional[pulumi.Input['DatascanDataProfileSpecPostScanActionsBigqueryExportArgs']] = None):
        """
        :param pulumi.Input['DatascanDataProfileSpecPostScanActionsBigqueryExportArgs'] bigquery_export: If set, results will be exported to the provided BigQuery table.
               Structure is documented below.
        """
        if bigquery_export is not None:
            pulumi.set(__self__, "bigquery_export", bigquery_export)

    @property
    @pulumi.getter(name="bigqueryExport")
    def bigquery_export(self) -> Optional[pulumi.Input['DatascanDataProfileSpecPostScanActionsBigqueryExportArgs']]:
        """
        If set, results will be exported to the provided BigQuery table.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_export")

    @bigquery_export.setter
    def bigquery_export(self, value: Optional[pulumi.Input['DatascanDataProfileSpecPostScanActionsBigqueryExportArgs']]):
        pulumi.set(self, "bigquery_export", value)


@pulumi.input_type
class DatascanDataProfileSpecPostScanActionsBigqueryExportArgs:
    def __init__(__self__, *,
                 results_table: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] results_table: The BigQuery table to export DataProfileScan results to.
               Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        if results_table is not None:
            pulumi.set(__self__, "results_table", results_table)

    @property
    @pulumi.getter(name="resultsTable")
    def results_table(self) -> Optional[pulumi.Input[str]]:
        """
        The BigQuery table to export DataProfileScan results to.
        Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        return pulumi.get(self, "results_table")

    @results_table.setter
    def results_table(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "results_table", value)


@pulumi.input_type
class DatascanDataQualityResultArgs:
    def __init__(__self__, *,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultDimensionArgs']]]] = None,
                 passed: Optional[pulumi.Input[bool]] = None,
                 row_count: Optional[pulumi.Input[str]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleArgs']]]] = None,
                 scanned_datas: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultScannedDataArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultDimensionArgs']]] dimensions: A list of results at the dimension level.
               Structure is documented below.
        :param pulumi.Input[bool] passed: (Output)
               Whether the rule passed or failed.
        :param pulumi.Input[str] row_count: The count of rows scanned.
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleArgs']]] rules: The list of rules to evaluate against a data source. At least one rule is required.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultScannedDataArgs']]] scanned_datas: (Output)
               The data scanned for this result.
               Structure is documented below.
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if passed is not None:
            pulumi.set(__self__, "passed", passed)
        if row_count is not None:
            pulumi.set(__self__, "row_count", row_count)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if scanned_datas is not None:
            pulumi.set(__self__, "scanned_datas", scanned_datas)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultDimensionArgs']]]]:
        """
        A list of results at the dimension level.
        Structure is documented below.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter
    def passed(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether the rule passed or failed.
        """
        return pulumi.get(self, "passed")

    @passed.setter
    def passed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "passed", value)

    @property
    @pulumi.getter(name="rowCount")
    def row_count(self) -> Optional[pulumi.Input[str]]:
        """
        The count of rows scanned.
        """
        return pulumi.get(self, "row_count")

    @row_count.setter
    def row_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "row_count", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleArgs']]]]:
        """
        The list of rules to evaluate against a data source. At least one rule is required.
        Structure is documented below.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter(name="scannedDatas")
    def scanned_datas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultScannedDataArgs']]]]:
        """
        (Output)
        The data scanned for this result.
        Structure is documented below.
        """
        return pulumi.get(self, "scanned_datas")

    @scanned_datas.setter
    def scanned_datas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultScannedDataArgs']]]]):
        pulumi.set(self, "scanned_datas", value)


@pulumi.input_type
class DatascanDataQualityResultDimensionArgs:
    def __init__(__self__, *,
                 passed: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] passed: (Output)
               Whether the rule passed or failed.
        """
        if passed is not None:
            pulumi.set(__self__, "passed", passed)

    @property
    @pulumi.getter
    def passed(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether the rule passed or failed.
        """
        return pulumi.get(self, "passed")

    @passed.setter
    def passed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "passed", value)


@pulumi.input_type
class DatascanDataQualityResultRuleArgs:
    def __init__(__self__, *,
                 evaluated_count: Optional[pulumi.Input[str]] = None,
                 failing_rows_query: Optional[pulumi.Input[str]] = None,
                 null_count: Optional[pulumi.Input[str]] = None,
                 pass_ratio: Optional[pulumi.Input[int]] = None,
                 passed: Optional[pulumi.Input[bool]] = None,
                 passed_count: Optional[pulumi.Input[str]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] evaluated_count: (Output)
               The number of rows a rule was evaluated against. This field is only valid for ColumnMap type rules.
               Evaluated count can be configured to either
               1. include all rows (default) - with null rows automatically failing rule evaluation, or
               2. exclude null rows from the evaluatedCount, by setting ignore_nulls = true.
        :param pulumi.Input[str] failing_rows_query: (Output)
               The query to find rows that did not pass this rule. Only applies to ColumnMap and RowCondition rules.
        :param pulumi.Input[str] null_count: (Output)
               The number of rows with null values in the specified column.
        :param pulumi.Input[int] pass_ratio: (Output)
               The ratio of passedCount / evaluatedCount. This field is only valid for ColumnMap type rules.
        :param pulumi.Input[bool] passed: (Output)
               Whether the rule passed or failed.
        :param pulumi.Input[str] passed_count: (Output)
               The number of rows which passed a rule evaluation. This field is only valid for ColumnMap type rules.
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleArgs']]] rules: (Output)
               The rule specified in the DataQualitySpec, as is.
               Structure is documented below.
        """
        if evaluated_count is not None:
            pulumi.set(__self__, "evaluated_count", evaluated_count)
        if failing_rows_query is not None:
            pulumi.set(__self__, "failing_rows_query", failing_rows_query)
        if null_count is not None:
            pulumi.set(__self__, "null_count", null_count)
        if pass_ratio is not None:
            pulumi.set(__self__, "pass_ratio", pass_ratio)
        if passed is not None:
            pulumi.set(__self__, "passed", passed)
        if passed_count is not None:
            pulumi.set(__self__, "passed_count", passed_count)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="evaluatedCount")
    def evaluated_count(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The number of rows a rule was evaluated against. This field is only valid for ColumnMap type rules.
        Evaluated count can be configured to either
        1. include all rows (default) - with null rows automatically failing rule evaluation, or
        2. exclude null rows from the evaluatedCount, by setting ignore_nulls = true.
        """
        return pulumi.get(self, "evaluated_count")

    @evaluated_count.setter
    def evaluated_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluated_count", value)

    @property
    @pulumi.getter(name="failingRowsQuery")
    def failing_rows_query(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The query to find rows that did not pass this rule. Only applies to ColumnMap and RowCondition rules.
        """
        return pulumi.get(self, "failing_rows_query")

    @failing_rows_query.setter
    def failing_rows_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failing_rows_query", value)

    @property
    @pulumi.getter(name="nullCount")
    def null_count(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The number of rows with null values in the specified column.
        """
        return pulumi.get(self, "null_count")

    @null_count.setter
    def null_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "null_count", value)

    @property
    @pulumi.getter(name="passRatio")
    def pass_ratio(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        The ratio of passedCount / evaluatedCount. This field is only valid for ColumnMap type rules.
        """
        return pulumi.get(self, "pass_ratio")

    @pass_ratio.setter
    def pass_ratio(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pass_ratio", value)

    @property
    @pulumi.getter
    def passed(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether the rule passed or failed.
        """
        return pulumi.get(self, "passed")

    @passed.setter
    def passed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "passed", value)

    @property
    @pulumi.getter(name="passedCount")
    def passed_count(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The number of rows which passed a rule evaluation. This field is only valid for ColumnMap type rules.
        """
        return pulumi.get(self, "passed_count")

    @passed_count.setter
    def passed_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "passed_count", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleArgs']]]]:
        """
        (Output)
        The rule specified in the DataQualitySpec, as is.
        Structure is documented below.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class DatascanDataQualityResultRuleRuleArgs:
    def __init__(__self__, *,
                 column: Optional[pulumi.Input[str]] = None,
                 dimension: Optional[pulumi.Input[str]] = None,
                 ignore_null: Optional[pulumi.Input[bool]] = None,
                 non_null_expectations: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleNonNullExpectationArgs']]]] = None,
                 range_expectations: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleRangeExpectationArgs']]]] = None,
                 regex_expectations: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleRegexExpectationArgs']]]] = None,
                 row_condition_expectations: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleRowConditionExpectationArgs']]]] = None,
                 set_expectations: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleSetExpectationArgs']]]] = None,
                 statistic_range_expectations: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleStatisticRangeExpectationArgs']]]] = None,
                 table_condition_expectations: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleTableConditionExpectationArgs']]]] = None,
                 threshold: Optional[pulumi.Input[int]] = None,
                 uniqueness_expectations: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleUniquenessExpectationArgs']]]] = None):
        """
        :param pulumi.Input[str] column: The unnested column which this rule is evaluated against.
        :param pulumi.Input[str] dimension: The dimension a rule belongs to. Results are also aggregated at the dimension level. Supported dimensions are ["COMPLETENESS", "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "INTEGRITY"]
        :param pulumi.Input[bool] ignore_null: Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleNonNullExpectationArgs']]] non_null_expectations: ColumnMap rule which evaluates whether each column value is null.
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleRangeExpectationArgs']]] range_expectations: ColumnMap rule which evaluates whether each column value lies between a specified range.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleRegexExpectationArgs']]] regex_expectations: ColumnMap rule which evaluates whether each column value matches a specified regex.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleRowConditionExpectationArgs']]] row_condition_expectations: Table rule which evaluates whether each row passes the specified condition.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleSetExpectationArgs']]] set_expectations: ColumnMap rule which evaluates whether each column value is contained by a specified set.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleStatisticRangeExpectationArgs']]] statistic_range_expectations: ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleTableConditionExpectationArgs']]] table_condition_expectations: Table rule which evaluates whether the provided expression is true.
               Structure is documented below.
        :param pulumi.Input[int] threshold: The minimum ratio of passing_rows / total_rows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0).
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleUniquenessExpectationArgs']]] uniqueness_expectations: Row-level rule which evaluates whether each column value is unique.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if ignore_null is not None:
            pulumi.set(__self__, "ignore_null", ignore_null)
        if non_null_expectations is not None:
            pulumi.set(__self__, "non_null_expectations", non_null_expectations)
        if range_expectations is not None:
            pulumi.set(__self__, "range_expectations", range_expectations)
        if regex_expectations is not None:
            pulumi.set(__self__, "regex_expectations", regex_expectations)
        if row_condition_expectations is not None:
            pulumi.set(__self__, "row_condition_expectations", row_condition_expectations)
        if set_expectations is not None:
            pulumi.set(__self__, "set_expectations", set_expectations)
        if statistic_range_expectations is not None:
            pulumi.set(__self__, "statistic_range_expectations", statistic_range_expectations)
        if table_condition_expectations is not None:
            pulumi.set(__self__, "table_condition_expectations", table_condition_expectations)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if uniqueness_expectations is not None:
            pulumi.set(__self__, "uniqueness_expectations", uniqueness_expectations)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        The unnested column which this rule is evaluated against.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input[str]]:
        """
        The dimension a rule belongs to. Results are also aggregated at the dimension level. Supported dimensions are ["COMPLETENESS", "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "INTEGRITY"]
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter(name="ignoreNull")
    def ignore_null(self) -> Optional[pulumi.Input[bool]]:
        """
        Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
        """
        return pulumi.get(self, "ignore_null")

    @ignore_null.setter
    def ignore_null(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_null", value)

    @property
    @pulumi.getter(name="nonNullExpectations")
    def non_null_expectations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleNonNullExpectationArgs']]]]:
        """
        ColumnMap rule which evaluates whether each column value is null.
        """
        return pulumi.get(self, "non_null_expectations")

    @non_null_expectations.setter
    def non_null_expectations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleNonNullExpectationArgs']]]]):
        pulumi.set(self, "non_null_expectations", value)

    @property
    @pulumi.getter(name="rangeExpectations")
    def range_expectations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleRangeExpectationArgs']]]]:
        """
        ColumnMap rule which evaluates whether each column value lies between a specified range.
        Structure is documented below.
        """
        return pulumi.get(self, "range_expectations")

    @range_expectations.setter
    def range_expectations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleRangeExpectationArgs']]]]):
        pulumi.set(self, "range_expectations", value)

    @property
    @pulumi.getter(name="regexExpectations")
    def regex_expectations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleRegexExpectationArgs']]]]:
        """
        ColumnMap rule which evaluates whether each column value matches a specified regex.
        Structure is documented below.
        """
        return pulumi.get(self, "regex_expectations")

    @regex_expectations.setter
    def regex_expectations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleRegexExpectationArgs']]]]):
        pulumi.set(self, "regex_expectations", value)

    @property
    @pulumi.getter(name="rowConditionExpectations")
    def row_condition_expectations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleRowConditionExpectationArgs']]]]:
        """
        Table rule which evaluates whether each row passes the specified condition.
        Structure is documented below.
        """
        return pulumi.get(self, "row_condition_expectations")

    @row_condition_expectations.setter
    def row_condition_expectations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleRowConditionExpectationArgs']]]]):
        pulumi.set(self, "row_condition_expectations", value)

    @property
    @pulumi.getter(name="setExpectations")
    def set_expectations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleSetExpectationArgs']]]]:
        """
        ColumnMap rule which evaluates whether each column value is contained by a specified set.
        Structure is documented below.
        """
        return pulumi.get(self, "set_expectations")

    @set_expectations.setter
    def set_expectations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleSetExpectationArgs']]]]):
        pulumi.set(self, "set_expectations", value)

    @property
    @pulumi.getter(name="statisticRangeExpectations")
    def statistic_range_expectations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleStatisticRangeExpectationArgs']]]]:
        """
        ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
        Structure is documented below.
        """
        return pulumi.get(self, "statistic_range_expectations")

    @statistic_range_expectations.setter
    def statistic_range_expectations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleStatisticRangeExpectationArgs']]]]):
        pulumi.set(self, "statistic_range_expectations", value)

    @property
    @pulumi.getter(name="tableConditionExpectations")
    def table_condition_expectations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleTableConditionExpectationArgs']]]]:
        """
        Table rule which evaluates whether the provided expression is true.
        Structure is documented below.
        """
        return pulumi.get(self, "table_condition_expectations")

    @table_condition_expectations.setter
    def table_condition_expectations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleTableConditionExpectationArgs']]]]):
        pulumi.set(self, "table_condition_expectations", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum ratio of passing_rows / total_rows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0).
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="uniquenessExpectations")
    def uniqueness_expectations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleUniquenessExpectationArgs']]]]:
        """
        Row-level rule which evaluates whether each column value is unique.
        """
        return pulumi.get(self, "uniqueness_expectations")

    @uniqueness_expectations.setter
    def uniqueness_expectations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualityResultRuleRuleUniquenessExpectationArgs']]]]):
        pulumi.set(self, "uniqueness_expectations", value)


@pulumi.input_type
class DatascanDataQualityResultRuleRuleNonNullExpectationArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DatascanDataQualityResultRuleRuleRangeExpectationArgs:
    def __init__(__self__, *,
                 max_value: Optional[pulumi.Input[str]] = None,
                 min_value: Optional[pulumi.Input[str]] = None,
                 strict_max_enabled: Optional[pulumi.Input[bool]] = None,
                 strict_min_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] max_value: The maximum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        :param pulumi.Input[str] min_value: The minimum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        :param pulumi.Input[bool] strict_max_enabled: Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
               Only relevant if a maxValue has been defined. Default = false.
        :param pulumi.Input[bool] strict_min_enabled: Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
               Only relevant if a minValue has been defined. Default = false.
        """
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if strict_max_enabled is not None:
            pulumi.set(__self__, "strict_max_enabled", strict_max_enabled)
        if strict_min_enabled is not None:
            pulumi.set(__self__, "strict_min_enabled", strict_min_enabled)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_value", value)

    @property
    @pulumi.getter(name="strictMaxEnabled")
    def strict_max_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        Only relevant if a maxValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_max_enabled")

    @strict_max_enabled.setter
    def strict_max_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_max_enabled", value)

    @property
    @pulumi.getter(name="strictMinEnabled")
    def strict_min_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        Only relevant if a minValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_min_enabled")

    @strict_min_enabled.setter
    def strict_min_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_min_enabled", value)


@pulumi.input_type
class DatascanDataQualityResultRuleRuleRegexExpectationArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] regex: A regular expression the column value is expected to match.
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A regular expression the column value is expected to match.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class DatascanDataQualityResultRuleRuleRowConditionExpectationArgs:
    def __init__(__self__, *,
                 sql_expression: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] sql_expression: The SQL expression.
        """
        if sql_expression is not None:
            pulumi.set(__self__, "sql_expression", sql_expression)

    @property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> Optional[pulumi.Input[str]]:
        """
        The SQL expression.
        """
        return pulumi.get(self, "sql_expression")

    @sql_expression.setter
    def sql_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_expression", value)


@pulumi.input_type
class DatascanDataQualityResultRuleRuleSetExpectationArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Expected values for the column value.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Expected values for the column value.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class DatascanDataQualityResultRuleRuleStatisticRangeExpectationArgs:
    def __init__(__self__, *,
                 max_value: Optional[pulumi.Input[str]] = None,
                 min_value: Optional[pulumi.Input[str]] = None,
                 statistic: Optional[pulumi.Input[str]] = None,
                 strict_max_enabled: Optional[pulumi.Input[bool]] = None,
                 strict_min_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] max_value: The maximum column statistic value allowed for a row to pass this validation.
               At least one of minValue and maxValue need to be provided.
        :param pulumi.Input[str] min_value: The minimum column statistic value allowed for a row to pass this validation.
               At least one of minValue and maxValue need to be provided.
        :param pulumi.Input[str] statistic: column statistics.
               Possible values are: `STATISTIC_UNDEFINED`, `MEAN`, `MIN`, `MAX`.
        :param pulumi.Input[bool] strict_max_enabled: Whether column statistic needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
               Only relevant if a maxValue has been defined. Default = false.
        :param pulumi.Input[bool] strict_min_enabled: Whether column statistic needs to be strictly greater than ('>') the minimum, or if equality is allowed.
               Only relevant if a minValue has been defined. Default = false.
        """
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if strict_max_enabled is not None:
            pulumi.set(__self__, "strict_max_enabled", strict_max_enabled)
        if strict_min_enabled is not None:
            pulumi.set(__self__, "strict_min_enabled", strict_min_enabled)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum column statistic value allowed for a row to pass this validation.
        At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum column statistic value allowed for a row to pass this validation.
        At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_value", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[str]]:
        """
        column statistics.
        Possible values are: `STATISTIC_UNDEFINED`, `MEAN`, `MIN`, `MAX`.
        """
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter(name="strictMaxEnabled")
    def strict_max_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether column statistic needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        Only relevant if a maxValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_max_enabled")

    @strict_max_enabled.setter
    def strict_max_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_max_enabled", value)

    @property
    @pulumi.getter(name="strictMinEnabled")
    def strict_min_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether column statistic needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        Only relevant if a minValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_min_enabled")

    @strict_min_enabled.setter
    def strict_min_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_min_enabled", value)


@pulumi.input_type
class DatascanDataQualityResultRuleRuleTableConditionExpectationArgs:
    def __init__(__self__, *,
                 sql_expression: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] sql_expression: The SQL expression.
        """
        if sql_expression is not None:
            pulumi.set(__self__, "sql_expression", sql_expression)

    @property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> Optional[pulumi.Input[str]]:
        """
        The SQL expression.
        """
        return pulumi.get(self, "sql_expression")

    @sql_expression.setter
    def sql_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_expression", value)


@pulumi.input_type
class DatascanDataQualityResultRuleRuleUniquenessExpectationArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DatascanDataQualityResultScannedDataArgs:
    def __init__(__self__, *,
                 incremental_field: Optional[pulumi.Input['DatascanDataQualityResultScannedDataIncrementalFieldArgs']] = None):
        """
        :param pulumi.Input['DatascanDataQualityResultScannedDataIncrementalFieldArgs'] incremental_field: The range denoted by values of an incremental field
               Structure is documented below.
        """
        if incremental_field is not None:
            pulumi.set(__self__, "incremental_field", incremental_field)

    @property
    @pulumi.getter(name="incrementalField")
    def incremental_field(self) -> Optional[pulumi.Input['DatascanDataQualityResultScannedDataIncrementalFieldArgs']]:
        """
        The range denoted by values of an incremental field
        Structure is documented below.
        """
        return pulumi.get(self, "incremental_field")

    @incremental_field.setter
    def incremental_field(self, value: Optional[pulumi.Input['DatascanDataQualityResultScannedDataIncrementalFieldArgs']]):
        pulumi.set(self, "incremental_field", value)


@pulumi.input_type
class DatascanDataQualityResultScannedDataIncrementalFieldArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[str]] = None,
                 field: Optional[pulumi.Input[str]] = None,
                 start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] end: Value that marks the end of the range.
        :param pulumi.Input[str] field: The unnested field (of type Date or Timestamp) that contains values which monotonically increase over time. If not specified, a data scan will run for all data in the table.
        :param pulumi.Input[str] start: Value that marks the start of the range.
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[str]]:
        """
        Value that marks the end of the range.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        The unnested field (of type Date or Timestamp) that contains values which monotonically increase over time. If not specified, a data scan will run for all data in the table.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[str]]:
        """
        Value that marks the start of the range.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class DatascanDataQualitySpecArgs:
    def __init__(__self__, *,
                 post_scan_actions: Optional[pulumi.Input['DatascanDataQualitySpecPostScanActionsArgs']] = None,
                 row_filter: Optional[pulumi.Input[str]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualitySpecRuleArgs']]]] = None,
                 sampling_percent: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input['DatascanDataQualitySpecPostScanActionsArgs'] post_scan_actions: Actions to take upon job completion.
               Structure is documented below.
        :param pulumi.Input[str] row_filter: A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        :param pulumi.Input[Sequence[pulumi.Input['DatascanDataQualitySpecRuleArgs']]] rules: The list of rules to evaluate against a data source. At least one rule is required.
               Structure is documented below.
        :param pulumi.Input[float] sampling_percent: The percentage of the records to be selected from the dataset for DataScan.
               Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
               Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        if post_scan_actions is not None:
            pulumi.set(__self__, "post_scan_actions", post_scan_actions)
        if row_filter is not None:
            pulumi.set(__self__, "row_filter", row_filter)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if sampling_percent is not None:
            pulumi.set(__self__, "sampling_percent", sampling_percent)

    @property
    @pulumi.getter(name="postScanActions")
    def post_scan_actions(self) -> Optional[pulumi.Input['DatascanDataQualitySpecPostScanActionsArgs']]:
        """
        Actions to take upon job completion.
        Structure is documented below.
        """
        return pulumi.get(self, "post_scan_actions")

    @post_scan_actions.setter
    def post_scan_actions(self, value: Optional[pulumi.Input['DatascanDataQualitySpecPostScanActionsArgs']]):
        pulumi.set(self, "post_scan_actions", value)

    @property
    @pulumi.getter(name="rowFilter")
    def row_filter(self) -> Optional[pulumi.Input[str]]:
        """
        A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
        """
        return pulumi.get(self, "row_filter")

    @row_filter.setter
    def row_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "row_filter", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualitySpecRuleArgs']]]]:
        """
        The list of rules to evaluate against a data source. At least one rule is required.
        Structure is documented below.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatascanDataQualitySpecRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter(name="samplingPercent")
    def sampling_percent(self) -> Optional[pulumi.Input[float]]:
        """
        The percentage of the records to be selected from the dataset for DataScan.
        Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
        Sampling is not applied if `sampling_percent` is not specified, 0 or 100.
        """
        return pulumi.get(self, "sampling_percent")

    @sampling_percent.setter
    def sampling_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sampling_percent", value)


@pulumi.input_type
class DatascanDataQualitySpecPostScanActionsArgs:
    def __init__(__self__, *,
                 bigquery_export: Optional[pulumi.Input['DatascanDataQualitySpecPostScanActionsBigqueryExportArgs']] = None):
        """
        :param pulumi.Input['DatascanDataQualitySpecPostScanActionsBigqueryExportArgs'] bigquery_export: If set, results will be exported to the provided BigQuery table.
               Structure is documented below.
        """
        if bigquery_export is not None:
            pulumi.set(__self__, "bigquery_export", bigquery_export)

    @property
    @pulumi.getter(name="bigqueryExport")
    def bigquery_export(self) -> Optional[pulumi.Input['DatascanDataQualitySpecPostScanActionsBigqueryExportArgs']]:
        """
        If set, results will be exported to the provided BigQuery table.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_export")

    @bigquery_export.setter
    def bigquery_export(self, value: Optional[pulumi.Input['DatascanDataQualitySpecPostScanActionsBigqueryExportArgs']]):
        pulumi.set(self, "bigquery_export", value)


@pulumi.input_type
class DatascanDataQualitySpecPostScanActionsBigqueryExportArgs:
    def __init__(__self__, *,
                 results_table: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] results_table: The BigQuery table to export DataProfileScan results to.
               Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        if results_table is not None:
            pulumi.set(__self__, "results_table", results_table)

    @property
    @pulumi.getter(name="resultsTable")
    def results_table(self) -> Optional[pulumi.Input[str]]:
        """
        The BigQuery table to export DataProfileScan results to.
        Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        """
        return pulumi.get(self, "results_table")

    @results_table.setter
    def results_table(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "results_table", value)


@pulumi.input_type
class DatascanDataQualitySpecRuleArgs:
    def __init__(__self__, *,
                 dimension: pulumi.Input[str],
                 column: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ignore_null: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 non_null_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleNonNullExpectationArgs']] = None,
                 range_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleRangeExpectationArgs']] = None,
                 regex_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleRegexExpectationArgs']] = None,
                 row_condition_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleRowConditionExpectationArgs']] = None,
                 set_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleSetExpectationArgs']] = None,
                 statistic_range_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleStatisticRangeExpectationArgs']] = None,
                 table_condition_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleTableConditionExpectationArgs']] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 uniqueness_expectation: Optional[pulumi.Input['DatascanDataQualitySpecRuleUniquenessExpectationArgs']] = None):
        """
        :param pulumi.Input[str] dimension: The dimension a rule belongs to. Results are also aggregated at the dimension level. Supported dimensions are ["COMPLETENESS", "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "INTEGRITY"]
        :param pulumi.Input[str] column: The unnested column which this rule is evaluated against.
        :param pulumi.Input[str] description: Description of the rule.
               The maximum length is 1,024 characters.
        :param pulumi.Input[bool] ignore_null: Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
        :param pulumi.Input[str] name: A mutable name for the rule.
               The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
               The maximum length is 63 characters.
               Must start with a letter.
               Must end with a number or a letter.
        :param pulumi.Input['DatascanDataQualitySpecRuleNonNullExpectationArgs'] non_null_expectation: ColumnMap rule which evaluates whether each column value is null.
        :param pulumi.Input['DatascanDataQualitySpecRuleRangeExpectationArgs'] range_expectation: ColumnMap rule which evaluates whether each column value lies between a specified range.
               Structure is documented below.
        :param pulumi.Input['DatascanDataQualitySpecRuleRegexExpectationArgs'] regex_expectation: ColumnMap rule which evaluates whether each column value matches a specified regex.
               Structure is documented below.
        :param pulumi.Input['DatascanDataQualitySpecRuleRowConditionExpectationArgs'] row_condition_expectation: Table rule which evaluates whether each row passes the specified condition.
               Structure is documented below.
        :param pulumi.Input['DatascanDataQualitySpecRuleSetExpectationArgs'] set_expectation: ColumnMap rule which evaluates whether each column value is contained by a specified set.
               Structure is documented below.
        :param pulumi.Input['DatascanDataQualitySpecRuleStatisticRangeExpectationArgs'] statistic_range_expectation: ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
               Structure is documented below.
        :param pulumi.Input['DatascanDataQualitySpecRuleTableConditionExpectationArgs'] table_condition_expectation: Table rule which evaluates whether the provided expression is true.
               Structure is documented below.
        :param pulumi.Input[float] threshold: The minimum ratio of passing_rows / total_rows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0).
        :param pulumi.Input['DatascanDataQualitySpecRuleUniquenessExpectationArgs'] uniqueness_expectation: Row-level rule which evaluates whether each column value is unique.
        """
        pulumi.set(__self__, "dimension", dimension)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ignore_null is not None:
            pulumi.set(__self__, "ignore_null", ignore_null)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if non_null_expectation is not None:
            pulumi.set(__self__, "non_null_expectation", non_null_expectation)
        if range_expectation is not None:
            pulumi.set(__self__, "range_expectation", range_expectation)
        if regex_expectation is not None:
            pulumi.set(__self__, "regex_expectation", regex_expectation)
        if row_condition_expectation is not None:
            pulumi.set(__self__, "row_condition_expectation", row_condition_expectation)
        if set_expectation is not None:
            pulumi.set(__self__, "set_expectation", set_expectation)
        if statistic_range_expectation is not None:
            pulumi.set(__self__, "statistic_range_expectation", statistic_range_expectation)
        if table_condition_expectation is not None:
            pulumi.set(__self__, "table_condition_expectation", table_condition_expectation)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if uniqueness_expectation is not None:
            pulumi.set(__self__, "uniqueness_expectation", uniqueness_expectation)

    @property
    @pulumi.getter
    def dimension(self) -> pulumi.Input[str]:
        """
        The dimension a rule belongs to. Results are also aggregated at the dimension level. Supported dimensions are ["COMPLETENESS", "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "INTEGRITY"]
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: pulumi.Input[str]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        The unnested column which this rule is evaluated against.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the rule.
        The maximum length is 1,024 characters.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="ignoreNull")
    def ignore_null(self) -> Optional[pulumi.Input[bool]]:
        """
        Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
        """
        return pulumi.get(self, "ignore_null")

    @ignore_null.setter
    def ignore_null(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_null", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A mutable name for the rule.
        The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
        The maximum length is 63 characters.
        Must start with a letter.
        Must end with a number or a letter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nonNullExpectation")
    def non_null_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleNonNullExpectationArgs']]:
        """
        ColumnMap rule which evaluates whether each column value is null.
        """
        return pulumi.get(self, "non_null_expectation")

    @non_null_expectation.setter
    def non_null_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleNonNullExpectationArgs']]):
        pulumi.set(self, "non_null_expectation", value)

    @property
    @pulumi.getter(name="rangeExpectation")
    def range_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleRangeExpectationArgs']]:
        """
        ColumnMap rule which evaluates whether each column value lies between a specified range.
        Structure is documented below.
        """
        return pulumi.get(self, "range_expectation")

    @range_expectation.setter
    def range_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleRangeExpectationArgs']]):
        pulumi.set(self, "range_expectation", value)

    @property
    @pulumi.getter(name="regexExpectation")
    def regex_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleRegexExpectationArgs']]:
        """
        ColumnMap rule which evaluates whether each column value matches a specified regex.
        Structure is documented below.
        """
        return pulumi.get(self, "regex_expectation")

    @regex_expectation.setter
    def regex_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleRegexExpectationArgs']]):
        pulumi.set(self, "regex_expectation", value)

    @property
    @pulumi.getter(name="rowConditionExpectation")
    def row_condition_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleRowConditionExpectationArgs']]:
        """
        Table rule which evaluates whether each row passes the specified condition.
        Structure is documented below.
        """
        return pulumi.get(self, "row_condition_expectation")

    @row_condition_expectation.setter
    def row_condition_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleRowConditionExpectationArgs']]):
        pulumi.set(self, "row_condition_expectation", value)

    @property
    @pulumi.getter(name="setExpectation")
    def set_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleSetExpectationArgs']]:
        """
        ColumnMap rule which evaluates whether each column value is contained by a specified set.
        Structure is documented below.
        """
        return pulumi.get(self, "set_expectation")

    @set_expectation.setter
    def set_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleSetExpectationArgs']]):
        pulumi.set(self, "set_expectation", value)

    @property
    @pulumi.getter(name="statisticRangeExpectation")
    def statistic_range_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleStatisticRangeExpectationArgs']]:
        """
        ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
        Structure is documented below.
        """
        return pulumi.get(self, "statistic_range_expectation")

    @statistic_range_expectation.setter
    def statistic_range_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleStatisticRangeExpectationArgs']]):
        pulumi.set(self, "statistic_range_expectation", value)

    @property
    @pulumi.getter(name="tableConditionExpectation")
    def table_condition_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleTableConditionExpectationArgs']]:
        """
        Table rule which evaluates whether the provided expression is true.
        Structure is documented below.
        """
        return pulumi.get(self, "table_condition_expectation")

    @table_condition_expectation.setter
    def table_condition_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleTableConditionExpectationArgs']]):
        pulumi.set(self, "table_condition_expectation", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The minimum ratio of passing_rows / total_rows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0).
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="uniquenessExpectation")
    def uniqueness_expectation(self) -> Optional[pulumi.Input['DatascanDataQualitySpecRuleUniquenessExpectationArgs']]:
        """
        Row-level rule which evaluates whether each column value is unique.
        """
        return pulumi.get(self, "uniqueness_expectation")

    @uniqueness_expectation.setter
    def uniqueness_expectation(self, value: Optional[pulumi.Input['DatascanDataQualitySpecRuleUniquenessExpectationArgs']]):
        pulumi.set(self, "uniqueness_expectation", value)


@pulumi.input_type
class DatascanDataQualitySpecRuleNonNullExpectationArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DatascanDataQualitySpecRuleRangeExpectationArgs:
    def __init__(__self__, *,
                 max_value: Optional[pulumi.Input[str]] = None,
                 min_value: Optional[pulumi.Input[str]] = None,
                 strict_max_enabled: Optional[pulumi.Input[bool]] = None,
                 strict_min_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] max_value: The maximum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        :param pulumi.Input[str] min_value: The minimum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        :param pulumi.Input[bool] strict_max_enabled: Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
               Only relevant if a maxValue has been defined. Default = false.
        :param pulumi.Input[bool] strict_min_enabled: Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
               Only relevant if a minValue has been defined. Default = false.
        """
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if strict_max_enabled is not None:
            pulumi.set(__self__, "strict_max_enabled", strict_max_enabled)
        if strict_min_enabled is not None:
            pulumi.set(__self__, "strict_min_enabled", strict_min_enabled)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_value", value)

    @property
    @pulumi.getter(name="strictMaxEnabled")
    def strict_max_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        Only relevant if a maxValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_max_enabled")

    @strict_max_enabled.setter
    def strict_max_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_max_enabled", value)

    @property
    @pulumi.getter(name="strictMinEnabled")
    def strict_min_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        Only relevant if a minValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_min_enabled")

    @strict_min_enabled.setter
    def strict_min_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_min_enabled", value)


@pulumi.input_type
class DatascanDataQualitySpecRuleRegexExpectationArgs:
    def __init__(__self__, *,
                 regex: pulumi.Input[str]):
        """
        :param pulumi.Input[str] regex: A regular expression the column value is expected to match.
        """
        pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def regex(self) -> pulumi.Input[str]:
        """
        A regular expression the column value is expected to match.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class DatascanDataQualitySpecRuleRowConditionExpectationArgs:
    def __init__(__self__, *,
                 sql_expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] sql_expression: The SQL expression.
        """
        pulumi.set(__self__, "sql_expression", sql_expression)

    @property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> pulumi.Input[str]:
        """
        The SQL expression.
        """
        return pulumi.get(self, "sql_expression")

    @sql_expression.setter
    def sql_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "sql_expression", value)


@pulumi.input_type
class DatascanDataQualitySpecRuleSetExpectationArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Expected values for the column value.
        """
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Expected values for the column value.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class DatascanDataQualitySpecRuleStatisticRangeExpectationArgs:
    def __init__(__self__, *,
                 statistic: pulumi.Input[str],
                 max_value: Optional[pulumi.Input[str]] = None,
                 min_value: Optional[pulumi.Input[str]] = None,
                 strict_max_enabled: Optional[pulumi.Input[bool]] = None,
                 strict_min_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] statistic: column statistics.
               Possible values are: `STATISTIC_UNDEFINED`, `MEAN`, `MIN`, `MAX`.
        :param pulumi.Input[str] max_value: The maximum column statistic value allowed for a row to pass this validation.
               At least one of minValue and maxValue need to be provided.
        :param pulumi.Input[str] min_value: The minimum column statistic value allowed for a row to pass this validation.
               At least one of minValue and maxValue need to be provided.
        :param pulumi.Input[bool] strict_max_enabled: Whether column statistic needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
               Only relevant if a maxValue has been defined. Default = false.
        :param pulumi.Input[bool] strict_min_enabled: Whether column statistic needs to be strictly greater than ('>') the minimum, or if equality is allowed.
               Only relevant if a minValue has been defined. Default = false.
        """
        pulumi.set(__self__, "statistic", statistic)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if strict_max_enabled is not None:
            pulumi.set(__self__, "strict_max_enabled", strict_max_enabled)
        if strict_min_enabled is not None:
            pulumi.set(__self__, "strict_min_enabled", strict_min_enabled)

    @property
    @pulumi.getter
    def statistic(self) -> pulumi.Input[str]:
        """
        column statistics.
        Possible values are: `STATISTIC_UNDEFINED`, `MEAN`, `MIN`, `MAX`.
        """
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: pulumi.Input[str]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum column statistic value allowed for a row to pass this validation.
        At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum column statistic value allowed for a row to pass this validation.
        At least one of minValue and maxValue need to be provided.
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_value", value)

    @property
    @pulumi.getter(name="strictMaxEnabled")
    def strict_max_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether column statistic needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
        Only relevant if a maxValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_max_enabled")

    @strict_max_enabled.setter
    def strict_max_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_max_enabled", value)

    @property
    @pulumi.getter(name="strictMinEnabled")
    def strict_min_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether column statistic needs to be strictly greater than ('>') the minimum, or if equality is allowed.
        Only relevant if a minValue has been defined. Default = false.
        """
        return pulumi.get(self, "strict_min_enabled")

    @strict_min_enabled.setter
    def strict_min_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_min_enabled", value)


@pulumi.input_type
class DatascanDataQualitySpecRuleTableConditionExpectationArgs:
    def __init__(__self__, *,
                 sql_expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] sql_expression: The SQL expression.
        """
        pulumi.set(__self__, "sql_expression", sql_expression)

    @property
    @pulumi.getter(name="sqlExpression")
    def sql_expression(self) -> pulumi.Input[str]:
        """
        The SQL expression.
        """
        return pulumi.get(self, "sql_expression")

    @sql_expression.setter
    def sql_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "sql_expression", value)


@pulumi.input_type
class DatascanDataQualitySpecRuleUniquenessExpectationArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DatascanExecutionSpecArgs:
    def __init__(__self__, *,
                 trigger: pulumi.Input['DatascanExecutionSpecTriggerArgs'],
                 field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DatascanExecutionSpecTriggerArgs'] trigger: Spec related to how often and when a scan should be triggered.
               Structure is documented below.
        :param pulumi.Input[str] field: The unnested field (of type Date or Timestamp) that contains values which monotonically increase over time. If not specified, a data scan will run for all data in the table.
        """
        pulumi.set(__self__, "trigger", trigger)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @property
    @pulumi.getter
    def trigger(self) -> pulumi.Input['DatascanExecutionSpecTriggerArgs']:
        """
        Spec related to how often and when a scan should be triggered.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: pulumi.Input['DatascanExecutionSpecTriggerArgs']):
        pulumi.set(self, "trigger", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        The unnested field (of type Date or Timestamp) that contains values which monotonically increase over time. If not specified, a data scan will run for all data in the table.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)


@pulumi.input_type
class DatascanExecutionSpecTriggerArgs:
    def __init__(__self__, *,
                 on_demand: Optional[pulumi.Input['DatascanExecutionSpecTriggerOnDemandArgs']] = None,
                 schedule: Optional[pulumi.Input['DatascanExecutionSpecTriggerScheduleArgs']] = None):
        """
        :param pulumi.Input['DatascanExecutionSpecTriggerOnDemandArgs'] on_demand: The scan runs once via dataScans.run API.
        :param pulumi.Input['DatascanExecutionSpecTriggerScheduleArgs'] schedule: The scan is scheduled to run periodically.
               Structure is documented below.
        """
        if on_demand is not None:
            pulumi.set(__self__, "on_demand", on_demand)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter(name="onDemand")
    def on_demand(self) -> Optional[pulumi.Input['DatascanExecutionSpecTriggerOnDemandArgs']]:
        """
        The scan runs once via dataScans.run API.
        """
        return pulumi.get(self, "on_demand")

    @on_demand.setter
    def on_demand(self, value: Optional[pulumi.Input['DatascanExecutionSpecTriggerOnDemandArgs']]):
        pulumi.set(self, "on_demand", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['DatascanExecutionSpecTriggerScheduleArgs']]:
        """
        The scan is scheduled to run periodically.
        Structure is documented below.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['DatascanExecutionSpecTriggerScheduleArgs']]):
        pulumi.set(self, "schedule", value)


@pulumi.input_type
class DatascanExecutionSpecTriggerOnDemandArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DatascanExecutionSpecTriggerScheduleArgs:
    def __init__(__self__, *,
                 cron: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cron: Cron schedule for running scans periodically. This field is required for Schedule scans.
               
               - - -
        """
        pulumi.set(__self__, "cron", cron)

    @property
    @pulumi.getter
    def cron(self) -> pulumi.Input[str]:
        """
        Cron schedule for running scans periodically. This field is required for Schedule scans.

        - - -
        """
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron", value)


@pulumi.input_type
class DatascanExecutionStatusArgs:
    def __init__(__self__, *,
                 latest_job_end_time: Optional[pulumi.Input[str]] = None,
                 latest_job_start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] latest_job_end_time: (Output)
               The time when the latest DataScanJob started.
        :param pulumi.Input[str] latest_job_start_time: (Output)
               The time when the latest DataScanJob ended.
        """
        if latest_job_end_time is not None:
            pulumi.set(__self__, "latest_job_end_time", latest_job_end_time)
        if latest_job_start_time is not None:
            pulumi.set(__self__, "latest_job_start_time", latest_job_start_time)

    @property
    @pulumi.getter(name="latestJobEndTime")
    def latest_job_end_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The time when the latest DataScanJob started.
        """
        return pulumi.get(self, "latest_job_end_time")

    @latest_job_end_time.setter
    def latest_job_end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "latest_job_end_time", value)

    @property
    @pulumi.getter(name="latestJobStartTime")
    def latest_job_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The time when the latest DataScanJob ended.
        """
        return pulumi.get(self, "latest_job_start_time")

    @latest_job_start_time.setter
    def latest_job_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "latest_job_start_time", value)


@pulumi.input_type
class DatascanIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class DatascanIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class LakeAssetStatusArgs:
    def __init__(__self__, *,
                 active_assets: Optional[pulumi.Input[int]] = None,
                 security_policy_applying_assets: Optional[pulumi.Input[int]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] update_time: Output only. The time when the lake was last updated.
        """
        if active_assets is not None:
            pulumi.set(__self__, "active_assets", active_assets)
        if security_policy_applying_assets is not None:
            pulumi.set(__self__, "security_policy_applying_assets", security_policy_applying_assets)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="activeAssets")
    def active_assets(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "active_assets")

    @active_assets.setter
    def active_assets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "active_assets", value)

    @property
    @pulumi.getter(name="securityPolicyApplyingAssets")
    def security_policy_applying_assets(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "security_policy_applying_assets")

    @security_policy_applying_assets.setter
    def security_policy_applying_assets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "security_policy_applying_assets", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. The time when the lake was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


@pulumi.input_type
class LakeIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class LakeIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class LakeMetastoreArgs:
    def __init__(__self__, *,
                 service: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service: Optional. A relative reference to the Dataproc Metastore (https://cloud.google.com/dataproc-metastore/docs) service associated with the lake: `projects/{project_id}/locations/{location_id}/services/{service_id}`
        """
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. A relative reference to the Dataproc Metastore (https://cloud.google.com/dataproc-metastore/docs) service associated with the lake: `projects/{project_id}/locations/{location_id}/services/{service_id}`
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)


@pulumi.input_type
class LakeMetastoreStatusArgs:
    def __init__(__self__, *,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] state: Output only. Current state of the lake. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        :param pulumi.Input[str] update_time: Output only. The time when the lake was last updated.
        """
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. Current state of the lake. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. The time when the lake was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


@pulumi.input_type
class TaskExecutionSpecArgs:
    def __init__(__self__, *,
                 service_account: pulumi.Input[str],
                 args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 max_job_execution_lifetime: Optional[pulumi.Input[str]] = None,
                 project: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_account: Service account to use to execute a task. If not provided, the default Compute service account for the project is used.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] args: The arguments to pass to the task. The args can use placeholders of the format ${placeholder} as part of key/value string. These will be interpolated before passing the args to the driver. Currently supported placeholders: - ${taskId} - ${job_time} To pass positional args, set the key as TASK_ARGS. The value should be a comma-separated string of all the positional arguments. To use a delimiter other than comma, refer to https://cloud.google.com/sdk/gcloud/reference/topic/escaping. In case of other keys being present in the args, then TASK_ARGS will be passed as the last argument. An object containing a list of 'key': value pairs. Example: { 'name': 'wrench', 'mass': '1.3kg', 'count': '3' }.
        :param pulumi.Input[str] kms_key: The Cloud KMS key to use for encryption, of the form: projects/{project_number}/locations/{locationId}/keyRings/{key-ring-name}/cryptoKeys/{key-name}.
               
               - - -
        :param pulumi.Input[str] max_job_execution_lifetime: The maximum duration after which the job execution is expired. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'.
        :param pulumi.Input[str] project: The ID of the project in which the resource belongs.
               If it is not provided, the provider project is used.
        """
        pulumi.set(__self__, "service_account", service_account)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if max_job_execution_lifetime is not None:
            pulumi.set(__self__, "max_job_execution_lifetime", max_job_execution_lifetime)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> pulumi.Input[str]:
        """
        Service account to use to execute a task. If not provided, the default Compute service account for the project is used.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The arguments to pass to the task. The args can use placeholders of the format ${placeholder} as part of key/value string. These will be interpolated before passing the args to the driver. Currently supported placeholders: - ${taskId} - ${job_time} To pass positional args, set the key as TASK_ARGS. The value should be a comma-separated string of all the positional arguments. To use a delimiter other than comma, refer to https://cloud.google.com/sdk/gcloud/reference/topic/escaping. In case of other keys being present in the args, then TASK_ARGS will be passed as the last argument. An object containing a list of 'key': value pairs. Example: { 'name': 'wrench', 'mass': '1.3kg', 'count': '3' }.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloud KMS key to use for encryption, of the form: projects/{project_number}/locations/{locationId}/keyRings/{key-ring-name}/cryptoKeys/{key-name}.

        - - -
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter(name="maxJobExecutionLifetime")
    def max_job_execution_lifetime(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum duration after which the job execution is expired. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'.
        """
        return pulumi.get(self, "max_job_execution_lifetime")

    @max_job_execution_lifetime.setter
    def max_job_execution_lifetime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_job_execution_lifetime", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the project in which the resource belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project", value)


@pulumi.input_type
class TaskExecutionStatusArgs:
    def __init__(__self__, *,
                 latest_jobs: Optional[pulumi.Input[Sequence[pulumi.Input['TaskExecutionStatusLatestJobArgs']]]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TaskExecutionStatusLatestJobArgs']]] latest_jobs: (Output)
               latest job execution.
               Structure is documented below.
        :param pulumi.Input[str] update_time: (Output)
               Last update time of the status.
        """
        if latest_jobs is not None:
            pulumi.set(__self__, "latest_jobs", latest_jobs)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="latestJobs")
    def latest_jobs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskExecutionStatusLatestJobArgs']]]]:
        """
        (Output)
        latest job execution.
        Structure is documented below.
        """
        return pulumi.get(self, "latest_jobs")

    @latest_jobs.setter
    def latest_jobs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskExecutionStatusLatestJobArgs']]]]):
        pulumi.set(self, "latest_jobs", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Last update time of the status.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


@pulumi.input_type
class TaskExecutionStatusLatestJobArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 retry_count: Optional[pulumi.Input[int]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 service_job: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] end_time: (Output)
               The time when the job ended.
        :param pulumi.Input[str] message: (Output)
               Additional information about the current state.
        :param pulumi.Input[str] name: (Output)
               The relative resource name of the job, of the form: projects/{project_number}/locations/{locationId}/lakes/{lakeId}/tasks/{taskId}/jobs/{jobId}.
        :param pulumi.Input[int] retry_count: (Output)
               The number of times the job has been retried (excluding the initial attempt).
        :param pulumi.Input[str] service: (Output)
               The underlying service running a job.
        :param pulumi.Input[str] service_job: (Output)
               The full resource name for the job run under a particular service.
        :param pulumi.Input[str] start_time: The first run of the task will be after this time. If not specified, the task will run shortly after being submitted if ON_DEMAND and based on the schedule if RECURRING.
        :param pulumi.Input[str] state: (Output)
               Execution state for the job.
        :param pulumi.Input[str] uid: (Output)
               System generated globally unique ID for the job.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if service_job is not None:
            pulumi.set(__self__, "service_job", service_job)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The time when the job ended.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Additional information about the current state.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The relative resource name of the job, of the form: projects/{project_number}/locations/{locationId}/lakes/{lakeId}/tasks/{taskId}/jobs/{jobId}.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        The number of times the job has been retried (excluding the initial attempt).
        """
        return pulumi.get(self, "retry_count")

    @retry_count.setter
    def retry_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retry_count", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The underlying service running a job.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="serviceJob")
    def service_job(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The full resource name for the job run under a particular service.
        """
        return pulumi.get(self, "service_job")

    @service_job.setter
    def service_job(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_job", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The first run of the task will be after this time. If not specified, the task will run shortly after being submitted if ON_DEMAND and based on the schedule if RECURRING.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Execution state for the job.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        System generated globally unique ID for the job.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class TaskIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class TaskIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class TaskNotebookArgs:
    def __init__(__self__, *,
                 notebook: pulumi.Input[str],
                 archive_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 file_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 infrastructure_spec: Optional[pulumi.Input['TaskNotebookInfrastructureSpecArgs']] = None):
        """
        :param pulumi.Input[str] notebook: Path to input notebook. This can be the Cloud Storage URI of the notebook file or the path to a Notebook Content. The execution args are accessible as environment variables (TASK_key=value).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] archive_uris: Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_uris: Cloud Storage URIs of files to be placed in the working directory of each executor.
        :param pulumi.Input['TaskNotebookInfrastructureSpecArgs'] infrastructure_spec: Infrastructure specification for the execution.
               Structure is documented below.
        """
        pulumi.set(__self__, "notebook", notebook)
        if archive_uris is not None:
            pulumi.set(__self__, "archive_uris", archive_uris)
        if file_uris is not None:
            pulumi.set(__self__, "file_uris", file_uris)
        if infrastructure_spec is not None:
            pulumi.set(__self__, "infrastructure_spec", infrastructure_spec)

    @property
    @pulumi.getter
    def notebook(self) -> pulumi.Input[str]:
        """
        Path to input notebook. This can be the Cloud Storage URI of the notebook file or the path to a Notebook Content. The execution args are accessible as environment variables (TASK_key=value).
        """
        return pulumi.get(self, "notebook")

    @notebook.setter
    def notebook(self, value: pulumi.Input[str]):
        pulumi.set(self, "notebook", value)

    @property
    @pulumi.getter(name="archiveUris")
    def archive_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        """
        return pulumi.get(self, "archive_uris")

    @archive_uris.setter
    def archive_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "archive_uris", value)

    @property
    @pulumi.getter(name="fileUris")
    def file_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Cloud Storage URIs of files to be placed in the working directory of each executor.
        """
        return pulumi.get(self, "file_uris")

    @file_uris.setter
    def file_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "file_uris", value)

    @property
    @pulumi.getter(name="infrastructureSpec")
    def infrastructure_spec(self) -> Optional[pulumi.Input['TaskNotebookInfrastructureSpecArgs']]:
        """
        Infrastructure specification for the execution.
        Structure is documented below.
        """
        return pulumi.get(self, "infrastructure_spec")

    @infrastructure_spec.setter
    def infrastructure_spec(self, value: Optional[pulumi.Input['TaskNotebookInfrastructureSpecArgs']]):
        pulumi.set(self, "infrastructure_spec", value)


@pulumi.input_type
class TaskNotebookInfrastructureSpecArgs:
    def __init__(__self__, *,
                 batch: Optional[pulumi.Input['TaskNotebookInfrastructureSpecBatchArgs']] = None,
                 container_image: Optional[pulumi.Input['TaskNotebookInfrastructureSpecContainerImageArgs']] = None,
                 vpc_network: Optional[pulumi.Input['TaskNotebookInfrastructureSpecVpcNetworkArgs']] = None):
        """
        :param pulumi.Input['TaskNotebookInfrastructureSpecBatchArgs'] batch: Compute resources needed for a Task when using Dataproc Serverless.
               Structure is documented below.
        :param pulumi.Input['TaskNotebookInfrastructureSpecContainerImageArgs'] container_image: Container Image Runtime Configuration.
               Structure is documented below.
        :param pulumi.Input['TaskNotebookInfrastructureSpecVpcNetworkArgs'] vpc_network: Vpc network.
               Structure is documented below.
        """
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if container_image is not None:
            pulumi.set(__self__, "container_image", container_image)
        if vpc_network is not None:
            pulumi.set(__self__, "vpc_network", vpc_network)

    @property
    @pulumi.getter
    def batch(self) -> Optional[pulumi.Input['TaskNotebookInfrastructureSpecBatchArgs']]:
        """
        Compute resources needed for a Task when using Dataproc Serverless.
        Structure is documented below.
        """
        return pulumi.get(self, "batch")

    @batch.setter
    def batch(self, value: Optional[pulumi.Input['TaskNotebookInfrastructureSpecBatchArgs']]):
        pulumi.set(self, "batch", value)

    @property
    @pulumi.getter(name="containerImage")
    def container_image(self) -> Optional[pulumi.Input['TaskNotebookInfrastructureSpecContainerImageArgs']]:
        """
        Container Image Runtime Configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "container_image")

    @container_image.setter
    def container_image(self, value: Optional[pulumi.Input['TaskNotebookInfrastructureSpecContainerImageArgs']]):
        pulumi.set(self, "container_image", value)

    @property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> Optional[pulumi.Input['TaskNotebookInfrastructureSpecVpcNetworkArgs']]:
        """
        Vpc network.
        Structure is documented below.
        """
        return pulumi.get(self, "vpc_network")

    @vpc_network.setter
    def vpc_network(self, value: Optional[pulumi.Input['TaskNotebookInfrastructureSpecVpcNetworkArgs']]):
        pulumi.set(self, "vpc_network", value)


@pulumi.input_type
class TaskNotebookInfrastructureSpecBatchArgs:
    def __init__(__self__, *,
                 executors_count: Optional[pulumi.Input[int]] = None,
                 max_executors_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] executors_count: Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        :param pulumi.Input[int] max_executors_count: Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        if executors_count is not None:
            pulumi.set(__self__, "executors_count", executors_count)
        if max_executors_count is not None:
            pulumi.set(__self__, "max_executors_count", max_executors_count)

    @property
    @pulumi.getter(name="executorsCount")
    def executors_count(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        """
        return pulumi.get(self, "executors_count")

    @executors_count.setter
    def executors_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "executors_count", value)

    @property
    @pulumi.getter(name="maxExecutorsCount")
    def max_executors_count(self) -> Optional[pulumi.Input[int]]:
        """
        Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        return pulumi.get(self, "max_executors_count")

    @max_executors_count.setter
    def max_executors_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_executors_count", value)


@pulumi.input_type
class TaskNotebookInfrastructureSpecContainerImageArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input[str]] = None,
                 java_jars: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 python_packages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] image: Container image to use.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] java_jars: A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] python_packages: A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if java_jars is not None:
            pulumi.set(__self__, "java_jars", java_jars)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if python_packages is not None:
            pulumi.set(__self__, "python_packages", python_packages)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Container image to use.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="javaJars")
    def java_jars(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        """
        return pulumi.get(self, "java_jars")

    @java_jars.setter
    def java_jars(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "java_jars", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="pythonPackages")
    def python_packages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        return pulumi.get(self, "python_packages")

    @python_packages.setter
    def python_packages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "python_packages", value)


@pulumi.input_type
class TaskNotebookInfrastructureSpecVpcNetworkArgs:
    def __init__(__self__, *,
                 network: Optional[pulumi.Input[str]] = None,
                 network_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sub_network: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network: The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] network_tags: List of network tags to apply to the job.
        :param pulumi.Input[str] sub_network: The Cloud VPC sub-network in which the job is run.
        """
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_tags is not None:
            pulumi.set(__self__, "network_tags", network_tags)
        if sub_network is not None:
            pulumi.set(__self__, "sub_network", sub_network)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="networkTags")
    def network_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of network tags to apply to the job.
        """
        return pulumi.get(self, "network_tags")

    @network_tags.setter
    def network_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "network_tags", value)

    @property
    @pulumi.getter(name="subNetwork")
    def sub_network(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloud VPC sub-network in which the job is run.
        """
        return pulumi.get(self, "sub_network")

    @sub_network.setter
    def sub_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sub_network", value)


@pulumi.input_type
class TaskSparkArgs:
    def __init__(__self__, *,
                 archive_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 file_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 infrastructure_spec: Optional[pulumi.Input['TaskSparkInfrastructureSpecArgs']] = None,
                 main_class: Optional[pulumi.Input[str]] = None,
                 main_jar_file_uri: Optional[pulumi.Input[str]] = None,
                 python_script_file: Optional[pulumi.Input[str]] = None,
                 sql_script: Optional[pulumi.Input[str]] = None,
                 sql_script_file: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] archive_uris: Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_uris: Cloud Storage URIs of files to be placed in the working directory of each executor.
        :param pulumi.Input['TaskSparkInfrastructureSpecArgs'] infrastructure_spec: Infrastructure specification for the execution.
               Structure is documented below.
        :param pulumi.Input[str] main_class: The name of the driver's main class. The jar file that contains the class must be in the default CLASSPATH or specified in jar_file_uris. The execution args are passed in as a sequence of named process arguments (--key=value).
        :param pulumi.Input[str] main_jar_file_uri: The Cloud Storage URI of the jar file that contains the main class. The execution args are passed in as a sequence of named process arguments (--key=value).
        :param pulumi.Input[str] python_script_file: The Gcloud Storage URI of the main Python file to use as the driver. Must be a .py file. The execution args are passed in as a sequence of named process arguments (--key=value).
        :param pulumi.Input[str] sql_script: The query text. The execution args are used to declare a set of script variables (set key='value';).
        :param pulumi.Input[str] sql_script_file: A reference to a query file. This can be the Cloud Storage URI of the query file or it can the path to a SqlScript Content. The execution args are used to declare a set of script variables (set key='value';).
        """
        if archive_uris is not None:
            pulumi.set(__self__, "archive_uris", archive_uris)
        if file_uris is not None:
            pulumi.set(__self__, "file_uris", file_uris)
        if infrastructure_spec is not None:
            pulumi.set(__self__, "infrastructure_spec", infrastructure_spec)
        if main_class is not None:
            pulumi.set(__self__, "main_class", main_class)
        if main_jar_file_uri is not None:
            pulumi.set(__self__, "main_jar_file_uri", main_jar_file_uri)
        if python_script_file is not None:
            pulumi.set(__self__, "python_script_file", python_script_file)
        if sql_script is not None:
            pulumi.set(__self__, "sql_script", sql_script)
        if sql_script_file is not None:
            pulumi.set(__self__, "sql_script_file", sql_script_file)

    @property
    @pulumi.getter(name="archiveUris")
    def archive_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
        """
        return pulumi.get(self, "archive_uris")

    @archive_uris.setter
    def archive_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "archive_uris", value)

    @property
    @pulumi.getter(name="fileUris")
    def file_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Cloud Storage URIs of files to be placed in the working directory of each executor.
        """
        return pulumi.get(self, "file_uris")

    @file_uris.setter
    def file_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "file_uris", value)

    @property
    @pulumi.getter(name="infrastructureSpec")
    def infrastructure_spec(self) -> Optional[pulumi.Input['TaskSparkInfrastructureSpecArgs']]:
        """
        Infrastructure specification for the execution.
        Structure is documented below.
        """
        return pulumi.get(self, "infrastructure_spec")

    @infrastructure_spec.setter
    def infrastructure_spec(self, value: Optional[pulumi.Input['TaskSparkInfrastructureSpecArgs']]):
        pulumi.set(self, "infrastructure_spec", value)

    @property
    @pulumi.getter(name="mainClass")
    def main_class(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the driver's main class. The jar file that contains the class must be in the default CLASSPATH or specified in jar_file_uris. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        return pulumi.get(self, "main_class")

    @main_class.setter
    def main_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "main_class", value)

    @property
    @pulumi.getter(name="mainJarFileUri")
    def main_jar_file_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloud Storage URI of the jar file that contains the main class. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        return pulumi.get(self, "main_jar_file_uri")

    @main_jar_file_uri.setter
    def main_jar_file_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "main_jar_file_uri", value)

    @property
    @pulumi.getter(name="pythonScriptFile")
    def python_script_file(self) -> Optional[pulumi.Input[str]]:
        """
        The Gcloud Storage URI of the main Python file to use as the driver. Must be a .py file. The execution args are passed in as a sequence of named process arguments (--key=value).
        """
        return pulumi.get(self, "python_script_file")

    @python_script_file.setter
    def python_script_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "python_script_file", value)

    @property
    @pulumi.getter(name="sqlScript")
    def sql_script(self) -> Optional[pulumi.Input[str]]:
        """
        The query text. The execution args are used to declare a set of script variables (set key='value';).
        """
        return pulumi.get(self, "sql_script")

    @sql_script.setter
    def sql_script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_script", value)

    @property
    @pulumi.getter(name="sqlScriptFile")
    def sql_script_file(self) -> Optional[pulumi.Input[str]]:
        """
        A reference to a query file. This can be the Cloud Storage URI of the query file or it can the path to a SqlScript Content. The execution args are used to declare a set of script variables (set key='value';).
        """
        return pulumi.get(self, "sql_script_file")

    @sql_script_file.setter
    def sql_script_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_script_file", value)


@pulumi.input_type
class TaskSparkInfrastructureSpecArgs:
    def __init__(__self__, *,
                 batch: Optional[pulumi.Input['TaskSparkInfrastructureSpecBatchArgs']] = None,
                 container_image: Optional[pulumi.Input['TaskSparkInfrastructureSpecContainerImageArgs']] = None,
                 vpc_network: Optional[pulumi.Input['TaskSparkInfrastructureSpecVpcNetworkArgs']] = None):
        """
        :param pulumi.Input['TaskSparkInfrastructureSpecBatchArgs'] batch: Compute resources needed for a Task when using Dataproc Serverless.
               Structure is documented below.
        :param pulumi.Input['TaskSparkInfrastructureSpecContainerImageArgs'] container_image: Container Image Runtime Configuration.
               Structure is documented below.
        :param pulumi.Input['TaskSparkInfrastructureSpecVpcNetworkArgs'] vpc_network: Vpc network.
               Structure is documented below.
        """
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if container_image is not None:
            pulumi.set(__self__, "container_image", container_image)
        if vpc_network is not None:
            pulumi.set(__self__, "vpc_network", vpc_network)

    @property
    @pulumi.getter
    def batch(self) -> Optional[pulumi.Input['TaskSparkInfrastructureSpecBatchArgs']]:
        """
        Compute resources needed for a Task when using Dataproc Serverless.
        Structure is documented below.
        """
        return pulumi.get(self, "batch")

    @batch.setter
    def batch(self, value: Optional[pulumi.Input['TaskSparkInfrastructureSpecBatchArgs']]):
        pulumi.set(self, "batch", value)

    @property
    @pulumi.getter(name="containerImage")
    def container_image(self) -> Optional[pulumi.Input['TaskSparkInfrastructureSpecContainerImageArgs']]:
        """
        Container Image Runtime Configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "container_image")

    @container_image.setter
    def container_image(self, value: Optional[pulumi.Input['TaskSparkInfrastructureSpecContainerImageArgs']]):
        pulumi.set(self, "container_image", value)

    @property
    @pulumi.getter(name="vpcNetwork")
    def vpc_network(self) -> Optional[pulumi.Input['TaskSparkInfrastructureSpecVpcNetworkArgs']]:
        """
        Vpc network.
        Structure is documented below.
        """
        return pulumi.get(self, "vpc_network")

    @vpc_network.setter
    def vpc_network(self, value: Optional[pulumi.Input['TaskSparkInfrastructureSpecVpcNetworkArgs']]):
        pulumi.set(self, "vpc_network", value)


@pulumi.input_type
class TaskSparkInfrastructureSpecBatchArgs:
    def __init__(__self__, *,
                 executors_count: Optional[pulumi.Input[int]] = None,
                 max_executors_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] executors_count: Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        :param pulumi.Input[int] max_executors_count: Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        if executors_count is not None:
            pulumi.set(__self__, "executors_count", executors_count)
        if max_executors_count is not None:
            pulumi.set(__self__, "max_executors_count", max_executors_count)

    @property
    @pulumi.getter(name="executorsCount")
    def executors_count(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
        """
        return pulumi.get(self, "executors_count")

    @executors_count.setter
    def executors_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "executors_count", value)

    @property
    @pulumi.getter(name="maxExecutorsCount")
    def max_executors_count(self) -> Optional[pulumi.Input[int]]:
        """
        Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
        """
        return pulumi.get(self, "max_executors_count")

    @max_executors_count.setter
    def max_executors_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_executors_count", value)


@pulumi.input_type
class TaskSparkInfrastructureSpecContainerImageArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input[str]] = None,
                 java_jars: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 python_packages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] image: Container image to use.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] java_jars: A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] python_packages: A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if java_jars is not None:
            pulumi.set(__self__, "java_jars", java_jars)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if python_packages is not None:
            pulumi.set(__self__, "python_packages", python_packages)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Container image to use.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="javaJars")
    def java_jars(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
        """
        return pulumi.get(self, "java_jars")

    @java_jars.setter
    def java_jars(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "java_jars", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="pythonPackages")
    def python_packages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
        """
        return pulumi.get(self, "python_packages")

    @python_packages.setter
    def python_packages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "python_packages", value)


@pulumi.input_type
class TaskSparkInfrastructureSpecVpcNetworkArgs:
    def __init__(__self__, *,
                 network: Optional[pulumi.Input[str]] = None,
                 network_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sub_network: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network: The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] network_tags: List of network tags to apply to the job.
        :param pulumi.Input[str] sub_network: The Cloud VPC sub-network in which the job is run.
        """
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_tags is not None:
            pulumi.set(__self__, "network_tags", network_tags)
        if sub_network is not None:
            pulumi.set(__self__, "sub_network", sub_network)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="networkTags")
    def network_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of network tags to apply to the job.
        """
        return pulumi.get(self, "network_tags")

    @network_tags.setter
    def network_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "network_tags", value)

    @property
    @pulumi.getter(name="subNetwork")
    def sub_network(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloud VPC sub-network in which the job is run.
        """
        return pulumi.get(self, "sub_network")

    @sub_network.setter
    def sub_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sub_network", value)


@pulumi.input_type
class TaskTriggerSpecArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disabled: Optional[pulumi.Input[bool]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 schedule: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Trigger type of the user-specified Task
               Possible values are: `ON_DEMAND`, `RECURRING`.
        :param pulumi.Input[bool] disabled: Prevent the task from executing. This does not cancel already running tasks. It is intended to temporarily disable RECURRING tasks.
        :param pulumi.Input[int] max_retries: Number of retry attempts before aborting. Set to zero to never attempt to retry a failed task.
        :param pulumi.Input[str] schedule: Cron schedule (https://en.wikipedia.org/wiki/Cron) for running tasks periodically. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: 'CRON_TZ=${IANA_TIME_ZONE}' or 'TZ=${IANA_TIME_ZONE}'. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, CRON_TZ=America/New_York 1 * * * *, or TZ=America/New_York 1 * * * *. This field is required for RECURRING tasks.
        :param pulumi.Input[str] start_time: The first run of the task will be after this time. If not specified, the task will run shortly after being submitted if ON_DEMAND and based on the schedule if RECURRING.
        """
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Trigger type of the user-specified Task
        Possible values are: `ON_DEMAND`, `RECURRING`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Prevent the task from executing. This does not cancel already running tasks. It is intended to temporarily disable RECURRING tasks.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retry attempts before aborting. Set to zero to never attempt to retry a failed task.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input[str]]:
        """
        Cron schedule (https://en.wikipedia.org/wiki/Cron) for running tasks periodically. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: 'CRON_TZ=${IANA_TIME_ZONE}' or 'TZ=${IANA_TIME_ZONE}'. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, CRON_TZ=America/New_York 1 * * * *, or TZ=America/New_York 1 * * * *. This field is required for RECURRING tasks.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The first run of the task will be after this time. If not specified, the task will run shortly after being submitted if ON_DEMAND and based on the schedule if RECURRING.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


@pulumi.input_type
class ZoneAssetStatusArgs:
    def __init__(__self__, *,
                 active_assets: Optional[pulumi.Input[int]] = None,
                 security_policy_applying_assets: Optional[pulumi.Input[int]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] update_time: Output only. The time when the zone was last updated.
        """
        if active_assets is not None:
            pulumi.set(__self__, "active_assets", active_assets)
        if security_policy_applying_assets is not None:
            pulumi.set(__self__, "security_policy_applying_assets", security_policy_applying_assets)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="activeAssets")
    def active_assets(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "active_assets")

    @active_assets.setter
    def active_assets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "active_assets", value)

    @property
    @pulumi.getter(name="securityPolicyApplyingAssets")
    def security_policy_applying_assets(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "security_policy_applying_assets")

    @security_policy_applying_assets.setter
    def security_policy_applying_assets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "security_policy_applying_assets", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. The time when the zone was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


@pulumi.input_type
class ZoneDiscoverySpecArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 csv_options: Optional[pulumi.Input['ZoneDiscoverySpecCsvOptionsArgs']] = None,
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 json_options: Optional[pulumi.Input['ZoneDiscoverySpecJsonOptionsArgs']] = None,
                 schedule: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Required. Whether discovery is enabled.
        :param pulumi.Input['ZoneDiscoverySpecCsvOptionsArgs'] csv_options: Optional. Configuration for CSV data.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        :param pulumi.Input['ZoneDiscoverySpecJsonOptionsArgs'] json_options: Optional. Configuration for Json data.
        :param pulumi.Input[str] schedule: Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        pulumi.set(__self__, "enabled", enabled)
        if csv_options is not None:
            pulumi.set(__self__, "csv_options", csv_options)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if json_options is not None:
            pulumi.set(__self__, "json_options", json_options)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Required. Whether discovery is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="csvOptions")
    def csv_options(self) -> Optional[pulumi.Input['ZoneDiscoverySpecCsvOptionsArgs']]:
        """
        Optional. Configuration for CSV data.
        """
        return pulumi.get(self, "csv_options")

    @csv_options.setter
    def csv_options(self, value: Optional[pulumi.Input['ZoneDiscoverySpecCsvOptionsArgs']]):
        pulumi.set(self, "csv_options", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)

    @property
    @pulumi.getter(name="jsonOptions")
    def json_options(self) -> Optional[pulumi.Input['ZoneDiscoverySpecJsonOptionsArgs']]:
        """
        Optional. Configuration for Json data.
        """
        return pulumi.get(self, "json_options")

    @json_options.setter
    def json_options(self, value: Optional[pulumi.Input['ZoneDiscoverySpecJsonOptionsArgs']]):
        pulumi.set(self, "json_options", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule", value)


@pulumi.input_type
class ZoneDiscoverySpecCsvOptionsArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 disable_type_inference: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 header_rows: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] delimiter: Optional. The delimiter being used to separate values. This defaults to ','.
        :param pulumi.Input[bool] disable_type_inference: Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        :param pulumi.Input[str] encoding: Optional. The character encoding of the data. The default is UTF-8.
        :param pulumi.Input[int] header_rows: Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if header_rows is not None:
            pulumi.set(__self__, "header_rows", header_rows)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The delimiter being used to separate values. This defaults to ','.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
        """
        return pulumi.get(self, "disable_type_inference")

    @disable_type_inference.setter
    def disable_type_inference(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_type_inference", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="headerRows")
    def header_rows(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
        """
        return pulumi.get(self, "header_rows")

    @header_rows.setter
    def header_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "header_rows", value)


@pulumi.input_type
class ZoneDiscoverySpecJsonOptionsArgs:
    def __init__(__self__, *,
                 disable_type_inference: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable_type_inference: Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        :param pulumi.Input[str] encoding: Optional. The character encoding of the data. The default is UTF-8.
        """
        if disable_type_inference is not None:
            pulumi.set(__self__, "disable_type_inference", disable_type_inference)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @property
    @pulumi.getter(name="disableTypeInference")
    def disable_type_inference(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
        """
        return pulumi.get(self, "disable_type_inference")

    @disable_type_inference.setter
    def disable_type_inference(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_type_inference", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The character encoding of the data. The default is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)


@pulumi.input_type
class ZoneIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class ZoneIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class ZoneResourceSpecArgs:
    def __init__(__self__, *,
                 location_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] location_type: Required. Immutable. The location type of the resources that are allowed to be attached to the assets within this zone. Possible values: LOCATION_TYPE_UNSPECIFIED, SINGLE_REGION, MULTI_REGION
               
               - - -
        """
        pulumi.set(__self__, "location_type", location_type)

    @property
    @pulumi.getter(name="locationType")
    def location_type(self) -> pulumi.Input[str]:
        """
        Required. Immutable. The location type of the resources that are allowed to be attached to the assets within this zone. Possible values: LOCATION_TYPE_UNSPECIFIED, SINGLE_REGION, MULTI_REGION

        - - -
        """
        return pulumi.get(self, "location_type")

    @location_type.setter
    def location_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "location_type", value)


