# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'CryptoKeyIAMBindingCondition',
    'CryptoKeyIAMMemberCondition',
    'CryptoKeyPrimary',
    'CryptoKeyVersionAttestation',
    'CryptoKeyVersionAttestationCertChains',
    'CryptoKeyVersionAttestationExternalProtectionLevelOptions',
    'CryptoKeyVersionExternalProtectionLevelOptions',
    'CryptoKeyVersionTemplate',
    'EkmConnectionServiceResolver',
    'EkmConnectionServiceResolverServerCertificate',
    'KeyRingIAMBindingCondition',
    'KeyRingIAMMemberCondition',
    'KeyRingImportJobAttestation',
    'KeyRingImportJobPublicKey',
    'GetKMSCryptoKeyPrimaryResult',
    'GetKMSCryptoKeyVersionPublicKeyResult',
    'GetKMSCryptoKeyVersionTemplateResult',
]

@pulumi.output_type
class CryptoKeyIAMBindingCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        """
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str title: A title for the expression, i.e. a short string describing its purpose.
        :param str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
               
               > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
               identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
               consider it to be an entirely different resource and will treat it as such.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
        identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
        consider it to be an entirely different resource and will treat it as such.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class CryptoKeyIAMMemberCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        """
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str title: A title for the expression, i.e. a short string describing its purpose.
        :param str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
               
               > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
               identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
               consider it to be an entirely different resource and will treat it as such.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
        identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
        consider it to be an entirely different resource and will treat it as such.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class CryptoKeyPrimary(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param str name: The resource name for the CryptoKey.
        :param str state: (Output)
               The current state of the CryptoKeyVersion.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The resource name for the CryptoKey.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Output)
        The current state of the CryptoKeyVersion.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class CryptoKeyVersionAttestation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certChains":
            suggest = "cert_chains"
        elif key == "externalProtectionLevelOptions":
            suggest = "external_protection_level_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CryptoKeyVersionAttestation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CryptoKeyVersionAttestation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CryptoKeyVersionAttestation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_chains: Optional['outputs.CryptoKeyVersionAttestationCertChains'] = None,
                 content: Optional[str] = None,
                 external_protection_level_options: Optional['outputs.CryptoKeyVersionAttestationExternalProtectionLevelOptions'] = None,
                 format: Optional[str] = None):
        """
        :param 'CryptoKeyVersionAttestationCertChainsArgs' cert_chains: The certificate chains needed to validate the attestation
               Structure is documented below.
        :param str content: (Output)
               The attestation data provided by the HSM when the key operation was performed.
        :param 'CryptoKeyVersionAttestationExternalProtectionLevelOptionsArgs' external_protection_level_options: ExternalProtectionLevelOptions stores a group of additional fields for configuring a CryptoKeyVersion that are specific to the EXTERNAL protection level and EXTERNAL_VPC protection levels.
               Structure is documented below.
        :param str format: (Output)
               The format of the attestation data.
        """
        if cert_chains is not None:
            pulumi.set(__self__, "cert_chains", cert_chains)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if external_protection_level_options is not None:
            pulumi.set(__self__, "external_protection_level_options", external_protection_level_options)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @property
    @pulumi.getter(name="certChains")
    def cert_chains(self) -> Optional['outputs.CryptoKeyVersionAttestationCertChains']:
        """
        The certificate chains needed to validate the attestation
        Structure is documented below.
        """
        return pulumi.get(self, "cert_chains")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        (Output)
        The attestation data provided by the HSM when the key operation was performed.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="externalProtectionLevelOptions")
    @_utilities.deprecated("""`externalProtectionLevelOptions` is being un-nested from the `attestation` field. Please use the top level `externalProtectionLevelOptions` field instead.""")
    def external_protection_level_options(self) -> Optional['outputs.CryptoKeyVersionAttestationExternalProtectionLevelOptions']:
        """
        ExternalProtectionLevelOptions stores a group of additional fields for configuring a CryptoKeyVersion that are specific to the EXTERNAL protection level and EXTERNAL_VPC protection levels.
        Structure is documented below.
        """
        return pulumi.get(self, "external_protection_level_options")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        (Output)
        The format of the attestation data.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class CryptoKeyVersionAttestationCertChains(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caviumCerts":
            suggest = "cavium_certs"
        elif key == "googleCardCerts":
            suggest = "google_card_certs"
        elif key == "googlePartitionCerts":
            suggest = "google_partition_certs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CryptoKeyVersionAttestationCertChains. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CryptoKeyVersionAttestationCertChains.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CryptoKeyVersionAttestationCertChains.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cavium_certs: Optional[Sequence[str]] = None,
                 google_card_certs: Optional[Sequence[str]] = None,
                 google_partition_certs: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] cavium_certs: Cavium certificate chain corresponding to the attestation.
        :param Sequence[str] google_card_certs: Google card certificate chain corresponding to the attestation.
        :param Sequence[str] google_partition_certs: Google partition certificate chain corresponding to the attestation.
        """
        if cavium_certs is not None:
            pulumi.set(__self__, "cavium_certs", cavium_certs)
        if google_card_certs is not None:
            pulumi.set(__self__, "google_card_certs", google_card_certs)
        if google_partition_certs is not None:
            pulumi.set(__self__, "google_partition_certs", google_partition_certs)

    @property
    @pulumi.getter(name="caviumCerts")
    def cavium_certs(self) -> Optional[Sequence[str]]:
        """
        Cavium certificate chain corresponding to the attestation.
        """
        return pulumi.get(self, "cavium_certs")

    @property
    @pulumi.getter(name="googleCardCerts")
    def google_card_certs(self) -> Optional[Sequence[str]]:
        """
        Google card certificate chain corresponding to the attestation.
        """
        return pulumi.get(self, "google_card_certs")

    @property
    @pulumi.getter(name="googlePartitionCerts")
    def google_partition_certs(self) -> Optional[Sequence[str]]:
        """
        Google partition certificate chain corresponding to the attestation.
        """
        return pulumi.get(self, "google_partition_certs")


@pulumi.output_type
class CryptoKeyVersionAttestationExternalProtectionLevelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ekmConnectionKeyPath":
            suggest = "ekm_connection_key_path"
        elif key == "externalKeyUri":
            suggest = "external_key_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CryptoKeyVersionAttestationExternalProtectionLevelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CryptoKeyVersionAttestationExternalProtectionLevelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CryptoKeyVersionAttestationExternalProtectionLevelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ekm_connection_key_path: Optional[str] = None,
                 external_key_uri: Optional[str] = None):
        """
        :param str ekm_connection_key_path: The path to the external key material on the EKM when using EkmConnection e.g., "v0/my/key". Set this field instead of externalKeyUri when using an EkmConnection.
        :param str external_key_uri: The URI for an external resource that this CryptoKeyVersion represents.
        """
        if ekm_connection_key_path is not None:
            pulumi.set(__self__, "ekm_connection_key_path", ekm_connection_key_path)
        if external_key_uri is not None:
            pulumi.set(__self__, "external_key_uri", external_key_uri)

    @property
    @pulumi.getter(name="ekmConnectionKeyPath")
    def ekm_connection_key_path(self) -> Optional[str]:
        """
        The path to the external key material on the EKM when using EkmConnection e.g., "v0/my/key". Set this field instead of externalKeyUri when using an EkmConnection.
        """
        return pulumi.get(self, "ekm_connection_key_path")

    @property
    @pulumi.getter(name="externalKeyUri")
    def external_key_uri(self) -> Optional[str]:
        """
        The URI for an external resource that this CryptoKeyVersion represents.
        """
        return pulumi.get(self, "external_key_uri")


@pulumi.output_type
class CryptoKeyVersionExternalProtectionLevelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ekmConnectionKeyPath":
            suggest = "ekm_connection_key_path"
        elif key == "externalKeyUri":
            suggest = "external_key_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CryptoKeyVersionExternalProtectionLevelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CryptoKeyVersionExternalProtectionLevelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CryptoKeyVersionExternalProtectionLevelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ekm_connection_key_path: Optional[str] = None,
                 external_key_uri: Optional[str] = None):
        """
        :param str ekm_connection_key_path: The path to the external key material on the EKM when using EkmConnection e.g., "v0/my/key". Set this field instead of externalKeyUri when using an EkmConnection.
        :param str external_key_uri: The URI for an external resource that this CryptoKeyVersion represents.
        """
        if ekm_connection_key_path is not None:
            pulumi.set(__self__, "ekm_connection_key_path", ekm_connection_key_path)
        if external_key_uri is not None:
            pulumi.set(__self__, "external_key_uri", external_key_uri)

    @property
    @pulumi.getter(name="ekmConnectionKeyPath")
    def ekm_connection_key_path(self) -> Optional[str]:
        """
        The path to the external key material on the EKM when using EkmConnection e.g., "v0/my/key". Set this field instead of externalKeyUri when using an EkmConnection.
        """
        return pulumi.get(self, "ekm_connection_key_path")

    @property
    @pulumi.getter(name="externalKeyUri")
    def external_key_uri(self) -> Optional[str]:
        """
        The URI for an external resource that this CryptoKeyVersion represents.
        """
        return pulumi.get(self, "external_key_uri")


@pulumi.output_type
class CryptoKeyVersionTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "protectionLevel":
            suggest = "protection_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CryptoKeyVersionTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CryptoKeyVersionTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CryptoKeyVersionTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: str,
                 protection_level: Optional[str] = None):
        """
        :param str algorithm: The algorithm to use when creating a version based on this template.
               See the [algorithm reference](https://cloud.google.com/kms/docs/reference/rest/v1/CryptoKeyVersionAlgorithm) for possible inputs.
        :param str protection_level: The protection level to use when creating a version based on this template. Possible values include "SOFTWARE", "HSM", "EXTERNAL", "EXTERNAL_VPC". Defaults to "SOFTWARE".
        """
        pulumi.set(__self__, "algorithm", algorithm)
        if protection_level is not None:
            pulumi.set(__self__, "protection_level", protection_level)

    @property
    @pulumi.getter
    def algorithm(self) -> str:
        """
        The algorithm to use when creating a version based on this template.
        See the [algorithm reference](https://cloud.google.com/kms/docs/reference/rest/v1/CryptoKeyVersionAlgorithm) for possible inputs.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="protectionLevel")
    def protection_level(self) -> Optional[str]:
        """
        The protection level to use when creating a version based on this template. Possible values include "SOFTWARE", "HSM", "EXTERNAL", "EXTERNAL_VPC". Defaults to "SOFTWARE".
        """
        return pulumi.get(self, "protection_level")


@pulumi.output_type
class EkmConnectionServiceResolver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverCertificates":
            suggest = "server_certificates"
        elif key == "serviceDirectoryService":
            suggest = "service_directory_service"
        elif key == "endpointFilter":
            suggest = "endpoint_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EkmConnectionServiceResolver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EkmConnectionServiceResolver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EkmConnectionServiceResolver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 server_certificates: Sequence['outputs.EkmConnectionServiceResolverServerCertificate'],
                 service_directory_service: str,
                 endpoint_filter: Optional[str] = None):
        """
        :param str hostname: Required. The hostname of the EKM replica used at TLS and HTTP layers.
        :param Sequence['EkmConnectionServiceResolverServerCertificateArgs'] server_certificates: Required. A list of leaf server certificates used to authenticate HTTPS connections to the EKM replica. Currently, a maximum of 10 Certificate is supported.
               Structure is documented below.
        :param str service_directory_service: Required. The resource name of the Service Directory service pointing to an EKM replica, in the format projects/*/locations/*/namespaces/*/services/*
        :param str endpoint_filter: Optional. The filter applied to the endpoints of the resolved service. If no filter is specified, all endpoints will be considered. An endpoint will be chosen arbitrarily from the filtered list for each request. For endpoint filter syntax and examples, see https://cloud.google.com/service-directory/docs/reference/rpc/google.cloud.servicedirectory.v1#resolveservicerequest.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "server_certificates", server_certificates)
        pulumi.set(__self__, "service_directory_service", service_directory_service)
        if endpoint_filter is not None:
            pulumi.set(__self__, "endpoint_filter", endpoint_filter)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        Required. The hostname of the EKM replica used at TLS and HTTP layers.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="serverCertificates")
    def server_certificates(self) -> Sequence['outputs.EkmConnectionServiceResolverServerCertificate']:
        """
        Required. A list of leaf server certificates used to authenticate HTTPS connections to the EKM replica. Currently, a maximum of 10 Certificate is supported.
        Structure is documented below.
        """
        return pulumi.get(self, "server_certificates")

    @property
    @pulumi.getter(name="serviceDirectoryService")
    def service_directory_service(self) -> str:
        """
        Required. The resource name of the Service Directory service pointing to an EKM replica, in the format projects/*/locations/*/namespaces/*/services/*
        """
        return pulumi.get(self, "service_directory_service")

    @property
    @pulumi.getter(name="endpointFilter")
    def endpoint_filter(self) -> Optional[str]:
        """
        Optional. The filter applied to the endpoints of the resolved service. If no filter is specified, all endpoints will be considered. An endpoint will be chosen arbitrarily from the filtered list for each request. For endpoint filter syntax and examples, see https://cloud.google.com/service-directory/docs/reference/rpc/google.cloud.servicedirectory.v1#resolveservicerequest.
        """
        return pulumi.get(self, "endpoint_filter")


@pulumi.output_type
class EkmConnectionServiceResolverServerCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rawDer":
            suggest = "raw_der"
        elif key == "notAfterTime":
            suggest = "not_after_time"
        elif key == "notBeforeTime":
            suggest = "not_before_time"
        elif key == "serialNumber":
            suggest = "serial_number"
        elif key == "sha256Fingerprint":
            suggest = "sha256_fingerprint"
        elif key == "subjectAlternativeDnsNames":
            suggest = "subject_alternative_dns_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EkmConnectionServiceResolverServerCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EkmConnectionServiceResolverServerCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EkmConnectionServiceResolverServerCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 raw_der: str,
                 issuer: Optional[str] = None,
                 not_after_time: Optional[str] = None,
                 not_before_time: Optional[str] = None,
                 parsed: Optional[bool] = None,
                 serial_number: Optional[str] = None,
                 sha256_fingerprint: Optional[str] = None,
                 subject: Optional[str] = None,
                 subject_alternative_dns_names: Optional[Sequence[str]] = None):
        """
        :param str raw_der: Required. The raw certificate bytes in DER format. A base64-encoded string.
        :param str issuer: (Output)
               Output only. The issuer distinguished name in RFC 2253 format. Only present if parsed is true.
        :param str not_after_time: (Output)
               Output only. The certificate is not valid after this time. Only present if parsed is true.
               A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        :param str not_before_time: (Output)
               Output only. The certificate is not valid before this time. Only present if parsed is true.
               A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        :param bool parsed: (Output)
               Output only. True if the certificate was parsed successfully.
        :param str serial_number: (Output)
               Output only. The certificate serial number as a hex string. Only present if parsed is true.
        :param str sha256_fingerprint: (Output)
               Output only. The SHA-256 certificate fingerprint as a hex string. Only present if parsed is true.
        :param str subject: (Output)
               Output only. The subject distinguished name in RFC 2253 format. Only present if parsed is true.
        :param Sequence[str] subject_alternative_dns_names: (Output)
               Output only. The subject Alternative DNS names. Only present if parsed is true.
               
               - - -
        """
        pulumi.set(__self__, "raw_der", raw_der)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if not_after_time is not None:
            pulumi.set(__self__, "not_after_time", not_after_time)
        if not_before_time is not None:
            pulumi.set(__self__, "not_before_time", not_before_time)
        if parsed is not None:
            pulumi.set(__self__, "parsed", parsed)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if sha256_fingerprint is not None:
            pulumi.set(__self__, "sha256_fingerprint", sha256_fingerprint)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if subject_alternative_dns_names is not None:
            pulumi.set(__self__, "subject_alternative_dns_names", subject_alternative_dns_names)

    @property
    @pulumi.getter(name="rawDer")
    def raw_der(self) -> str:
        """
        Required. The raw certificate bytes in DER format. A base64-encoded string.
        """
        return pulumi.get(self, "raw_der")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        (Output)
        Output only. The issuer distinguished name in RFC 2253 format. Only present if parsed is true.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter(name="notAfterTime")
    def not_after_time(self) -> Optional[str]:
        """
        (Output)
        Output only. The certificate is not valid after this time. Only present if parsed is true.
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "not_after_time")

    @property
    @pulumi.getter(name="notBeforeTime")
    def not_before_time(self) -> Optional[str]:
        """
        (Output)
        Output only. The certificate is not valid before this time. Only present if parsed is true.
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "not_before_time")

    @property
    @pulumi.getter
    def parsed(self) -> Optional[bool]:
        """
        (Output)
        Output only. True if the certificate was parsed successfully.
        """
        return pulumi.get(self, "parsed")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        """
        (Output)
        Output only. The certificate serial number as a hex string. Only present if parsed is true.
        """
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter(name="sha256Fingerprint")
    def sha256_fingerprint(self) -> Optional[str]:
        """
        (Output)
        Output only. The SHA-256 certificate fingerprint as a hex string. Only present if parsed is true.
        """
        return pulumi.get(self, "sha256_fingerprint")

    @property
    @pulumi.getter
    def subject(self) -> Optional[str]:
        """
        (Output)
        Output only. The subject distinguished name in RFC 2253 format. Only present if parsed is true.
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="subjectAlternativeDnsNames")
    def subject_alternative_dns_names(self) -> Optional[Sequence[str]]:
        """
        (Output)
        Output only. The subject Alternative DNS names. Only present if parsed is true.

        - - -
        """
        return pulumi.get(self, "subject_alternative_dns_names")


@pulumi.output_type
class KeyRingIAMBindingCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        """
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str title: A title for the expression, i.e. a short string describing its purpose.
        :param str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
               
               > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
               identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
               consider it to be an entirely different resource and will treat it as such.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
        identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
        consider it to be an entirely different resource and will treat it as such.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class KeyRingIAMMemberCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        """
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str title: A title for the expression, i.e. a short string describing its purpose.
        :param str description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
               
               > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
               identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
               consider it to be an entirely different resource and will treat it as such.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
        identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
        consider it to be an entirely different resource and will treat it as such.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class KeyRingImportJobAttestation(dict):
    def __init__(__self__, *,
                 content: Optional[str] = None,
                 format: Optional[str] = None):
        """
        :param str content: (Output)
               The attestation data provided by the HSM when the key operation was performed.
               A base64-encoded string.
        :param str format: (Output)
               The format of the attestation data.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        (Output)
        The attestation data provided by the HSM when the key operation was performed.
        A base64-encoded string.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        (Output)
        The format of the attestation data.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class KeyRingImportJobPublicKey(dict):
    def __init__(__self__, *,
                 pem: Optional[str] = None):
        """
        :param str pem: (Output)
               The public key, encoded in PEM format. For more information, see the RFC 7468 sections
               for General Considerations and Textual Encoding of Subject Public Key Info.
        """
        if pem is not None:
            pulumi.set(__self__, "pem", pem)

    @property
    @pulumi.getter
    def pem(self) -> Optional[str]:
        """
        (Output)
        The public key, encoded in PEM format. For more information, see the RFC 7468 sections
        for General Considerations and Textual Encoding of Subject Public Key Info.
        """
        return pulumi.get(self, "pem")


@pulumi.output_type
class GetKMSCryptoKeyPrimaryResult(dict):
    def __init__(__self__, *,
                 name: str,
                 state: str):
        """
        :param str name: The CryptoKey's name.
               A CryptoKey’s name belonging to the specified Google Cloud Platform KeyRing and match the regular expression `[a-zA-Z0-9_-]{1,63}`
        :param str state: The current state of the CryptoKeyVersion.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The CryptoKey's name.
        A CryptoKey’s name belonging to the specified Google Cloud Platform KeyRing and match the regular expression `[a-zA-Z0-9_-]{1,63}`
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the CryptoKeyVersion.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetKMSCryptoKeyVersionPublicKeyResult(dict):
    def __init__(__self__, *,
                 algorithm: str,
                 pem: str):
        """
        :param str algorithm: The CryptoKeyVersionAlgorithm that this CryptoKeyVersion supports.
        :param str pem: The public key, encoded in PEM format. For more information, see the RFC 7468 sections for General Considerations and Textual Encoding of Subject Public Key Info.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "pem", pem)

    @property
    @pulumi.getter
    def algorithm(self) -> str:
        """
        The CryptoKeyVersionAlgorithm that this CryptoKeyVersion supports.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def pem(self) -> str:
        """
        The public key, encoded in PEM format. For more information, see the RFC 7468 sections for General Considerations and Textual Encoding of Subject Public Key Info.
        """
        return pulumi.get(self, "pem")


@pulumi.output_type
class GetKMSCryptoKeyVersionTemplateResult(dict):
    def __init__(__self__, *,
                 algorithm: str,
                 protection_level: str):
        """
        :param str algorithm: The algorithm to use when creating a version based on this template.
               See the [algorithm reference](https://cloud.google.com/kms/docs/reference/rest/v1/CryptoKeyVersionAlgorithm) for possible inputs.
        :param str protection_level: The protection level to use when creating a version based on this template. Possible values include "SOFTWARE", "HSM", "EXTERNAL", "EXTERNAL_VPC". Defaults to "SOFTWARE".
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "protection_level", protection_level)

    @property
    @pulumi.getter
    def algorithm(self) -> str:
        """
        The algorithm to use when creating a version based on this template.
        See the [algorithm reference](https://cloud.google.com/kms/docs/reference/rest/v1/CryptoKeyVersionAlgorithm) for possible inputs.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="protectionLevel")
    def protection_level(self) -> str:
        """
        The protection level to use when creating a version based on this template. Possible values include "SOFTWARE", "HSM", "EXTERNAL", "EXTERNAL_VPC". Defaults to "SOFTWARE".
        """
        return pulumi.get(self, "protection_level")


