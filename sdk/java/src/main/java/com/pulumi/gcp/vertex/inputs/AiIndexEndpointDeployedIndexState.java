// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.vertex.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.vertex.inputs.AiIndexEndpointDeployedIndexAutomaticResourcesArgs;
import com.pulumi.gcp.vertex.inputs.AiIndexEndpointDeployedIndexDedicatedResourcesArgs;
import com.pulumi.gcp.vertex.inputs.AiIndexEndpointDeployedIndexDeployedIndexAuthConfigArgs;
import com.pulumi.gcp.vertex.inputs.AiIndexEndpointDeployedIndexPrivateEndpointArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class AiIndexEndpointDeployedIndexState extends com.pulumi.resources.ResourceArgs {

    public static final AiIndexEndpointDeployedIndexState Empty = new AiIndexEndpointDeployedIndexState();

    /**
     * A description of resources that the DeployedIndex uses, which to large degree are decided by Vertex AI, and optionally allows only a modest additional configuration.
     * Structure is documented below.
     * 
     */
    @Import(name="automaticResources")
    private @Nullable Output<AiIndexEndpointDeployedIndexAutomaticResourcesArgs> automaticResources;

    /**
     * @return A description of resources that the DeployedIndex uses, which to large degree are decided by Vertex AI, and optionally allows only a modest additional configuration.
     * Structure is documented below.
     * 
     */
    public Optional<Output<AiIndexEndpointDeployedIndexAutomaticResourcesArgs>> automaticResources() {
        return Optional.ofNullable(this.automaticResources);
    }

    /**
     * The timestamp of when the Index was created in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits.
     * 
     */
    @Import(name="createTime")
    private @Nullable Output<String> createTime;

    /**
     * @return The timestamp of when the Index was created in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits.
     * 
     */
    public Optional<Output<String>> createTime() {
        return Optional.ofNullable(this.createTime);
    }

    /**
     * A description of resources that are dedicated to the DeployedIndex, and that need a higher degree of manual configuration. The field minReplicaCount must be set to a value strictly greater than 0, or else validation will fail. We don&#39;t provide SLA when minReplicaCount=1. If maxReplicaCount is not set, the default value is minReplicaCount. The max allowed replica count is 1000.
     * Available machine types for SMALL shard: e2-standard-2 and all machine types available for MEDIUM and LARGE shard.
     * Available machine types for MEDIUM shard: e2-standard-16 and all machine types available for LARGE shard.
     * Available machine types for LARGE shard: e2-highmem-16, n2d-standard-32.
     * n1-standard-16 and n1-standard-32 are still available, but we recommend e2-standard-16 and e2-highmem-16 for cost efficiency.
     * Structure is documented below.
     * 
     */
    @Import(name="dedicatedResources")
    private @Nullable Output<AiIndexEndpointDeployedIndexDedicatedResourcesArgs> dedicatedResources;

    /**
     * @return A description of resources that are dedicated to the DeployedIndex, and that need a higher degree of manual configuration. The field minReplicaCount must be set to a value strictly greater than 0, or else validation will fail. We don&#39;t provide SLA when minReplicaCount=1. If maxReplicaCount is not set, the default value is minReplicaCount. The max allowed replica count is 1000.
     * Available machine types for SMALL shard: e2-standard-2 and all machine types available for MEDIUM and LARGE shard.
     * Available machine types for MEDIUM shard: e2-standard-16 and all machine types available for LARGE shard.
     * Available machine types for LARGE shard: e2-highmem-16, n2d-standard-32.
     * n1-standard-16 and n1-standard-32 are still available, but we recommend e2-standard-16 and e2-highmem-16 for cost efficiency.
     * Structure is documented below.
     * 
     */
    public Optional<Output<AiIndexEndpointDeployedIndexDedicatedResourcesArgs>> dedicatedResources() {
        return Optional.ofNullable(this.dedicatedResources);
    }

    /**
     * If set, the authentication is enabled for the private endpoint.
     * Structure is documented below.
     * 
     */
    @Import(name="deployedIndexAuthConfig")
    private @Nullable Output<AiIndexEndpointDeployedIndexDeployedIndexAuthConfigArgs> deployedIndexAuthConfig;

    /**
     * @return If set, the authentication is enabled for the private endpoint.
     * Structure is documented below.
     * 
     */
    public Optional<Output<AiIndexEndpointDeployedIndexDeployedIndexAuthConfigArgs>> deployedIndexAuthConfig() {
        return Optional.ofNullable(this.deployedIndexAuthConfig);
    }

    /**
     * The user specified ID of the DeployedIndex. The ID can be up to 128 characters long and must start with a letter and only contain letters, numbers, and underscores. The ID must be unique within the project it is created in.
     * 
     */
    @Import(name="deployedIndexId")
    private @Nullable Output<String> deployedIndexId;

    /**
     * @return The user specified ID of the DeployedIndex. The ID can be up to 128 characters long and must start with a letter and only contain letters, numbers, and underscores. The ID must be unique within the project it is created in.
     * 
     */
    public Optional<Output<String>> deployedIndexId() {
        return Optional.ofNullable(this.deployedIndexId);
    }

    /**
     * The deployment group can be no longer than 64 characters (eg: &#39;test&#39;, &#39;prod&#39;). If not set, we will use the &#39;default&#39; deployment group.
     * Creating deployment_groups with reserved_ip_ranges is a recommended practice when the peered network has multiple peering ranges. This creates your deployments from predictable IP spaces for easier traffic administration. Also, one deployment_group (except &#39;default&#39;) can only be used with the same reserved_ip_ranges which means if the deployment_group has been used with reserved_ip_ranges: [a, b, c], using it with [a, b] or [d, e] is disallowed. [See the official documentation here](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#DeployedIndex.FIELDS.deployment_group).
     * Note: we only support up to 5 deployment groups (not including &#39;default&#39;).
     * 
     */
    @Import(name="deploymentGroup")
    private @Nullable Output<String> deploymentGroup;

    /**
     * @return The deployment group can be no longer than 64 characters (eg: &#39;test&#39;, &#39;prod&#39;). If not set, we will use the &#39;default&#39; deployment group.
     * Creating deployment_groups with reserved_ip_ranges is a recommended practice when the peered network has multiple peering ranges. This creates your deployments from predictable IP spaces for easier traffic administration. Also, one deployment_group (except &#39;default&#39;) can only be used with the same reserved_ip_ranges which means if the deployment_group has been used with reserved_ip_ranges: [a, b, c], using it with [a, b] or [d, e] is disallowed. [See the official documentation here](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#DeployedIndex.FIELDS.deployment_group).
     * Note: we only support up to 5 deployment groups (not including &#39;default&#39;).
     * 
     */
    public Optional<Output<String>> deploymentGroup() {
        return Optional.ofNullable(this.deploymentGroup);
    }

    /**
     * The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
     * 
     */
    @Import(name="displayName")
    private @Nullable Output<String> displayName;

    /**
     * @return The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
     * 
     */
    public Optional<Output<String>> displayName() {
        return Optional.ofNullable(this.displayName);
    }

    /**
     * If true, private endpoint&#39;s access logs are sent to Cloud Logging.
     * 
     */
    @Import(name="enableAccessLogging")
    private @Nullable Output<Boolean> enableAccessLogging;

    /**
     * @return If true, private endpoint&#39;s access logs are sent to Cloud Logging.
     * 
     */
    public Optional<Output<Boolean>> enableAccessLogging() {
        return Optional.ofNullable(this.enableAccessLogging);
    }

    /**
     * The name of the Index this is the deployment of.
     * 
     */
    @Import(name="index")
    private @Nullable Output<String> index;

    /**
     * @return The name of the Index this is the deployment of.
     * 
     */
    public Optional<Output<String>> index() {
        return Optional.ofNullable(this.index);
    }

    /**
     * Identifies the index endpoint. Must be in the format
     * &#39;projects/{{project}}/locations/{{region}}/indexEndpoints/{{indexEndpoint}}&#39;
     * 
     */
    @Import(name="indexEndpoint")
    private @Nullable Output<String> indexEndpoint;

    /**
     * @return Identifies the index endpoint. Must be in the format
     * &#39;projects/{{project}}/locations/{{region}}/indexEndpoints/{{indexEndpoint}}&#39;
     * 
     */
    public Optional<Output<String>> indexEndpoint() {
        return Optional.ofNullable(this.indexEndpoint);
    }

    /**
     * The DeployedIndex may depend on various data on its original Index. Additionally when certain changes to the original Index are being done (e.g. when what the Index contains is being changed) the DeployedIndex may be asynchronously updated in the background to reflect these changes. If this timestamp&#39;s value is at least the [Index.update_time](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexes#Index.FIELDS.update_time) of the original Index, it means that this DeployedIndex and the original Index are in sync. If this timestamp is older, then to see which updates this DeployedIndex already contains (and which it does not), one must [list](https://cloud.google.com/vertex-ai/docs/reference/rest/v1beta1/projects.locations.operations/list#google.longrunning.Operations.ListOperations) the operations that are running on the original Index. Only the successfully completed Operations with updateTime equal or before this sync time are contained in this DeployedIndex.
     * A timestamp in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits. Examples: &#34;2014-10-02T15:01:23Z&#34; and &#34;2014-10-02T15:01:23.045123456Z&#34;.
     * 
     */
    @Import(name="indexSyncTime")
    private @Nullable Output<String> indexSyncTime;

    /**
     * @return The DeployedIndex may depend on various data on its original Index. Additionally when certain changes to the original Index are being done (e.g. when what the Index contains is being changed) the DeployedIndex may be asynchronously updated in the background to reflect these changes. If this timestamp&#39;s value is at least the [Index.update_time](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexes#Index.FIELDS.update_time) of the original Index, it means that this DeployedIndex and the original Index are in sync. If this timestamp is older, then to see which updates this DeployedIndex already contains (and which it does not), one must [list](https://cloud.google.com/vertex-ai/docs/reference/rest/v1beta1/projects.locations.operations/list#google.longrunning.Operations.ListOperations) the operations that are running on the original Index. Only the successfully completed Operations with updateTime equal or before this sync time are contained in this DeployedIndex.
     * A timestamp in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits. Examples: &#34;2014-10-02T15:01:23Z&#34; and &#34;2014-10-02T15:01:23.045123456Z&#34;.
     * 
     */
    public Optional<Output<String>> indexSyncTime() {
        return Optional.ofNullable(this.indexSyncTime);
    }

    /**
     * The name of the DeployedIndex resource.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the DeployedIndex resource.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Provides paths for users to send requests directly to the deployed index services running on Cloud via private services access. This field is populated if [network](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#IndexEndpoint.FIELDS.network) is configured.
     * Structure is documented below.
     * 
     */
    @Import(name="privateEndpoints")
    private @Nullable Output<List<AiIndexEndpointDeployedIndexPrivateEndpointArgs>> privateEndpoints;

    /**
     * @return Provides paths for users to send requests directly to the deployed index services running on Cloud via private services access. This field is populated if [network](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#IndexEndpoint.FIELDS.network) is configured.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<AiIndexEndpointDeployedIndexPrivateEndpointArgs>>> privateEndpoints() {
        return Optional.ofNullable(this.privateEndpoints);
    }

    /**
     * The region of the index endpoint deployment. eg us-central1
     * 
     */
    @Import(name="region")
    private @Nullable Output<String> region;

    /**
     * @return The region of the index endpoint deployment. eg us-central1
     * 
     */
    public Optional<Output<String>> region() {
        return Optional.ofNullable(this.region);
    }

    /**
     * A list of reserved ip ranges under the VPC network that can be used for this DeployedIndex.
     * If set, we will deploy the index within the provided ip ranges. Otherwise, the index might be deployed to any ip ranges under the provided VPC network.
     * The value should be the name of the address (https://cloud.google.com/compute/docs/reference/rest/v1/addresses) Example: [&#39;vertex-ai-ip-range&#39;].
     * For more information about subnets and network IP ranges, please see https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges.
     * 
     */
    @Import(name="reservedIpRanges")
    private @Nullable Output<List<String>> reservedIpRanges;

    /**
     * @return A list of reserved ip ranges under the VPC network that can be used for this DeployedIndex.
     * If set, we will deploy the index within the provided ip ranges. Otherwise, the index might be deployed to any ip ranges under the provided VPC network.
     * The value should be the name of the address (https://cloud.google.com/compute/docs/reference/rest/v1/addresses) Example: [&#39;vertex-ai-ip-range&#39;].
     * For more information about subnets and network IP ranges, please see https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges.
     * 
     */
    public Optional<Output<List<String>>> reservedIpRanges() {
        return Optional.ofNullable(this.reservedIpRanges);
    }

    private AiIndexEndpointDeployedIndexState() {}

    private AiIndexEndpointDeployedIndexState(AiIndexEndpointDeployedIndexState $) {
        this.automaticResources = $.automaticResources;
        this.createTime = $.createTime;
        this.dedicatedResources = $.dedicatedResources;
        this.deployedIndexAuthConfig = $.deployedIndexAuthConfig;
        this.deployedIndexId = $.deployedIndexId;
        this.deploymentGroup = $.deploymentGroup;
        this.displayName = $.displayName;
        this.enableAccessLogging = $.enableAccessLogging;
        this.index = $.index;
        this.indexEndpoint = $.indexEndpoint;
        this.indexSyncTime = $.indexSyncTime;
        this.name = $.name;
        this.privateEndpoints = $.privateEndpoints;
        this.region = $.region;
        this.reservedIpRanges = $.reservedIpRanges;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(AiIndexEndpointDeployedIndexState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private AiIndexEndpointDeployedIndexState $;

        public Builder() {
            $ = new AiIndexEndpointDeployedIndexState();
        }

        public Builder(AiIndexEndpointDeployedIndexState defaults) {
            $ = new AiIndexEndpointDeployedIndexState(Objects.requireNonNull(defaults));
        }

        /**
         * @param automaticResources A description of resources that the DeployedIndex uses, which to large degree are decided by Vertex AI, and optionally allows only a modest additional configuration.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder automaticResources(@Nullable Output<AiIndexEndpointDeployedIndexAutomaticResourcesArgs> automaticResources) {
            $.automaticResources = automaticResources;
            return this;
        }

        /**
         * @param automaticResources A description of resources that the DeployedIndex uses, which to large degree are decided by Vertex AI, and optionally allows only a modest additional configuration.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder automaticResources(AiIndexEndpointDeployedIndexAutomaticResourcesArgs automaticResources) {
            return automaticResources(Output.of(automaticResources));
        }

        /**
         * @param createTime The timestamp of when the Index was created in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits.
         * 
         * @return builder
         * 
         */
        public Builder createTime(@Nullable Output<String> createTime) {
            $.createTime = createTime;
            return this;
        }

        /**
         * @param createTime The timestamp of when the Index was created in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits.
         * 
         * @return builder
         * 
         */
        public Builder createTime(String createTime) {
            return createTime(Output.of(createTime));
        }

        /**
         * @param dedicatedResources A description of resources that are dedicated to the DeployedIndex, and that need a higher degree of manual configuration. The field minReplicaCount must be set to a value strictly greater than 0, or else validation will fail. We don&#39;t provide SLA when minReplicaCount=1. If maxReplicaCount is not set, the default value is minReplicaCount. The max allowed replica count is 1000.
         * Available machine types for SMALL shard: e2-standard-2 and all machine types available for MEDIUM and LARGE shard.
         * Available machine types for MEDIUM shard: e2-standard-16 and all machine types available for LARGE shard.
         * Available machine types for LARGE shard: e2-highmem-16, n2d-standard-32.
         * n1-standard-16 and n1-standard-32 are still available, but we recommend e2-standard-16 and e2-highmem-16 for cost efficiency.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder dedicatedResources(@Nullable Output<AiIndexEndpointDeployedIndexDedicatedResourcesArgs> dedicatedResources) {
            $.dedicatedResources = dedicatedResources;
            return this;
        }

        /**
         * @param dedicatedResources A description of resources that are dedicated to the DeployedIndex, and that need a higher degree of manual configuration. The field minReplicaCount must be set to a value strictly greater than 0, or else validation will fail. We don&#39;t provide SLA when minReplicaCount=1. If maxReplicaCount is not set, the default value is minReplicaCount. The max allowed replica count is 1000.
         * Available machine types for SMALL shard: e2-standard-2 and all machine types available for MEDIUM and LARGE shard.
         * Available machine types for MEDIUM shard: e2-standard-16 and all machine types available for LARGE shard.
         * Available machine types for LARGE shard: e2-highmem-16, n2d-standard-32.
         * n1-standard-16 and n1-standard-32 are still available, but we recommend e2-standard-16 and e2-highmem-16 for cost efficiency.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder dedicatedResources(AiIndexEndpointDeployedIndexDedicatedResourcesArgs dedicatedResources) {
            return dedicatedResources(Output.of(dedicatedResources));
        }

        /**
         * @param deployedIndexAuthConfig If set, the authentication is enabled for the private endpoint.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder deployedIndexAuthConfig(@Nullable Output<AiIndexEndpointDeployedIndexDeployedIndexAuthConfigArgs> deployedIndexAuthConfig) {
            $.deployedIndexAuthConfig = deployedIndexAuthConfig;
            return this;
        }

        /**
         * @param deployedIndexAuthConfig If set, the authentication is enabled for the private endpoint.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder deployedIndexAuthConfig(AiIndexEndpointDeployedIndexDeployedIndexAuthConfigArgs deployedIndexAuthConfig) {
            return deployedIndexAuthConfig(Output.of(deployedIndexAuthConfig));
        }

        /**
         * @param deployedIndexId The user specified ID of the DeployedIndex. The ID can be up to 128 characters long and must start with a letter and only contain letters, numbers, and underscores. The ID must be unique within the project it is created in.
         * 
         * @return builder
         * 
         */
        public Builder deployedIndexId(@Nullable Output<String> deployedIndexId) {
            $.deployedIndexId = deployedIndexId;
            return this;
        }

        /**
         * @param deployedIndexId The user specified ID of the DeployedIndex. The ID can be up to 128 characters long and must start with a letter and only contain letters, numbers, and underscores. The ID must be unique within the project it is created in.
         * 
         * @return builder
         * 
         */
        public Builder deployedIndexId(String deployedIndexId) {
            return deployedIndexId(Output.of(deployedIndexId));
        }

        /**
         * @param deploymentGroup The deployment group can be no longer than 64 characters (eg: &#39;test&#39;, &#39;prod&#39;). If not set, we will use the &#39;default&#39; deployment group.
         * Creating deployment_groups with reserved_ip_ranges is a recommended practice when the peered network has multiple peering ranges. This creates your deployments from predictable IP spaces for easier traffic administration. Also, one deployment_group (except &#39;default&#39;) can only be used with the same reserved_ip_ranges which means if the deployment_group has been used with reserved_ip_ranges: [a, b, c], using it with [a, b] or [d, e] is disallowed. [See the official documentation here](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#DeployedIndex.FIELDS.deployment_group).
         * Note: we only support up to 5 deployment groups (not including &#39;default&#39;).
         * 
         * @return builder
         * 
         */
        public Builder deploymentGroup(@Nullable Output<String> deploymentGroup) {
            $.deploymentGroup = deploymentGroup;
            return this;
        }

        /**
         * @param deploymentGroup The deployment group can be no longer than 64 characters (eg: &#39;test&#39;, &#39;prod&#39;). If not set, we will use the &#39;default&#39; deployment group.
         * Creating deployment_groups with reserved_ip_ranges is a recommended practice when the peered network has multiple peering ranges. This creates your deployments from predictable IP spaces for easier traffic administration. Also, one deployment_group (except &#39;default&#39;) can only be used with the same reserved_ip_ranges which means if the deployment_group has been used with reserved_ip_ranges: [a, b, c], using it with [a, b] or [d, e] is disallowed. [See the official documentation here](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#DeployedIndex.FIELDS.deployment_group).
         * Note: we only support up to 5 deployment groups (not including &#39;default&#39;).
         * 
         * @return builder
         * 
         */
        public Builder deploymentGroup(String deploymentGroup) {
            return deploymentGroup(Output.of(deploymentGroup));
        }

        /**
         * @param displayName The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
         * 
         * @return builder
         * 
         */
        public Builder displayName(@Nullable Output<String> displayName) {
            $.displayName = displayName;
            return this;
        }

        /**
         * @param displayName The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
         * 
         * @return builder
         * 
         */
        public Builder displayName(String displayName) {
            return displayName(Output.of(displayName));
        }

        /**
         * @param enableAccessLogging If true, private endpoint&#39;s access logs are sent to Cloud Logging.
         * 
         * @return builder
         * 
         */
        public Builder enableAccessLogging(@Nullable Output<Boolean> enableAccessLogging) {
            $.enableAccessLogging = enableAccessLogging;
            return this;
        }

        /**
         * @param enableAccessLogging If true, private endpoint&#39;s access logs are sent to Cloud Logging.
         * 
         * @return builder
         * 
         */
        public Builder enableAccessLogging(Boolean enableAccessLogging) {
            return enableAccessLogging(Output.of(enableAccessLogging));
        }

        /**
         * @param index The name of the Index this is the deployment of.
         * 
         * @return builder
         * 
         */
        public Builder index(@Nullable Output<String> index) {
            $.index = index;
            return this;
        }

        /**
         * @param index The name of the Index this is the deployment of.
         * 
         * @return builder
         * 
         */
        public Builder index(String index) {
            return index(Output.of(index));
        }

        /**
         * @param indexEndpoint Identifies the index endpoint. Must be in the format
         * &#39;projects/{{project}}/locations/{{region}}/indexEndpoints/{{indexEndpoint}}&#39;
         * 
         * @return builder
         * 
         */
        public Builder indexEndpoint(@Nullable Output<String> indexEndpoint) {
            $.indexEndpoint = indexEndpoint;
            return this;
        }

        /**
         * @param indexEndpoint Identifies the index endpoint. Must be in the format
         * &#39;projects/{{project}}/locations/{{region}}/indexEndpoints/{{indexEndpoint}}&#39;
         * 
         * @return builder
         * 
         */
        public Builder indexEndpoint(String indexEndpoint) {
            return indexEndpoint(Output.of(indexEndpoint));
        }

        /**
         * @param indexSyncTime The DeployedIndex may depend on various data on its original Index. Additionally when certain changes to the original Index are being done (e.g. when what the Index contains is being changed) the DeployedIndex may be asynchronously updated in the background to reflect these changes. If this timestamp&#39;s value is at least the [Index.update_time](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexes#Index.FIELDS.update_time) of the original Index, it means that this DeployedIndex and the original Index are in sync. If this timestamp is older, then to see which updates this DeployedIndex already contains (and which it does not), one must [list](https://cloud.google.com/vertex-ai/docs/reference/rest/v1beta1/projects.locations.operations/list#google.longrunning.Operations.ListOperations) the operations that are running on the original Index. Only the successfully completed Operations with updateTime equal or before this sync time are contained in this DeployedIndex.
         * A timestamp in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits. Examples: &#34;2014-10-02T15:01:23Z&#34; and &#34;2014-10-02T15:01:23.045123456Z&#34;.
         * 
         * @return builder
         * 
         */
        public Builder indexSyncTime(@Nullable Output<String> indexSyncTime) {
            $.indexSyncTime = indexSyncTime;
            return this;
        }

        /**
         * @param indexSyncTime The DeployedIndex may depend on various data on its original Index. Additionally when certain changes to the original Index are being done (e.g. when what the Index contains is being changed) the DeployedIndex may be asynchronously updated in the background to reflect these changes. If this timestamp&#39;s value is at least the [Index.update_time](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexes#Index.FIELDS.update_time) of the original Index, it means that this DeployedIndex and the original Index are in sync. If this timestamp is older, then to see which updates this DeployedIndex already contains (and which it does not), one must [list](https://cloud.google.com/vertex-ai/docs/reference/rest/v1beta1/projects.locations.operations/list#google.longrunning.Operations.ListOperations) the operations that are running on the original Index. Only the successfully completed Operations with updateTime equal or before this sync time are contained in this DeployedIndex.
         * A timestamp in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits. Examples: &#34;2014-10-02T15:01:23Z&#34; and &#34;2014-10-02T15:01:23.045123456Z&#34;.
         * 
         * @return builder
         * 
         */
        public Builder indexSyncTime(String indexSyncTime) {
            return indexSyncTime(Output.of(indexSyncTime));
        }

        /**
         * @param name The name of the DeployedIndex resource.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the DeployedIndex resource.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param privateEndpoints Provides paths for users to send requests directly to the deployed index services running on Cloud via private services access. This field is populated if [network](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#IndexEndpoint.FIELDS.network) is configured.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder privateEndpoints(@Nullable Output<List<AiIndexEndpointDeployedIndexPrivateEndpointArgs>> privateEndpoints) {
            $.privateEndpoints = privateEndpoints;
            return this;
        }

        /**
         * @param privateEndpoints Provides paths for users to send requests directly to the deployed index services running on Cloud via private services access. This field is populated if [network](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#IndexEndpoint.FIELDS.network) is configured.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder privateEndpoints(List<AiIndexEndpointDeployedIndexPrivateEndpointArgs> privateEndpoints) {
            return privateEndpoints(Output.of(privateEndpoints));
        }

        /**
         * @param privateEndpoints Provides paths for users to send requests directly to the deployed index services running on Cloud via private services access. This field is populated if [network](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#IndexEndpoint.FIELDS.network) is configured.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder privateEndpoints(AiIndexEndpointDeployedIndexPrivateEndpointArgs... privateEndpoints) {
            return privateEndpoints(List.of(privateEndpoints));
        }

        /**
         * @param region The region of the index endpoint deployment. eg us-central1
         * 
         * @return builder
         * 
         */
        public Builder region(@Nullable Output<String> region) {
            $.region = region;
            return this;
        }

        /**
         * @param region The region of the index endpoint deployment. eg us-central1
         * 
         * @return builder
         * 
         */
        public Builder region(String region) {
            return region(Output.of(region));
        }

        /**
         * @param reservedIpRanges A list of reserved ip ranges under the VPC network that can be used for this DeployedIndex.
         * If set, we will deploy the index within the provided ip ranges. Otherwise, the index might be deployed to any ip ranges under the provided VPC network.
         * The value should be the name of the address (https://cloud.google.com/compute/docs/reference/rest/v1/addresses) Example: [&#39;vertex-ai-ip-range&#39;].
         * For more information about subnets and network IP ranges, please see https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges.
         * 
         * @return builder
         * 
         */
        public Builder reservedIpRanges(@Nullable Output<List<String>> reservedIpRanges) {
            $.reservedIpRanges = reservedIpRanges;
            return this;
        }

        /**
         * @param reservedIpRanges A list of reserved ip ranges under the VPC network that can be used for this DeployedIndex.
         * If set, we will deploy the index within the provided ip ranges. Otherwise, the index might be deployed to any ip ranges under the provided VPC network.
         * The value should be the name of the address (https://cloud.google.com/compute/docs/reference/rest/v1/addresses) Example: [&#39;vertex-ai-ip-range&#39;].
         * For more information about subnets and network IP ranges, please see https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges.
         * 
         * @return builder
         * 
         */
        public Builder reservedIpRanges(List<String> reservedIpRanges) {
            return reservedIpRanges(Output.of(reservedIpRanges));
        }

        /**
         * @param reservedIpRanges A list of reserved ip ranges under the VPC network that can be used for this DeployedIndex.
         * If set, we will deploy the index within the provided ip ranges. Otherwise, the index might be deployed to any ip ranges under the provided VPC network.
         * The value should be the name of the address (https://cloud.google.com/compute/docs/reference/rest/v1/addresses) Example: [&#39;vertex-ai-ip-range&#39;].
         * For more information about subnets and network IP ranges, please see https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges.
         * 
         * @return builder
         * 
         */
        public Builder reservedIpRanges(String... reservedIpRanges) {
            return reservedIpRanges(List.of(reservedIpRanges));
        }

        public AiIndexEndpointDeployedIndexState build() {
            return $;
        }
    }

}
