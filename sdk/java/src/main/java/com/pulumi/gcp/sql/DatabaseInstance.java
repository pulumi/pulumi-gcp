// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.sql;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.sql.DatabaseInstanceArgs;
import com.pulumi.gcp.sql.inputs.DatabaseInstanceState;
import com.pulumi.gcp.sql.outputs.DatabaseInstanceClone;
import com.pulumi.gcp.sql.outputs.DatabaseInstanceDnsName;
import com.pulumi.gcp.sql.outputs.DatabaseInstanceIpAddress;
import com.pulumi.gcp.sql.outputs.DatabaseInstancePointInTimeRestoreContext;
import com.pulumi.gcp.sql.outputs.DatabaseInstanceReplicaConfiguration;
import com.pulumi.gcp.sql.outputs.DatabaseInstanceReplicationCluster;
import com.pulumi.gcp.sql.outputs.DatabaseInstanceRestoreBackupContext;
import com.pulumi.gcp.sql.outputs.DatabaseInstanceServerCaCert;
import com.pulumi.gcp.sql.outputs.DatabaseInstanceSettings;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Creates a new Google SQL Database Instance. For more information, see the [official documentation](https://cloud.google.com/sql/docs/mysql/create-instance),
 * or the [JSON API](https://cloud.google.com/sql/docs/admin-api/v1beta4/instances).
 * 
 * &gt; **NOTE on `gcp.sql.DatabaseInstance`:** - Second-generation instances include a
 * default &#39;root&#39;{@literal @}&#39;%&#39; user with no password. This user will be deleted by the provider on
 * instance creation. You should use `gcp.sql.User` to define a custom user with
 * a restricted host and strong password.
 * 
 * &gt; **Note**: On newer versions of the provider, you must explicitly set `deletion_protection=false`
 * (and run `pulumi update` to write the field to state) in order to destroy an instance.
 * It is recommended to not set this field (or set it to true) until you&#39;re ready to destroy the instance and its databases.
 * 
 * ## Example Usage
 * 
 * ### SQL Second Generation Instance
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.sql.DatabaseInstance;
 * import com.pulumi.gcp.sql.DatabaseInstanceArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var main = new DatabaseInstance("main", DatabaseInstanceArgs.builder()
 *             .name("main-instance")
 *             .databaseVersion("POSTGRES_15")
 *             .region("us-central1")
 *             .settings(DatabaseInstanceSettingsArgs.builder()
 *                 .tier("db-f1-micro")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Granular restriction of network access
 * 
 * ### Private IP Instance
 * &gt; **NOTE:** For private IP instance setup, note that the `gcp.sql.DatabaseInstance` does not actually interpolate values from `gcp.servicenetworking.Connection`. You must explicitly add a `dependsOn`reference as shown below.
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.Network;
 * import com.pulumi.gcp.compute.NetworkArgs;
 * import com.pulumi.gcp.compute.GlobalAddress;
 * import com.pulumi.gcp.compute.GlobalAddressArgs;
 * import com.pulumi.gcp.servicenetworking.Connection;
 * import com.pulumi.gcp.servicenetworking.ConnectionArgs;
 * import com.pulumi.random.Id;
 * import com.pulumi.random.IdArgs;
 * import com.pulumi.gcp.sql.DatabaseInstance;
 * import com.pulumi.gcp.sql.DatabaseInstanceArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsIpConfigurationArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var privateNetwork = new Network("privateNetwork", NetworkArgs.builder()
 *             .name("private-network")
 *             .build());
 * 
 *         var privateIpAddress = new GlobalAddress("privateIpAddress", GlobalAddressArgs.builder()
 *             .name("private-ip-address")
 *             .purpose("VPC_PEERING")
 *             .addressType("INTERNAL")
 *             .prefixLength(16)
 *             .network(privateNetwork.id())
 *             .build());
 * 
 *         var privateVpcConnection = new Connection("privateVpcConnection", ConnectionArgs.builder()
 *             .network(privateNetwork.id())
 *             .service("servicenetworking.googleapis.com")
 *             .reservedPeeringRanges(privateIpAddress.name())
 *             .build());
 * 
 *         var dbNameSuffix = new Id("dbNameSuffix", IdArgs.builder()
 *             .byteLength(4)
 *             .build());
 * 
 *         var instance = new DatabaseInstance("instance", DatabaseInstanceArgs.builder()
 *             .name(String.format("private-instance-%s", dbNameSuffix.hex()))
 *             .region("us-central1")
 *             .databaseVersion("MYSQL_5_7")
 *             .settings(DatabaseInstanceSettingsArgs.builder()
 *                 .tier("db-f1-micro")
 *                 .ipConfiguration(DatabaseInstanceSettingsIpConfigurationArgs.builder()
 *                     .ipv4Enabled(false)
 *                     .privateNetwork(privateNetwork.selfLink())
 *                     .enablePrivatePathForGoogleCloudServices(true)
 *                     .build())
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(privateVpcConnection)
 *                 .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### ENTERPRISE_PLUS Instance with dataCacheConfig
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.sql.DatabaseInstance;
 * import com.pulumi.gcp.sql.DatabaseInstanceArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsDataCacheConfigArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var main = new DatabaseInstance("main", DatabaseInstanceArgs.builder()
 *             .name("enterprise-plus-main-instance")
 *             .databaseVersion("MYSQL_8_0_31")
 *             .settings(DatabaseInstanceSettingsArgs.builder()
 *                 .tier("db-perf-optimized-N-2")
 *                 .edition("ENTERPRISE_PLUS")
 *                 .dataCacheConfig(DatabaseInstanceSettingsDataCacheConfigArgs.builder()
 *                     .dataCacheEnabled(true)
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Cloud SQL Instance with Managed Connection Pooling
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.sql.DatabaseInstance;
 * import com.pulumi.gcp.sql.DatabaseInstanceArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var instance = new DatabaseInstance("instance", DatabaseInstanceArgs.builder()
 *             .name("mcp-enabled-main-instance")
 *             .region("us-central1")
 *             .databaseVersion("POSTGRES_16")
 *             .settings(DatabaseInstanceSettingsArgs.builder()
 *                 .tier("db-perf-optimized-N-2")
 *                 .edition("ENTERPRISE_PLUS")
 *                 .connectionPoolConfigs(DatabaseInstanceSettingsConnectionPoolConfigArgs.builder()
 *                     .connectionPoolingEnabled(true)
 *                     .flags(DatabaseInstanceSettingsConnectionPoolConfigFlagArgs.builder()
 *                         .name("max_client_connections")
 *                         .value("1980")
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Cloud SQL Instance with PSC connectivity
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.sql.DatabaseInstance;
 * import com.pulumi.gcp.sql.DatabaseInstanceArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsIpConfigurationArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsBackupConfigurationArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var main = new DatabaseInstance("main", DatabaseInstanceArgs.builder()
 *             .name("psc-enabled-main-instance")
 *             .databaseVersion("MYSQL_8_0")
 *             .settings(DatabaseInstanceSettingsArgs.builder()
 *                 .tier("db-f1-micro")
 *                 .ipConfiguration(DatabaseInstanceSettingsIpConfigurationArgs.builder()
 *                     .pscConfigs(DatabaseInstanceSettingsIpConfigurationPscConfigArgs.builder()
 *                         .pscEnabled(true)
 *                         .allowedConsumerProjects("allowed-consumer-project-name")
 *                         .build())
 *                     .ipv4Enabled(false)
 *                     .build())
 *                 .backupConfiguration(DatabaseInstanceSettingsBackupConfigurationArgs.builder()
 *                     .enabled(true)
 *                     .binaryLogEnabled(true)
 *                     .build())
 *                 .availabilityType("REGIONAL")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Cloud SQL Instance with PSC auto connections
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.sql.DatabaseInstance;
 * import com.pulumi.gcp.sql.DatabaseInstanceArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsIpConfigurationArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsBackupConfigurationArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var main = new DatabaseInstance("main", DatabaseInstanceArgs.builder()
 *             .name("psc-enabled-main-instance")
 *             .databaseVersion("MYSQL_8_0")
 *             .settings(DatabaseInstanceSettingsArgs.builder()
 *                 .tier("db-f1-micro")
 *                 .ipConfiguration(DatabaseInstanceSettingsIpConfigurationArgs.builder()
 *                     .pscConfigs(DatabaseInstanceSettingsIpConfigurationPscConfigArgs.builder()
 *                         .pscEnabled(true)
 *                         .allowedConsumerProjects("allowed-consumer-project-name")
 *                         .pscAutoConnections(DatabaseInstanceSettingsIpConfigurationPscConfigPscAutoConnectionArgs.builder()
 *                             .consumerNetwork("network-name")
 *                             .consumerServiceProjectId("project-id")
 *                             .build())
 *                         .build())
 *                     .ipv4Enabled(false)
 *                     .build())
 *                 .backupConfiguration(DatabaseInstanceSettingsBackupConfigurationArgs.builder()
 *                     .enabled(true)
 *                     .binaryLogEnabled(true)
 *                     .build())
 *                 .availabilityType("REGIONAL")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Cloud SQL Instance with PSC outbound
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.sql.DatabaseInstance;
 * import com.pulumi.gcp.sql.DatabaseInstanceArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsIpConfigurationArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsBackupConfigurationArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var main = new DatabaseInstance("main", DatabaseInstanceArgs.builder()
 *             .name("psc-enabled-main-instance")
 *             .databaseVersion("MYSQL_8_0")
 *             .settings(DatabaseInstanceSettingsArgs.builder()
 *                 .tier("db-f1-micro")
 *                 .ipConfiguration(DatabaseInstanceSettingsIpConfigurationArgs.builder()
 *                     .pscConfigs(DatabaseInstanceSettingsIpConfigurationPscConfigArgs.builder()
 *                         .pscEnabled(true)
 *                         .allowedConsumerProjects("allowed-consumer-project-name")
 *                         .networkAttachmentUri("network-attachment-uri")
 *                         .build())
 *                     .ipv4Enabled(false)
 *                     .build())
 *                 .backupConfiguration(DatabaseInstanceSettingsBackupConfigurationArgs.builder()
 *                     .enabled(true)
 *                     .binaryLogEnabled(true)
 *                     .build())
 *                 .availabilityType("REGIONAL")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Cloud SQL Instance created with backupdrBackup
 * &gt; **NOTE:** For restoring from a backupdr_backup, note that the backup must be in active state. List down the backups using `gcp.backupdisasterrecovery.getBackup`. Replace `backupdrBackupFullPath` with the backup name.
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.sql.DatabaseInstance;
 * import com.pulumi.gcp.sql.DatabaseInstanceArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsBackupConfigurationArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var instance = new DatabaseInstance("instance", DatabaseInstanceArgs.builder()
 *             .name("main-instance")
 *             .databaseVersion("MYSQL_8_0")
 *             .settings(DatabaseInstanceSettingsArgs.builder()
 *                 .tier("db-f1-micro")
 *                 .backupConfiguration(DatabaseInstanceSettingsBackupConfigurationArgs.builder()
 *                     .enabled(true)
 *                     .binaryLogEnabled(true)
 *                     .build())
 *                 .build())
 *             .backupdrBackup("backupdr_backup_full_path")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Cloud SQL Instance created using pointInTimeRestore
 * &gt; **NOTE:** Replace `backupdrDatasource` with the full datasource path, `timeStamp` should be in the format of `YYYY-MM-DDTHH:MM:SSZ`.
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.sql.DatabaseInstance;
 * import com.pulumi.gcp.sql.DatabaseInstanceArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstanceSettingsBackupConfigurationArgs;
 * import com.pulumi.gcp.sql.inputs.DatabaseInstancePointInTimeRestoreContextArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var instance = new DatabaseInstance("instance", DatabaseInstanceArgs.builder()
 *             .name("main-instance")
 *             .databaseVersion("MYSQL_8_0")
 *             .settings(DatabaseInstanceSettingsArgs.builder()
 *                 .tier("db-f1-micro")
 *                 .backupConfiguration(DatabaseInstanceSettingsBackupConfigurationArgs.builder()
 *                     .enabled(true)
 *                     .binaryLogEnabled(true)
 *                     .build())
 *                 .build())
 *             .pointInTimeRestoreContext(DatabaseInstancePointInTimeRestoreContextArgs.builder()
 *                 .datasource("backupdr_datasource")
 *                 .targetInstance("target_instance_name")
 *                 .pointInTime("time_stamp")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Switchover
 * 
 * Users can perform a switchover on a replica by following the steps below.
 * 
 *   ~&gt;**WARNING:** Failure to follow these steps can lead to data loss (You will be warned during plan stage). To prevent data loss during a switchover, please verify your plan with the checklist below.
 * 
 * For a more in-depth walkthrough with example code, see the Switchover Guide
 * 
 * ### Steps to Invoke Switchover
 * 
 * MySQL/PostgreSQL: Create a cross-region, Enterprise Plus edition primary and replica pair, then set the value of primary&#39;s `replication_cluster.failover_dr_replica_name` as the replica.
 * 
 * SQL Server: Create a `cascadable` replica in a different region from the primary (`cascadableReplica` is set to true in `replicaConfiguration`)
 * 
 * #### Invoking switchover in the replica resource:
 * 1. Change instanceType from `READ_REPLICA_INSTANCE` to `CLOUD_SQL_INSTANCE`
 * 2. Remove `masterInstanceName`
 * 3. (SQL Server) Remove `replicaConfiguration`
 * 4. Add current primary&#39;s name to the replica&#39;s `replicaNames` list
 * 5. (MySQL/PostgreSQL) Add current primary&#39;s name to the replica&#39;s `replication_cluster.failover_dr_replica_name`.
 * 6. (MySQL/PostgreSQL) Adjust `backupConfiguration`. See Switchover Guide for details.
 * 
 * #### Updating the primary resource:
 * 1. Change `instanceType` from `CLOUD_SQL_INSTANCE` to `READ_REPLICA_INSTANCE`
 * 2. Set `masterInstanceName` to the original replica (which will be primary after switchover)
 * 3. (SQL Server) Set `replicaConfiguration` and set `cascadableReplica` to `true`
 * 4. Remove original replica from `replicaNames`
 *    * **NOTE**: Do **not** delete the replicaNames field, even if it has no replicas remaining. Set replicaNames = [ ] to indicate it having no replicas.
 * 5. (MySQL/PostgreSQL) Set `replication_cluster.failover_dr_replica_name` as the empty string.
 * 6. (MySQL/PostgreSQL) Adjust `backupConfiguration`. See Switchover Guide for details.
 * #### Plan and verify that:
 * - `pulumi preview` outputs **&#34;0 to add, 0 to destroy&#34;**
 * - `pulumi preview` does not say **&#34;must be replaced&#34;** for any resource
 * - Every resource **&#34;will be updated in-place&#34;**
 * - Only the 2 instances involved in switchover have planned changes
 * - (Recommended) Use `deletionProtection` on instances as a safety measure
 * 
 * ## Import
 * 
 * Database instances can be imported using one of any of these accepted formats:
 * 
 * * `projects/{{project}}/instances/{{name}}`
 * * `{{project}}/{{name}}`
 * * `{{name}}`
 * 
 * When using the `pulumi import` command, Database instances can be imported using one of the formats above. For example:
 * 
 * ```sh
 * $ pulumi import gcp:sql/databaseInstance:DatabaseInstance default projects/{{project}}/instances/{{name}}
 * $ pulumi import gcp:sql/databaseInstance:DatabaseInstance default {{project}}/{{name}}
 * $ pulumi import gcp:sql/databaseInstance:DatabaseInstance default {{name}}
 * ```
 * 
 * &gt; **NOTE:** Some fields (such as `replicaConfiguration`) won&#39;t show a diff if they are unset in
 * config and set on the server.
 * When importing, double-check that your config has all the fields set that you expect- just seeing
 * no diff isn&#39;t sufficient to know that your config could reproduce the imported resource.
 * 
 */
@ResourceType(type="gcp:sql/databaseInstance:DatabaseInstance")
public class DatabaseInstance extends com.pulumi.resources.CustomResource {
    /**
     * The list of all maintenance versions applicable on the instance.
     * 
     */
    @Export(name="availableMaintenanceVersions", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> availableMaintenanceVersions;

    /**
     * @return The list of all maintenance versions applicable on the instance.
     * 
     */
    public Output<List<String>> availableMaintenanceVersions() {
        return this.availableMaintenanceVersions;
    }
    /**
     * The backupdrBackup needed to restore the database to a backup run. This field will
     * cause Terraform to trigger the database to restore from the backup run indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via Terraform. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     * 
     */
    @Export(name="backupdrBackup", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> backupdrBackup;

    /**
     * @return The backupdrBackup needed to restore the database to a backup run. This field will
     * cause Terraform to trigger the database to restore from the backup run indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via Terraform. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     * 
     */
    public Output<Optional<String>> backupdrBackup() {
        return Codegen.optional(this.backupdrBackup);
    }
    /**
     * The context needed to create this instance as a clone of another instance. When this field is set during
     * resource creation, this provider will attempt to clone another instance as indicated in the context. The
     * configuration is detailed below.
     * 
     */
    @Export(name="clone", refs={DatabaseInstanceClone.class}, tree="[0]")
    private Output</* @Nullable */ DatabaseInstanceClone> clone;

    /**
     * @return The context needed to create this instance as a clone of another instance. When this field is set during
     * resource creation, this provider will attempt to clone another instance as indicated in the context. The
     * configuration is detailed below.
     * 
     */
    public Output<Optional<DatabaseInstanceClone>> clone_() {
        return Codegen.optional(this.clone);
    }
    /**
     * The connection name of the instance to be used in
     * connection strings. For example, when connecting with [Cloud SQL Proxy](https://cloud.google.com/sql/docs/mysql/connect-admin-proxy).
     * 
     */
    @Export(name="connectionName", refs={String.class}, tree="[0]")
    private Output<String> connectionName;

    /**
     * @return The connection name of the instance to be used in
     * connection strings. For example, when connecting with [Cloud SQL Proxy](https://cloud.google.com/sql/docs/mysql/connect-admin-proxy).
     * 
     */
    public Output<String> connectionName() {
        return this.connectionName;
    }
    /**
     * The MySQL, PostgreSQL or
     * SQL Server version to use. Supported values include `MYSQL_5_6`,
     * `MYSQL_5_7`, `MYSQL_8_0`, `MYSQL_8_4`, `POSTGRES_9_6`,`POSTGRES_10`, `POSTGRES_11`,
     * `POSTGRES_12`, `POSTGRES_13`, `POSTGRES_14`, `POSTGRES_15`, `POSTGRES_16`, `POSTGRES_17`,
     * `SQLSERVER_2017_STANDARD`, `SQLSERVER_2017_ENTERPRISE`, `SQLSERVER_2017_EXPRESS`, `SQLSERVER_2017_WEB`.
     * `SQLSERVER_2019_STANDARD`, `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`,
     * `SQLSERVER_2019_WEB`.
     * [Database Version Policies](https://cloud.google.com/sql/docs/db-versions)
     * includes an up-to-date reference of supported versions.
     * 
     */
    @Export(name="databaseVersion", refs={String.class}, tree="[0]")
    private Output<String> databaseVersion;

    /**
     * @return The MySQL, PostgreSQL or
     * SQL Server version to use. Supported values include `MYSQL_5_6`,
     * `MYSQL_5_7`, `MYSQL_8_0`, `MYSQL_8_4`, `POSTGRES_9_6`,`POSTGRES_10`, `POSTGRES_11`,
     * `POSTGRES_12`, `POSTGRES_13`, `POSTGRES_14`, `POSTGRES_15`, `POSTGRES_16`, `POSTGRES_17`,
     * `SQLSERVER_2017_STANDARD`, `SQLSERVER_2017_ENTERPRISE`, `SQLSERVER_2017_EXPRESS`, `SQLSERVER_2017_WEB`.
     * `SQLSERVER_2019_STANDARD`, `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`,
     * `SQLSERVER_2019_WEB`.
     * [Database Version Policies](https://cloud.google.com/sql/docs/db-versions)
     * includes an up-to-date reference of supported versions.
     * 
     */
    public Output<String> databaseVersion() {
        return this.databaseVersion;
    }
    /**
     * Whether or not to allow the provider to destroy the instance. Unless this field is set to false
     * in state, a `destroy` or `update` command that deletes the instance will fail. Defaults to `true`.
     * 
     * &gt; **NOTE:** This flag only protects instances from deletion within Pulumi. To protect your instances from accidental deletion across all surfaces (API, gcloud, Cloud Console and Pulumi), use the API flag `settings.deletion_protection_enabled`.
     * 
     */
    @Export(name="deletionProtection", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> deletionProtection;

    /**
     * @return Whether or not to allow the provider to destroy the instance. Unless this field is set to false
     * in state, a `destroy` or `update` command that deletes the instance will fail. Defaults to `true`.
     * 
     * &gt; **NOTE:** This flag only protects instances from deletion within Pulumi. To protect your instances from accidental deletion across all surfaces (API, gcloud, Cloud Console and Pulumi), use the API flag `settings.deletion_protection_enabled`.
     * 
     */
    public Output<Optional<Boolean>> deletionProtection() {
        return Codegen.optional(this.deletionProtection);
    }
    /**
     * The DNS name of the instance. See [Connect to an instance using Private Service Connect](https://cloud.google.com/sql/docs/mysql/configure-private-service-connect#view-summary-information-cloud-sql-instances-psc-enabled) for more details.
     * 
     */
    @Export(name="dnsName", refs={String.class}, tree="[0]")
    private Output<String> dnsName;

    /**
     * @return The DNS name of the instance. See [Connect to an instance using Private Service Connect](https://cloud.google.com/sql/docs/mysql/configure-private-service-connect#view-summary-information-cloud-sql-instances-psc-enabled) for more details.
     * 
     */
    public Output<String> dnsName() {
        return this.dnsName;
    }
    /**
     * The list of DNS names used by this instance. Different connection types for an instance may have different DNS names. DNS names can apply to an individual instance or a cluster of instances.
     * 
     */
    @Export(name="dnsNames", refs={List.class,DatabaseInstanceDnsName.class}, tree="[0,1]")
    private Output<List<DatabaseInstanceDnsName>> dnsNames;

    /**
     * @return The list of DNS names used by this instance. Different connection types for an instance may have different DNS names. DNS names can apply to an individual instance or a cluster of instances.
     * 
     */
    public Output<List<DatabaseInstanceDnsName>> dnsNames() {
        return this.dnsNames;
    }
    /**
     * The full path to the encryption key used for the CMEK disk encryption.  Setting
     * up disk encryption currently requires manual steps outside of this provider.
     * The provided key must be in the same region as the SQL instance.  In order
     * to use this feature, a special kind of service account must be created and
     * granted permission on this key.  This step can currently only be done
     * manually, please see [this step](https://cloud.google.com/sql/docs/mysql/configure-cmek#service-account).
     * That service account needs the `Cloud KMS &gt; Cloud KMS CryptoKey Encrypter/Decrypter` role on your
     * key - please see [this step](https://cloud.google.com/sql/docs/mysql/configure-cmek#grantkey).
     * 
     */
    @Export(name="encryptionKeyName", refs={String.class}, tree="[0]")
    private Output<String> encryptionKeyName;

    /**
     * @return The full path to the encryption key used for the CMEK disk encryption.  Setting
     * up disk encryption currently requires manual steps outside of this provider.
     * The provided key must be in the same region as the SQL instance.  In order
     * to use this feature, a special kind of service account must be created and
     * granted permission on this key.  This step can currently only be done
     * manually, please see [this step](https://cloud.google.com/sql/docs/mysql/configure-cmek#service-account).
     * That service account needs the `Cloud KMS &gt; Cloud KMS CryptoKey Encrypter/Decrypter` role on your
     * key - please see [this step](https://cloud.google.com/sql/docs/mysql/configure-cmek#grantkey).
     * 
     */
    public Output<String> encryptionKeyName() {
        return this.encryptionKeyName;
    }
    /**
     * The description of final backup. Only set this field when `final_backup_config.enabled` is true.
     * 
     */
    @Export(name="finalBackupDescription", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> finalBackupDescription;

    /**
     * @return The description of final backup. Only set this field when `final_backup_config.enabled` is true.
     * 
     */
    public Output<Optional<String>> finalBackupDescription() {
        return Codegen.optional(this.finalBackupDescription);
    }
    /**
     * The first IPv4 address of any type assigned.
     * 
     */
    @Export(name="firstIpAddress", refs={String.class}, tree="[0]")
    private Output<String> firstIpAddress;

    /**
     * @return The first IPv4 address of any type assigned.
     * 
     */
    public Output<String> firstIpAddress() {
        return this.firstIpAddress;
    }
    /**
     * The type of the instance. See [API reference for SqlInstanceType](https://cloud.google.com/sql/docs/mysql/admin-api/rest/v1/instances#SqlInstanceType) for supported values.
     * 
     */
    @Export(name="instanceType", refs={String.class}, tree="[0]")
    private Output<String> instanceType;

    /**
     * @return The type of the instance. See [API reference for SqlInstanceType](https://cloud.google.com/sql/docs/mysql/admin-api/rest/v1/instances#SqlInstanceType) for supported values.
     * 
     */
    public Output<String> instanceType() {
        return this.instanceType;
    }
    @Export(name="ipAddresses", refs={List.class,DatabaseInstanceIpAddress.class}, tree="[0,1]")
    private Output<List<DatabaseInstanceIpAddress>> ipAddresses;

    public Output<List<DatabaseInstanceIpAddress>> ipAddresses() {
        return this.ipAddresses;
    }
    /**
     * The current software version on the instance. This attribute can not be set during creation. Refer to `availableMaintenanceVersions` attribute to see what `maintenanceVersion` are available for upgrade. When this attribute gets updated, it will cause an instance restart. Setting a `maintenanceVersion` value that is older than the current one on the instance will be ignored.
     * 
     */
    @Export(name="maintenanceVersion", refs={String.class}, tree="[0]")
    private Output<String> maintenanceVersion;

    /**
     * @return The current software version on the instance. This attribute can not be set during creation. Refer to `availableMaintenanceVersions` attribute to see what `maintenanceVersion` are available for upgrade. When this attribute gets updated, it will cause an instance restart. Setting a `maintenanceVersion` value that is older than the current one on the instance will be ignored.
     * 
     */
    public Output<String> maintenanceVersion() {
        return this.maintenanceVersion;
    }
    /**
     * The name of the existing instance that will
     * act as the master in the replication setup. Note, this requires the master to
     * have `binaryLogEnabled` set, as well as existing backups.
     * 
     */
    @Export(name="masterInstanceName", refs={String.class}, tree="[0]")
    private Output<String> masterInstanceName;

    /**
     * @return The name of the existing instance that will
     * act as the master in the replication setup. Note, this requires the master to
     * have `binaryLogEnabled` set, as well as existing backups.
     * 
     */
    public Output<String> masterInstanceName() {
        return this.masterInstanceName;
    }
    /**
     * The name of the instance. If the name is left
     * blank, the provider will randomly generate one when the instance is first
     * created. This is done because after a name is used, it cannot be reused for
     * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the instance. If the name is left
     * blank, the provider will randomly generate one when the instance is first
     * created. This is done because after a name is used, it cannot be reused for
     * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * For a read pool instance, the number of nodes in the read pool. For read pools with auto scaling enabled, this field is read only.
     * 
     */
    @Export(name="nodeCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> nodeCount;

    /**
     * @return For a read pool instance, the number of nodes in the read pool. For read pools with auto scaling enabled, this field is read only.
     * 
     */
    public Output<Integer> nodeCount() {
        return this.nodeCount;
    }
    /**
     * The pointInTimeRestoreContext needed for performing a point-in-time recovery of an instance managed by Google Cloud Backup and Disaster Recovery. This field will
     * cause Terraform to trigger the database to restore to a point in time indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via Terraform. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     * 
     */
    @Export(name="pointInTimeRestoreContext", refs={DatabaseInstancePointInTimeRestoreContext.class}, tree="[0]")
    private Output</* @Nullable */ DatabaseInstancePointInTimeRestoreContext> pointInTimeRestoreContext;

    /**
     * @return The pointInTimeRestoreContext needed for performing a point-in-time recovery of an instance managed by Google Cloud Backup and Disaster Recovery. This field will
     * cause Terraform to trigger the database to restore to a point in time indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via Terraform. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     * 
     */
    public Output<Optional<DatabaseInstancePointInTimeRestoreContext>> pointInTimeRestoreContext() {
        return Codegen.optional(this.pointInTimeRestoreContext);
    }
    /**
     * The first private (`PRIVATE`) IPv4 address assigned.
     * 
     */
    @Export(name="privateIpAddress", refs={String.class}, tree="[0]")
    private Output<String> privateIpAddress;

    /**
     * @return The first private (`PRIVATE`) IPv4 address assigned.
     * 
     */
    public Output<String> privateIpAddress() {
        return this.privateIpAddress;
    }
    /**
     * The ID of the project in which the resource belongs. If it
     * is not provided, the provider project is used.
     * 
     */
    @Export(name="project", refs={String.class}, tree="[0]")
    private Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs. If it
     * is not provided, the provider project is used.
     * 
     */
    public Output<String> project() {
        return this.project;
    }
    /**
     * the URI that points to the service attachment of the instance.
     * 
     */
    @Export(name="pscServiceAttachmentLink", refs={String.class}, tree="[0]")
    private Output<String> pscServiceAttachmentLink;

    /**
     * @return the URI that points to the service attachment of the instance.
     * 
     */
    public Output<String> pscServiceAttachmentLink() {
        return this.pscServiceAttachmentLink;
    }
    /**
     * The first public (`PRIMARY`) IPv4 address assigned.
     * 
     */
    @Export(name="publicIpAddress", refs={String.class}, tree="[0]")
    private Output<String> publicIpAddress;

    /**
     * @return The first public (`PRIMARY`) IPv4 address assigned.
     * 
     */
    public Output<String> publicIpAddress() {
        return this.publicIpAddress;
    }
    /**
     * The region the instance will sit in. If a region is not provided in the resource definition,
     * the provider region will be used instead.
     * 
     * ***
     * 
     */
    @Export(name="region", refs={String.class}, tree="[0]")
    private Output<String> region;

    /**
     * @return The region the instance will sit in. If a region is not provided in the resource definition,
     * the provider region will be used instead.
     * 
     * ***
     * 
     */
    public Output<String> region() {
        return this.region;
    }
    /**
     * The configuration for replication. The
     * configuration is detailed below.
     * 
     */
    @Export(name="replicaConfiguration", refs={DatabaseInstanceReplicaConfiguration.class}, tree="[0]")
    private Output<DatabaseInstanceReplicaConfiguration> replicaConfiguration;

    /**
     * @return The configuration for replication. The
     * configuration is detailed below.
     * 
     */
    public Output<DatabaseInstanceReplicaConfiguration> replicaConfiguration() {
        return this.replicaConfiguration;
    }
    /**
     * List of replica names. Can be updated.
     * 
     */
    @Export(name="replicaNames", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> replicaNames;

    /**
     * @return List of replica names. Can be updated.
     * 
     */
    public Output<List<String>> replicaNames() {
        return this.replicaNames;
    }
    /**
     * A primary instance and disaster recovery replica pair. Applicable to MySQL and PostgreSQL. This field can be set if the primary has psaWriteEndpoint set or both the primary and replica are created.
     * 
     */
    @Export(name="replicationCluster", refs={DatabaseInstanceReplicationCluster.class}, tree="[0]")
    private Output<DatabaseInstanceReplicationCluster> replicationCluster;

    /**
     * @return A primary instance and disaster recovery replica pair. Applicable to MySQL and PostgreSQL. This field can be set if the primary has psaWriteEndpoint set or both the primary and replica are created.
     * 
     */
    public Output<DatabaseInstanceReplicationCluster> replicationCluster() {
        return this.replicationCluster;
    }
    /**
     * The context needed to restore the database to a backup run. This field will
     * cause the provider to trigger the database to restore from the backup run indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via this provider. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     * 
     */
    @Export(name="restoreBackupContext", refs={DatabaseInstanceRestoreBackupContext.class}, tree="[0]")
    private Output</* @Nullable */ DatabaseInstanceRestoreBackupContext> restoreBackupContext;

    /**
     * @return The context needed to restore the database to a backup run. This field will
     * cause the provider to trigger the database to restore from the backup run indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via this provider. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     * 
     */
    public Output<Optional<DatabaseInstanceRestoreBackupContext>> restoreBackupContext() {
        return Codegen.optional(this.restoreBackupContext);
    }
    /**
     * Initial root password. Can be updated. Required for MS SQL Server.
     * 
     */
    @Export(name="rootPassword", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> rootPassword;

    /**
     * @return Initial root password. Can be updated. Required for MS SQL Server.
     * 
     */
    public Output<Optional<String>> rootPassword() {
        return Codegen.optional(this.rootPassword);
    }
    /**
     * **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
     * Initial root password. Can be updated. Required for MS SQL Server. **Note**: This property is write-only and will not be read from the API.
     * 
     * &gt; **Note:** One of `rootPassword` or `rootPasswordWo` can only be set.
     * 
     */
    @Export(name="rootPasswordWo", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> rootPasswordWo;

    /**
     * @return **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
     * Initial root password. Can be updated. Required for MS SQL Server. **Note**: This property is write-only and will not be read from the API.
     * 
     * &gt; **Note:** One of `rootPassword` or `rootPasswordWo` can only be set.
     * 
     */
    public Output<Optional<String>> rootPasswordWo() {
        return Codegen.optional(this.rootPasswordWo);
    }
    /**
     * Triggers update of `rootPasswordWo` write-only. Increment this value when an update to `rootPasswordWo` is needed. For more info see [updating write-only arguments](https://www.terraform.io/docs/providers/google/guides/using_write_only_arguments.html#updating-write-only-arguments)
     * 
     */
    @Export(name="rootPasswordWoVersion", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> rootPasswordWoVersion;

    /**
     * @return Triggers update of `rootPasswordWo` write-only. Increment this value when an update to `rootPasswordWo` is needed. For more info see [updating write-only arguments](https://www.terraform.io/docs/providers/google/guides/using_write_only_arguments.html#updating-write-only-arguments)
     * 
     */
    public Output<Optional<String>> rootPasswordWoVersion() {
        return Codegen.optional(this.rootPasswordWoVersion);
    }
    /**
     * The URI of the created resource.
     * 
     */
    @Export(name="selfLink", refs={String.class}, tree="[0]")
    private Output<String> selfLink;

    /**
     * @return The URI of the created resource.
     * 
     */
    public Output<String> selfLink() {
        return this.selfLink;
    }
    @Export(name="serverCaCerts", refs={List.class,DatabaseInstanceServerCaCert.class}, tree="[0,1]")
    private Output<List<DatabaseInstanceServerCaCert>> serverCaCerts;

    public Output<List<DatabaseInstanceServerCaCert>> serverCaCerts() {
        return this.serverCaCerts;
    }
    /**
     * The service account email address assigned to the
     * instance.
     * 
     */
    @Export(name="serviceAccountEmailAddress", refs={String.class}, tree="[0]")
    private Output<String> serviceAccountEmailAddress;

    /**
     * @return The service account email address assigned to the
     * instance.
     * 
     */
    public Output<String> serviceAccountEmailAddress() {
        return this.serviceAccountEmailAddress;
    }
    /**
     * The settings to use for the database. The
     * configuration is detailed below. Required if `clone` is not set.
     * 
     */
    @Export(name="settings", refs={DatabaseInstanceSettings.class}, tree="[0]")
    private Output<DatabaseInstanceSettings> settings;

    /**
     * @return The settings to use for the database. The
     * configuration is detailed below. Required if `clone` is not set.
     * 
     */
    public Output<DatabaseInstanceSettings> settings() {
        return this.settings;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public DatabaseInstance(java.lang.String name) {
        this(name, DatabaseInstanceArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public DatabaseInstance(java.lang.String name, DatabaseInstanceArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public DatabaseInstance(java.lang.String name, DatabaseInstanceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:sql/databaseInstance:DatabaseInstance", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private DatabaseInstance(java.lang.String name, Output<java.lang.String> id, @Nullable DatabaseInstanceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:sql/databaseInstance:DatabaseInstance", name, state, makeResourceOptions(options, id), false);
    }

    private static DatabaseInstanceArgs makeArgs(DatabaseInstanceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? DatabaseInstanceArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "replicaConfiguration",
                "rootPassword",
                "rootPasswordWo",
                "serverCaCerts"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static DatabaseInstance get(java.lang.String name, Output<java.lang.String> id, @Nullable DatabaseInstanceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new DatabaseInstance(name, id, state, options);
    }
}
