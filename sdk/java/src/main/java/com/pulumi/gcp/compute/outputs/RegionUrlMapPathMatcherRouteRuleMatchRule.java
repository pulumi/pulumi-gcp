// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.gcp.compute.outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch;
import com.pulumi.gcp.compute.outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter;
import com.pulumi.gcp.compute.outputs.RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class RegionUrlMapPathMatcherRouteRuleMatchRule {
    /**
     * @return For satisfying the matchRule condition, the path of the request must exactly
     * match the value specified in fullPathMatch after removing any query parameters
     * and anchor that may be part of the original URL. FullPathMatch must be between 1
     * and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
     * be specified.
     * 
     */
    private @Nullable String fullPathMatch;
    /**
     * @return Specifies a list of header match criteria, all of which must match corresponding
     * headers in the request.
     * Structure is documented below.
     * 
     */
    private @Nullable List<RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch> headerMatches;
    /**
     * @return Specifies that prefixMatch and fullPathMatch matches are case sensitive.
     * Defaults to false.
     * 
     */
    private @Nullable Boolean ignoreCase;
    /**
     * @return Opaque filter criteria used by Loadbalancer to restrict routing configuration to
     * a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
     * clients present node metadata. If a match takes place, the relevant routing
     * configuration is made available to those proxies. For each metadataFilter in
     * this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
     * filterLabels must match the corresponding label provided in the metadata. If its
     * filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
     * with corresponding labels in the provided metadata. metadataFilters specified
     * here can be overrides those specified in ForwardingRule that refers to this
     * UrlMap. metadataFilters only applies to Loadbalancers that have their
     * loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * Structure is documented below.
     * 
     */
    private @Nullable List<RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter> metadataFilters;
    /**
     * @return For satisfying the matchRule condition, the path of the request
     * must match the wildcard pattern specified in pathTemplateMatch
     * after removing any query parameters and anchor that may be part
     * of the original URL.
     * pathTemplateMatch must be between 1 and 255 characters
     * (inclusive).  The pattern specified by pathTemplateMatch may
     * have at most 5 wildcard operators and at most 5 variable
     * captures in total.
     * 
     */
    private @Nullable String pathTemplateMatch;
    /**
     * @return For satisfying the matchRule condition, the request&#39;s path must begin with the
     * specified prefixMatch. prefixMatch must begin with a /. The value must be
     * between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
     * regexMatch must be specified.
     * 
     */
    private @Nullable String prefixMatch;
    /**
     * @return Specifies a list of query parameter match criteria, all of which must match
     * corresponding query parameters in the request.
     * Structure is documented below.
     * 
     */
    private @Nullable List<RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch> queryParameterMatches;
    /**
     * @return For satisfying the matchRule condition, the path of the request must satisfy the
     * regular expression specified in regexMatch after removing any query parameters
     * and anchor supplied with the original URL. For regular expression grammar please
     * see en.cppreference.com/w/cpp/regex/ecmascript  Only one of prefixMatch,
     * fullPathMatch or regexMatch must be specified.
     * 
     */
    private @Nullable String regexMatch;

    private RegionUrlMapPathMatcherRouteRuleMatchRule() {}
    /**
     * @return For satisfying the matchRule condition, the path of the request must exactly
     * match the value specified in fullPathMatch after removing any query parameters
     * and anchor that may be part of the original URL. FullPathMatch must be between 1
     * and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
     * be specified.
     * 
     */
    public Optional<String> fullPathMatch() {
        return Optional.ofNullable(this.fullPathMatch);
    }
    /**
     * @return Specifies a list of header match criteria, all of which must match corresponding
     * headers in the request.
     * Structure is documented below.
     * 
     */
    public List<RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch> headerMatches() {
        return this.headerMatches == null ? List.of() : this.headerMatches;
    }
    /**
     * @return Specifies that prefixMatch and fullPathMatch matches are case sensitive.
     * Defaults to false.
     * 
     */
    public Optional<Boolean> ignoreCase() {
        return Optional.ofNullable(this.ignoreCase);
    }
    /**
     * @return Opaque filter criteria used by Loadbalancer to restrict routing configuration to
     * a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
     * clients present node metadata. If a match takes place, the relevant routing
     * configuration is made available to those proxies. For each metadataFilter in
     * this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
     * filterLabels must match the corresponding label provided in the metadata. If its
     * filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
     * with corresponding labels in the provided metadata. metadataFilters specified
     * here can be overrides those specified in ForwardingRule that refers to this
     * UrlMap. metadataFilters only applies to Loadbalancers that have their
     * loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * Structure is documented below.
     * 
     */
    public List<RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter> metadataFilters() {
        return this.metadataFilters == null ? List.of() : this.metadataFilters;
    }
    /**
     * @return For satisfying the matchRule condition, the path of the request
     * must match the wildcard pattern specified in pathTemplateMatch
     * after removing any query parameters and anchor that may be part
     * of the original URL.
     * pathTemplateMatch must be between 1 and 255 characters
     * (inclusive).  The pattern specified by pathTemplateMatch may
     * have at most 5 wildcard operators and at most 5 variable
     * captures in total.
     * 
     */
    public Optional<String> pathTemplateMatch() {
        return Optional.ofNullable(this.pathTemplateMatch);
    }
    /**
     * @return For satisfying the matchRule condition, the request&#39;s path must begin with the
     * specified prefixMatch. prefixMatch must begin with a /. The value must be
     * between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
     * regexMatch must be specified.
     * 
     */
    public Optional<String> prefixMatch() {
        return Optional.ofNullable(this.prefixMatch);
    }
    /**
     * @return Specifies a list of query parameter match criteria, all of which must match
     * corresponding query parameters in the request.
     * Structure is documented below.
     * 
     */
    public List<RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch> queryParameterMatches() {
        return this.queryParameterMatches == null ? List.of() : this.queryParameterMatches;
    }
    /**
     * @return For satisfying the matchRule condition, the path of the request must satisfy the
     * regular expression specified in regexMatch after removing any query parameters
     * and anchor supplied with the original URL. For regular expression grammar please
     * see en.cppreference.com/w/cpp/regex/ecmascript  Only one of prefixMatch,
     * fullPathMatch or regexMatch must be specified.
     * 
     */
    public Optional<String> regexMatch() {
        return Optional.ofNullable(this.regexMatch);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(RegionUrlMapPathMatcherRouteRuleMatchRule defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable String fullPathMatch;
        private @Nullable List<RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch> headerMatches;
        private @Nullable Boolean ignoreCase;
        private @Nullable List<RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter> metadataFilters;
        private @Nullable String pathTemplateMatch;
        private @Nullable String prefixMatch;
        private @Nullable List<RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch> queryParameterMatches;
        private @Nullable String regexMatch;
        public Builder() {}
        public Builder(RegionUrlMapPathMatcherRouteRuleMatchRule defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.fullPathMatch = defaults.fullPathMatch;
    	      this.headerMatches = defaults.headerMatches;
    	      this.ignoreCase = defaults.ignoreCase;
    	      this.metadataFilters = defaults.metadataFilters;
    	      this.pathTemplateMatch = defaults.pathTemplateMatch;
    	      this.prefixMatch = defaults.prefixMatch;
    	      this.queryParameterMatches = defaults.queryParameterMatches;
    	      this.regexMatch = defaults.regexMatch;
        }

        @CustomType.Setter
        public Builder fullPathMatch(@Nullable String fullPathMatch) {

            this.fullPathMatch = fullPathMatch;
            return this;
        }
        @CustomType.Setter
        public Builder headerMatches(@Nullable List<RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch> headerMatches) {

            this.headerMatches = headerMatches;
            return this;
        }
        public Builder headerMatches(RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch... headerMatches) {
            return headerMatches(List.of(headerMatches));
        }
        @CustomType.Setter
        public Builder ignoreCase(@Nullable Boolean ignoreCase) {

            this.ignoreCase = ignoreCase;
            return this;
        }
        @CustomType.Setter
        public Builder metadataFilters(@Nullable List<RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter> metadataFilters) {

            this.metadataFilters = metadataFilters;
            return this;
        }
        public Builder metadataFilters(RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter... metadataFilters) {
            return metadataFilters(List.of(metadataFilters));
        }
        @CustomType.Setter
        public Builder pathTemplateMatch(@Nullable String pathTemplateMatch) {

            this.pathTemplateMatch = pathTemplateMatch;
            return this;
        }
        @CustomType.Setter
        public Builder prefixMatch(@Nullable String prefixMatch) {

            this.prefixMatch = prefixMatch;
            return this;
        }
        @CustomType.Setter
        public Builder queryParameterMatches(@Nullable List<RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch> queryParameterMatches) {

            this.queryParameterMatches = queryParameterMatches;
            return this;
        }
        public Builder queryParameterMatches(RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch... queryParameterMatches) {
            return queryParameterMatches(List.of(queryParameterMatches));
        }
        @CustomType.Setter
        public Builder regexMatch(@Nullable String regexMatch) {

            this.regexMatch = regexMatch;
            return this;
        }
        public RegionUrlMapPathMatcherRouteRuleMatchRule build() {
            final var _resultValue = new RegionUrlMapPathMatcherRouteRuleMatchRule();
            _resultValue.fullPathMatch = fullPathMatch;
            _resultValue.headerMatches = headerMatches;
            _resultValue.ignoreCase = ignoreCase;
            _resultValue.metadataFilters = metadataFilters;
            _resultValue.pathTemplateMatch = pathTemplateMatch;
            _resultValue.prefixMatch = prefixMatch;
            _resultValue.queryParameterMatches = queryParameterMatches;
            _resultValue.regexMatch = regexMatch;
            return _resultValue;
        }
    }
}
