// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.firestore;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.firestore.inputs.IndexFieldArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class IndexArgs extends com.pulumi.resources.ResourceArgs {

    public static final IndexArgs Empty = new IndexArgs();

    /**
     * The API scope at which a query is run.
     * Default value is `ANY_API`.
     * Possible values are: `ANY_API`, `DATASTORE_MODE_API`, `MONGODB_COMPATIBLE_API`.
     * 
     */
    @Import(name="apiScope")
    private @Nullable Output<String> apiScope;

    /**
     * @return The API scope at which a query is run.
     * Default value is `ANY_API`.
     * Possible values are: `ANY_API`, `DATASTORE_MODE_API`, `MONGODB_COMPATIBLE_API`.
     * 
     */
    public Optional<Output<String>> apiScope() {
        return Optional.ofNullable(this.apiScope);
    }

    /**
     * The collection being indexed.
     * 
     */
    @Import(name="collection", required=true)
    private Output<String> collection;

    /**
     * @return The collection being indexed.
     * 
     */
    public Output<String> collection() {
        return this.collection;
    }

    /**
     * The Firestore database id. Defaults to `&#34;(default)&#34;`.
     * 
     */
    @Import(name="database")
    private @Nullable Output<String> database;

    /**
     * @return The Firestore database id. Defaults to `&#34;(default)&#34;`.
     * 
     */
    public Optional<Output<String>> database() {
        return Optional.ofNullable(this.database);
    }

    /**
     * The density configuration for this index.
     * Possible values are: `SPARSE_ALL`, `SPARSE_ANY`, `DENSE`.
     * 
     */
    @Import(name="density")
    private @Nullable Output<String> density;

    /**
     * @return The density configuration for this index.
     * Possible values are: `SPARSE_ALL`, `SPARSE_ANY`, `DENSE`.
     * 
     */
    public Optional<Output<String>> density() {
        return Optional.ofNullable(this.density);
    }

    /**
     * The fields supported by this index. The last non-stored field entry is
     * always for the field path `__name__`. If, on creation, `__name__` was not
     * specified as the last field, it will be added automatically with the same
     * direction as that of the last field defined. If the final field in a
     * composite index is not directional, the `__name__` will be ordered
     * `&#34;ASCENDING&#34;` (unless explicitly specified otherwise).
     * Structure is documented below.
     * 
     */
    @Import(name="fields", required=true)
    private Output<List<IndexFieldArgs>> fields;

    /**
     * @return The fields supported by this index. The last non-stored field entry is
     * always for the field path `__name__`. If, on creation, `__name__` was not
     * specified as the last field, it will be added automatically with the same
     * direction as that of the last field defined. If the final field in a
     * composite index is not directional, the `__name__` will be ordered
     * `&#34;ASCENDING&#34;` (unless explicitly specified otherwise).
     * Structure is documented below.
     * 
     */
    public Output<List<IndexFieldArgs>> fields() {
        return this.fields;
    }

    /**
     * Optional. Whether the index is multikey. By default, the index is not multikey. For non-multikey indexes, none of the paths in the index definition reach or traverse an array, except via an explicit array index. For multikey indexes, at most one of the paths in the index definition reach or traverse an array, except via an explicit array index. Violations will result in errors. Note this field only applies to indexes with MONGODB_COMPATIBLE_API ApiScope.
     * 
     */
    @Import(name="multikey")
    private @Nullable Output<Boolean> multikey;

    /**
     * @return Optional. Whether the index is multikey. By default, the index is not multikey. For non-multikey indexes, none of the paths in the index definition reach or traverse an array, except via an explicit array index. For multikey indexes, at most one of the paths in the index definition reach or traverse an array, except via an explicit array index. Violations will result in errors. Note this field only applies to indexes with MONGODB_COMPATIBLE_API ApiScope.
     * 
     */
    public Optional<Output<Boolean>> multikey() {
        return Optional.ofNullable(this.multikey);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * The scope at which a query is run.
     * Default value is `COLLECTION`.
     * Possible values are: `COLLECTION`, `COLLECTION_GROUP`, `COLLECTION_RECURSIVE`.
     * 
     */
    @Import(name="queryScope")
    private @Nullable Output<String> queryScope;

    /**
     * @return The scope at which a query is run.
     * Default value is `COLLECTION`.
     * Possible values are: `COLLECTION`, `COLLECTION_GROUP`, `COLLECTION_RECURSIVE`.
     * 
     */
    public Optional<Output<String>> queryScope() {
        return Optional.ofNullable(this.queryScope);
    }

    /**
     * Whether it is an unique index. Unique index ensures all values for the indexed field(s) are unique across documents.
     * 
     */
    @Import(name="unique")
    private @Nullable Output<Boolean> unique;

    /**
     * @return Whether it is an unique index. Unique index ensures all values for the indexed field(s) are unique across documents.
     * 
     */
    public Optional<Output<Boolean>> unique() {
        return Optional.ofNullable(this.unique);
    }

    private IndexArgs() {}

    private IndexArgs(IndexArgs $) {
        this.apiScope = $.apiScope;
        this.collection = $.collection;
        this.database = $.database;
        this.density = $.density;
        this.fields = $.fields;
        this.multikey = $.multikey;
        this.project = $.project;
        this.queryScope = $.queryScope;
        this.unique = $.unique;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(IndexArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private IndexArgs $;

        public Builder() {
            $ = new IndexArgs();
        }

        public Builder(IndexArgs defaults) {
            $ = new IndexArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param apiScope The API scope at which a query is run.
         * Default value is `ANY_API`.
         * Possible values are: `ANY_API`, `DATASTORE_MODE_API`, `MONGODB_COMPATIBLE_API`.
         * 
         * @return builder
         * 
         */
        public Builder apiScope(@Nullable Output<String> apiScope) {
            $.apiScope = apiScope;
            return this;
        }

        /**
         * @param apiScope The API scope at which a query is run.
         * Default value is `ANY_API`.
         * Possible values are: `ANY_API`, `DATASTORE_MODE_API`, `MONGODB_COMPATIBLE_API`.
         * 
         * @return builder
         * 
         */
        public Builder apiScope(String apiScope) {
            return apiScope(Output.of(apiScope));
        }

        /**
         * @param collection The collection being indexed.
         * 
         * @return builder
         * 
         */
        public Builder collection(Output<String> collection) {
            $.collection = collection;
            return this;
        }

        /**
         * @param collection The collection being indexed.
         * 
         * @return builder
         * 
         */
        public Builder collection(String collection) {
            return collection(Output.of(collection));
        }

        /**
         * @param database The Firestore database id. Defaults to `&#34;(default)&#34;`.
         * 
         * @return builder
         * 
         */
        public Builder database(@Nullable Output<String> database) {
            $.database = database;
            return this;
        }

        /**
         * @param database The Firestore database id. Defaults to `&#34;(default)&#34;`.
         * 
         * @return builder
         * 
         */
        public Builder database(String database) {
            return database(Output.of(database));
        }

        /**
         * @param density The density configuration for this index.
         * Possible values are: `SPARSE_ALL`, `SPARSE_ANY`, `DENSE`.
         * 
         * @return builder
         * 
         */
        public Builder density(@Nullable Output<String> density) {
            $.density = density;
            return this;
        }

        /**
         * @param density The density configuration for this index.
         * Possible values are: `SPARSE_ALL`, `SPARSE_ANY`, `DENSE`.
         * 
         * @return builder
         * 
         */
        public Builder density(String density) {
            return density(Output.of(density));
        }

        /**
         * @param fields The fields supported by this index. The last non-stored field entry is
         * always for the field path `__name__`. If, on creation, `__name__` was not
         * specified as the last field, it will be added automatically with the same
         * direction as that of the last field defined. If the final field in a
         * composite index is not directional, the `__name__` will be ordered
         * `&#34;ASCENDING&#34;` (unless explicitly specified otherwise).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder fields(Output<List<IndexFieldArgs>> fields) {
            $.fields = fields;
            return this;
        }

        /**
         * @param fields The fields supported by this index. The last non-stored field entry is
         * always for the field path `__name__`. If, on creation, `__name__` was not
         * specified as the last field, it will be added automatically with the same
         * direction as that of the last field defined. If the final field in a
         * composite index is not directional, the `__name__` will be ordered
         * `&#34;ASCENDING&#34;` (unless explicitly specified otherwise).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder fields(List<IndexFieldArgs> fields) {
            return fields(Output.of(fields));
        }

        /**
         * @param fields The fields supported by this index. The last non-stored field entry is
         * always for the field path `__name__`. If, on creation, `__name__` was not
         * specified as the last field, it will be added automatically with the same
         * direction as that of the last field defined. If the final field in a
         * composite index is not directional, the `__name__` will be ordered
         * `&#34;ASCENDING&#34;` (unless explicitly specified otherwise).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder fields(IndexFieldArgs... fields) {
            return fields(List.of(fields));
        }

        /**
         * @param multikey Optional. Whether the index is multikey. By default, the index is not multikey. For non-multikey indexes, none of the paths in the index definition reach or traverse an array, except via an explicit array index. For multikey indexes, at most one of the paths in the index definition reach or traverse an array, except via an explicit array index. Violations will result in errors. Note this field only applies to indexes with MONGODB_COMPATIBLE_API ApiScope.
         * 
         * @return builder
         * 
         */
        public Builder multikey(@Nullable Output<Boolean> multikey) {
            $.multikey = multikey;
            return this;
        }

        /**
         * @param multikey Optional. Whether the index is multikey. By default, the index is not multikey. For non-multikey indexes, none of the paths in the index definition reach or traverse an array, except via an explicit array index. For multikey indexes, at most one of the paths in the index definition reach or traverse an array, except via an explicit array index. Violations will result in errors. Note this field only applies to indexes with MONGODB_COMPATIBLE_API ApiScope.
         * 
         * @return builder
         * 
         */
        public Builder multikey(Boolean multikey) {
            return multikey(Output.of(multikey));
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param queryScope The scope at which a query is run.
         * Default value is `COLLECTION`.
         * Possible values are: `COLLECTION`, `COLLECTION_GROUP`, `COLLECTION_RECURSIVE`.
         * 
         * @return builder
         * 
         */
        public Builder queryScope(@Nullable Output<String> queryScope) {
            $.queryScope = queryScope;
            return this;
        }

        /**
         * @param queryScope The scope at which a query is run.
         * Default value is `COLLECTION`.
         * Possible values are: `COLLECTION`, `COLLECTION_GROUP`, `COLLECTION_RECURSIVE`.
         * 
         * @return builder
         * 
         */
        public Builder queryScope(String queryScope) {
            return queryScope(Output.of(queryScope));
        }

        /**
         * @param unique Whether it is an unique index. Unique index ensures all values for the indexed field(s) are unique across documents.
         * 
         * @return builder
         * 
         */
        public Builder unique(@Nullable Output<Boolean> unique) {
            $.unique = unique;
            return this;
        }

        /**
         * @param unique Whether it is an unique index. Unique index ensures all values for the indexed field(s) are unique across documents.
         * 
         * @return builder
         * 
         */
        public Builder unique(Boolean unique) {
            return unique(Output.of(unique));
        }

        public IndexArgs build() {
            if ($.collection == null) {
                throw new MissingRequiredPropertyException("IndexArgs", "collection");
            }
            if ($.fields == null) {
                throw new MissingRequiredPropertyException("IndexArgs", "fields");
            }
            return $;
        }
    }

}
