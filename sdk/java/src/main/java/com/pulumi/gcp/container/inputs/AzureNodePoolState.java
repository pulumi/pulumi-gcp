// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.container.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.container.inputs.AzureNodePoolAutoscalingArgs;
import com.pulumi.gcp.container.inputs.AzureNodePoolConfigArgs;
import com.pulumi.gcp.container.inputs.AzureNodePoolManagementArgs;
import com.pulumi.gcp.container.inputs.AzureNodePoolMaxPodsConstraintArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class AzureNodePoolState extends com.pulumi.resources.ResourceArgs {

    public static final AzureNodePoolState Empty = new AzureNodePoolState();

    /**
     * Optional. Annotations on the node pool. This field has the same restrictions as Kubernetes annotations. The total size of all keys and values combined is limited to 256k. Keys can have 2 segments: prefix (optional) and name (required), separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between.
     * 
     * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
     * Please refer to the field `effective_annotations` for all of the annotations present on the resource.
     * 
     */
    @Import(name="annotations")
    private @Nullable Output<Map<String,String>> annotations;

    /**
     * @return Optional. Annotations on the node pool. This field has the same restrictions as Kubernetes annotations. The total size of all keys and values combined is limited to 256k. Keys can have 2 segments: prefix (optional) and name (required), separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between.
     * 
     * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
     * Please refer to the field `effective_annotations` for all of the annotations present on the resource.
     * 
     */
    public Optional<Output<Map<String,String>>> annotations() {
        return Optional.ofNullable(this.annotations);
    }

    /**
     * Autoscaler configuration for this node pool.
     * 
     */
    @Import(name="autoscaling")
    private @Nullable Output<AzureNodePoolAutoscalingArgs> autoscaling;

    /**
     * @return Autoscaler configuration for this node pool.
     * 
     */
    public Optional<Output<AzureNodePoolAutoscalingArgs>> autoscaling() {
        return Optional.ofNullable(this.autoscaling);
    }

    /**
     * Optional. The Azure availability zone of the nodes in this nodepool. When unspecified, it defaults to `1`.
     * 
     */
    @Import(name="azureAvailabilityZone")
    private @Nullable Output<String> azureAvailabilityZone;

    /**
     * @return Optional. The Azure availability zone of the nodes in this nodepool. When unspecified, it defaults to `1`.
     * 
     */
    public Optional<Output<String>> azureAvailabilityZone() {
        return Optional.ofNullable(this.azureAvailabilityZone);
    }

    /**
     * The azureCluster for the resource
     * 
     */
    @Import(name="cluster")
    private @Nullable Output<String> cluster;

    /**
     * @return The azureCluster for the resource
     * 
     */
    public Optional<Output<String>> cluster() {
        return Optional.ofNullable(this.cluster);
    }

    /**
     * The node configuration of the node pool.
     * 
     */
    @Import(name="config")
    private @Nullable Output<AzureNodePoolConfigArgs> config;

    /**
     * @return The node configuration of the node pool.
     * 
     */
    public Optional<Output<AzureNodePoolConfigArgs>> config() {
        return Optional.ofNullable(this.config);
    }

    /**
     * Output only. The time at which this node pool was created.
     * 
     */
    @Import(name="createTime")
    private @Nullable Output<String> createTime;

    /**
     * @return Output only. The time at which this node pool was created.
     * 
     */
    public Optional<Output<String>> createTime() {
        return Optional.ofNullable(this.createTime);
    }

    @Import(name="effectiveAnnotations")
    private @Nullable Output<Map<String,String>> effectiveAnnotations;

    public Optional<Output<Map<String,String>>> effectiveAnnotations() {
        return Optional.ofNullable(this.effectiveAnnotations);
    }

    /**
     * Allows clients to perform consistent read-modify-writes through optimistic concurrency control. May be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.
     * 
     */
    @Import(name="etag")
    private @Nullable Output<String> etag;

    /**
     * @return Allows clients to perform consistent read-modify-writes through optimistic concurrency control. May be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.
     * 
     */
    public Optional<Output<String>> etag() {
        return Optional.ofNullable(this.etag);
    }

    /**
     * The location for the resource
     * 
     */
    @Import(name="location")
    private @Nullable Output<String> location;

    /**
     * @return The location for the resource
     * 
     */
    public Optional<Output<String>> location() {
        return Optional.ofNullable(this.location);
    }

    /**
     * The Management configuration for this node pool.
     * 
     */
    @Import(name="management")
    private @Nullable Output<AzureNodePoolManagementArgs> management;

    /**
     * @return The Management configuration for this node pool.
     * 
     */
    public Optional<Output<AzureNodePoolManagementArgs>> management() {
        return Optional.ofNullable(this.management);
    }

    /**
     * The constraint on the maximum number of pods that can be run simultaneously on a node in the node pool.
     * 
     */
    @Import(name="maxPodsConstraint")
    private @Nullable Output<AzureNodePoolMaxPodsConstraintArgs> maxPodsConstraint;

    /**
     * @return The constraint on the maximum number of pods that can be run simultaneously on a node in the node pool.
     * 
     */
    public Optional<Output<AzureNodePoolMaxPodsConstraintArgs>> maxPodsConstraint() {
        return Optional.ofNullable(this.maxPodsConstraint);
    }

    /**
     * The name of this resource.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of this resource.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The project for the resource
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The project for the resource
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * Output only. If set, there are currently pending changes to the node pool.
     * 
     */
    @Import(name="reconciling")
    private @Nullable Output<Boolean> reconciling;

    /**
     * @return Output only. If set, there are currently pending changes to the node pool.
     * 
     */
    public Optional<Output<Boolean>> reconciling() {
        return Optional.ofNullable(this.reconciling);
    }

    /**
     * Output only. The current state of the node pool. Possible values: STATE_UNSPECIFIED, PROVISIONING, RUNNING, RECONCILING, STOPPING, ERROR, DEGRADED
     * 
     */
    @Import(name="state")
    private @Nullable Output<String> state;

    /**
     * @return Output only. The current state of the node pool. Possible values: STATE_UNSPECIFIED, PROVISIONING, RUNNING, RECONCILING, STOPPING, ERROR, DEGRADED
     * 
     */
    public Optional<Output<String>> state() {
        return Optional.ofNullable(this.state);
    }

    /**
     * The ARM ID of the subnet where the node pool VMs run. Make sure it&#39;s a subnet under the virtual network in the cluster configuration.
     * 
     */
    @Import(name="subnetId")
    private @Nullable Output<String> subnetId;

    /**
     * @return The ARM ID of the subnet where the node pool VMs run. Make sure it&#39;s a subnet under the virtual network in the cluster configuration.
     * 
     */
    public Optional<Output<String>> subnetId() {
        return Optional.ofNullable(this.subnetId);
    }

    /**
     * Output only. A globally unique identifier for the node pool.
     * 
     */
    @Import(name="uid")
    private @Nullable Output<String> uid;

    /**
     * @return Output only. A globally unique identifier for the node pool.
     * 
     */
    public Optional<Output<String>> uid() {
        return Optional.ofNullable(this.uid);
    }

    /**
     * Output only. The time at which this node pool was last updated.
     * 
     */
    @Import(name="updateTime")
    private @Nullable Output<String> updateTime;

    /**
     * @return Output only. The time at which this node pool was last updated.
     * 
     */
    public Optional<Output<String>> updateTime() {
        return Optional.ofNullable(this.updateTime);
    }

    /**
     * The Kubernetes version (e.g. `1.19.10-gke.1000`) running on this node pool.
     * 
     */
    @Import(name="version")
    private @Nullable Output<String> version;

    /**
     * @return The Kubernetes version (e.g. `1.19.10-gke.1000`) running on this node pool.
     * 
     */
    public Optional<Output<String>> version() {
        return Optional.ofNullable(this.version);
    }

    private AzureNodePoolState() {}

    private AzureNodePoolState(AzureNodePoolState $) {
        this.annotations = $.annotations;
        this.autoscaling = $.autoscaling;
        this.azureAvailabilityZone = $.azureAvailabilityZone;
        this.cluster = $.cluster;
        this.config = $.config;
        this.createTime = $.createTime;
        this.effectiveAnnotations = $.effectiveAnnotations;
        this.etag = $.etag;
        this.location = $.location;
        this.management = $.management;
        this.maxPodsConstraint = $.maxPodsConstraint;
        this.name = $.name;
        this.project = $.project;
        this.reconciling = $.reconciling;
        this.state = $.state;
        this.subnetId = $.subnetId;
        this.uid = $.uid;
        this.updateTime = $.updateTime;
        this.version = $.version;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(AzureNodePoolState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private AzureNodePoolState $;

        public Builder() {
            $ = new AzureNodePoolState();
        }

        public Builder(AzureNodePoolState defaults) {
            $ = new AzureNodePoolState(Objects.requireNonNull(defaults));
        }

        /**
         * @param annotations Optional. Annotations on the node pool. This field has the same restrictions as Kubernetes annotations. The total size of all keys and values combined is limited to 256k. Keys can have 2 segments: prefix (optional) and name (required), separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between.
         * 
         * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
         * Please refer to the field `effective_annotations` for all of the annotations present on the resource.
         * 
         * @return builder
         * 
         */
        public Builder annotations(@Nullable Output<Map<String,String>> annotations) {
            $.annotations = annotations;
            return this;
        }

        /**
         * @param annotations Optional. Annotations on the node pool. This field has the same restrictions as Kubernetes annotations. The total size of all keys and values combined is limited to 256k. Keys can have 2 segments: prefix (optional) and name (required), separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between.
         * 
         * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
         * Please refer to the field `effective_annotations` for all of the annotations present on the resource.
         * 
         * @return builder
         * 
         */
        public Builder annotations(Map<String,String> annotations) {
            return annotations(Output.of(annotations));
        }

        /**
         * @param autoscaling Autoscaler configuration for this node pool.
         * 
         * @return builder
         * 
         */
        public Builder autoscaling(@Nullable Output<AzureNodePoolAutoscalingArgs> autoscaling) {
            $.autoscaling = autoscaling;
            return this;
        }

        /**
         * @param autoscaling Autoscaler configuration for this node pool.
         * 
         * @return builder
         * 
         */
        public Builder autoscaling(AzureNodePoolAutoscalingArgs autoscaling) {
            return autoscaling(Output.of(autoscaling));
        }

        /**
         * @param azureAvailabilityZone Optional. The Azure availability zone of the nodes in this nodepool. When unspecified, it defaults to `1`.
         * 
         * @return builder
         * 
         */
        public Builder azureAvailabilityZone(@Nullable Output<String> azureAvailabilityZone) {
            $.azureAvailabilityZone = azureAvailabilityZone;
            return this;
        }

        /**
         * @param azureAvailabilityZone Optional. The Azure availability zone of the nodes in this nodepool. When unspecified, it defaults to `1`.
         * 
         * @return builder
         * 
         */
        public Builder azureAvailabilityZone(String azureAvailabilityZone) {
            return azureAvailabilityZone(Output.of(azureAvailabilityZone));
        }

        /**
         * @param cluster The azureCluster for the resource
         * 
         * @return builder
         * 
         */
        public Builder cluster(@Nullable Output<String> cluster) {
            $.cluster = cluster;
            return this;
        }

        /**
         * @param cluster The azureCluster for the resource
         * 
         * @return builder
         * 
         */
        public Builder cluster(String cluster) {
            return cluster(Output.of(cluster));
        }

        /**
         * @param config The node configuration of the node pool.
         * 
         * @return builder
         * 
         */
        public Builder config(@Nullable Output<AzureNodePoolConfigArgs> config) {
            $.config = config;
            return this;
        }

        /**
         * @param config The node configuration of the node pool.
         * 
         * @return builder
         * 
         */
        public Builder config(AzureNodePoolConfigArgs config) {
            return config(Output.of(config));
        }

        /**
         * @param createTime Output only. The time at which this node pool was created.
         * 
         * @return builder
         * 
         */
        public Builder createTime(@Nullable Output<String> createTime) {
            $.createTime = createTime;
            return this;
        }

        /**
         * @param createTime Output only. The time at which this node pool was created.
         * 
         * @return builder
         * 
         */
        public Builder createTime(String createTime) {
            return createTime(Output.of(createTime));
        }

        public Builder effectiveAnnotations(@Nullable Output<Map<String,String>> effectiveAnnotations) {
            $.effectiveAnnotations = effectiveAnnotations;
            return this;
        }

        public Builder effectiveAnnotations(Map<String,String> effectiveAnnotations) {
            return effectiveAnnotations(Output.of(effectiveAnnotations));
        }

        /**
         * @param etag Allows clients to perform consistent read-modify-writes through optimistic concurrency control. May be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.
         * 
         * @return builder
         * 
         */
        public Builder etag(@Nullable Output<String> etag) {
            $.etag = etag;
            return this;
        }

        /**
         * @param etag Allows clients to perform consistent read-modify-writes through optimistic concurrency control. May be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.
         * 
         * @return builder
         * 
         */
        public Builder etag(String etag) {
            return etag(Output.of(etag));
        }

        /**
         * @param location The location for the resource
         * 
         * @return builder
         * 
         */
        public Builder location(@Nullable Output<String> location) {
            $.location = location;
            return this;
        }

        /**
         * @param location The location for the resource
         * 
         * @return builder
         * 
         */
        public Builder location(String location) {
            return location(Output.of(location));
        }

        /**
         * @param management The Management configuration for this node pool.
         * 
         * @return builder
         * 
         */
        public Builder management(@Nullable Output<AzureNodePoolManagementArgs> management) {
            $.management = management;
            return this;
        }

        /**
         * @param management The Management configuration for this node pool.
         * 
         * @return builder
         * 
         */
        public Builder management(AzureNodePoolManagementArgs management) {
            return management(Output.of(management));
        }

        /**
         * @param maxPodsConstraint The constraint on the maximum number of pods that can be run simultaneously on a node in the node pool.
         * 
         * @return builder
         * 
         */
        public Builder maxPodsConstraint(@Nullable Output<AzureNodePoolMaxPodsConstraintArgs> maxPodsConstraint) {
            $.maxPodsConstraint = maxPodsConstraint;
            return this;
        }

        /**
         * @param maxPodsConstraint The constraint on the maximum number of pods that can be run simultaneously on a node in the node pool.
         * 
         * @return builder
         * 
         */
        public Builder maxPodsConstraint(AzureNodePoolMaxPodsConstraintArgs maxPodsConstraint) {
            return maxPodsConstraint(Output.of(maxPodsConstraint));
        }

        /**
         * @param name The name of this resource.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of this resource.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param project The project for the resource
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The project for the resource
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param reconciling Output only. If set, there are currently pending changes to the node pool.
         * 
         * @return builder
         * 
         */
        public Builder reconciling(@Nullable Output<Boolean> reconciling) {
            $.reconciling = reconciling;
            return this;
        }

        /**
         * @param reconciling Output only. If set, there are currently pending changes to the node pool.
         * 
         * @return builder
         * 
         */
        public Builder reconciling(Boolean reconciling) {
            return reconciling(Output.of(reconciling));
        }

        /**
         * @param state Output only. The current state of the node pool. Possible values: STATE_UNSPECIFIED, PROVISIONING, RUNNING, RECONCILING, STOPPING, ERROR, DEGRADED
         * 
         * @return builder
         * 
         */
        public Builder state(@Nullable Output<String> state) {
            $.state = state;
            return this;
        }

        /**
         * @param state Output only. The current state of the node pool. Possible values: STATE_UNSPECIFIED, PROVISIONING, RUNNING, RECONCILING, STOPPING, ERROR, DEGRADED
         * 
         * @return builder
         * 
         */
        public Builder state(String state) {
            return state(Output.of(state));
        }

        /**
         * @param subnetId The ARM ID of the subnet where the node pool VMs run. Make sure it&#39;s a subnet under the virtual network in the cluster configuration.
         * 
         * @return builder
         * 
         */
        public Builder subnetId(@Nullable Output<String> subnetId) {
            $.subnetId = subnetId;
            return this;
        }

        /**
         * @param subnetId The ARM ID of the subnet where the node pool VMs run. Make sure it&#39;s a subnet under the virtual network in the cluster configuration.
         * 
         * @return builder
         * 
         */
        public Builder subnetId(String subnetId) {
            return subnetId(Output.of(subnetId));
        }

        /**
         * @param uid Output only. A globally unique identifier for the node pool.
         * 
         * @return builder
         * 
         */
        public Builder uid(@Nullable Output<String> uid) {
            $.uid = uid;
            return this;
        }

        /**
         * @param uid Output only. A globally unique identifier for the node pool.
         * 
         * @return builder
         * 
         */
        public Builder uid(String uid) {
            return uid(Output.of(uid));
        }

        /**
         * @param updateTime Output only. The time at which this node pool was last updated.
         * 
         * @return builder
         * 
         */
        public Builder updateTime(@Nullable Output<String> updateTime) {
            $.updateTime = updateTime;
            return this;
        }

        /**
         * @param updateTime Output only. The time at which this node pool was last updated.
         * 
         * @return builder
         * 
         */
        public Builder updateTime(String updateTime) {
            return updateTime(Output.of(updateTime));
        }

        /**
         * @param version The Kubernetes version (e.g. `1.19.10-gke.1000`) running on this node pool.
         * 
         * @return builder
         * 
         */
        public Builder version(@Nullable Output<String> version) {
            $.version = version;
            return this;
        }

        /**
         * @param version The Kubernetes version (e.g. `1.19.10-gke.1000`) running on this node pool.
         * 
         * @return builder
         * 
         */
        public Builder version(String version) {
            return version(Output.of(version));
        }

        public AzureNodePoolState build() {
            return $;
        }
    }

}
