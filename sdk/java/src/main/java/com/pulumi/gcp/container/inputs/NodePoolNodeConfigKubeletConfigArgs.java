// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.container.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.container.inputs.NodePoolNodeConfigKubeletConfigEvictionMinimumReclaimArgs;
import com.pulumi.gcp.container.inputs.NodePoolNodeConfigKubeletConfigEvictionSoftArgs;
import com.pulumi.gcp.container.inputs.NodePoolNodeConfigKubeletConfigEvictionSoftGracePeriodArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class NodePoolNodeConfigKubeletConfigArgs extends com.pulumi.resources.ResourceArgs {

    public static final NodePoolNodeConfigKubeletConfigArgs Empty = new NodePoolNodeConfigKubeletConfigArgs();

    /**
     * Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods.
     * 
     */
    @Import(name="allowedUnsafeSysctls")
    private @Nullable Output<List<String>> allowedUnsafeSysctls;

    /**
     * @return Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods.
     * 
     */
    public Optional<Output<List<String>>> allowedUnsafeSysctls() {
        return Optional.ofNullable(this.allowedUnsafeSysctls);
    }

    /**
     * Defines the maximum number of container log files that can be present for a container.
     * 
     */
    @Import(name="containerLogMaxFiles")
    private @Nullable Output<Integer> containerLogMaxFiles;

    /**
     * @return Defines the maximum number of container log files that can be present for a container.
     * 
     */
    public Optional<Output<Integer>> containerLogMaxFiles() {
        return Optional.ofNullable(this.containerLogMaxFiles);
    }

    /**
     * Defines the maximum size of the container log file before it is rotated.
     * 
     */
    @Import(name="containerLogMaxSize")
    private @Nullable Output<String> containerLogMaxSize;

    /**
     * @return Defines the maximum size of the container log file before it is rotated.
     * 
     */
    public Optional<Output<String>> containerLogMaxSize() {
        return Optional.ofNullable(this.containerLogMaxSize);
    }

    /**
     * Enable CPU CFS quota enforcement for containers that specify CPU limits.
     * 
     */
    @Import(name="cpuCfsQuota")
    private @Nullable Output<Boolean> cpuCfsQuota;

    /**
     * @return Enable CPU CFS quota enforcement for containers that specify CPU limits.
     * 
     */
    public Optional<Output<Boolean>> cpuCfsQuota() {
        return Optional.ofNullable(this.cpuCfsQuota);
    }

    /**
     * Set the CPU CFS quota period value &#39;cpu.cfs_period_us&#39;.
     * 
     */
    @Import(name="cpuCfsQuotaPeriod")
    private @Nullable Output<String> cpuCfsQuotaPeriod;

    /**
     * @return Set the CPU CFS quota period value &#39;cpu.cfs_period_us&#39;.
     * 
     */
    public Optional<Output<String>> cpuCfsQuotaPeriod() {
        return Optional.ofNullable(this.cpuCfsQuotaPeriod);
    }

    /**
     * Control the CPU management policy on the node.
     * 
     */
    @Import(name="cpuManagerPolicy")
    private @Nullable Output<String> cpuManagerPolicy;

    /**
     * @return Control the CPU management policy on the node.
     * 
     */
    public Optional<Output<String>> cpuManagerPolicy() {
        return Optional.ofNullable(this.cpuManagerPolicy);
    }

    /**
     * Defines the maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.
     * 
     */
    @Import(name="evictionMaxPodGracePeriodSeconds")
    private @Nullable Output<Integer> evictionMaxPodGracePeriodSeconds;

    /**
     * @return Defines the maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.
     * 
     */
    public Optional<Output<Integer>> evictionMaxPodGracePeriodSeconds() {
        return Optional.ofNullable(this.evictionMaxPodGracePeriodSeconds);
    }

    /**
     * Defines a map of signal names to percentage that defines minimum reclaims. It describes the minimum amount of a given resource the kubelet will reclaim when performing a pod eviction.
     * 
     */
    @Import(name="evictionMinimumReclaim")
    private @Nullable Output<NodePoolNodeConfigKubeletConfigEvictionMinimumReclaimArgs> evictionMinimumReclaim;

    /**
     * @return Defines a map of signal names to percentage that defines minimum reclaims. It describes the minimum amount of a given resource the kubelet will reclaim when performing a pod eviction.
     * 
     */
    public Optional<Output<NodePoolNodeConfigKubeletConfigEvictionMinimumReclaimArgs>> evictionMinimumReclaim() {
        return Optional.ofNullable(this.evictionMinimumReclaim);
    }

    /**
     * Defines a map of signal names to quantities or percentage that defines soft eviction thresholds.
     * 
     */
    @Import(name="evictionSoft")
    private @Nullable Output<NodePoolNodeConfigKubeletConfigEvictionSoftArgs> evictionSoft;

    /**
     * @return Defines a map of signal names to quantities or percentage that defines soft eviction thresholds.
     * 
     */
    public Optional<Output<NodePoolNodeConfigKubeletConfigEvictionSoftArgs>> evictionSoft() {
        return Optional.ofNullable(this.evictionSoft);
    }

    /**
     * Defines a map of signal names to durations that defines grace periods for soft eviction thresholds. Each soft eviction threshold must have a corresponding grace period.
     * 
     */
    @Import(name="evictionSoftGracePeriod")
    private @Nullable Output<NodePoolNodeConfigKubeletConfigEvictionSoftGracePeriodArgs> evictionSoftGracePeriod;

    /**
     * @return Defines a map of signal names to durations that defines grace periods for soft eviction thresholds. Each soft eviction threshold must have a corresponding grace period.
     * 
     */
    public Optional<Output<NodePoolNodeConfigKubeletConfigEvictionSoftGracePeriodArgs>> evictionSoftGracePeriod() {
        return Optional.ofNullable(this.evictionSoftGracePeriod);
    }

    /**
     * Defines the percent of disk usage after which image garbage collection is always run.
     * 
     */
    @Import(name="imageGcHighThresholdPercent")
    private @Nullable Output<Integer> imageGcHighThresholdPercent;

    /**
     * @return Defines the percent of disk usage after which image garbage collection is always run.
     * 
     */
    public Optional<Output<Integer>> imageGcHighThresholdPercent() {
        return Optional.ofNullable(this.imageGcHighThresholdPercent);
    }

    /**
     * Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to.
     * 
     */
    @Import(name="imageGcLowThresholdPercent")
    private @Nullable Output<Integer> imageGcLowThresholdPercent;

    /**
     * @return Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to.
     * 
     */
    public Optional<Output<Integer>> imageGcLowThresholdPercent() {
        return Optional.ofNullable(this.imageGcLowThresholdPercent);
    }

    /**
     * Defines the maximum age an image can be unused before it is garbage collected.
     * 
     */
    @Import(name="imageMaximumGcAge")
    private @Nullable Output<String> imageMaximumGcAge;

    /**
     * @return Defines the maximum age an image can be unused before it is garbage collected.
     * 
     */
    public Optional<Output<String>> imageMaximumGcAge() {
        return Optional.ofNullable(this.imageMaximumGcAge);
    }

    /**
     * Defines the minimum age for an unused image before it is garbage collected.
     * 
     */
    @Import(name="imageMinimumGcAge")
    private @Nullable Output<String> imageMinimumGcAge;

    /**
     * @return Defines the minimum age for an unused image before it is garbage collected.
     * 
     */
    public Optional<Output<String>> imageMinimumGcAge() {
        return Optional.ofNullable(this.imageMinimumGcAge);
    }

    /**
     * Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to `FALSE`. Possible values: `TRUE`, `FALSE`.
     * 
     */
    @Import(name="insecureKubeletReadonlyPortEnabled")
    private @Nullable Output<String> insecureKubeletReadonlyPortEnabled;

    /**
     * @return Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to `FALSE`. Possible values: `TRUE`, `FALSE`.
     * 
     */
    public Optional<Output<String>> insecureKubeletReadonlyPortEnabled() {
        return Optional.ofNullable(this.insecureKubeletReadonlyPortEnabled);
    }

    /**
     * Set the maximum number of image pulls in parallel.
     * 
     */
    @Import(name="maxParallelImagePulls")
    private @Nullable Output<Integer> maxParallelImagePulls;

    /**
     * @return Set the maximum number of image pulls in parallel.
     * 
     */
    public Optional<Output<Integer>> maxParallelImagePulls() {
        return Optional.ofNullable(this.maxParallelImagePulls);
    }

    /**
     * Controls the maximum number of processes allowed to run in a pod.
     * 
     */
    @Import(name="podPidsLimit")
    private @Nullable Output<Integer> podPidsLimit;

    /**
     * @return Controls the maximum number of processes allowed to run in a pod.
     * 
     */
    public Optional<Output<Integer>> podPidsLimit() {
        return Optional.ofNullable(this.podPidsLimit);
    }

    /**
     * Defines whether to enable single process OOM killer.
     * 
     */
    @Import(name="singleProcessOomKill")
    private @Nullable Output<Boolean> singleProcessOomKill;

    /**
     * @return Defines whether to enable single process OOM killer.
     * 
     */
    public Optional<Output<Boolean>> singleProcessOomKill() {
        return Optional.ofNullable(this.singleProcessOomKill);
    }

    private NodePoolNodeConfigKubeletConfigArgs() {}

    private NodePoolNodeConfigKubeletConfigArgs(NodePoolNodeConfigKubeletConfigArgs $) {
        this.allowedUnsafeSysctls = $.allowedUnsafeSysctls;
        this.containerLogMaxFiles = $.containerLogMaxFiles;
        this.containerLogMaxSize = $.containerLogMaxSize;
        this.cpuCfsQuota = $.cpuCfsQuota;
        this.cpuCfsQuotaPeriod = $.cpuCfsQuotaPeriod;
        this.cpuManagerPolicy = $.cpuManagerPolicy;
        this.evictionMaxPodGracePeriodSeconds = $.evictionMaxPodGracePeriodSeconds;
        this.evictionMinimumReclaim = $.evictionMinimumReclaim;
        this.evictionSoft = $.evictionSoft;
        this.evictionSoftGracePeriod = $.evictionSoftGracePeriod;
        this.imageGcHighThresholdPercent = $.imageGcHighThresholdPercent;
        this.imageGcLowThresholdPercent = $.imageGcLowThresholdPercent;
        this.imageMaximumGcAge = $.imageMaximumGcAge;
        this.imageMinimumGcAge = $.imageMinimumGcAge;
        this.insecureKubeletReadonlyPortEnabled = $.insecureKubeletReadonlyPortEnabled;
        this.maxParallelImagePulls = $.maxParallelImagePulls;
        this.podPidsLimit = $.podPidsLimit;
        this.singleProcessOomKill = $.singleProcessOomKill;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(NodePoolNodeConfigKubeletConfigArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private NodePoolNodeConfigKubeletConfigArgs $;

        public Builder() {
            $ = new NodePoolNodeConfigKubeletConfigArgs();
        }

        public Builder(NodePoolNodeConfigKubeletConfigArgs defaults) {
            $ = new NodePoolNodeConfigKubeletConfigArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowedUnsafeSysctls Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods.
         * 
         * @return builder
         * 
         */
        public Builder allowedUnsafeSysctls(@Nullable Output<List<String>> allowedUnsafeSysctls) {
            $.allowedUnsafeSysctls = allowedUnsafeSysctls;
            return this;
        }

        /**
         * @param allowedUnsafeSysctls Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods.
         * 
         * @return builder
         * 
         */
        public Builder allowedUnsafeSysctls(List<String> allowedUnsafeSysctls) {
            return allowedUnsafeSysctls(Output.of(allowedUnsafeSysctls));
        }

        /**
         * @param allowedUnsafeSysctls Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods.
         * 
         * @return builder
         * 
         */
        public Builder allowedUnsafeSysctls(String... allowedUnsafeSysctls) {
            return allowedUnsafeSysctls(List.of(allowedUnsafeSysctls));
        }

        /**
         * @param containerLogMaxFiles Defines the maximum number of container log files that can be present for a container.
         * 
         * @return builder
         * 
         */
        public Builder containerLogMaxFiles(@Nullable Output<Integer> containerLogMaxFiles) {
            $.containerLogMaxFiles = containerLogMaxFiles;
            return this;
        }

        /**
         * @param containerLogMaxFiles Defines the maximum number of container log files that can be present for a container.
         * 
         * @return builder
         * 
         */
        public Builder containerLogMaxFiles(Integer containerLogMaxFiles) {
            return containerLogMaxFiles(Output.of(containerLogMaxFiles));
        }

        /**
         * @param containerLogMaxSize Defines the maximum size of the container log file before it is rotated.
         * 
         * @return builder
         * 
         */
        public Builder containerLogMaxSize(@Nullable Output<String> containerLogMaxSize) {
            $.containerLogMaxSize = containerLogMaxSize;
            return this;
        }

        /**
         * @param containerLogMaxSize Defines the maximum size of the container log file before it is rotated.
         * 
         * @return builder
         * 
         */
        public Builder containerLogMaxSize(String containerLogMaxSize) {
            return containerLogMaxSize(Output.of(containerLogMaxSize));
        }

        /**
         * @param cpuCfsQuota Enable CPU CFS quota enforcement for containers that specify CPU limits.
         * 
         * @return builder
         * 
         */
        public Builder cpuCfsQuota(@Nullable Output<Boolean> cpuCfsQuota) {
            $.cpuCfsQuota = cpuCfsQuota;
            return this;
        }

        /**
         * @param cpuCfsQuota Enable CPU CFS quota enforcement for containers that specify CPU limits.
         * 
         * @return builder
         * 
         */
        public Builder cpuCfsQuota(Boolean cpuCfsQuota) {
            return cpuCfsQuota(Output.of(cpuCfsQuota));
        }

        /**
         * @param cpuCfsQuotaPeriod Set the CPU CFS quota period value &#39;cpu.cfs_period_us&#39;.
         * 
         * @return builder
         * 
         */
        public Builder cpuCfsQuotaPeriod(@Nullable Output<String> cpuCfsQuotaPeriod) {
            $.cpuCfsQuotaPeriod = cpuCfsQuotaPeriod;
            return this;
        }

        /**
         * @param cpuCfsQuotaPeriod Set the CPU CFS quota period value &#39;cpu.cfs_period_us&#39;.
         * 
         * @return builder
         * 
         */
        public Builder cpuCfsQuotaPeriod(String cpuCfsQuotaPeriod) {
            return cpuCfsQuotaPeriod(Output.of(cpuCfsQuotaPeriod));
        }

        /**
         * @param cpuManagerPolicy Control the CPU management policy on the node.
         * 
         * @return builder
         * 
         */
        public Builder cpuManagerPolicy(@Nullable Output<String> cpuManagerPolicy) {
            $.cpuManagerPolicy = cpuManagerPolicy;
            return this;
        }

        /**
         * @param cpuManagerPolicy Control the CPU management policy on the node.
         * 
         * @return builder
         * 
         */
        public Builder cpuManagerPolicy(String cpuManagerPolicy) {
            return cpuManagerPolicy(Output.of(cpuManagerPolicy));
        }

        /**
         * @param evictionMaxPodGracePeriodSeconds Defines the maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.
         * 
         * @return builder
         * 
         */
        public Builder evictionMaxPodGracePeriodSeconds(@Nullable Output<Integer> evictionMaxPodGracePeriodSeconds) {
            $.evictionMaxPodGracePeriodSeconds = evictionMaxPodGracePeriodSeconds;
            return this;
        }

        /**
         * @param evictionMaxPodGracePeriodSeconds Defines the maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.
         * 
         * @return builder
         * 
         */
        public Builder evictionMaxPodGracePeriodSeconds(Integer evictionMaxPodGracePeriodSeconds) {
            return evictionMaxPodGracePeriodSeconds(Output.of(evictionMaxPodGracePeriodSeconds));
        }

        /**
         * @param evictionMinimumReclaim Defines a map of signal names to percentage that defines minimum reclaims. It describes the minimum amount of a given resource the kubelet will reclaim when performing a pod eviction.
         * 
         * @return builder
         * 
         */
        public Builder evictionMinimumReclaim(@Nullable Output<NodePoolNodeConfigKubeletConfigEvictionMinimumReclaimArgs> evictionMinimumReclaim) {
            $.evictionMinimumReclaim = evictionMinimumReclaim;
            return this;
        }

        /**
         * @param evictionMinimumReclaim Defines a map of signal names to percentage that defines minimum reclaims. It describes the minimum amount of a given resource the kubelet will reclaim when performing a pod eviction.
         * 
         * @return builder
         * 
         */
        public Builder evictionMinimumReclaim(NodePoolNodeConfigKubeletConfigEvictionMinimumReclaimArgs evictionMinimumReclaim) {
            return evictionMinimumReclaim(Output.of(evictionMinimumReclaim));
        }

        /**
         * @param evictionSoft Defines a map of signal names to quantities or percentage that defines soft eviction thresholds.
         * 
         * @return builder
         * 
         */
        public Builder evictionSoft(@Nullable Output<NodePoolNodeConfigKubeletConfigEvictionSoftArgs> evictionSoft) {
            $.evictionSoft = evictionSoft;
            return this;
        }

        /**
         * @param evictionSoft Defines a map of signal names to quantities or percentage that defines soft eviction thresholds.
         * 
         * @return builder
         * 
         */
        public Builder evictionSoft(NodePoolNodeConfigKubeletConfigEvictionSoftArgs evictionSoft) {
            return evictionSoft(Output.of(evictionSoft));
        }

        /**
         * @param evictionSoftGracePeriod Defines a map of signal names to durations that defines grace periods for soft eviction thresholds. Each soft eviction threshold must have a corresponding grace period.
         * 
         * @return builder
         * 
         */
        public Builder evictionSoftGracePeriod(@Nullable Output<NodePoolNodeConfigKubeletConfigEvictionSoftGracePeriodArgs> evictionSoftGracePeriod) {
            $.evictionSoftGracePeriod = evictionSoftGracePeriod;
            return this;
        }

        /**
         * @param evictionSoftGracePeriod Defines a map of signal names to durations that defines grace periods for soft eviction thresholds. Each soft eviction threshold must have a corresponding grace period.
         * 
         * @return builder
         * 
         */
        public Builder evictionSoftGracePeriod(NodePoolNodeConfigKubeletConfigEvictionSoftGracePeriodArgs evictionSoftGracePeriod) {
            return evictionSoftGracePeriod(Output.of(evictionSoftGracePeriod));
        }

        /**
         * @param imageGcHighThresholdPercent Defines the percent of disk usage after which image garbage collection is always run.
         * 
         * @return builder
         * 
         */
        public Builder imageGcHighThresholdPercent(@Nullable Output<Integer> imageGcHighThresholdPercent) {
            $.imageGcHighThresholdPercent = imageGcHighThresholdPercent;
            return this;
        }

        /**
         * @param imageGcHighThresholdPercent Defines the percent of disk usage after which image garbage collection is always run.
         * 
         * @return builder
         * 
         */
        public Builder imageGcHighThresholdPercent(Integer imageGcHighThresholdPercent) {
            return imageGcHighThresholdPercent(Output.of(imageGcHighThresholdPercent));
        }

        /**
         * @param imageGcLowThresholdPercent Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to.
         * 
         * @return builder
         * 
         */
        public Builder imageGcLowThresholdPercent(@Nullable Output<Integer> imageGcLowThresholdPercent) {
            $.imageGcLowThresholdPercent = imageGcLowThresholdPercent;
            return this;
        }

        /**
         * @param imageGcLowThresholdPercent Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to.
         * 
         * @return builder
         * 
         */
        public Builder imageGcLowThresholdPercent(Integer imageGcLowThresholdPercent) {
            return imageGcLowThresholdPercent(Output.of(imageGcLowThresholdPercent));
        }

        /**
         * @param imageMaximumGcAge Defines the maximum age an image can be unused before it is garbage collected.
         * 
         * @return builder
         * 
         */
        public Builder imageMaximumGcAge(@Nullable Output<String> imageMaximumGcAge) {
            $.imageMaximumGcAge = imageMaximumGcAge;
            return this;
        }

        /**
         * @param imageMaximumGcAge Defines the maximum age an image can be unused before it is garbage collected.
         * 
         * @return builder
         * 
         */
        public Builder imageMaximumGcAge(String imageMaximumGcAge) {
            return imageMaximumGcAge(Output.of(imageMaximumGcAge));
        }

        /**
         * @param imageMinimumGcAge Defines the minimum age for an unused image before it is garbage collected.
         * 
         * @return builder
         * 
         */
        public Builder imageMinimumGcAge(@Nullable Output<String> imageMinimumGcAge) {
            $.imageMinimumGcAge = imageMinimumGcAge;
            return this;
        }

        /**
         * @param imageMinimumGcAge Defines the minimum age for an unused image before it is garbage collected.
         * 
         * @return builder
         * 
         */
        public Builder imageMinimumGcAge(String imageMinimumGcAge) {
            return imageMinimumGcAge(Output.of(imageMinimumGcAge));
        }

        /**
         * @param insecureKubeletReadonlyPortEnabled Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to `FALSE`. Possible values: `TRUE`, `FALSE`.
         * 
         * @return builder
         * 
         */
        public Builder insecureKubeletReadonlyPortEnabled(@Nullable Output<String> insecureKubeletReadonlyPortEnabled) {
            $.insecureKubeletReadonlyPortEnabled = insecureKubeletReadonlyPortEnabled;
            return this;
        }

        /**
         * @param insecureKubeletReadonlyPortEnabled Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to `FALSE`. Possible values: `TRUE`, `FALSE`.
         * 
         * @return builder
         * 
         */
        public Builder insecureKubeletReadonlyPortEnabled(String insecureKubeletReadonlyPortEnabled) {
            return insecureKubeletReadonlyPortEnabled(Output.of(insecureKubeletReadonlyPortEnabled));
        }

        /**
         * @param maxParallelImagePulls Set the maximum number of image pulls in parallel.
         * 
         * @return builder
         * 
         */
        public Builder maxParallelImagePulls(@Nullable Output<Integer> maxParallelImagePulls) {
            $.maxParallelImagePulls = maxParallelImagePulls;
            return this;
        }

        /**
         * @param maxParallelImagePulls Set the maximum number of image pulls in parallel.
         * 
         * @return builder
         * 
         */
        public Builder maxParallelImagePulls(Integer maxParallelImagePulls) {
            return maxParallelImagePulls(Output.of(maxParallelImagePulls));
        }

        /**
         * @param podPidsLimit Controls the maximum number of processes allowed to run in a pod.
         * 
         * @return builder
         * 
         */
        public Builder podPidsLimit(@Nullable Output<Integer> podPidsLimit) {
            $.podPidsLimit = podPidsLimit;
            return this;
        }

        /**
         * @param podPidsLimit Controls the maximum number of processes allowed to run in a pod.
         * 
         * @return builder
         * 
         */
        public Builder podPidsLimit(Integer podPidsLimit) {
            return podPidsLimit(Output.of(podPidsLimit));
        }

        /**
         * @param singleProcessOomKill Defines whether to enable single process OOM killer.
         * 
         * @return builder
         * 
         */
        public Builder singleProcessOomKill(@Nullable Output<Boolean> singleProcessOomKill) {
            $.singleProcessOomKill = singleProcessOomKill;
            return this;
        }

        /**
         * @param singleProcessOomKill Defines whether to enable single process OOM killer.
         * 
         * @return builder
         * 
         */
        public Builder singleProcessOomKill(Boolean singleProcessOomKill) {
            return singleProcessOomKill(Output.of(singleProcessOomKill));
        }

        public NodePoolNodeConfigKubeletConfigArgs build() {
            return $;
        }
    }

}
