// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.gcp.compute.outputs.URLMapPathMatcherRouteRuleMatchRuleHeaderMatch;
import com.pulumi.gcp.compute.outputs.URLMapPathMatcherRouteRuleMatchRuleMetadataFilter;
import com.pulumi.gcp.compute.outputs.URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class URLMapPathMatcherRouteRuleMatchRule {
    /**
     * @return For satisfying the matchRule condition, the path of the request must exactly
     * match the value specified in fullPathMatch after removing any query parameters
     * and anchor that may be part of the original URL. FullPathMatch must be between 1
     * and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
     * be specified.
     * 
     */
    private final @Nullable String fullPathMatch;
    /**
     * @return Specifies a list of header match criteria, all of which must match corresponding
     * headers in the request.
     * Structure is documented below.
     * 
     */
    private final @Nullable List<URLMapPathMatcherRouteRuleMatchRuleHeaderMatch> headerMatches;
    /**
     * @return Specifies that prefixMatch and fullPathMatch matches are case sensitive.
     * Defaults to false.
     * 
     */
    private final @Nullable Boolean ignoreCase;
    /**
     * @return Opaque filter criteria used by Loadbalancer to restrict routing configuration to
     * a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
     * clients present node metadata. If a match takes place, the relevant routing
     * configuration is made available to those proxies. For each metadataFilter in
     * this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
     * filterLabels must match the corresponding label provided in the metadata. If its
     * filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
     * with corresponding labels in the provided metadata. metadataFilters specified
     * here can be overrides those specified in ForwardingRule that refers to this
     * UrlMap. metadataFilters only applies to Loadbalancers that have their
     * loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * Structure is documented below.
     * 
     */
    private final @Nullable List<URLMapPathMatcherRouteRuleMatchRuleMetadataFilter> metadataFilters;
    /**
     * @return The value of the header must start with the contents of prefixMatch. Only one of
     * exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
     * must be set.
     * 
     */
    private final @Nullable String prefixMatch;
    /**
     * @return Specifies a list of query parameter match criteria, all of which must match
     * corresponding query parameters in the request.
     * Structure is documented below.
     * 
     */
    private final @Nullable List<URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch> queryParameterMatches;
    /**
     * @return The queryParameterMatch matches if the value of the parameter matches the
     * regular expression specified by regexMatch. For the regular expression grammar,
     * please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
     * exactMatch and regexMatch must be set.
     * 
     */
    private final @Nullable String regexMatch;

    @CustomType.Constructor
    private URLMapPathMatcherRouteRuleMatchRule(
        @CustomType.Parameter("fullPathMatch") @Nullable String fullPathMatch,
        @CustomType.Parameter("headerMatches") @Nullable List<URLMapPathMatcherRouteRuleMatchRuleHeaderMatch> headerMatches,
        @CustomType.Parameter("ignoreCase") @Nullable Boolean ignoreCase,
        @CustomType.Parameter("metadataFilters") @Nullable List<URLMapPathMatcherRouteRuleMatchRuleMetadataFilter> metadataFilters,
        @CustomType.Parameter("prefixMatch") @Nullable String prefixMatch,
        @CustomType.Parameter("queryParameterMatches") @Nullable List<URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch> queryParameterMatches,
        @CustomType.Parameter("regexMatch") @Nullable String regexMatch) {
        this.fullPathMatch = fullPathMatch;
        this.headerMatches = headerMatches;
        this.ignoreCase = ignoreCase;
        this.metadataFilters = metadataFilters;
        this.prefixMatch = prefixMatch;
        this.queryParameterMatches = queryParameterMatches;
        this.regexMatch = regexMatch;
    }

    /**
     * @return For satisfying the matchRule condition, the path of the request must exactly
     * match the value specified in fullPathMatch after removing any query parameters
     * and anchor that may be part of the original URL. FullPathMatch must be between 1
     * and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
     * be specified.
     * 
     */
    public Optional<String> fullPathMatch() {
        return Optional.ofNullable(this.fullPathMatch);
    }
    /**
     * @return Specifies a list of header match criteria, all of which must match corresponding
     * headers in the request.
     * Structure is documented below.
     * 
     */
    public List<URLMapPathMatcherRouteRuleMatchRuleHeaderMatch> headerMatches() {
        return this.headerMatches == null ? List.of() : this.headerMatches;
    }
    /**
     * @return Specifies that prefixMatch and fullPathMatch matches are case sensitive.
     * Defaults to false.
     * 
     */
    public Optional<Boolean> ignoreCase() {
        return Optional.ofNullable(this.ignoreCase);
    }
    /**
     * @return Opaque filter criteria used by Loadbalancer to restrict routing configuration to
     * a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
     * clients present node metadata. If a match takes place, the relevant routing
     * configuration is made available to those proxies. For each metadataFilter in
     * this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
     * filterLabels must match the corresponding label provided in the metadata. If its
     * filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
     * with corresponding labels in the provided metadata. metadataFilters specified
     * here can be overrides those specified in ForwardingRule that refers to this
     * UrlMap. metadataFilters only applies to Loadbalancers that have their
     * loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * Structure is documented below.
     * 
     */
    public List<URLMapPathMatcherRouteRuleMatchRuleMetadataFilter> metadataFilters() {
        return this.metadataFilters == null ? List.of() : this.metadataFilters;
    }
    /**
     * @return The value of the header must start with the contents of prefixMatch. Only one of
     * exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
     * must be set.
     * 
     */
    public Optional<String> prefixMatch() {
        return Optional.ofNullable(this.prefixMatch);
    }
    /**
     * @return Specifies a list of query parameter match criteria, all of which must match
     * corresponding query parameters in the request.
     * Structure is documented below.
     * 
     */
    public List<URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch> queryParameterMatches() {
        return this.queryParameterMatches == null ? List.of() : this.queryParameterMatches;
    }
    /**
     * @return The queryParameterMatch matches if the value of the parameter matches the
     * regular expression specified by regexMatch. For the regular expression grammar,
     * please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
     * exactMatch and regexMatch must be set.
     * 
     */
    public Optional<String> regexMatch() {
        return Optional.ofNullable(this.regexMatch);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(URLMapPathMatcherRouteRuleMatchRule defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable String fullPathMatch;
        private @Nullable List<URLMapPathMatcherRouteRuleMatchRuleHeaderMatch> headerMatches;
        private @Nullable Boolean ignoreCase;
        private @Nullable List<URLMapPathMatcherRouteRuleMatchRuleMetadataFilter> metadataFilters;
        private @Nullable String prefixMatch;
        private @Nullable List<URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch> queryParameterMatches;
        private @Nullable String regexMatch;

        public Builder() {
    	      // Empty
        }

        public Builder(URLMapPathMatcherRouteRuleMatchRule defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.fullPathMatch = defaults.fullPathMatch;
    	      this.headerMatches = defaults.headerMatches;
    	      this.ignoreCase = defaults.ignoreCase;
    	      this.metadataFilters = defaults.metadataFilters;
    	      this.prefixMatch = defaults.prefixMatch;
    	      this.queryParameterMatches = defaults.queryParameterMatches;
    	      this.regexMatch = defaults.regexMatch;
        }

        public Builder fullPathMatch(@Nullable String fullPathMatch) {
            this.fullPathMatch = fullPathMatch;
            return this;
        }
        public Builder headerMatches(@Nullable List<URLMapPathMatcherRouteRuleMatchRuleHeaderMatch> headerMatches) {
            this.headerMatches = headerMatches;
            return this;
        }
        public Builder headerMatches(URLMapPathMatcherRouteRuleMatchRuleHeaderMatch... headerMatches) {
            return headerMatches(List.of(headerMatches));
        }
        public Builder ignoreCase(@Nullable Boolean ignoreCase) {
            this.ignoreCase = ignoreCase;
            return this;
        }
        public Builder metadataFilters(@Nullable List<URLMapPathMatcherRouteRuleMatchRuleMetadataFilter> metadataFilters) {
            this.metadataFilters = metadataFilters;
            return this;
        }
        public Builder metadataFilters(URLMapPathMatcherRouteRuleMatchRuleMetadataFilter... metadataFilters) {
            return metadataFilters(List.of(metadataFilters));
        }
        public Builder prefixMatch(@Nullable String prefixMatch) {
            this.prefixMatch = prefixMatch;
            return this;
        }
        public Builder queryParameterMatches(@Nullable List<URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch> queryParameterMatches) {
            this.queryParameterMatches = queryParameterMatches;
            return this;
        }
        public Builder queryParameterMatches(URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch... queryParameterMatches) {
            return queryParameterMatches(List.of(queryParameterMatches));
        }
        public Builder regexMatch(@Nullable String regexMatch) {
            this.regexMatch = regexMatch;
            return this;
        }        public URLMapPathMatcherRouteRuleMatchRule build() {
            return new URLMapPathMatcherRouteRuleMatchRule(fullPathMatch, headerMatches, ignoreCase, metadataFilters, prefixMatch, queryParameterMatches, regexMatch);
        }
    }
}
