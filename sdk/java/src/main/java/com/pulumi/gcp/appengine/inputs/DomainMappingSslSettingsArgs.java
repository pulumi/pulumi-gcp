// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.appengine.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DomainMappingSslSettingsArgs extends com.pulumi.resources.ResourceArgs {

    public static final DomainMappingSslSettingsArgs Empty = new DomainMappingSslSettingsArgs();

    /**
     * ID of the AuthorizedCertificate resource configuring SSL for the application. Clearing this field will
     * remove SSL support.
     * By default, a managed certificate is automatically created for every domain mapping. To omit SSL support
     * or to configure SSL manually, specify `SslManagementType.MANUAL` on a `CREATE` or `UPDATE` request. You must be
     * authorized to administer the `AuthorizedCertificate` resource to manually map it to a DomainMapping resource.
     * Example: 12345.
     * 
     */
    @Import(name="certificateId")
    private @Nullable Output<String> certificateId;

    /**
     * @return ID of the AuthorizedCertificate resource configuring SSL for the application. Clearing this field will
     * remove SSL support.
     * By default, a managed certificate is automatically created for every domain mapping. To omit SSL support
     * or to configure SSL manually, specify `SslManagementType.MANUAL` on a `CREATE` or `UPDATE` request. You must be
     * authorized to administer the `AuthorizedCertificate` resource to manually map it to a DomainMapping resource.
     * Example: 12345.
     * 
     */
    public Optional<Output<String>> certificateId() {
        return Optional.ofNullable(this.certificateId);
    }

    /**
     * (Output)
     * ID of the managed `AuthorizedCertificate` resource currently being provisioned, if applicable. Until the new
     * managed certificate has been successfully provisioned, the previous SSL state will be preserved. Once the
     * provisioning process completes, the `certificateId` field will reflect the new managed certificate and this
     * field will be left empty. To remove SSL support while there is still a pending managed certificate, clear the
     * `certificateId` field with an update request.
     * 
     */
    @Import(name="pendingManagedCertificateId")
    private @Nullable Output<String> pendingManagedCertificateId;

    /**
     * @return (Output)
     * ID of the managed `AuthorizedCertificate` resource currently being provisioned, if applicable. Until the new
     * managed certificate has been successfully provisioned, the previous SSL state will be preserved. Once the
     * provisioning process completes, the `certificateId` field will reflect the new managed certificate and this
     * field will be left empty. To remove SSL support while there is still a pending managed certificate, clear the
     * `certificateId` field with an update request.
     * 
     */
    public Optional<Output<String>> pendingManagedCertificateId() {
        return Optional.ofNullable(this.pendingManagedCertificateId);
    }

    /**
     * SSL management type for this domain. If `AUTOMATIC`, a managed certificate is automatically provisioned.
     * If `MANUAL`, `certificateId` must be manually specified in order to configure SSL for this domain.
     * Possible values are: `AUTOMATIC`, `MANUAL`.
     * 
     */
    @Import(name="sslManagementType", required=true)
    private Output<String> sslManagementType;

    /**
     * @return SSL management type for this domain. If `AUTOMATIC`, a managed certificate is automatically provisioned.
     * If `MANUAL`, `certificateId` must be manually specified in order to configure SSL for this domain.
     * Possible values are: `AUTOMATIC`, `MANUAL`.
     * 
     */
    public Output<String> sslManagementType() {
        return this.sslManagementType;
    }

    private DomainMappingSslSettingsArgs() {}

    private DomainMappingSslSettingsArgs(DomainMappingSslSettingsArgs $) {
        this.certificateId = $.certificateId;
        this.pendingManagedCertificateId = $.pendingManagedCertificateId;
        this.sslManagementType = $.sslManagementType;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DomainMappingSslSettingsArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DomainMappingSslSettingsArgs $;

        public Builder() {
            $ = new DomainMappingSslSettingsArgs();
        }

        public Builder(DomainMappingSslSettingsArgs defaults) {
            $ = new DomainMappingSslSettingsArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param certificateId ID of the AuthorizedCertificate resource configuring SSL for the application. Clearing this field will
         * remove SSL support.
         * By default, a managed certificate is automatically created for every domain mapping. To omit SSL support
         * or to configure SSL manually, specify `SslManagementType.MANUAL` on a `CREATE` or `UPDATE` request. You must be
         * authorized to administer the `AuthorizedCertificate` resource to manually map it to a DomainMapping resource.
         * Example: 12345.
         * 
         * @return builder
         * 
         */
        public Builder certificateId(@Nullable Output<String> certificateId) {
            $.certificateId = certificateId;
            return this;
        }

        /**
         * @param certificateId ID of the AuthorizedCertificate resource configuring SSL for the application. Clearing this field will
         * remove SSL support.
         * By default, a managed certificate is automatically created for every domain mapping. To omit SSL support
         * or to configure SSL manually, specify `SslManagementType.MANUAL` on a `CREATE` or `UPDATE` request. You must be
         * authorized to administer the `AuthorizedCertificate` resource to manually map it to a DomainMapping resource.
         * Example: 12345.
         * 
         * @return builder
         * 
         */
        public Builder certificateId(String certificateId) {
            return certificateId(Output.of(certificateId));
        }

        /**
         * @param pendingManagedCertificateId (Output)
         * ID of the managed `AuthorizedCertificate` resource currently being provisioned, if applicable. Until the new
         * managed certificate has been successfully provisioned, the previous SSL state will be preserved. Once the
         * provisioning process completes, the `certificateId` field will reflect the new managed certificate and this
         * field will be left empty. To remove SSL support while there is still a pending managed certificate, clear the
         * `certificateId` field with an update request.
         * 
         * @return builder
         * 
         */
        public Builder pendingManagedCertificateId(@Nullable Output<String> pendingManagedCertificateId) {
            $.pendingManagedCertificateId = pendingManagedCertificateId;
            return this;
        }

        /**
         * @param pendingManagedCertificateId (Output)
         * ID of the managed `AuthorizedCertificate` resource currently being provisioned, if applicable. Until the new
         * managed certificate has been successfully provisioned, the previous SSL state will be preserved. Once the
         * provisioning process completes, the `certificateId` field will reflect the new managed certificate and this
         * field will be left empty. To remove SSL support while there is still a pending managed certificate, clear the
         * `certificateId` field with an update request.
         * 
         * @return builder
         * 
         */
        public Builder pendingManagedCertificateId(String pendingManagedCertificateId) {
            return pendingManagedCertificateId(Output.of(pendingManagedCertificateId));
        }

        /**
         * @param sslManagementType SSL management type for this domain. If `AUTOMATIC`, a managed certificate is automatically provisioned.
         * If `MANUAL`, `certificateId` must be manually specified in order to configure SSL for this domain.
         * Possible values are: `AUTOMATIC`, `MANUAL`.
         * 
         * @return builder
         * 
         */
        public Builder sslManagementType(Output<String> sslManagementType) {
            $.sslManagementType = sslManagementType;
            return this;
        }

        /**
         * @param sslManagementType SSL management type for this domain. If `AUTOMATIC`, a managed certificate is automatically provisioned.
         * If `MANUAL`, `certificateId` must be manually specified in order to configure SSL for this domain.
         * Possible values are: `AUTOMATIC`, `MANUAL`.
         * 
         * @return builder
         * 
         */
        public Builder sslManagementType(String sslManagementType) {
            return sslManagementType(Output.of(sslManagementType));
        }

        public DomainMappingSslSettingsArgs build() {
            if ($.sslManagementType == null) {
                throw new MissingRequiredPropertyException("DomainMappingSslSettingsArgs", "sslManagementType");
            }
            return $;
        }
    }

}
