// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.diagflow.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.diagflow.inputs.CxWebhookGenericWebServiceOauthConfigArgs;
import com.pulumi.gcp.diagflow.inputs.CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgs;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class CxWebhookGenericWebServiceArgs extends com.pulumi.resources.ResourceArgs {

    public static final CxWebhookGenericWebServiceArgs Empty = new CxWebhookGenericWebServiceArgs();

    /**
     * Specifies a list of allowed custom CA certificates (in DER format) for
     * HTTPS verification. This overrides the default SSL trust store. If this
     * is empty or unspecified, Dialogflow will use Google&#39;s default trust store
     * to verify certificates.
     * N.B. Make sure the HTTPS server certificates are signed with &#34;subject alt
     * name&#34;. For instance a certificate can be self-signed using the following
     * command,
     * openssl x509 -req -days 200 -in example.com.csr\
     * -signkey example.com.key\
     * -out example.com.crt\
     * -extfile &lt;(printf &#34;\nsubjectAltName=&#39;DNS:www.example.com&#39;&#34;)
     * 
     */
    @Import(name="allowedCaCerts")
    private @Nullable Output<List<String>> allowedCaCerts;

    /**
     * @return Specifies a list of allowed custom CA certificates (in DER format) for
     * HTTPS verification. This overrides the default SSL trust store. If this
     * is empty or unspecified, Dialogflow will use Google&#39;s default trust store
     * to verify certificates.
     * N.B. Make sure the HTTPS server certificates are signed with &#34;subject alt
     * name&#34;. For instance a certificate can be self-signed using the following
     * command,
     * openssl x509 -req -days 200 -in example.com.csr\
     * -signkey example.com.key\
     * -out example.com.crt\
     * -extfile &lt;(printf &#34;\nsubjectAltName=&#39;DNS:www.example.com&#39;&#34;)
     * 
     */
    public Optional<Output<List<String>>> allowedCaCerts() {
        return Optional.ofNullable(this.allowedCaCerts);
    }

    /**
     * HTTP method for the flexible webhook calls. Standard webhook always uses
     * POST.
     * Possible values are: `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
     * 
     */
    @Import(name="httpMethod")
    private @Nullable Output<String> httpMethod;

    /**
     * @return HTTP method for the flexible webhook calls. Standard webhook always uses
     * POST.
     * Possible values are: `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
     * 
     */
    public Optional<Output<String>> httpMethod() {
        return Optional.ofNullable(this.httpMethod);
    }

    /**
     * Represents configuration of OAuth client credential flow for 3rd party
     * API authentication.
     * Structure is documented below.
     * 
     */
    @Import(name="oauthConfig")
    private @Nullable Output<CxWebhookGenericWebServiceOauthConfigArgs> oauthConfig;

    /**
     * @return Represents configuration of OAuth client credential flow for 3rd party
     * API authentication.
     * Structure is documented below.
     * 
     */
    public Optional<Output<CxWebhookGenericWebServiceOauthConfigArgs>> oauthConfig() {
        return Optional.ofNullable(this.oauthConfig);
    }

    /**
     * Maps the values extracted from specific fields of the flexible webhook
     * response into session parameters.
     * - Key: session parameter name
     * - Value: field path in the webhook response
     * 
     */
    @Import(name="parameterMapping")
    private @Nullable Output<Map<String,String>> parameterMapping;

    /**
     * @return Maps the values extracted from specific fields of the flexible webhook
     * response into session parameters.
     * - Key: session parameter name
     * - Value: field path in the webhook response
     * 
     */
    public Optional<Output<Map<String,String>>> parameterMapping() {
        return Optional.ofNullable(this.parameterMapping);
    }

    /**
     * Defines a custom JSON object as request body to send to flexible webhook.
     * 
     */
    @Import(name="requestBody")
    private @Nullable Output<String> requestBody;

    /**
     * @return Defines a custom JSON object as request body to send to flexible webhook.
     * 
     */
    public Optional<Output<String>> requestBody() {
        return Optional.ofNullable(this.requestBody);
    }

    /**
     * The HTTP request headers to send together with webhook requests.
     * 
     */
    @Import(name="requestHeaders")
    private @Nullable Output<Map<String,String>> requestHeaders;

    /**
     * @return The HTTP request headers to send together with webhook requests.
     * 
     */
    public Optional<Output<Map<String,String>>> requestHeaders() {
        return Optional.ofNullable(this.requestHeaders);
    }

    /**
     * The SecretManager secret version resource storing the username:password
     * pair for HTTP Basic authentication.
     * Format: `projects/{project}/secrets/{secret}/versions/{version}`
     * 
     */
    @Import(name="secretVersionForUsernamePassword")
    private @Nullable Output<String> secretVersionForUsernamePassword;

    /**
     * @return The SecretManager secret version resource storing the username:password
     * pair for HTTP Basic authentication.
     * Format: `projects/{project}/secrets/{secret}/versions/{version}`
     * 
     */
    public Optional<Output<String>> secretVersionForUsernamePassword() {
        return Optional.ofNullable(this.secretVersionForUsernamePassword);
    }

    /**
     * The HTTP request headers to send together with webhook requests. Header
     * values are stored in SecretManager secret versions.
     * When the same header name is specified in both `request_headers` and
     * `secret_versions_for_request_headers`, the value in
     * `secret_versions_for_request_headers` will be used.
     * Structure is documented below.
     * 
     */
    @Import(name="secretVersionsForRequestHeaders")
    private @Nullable Output<List<CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgs>> secretVersionsForRequestHeaders;

    /**
     * @return The HTTP request headers to send together with webhook requests. Header
     * values are stored in SecretManager secret versions.
     * When the same header name is specified in both `request_headers` and
     * `secret_versions_for_request_headers`, the value in
     * `secret_versions_for_request_headers` will be used.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgs>>> secretVersionsForRequestHeaders() {
        return Optional.ofNullable(this.secretVersionsForRequestHeaders);
    }

    /**
     * Indicate the auth token type generated from the [Diglogflow service
     * agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
     * The generated token is sent in the Authorization header.
     * Possible values are: `NONE`, `ID_TOKEN`, `ACCESS_TOKEN`.
     * 
     */
    @Import(name="serviceAgentAuth")
    private @Nullable Output<String> serviceAgentAuth;

    /**
     * @return Indicate the auth token type generated from the [Diglogflow service
     * agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
     * The generated token is sent in the Authorization header.
     * Possible values are: `NONE`, `ID_TOKEN`, `ACCESS_TOKEN`.
     * 
     */
    public Optional<Output<String>> serviceAgentAuth() {
        return Optional.ofNullable(this.serviceAgentAuth);
    }

    /**
     * The webhook URI for receiving POST requests. It must use https protocol.
     * 
     */
    @Import(name="uri", required=true)
    private Output<String> uri;

    /**
     * @return The webhook URI for receiving POST requests. It must use https protocol.
     * 
     */
    public Output<String> uri() {
        return this.uri;
    }

    /**
     * Type of the webhook.
     * Possible values are: `STANDARD`, `FLEXIBLE`.
     * 
     */
    @Import(name="webhookType")
    private @Nullable Output<String> webhookType;

    /**
     * @return Type of the webhook.
     * Possible values are: `STANDARD`, `FLEXIBLE`.
     * 
     */
    public Optional<Output<String>> webhookType() {
        return Optional.ofNullable(this.webhookType);
    }

    private CxWebhookGenericWebServiceArgs() {}

    private CxWebhookGenericWebServiceArgs(CxWebhookGenericWebServiceArgs $) {
        this.allowedCaCerts = $.allowedCaCerts;
        this.httpMethod = $.httpMethod;
        this.oauthConfig = $.oauthConfig;
        this.parameterMapping = $.parameterMapping;
        this.requestBody = $.requestBody;
        this.requestHeaders = $.requestHeaders;
        this.secretVersionForUsernamePassword = $.secretVersionForUsernamePassword;
        this.secretVersionsForRequestHeaders = $.secretVersionsForRequestHeaders;
        this.serviceAgentAuth = $.serviceAgentAuth;
        this.uri = $.uri;
        this.webhookType = $.webhookType;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(CxWebhookGenericWebServiceArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private CxWebhookGenericWebServiceArgs $;

        public Builder() {
            $ = new CxWebhookGenericWebServiceArgs();
        }

        public Builder(CxWebhookGenericWebServiceArgs defaults) {
            $ = new CxWebhookGenericWebServiceArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowedCaCerts Specifies a list of allowed custom CA certificates (in DER format) for
         * HTTPS verification. This overrides the default SSL trust store. If this
         * is empty or unspecified, Dialogflow will use Google&#39;s default trust store
         * to verify certificates.
         * N.B. Make sure the HTTPS server certificates are signed with &#34;subject alt
         * name&#34;. For instance a certificate can be self-signed using the following
         * command,
         * openssl x509 -req -days 200 -in example.com.csr\
         * -signkey example.com.key\
         * -out example.com.crt\
         * -extfile &lt;(printf &#34;\nsubjectAltName=&#39;DNS:www.example.com&#39;&#34;)
         * 
         * @return builder
         * 
         */
        public Builder allowedCaCerts(@Nullable Output<List<String>> allowedCaCerts) {
            $.allowedCaCerts = allowedCaCerts;
            return this;
        }

        /**
         * @param allowedCaCerts Specifies a list of allowed custom CA certificates (in DER format) for
         * HTTPS verification. This overrides the default SSL trust store. If this
         * is empty or unspecified, Dialogflow will use Google&#39;s default trust store
         * to verify certificates.
         * N.B. Make sure the HTTPS server certificates are signed with &#34;subject alt
         * name&#34;. For instance a certificate can be self-signed using the following
         * command,
         * openssl x509 -req -days 200 -in example.com.csr\
         * -signkey example.com.key\
         * -out example.com.crt\
         * -extfile &lt;(printf &#34;\nsubjectAltName=&#39;DNS:www.example.com&#39;&#34;)
         * 
         * @return builder
         * 
         */
        public Builder allowedCaCerts(List<String> allowedCaCerts) {
            return allowedCaCerts(Output.of(allowedCaCerts));
        }

        /**
         * @param allowedCaCerts Specifies a list of allowed custom CA certificates (in DER format) for
         * HTTPS verification. This overrides the default SSL trust store. If this
         * is empty or unspecified, Dialogflow will use Google&#39;s default trust store
         * to verify certificates.
         * N.B. Make sure the HTTPS server certificates are signed with &#34;subject alt
         * name&#34;. For instance a certificate can be self-signed using the following
         * command,
         * openssl x509 -req -days 200 -in example.com.csr\
         * -signkey example.com.key\
         * -out example.com.crt\
         * -extfile &lt;(printf &#34;\nsubjectAltName=&#39;DNS:www.example.com&#39;&#34;)
         * 
         * @return builder
         * 
         */
        public Builder allowedCaCerts(String... allowedCaCerts) {
            return allowedCaCerts(List.of(allowedCaCerts));
        }

        /**
         * @param httpMethod HTTP method for the flexible webhook calls. Standard webhook always uses
         * POST.
         * Possible values are: `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
         * 
         * @return builder
         * 
         */
        public Builder httpMethod(@Nullable Output<String> httpMethod) {
            $.httpMethod = httpMethod;
            return this;
        }

        /**
         * @param httpMethod HTTP method for the flexible webhook calls. Standard webhook always uses
         * POST.
         * Possible values are: `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
         * 
         * @return builder
         * 
         */
        public Builder httpMethod(String httpMethod) {
            return httpMethod(Output.of(httpMethod));
        }

        /**
         * @param oauthConfig Represents configuration of OAuth client credential flow for 3rd party
         * API authentication.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder oauthConfig(@Nullable Output<CxWebhookGenericWebServiceOauthConfigArgs> oauthConfig) {
            $.oauthConfig = oauthConfig;
            return this;
        }

        /**
         * @param oauthConfig Represents configuration of OAuth client credential flow for 3rd party
         * API authentication.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder oauthConfig(CxWebhookGenericWebServiceOauthConfigArgs oauthConfig) {
            return oauthConfig(Output.of(oauthConfig));
        }

        /**
         * @param parameterMapping Maps the values extracted from specific fields of the flexible webhook
         * response into session parameters.
         * - Key: session parameter name
         * - Value: field path in the webhook response
         * 
         * @return builder
         * 
         */
        public Builder parameterMapping(@Nullable Output<Map<String,String>> parameterMapping) {
            $.parameterMapping = parameterMapping;
            return this;
        }

        /**
         * @param parameterMapping Maps the values extracted from specific fields of the flexible webhook
         * response into session parameters.
         * - Key: session parameter name
         * - Value: field path in the webhook response
         * 
         * @return builder
         * 
         */
        public Builder parameterMapping(Map<String,String> parameterMapping) {
            return parameterMapping(Output.of(parameterMapping));
        }

        /**
         * @param requestBody Defines a custom JSON object as request body to send to flexible webhook.
         * 
         * @return builder
         * 
         */
        public Builder requestBody(@Nullable Output<String> requestBody) {
            $.requestBody = requestBody;
            return this;
        }

        /**
         * @param requestBody Defines a custom JSON object as request body to send to flexible webhook.
         * 
         * @return builder
         * 
         */
        public Builder requestBody(String requestBody) {
            return requestBody(Output.of(requestBody));
        }

        /**
         * @param requestHeaders The HTTP request headers to send together with webhook requests.
         * 
         * @return builder
         * 
         */
        public Builder requestHeaders(@Nullable Output<Map<String,String>> requestHeaders) {
            $.requestHeaders = requestHeaders;
            return this;
        }

        /**
         * @param requestHeaders The HTTP request headers to send together with webhook requests.
         * 
         * @return builder
         * 
         */
        public Builder requestHeaders(Map<String,String> requestHeaders) {
            return requestHeaders(Output.of(requestHeaders));
        }

        /**
         * @param secretVersionForUsernamePassword The SecretManager secret version resource storing the username:password
         * pair for HTTP Basic authentication.
         * Format: `projects/{project}/secrets/{secret}/versions/{version}`
         * 
         * @return builder
         * 
         */
        public Builder secretVersionForUsernamePassword(@Nullable Output<String> secretVersionForUsernamePassword) {
            $.secretVersionForUsernamePassword = secretVersionForUsernamePassword;
            return this;
        }

        /**
         * @param secretVersionForUsernamePassword The SecretManager secret version resource storing the username:password
         * pair for HTTP Basic authentication.
         * Format: `projects/{project}/secrets/{secret}/versions/{version}`
         * 
         * @return builder
         * 
         */
        public Builder secretVersionForUsernamePassword(String secretVersionForUsernamePassword) {
            return secretVersionForUsernamePassword(Output.of(secretVersionForUsernamePassword));
        }

        /**
         * @param secretVersionsForRequestHeaders The HTTP request headers to send together with webhook requests. Header
         * values are stored in SecretManager secret versions.
         * When the same header name is specified in both `request_headers` and
         * `secret_versions_for_request_headers`, the value in
         * `secret_versions_for_request_headers` will be used.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder secretVersionsForRequestHeaders(@Nullable Output<List<CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgs>> secretVersionsForRequestHeaders) {
            $.secretVersionsForRequestHeaders = secretVersionsForRequestHeaders;
            return this;
        }

        /**
         * @param secretVersionsForRequestHeaders The HTTP request headers to send together with webhook requests. Header
         * values are stored in SecretManager secret versions.
         * When the same header name is specified in both `request_headers` and
         * `secret_versions_for_request_headers`, the value in
         * `secret_versions_for_request_headers` will be used.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder secretVersionsForRequestHeaders(List<CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgs> secretVersionsForRequestHeaders) {
            return secretVersionsForRequestHeaders(Output.of(secretVersionsForRequestHeaders));
        }

        /**
         * @param secretVersionsForRequestHeaders The HTTP request headers to send together with webhook requests. Header
         * values are stored in SecretManager secret versions.
         * When the same header name is specified in both `request_headers` and
         * `secret_versions_for_request_headers`, the value in
         * `secret_versions_for_request_headers` will be used.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder secretVersionsForRequestHeaders(CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgs... secretVersionsForRequestHeaders) {
            return secretVersionsForRequestHeaders(List.of(secretVersionsForRequestHeaders));
        }

        /**
         * @param serviceAgentAuth Indicate the auth token type generated from the [Diglogflow service
         * agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
         * The generated token is sent in the Authorization header.
         * Possible values are: `NONE`, `ID_TOKEN`, `ACCESS_TOKEN`.
         * 
         * @return builder
         * 
         */
        public Builder serviceAgentAuth(@Nullable Output<String> serviceAgentAuth) {
            $.serviceAgentAuth = serviceAgentAuth;
            return this;
        }

        /**
         * @param serviceAgentAuth Indicate the auth token type generated from the [Diglogflow service
         * agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
         * The generated token is sent in the Authorization header.
         * Possible values are: `NONE`, `ID_TOKEN`, `ACCESS_TOKEN`.
         * 
         * @return builder
         * 
         */
        public Builder serviceAgentAuth(String serviceAgentAuth) {
            return serviceAgentAuth(Output.of(serviceAgentAuth));
        }

        /**
         * @param uri The webhook URI for receiving POST requests. It must use https protocol.
         * 
         * @return builder
         * 
         */
        public Builder uri(Output<String> uri) {
            $.uri = uri;
            return this;
        }

        /**
         * @param uri The webhook URI for receiving POST requests. It must use https protocol.
         * 
         * @return builder
         * 
         */
        public Builder uri(String uri) {
            return uri(Output.of(uri));
        }

        /**
         * @param webhookType Type of the webhook.
         * Possible values are: `STANDARD`, `FLEXIBLE`.
         * 
         * @return builder
         * 
         */
        public Builder webhookType(@Nullable Output<String> webhookType) {
            $.webhookType = webhookType;
            return this;
        }

        /**
         * @param webhookType Type of the webhook.
         * Possible values are: `STANDARD`, `FLEXIBLE`.
         * 
         * @return builder
         * 
         */
        public Builder webhookType(String webhookType) {
            return webhookType(Output.of(webhookType));
        }

        public CxWebhookGenericWebServiceArgs build() {
            if ($.uri == null) {
                throw new MissingRequiredPropertyException("CxWebhookGenericWebServiceArgs", "uri");
            }
            return $;
        }
    }

}
