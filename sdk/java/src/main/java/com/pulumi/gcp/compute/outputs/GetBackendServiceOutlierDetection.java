// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.compute.outputs.GetBackendServiceOutlierDetectionBaseEjectionTime;
import com.pulumi.gcp.compute.outputs.GetBackendServiceOutlierDetectionInterval;
import java.lang.Integer;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetBackendServiceOutlierDetection {
    /**
     * @return The base time that a host is ejected for. The real time is equal to the base
     * time multiplied by the number of times the host has been ejected. Defaults to
     * 30000ms or 30s.
     * 
     */
    private List<GetBackendServiceOutlierDetectionBaseEjectionTime> baseEjectionTimes;
    /**
     * @return Number of errors before a host is ejected from the connection pool. When the
     * backend host is accessed over HTTP, a 5xx return code qualifies as an error.
     * Defaults to 5.
     * 
     */
    private Integer consecutiveErrors;
    /**
     * @return The number of consecutive gateway failures (502, 503, 504 status or connection
     * errors that are mapped to one of those status codes) before a consecutive
     * gateway failure ejection occurs. Defaults to 5.
     * 
     */
    private Integer consecutiveGatewayFailure;
    /**
     * @return The percentage chance that a host will be actually ejected when an outlier
     * status is detected through consecutive 5xx. This setting can be used to disable
     * ejection or to ramp it up slowly. Defaults to 100.
     * 
     */
    private Integer enforcingConsecutiveErrors;
    /**
     * @return The percentage chance that a host will be actually ejected when an outlier
     * status is detected through consecutive gateway failures. This setting can be
     * used to disable ejection or to ramp it up slowly. Defaults to 0.
     * 
     */
    private Integer enforcingConsecutiveGatewayFailure;
    /**
     * @return The percentage chance that a host will be actually ejected when an outlier
     * status is detected through success rate statistics. This setting can be used to
     * disable ejection or to ramp it up slowly. Defaults to 100.
     * 
     */
    private Integer enforcingSuccessRate;
    /**
     * @return Time interval between ejection sweep analysis. This can result in both new
     * ejections as well as hosts being returned to service. Defaults to 10 seconds.
     * 
     */
    private List<GetBackendServiceOutlierDetectionInterval> intervals;
    /**
     * @return Maximum percentage of hosts in the load balancing pool for the backend service
     * that can be ejected. Defaults to 10%.
     * 
     */
    private Integer maxEjectionPercent;
    /**
     * @return The number of hosts in a cluster that must have enough request volume to detect
     * success rate outliers. If the number of hosts is less than this setting, outlier
     * detection via success rate statistics is not performed for any host in the
     * cluster. Defaults to 5.
     * 
     */
    private Integer successRateMinimumHosts;
    /**
     * @return The minimum number of total requests that must be collected in one interval (as
     * defined by the interval duration above) to include this host in success rate
     * based outlier detection. If the volume is lower than this setting, outlier
     * detection via success rate statistics is not performed for that host. Defaults
     * to 100.
     * 
     */
    private Integer successRateRequestVolume;
    /**
     * @return This factor is used to determine the ejection threshold for success rate outlier
     * ejection. The ejection threshold is the difference between the mean success
     * rate, and the product of this factor and the standard deviation of the mean
     * success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
     * by a thousand to get a double. That is, if the desired factor is 1.9, the
     * runtime value should be 1900. Defaults to 1900.
     * 
     */
    private Integer successRateStdevFactor;

    private GetBackendServiceOutlierDetection() {}
    /**
     * @return The base time that a host is ejected for. The real time is equal to the base
     * time multiplied by the number of times the host has been ejected. Defaults to
     * 30000ms or 30s.
     * 
     */
    public List<GetBackendServiceOutlierDetectionBaseEjectionTime> baseEjectionTimes() {
        return this.baseEjectionTimes;
    }
    /**
     * @return Number of errors before a host is ejected from the connection pool. When the
     * backend host is accessed over HTTP, a 5xx return code qualifies as an error.
     * Defaults to 5.
     * 
     */
    public Integer consecutiveErrors() {
        return this.consecutiveErrors;
    }
    /**
     * @return The number of consecutive gateway failures (502, 503, 504 status or connection
     * errors that are mapped to one of those status codes) before a consecutive
     * gateway failure ejection occurs. Defaults to 5.
     * 
     */
    public Integer consecutiveGatewayFailure() {
        return this.consecutiveGatewayFailure;
    }
    /**
     * @return The percentage chance that a host will be actually ejected when an outlier
     * status is detected through consecutive 5xx. This setting can be used to disable
     * ejection or to ramp it up slowly. Defaults to 100.
     * 
     */
    public Integer enforcingConsecutiveErrors() {
        return this.enforcingConsecutiveErrors;
    }
    /**
     * @return The percentage chance that a host will be actually ejected when an outlier
     * status is detected through consecutive gateway failures. This setting can be
     * used to disable ejection or to ramp it up slowly. Defaults to 0.
     * 
     */
    public Integer enforcingConsecutiveGatewayFailure() {
        return this.enforcingConsecutiveGatewayFailure;
    }
    /**
     * @return The percentage chance that a host will be actually ejected when an outlier
     * status is detected through success rate statistics. This setting can be used to
     * disable ejection or to ramp it up slowly. Defaults to 100.
     * 
     */
    public Integer enforcingSuccessRate() {
        return this.enforcingSuccessRate;
    }
    /**
     * @return Time interval between ejection sweep analysis. This can result in both new
     * ejections as well as hosts being returned to service. Defaults to 10 seconds.
     * 
     */
    public List<GetBackendServiceOutlierDetectionInterval> intervals() {
        return this.intervals;
    }
    /**
     * @return Maximum percentage of hosts in the load balancing pool for the backend service
     * that can be ejected. Defaults to 10%.
     * 
     */
    public Integer maxEjectionPercent() {
        return this.maxEjectionPercent;
    }
    /**
     * @return The number of hosts in a cluster that must have enough request volume to detect
     * success rate outliers. If the number of hosts is less than this setting, outlier
     * detection via success rate statistics is not performed for any host in the
     * cluster. Defaults to 5.
     * 
     */
    public Integer successRateMinimumHosts() {
        return this.successRateMinimumHosts;
    }
    /**
     * @return The minimum number of total requests that must be collected in one interval (as
     * defined by the interval duration above) to include this host in success rate
     * based outlier detection. If the volume is lower than this setting, outlier
     * detection via success rate statistics is not performed for that host. Defaults
     * to 100.
     * 
     */
    public Integer successRateRequestVolume() {
        return this.successRateRequestVolume;
    }
    /**
     * @return This factor is used to determine the ejection threshold for success rate outlier
     * ejection. The ejection threshold is the difference between the mean success
     * rate, and the product of this factor and the standard deviation of the mean
     * success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
     * by a thousand to get a double. That is, if the desired factor is 1.9, the
     * runtime value should be 1900. Defaults to 1900.
     * 
     */
    public Integer successRateStdevFactor() {
        return this.successRateStdevFactor;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetBackendServiceOutlierDetection defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private List<GetBackendServiceOutlierDetectionBaseEjectionTime> baseEjectionTimes;
        private Integer consecutiveErrors;
        private Integer consecutiveGatewayFailure;
        private Integer enforcingConsecutiveErrors;
        private Integer enforcingConsecutiveGatewayFailure;
        private Integer enforcingSuccessRate;
        private List<GetBackendServiceOutlierDetectionInterval> intervals;
        private Integer maxEjectionPercent;
        private Integer successRateMinimumHosts;
        private Integer successRateRequestVolume;
        private Integer successRateStdevFactor;
        public Builder() {}
        public Builder(GetBackendServiceOutlierDetection defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.baseEjectionTimes = defaults.baseEjectionTimes;
    	      this.consecutiveErrors = defaults.consecutiveErrors;
    	      this.consecutiveGatewayFailure = defaults.consecutiveGatewayFailure;
    	      this.enforcingConsecutiveErrors = defaults.enforcingConsecutiveErrors;
    	      this.enforcingConsecutiveGatewayFailure = defaults.enforcingConsecutiveGatewayFailure;
    	      this.enforcingSuccessRate = defaults.enforcingSuccessRate;
    	      this.intervals = defaults.intervals;
    	      this.maxEjectionPercent = defaults.maxEjectionPercent;
    	      this.successRateMinimumHosts = defaults.successRateMinimumHosts;
    	      this.successRateRequestVolume = defaults.successRateRequestVolume;
    	      this.successRateStdevFactor = defaults.successRateStdevFactor;
        }

        @CustomType.Setter
        public Builder baseEjectionTimes(List<GetBackendServiceOutlierDetectionBaseEjectionTime> baseEjectionTimes) {
            if (baseEjectionTimes == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceOutlierDetection", "baseEjectionTimes");
            }
            this.baseEjectionTimes = baseEjectionTimes;
            return this;
        }
        public Builder baseEjectionTimes(GetBackendServiceOutlierDetectionBaseEjectionTime... baseEjectionTimes) {
            return baseEjectionTimes(List.of(baseEjectionTimes));
        }
        @CustomType.Setter
        public Builder consecutiveErrors(Integer consecutiveErrors) {
            if (consecutiveErrors == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceOutlierDetection", "consecutiveErrors");
            }
            this.consecutiveErrors = consecutiveErrors;
            return this;
        }
        @CustomType.Setter
        public Builder consecutiveGatewayFailure(Integer consecutiveGatewayFailure) {
            if (consecutiveGatewayFailure == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceOutlierDetection", "consecutiveGatewayFailure");
            }
            this.consecutiveGatewayFailure = consecutiveGatewayFailure;
            return this;
        }
        @CustomType.Setter
        public Builder enforcingConsecutiveErrors(Integer enforcingConsecutiveErrors) {
            if (enforcingConsecutiveErrors == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceOutlierDetection", "enforcingConsecutiveErrors");
            }
            this.enforcingConsecutiveErrors = enforcingConsecutiveErrors;
            return this;
        }
        @CustomType.Setter
        public Builder enforcingConsecutiveGatewayFailure(Integer enforcingConsecutiveGatewayFailure) {
            if (enforcingConsecutiveGatewayFailure == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceOutlierDetection", "enforcingConsecutiveGatewayFailure");
            }
            this.enforcingConsecutiveGatewayFailure = enforcingConsecutiveGatewayFailure;
            return this;
        }
        @CustomType.Setter
        public Builder enforcingSuccessRate(Integer enforcingSuccessRate) {
            if (enforcingSuccessRate == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceOutlierDetection", "enforcingSuccessRate");
            }
            this.enforcingSuccessRate = enforcingSuccessRate;
            return this;
        }
        @CustomType.Setter
        public Builder intervals(List<GetBackendServiceOutlierDetectionInterval> intervals) {
            if (intervals == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceOutlierDetection", "intervals");
            }
            this.intervals = intervals;
            return this;
        }
        public Builder intervals(GetBackendServiceOutlierDetectionInterval... intervals) {
            return intervals(List.of(intervals));
        }
        @CustomType.Setter
        public Builder maxEjectionPercent(Integer maxEjectionPercent) {
            if (maxEjectionPercent == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceOutlierDetection", "maxEjectionPercent");
            }
            this.maxEjectionPercent = maxEjectionPercent;
            return this;
        }
        @CustomType.Setter
        public Builder successRateMinimumHosts(Integer successRateMinimumHosts) {
            if (successRateMinimumHosts == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceOutlierDetection", "successRateMinimumHosts");
            }
            this.successRateMinimumHosts = successRateMinimumHosts;
            return this;
        }
        @CustomType.Setter
        public Builder successRateRequestVolume(Integer successRateRequestVolume) {
            if (successRateRequestVolume == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceOutlierDetection", "successRateRequestVolume");
            }
            this.successRateRequestVolume = successRateRequestVolume;
            return this;
        }
        @CustomType.Setter
        public Builder successRateStdevFactor(Integer successRateStdevFactor) {
            if (successRateStdevFactor == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceOutlierDetection", "successRateStdevFactor");
            }
            this.successRateStdevFactor = successRateStdevFactor;
            return this;
        }
        public GetBackendServiceOutlierDetection build() {
            final var _resultValue = new GetBackendServiceOutlierDetection();
            _resultValue.baseEjectionTimes = baseEjectionTimes;
            _resultValue.consecutiveErrors = consecutiveErrors;
            _resultValue.consecutiveGatewayFailure = consecutiveGatewayFailure;
            _resultValue.enforcingConsecutiveErrors = enforcingConsecutiveErrors;
            _resultValue.enforcingConsecutiveGatewayFailure = enforcingConsecutiveGatewayFailure;
            _resultValue.enforcingSuccessRate = enforcingSuccessRate;
            _resultValue.intervals = intervals;
            _resultValue.maxEjectionPercent = maxEjectionPercent;
            _resultValue.successRateMinimumHosts = successRateMinimumHosts;
            _resultValue.successRateRequestVolume = successRateRequestVolume;
            _resultValue.successRateStdevFactor = successRateStdevFactor;
            return _resultValue;
        }
    }
}
