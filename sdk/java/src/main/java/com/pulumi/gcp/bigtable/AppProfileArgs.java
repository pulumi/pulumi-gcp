// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.bigtable;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.bigtable.inputs.AppProfileDataBoostIsolationReadOnlyArgs;
import com.pulumi.gcp.bigtable.inputs.AppProfileSingleClusterRoutingArgs;
import com.pulumi.gcp.bigtable.inputs.AppProfileStandardIsolationArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class AppProfileArgs extends com.pulumi.resources.ResourceArgs {

    public static final AppProfileArgs Empty = new AppProfileArgs();

    /**
     * The unique name of the app profile in the form `[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
     * 
     */
    @Import(name="appProfileId", required=true)
    private Output<String> appProfileId;

    /**
     * @return The unique name of the app profile in the form `[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
     * 
     */
    public Output<String> appProfileId() {
        return this.appProfileId;
    }

    /**
     * Specifies that this app profile is intended for read-only usage via the Data Boost feature.
     * Structure is documented below.
     * 
     */
    @Import(name="dataBoostIsolationReadOnly")
    private @Nullable Output<AppProfileDataBoostIsolationReadOnlyArgs> dataBoostIsolationReadOnly;

    /**
     * @return Specifies that this app profile is intended for read-only usage via the Data Boost feature.
     * Structure is documented below.
     * 
     */
    public Optional<Output<AppProfileDataBoostIsolationReadOnlyArgs>> dataBoostIsolationReadOnly() {
        return Optional.ofNullable(this.dataBoostIsolationReadOnly);
    }

    /**
     * Long form description of the use case for this app profile.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return Long form description of the use case for this app profile.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * If true, ignore safety checks when deleting/updating the app profile.
     * 
     */
    @Import(name="ignoreWarnings")
    private @Nullable Output<Boolean> ignoreWarnings;

    /**
     * @return If true, ignore safety checks when deleting/updating the app profile.
     * 
     */
    public Optional<Output<Boolean>> ignoreWarnings() {
        return Optional.ofNullable(this.ignoreWarnings);
    }

    /**
     * The name of the instance to create the app profile within.
     * 
     */
    @Import(name="instance")
    private @Nullable Output<String> instance;

    /**
     * @return The name of the instance to create the app profile within.
     * 
     */
    public Optional<Output<String>> instance() {
        return Optional.ofNullable(this.instance);
    }

    /**
     * The set of clusters to route to. The order is ignored; clusters will be tried in order of distance. If left empty, all clusters are eligible.
     * 
     */
    @Import(name="multiClusterRoutingClusterIds")
    private @Nullable Output<List<String>> multiClusterRoutingClusterIds;

    /**
     * @return The set of clusters to route to. The order is ignored; clusters will be tried in order of distance. If left empty, all clusters are eligible.
     * 
     */
    public Optional<Output<List<String>>> multiClusterRoutingClusterIds() {
        return Optional.ofNullable(this.multiClusterRoutingClusterIds);
    }

    /**
     * If true, read/write requests are routed to the nearest cluster in the instance, and will fail over to the nearest cluster that is available
     * in the event of transient errors or delays. Clusters in a region are considered equidistant. Choosing this option sacrifices read-your-writes
     * consistency to improve availability.
     * 
     */
    @Import(name="multiClusterRoutingUseAny")
    private @Nullable Output<Boolean> multiClusterRoutingUseAny;

    /**
     * @return If true, read/write requests are routed to the nearest cluster in the instance, and will fail over to the nearest cluster that is available
     * in the event of transient errors or delays. Clusters in a region are considered equidistant. Choosing this option sacrifices read-your-writes
     * consistency to improve availability.
     * 
     */
    public Optional<Output<Boolean>> multiClusterRoutingUseAny() {
        return Optional.ofNullable(this.multiClusterRoutingUseAny);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * Must be used with multi-cluster routing. If true, then this app profile will use row affinity sticky routing. With row affinity, Bigtable will route single row key requests based on the row key, rather than randomly. Instead, each row key will be assigned to a cluster by Cloud Bigtable, and will stick to that cluster. Choosing this option improves read-your-writes consistency for most requests under most circumstances, without sacrificing availability. Consistency is not guaranteed, as requests may still fail over between clusters in the event of errors or latency.
     * 
     */
    @Import(name="rowAffinity")
    private @Nullable Output<Boolean> rowAffinity;

    /**
     * @return Must be used with multi-cluster routing. If true, then this app profile will use row affinity sticky routing. With row affinity, Bigtable will route single row key requests based on the row key, rather than randomly. Instead, each row key will be assigned to a cluster by Cloud Bigtable, and will stick to that cluster. Choosing this option improves read-your-writes consistency for most requests under most circumstances, without sacrificing availability. Consistency is not guaranteed, as requests may still fail over between clusters in the event of errors or latency.
     * 
     */
    public Optional<Output<Boolean>> rowAffinity() {
        return Optional.ofNullable(this.rowAffinity);
    }

    /**
     * Use a single-cluster routing policy.
     * Structure is documented below.
     * 
     */
    @Import(name="singleClusterRouting")
    private @Nullable Output<AppProfileSingleClusterRoutingArgs> singleClusterRouting;

    /**
     * @return Use a single-cluster routing policy.
     * Structure is documented below.
     * 
     */
    public Optional<Output<AppProfileSingleClusterRoutingArgs>> singleClusterRouting() {
        return Optional.ofNullable(this.singleClusterRouting);
    }

    /**
     * The standard options used for isolating this app profile&#39;s traffic from other use cases.
     * Structure is documented below.
     * 
     */
    @Import(name="standardIsolation")
    private @Nullable Output<AppProfileStandardIsolationArgs> standardIsolation;

    /**
     * @return The standard options used for isolating this app profile&#39;s traffic from other use cases.
     * Structure is documented below.
     * 
     */
    public Optional<Output<AppProfileStandardIsolationArgs>> standardIsolation() {
        return Optional.ofNullable(this.standardIsolation);
    }

    private AppProfileArgs() {}

    private AppProfileArgs(AppProfileArgs $) {
        this.appProfileId = $.appProfileId;
        this.dataBoostIsolationReadOnly = $.dataBoostIsolationReadOnly;
        this.description = $.description;
        this.ignoreWarnings = $.ignoreWarnings;
        this.instance = $.instance;
        this.multiClusterRoutingClusterIds = $.multiClusterRoutingClusterIds;
        this.multiClusterRoutingUseAny = $.multiClusterRoutingUseAny;
        this.project = $.project;
        this.rowAffinity = $.rowAffinity;
        this.singleClusterRouting = $.singleClusterRouting;
        this.standardIsolation = $.standardIsolation;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(AppProfileArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private AppProfileArgs $;

        public Builder() {
            $ = new AppProfileArgs();
        }

        public Builder(AppProfileArgs defaults) {
            $ = new AppProfileArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param appProfileId The unique name of the app profile in the form `[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
         * 
         * @return builder
         * 
         */
        public Builder appProfileId(Output<String> appProfileId) {
            $.appProfileId = appProfileId;
            return this;
        }

        /**
         * @param appProfileId The unique name of the app profile in the form `[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
         * 
         * @return builder
         * 
         */
        public Builder appProfileId(String appProfileId) {
            return appProfileId(Output.of(appProfileId));
        }

        /**
         * @param dataBoostIsolationReadOnly Specifies that this app profile is intended for read-only usage via the Data Boost feature.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder dataBoostIsolationReadOnly(@Nullable Output<AppProfileDataBoostIsolationReadOnlyArgs> dataBoostIsolationReadOnly) {
            $.dataBoostIsolationReadOnly = dataBoostIsolationReadOnly;
            return this;
        }

        /**
         * @param dataBoostIsolationReadOnly Specifies that this app profile is intended for read-only usage via the Data Boost feature.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder dataBoostIsolationReadOnly(AppProfileDataBoostIsolationReadOnlyArgs dataBoostIsolationReadOnly) {
            return dataBoostIsolationReadOnly(Output.of(dataBoostIsolationReadOnly));
        }

        /**
         * @param description Long form description of the use case for this app profile.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description Long form description of the use case for this app profile.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param ignoreWarnings If true, ignore safety checks when deleting/updating the app profile.
         * 
         * @return builder
         * 
         */
        public Builder ignoreWarnings(@Nullable Output<Boolean> ignoreWarnings) {
            $.ignoreWarnings = ignoreWarnings;
            return this;
        }

        /**
         * @param ignoreWarnings If true, ignore safety checks when deleting/updating the app profile.
         * 
         * @return builder
         * 
         */
        public Builder ignoreWarnings(Boolean ignoreWarnings) {
            return ignoreWarnings(Output.of(ignoreWarnings));
        }

        /**
         * @param instance The name of the instance to create the app profile within.
         * 
         * @return builder
         * 
         */
        public Builder instance(@Nullable Output<String> instance) {
            $.instance = instance;
            return this;
        }

        /**
         * @param instance The name of the instance to create the app profile within.
         * 
         * @return builder
         * 
         */
        public Builder instance(String instance) {
            return instance(Output.of(instance));
        }

        /**
         * @param multiClusterRoutingClusterIds The set of clusters to route to. The order is ignored; clusters will be tried in order of distance. If left empty, all clusters are eligible.
         * 
         * @return builder
         * 
         */
        public Builder multiClusterRoutingClusterIds(@Nullable Output<List<String>> multiClusterRoutingClusterIds) {
            $.multiClusterRoutingClusterIds = multiClusterRoutingClusterIds;
            return this;
        }

        /**
         * @param multiClusterRoutingClusterIds The set of clusters to route to. The order is ignored; clusters will be tried in order of distance. If left empty, all clusters are eligible.
         * 
         * @return builder
         * 
         */
        public Builder multiClusterRoutingClusterIds(List<String> multiClusterRoutingClusterIds) {
            return multiClusterRoutingClusterIds(Output.of(multiClusterRoutingClusterIds));
        }

        /**
         * @param multiClusterRoutingClusterIds The set of clusters to route to. The order is ignored; clusters will be tried in order of distance. If left empty, all clusters are eligible.
         * 
         * @return builder
         * 
         */
        public Builder multiClusterRoutingClusterIds(String... multiClusterRoutingClusterIds) {
            return multiClusterRoutingClusterIds(List.of(multiClusterRoutingClusterIds));
        }

        /**
         * @param multiClusterRoutingUseAny If true, read/write requests are routed to the nearest cluster in the instance, and will fail over to the nearest cluster that is available
         * in the event of transient errors or delays. Clusters in a region are considered equidistant. Choosing this option sacrifices read-your-writes
         * consistency to improve availability.
         * 
         * @return builder
         * 
         */
        public Builder multiClusterRoutingUseAny(@Nullable Output<Boolean> multiClusterRoutingUseAny) {
            $.multiClusterRoutingUseAny = multiClusterRoutingUseAny;
            return this;
        }

        /**
         * @param multiClusterRoutingUseAny If true, read/write requests are routed to the nearest cluster in the instance, and will fail over to the nearest cluster that is available
         * in the event of transient errors or delays. Clusters in a region are considered equidistant. Choosing this option sacrifices read-your-writes
         * consistency to improve availability.
         * 
         * @return builder
         * 
         */
        public Builder multiClusterRoutingUseAny(Boolean multiClusterRoutingUseAny) {
            return multiClusterRoutingUseAny(Output.of(multiClusterRoutingUseAny));
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param rowAffinity Must be used with multi-cluster routing. If true, then this app profile will use row affinity sticky routing. With row affinity, Bigtable will route single row key requests based on the row key, rather than randomly. Instead, each row key will be assigned to a cluster by Cloud Bigtable, and will stick to that cluster. Choosing this option improves read-your-writes consistency for most requests under most circumstances, without sacrificing availability. Consistency is not guaranteed, as requests may still fail over between clusters in the event of errors or latency.
         * 
         * @return builder
         * 
         */
        public Builder rowAffinity(@Nullable Output<Boolean> rowAffinity) {
            $.rowAffinity = rowAffinity;
            return this;
        }

        /**
         * @param rowAffinity Must be used with multi-cluster routing. If true, then this app profile will use row affinity sticky routing. With row affinity, Bigtable will route single row key requests based on the row key, rather than randomly. Instead, each row key will be assigned to a cluster by Cloud Bigtable, and will stick to that cluster. Choosing this option improves read-your-writes consistency for most requests under most circumstances, without sacrificing availability. Consistency is not guaranteed, as requests may still fail over between clusters in the event of errors or latency.
         * 
         * @return builder
         * 
         */
        public Builder rowAffinity(Boolean rowAffinity) {
            return rowAffinity(Output.of(rowAffinity));
        }

        /**
         * @param singleClusterRouting Use a single-cluster routing policy.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder singleClusterRouting(@Nullable Output<AppProfileSingleClusterRoutingArgs> singleClusterRouting) {
            $.singleClusterRouting = singleClusterRouting;
            return this;
        }

        /**
         * @param singleClusterRouting Use a single-cluster routing policy.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder singleClusterRouting(AppProfileSingleClusterRoutingArgs singleClusterRouting) {
            return singleClusterRouting(Output.of(singleClusterRouting));
        }

        /**
         * @param standardIsolation The standard options used for isolating this app profile&#39;s traffic from other use cases.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder standardIsolation(@Nullable Output<AppProfileStandardIsolationArgs> standardIsolation) {
            $.standardIsolation = standardIsolation;
            return this;
        }

        /**
         * @param standardIsolation The standard options used for isolating this app profile&#39;s traffic from other use cases.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder standardIsolation(AppProfileStandardIsolationArgs standardIsolation) {
            return standardIsolation(Output.of(standardIsolation));
        }

        public AppProfileArgs build() {
            if ($.appProfileId == null) {
                throw new MissingRequiredPropertyException("AppProfileArgs", "appProfileId");
            }
            return $;
        }
    }

}
