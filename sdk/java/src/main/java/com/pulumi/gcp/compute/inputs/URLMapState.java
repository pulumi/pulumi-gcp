// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.compute.inputs.URLMapDefaultCustomErrorResponsePolicyArgs;
import com.pulumi.gcp.compute.inputs.URLMapDefaultRouteActionArgs;
import com.pulumi.gcp.compute.inputs.URLMapDefaultUrlRedirectArgs;
import com.pulumi.gcp.compute.inputs.URLMapHeaderActionArgs;
import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
import com.pulumi.gcp.compute.inputs.URLMapTestArgs;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class URLMapState extends com.pulumi.resources.ResourceArgs {

    public static final URLMapState Empty = new URLMapState();

    /**
     * Creation timestamp in RFC3339 text format.
     * 
     */
    @Import(name="creationTimestamp")
    private @Nullable Output<String> creationTimestamp;

    /**
     * @return Creation timestamp in RFC3339 text format.
     * 
     */
    public Optional<Output<String>> creationTimestamp() {
        return Optional.ofNullable(this.creationTimestamp);
    }

    /**
     * defaultCustomErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
     * This policy takes effect at the PathMatcher level and applies only when no policy has been defined for the error code at lower levels like RouteRule and PathRule within this PathMatcher. If an error code does not have a policy defined in defaultCustomErrorResponsePolicy, then a policy defined for the error code in UrlMap.defaultCustomErrorResponsePolicy takes effect.
     * For example, consider a UrlMap with the following configuration:
     * UrlMap.defaultCustomErrorResponsePolicy is configured with policies for 5xx and 4xx errors
     * A RouteRule for /coming_soon/ is configured for the error code 404.
     * If the request is for www.myotherdomain.com and a 404 is encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404 response is encountered for the request www.example.com/current_events/, the pathMatcher&#39;s policy takes effect. If however, the request for www.example.com/coming_soon/ encounters a 404, the policy in RouteRule.customErrorResponsePolicy takes effect. If any of the requests in this example encounter a 500 error code, the policy at UrlMap.defaultCustomErrorResponsePolicy takes effect.
     * When used in conjunction with pathMatcher.defaultRouteAction.retryPolicy, retries take precedence. Only once all retries are exhausted, the defaultCustomErrorResponsePolicy is applied. While attempting a retry, if load balancer is successful in reaching the service, the defaultCustomErrorResponsePolicy is ignored and the response from the service is returned to the client.
     * defaultCustomErrorResponsePolicy is supported only for global external Application Load Balancers.
     * Structure is documented below.
     * 
     */
    @Import(name="defaultCustomErrorResponsePolicy")
    private @Nullable Output<URLMapDefaultCustomErrorResponsePolicyArgs> defaultCustomErrorResponsePolicy;

    /**
     * @return defaultCustomErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
     * This policy takes effect at the PathMatcher level and applies only when no policy has been defined for the error code at lower levels like RouteRule and PathRule within this PathMatcher. If an error code does not have a policy defined in defaultCustomErrorResponsePolicy, then a policy defined for the error code in UrlMap.defaultCustomErrorResponsePolicy takes effect.
     * For example, consider a UrlMap with the following configuration:
     * UrlMap.defaultCustomErrorResponsePolicy is configured with policies for 5xx and 4xx errors
     * A RouteRule for /coming_soon/ is configured for the error code 404.
     * If the request is for www.myotherdomain.com and a 404 is encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404 response is encountered for the request www.example.com/current_events/, the pathMatcher&#39;s policy takes effect. If however, the request for www.example.com/coming_soon/ encounters a 404, the policy in RouteRule.customErrorResponsePolicy takes effect. If any of the requests in this example encounter a 500 error code, the policy at UrlMap.defaultCustomErrorResponsePolicy takes effect.
     * When used in conjunction with pathMatcher.defaultRouteAction.retryPolicy, retries take precedence. Only once all retries are exhausted, the defaultCustomErrorResponsePolicy is applied. While attempting a retry, if load balancer is successful in reaching the service, the defaultCustomErrorResponsePolicy is ignored and the response from the service is returned to the client.
     * defaultCustomErrorResponsePolicy is supported only for global external Application Load Balancers.
     * Structure is documented below.
     * 
     */
    public Optional<Output<URLMapDefaultCustomErrorResponsePolicyArgs>> defaultCustomErrorResponsePolicy() {
        return Optional.ofNullable(this.defaultCustomErrorResponsePolicy);
    }

    /**
     * defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
     * like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
     * If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
     * is set, defaultRouteAction cannot contain any weightedBackendServices.
     * Only one of defaultRouteAction or defaultUrlRedirect must be set.
     * Structure is documented below.
     * 
     */
    @Import(name="defaultRouteAction")
    private @Nullable Output<URLMapDefaultRouteActionArgs> defaultRouteAction;

    /**
     * @return defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
     * like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
     * If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
     * is set, defaultRouteAction cannot contain any weightedBackendServices.
     * Only one of defaultRouteAction or defaultUrlRedirect must be set.
     * Structure is documented below.
     * 
     */
    public Optional<Output<URLMapDefaultRouteActionArgs>> defaultRouteAction() {
        return Optional.ofNullable(this.defaultRouteAction);
    }

    /**
     * The backend service or backend bucket to use when none of the given rules match.
     * 
     */
    @Import(name="defaultService")
    private @Nullable Output<String> defaultService;

    /**
     * @return The backend service or backend bucket to use when none of the given rules match.
     * 
     */
    public Optional<Output<String>> defaultService() {
        return Optional.ofNullable(this.defaultService);
    }

    /**
     * When none of the specified hostRules match, the request is redirected to a URL specified
     * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
     * defaultRouteAction must not be set.
     * Structure is documented below.
     * 
     */
    @Import(name="defaultUrlRedirect")
    private @Nullable Output<URLMapDefaultUrlRedirectArgs> defaultUrlRedirect;

    /**
     * @return When none of the specified hostRules match, the request is redirected to a URL specified
     * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
     * defaultRouteAction must not be set.
     * Structure is documented below.
     * 
     */
    public Optional<Output<URLMapDefaultUrlRedirectArgs>> defaultUrlRedirect() {
        return Optional.ofNullable(this.defaultUrlRedirect);
    }

    /**
     * An optional description of this resource. Provide this property when you create
     * the resource.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return An optional description of this resource. Provide this property when you create
     * the resource.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Fingerprint of this resource. A hash of the contents stored in this object. This
     * field is used in optimistic locking.
     * 
     */
    @Import(name="fingerprint")
    private @Nullable Output<String> fingerprint;

    /**
     * @return Fingerprint of this resource. A hash of the contents stored in this object. This
     * field is used in optimistic locking.
     * 
     */
    public Optional<Output<String>> fingerprint() {
        return Optional.ofNullable(this.fingerprint);
    }

    /**
     * Specifies changes to request and response headers that need to take effect for
     * the selected backendService. The headerAction specified here take effect after
     * headerAction specified under pathMatcher.
     * Structure is documented below.
     * 
     */
    @Import(name="headerAction")
    private @Nullable Output<URLMapHeaderActionArgs> headerAction;

    /**
     * @return Specifies changes to request and response headers that need to take effect for
     * the selected backendService. The headerAction specified here take effect after
     * headerAction specified under pathMatcher.
     * Structure is documented below.
     * 
     */
    public Optional<Output<URLMapHeaderActionArgs>> headerAction() {
        return Optional.ofNullable(this.headerAction);
    }

    /**
     * The list of HostRules to use against the URL.
     * Structure is documented below.
     * 
     */
    @Import(name="hostRules")
    private @Nullable Output<List<URLMapHostRuleArgs>> hostRules;

    /**
     * @return The list of HostRules to use against the URL.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<URLMapHostRuleArgs>>> hostRules() {
        return Optional.ofNullable(this.hostRules);
    }

    /**
     * The unique identifier for the resource.
     * 
     */
    @Import(name="mapId")
    private @Nullable Output<Integer> mapId;

    /**
     * @return The unique identifier for the resource.
     * 
     */
    public Optional<Output<Integer>> mapId() {
        return Optional.ofNullable(this.mapId);
    }

    /**
     * Name of the resource. Provided by the client when the resource is created. The
     * name must be 1-63 characters long, and comply with RFC1035. Specifically, the
     * name must be 1-63 characters long and match the regular expression
     * `a-z?` which means the first character must be a lowercase
     * letter, and all following characters must be a dash, lowercase letter, or digit,
     * except the last character, which cannot be a dash.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return Name of the resource. Provided by the client when the resource is created. The
     * name must be 1-63 characters long, and comply with RFC1035. Specifically, the
     * name must be 1-63 characters long and match the regular expression
     * `a-z?` which means the first character must be a lowercase
     * letter, and all following characters must be a dash, lowercase letter, or digit,
     * except the last character, which cannot be a dash.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The list of named PathMatchers to use against the URL.
     * Structure is documented below.
     * 
     */
    @Import(name="pathMatchers")
    private @Nullable Output<List<URLMapPathMatcherArgs>> pathMatchers;

    /**
     * @return The list of named PathMatchers to use against the URL.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<URLMapPathMatcherArgs>>> pathMatchers() {
        return Optional.ofNullable(this.pathMatchers);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * The URI of the created resource.
     * 
     */
    @Import(name="selfLink")
    private @Nullable Output<String> selfLink;

    /**
     * @return The URI of the created resource.
     * 
     */
    public Optional<Output<String>> selfLink() {
        return Optional.ofNullable(this.selfLink);
    }

    /**
     * The list of expected URL mapping tests. Request to update this UrlMap will
     * succeed only if all of the test cases pass. You can specify a maximum of 100
     * tests per UrlMap.
     * Structure is documented below.
     * 
     */
    @Import(name="tests")
    private @Nullable Output<List<URLMapTestArgs>> tests;

    /**
     * @return The list of expected URL mapping tests. Request to update this UrlMap will
     * succeed only if all of the test cases pass. You can specify a maximum of 100
     * tests per UrlMap.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<URLMapTestArgs>>> tests() {
        return Optional.ofNullable(this.tests);
    }

    private URLMapState() {}

    private URLMapState(URLMapState $) {
        this.creationTimestamp = $.creationTimestamp;
        this.defaultCustomErrorResponsePolicy = $.defaultCustomErrorResponsePolicy;
        this.defaultRouteAction = $.defaultRouteAction;
        this.defaultService = $.defaultService;
        this.defaultUrlRedirect = $.defaultUrlRedirect;
        this.description = $.description;
        this.fingerprint = $.fingerprint;
        this.headerAction = $.headerAction;
        this.hostRules = $.hostRules;
        this.mapId = $.mapId;
        this.name = $.name;
        this.pathMatchers = $.pathMatchers;
        this.project = $.project;
        this.selfLink = $.selfLink;
        this.tests = $.tests;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(URLMapState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private URLMapState $;

        public Builder() {
            $ = new URLMapState();
        }

        public Builder(URLMapState defaults) {
            $ = new URLMapState(Objects.requireNonNull(defaults));
        }

        /**
         * @param creationTimestamp Creation timestamp in RFC3339 text format.
         * 
         * @return builder
         * 
         */
        public Builder creationTimestamp(@Nullable Output<String> creationTimestamp) {
            $.creationTimestamp = creationTimestamp;
            return this;
        }

        /**
         * @param creationTimestamp Creation timestamp in RFC3339 text format.
         * 
         * @return builder
         * 
         */
        public Builder creationTimestamp(String creationTimestamp) {
            return creationTimestamp(Output.of(creationTimestamp));
        }

        /**
         * @param defaultCustomErrorResponsePolicy defaultCustomErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
         * This policy takes effect at the PathMatcher level and applies only when no policy has been defined for the error code at lower levels like RouteRule and PathRule within this PathMatcher. If an error code does not have a policy defined in defaultCustomErrorResponsePolicy, then a policy defined for the error code in UrlMap.defaultCustomErrorResponsePolicy takes effect.
         * For example, consider a UrlMap with the following configuration:
         * UrlMap.defaultCustomErrorResponsePolicy is configured with policies for 5xx and 4xx errors
         * A RouteRule for /coming_soon/ is configured for the error code 404.
         * If the request is for www.myotherdomain.com and a 404 is encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404 response is encountered for the request www.example.com/current_events/, the pathMatcher&#39;s policy takes effect. If however, the request for www.example.com/coming_soon/ encounters a 404, the policy in RouteRule.customErrorResponsePolicy takes effect. If any of the requests in this example encounter a 500 error code, the policy at UrlMap.defaultCustomErrorResponsePolicy takes effect.
         * When used in conjunction with pathMatcher.defaultRouteAction.retryPolicy, retries take precedence. Only once all retries are exhausted, the defaultCustomErrorResponsePolicy is applied. While attempting a retry, if load balancer is successful in reaching the service, the defaultCustomErrorResponsePolicy is ignored and the response from the service is returned to the client.
         * defaultCustomErrorResponsePolicy is supported only for global external Application Load Balancers.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder defaultCustomErrorResponsePolicy(@Nullable Output<URLMapDefaultCustomErrorResponsePolicyArgs> defaultCustomErrorResponsePolicy) {
            $.defaultCustomErrorResponsePolicy = defaultCustomErrorResponsePolicy;
            return this;
        }

        /**
         * @param defaultCustomErrorResponsePolicy defaultCustomErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
         * This policy takes effect at the PathMatcher level and applies only when no policy has been defined for the error code at lower levels like RouteRule and PathRule within this PathMatcher. If an error code does not have a policy defined in defaultCustomErrorResponsePolicy, then a policy defined for the error code in UrlMap.defaultCustomErrorResponsePolicy takes effect.
         * For example, consider a UrlMap with the following configuration:
         * UrlMap.defaultCustomErrorResponsePolicy is configured with policies for 5xx and 4xx errors
         * A RouteRule for /coming_soon/ is configured for the error code 404.
         * If the request is for www.myotherdomain.com and a 404 is encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404 response is encountered for the request www.example.com/current_events/, the pathMatcher&#39;s policy takes effect. If however, the request for www.example.com/coming_soon/ encounters a 404, the policy in RouteRule.customErrorResponsePolicy takes effect. If any of the requests in this example encounter a 500 error code, the policy at UrlMap.defaultCustomErrorResponsePolicy takes effect.
         * When used in conjunction with pathMatcher.defaultRouteAction.retryPolicy, retries take precedence. Only once all retries are exhausted, the defaultCustomErrorResponsePolicy is applied. While attempting a retry, if load balancer is successful in reaching the service, the defaultCustomErrorResponsePolicy is ignored and the response from the service is returned to the client.
         * defaultCustomErrorResponsePolicy is supported only for global external Application Load Balancers.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder defaultCustomErrorResponsePolicy(URLMapDefaultCustomErrorResponsePolicyArgs defaultCustomErrorResponsePolicy) {
            return defaultCustomErrorResponsePolicy(Output.of(defaultCustomErrorResponsePolicy));
        }

        /**
         * @param defaultRouteAction defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
         * like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
         * If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
         * is set, defaultRouteAction cannot contain any weightedBackendServices.
         * Only one of defaultRouteAction or defaultUrlRedirect must be set.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder defaultRouteAction(@Nullable Output<URLMapDefaultRouteActionArgs> defaultRouteAction) {
            $.defaultRouteAction = defaultRouteAction;
            return this;
        }

        /**
         * @param defaultRouteAction defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
         * like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
         * If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
         * is set, defaultRouteAction cannot contain any weightedBackendServices.
         * Only one of defaultRouteAction or defaultUrlRedirect must be set.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder defaultRouteAction(URLMapDefaultRouteActionArgs defaultRouteAction) {
            return defaultRouteAction(Output.of(defaultRouteAction));
        }

        /**
         * @param defaultService The backend service or backend bucket to use when none of the given rules match.
         * 
         * @return builder
         * 
         */
        public Builder defaultService(@Nullable Output<String> defaultService) {
            $.defaultService = defaultService;
            return this;
        }

        /**
         * @param defaultService The backend service or backend bucket to use when none of the given rules match.
         * 
         * @return builder
         * 
         */
        public Builder defaultService(String defaultService) {
            return defaultService(Output.of(defaultService));
        }

        /**
         * @param defaultUrlRedirect When none of the specified hostRules match, the request is redirected to a URL specified
         * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
         * defaultRouteAction must not be set.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder defaultUrlRedirect(@Nullable Output<URLMapDefaultUrlRedirectArgs> defaultUrlRedirect) {
            $.defaultUrlRedirect = defaultUrlRedirect;
            return this;
        }

        /**
         * @param defaultUrlRedirect When none of the specified hostRules match, the request is redirected to a URL specified
         * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
         * defaultRouteAction must not be set.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder defaultUrlRedirect(URLMapDefaultUrlRedirectArgs defaultUrlRedirect) {
            return defaultUrlRedirect(Output.of(defaultUrlRedirect));
        }

        /**
         * @param description An optional description of this resource. Provide this property when you create
         * the resource.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description An optional description of this resource. Provide this property when you create
         * the resource.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param fingerprint Fingerprint of this resource. A hash of the contents stored in this object. This
         * field is used in optimistic locking.
         * 
         * @return builder
         * 
         */
        public Builder fingerprint(@Nullable Output<String> fingerprint) {
            $.fingerprint = fingerprint;
            return this;
        }

        /**
         * @param fingerprint Fingerprint of this resource. A hash of the contents stored in this object. This
         * field is used in optimistic locking.
         * 
         * @return builder
         * 
         */
        public Builder fingerprint(String fingerprint) {
            return fingerprint(Output.of(fingerprint));
        }

        /**
         * @param headerAction Specifies changes to request and response headers that need to take effect for
         * the selected backendService. The headerAction specified here take effect after
         * headerAction specified under pathMatcher.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder headerAction(@Nullable Output<URLMapHeaderActionArgs> headerAction) {
            $.headerAction = headerAction;
            return this;
        }

        /**
         * @param headerAction Specifies changes to request and response headers that need to take effect for
         * the selected backendService. The headerAction specified here take effect after
         * headerAction specified under pathMatcher.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder headerAction(URLMapHeaderActionArgs headerAction) {
            return headerAction(Output.of(headerAction));
        }

        /**
         * @param hostRules The list of HostRules to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder hostRules(@Nullable Output<List<URLMapHostRuleArgs>> hostRules) {
            $.hostRules = hostRules;
            return this;
        }

        /**
         * @param hostRules The list of HostRules to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder hostRules(List<URLMapHostRuleArgs> hostRules) {
            return hostRules(Output.of(hostRules));
        }

        /**
         * @param hostRules The list of HostRules to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder hostRules(URLMapHostRuleArgs... hostRules) {
            return hostRules(List.of(hostRules));
        }

        /**
         * @param mapId The unique identifier for the resource.
         * 
         * @return builder
         * 
         */
        public Builder mapId(@Nullable Output<Integer> mapId) {
            $.mapId = mapId;
            return this;
        }

        /**
         * @param mapId The unique identifier for the resource.
         * 
         * @return builder
         * 
         */
        public Builder mapId(Integer mapId) {
            return mapId(Output.of(mapId));
        }

        /**
         * @param name Name of the resource. Provided by the client when the resource is created. The
         * name must be 1-63 characters long, and comply with RFC1035. Specifically, the
         * name must be 1-63 characters long and match the regular expression
         * `a-z?` which means the first character must be a lowercase
         * letter, and all following characters must be a dash, lowercase letter, or digit,
         * except the last character, which cannot be a dash.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name Name of the resource. Provided by the client when the resource is created. The
         * name must be 1-63 characters long, and comply with RFC1035. Specifically, the
         * name must be 1-63 characters long and match the regular expression
         * `a-z?` which means the first character must be a lowercase
         * letter, and all following characters must be a dash, lowercase letter, or digit,
         * except the last character, which cannot be a dash.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param pathMatchers The list of named PathMatchers to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder pathMatchers(@Nullable Output<List<URLMapPathMatcherArgs>> pathMatchers) {
            $.pathMatchers = pathMatchers;
            return this;
        }

        /**
         * @param pathMatchers The list of named PathMatchers to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder pathMatchers(List<URLMapPathMatcherArgs> pathMatchers) {
            return pathMatchers(Output.of(pathMatchers));
        }

        /**
         * @param pathMatchers The list of named PathMatchers to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder pathMatchers(URLMapPathMatcherArgs... pathMatchers) {
            return pathMatchers(List.of(pathMatchers));
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param selfLink The URI of the created resource.
         * 
         * @return builder
         * 
         */
        public Builder selfLink(@Nullable Output<String> selfLink) {
            $.selfLink = selfLink;
            return this;
        }

        /**
         * @param selfLink The URI of the created resource.
         * 
         * @return builder
         * 
         */
        public Builder selfLink(String selfLink) {
            return selfLink(Output.of(selfLink));
        }

        /**
         * @param tests The list of expected URL mapping tests. Request to update this UrlMap will
         * succeed only if all of the test cases pass. You can specify a maximum of 100
         * tests per UrlMap.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder tests(@Nullable Output<List<URLMapTestArgs>> tests) {
            $.tests = tests;
            return this;
        }

        /**
         * @param tests The list of expected URL mapping tests. Request to update this UrlMap will
         * succeed only if all of the test cases pass. You can specify a maximum of 100
         * tests per UrlMap.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder tests(List<URLMapTestArgs> tests) {
            return tests(Output.of(tests));
        }

        /**
         * @param tests The list of expected URL mapping tests. Request to update this UrlMap will
         * succeed only if all of the test cases pass. You can specify a maximum of 100
         * tests per UrlMap.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder tests(URLMapTestArgs... tests) {
            return tests(List.of(tests));
        }

        public URLMapState build() {
            return $;
        }
    }

}
