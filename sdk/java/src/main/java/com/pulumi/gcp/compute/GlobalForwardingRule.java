// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.compute.GlobalForwardingRuleArgs;
import com.pulumi.gcp.compute.inputs.GlobalForwardingRuleState;
import com.pulumi.gcp.compute.outputs.GlobalForwardingRuleMetadataFilter;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Represents a GlobalForwardingRule resource. Global forwarding rules are
 * used to forward traffic to the correct load balancer for HTTP load
 * balancing. Global forwarding rules can only be used for HTTP load
 * balancing.
 * 
 * For more information, see
 * https://cloud.google.com/compute/docs/load-balancing/http/
 * 
 * ## Example Usage
 * ### External Ssl Proxy Lb Mig Backend
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.Network;
 * import com.pulumi.gcp.compute.NetworkArgs;
 * import com.pulumi.gcp.compute.Subnetwork;
 * import com.pulumi.gcp.compute.SubnetworkArgs;
 * import com.pulumi.gcp.compute.GlobalAddress;
 * import com.pulumi.tls.PrivateKey;
 * import com.pulumi.tls.PrivateKeyArgs;
 * import com.pulumi.tls.SelfSignedCert;
 * import com.pulumi.tls.SelfSignedCertArgs;
 * import com.pulumi.tls.inputs.SelfSignedCertSubjectArgs;
 * import com.pulumi.gcp.compute.SSLCertificate;
 * import com.pulumi.gcp.compute.SSLCertificateArgs;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckTcpHealthCheckArgs;
 * import com.pulumi.gcp.compute.InstanceTemplate;
 * import com.pulumi.gcp.compute.InstanceTemplateArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceTemplateNetworkInterfaceArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceTemplateDiskArgs;
 * import com.pulumi.gcp.compute.InstanceGroupManager;
 * import com.pulumi.gcp.compute.InstanceGroupManagerArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceGroupManagerNamedPortArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceGroupManagerVersionArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceBackendArgs;
 * import com.pulumi.gcp.compute.TargetSSLProxy;
 * import com.pulumi.gcp.compute.TargetSSLProxyArgs;
 * import com.pulumi.gcp.compute.GlobalForwardingRule;
 * import com.pulumi.gcp.compute.GlobalForwardingRuleArgs;
 * import com.pulumi.gcp.compute.Firewall;
 * import com.pulumi.gcp.compute.FirewallArgs;
 * import com.pulumi.gcp.compute.inputs.FirewallAllowArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var defaultNetwork = new Network(&#34;defaultNetwork&#34;, NetworkArgs.builder()        
 *             .autoCreateSubnetworks(false)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google)
 *                 .build());
 * 
 *         var defaultSubnetwork = new Subnetwork(&#34;defaultSubnetwork&#34;, SubnetworkArgs.builder()        
 *             .ipCidrRange(&#34;10.0.1.0/24&#34;)
 *             .region(&#34;us-central1&#34;)
 *             .network(defaultNetwork.id())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google)
 *                 .build());
 * 
 *         var defaultGlobalAddress = new GlobalAddress(&#34;defaultGlobalAddress&#34;);
 * 
 *         var defaultPrivateKey = new PrivateKey(&#34;defaultPrivateKey&#34;, PrivateKeyArgs.builder()        
 *             .algorithm(&#34;RSA&#34;)
 *             .rsaBits(2048)
 *             .build());
 * 
 *         var defaultSelfSignedCert = new SelfSignedCert(&#34;defaultSelfSignedCert&#34;, SelfSignedCertArgs.builder()        
 *             .keyAlgorithm(defaultPrivateKey.algorithm())
 *             .privateKeyPem(defaultPrivateKey.privateKeyPem())
 *             .validityPeriodHours(12)
 *             .earlyRenewalHours(3)
 *             .allowedUses(            
 *                 &#34;key_encipherment&#34;,
 *                 &#34;digital_signature&#34;,
 *                 &#34;server_auth&#34;)
 *             .dnsNames(&#34;example.com&#34;)
 *             .subject(SelfSignedCertSubjectArgs.builder()
 *                 .commonName(&#34;example.com&#34;)
 *                 .organization(&#34;ACME Examples, Inc&#34;)
 *                 .build())
 *             .build());
 * 
 *         var defaultSSLCertificate = new SSLCertificate(&#34;defaultSSLCertificate&#34;, SSLCertificateArgs.builder()        
 *             .privateKey(defaultPrivateKey.privateKeyPem())
 *             .certificate(defaultSelfSignedCert.certPem())
 *             .build());
 * 
 *         var defaultHealthCheck = new HealthCheck(&#34;defaultHealthCheck&#34;, HealthCheckArgs.builder()        
 *             .timeoutSec(1)
 *             .checkIntervalSec(1)
 *             .tcpHealthCheck(HealthCheckTcpHealthCheckArgs.builder()
 *                 .port(&#34;443&#34;)
 *                 .build())
 *             .build());
 * 
 *         var defaultInstanceTemplate = new InstanceTemplate(&#34;defaultInstanceTemplate&#34;, InstanceTemplateArgs.builder()        
 *             .machineType(&#34;e2-small&#34;)
 *             .tags(&#34;allow-health-check&#34;)
 *             .networkInterfaces(InstanceTemplateNetworkInterfaceArgs.builder()
 *                 .network(defaultNetwork.id())
 *                 .subnetwork(defaultSubnetwork.id())
 *                 .accessConfigs()
 *                 .build())
 *             .disks(InstanceTemplateDiskArgs.builder()
 *                 .sourceImage(&#34;debian-cloud/debian-10&#34;)
 *                 .autoDelete(true)
 *                 .boot(true)
 *                 .build())
 *             .metadata(Map.of(&#34;startup-script&#34;, &#34;&#34;&#34;
 * #! /bin/bash
 * set -euo pipefail
 * export DEBIAN_FRONTEND=noninteractive
 * sudo apt-get update
 * sudo apt-get install  -y apache2 jq
 * sudo a2ensite default-ssl
 * sudo a2enmod ssl
 * sudo service apache2 restart
 * NAME=$(curl -H &#34;Metadata-Flavor: Google&#34; &#34;http://metadata.google.internal/computeMetadata/v1/instance/hostname&#34;)
 * IP=$(curl -H &#34;Metadata-Flavor: Google&#34; &#34;http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/ip&#34;)
 * METADATA=$(curl -f -H &#34;Metadata-Flavor: Google&#34; &#34;http://metadata.google.internal/computeMetadata/v1/instance/attributes/?recursive=True&#34; | jq &#39;del(.[&#34;startup-script&#34;])&#39;)
 * cat &lt;&lt;EOF &gt; /var/www/html/index.html
 * &lt;h1&gt;SSL Load Balancer&lt;/h1&gt;
 * &lt;pre&gt;
 * Name: $NAME
 * IP: $IP
 * Metadata: $METADATA
 * &lt;/pre&gt;
 * EOF
 *             &#34;&#34;&#34;))
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google)
 *                 .build());
 * 
 *         var defaultInstanceGroupManager = new InstanceGroupManager(&#34;defaultInstanceGroupManager&#34;, InstanceGroupManagerArgs.builder()        
 *             .zone(&#34;us-central1-c&#34;)
 *             .namedPorts(InstanceGroupManagerNamedPortArgs.builder()
 *                 .name(&#34;tcp&#34;)
 *                 .port(443)
 *                 .build())
 *             .versions(InstanceGroupManagerVersionArgs.builder()
 *                 .instanceTemplate(defaultInstanceTemplate.id())
 *                 .name(&#34;primary&#34;)
 *                 .build())
 *             .baseInstanceName(&#34;vm&#34;)
 *             .targetSize(2)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google)
 *                 .build());
 * 
 *         var defaultBackendService = new BackendService(&#34;defaultBackendService&#34;, BackendServiceArgs.builder()        
 *             .protocol(&#34;SSL&#34;)
 *             .portName(&#34;tcp&#34;)
 *             .loadBalancingScheme(&#34;EXTERNAL&#34;)
 *             .timeoutSec(10)
 *             .healthChecks(defaultHealthCheck.id())
 *             .backends(BackendServiceBackendArgs.builder()
 *                 .group(defaultInstanceGroupManager.instanceGroup())
 *                 .balancingMode(&#34;UTILIZATION&#34;)
 *                 .maxUtilization(1)
 *                 .capacityScaler(1)
 *                 .build())
 *             .build());
 * 
 *         var defaultTargetSSLProxy = new TargetSSLProxy(&#34;defaultTargetSSLProxy&#34;, TargetSSLProxyArgs.builder()        
 *             .backendService(defaultBackendService.id())
 *             .sslCertificates(defaultSSLCertificate.id())
 *             .build());
 * 
 *         var defaultGlobalForwardingRule = new GlobalForwardingRule(&#34;defaultGlobalForwardingRule&#34;, GlobalForwardingRuleArgs.builder()        
 *             .ipProtocol(&#34;TCP&#34;)
 *             .loadBalancingScheme(&#34;EXTERNAL&#34;)
 *             .portRange(&#34;443&#34;)
 *             .target(defaultTargetSSLProxy.id())
 *             .ipAddress(defaultGlobalAddress.id())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google)
 *                 .build());
 * 
 *         var defaultFirewall = new Firewall(&#34;defaultFirewall&#34;, FirewallArgs.builder()        
 *             .direction(&#34;INGRESS&#34;)
 *             .network(defaultNetwork.id())
 *             .sourceRanges(            
 *                 &#34;130.211.0.0/22&#34;,
 *                 &#34;35.191.0.0/16&#34;)
 *             .allows(FirewallAllowArgs.builder()
 *                 .protocol(&#34;tcp&#34;)
 *                 .build())
 *             .targetTags(&#34;allow-health-check&#34;)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google)
 *                 .build());
 * 
 *     }
 * }
 * ```
 * ### External Tcp Proxy Lb Mig Backend
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.Network;
 * import com.pulumi.gcp.compute.NetworkArgs;
 * import com.pulumi.gcp.compute.Subnetwork;
 * import com.pulumi.gcp.compute.SubnetworkArgs;
 * import com.pulumi.gcp.compute.GlobalAddress;
 * import com.pulumi.gcp.compute.GlobalAddressArgs;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckTcpHealthCheckArgs;
 * import com.pulumi.gcp.compute.InstanceTemplate;
 * import com.pulumi.gcp.compute.InstanceTemplateArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceTemplateNetworkInterfaceArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceTemplateDiskArgs;
 * import com.pulumi.gcp.compute.InstanceGroupManager;
 * import com.pulumi.gcp.compute.InstanceGroupManagerArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceGroupManagerNamedPortArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceGroupManagerVersionArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceBackendArgs;
 * import com.pulumi.gcp.compute.TargetTCPProxy;
 * import com.pulumi.gcp.compute.TargetTCPProxyArgs;
 * import com.pulumi.gcp.compute.GlobalForwardingRule;
 * import com.pulumi.gcp.compute.GlobalForwardingRuleArgs;
 * import com.pulumi.gcp.compute.Firewall;
 * import com.pulumi.gcp.compute.FirewallArgs;
 * import com.pulumi.gcp.compute.inputs.FirewallAllowArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var defaultNetwork = new Network(&#34;defaultNetwork&#34;, NetworkArgs.builder()        
 *             .autoCreateSubnetworks(false)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultSubnetwork = new Subnetwork(&#34;defaultSubnetwork&#34;, SubnetworkArgs.builder()        
 *             .ipCidrRange(&#34;10.0.1.0/24&#34;)
 *             .region(&#34;us-central1&#34;)
 *             .network(defaultNetwork.id())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultGlobalAddress = new GlobalAddress(&#34;defaultGlobalAddress&#34;, GlobalAddressArgs.Empty, CustomResourceOptions.builder()
 *             .provider(google_beta)
 *             .build());
 * 
 *         var defaultHealthCheck = new HealthCheck(&#34;defaultHealthCheck&#34;, HealthCheckArgs.builder()        
 *             .timeoutSec(1)
 *             .checkIntervalSec(1)
 *             .tcpHealthCheck(HealthCheckTcpHealthCheckArgs.builder()
 *                 .port(&#34;80&#34;)
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultInstanceTemplate = new InstanceTemplate(&#34;defaultInstanceTemplate&#34;, InstanceTemplateArgs.builder()        
 *             .machineType(&#34;e2-small&#34;)
 *             .tags(&#34;allow-health-check&#34;)
 *             .networkInterfaces(InstanceTemplateNetworkInterfaceArgs.builder()
 *                 .network(defaultNetwork.id())
 *                 .subnetwork(defaultSubnetwork.id())
 *                 .accessConfigs()
 *                 .build())
 *             .disks(InstanceTemplateDiskArgs.builder()
 *                 .sourceImage(&#34;debian-cloud/debian-10&#34;)
 *                 .autoDelete(true)
 *                 .boot(true)
 *                 .build())
 *             .metadata(Map.of(&#34;startup-script&#34;, &#34;&#34;&#34;
 * #! /bin/bash
 * set -euo pipefail
 * export DEBIAN_FRONTEND=noninteractive
 * apt-get update
 * apt-get install -y nginx-light jq
 * NAME=$(curl -H &#34;Metadata-Flavor: Google&#34; &#34;http://metadata.google.internal/computeMetadata/v1/instance/hostname&#34;)
 * IP=$(curl -H &#34;Metadata-Flavor: Google&#34; &#34;http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/ip&#34;)
 * METADATA=$(curl -f -H &#34;Metadata-Flavor: Google&#34; &#34;http://metadata.google.internal/computeMetadata/v1/instance/attributes/?recursive=True&#34; | jq &#39;del(.[&#34;startup-script&#34;])&#39;)
 * cat &lt;&lt;EOF &gt; /var/www/html/index.html
 * &lt;pre&gt;
 * Name: $NAME
 * IP: $IP
 * Metadata: $METADATA
 * &lt;/pre&gt;
 * EOF
 *             &#34;&#34;&#34;))
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultInstanceGroupManager = new InstanceGroupManager(&#34;defaultInstanceGroupManager&#34;, InstanceGroupManagerArgs.builder()        
 *             .zone(&#34;us-central1-c&#34;)
 *             .namedPorts(InstanceGroupManagerNamedPortArgs.builder()
 *                 .name(&#34;tcp&#34;)
 *                 .port(80)
 *                 .build())
 *             .versions(InstanceGroupManagerVersionArgs.builder()
 *                 .instanceTemplate(defaultInstanceTemplate.id())
 *                 .name(&#34;primary&#34;)
 *                 .build())
 *             .baseInstanceName(&#34;vm&#34;)
 *             .targetSize(2)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultBackendService = new BackendService(&#34;defaultBackendService&#34;, BackendServiceArgs.builder()        
 *             .protocol(&#34;TCP&#34;)
 *             .portName(&#34;tcp&#34;)
 *             .loadBalancingScheme(&#34;EXTERNAL&#34;)
 *             .timeoutSec(10)
 *             .healthChecks(defaultHealthCheck.id())
 *             .backends(BackendServiceBackendArgs.builder()
 *                 .group(defaultInstanceGroupManager.instanceGroup())
 *                 .balancingMode(&#34;UTILIZATION&#34;)
 *                 .maxUtilization(1)
 *                 .capacityScaler(1)
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultTargetTCPProxy = new TargetTCPProxy(&#34;defaultTargetTCPProxy&#34;, TargetTCPProxyArgs.builder()        
 *             .backendService(defaultBackendService.id())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultGlobalForwardingRule = new GlobalForwardingRule(&#34;defaultGlobalForwardingRule&#34;, GlobalForwardingRuleArgs.builder()        
 *             .ipProtocol(&#34;TCP&#34;)
 *             .loadBalancingScheme(&#34;EXTERNAL&#34;)
 *             .portRange(&#34;110&#34;)
 *             .target(defaultTargetTCPProxy.id())
 *             .ipAddress(defaultGlobalAddress.id())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultFirewall = new Firewall(&#34;defaultFirewall&#34;, FirewallArgs.builder()        
 *             .direction(&#34;INGRESS&#34;)
 *             .network(defaultNetwork.id())
 *             .sourceRanges(            
 *                 &#34;130.211.0.0/22&#34;,
 *                 &#34;35.191.0.0/16&#34;)
 *             .allows(FirewallAllowArgs.builder()
 *                 .protocol(&#34;tcp&#34;)
 *                 .build())
 *             .targetTags(&#34;allow-health-check&#34;)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *     }
 * }
 * ```
 * ### External Http Lb Mig Backend Custom Header
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.Network;
 * import com.pulumi.gcp.compute.NetworkArgs;
 * import com.pulumi.gcp.compute.Subnetwork;
 * import com.pulumi.gcp.compute.SubnetworkArgs;
 * import com.pulumi.gcp.compute.GlobalAddress;
 * import com.pulumi.gcp.compute.GlobalAddressArgs;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.InstanceTemplate;
 * import com.pulumi.gcp.compute.InstanceTemplateArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceTemplateNetworkInterfaceArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceTemplateDiskArgs;
 * import com.pulumi.gcp.compute.InstanceGroupManager;
 * import com.pulumi.gcp.compute.InstanceGroupManagerArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceGroupManagerNamedPortArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceGroupManagerVersionArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceBackendArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.TargetHttpProxy;
 * import com.pulumi.gcp.compute.TargetHttpProxyArgs;
 * import com.pulumi.gcp.compute.GlobalForwardingRule;
 * import com.pulumi.gcp.compute.GlobalForwardingRuleArgs;
 * import com.pulumi.gcp.compute.Firewall;
 * import com.pulumi.gcp.compute.FirewallArgs;
 * import com.pulumi.gcp.compute.inputs.FirewallAllowArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var defaultNetwork = new Network(&#34;defaultNetwork&#34;, NetworkArgs.builder()        
 *             .autoCreateSubnetworks(false)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultSubnetwork = new Subnetwork(&#34;defaultSubnetwork&#34;, SubnetworkArgs.builder()        
 *             .ipCidrRange(&#34;10.0.1.0/24&#34;)
 *             .region(&#34;us-central1&#34;)
 *             .network(defaultNetwork.id())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultGlobalAddress = new GlobalAddress(&#34;defaultGlobalAddress&#34;, GlobalAddressArgs.Empty, CustomResourceOptions.builder()
 *             .provider(google_beta)
 *             .build());
 * 
 *         var defaultHealthCheck = new HealthCheck(&#34;defaultHealthCheck&#34;, HealthCheckArgs.builder()        
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .portSpecification(&#34;USE_SERVING_PORT&#34;)
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultInstanceTemplate = new InstanceTemplate(&#34;defaultInstanceTemplate&#34;, InstanceTemplateArgs.builder()        
 *             .machineType(&#34;e2-small&#34;)
 *             .tags(&#34;allow-health-check&#34;)
 *             .networkInterfaces(InstanceTemplateNetworkInterfaceArgs.builder()
 *                 .network(defaultNetwork.id())
 *                 .subnetwork(defaultSubnetwork.id())
 *                 .accessConfigs()
 *                 .build())
 *             .disks(InstanceTemplateDiskArgs.builder()
 *                 .sourceImage(&#34;debian-cloud/debian-10&#34;)
 *                 .autoDelete(true)
 *                 .boot(true)
 *                 .build())
 *             .metadata(Map.of(&#34;startup-script&#34;, &#34;&#34;&#34;
 * #! /bin/bash
 * set -euo pipefail
 * 
 * export DEBIAN_FRONTEND=noninteractive
 * apt-get update
 * apt-get install -y nginx-light jq
 * 
 * NAME=$(curl -H &#34;Metadata-Flavor: Google&#34; &#34;http://metadata.google.internal/computeMetadata/v1/instance/hostname&#34;)
 * IP=$(curl -H &#34;Metadata-Flavor: Google&#34; &#34;http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/ip&#34;)
 * METADATA=$(curl -f -H &#34;Metadata-Flavor: Google&#34; &#34;http://metadata.google.internal/computeMetadata/v1/instance/attributes/?recursive=True&#34; | jq &#39;del(.[&#34;startup-script&#34;])&#39;)
 * 
 * cat &lt;&lt;EOF &gt; /var/www/html/index.html
 * &lt;pre&gt;
 * Name: $NAME
 * IP: $IP
 * Metadata: $METADATA
 * &lt;/pre&gt;
 * EOF
 *             &#34;&#34;&#34;))
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultInstanceGroupManager = new InstanceGroupManager(&#34;defaultInstanceGroupManager&#34;, InstanceGroupManagerArgs.builder()        
 *             .zone(&#34;us-central1-c&#34;)
 *             .namedPorts(InstanceGroupManagerNamedPortArgs.builder()
 *                 .name(&#34;http&#34;)
 *                 .port(8080)
 *                 .build())
 *             .versions(InstanceGroupManagerVersionArgs.builder()
 *                 .instanceTemplate(defaultInstanceTemplate.id())
 *                 .name(&#34;primary&#34;)
 *                 .build())
 *             .baseInstanceName(&#34;vm&#34;)
 *             .targetSize(2)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultBackendService = new BackendService(&#34;defaultBackendService&#34;, BackendServiceArgs.builder()        
 *             .protocol(&#34;HTTP&#34;)
 *             .portName(&#34;my-port&#34;)
 *             .loadBalancingScheme(&#34;EXTERNAL&#34;)
 *             .timeoutSec(10)
 *             .enableCdn(true)
 *             .customRequestHeaders(&#34;X-Client-Geo-Location: {client_region_subdivision}, {client_city}&#34;)
 *             .customResponseHeaders(&#34;X-Cache-Hit: {cdn_cache_status}&#34;)
 *             .healthChecks(defaultHealthCheck.id())
 *             .backends(BackendServiceBackendArgs.builder()
 *                 .group(defaultInstanceGroupManager.instanceGroup())
 *                 .balancingMode(&#34;UTILIZATION&#34;)
 *                 .capacityScaler(1)
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultURLMap = new URLMap(&#34;defaultURLMap&#34;, URLMapArgs.builder()        
 *             .defaultService(defaultBackendService.id())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultTargetHttpProxy = new TargetHttpProxy(&#34;defaultTargetHttpProxy&#34;, TargetHttpProxyArgs.builder()        
 *             .urlMap(defaultURLMap.id())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultGlobalForwardingRule = new GlobalForwardingRule(&#34;defaultGlobalForwardingRule&#34;, GlobalForwardingRuleArgs.builder()        
 *             .ipProtocol(&#34;TCP&#34;)
 *             .loadBalancingScheme(&#34;EXTERNAL&#34;)
 *             .portRange(&#34;80&#34;)
 *             .target(defaultTargetHttpProxy.id())
 *             .ipAddress(defaultGlobalAddress.id())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultFirewall = new Firewall(&#34;defaultFirewall&#34;, FirewallArgs.builder()        
 *             .direction(&#34;INGRESS&#34;)
 *             .network(defaultNetwork.id())
 *             .sourceRanges(            
 *                 &#34;130.211.0.0/22&#34;,
 *                 &#34;35.191.0.0/16&#34;)
 *             .allows(FirewallAllowArgs.builder()
 *                 .protocol(&#34;tcp&#34;)
 *                 .build())
 *             .targetTags(&#34;allow-health-check&#34;)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *     }
 * }
 * ```
 * ### Global Forwarding Rule Http
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HttpHealthCheck;
 * import com.pulumi.gcp.compute.HttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import com.pulumi.gcp.compute.TargetHttpProxy;
 * import com.pulumi.gcp.compute.TargetHttpProxyArgs;
 * import com.pulumi.gcp.compute.GlobalForwardingRule;
 * import com.pulumi.gcp.compute.GlobalForwardingRuleArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var defaultHttpHealthCheck = new HttpHealthCheck(&#34;defaultHttpHealthCheck&#34;, HttpHealthCheckArgs.builder()        
 *             .requestPath(&#34;/&#34;)
 *             .checkIntervalSec(1)
 *             .timeoutSec(1)
 *             .build());
 * 
 *         var defaultBackendService = new BackendService(&#34;defaultBackendService&#34;, BackendServiceArgs.builder()        
 *             .portName(&#34;http&#34;)
 *             .protocol(&#34;HTTP&#34;)
 *             .timeoutSec(10)
 *             .healthChecks(defaultHttpHealthCheck.id())
 *             .build());
 * 
 *         var defaultURLMap = new URLMap(&#34;defaultURLMap&#34;, URLMapArgs.builder()        
 *             .description(&#34;a description&#34;)
 *             .defaultService(defaultBackendService.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts(&#34;mysite.com&#34;)
 *                 .pathMatcher(&#34;allpaths&#34;)
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name(&#34;allpaths&#34;)
 *                 .defaultService(defaultBackendService.id())
 *                 .pathRules(URLMapPathMatcherPathRuleArgs.builder()
 *                     .paths(&#34;/*&#34;)
 *                     .service(defaultBackendService.id())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *         var defaultTargetHttpProxy = new TargetHttpProxy(&#34;defaultTargetHttpProxy&#34;, TargetHttpProxyArgs.builder()        
 *             .description(&#34;a description&#34;)
 *             .urlMap(defaultURLMap.id())
 *             .build());
 * 
 *         var defaultGlobalForwardingRule = new GlobalForwardingRule(&#34;defaultGlobalForwardingRule&#34;, GlobalForwardingRuleArgs.builder()        
 *             .target(defaultTargetHttpProxy.id())
 *             .portRange(&#34;80&#34;)
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### Global Forwarding Rule Internal
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.ComputeFunctions;
 * import com.pulumi.gcp.compute.inputs.GetImageArgs;
 * import com.pulumi.gcp.compute.InstanceTemplate;
 * import com.pulumi.gcp.compute.InstanceTemplateArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceTemplateNetworkInterfaceArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceTemplateDiskArgs;
 * import com.pulumi.gcp.compute.InstanceGroupManager;
 * import com.pulumi.gcp.compute.InstanceGroupManagerArgs;
 * import com.pulumi.gcp.compute.inputs.InstanceGroupManagerVersionArgs;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckTcpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceBackendArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import com.pulumi.gcp.compute.TargetHttpProxy;
 * import com.pulumi.gcp.compute.TargetHttpProxyArgs;
 * import com.pulumi.gcp.compute.GlobalForwardingRule;
 * import com.pulumi.gcp.compute.GlobalForwardingRuleArgs;
 * import com.pulumi.gcp.compute.inputs.GlobalForwardingRuleMetadataFilterArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         final var debianImage = ComputeFunctions.getImage(GetImageArgs.builder()
 *             .family(&#34;debian-11&#34;)
 *             .project(&#34;debian-cloud&#34;)
 *             .build());
 * 
 *         var instanceTemplate = new InstanceTemplate(&#34;instanceTemplate&#34;, InstanceTemplateArgs.builder()        
 *             .machineType(&#34;e2-medium&#34;)
 *             .networkInterfaces(InstanceTemplateNetworkInterfaceArgs.builder()
 *                 .network(&#34;default&#34;)
 *                 .build())
 *             .disks(InstanceTemplateDiskArgs.builder()
 *                 .sourceImage(debianImage.applyValue(getImageResult -&gt; getImageResult.selfLink()))
 *                 .autoDelete(true)
 *                 .boot(true)
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var igm = new InstanceGroupManager(&#34;igm&#34;, InstanceGroupManagerArgs.builder()        
 *             .versions(InstanceGroupManagerVersionArgs.builder()
 *                 .instanceTemplate(instanceTemplate.id())
 *                 .name(&#34;primary&#34;)
 *                 .build())
 *             .baseInstanceName(&#34;internal-glb&#34;)
 *             .zone(&#34;us-central1-f&#34;)
 *             .targetSize(1)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultHealthCheck = new HealthCheck(&#34;defaultHealthCheck&#34;, HealthCheckArgs.builder()        
 *             .checkIntervalSec(1)
 *             .timeoutSec(1)
 *             .tcpHealthCheck(HealthCheckTcpHealthCheckArgs.builder()
 *                 .port(&#34;80&#34;)
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultBackendService = new BackendService(&#34;defaultBackendService&#34;, BackendServiceArgs.builder()        
 *             .portName(&#34;http&#34;)
 *             .protocol(&#34;HTTP&#34;)
 *             .timeoutSec(10)
 *             .loadBalancingScheme(&#34;INTERNAL_SELF_MANAGED&#34;)
 *             .backends(BackendServiceBackendArgs.builder()
 *                 .group(igm.instanceGroup())
 *                 .balancingMode(&#34;RATE&#34;)
 *                 .capacityScaler(0.4)
 *                 .maxRatePerInstance(50)
 *                 .build())
 *             .healthChecks(defaultHealthCheck.id())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultURLMap = new URLMap(&#34;defaultURLMap&#34;, URLMapArgs.builder()        
 *             .description(&#34;a description&#34;)
 *             .defaultService(defaultBackendService.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts(&#34;mysite.com&#34;)
 *                 .pathMatcher(&#34;allpaths&#34;)
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name(&#34;allpaths&#34;)
 *                 .defaultService(defaultBackendService.id())
 *                 .pathRules(URLMapPathMatcherPathRuleArgs.builder()
 *                     .paths(&#34;/*&#34;)
 *                     .service(defaultBackendService.id())
 *                     .build())
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultTargetHttpProxy = new TargetHttpProxy(&#34;defaultTargetHttpProxy&#34;, TargetHttpProxyArgs.builder()        
 *             .description(&#34;a description&#34;)
 *             .urlMap(defaultURLMap.id())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultGlobalForwardingRule = new GlobalForwardingRule(&#34;defaultGlobalForwardingRule&#34;, GlobalForwardingRuleArgs.builder()        
 *             .target(defaultTargetHttpProxy.id())
 *             .portRange(&#34;80&#34;)
 *             .loadBalancingScheme(&#34;INTERNAL_SELF_MANAGED&#34;)
 *             .ipAddress(&#34;0.0.0.0&#34;)
 *             .metadataFilters(GlobalForwardingRuleMetadataFilterArgs.builder()
 *                 .filterMatchCriteria(&#34;MATCH_ANY&#34;)
 *                 .filterLabels(GlobalForwardingRuleMetadataFilterFilterLabelArgs.builder()
 *                     .name(&#34;PLANET&#34;)
 *                     .value(&#34;MARS&#34;)
 *                     .build())
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *     }
 * }
 * ```
 * ### Global Forwarding Rule External Managed
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import com.pulumi.gcp.compute.TargetHttpProxy;
 * import com.pulumi.gcp.compute.TargetHttpProxyArgs;
 * import com.pulumi.gcp.compute.GlobalForwardingRule;
 * import com.pulumi.gcp.compute.GlobalForwardingRuleArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var defaultBackendService = new BackendService(&#34;defaultBackendService&#34;, BackendServiceArgs.builder()        
 *             .portName(&#34;http&#34;)
 *             .protocol(&#34;HTTP&#34;)
 *             .timeoutSec(10)
 *             .loadBalancingScheme(&#34;EXTERNAL_MANAGED&#34;)
 *             .build());
 * 
 *         var defaultURLMap = new URLMap(&#34;defaultURLMap&#34;, URLMapArgs.builder()        
 *             .description(&#34;a description&#34;)
 *             .defaultService(defaultBackendService.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts(&#34;mysite.com&#34;)
 *                 .pathMatcher(&#34;allpaths&#34;)
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name(&#34;allpaths&#34;)
 *                 .defaultService(defaultBackendService.id())
 *                 .pathRules(URLMapPathMatcherPathRuleArgs.builder()
 *                     .paths(&#34;/*&#34;)
 *                     .service(defaultBackendService.id())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *         var defaultTargetHttpProxy = new TargetHttpProxy(&#34;defaultTargetHttpProxy&#34;, TargetHttpProxyArgs.builder()        
 *             .description(&#34;a description&#34;)
 *             .urlMap(defaultURLMap.id())
 *             .build());
 * 
 *         var defaultGlobalForwardingRule = new GlobalForwardingRule(&#34;defaultGlobalForwardingRule&#34;, GlobalForwardingRuleArgs.builder()        
 *             .target(defaultTargetHttpProxy.id())
 *             .portRange(&#34;80&#34;)
 *             .loadBalancingScheme(&#34;EXTERNAL_MANAGED&#34;)
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### Global Forwarding Rule Hybrid
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.Network;
 * import com.pulumi.gcp.compute.NetworkArgs;
 * import com.pulumi.gcp.compute.Subnetwork;
 * import com.pulumi.gcp.compute.SubnetworkArgs;
 * import com.pulumi.gcp.compute.NetworkEndpointGroup;
 * import com.pulumi.gcp.compute.NetworkEndpointGroupArgs;
 * import com.pulumi.gcp.compute.NetworkEndpoint;
 * import com.pulumi.gcp.compute.NetworkEndpointArgs;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckTcpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceBackendArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import com.pulumi.gcp.compute.TargetHttpProxy;
 * import com.pulumi.gcp.compute.TargetHttpProxyArgs;
 * import com.pulumi.gcp.compute.GlobalForwardingRule;
 * import com.pulumi.gcp.compute.GlobalForwardingRuleArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         final var config = ctx.config();
 *         final var subnetworkCidr = config.get(&#34;subnetworkCidr&#34;).orElse(&#34;10.0.0.0/24&#34;);
 *         var defaultNetwork = new Network(&#34;defaultNetwork&#34;);
 * 
 *         var internalNetwork = new Network(&#34;internalNetwork&#34;, NetworkArgs.builder()        
 *             .autoCreateSubnetworks(false)
 *             .build());
 * 
 *         var internalSubnetwork = new Subnetwork(&#34;internalSubnetwork&#34;, SubnetworkArgs.builder()        
 *             .network(internalNetwork.id())
 *             .ipCidrRange(subnetworkCidr)
 *             .region(&#34;us-central1&#34;)
 *             .privateIpGoogleAccess(true)
 *             .build());
 * 
 *         var defaultNetworkEndpointGroup = new NetworkEndpointGroup(&#34;defaultNetworkEndpointGroup&#34;, NetworkEndpointGroupArgs.builder()        
 *             .network(defaultNetwork.id())
 *             .defaultPort(&#34;90&#34;)
 *             .zone(&#34;us-central1-a&#34;)
 *             .networkEndpointType(&#34;GCE_VM_IP_PORT&#34;)
 *             .build());
 * 
 *         var internalNetworkEndpointGroup = new NetworkEndpointGroup(&#34;internalNetworkEndpointGroup&#34;, NetworkEndpointGroupArgs.builder()        
 *             .network(internalNetwork.id())
 *             .subnetwork(internalSubnetwork.id())
 *             .zone(&#34;us-central1-a&#34;)
 *             .networkEndpointType(&#34;GCE_VM_IP&#34;)
 *             .build());
 * 
 *         var hybridNetworkEndpointGroup = new NetworkEndpointGroup(&#34;hybridNetworkEndpointGroup&#34;, NetworkEndpointGroupArgs.builder()        
 *             .network(defaultNetwork.id())
 *             .defaultPort(&#34;90&#34;)
 *             .zone(&#34;us-central1-a&#34;)
 *             .networkEndpointType(&#34;NON_GCP_PRIVATE_IP_PORT&#34;)
 *             .build());
 * 
 *         var hybrid_endpoint = new NetworkEndpoint(&#34;hybrid-endpoint&#34;, NetworkEndpointArgs.builder()        
 *             .networkEndpointGroup(hybridNetworkEndpointGroup.name())
 *             .port(hybridNetworkEndpointGroup.defaultPort())
 *             .ipAddress(&#34;127.0.0.1&#34;)
 *             .build());
 * 
 *         var defaultHealthCheck = new HealthCheck(&#34;defaultHealthCheck&#34;, HealthCheckArgs.builder()        
 *             .timeoutSec(1)
 *             .checkIntervalSec(1)
 *             .tcpHealthCheck(HealthCheckTcpHealthCheckArgs.builder()
 *                 .port(&#34;80&#34;)
 *                 .build())
 *             .build());
 * 
 *         var defaultBackendService = new BackendService(&#34;defaultBackendService&#34;, BackendServiceArgs.builder()        
 *             .portName(&#34;http&#34;)
 *             .protocol(&#34;HTTP&#34;)
 *             .timeoutSec(10)
 *             .backends(BackendServiceBackendArgs.builder()
 *                 .group(defaultNetworkEndpointGroup.id())
 *                 .balancingMode(&#34;RATE&#34;)
 *                 .maxRatePerEndpoint(10)
 *                 .build())
 *             .healthChecks(defaultHealthCheck.id())
 *             .build());
 * 
 *         var hybridBackendService = new BackendService(&#34;hybridBackendService&#34;, BackendServiceArgs.builder()        
 *             .portName(&#34;http&#34;)
 *             .protocol(&#34;HTTP&#34;)
 *             .timeoutSec(10)
 *             .backends(BackendServiceBackendArgs.builder()
 *                 .group(hybridNetworkEndpointGroup.id())
 *                 .balancingMode(&#34;RATE&#34;)
 *                 .maxRatePerEndpoint(10)
 *                 .build())
 *             .healthChecks(defaultHealthCheck.id())
 *             .build());
 * 
 *         var defaultURLMap = new URLMap(&#34;defaultURLMap&#34;, URLMapArgs.builder()        
 *             .description(&#34;a description&#34;)
 *             .defaultService(defaultBackendService.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts(&#34;mysite.com&#34;)
 *                 .pathMatcher(&#34;allpaths&#34;)
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name(&#34;allpaths&#34;)
 *                 .defaultService(defaultBackendService.id())
 *                 .pathRules(                
 *                     URLMapPathMatcherPathRuleArgs.builder()
 *                         .paths(&#34;/*&#34;)
 *                         .service(defaultBackendService.id())
 *                         .build(),
 *                     URLMapPathMatcherPathRuleArgs.builder()
 *                         .paths(&#34;/hybrid&#34;)
 *                         .service(hybridBackendService.id())
 *                         .build())
 *                 .build())
 *             .build());
 * 
 *         var defaultTargetHttpProxy = new TargetHttpProxy(&#34;defaultTargetHttpProxy&#34;, TargetHttpProxyArgs.builder()        
 *             .description(&#34;a description&#34;)
 *             .urlMap(defaultURLMap.id())
 *             .build());
 * 
 *         var defaultGlobalForwardingRule = new GlobalForwardingRule(&#34;defaultGlobalForwardingRule&#34;, GlobalForwardingRuleArgs.builder()        
 *             .target(defaultTargetHttpProxy.id())
 *             .portRange(&#34;80&#34;)
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### Private Service Connect Google Apis
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.Network;
 * import com.pulumi.gcp.compute.NetworkArgs;
 * import com.pulumi.gcp.compute.Subnetwork;
 * import com.pulumi.gcp.compute.SubnetworkArgs;
 * import com.pulumi.gcp.compute.GlobalAddress;
 * import com.pulumi.gcp.compute.GlobalAddressArgs;
 * import com.pulumi.gcp.compute.GlobalForwardingRule;
 * import com.pulumi.gcp.compute.GlobalForwardingRuleArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var network = new Network(&#34;network&#34;, NetworkArgs.builder()        
 *             .project(&#34;my-project-name&#34;)
 *             .autoCreateSubnetworks(false)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var vpcSubnetwork = new Subnetwork(&#34;vpcSubnetwork&#34;, SubnetworkArgs.builder()        
 *             .project(network.project())
 *             .ipCidrRange(&#34;10.2.0.0/16&#34;)
 *             .region(&#34;us-central1&#34;)
 *             .network(network.id())
 *             .privateIpGoogleAccess(true)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultGlobalAddress = new GlobalAddress(&#34;defaultGlobalAddress&#34;, GlobalAddressArgs.builder()        
 *             .project(network.project())
 *             .addressType(&#34;INTERNAL&#34;)
 *             .purpose(&#34;PRIVATE_SERVICE_CONNECT&#34;)
 *             .network(network.id())
 *             .address(&#34;100.100.100.106&#34;)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var defaultGlobalForwardingRule = new GlobalForwardingRule(&#34;defaultGlobalForwardingRule&#34;, GlobalForwardingRuleArgs.builder()        
 *             .project(network.project())
 *             .target(&#34;all-apis&#34;)
 *             .network(network.id())
 *             .ipAddress(defaultGlobalAddress.id())
 *             .loadBalancingScheme(&#34;&#34;)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *     }
 * }
 * ```
 * 
 * ## Import
 * 
 * GlobalForwardingRule can be imported using any of these accepted formats
 * 
 * ```sh
 *  $ pulumi import gcp:compute/globalForwardingRule:GlobalForwardingRule default projects/{{project}}/global/forwardingRules/{{name}}
 * ```
 * 
 * ```sh
 *  $ pulumi import gcp:compute/globalForwardingRule:GlobalForwardingRule default {{project}}/{{name}}
 * ```
 * 
 * ```sh
 *  $ pulumi import gcp:compute/globalForwardingRule:GlobalForwardingRule default {{name}}
 * ```
 * 
 */
@ResourceType(type="gcp:compute/globalForwardingRule:GlobalForwardingRule")
public class GlobalForwardingRule extends com.pulumi.resources.CustomResource {
    /**
     * An optional description of this resource. Provide this property when
     * you create the resource.
     * 
     */
    @Export(name="description", type=String.class, parameters={})
    private Output</* @Nullable */ String> description;

    /**
     * @return An optional description of this resource. Provide this property when
     * you create the resource.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * The IP address that this forwarding rule serves. When a client sends
     * traffic to this IP address, the forwarding rule directs the traffic to
     * the target that you specify in the forwarding rule. The
     * loadBalancingScheme and the forwarding rule&#39;s target determine the
     * type of IP address that you can use. For detailed information, refer
     * to [IP address specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
     * An address can be specified either by a literal IP address or a
     * reference to an existing Address resource. If you don&#39;t specify a
     * reserved IP address, an ephemeral IP address is assigned.
     * The value must be set to 0.0.0.0 when the target is a targetGrpcProxy
     * that has validateForProxyless field set to true.
     * For Private Service Connect forwarding rules that forward traffic to
     * Google APIs, IP address must be provided.
     * 
     */
    @Export(name="ipAddress", type=String.class, parameters={})
    private Output<String> ipAddress;

    /**
     * @return The IP address that this forwarding rule serves. When a client sends
     * traffic to this IP address, the forwarding rule directs the traffic to
     * the target that you specify in the forwarding rule. The
     * loadBalancingScheme and the forwarding rule&#39;s target determine the
     * type of IP address that you can use. For detailed information, refer
     * to [IP address specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
     * An address can be specified either by a literal IP address or a
     * reference to an existing Address resource. If you don&#39;t specify a
     * reserved IP address, an ephemeral IP address is assigned.
     * The value must be set to 0.0.0.0 when the target is a targetGrpcProxy
     * that has validateForProxyless field set to true.
     * For Private Service Connect forwarding rules that forward traffic to
     * Google APIs, IP address must be provided.
     * 
     */
    public Output<String> ipAddress() {
        return this.ipAddress;
    }
    /**
     * The IP protocol to which this rule applies. When the load balancing scheme is
     * INTERNAL_SELF_MANAGED, only TCP is valid. This field must not be set if the
     * global address is configured as a purpose of PRIVATE_SERVICE_CONNECT
     * and addressType of INTERNAL
     * Possible values are `TCP`, `UDP`, `ESP`, `AH`, `SCTP`, and `ICMP`.
     * 
     */
    @Export(name="ipProtocol", type=String.class, parameters={})
    private Output<String> ipProtocol;

    /**
     * @return The IP protocol to which this rule applies. When the load balancing scheme is
     * INTERNAL_SELF_MANAGED, only TCP is valid. This field must not be set if the
     * global address is configured as a purpose of PRIVATE_SERVICE_CONNECT
     * and addressType of INTERNAL
     * Possible values are `TCP`, `UDP`, `ESP`, `AH`, `SCTP`, and `ICMP`.
     * 
     */
    public Output<String> ipProtocol() {
        return this.ipProtocol;
    }
    /**
     * The IP Version that will be used by this global forwarding rule.
     * Possible values are `IPV4` and `IPV6`.
     * 
     */
    @Export(name="ipVersion", type=String.class, parameters={})
    private Output</* @Nullable */ String> ipVersion;

    /**
     * @return The IP Version that will be used by this global forwarding rule.
     * Possible values are `IPV4` and `IPV6`.
     * 
     */
    public Output<Optional<String>> ipVersion() {
        return Codegen.optional(this.ipVersion);
    }
    /**
     * Used internally during label updates.
     * 
     */
    @Export(name="labelFingerprint", type=String.class, parameters={})
    private Output<String> labelFingerprint;

    /**
     * @return Used internally during label updates.
     * 
     */
    public Output<String> labelFingerprint() {
        return this.labelFingerprint;
    }
    /**
     * Labels to apply to this rule.
     * 
     */
    @Export(name="labels", type=Map.class, parameters={String.class, String.class})
    private Output</* @Nullable */ Map<String,String>> labels;

    /**
     * @return Labels to apply to this rule.
     * 
     */
    public Output<Optional<Map<String,String>>> labels() {
        return Codegen.optional(this.labels);
    }
    /**
     * Specifies the forwarding rule type. * `EXTERNAL` is used for: * Classic Cloud VPN gateways * Protocol forwarding to VMs
     * from an external IP address * The following load balancers: HTTP(S), SSL Proxy, TCP Proxy, and Network TCP/UDP *
     * `INTERNAL` is used for: * Protocol forwarding to VMs from an internal IP address * Internal TCP/UDP load balancers *
     * `INTERNAL_MANAGED` is used for: * Internal HTTP(S) load balancers * `INTERNAL_SELF_MANAGED` is used for: * Traffic
     * Director * `EXTERNAL_MANAGED` is used for: * Global external HTTP(S) load balancers For more information about
     * forwarding rules, refer to [Forwarding rule concepts](/load-balancing/docs/forwarding-rule-concepts). Possible values:
     * INVALID, INTERNAL, INTERNAL_MANAGED, INTERNAL_SELF_MANAGED, EXTERNAL, EXTERNAL_MANAGED
     * 
     */
    @Export(name="loadBalancingScheme", type=String.class, parameters={})
    private Output</* @Nullable */ String> loadBalancingScheme;

    /**
     * @return Specifies the forwarding rule type. * `EXTERNAL` is used for: * Classic Cloud VPN gateways * Protocol forwarding to VMs
     * from an external IP address * The following load balancers: HTTP(S), SSL Proxy, TCP Proxy, and Network TCP/UDP *
     * `INTERNAL` is used for: * Protocol forwarding to VMs from an internal IP address * Internal TCP/UDP load balancers *
     * `INTERNAL_MANAGED` is used for: * Internal HTTP(S) load balancers * `INTERNAL_SELF_MANAGED` is used for: * Traffic
     * Director * `EXTERNAL_MANAGED` is used for: * Global external HTTP(S) load balancers For more information about
     * forwarding rules, refer to [Forwarding rule concepts](/load-balancing/docs/forwarding-rule-concepts). Possible values:
     * INVALID, INTERNAL, INTERNAL_MANAGED, INTERNAL_SELF_MANAGED, EXTERNAL, EXTERNAL_MANAGED
     * 
     */
    public Output<Optional<String>> loadBalancingScheme() {
        return Codegen.optional(this.loadBalancingScheme);
    }
    /**
     * Opaque filter criteria used by Loadbalancer to restrict routing
     * configuration to a limited set xDS compliant clients. In their xDS
     * requests to Loadbalancer, xDS clients present node metadata. If a
     * match takes place, the relevant routing configuration is made available
     * to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set
     * to MATCH_ANY, at least one of the filterLabels must match the
     * corresponding label provided in the metadata. If its filterMatchCriteria
     * is set to MATCH_ALL, then all of its filterLabels must match with
     * corresponding labels in the provided metadata.
     * metadataFilters specified here can be overridden by those specified in
     * the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their
     * loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * Structure is documented below.
     * 
     */
    @Export(name="metadataFilters", type=List.class, parameters={GlobalForwardingRuleMetadataFilter.class})
    private Output</* @Nullable */ List<GlobalForwardingRuleMetadataFilter>> metadataFilters;

    /**
     * @return Opaque filter criteria used by Loadbalancer to restrict routing
     * configuration to a limited set xDS compliant clients. In their xDS
     * requests to Loadbalancer, xDS clients present node metadata. If a
     * match takes place, the relevant routing configuration is made available
     * to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set
     * to MATCH_ANY, at least one of the filterLabels must match the
     * corresponding label provided in the metadata. If its filterMatchCriteria
     * is set to MATCH_ALL, then all of its filterLabels must match with
     * corresponding labels in the provided metadata.
     * metadataFilters specified here can be overridden by those specified in
     * the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their
     * loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * Structure is documented below.
     * 
     */
    public Output<Optional<List<GlobalForwardingRuleMetadataFilter>>> metadataFilters() {
        return Codegen.optional(this.metadataFilters);
    }
    /**
     * Name of the resource; provided by the client when the resource is
     * created. The name must be 1-63 characters long, and comply with
     * RFC1035. Specifically, the name must be 1-63 characters long and match
     * the regular expression `a-z?` which means the
     * first character must be a lowercase letter, and all following
     * characters must be a dash, lowercase letter, or digit, except the last
     * character, which cannot be a dash.
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return Name of the resource; provided by the client when the resource is
     * created. The name must be 1-63 characters long, and comply with
     * RFC1035. Specifically, the name must be 1-63 characters long and match
     * the regular expression `a-z?` which means the
     * first character must be a lowercase letter, and all following
     * characters must be a dash, lowercase letter, or digit, except the last
     * character, which cannot be a dash.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * This field is not used for external load balancing. For `INTERNAL` and `INTERNAL_SELF_MANAGED` load balancing, this
     * field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not
     * specified, the default network will be used.
     * 
     */
    @Export(name="network", type=String.class, parameters={})
    private Output<String> network;

    /**
     * @return This field is not used for external load balancing. For `INTERNAL` and `INTERNAL_SELF_MANAGED` load balancing, this
     * field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not
     * specified, the default network will be used.
     * 
     */
    public Output<String> network() {
        return this.network;
    }
    /**
     * This field is used along with the target field for TargetHttpProxy,
     * TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway,
     * TargetPool, TargetInstance.
     * Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets
     * addressed to ports in the specified range will be forwarded to target.
     * Forwarding rules with the same [IPAddress, IPProtocol] pair must have
     * disjoint port ranges.
     * Some types of forwarding target have constraints on the acceptable
     * ports:
     * * TargetHttpProxy: 80, 8080
     * * TargetHttpsProxy: 443
     * * TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
     *   1883, 5222
     * * TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
     *   1883, 5222
     * * TargetVpnGateway: 500, 4500
     * 
     */
    @Export(name="portRange", type=String.class, parameters={})
    private Output</* @Nullable */ String> portRange;

    /**
     * @return This field is used along with the target field for TargetHttpProxy,
     * TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway,
     * TargetPool, TargetInstance.
     * Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets
     * addressed to ports in the specified range will be forwarded to target.
     * Forwarding rules with the same [IPAddress, IPProtocol] pair must have
     * disjoint port ranges.
     * Some types of forwarding target have constraints on the acceptable
     * ports:
     * * TargetHttpProxy: 80, 8080
     * * TargetHttpsProxy: 443
     * * TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
     *   1883, 5222
     * * TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
     *   1883, 5222
     * * TargetVpnGateway: 500, 4500
     * 
     */
    public Output<Optional<String>> portRange() {
        return Codegen.optional(this.portRange);
    }
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Export(name="project", type=String.class, parameters={})
    private Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Output<String> project() {
        return this.project;
    }
    /**
     * The PSC connection id of the PSC Forwarding Rule.
     * 
     */
    @Export(name="pscConnectionId", type=String.class, parameters={})
    private Output<String> pscConnectionId;

    /**
     * @return The PSC connection id of the PSC Forwarding Rule.
     * 
     */
    public Output<String> pscConnectionId() {
        return this.pscConnectionId;
    }
    /**
     * The PSC connection status of the PSC Forwarding Rule. Possible values: STATUS_UNSPECIFIED, PENDING, ACCEPTED, REJECTED,
     * CLOSED
     * 
     */
    @Export(name="pscConnectionStatus", type=String.class, parameters={})
    private Output<String> pscConnectionStatus;

    /**
     * @return The PSC connection status of the PSC Forwarding Rule. Possible values: STATUS_UNSPECIFIED, PENDING, ACCEPTED, REJECTED,
     * CLOSED
     * 
     */
    public Output<String> pscConnectionStatus() {
        return this.pscConnectionStatus;
    }
    /**
     * The URI of the created resource.
     * 
     */
    @Export(name="selfLink", type=String.class, parameters={})
    private Output<String> selfLink;

    /**
     * @return The URI of the created resource.
     * 
     */
    public Output<String> selfLink() {
        return this.selfLink;
    }
    /**
     * The URL of the target resource to receive the matched traffic. For regional forwarding rules, this target must live in
     * the same region as the forwarding rule. For global forwarding rules, this target must be a global load balancing
     * resource. The forwarded traffic must be of a type appropriate to the target object. For `INTERNAL_SELF_MANAGED` load
     * balancing, only `targetHttpProxy` is valid, not `targetHttpsProxy`.
     * 
     */
    @Export(name="target", type=String.class, parameters={})
    private Output<String> target;

    /**
     * @return The URL of the target resource to receive the matched traffic. For regional forwarding rules, this target must live in
     * the same region as the forwarding rule. For global forwarding rules, this target must be a global load balancing
     * resource. The forwarded traffic must be of a type appropriate to the target object. For `INTERNAL_SELF_MANAGED` load
     * balancing, only `targetHttpProxy` is valid, not `targetHttpsProxy`.
     * 
     */
    public Output<String> target() {
        return this.target;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public GlobalForwardingRule(String name) {
        this(name, GlobalForwardingRuleArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public GlobalForwardingRule(String name, GlobalForwardingRuleArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public GlobalForwardingRule(String name, GlobalForwardingRuleArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:compute/globalForwardingRule:GlobalForwardingRule", name, args == null ? GlobalForwardingRuleArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private GlobalForwardingRule(String name, Output<String> id, @Nullable GlobalForwardingRuleState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:compute/globalForwardingRule:GlobalForwardingRule", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static GlobalForwardingRule get(String name, Output<String> id, @Nullable GlobalForwardingRuleState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new GlobalForwardingRule(name, id, state, options);
    }
}
