// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.compute.inputs.RegionUrlMapDefaultRouteActionArgs;
import com.pulumi.gcp.compute.inputs.RegionUrlMapDefaultUrlRedirectArgs;
import com.pulumi.gcp.compute.inputs.RegionUrlMapHeaderActionArgs;
import com.pulumi.gcp.compute.inputs.RegionUrlMapHostRuleArgs;
import com.pulumi.gcp.compute.inputs.RegionUrlMapPathMatcherArgs;
import com.pulumi.gcp.compute.inputs.RegionUrlMapTestArgs;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class RegionUrlMapArgs extends com.pulumi.resources.ResourceArgs {

    public static final RegionUrlMapArgs Empty = new RegionUrlMapArgs();

    /**
     * defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
     * Only one of defaultRouteAction or defaultUrlRedirect must be set.
     * URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
     * defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
     * Structure is documented below.
     * 
     */
    @Import(name="defaultRouteAction")
    private @Nullable Output<RegionUrlMapDefaultRouteActionArgs> defaultRouteAction;

    /**
     * @return defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
     * Only one of defaultRouteAction or defaultUrlRedirect must be set.
     * URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
     * defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
     * Structure is documented below.
     * 
     */
    public Optional<Output<RegionUrlMapDefaultRouteActionArgs>> defaultRouteAction() {
        return Optional.ofNullable(this.defaultRouteAction);
    }

    /**
     * The full or partial URL of the defaultService resource to which traffic is directed if
     * none of the hostRules match. If defaultRouteAction is additionally specified, advanced
     * routing actions like URL Rewrites, etc. take effect prior to sending the request to the
     * backend. However, if defaultService is specified, defaultRouteAction cannot contain any
     * weightedBackendServices. Conversely, if routeAction specifies any
     * weightedBackendServices, service must not be specified.  Only one of defaultService,
     * defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
     * 
     */
    @Import(name="defaultService")
    private @Nullable Output<String> defaultService;

    /**
     * @return The full or partial URL of the defaultService resource to which traffic is directed if
     * none of the hostRules match. If defaultRouteAction is additionally specified, advanced
     * routing actions like URL Rewrites, etc. take effect prior to sending the request to the
     * backend. However, if defaultService is specified, defaultRouteAction cannot contain any
     * weightedBackendServices. Conversely, if routeAction specifies any
     * weightedBackendServices, service must not be specified.  Only one of defaultService,
     * defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
     * 
     */
    public Optional<Output<String>> defaultService() {
        return Optional.ofNullable(this.defaultService);
    }

    /**
     * When none of the specified hostRules match, the request is redirected to a URL specified
     * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
     * defaultRouteAction must not be set.
     * Structure is documented below.
     * 
     */
    @Import(name="defaultUrlRedirect")
    private @Nullable Output<RegionUrlMapDefaultUrlRedirectArgs> defaultUrlRedirect;

    /**
     * @return When none of the specified hostRules match, the request is redirected to a URL specified
     * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
     * defaultRouteAction must not be set.
     * Structure is documented below.
     * 
     */
    public Optional<Output<RegionUrlMapDefaultUrlRedirectArgs>> defaultUrlRedirect() {
        return Optional.ofNullable(this.defaultUrlRedirect);
    }

    /**
     * An optional description of this resource. Provide this property when
     * you create the resource.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return An optional description of this resource. Provide this property when
     * you create the resource.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Specifies changes to request and response headers that need to take effect for the selected backendService.
     * headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
     * headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
     * Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
     * Structure is documented below.
     * 
     */
    @Import(name="headerAction")
    private @Nullable Output<RegionUrlMapHeaderActionArgs> headerAction;

    /**
     * @return Specifies changes to request and response headers that need to take effect for the selected backendService.
     * headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
     * headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
     * Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
     * Structure is documented below.
     * 
     */
    public Optional<Output<RegionUrlMapHeaderActionArgs>> headerAction() {
        return Optional.ofNullable(this.headerAction);
    }

    /**
     * The list of HostRules to use against the URL.
     * Structure is documented below.
     * 
     */
    @Import(name="hostRules")
    private @Nullable Output<List<RegionUrlMapHostRuleArgs>> hostRules;

    /**
     * @return The list of HostRules to use against the URL.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<RegionUrlMapHostRuleArgs>>> hostRules() {
        return Optional.ofNullable(this.hostRules);
    }

    /**
     * Name of the resource. Provided by the client when the resource is
     * created. The name must be 1-63 characters long, and comply with
     * RFC1035. Specifically, the name must be 1-63 characters long and match
     * the regular expression `a-z?` which means the
     * first character must be a lowercase letter, and all following
     * characters must be a dash, lowercase letter, or digit, except the last
     * character, which cannot be a dash.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return Name of the resource. Provided by the client when the resource is
     * created. The name must be 1-63 characters long, and comply with
     * RFC1035. Specifically, the name must be 1-63 characters long and match
     * the regular expression `a-z?` which means the
     * first character must be a lowercase letter, and all following
     * characters must be a dash, lowercase letter, or digit, except the last
     * character, which cannot be a dash.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The list of named PathMatchers to use against the URL.
     * Structure is documented below.
     * 
     */
    @Import(name="pathMatchers")
    private @Nullable Output<List<RegionUrlMapPathMatcherArgs>> pathMatchers;

    /**
     * @return The list of named PathMatchers to use against the URL.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<RegionUrlMapPathMatcherArgs>>> pathMatchers() {
        return Optional.ofNullable(this.pathMatchers);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * The Region in which the url map should reside.
     * If it is not provided, the provider region is used.
     * 
     */
    @Import(name="region")
    private @Nullable Output<String> region;

    /**
     * @return The Region in which the url map should reside.
     * If it is not provided, the provider region is used.
     * 
     */
    public Optional<Output<String>> region() {
        return Optional.ofNullable(this.region);
    }

    /**
     * The list of expected URL mappings. Requests to update this UrlMap will
     * succeed only if all of the test cases pass.
     * Structure is documented below.
     * 
     */
    @Import(name="tests")
    private @Nullable Output<List<RegionUrlMapTestArgs>> tests;

    /**
     * @return The list of expected URL mappings. Requests to update this UrlMap will
     * succeed only if all of the test cases pass.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<RegionUrlMapTestArgs>>> tests() {
        return Optional.ofNullable(this.tests);
    }

    private RegionUrlMapArgs() {}

    private RegionUrlMapArgs(RegionUrlMapArgs $) {
        this.defaultRouteAction = $.defaultRouteAction;
        this.defaultService = $.defaultService;
        this.defaultUrlRedirect = $.defaultUrlRedirect;
        this.description = $.description;
        this.headerAction = $.headerAction;
        this.hostRules = $.hostRules;
        this.name = $.name;
        this.pathMatchers = $.pathMatchers;
        this.project = $.project;
        this.region = $.region;
        this.tests = $.tests;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(RegionUrlMapArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private RegionUrlMapArgs $;

        public Builder() {
            $ = new RegionUrlMapArgs();
        }

        public Builder(RegionUrlMapArgs defaults) {
            $ = new RegionUrlMapArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param defaultRouteAction defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
         * Only one of defaultRouteAction or defaultUrlRedirect must be set.
         * URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
         * defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder defaultRouteAction(@Nullable Output<RegionUrlMapDefaultRouteActionArgs> defaultRouteAction) {
            $.defaultRouteAction = defaultRouteAction;
            return this;
        }

        /**
         * @param defaultRouteAction defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
         * Only one of defaultRouteAction or defaultUrlRedirect must be set.
         * URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
         * defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder defaultRouteAction(RegionUrlMapDefaultRouteActionArgs defaultRouteAction) {
            return defaultRouteAction(Output.of(defaultRouteAction));
        }

        /**
         * @param defaultService The full or partial URL of the defaultService resource to which traffic is directed if
         * none of the hostRules match. If defaultRouteAction is additionally specified, advanced
         * routing actions like URL Rewrites, etc. take effect prior to sending the request to the
         * backend. However, if defaultService is specified, defaultRouteAction cannot contain any
         * weightedBackendServices. Conversely, if routeAction specifies any
         * weightedBackendServices, service must not be specified.  Only one of defaultService,
         * defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
         * 
         * @return builder
         * 
         */
        public Builder defaultService(@Nullable Output<String> defaultService) {
            $.defaultService = defaultService;
            return this;
        }

        /**
         * @param defaultService The full or partial URL of the defaultService resource to which traffic is directed if
         * none of the hostRules match. If defaultRouteAction is additionally specified, advanced
         * routing actions like URL Rewrites, etc. take effect prior to sending the request to the
         * backend. However, if defaultService is specified, defaultRouteAction cannot contain any
         * weightedBackendServices. Conversely, if routeAction specifies any
         * weightedBackendServices, service must not be specified.  Only one of defaultService,
         * defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
         * 
         * @return builder
         * 
         */
        public Builder defaultService(String defaultService) {
            return defaultService(Output.of(defaultService));
        }

        /**
         * @param defaultUrlRedirect When none of the specified hostRules match, the request is redirected to a URL specified
         * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
         * defaultRouteAction must not be set.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder defaultUrlRedirect(@Nullable Output<RegionUrlMapDefaultUrlRedirectArgs> defaultUrlRedirect) {
            $.defaultUrlRedirect = defaultUrlRedirect;
            return this;
        }

        /**
         * @param defaultUrlRedirect When none of the specified hostRules match, the request is redirected to a URL specified
         * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
         * defaultRouteAction must not be set.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder defaultUrlRedirect(RegionUrlMapDefaultUrlRedirectArgs defaultUrlRedirect) {
            return defaultUrlRedirect(Output.of(defaultUrlRedirect));
        }

        /**
         * @param description An optional description of this resource. Provide this property when
         * you create the resource.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description An optional description of this resource. Provide this property when
         * you create the resource.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param headerAction Specifies changes to request and response headers that need to take effect for the selected backendService.
         * headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
         * headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
         * Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder headerAction(@Nullable Output<RegionUrlMapHeaderActionArgs> headerAction) {
            $.headerAction = headerAction;
            return this;
        }

        /**
         * @param headerAction Specifies changes to request and response headers that need to take effect for the selected backendService.
         * headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
         * headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
         * Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder headerAction(RegionUrlMapHeaderActionArgs headerAction) {
            return headerAction(Output.of(headerAction));
        }

        /**
         * @param hostRules The list of HostRules to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder hostRules(@Nullable Output<List<RegionUrlMapHostRuleArgs>> hostRules) {
            $.hostRules = hostRules;
            return this;
        }

        /**
         * @param hostRules The list of HostRules to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder hostRules(List<RegionUrlMapHostRuleArgs> hostRules) {
            return hostRules(Output.of(hostRules));
        }

        /**
         * @param hostRules The list of HostRules to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder hostRules(RegionUrlMapHostRuleArgs... hostRules) {
            return hostRules(List.of(hostRules));
        }

        /**
         * @param name Name of the resource. Provided by the client when the resource is
         * created. The name must be 1-63 characters long, and comply with
         * RFC1035. Specifically, the name must be 1-63 characters long and match
         * the regular expression `a-z?` which means the
         * first character must be a lowercase letter, and all following
         * characters must be a dash, lowercase letter, or digit, except the last
         * character, which cannot be a dash.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name Name of the resource. Provided by the client when the resource is
         * created. The name must be 1-63 characters long, and comply with
         * RFC1035. Specifically, the name must be 1-63 characters long and match
         * the regular expression `a-z?` which means the
         * first character must be a lowercase letter, and all following
         * characters must be a dash, lowercase letter, or digit, except the last
         * character, which cannot be a dash.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param pathMatchers The list of named PathMatchers to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder pathMatchers(@Nullable Output<List<RegionUrlMapPathMatcherArgs>> pathMatchers) {
            $.pathMatchers = pathMatchers;
            return this;
        }

        /**
         * @param pathMatchers The list of named PathMatchers to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder pathMatchers(List<RegionUrlMapPathMatcherArgs> pathMatchers) {
            return pathMatchers(Output.of(pathMatchers));
        }

        /**
         * @param pathMatchers The list of named PathMatchers to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder pathMatchers(RegionUrlMapPathMatcherArgs... pathMatchers) {
            return pathMatchers(List.of(pathMatchers));
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param region The Region in which the url map should reside.
         * If it is not provided, the provider region is used.
         * 
         * @return builder
         * 
         */
        public Builder region(@Nullable Output<String> region) {
            $.region = region;
            return this;
        }

        /**
         * @param region The Region in which the url map should reside.
         * If it is not provided, the provider region is used.
         * 
         * @return builder
         * 
         */
        public Builder region(String region) {
            return region(Output.of(region));
        }

        /**
         * @param tests The list of expected URL mappings. Requests to update this UrlMap will
         * succeed only if all of the test cases pass.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder tests(@Nullable Output<List<RegionUrlMapTestArgs>> tests) {
            $.tests = tests;
            return this;
        }

        /**
         * @param tests The list of expected URL mappings. Requests to update this UrlMap will
         * succeed only if all of the test cases pass.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder tests(List<RegionUrlMapTestArgs> tests) {
            return tests(Output.of(tests));
        }

        /**
         * @param tests The list of expected URL mappings. Requests to update this UrlMap will
         * succeed only if all of the test cases pass.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder tests(RegionUrlMapTestArgs... tests) {
            return tests(List.of(tests));
        }

        public RegionUrlMapArgs build() {
            return $;
        }
    }

}
