// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.container.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.container.inputs.NodePoolAutoscalingArgs;
import com.pulumi.gcp.container.inputs.NodePoolManagementArgs;
import com.pulumi.gcp.container.inputs.NodePoolNetworkConfigArgs;
import com.pulumi.gcp.container.inputs.NodePoolNodeConfigArgs;
import com.pulumi.gcp.container.inputs.NodePoolPlacementPolicyArgs;
import com.pulumi.gcp.container.inputs.NodePoolQueuedProvisioningArgs;
import com.pulumi.gcp.container.inputs.NodePoolUpgradeSettingsArgs;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class NodePoolState extends com.pulumi.resources.ResourceArgs {

    public static final NodePoolState Empty = new NodePoolState();

    /**
     * Configuration required by cluster autoscaler to adjust
     * the size of the node pool to the current cluster usage. Structure is documented below.
     * 
     */
    @Import(name="autoscaling")
    private @Nullable Output<NodePoolAutoscalingArgs> autoscaling;

    /**
     * @return Configuration required by cluster autoscaler to adjust
     * the size of the node pool to the current cluster usage. Structure is documented below.
     * 
     */
    public Optional<Output<NodePoolAutoscalingArgs>> autoscaling() {
        return Optional.ofNullable(this.autoscaling);
    }

    /**
     * The cluster to create the node pool for. Cluster must be present in `location` provided for clusters. May be specified in the format `projects/{{project}}/locations/{{location}}/clusters/{{cluster}}` or as just the name of the cluster.
     * 
     * ***
     * 
     */
    @Import(name="cluster")
    private @Nullable Output<String> cluster;

    /**
     * @return The cluster to create the node pool for. Cluster must be present in `location` provided for clusters. May be specified in the format `projects/{{project}}/locations/{{location}}/clusters/{{cluster}}` or as just the name of the cluster.
     * 
     * ***
     * 
     */
    public Optional<Output<String>> cluster() {
        return Optional.ofNullable(this.cluster);
    }

    /**
     * The initial number of nodes for the pool. In
     * regional or multi-zonal clusters, this is the number of nodes per zone. Changing
     * this will force recreation of the resource. WARNING: Resizing your node pool manually
     * may change this value in your existing cluster, which will trigger destruction
     * and recreation on the next provider run (to rectify the discrepancy).  If you don&#39;t
     * need this value, don&#39;t set it.  If you do need it, you can use a lifecycle block to
     * ignore subsqeuent changes to this field.
     * 
     */
    @Import(name="initialNodeCount")
    private @Nullable Output<Integer> initialNodeCount;

    /**
     * @return The initial number of nodes for the pool. In
     * regional or multi-zonal clusters, this is the number of nodes per zone. Changing
     * this will force recreation of the resource. WARNING: Resizing your node pool manually
     * may change this value in your existing cluster, which will trigger destruction
     * and recreation on the next provider run (to rectify the discrepancy).  If you don&#39;t
     * need this value, don&#39;t set it.  If you do need it, you can use a lifecycle block to
     * ignore subsqeuent changes to this field.
     * 
     */
    public Optional<Output<Integer>> initialNodeCount() {
        return Optional.ofNullable(this.initialNodeCount);
    }

    /**
     * The resource URLs of the managed instance groups associated with this node pool.
     * 
     */
    @Import(name="instanceGroupUrls")
    private @Nullable Output<List<String>> instanceGroupUrls;

    /**
     * @return The resource URLs of the managed instance groups associated with this node pool.
     * 
     */
    public Optional<Output<List<String>>> instanceGroupUrls() {
        return Optional.ofNullable(this.instanceGroupUrls);
    }

    /**
     * The location (region or zone) of the cluster.
     * 
     * ***
     * 
     */
    @Import(name="location")
    private @Nullable Output<String> location;

    /**
     * @return The location (region or zone) of the cluster.
     * 
     * ***
     * 
     */
    public Optional<Output<String>> location() {
        return Optional.ofNullable(this.location);
    }

    /**
     * List of instance group URLs which have been assigned to this node pool.
     * 
     */
    @Import(name="managedInstanceGroupUrls")
    private @Nullable Output<List<String>> managedInstanceGroupUrls;

    /**
     * @return List of instance group URLs which have been assigned to this node pool.
     * 
     */
    public Optional<Output<List<String>>> managedInstanceGroupUrls() {
        return Optional.ofNullable(this.managedInstanceGroupUrls);
    }

    /**
     * Node management configuration, wherein auto-repair and
     * auto-upgrade is configured. Structure is documented below.
     * 
     */
    @Import(name="management")
    private @Nullable Output<NodePoolManagementArgs> management;

    /**
     * @return Node management configuration, wherein auto-repair and
     * auto-upgrade is configured. Structure is documented below.
     * 
     */
    public Optional<Output<NodePoolManagementArgs>> management() {
        return Optional.ofNullable(this.management);
    }

    /**
     * The maximum number of pods per node in this node pool.
     * Note that this does not work on node pools which are &#34;route-based&#34; - that is, node
     * pools belonging to clusters that do not have IP Aliasing enabled.
     * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/flexible-pod-cidr)
     * for more information.
     * 
     */
    @Import(name="maxPodsPerNode")
    private @Nullable Output<Integer> maxPodsPerNode;

    /**
     * @return The maximum number of pods per node in this node pool.
     * Note that this does not work on node pools which are &#34;route-based&#34; - that is, node
     * pools belonging to clusters that do not have IP Aliasing enabled.
     * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/flexible-pod-cidr)
     * for more information.
     * 
     */
    public Optional<Output<Integer>> maxPodsPerNode() {
        return Optional.ofNullable(this.maxPodsPerNode);
    }

    /**
     * The name of the node pool. If left blank, the provider will
     * auto-generate a unique name.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the node pool. If left blank, the provider will
     * auto-generate a unique name.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Creates a unique name for the node pool beginning
     * with the specified prefix. Conflicts with `name`.
     * 
     */
    @Import(name="namePrefix")
    private @Nullable Output<String> namePrefix;

    /**
     * @return Creates a unique name for the node pool beginning
     * with the specified prefix. Conflicts with `name`.
     * 
     */
    public Optional<Output<String>> namePrefix() {
        return Optional.ofNullable(this.namePrefix);
    }

    /**
     * The network configuration of the pool. Such as
     * configuration for [Adding Pod IP address ranges](https://cloud.google.com/kubernetes-engine/docs/how-to/multi-pod-cidr)) to the node pool. Or enabling private nodes. Structure is
     * documented below
     * 
     */
    @Import(name="networkConfig")
    private @Nullable Output<NodePoolNetworkConfigArgs> networkConfig;

    /**
     * @return The network configuration of the pool. Such as
     * configuration for [Adding Pod IP address ranges](https://cloud.google.com/kubernetes-engine/docs/how-to/multi-pod-cidr)) to the node pool. Or enabling private nodes. Structure is
     * documented below
     * 
     */
    public Optional<Output<NodePoolNetworkConfigArgs>> networkConfig() {
        return Optional.ofNullable(this.networkConfig);
    }

    /**
     * Parameters used in creating the node pool. See
     * gcp.container.Cluster for schema.
     * 
     */
    @Import(name="nodeConfig")
    private @Nullable Output<NodePoolNodeConfigArgs> nodeConfig;

    /**
     * @return Parameters used in creating the node pool. See
     * gcp.container.Cluster for schema.
     * 
     */
    public Optional<Output<NodePoolNodeConfigArgs>> nodeConfig() {
        return Optional.ofNullable(this.nodeConfig);
    }

    /**
     * The number of nodes per instance group. This field can be used to
     * update the number of nodes per instance group but should not be used alongside `autoscaling`.
     * 
     */
    @Import(name="nodeCount")
    private @Nullable Output<Integer> nodeCount;

    /**
     * @return The number of nodes per instance group. This field can be used to
     * update the number of nodes per instance group but should not be used alongside `autoscaling`.
     * 
     */
    public Optional<Output<Integer>> nodeCount() {
        return Optional.ofNullable(this.nodeCount);
    }

    /**
     * The list of zones in which the node pool&#39;s nodes should be located. Nodes must
     * be in the region of their regional cluster or in the same region as their
     * cluster&#39;s zone for zonal clusters. If unspecified, the cluster-level
     * `node_locations` will be used.
     * 
     * &gt; Note: `node_locations` will not revert to the cluster&#39;s default set of zones
     * upon being unset. You must manually reconcile the list of zones with your
     * cluster.
     * 
     */
    @Import(name="nodeLocations")
    private @Nullable Output<List<String>> nodeLocations;

    /**
     * @return The list of zones in which the node pool&#39;s nodes should be located. Nodes must
     * be in the region of their regional cluster or in the same region as their
     * cluster&#39;s zone for zonal clusters. If unspecified, the cluster-level
     * `node_locations` will be used.
     * 
     * &gt; Note: `node_locations` will not revert to the cluster&#39;s default set of zones
     * upon being unset. You must manually reconcile the list of zones with your
     * cluster.
     * 
     */
    public Optional<Output<List<String>>> nodeLocations() {
        return Optional.ofNullable(this.nodeLocations);
    }

    @Import(name="operation")
    private @Nullable Output<String> operation;

    public Optional<Output<String>> operation() {
        return Optional.ofNullable(this.operation);
    }

    /**
     * Specifies a custom placement policy for the
     * nodes.
     * 
     */
    @Import(name="placementPolicy")
    private @Nullable Output<NodePoolPlacementPolicyArgs> placementPolicy;

    /**
     * @return Specifies a custom placement policy for the
     * nodes.
     * 
     */
    public Optional<Output<NodePoolPlacementPolicyArgs>> placementPolicy() {
        return Optional.ofNullable(this.placementPolicy);
    }

    /**
     * The ID of the project in which to create the node pool. If blank,
     * the provider-configured project will be used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The ID of the project in which to create the node pool. If blank,
     * the provider-configured project will be used.
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * Specifies node pool-level settings of queued provisioning.
     * Structure is documented below.
     * 
     * &lt;a name=&#34;nested_autoscaling&#34;&gt;&lt;/a&gt;The `autoscaling` block supports (either total or per zone limits are required):
     * 
     */
    @Import(name="queuedProvisioning")
    private @Nullable Output<NodePoolQueuedProvisioningArgs> queuedProvisioning;

    /**
     * @return Specifies node pool-level settings of queued provisioning.
     * Structure is documented below.
     * 
     * &lt;a name=&#34;nested_autoscaling&#34;&gt;&lt;/a&gt;The `autoscaling` block supports (either total or per zone limits are required):
     * 
     */
    public Optional<Output<NodePoolQueuedProvisioningArgs>> queuedProvisioning() {
        return Optional.ofNullable(this.queuedProvisioning);
    }

    /**
     * Specify node upgrade settings to change how GKE upgrades nodes.
     * The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
     * 
     */
    @Import(name="upgradeSettings")
    private @Nullable Output<NodePoolUpgradeSettingsArgs> upgradeSettings;

    /**
     * @return Specify node upgrade settings to change how GKE upgrades nodes.
     * The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
     * 
     */
    public Optional<Output<NodePoolUpgradeSettingsArgs>> upgradeSettings() {
        return Optional.ofNullable(this.upgradeSettings);
    }

    /**
     * The Kubernetes version for the nodes in this pool. Note that if this field
     * and `auto_upgrade` are both specified, they will fight each other for what the node version should
     * be, so setting both is highly discouraged. While a fuzzy version can be specified, it&#39;s
     * recommended that you specify explicit versions as the provider will see spurious diffs
     * when fuzzy versions are used. See the `gcp.container.getEngineVersions` data source&#39;s
     * `version_prefix` field to approximate fuzzy versions in a provider-compatible way.
     * 
     */
    @Import(name="version")
    private @Nullable Output<String> version;

    /**
     * @return The Kubernetes version for the nodes in this pool. Note that if this field
     * and `auto_upgrade` are both specified, they will fight each other for what the node version should
     * be, so setting both is highly discouraged. While a fuzzy version can be specified, it&#39;s
     * recommended that you specify explicit versions as the provider will see spurious diffs
     * when fuzzy versions are used. See the `gcp.container.getEngineVersions` data source&#39;s
     * `version_prefix` field to approximate fuzzy versions in a provider-compatible way.
     * 
     */
    public Optional<Output<String>> version() {
        return Optional.ofNullable(this.version);
    }

    private NodePoolState() {}

    private NodePoolState(NodePoolState $) {
        this.autoscaling = $.autoscaling;
        this.cluster = $.cluster;
        this.initialNodeCount = $.initialNodeCount;
        this.instanceGroupUrls = $.instanceGroupUrls;
        this.location = $.location;
        this.managedInstanceGroupUrls = $.managedInstanceGroupUrls;
        this.management = $.management;
        this.maxPodsPerNode = $.maxPodsPerNode;
        this.name = $.name;
        this.namePrefix = $.namePrefix;
        this.networkConfig = $.networkConfig;
        this.nodeConfig = $.nodeConfig;
        this.nodeCount = $.nodeCount;
        this.nodeLocations = $.nodeLocations;
        this.operation = $.operation;
        this.placementPolicy = $.placementPolicy;
        this.project = $.project;
        this.queuedProvisioning = $.queuedProvisioning;
        this.upgradeSettings = $.upgradeSettings;
        this.version = $.version;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(NodePoolState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private NodePoolState $;

        public Builder() {
            $ = new NodePoolState();
        }

        public Builder(NodePoolState defaults) {
            $ = new NodePoolState(Objects.requireNonNull(defaults));
        }

        /**
         * @param autoscaling Configuration required by cluster autoscaler to adjust
         * the size of the node pool to the current cluster usage. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder autoscaling(@Nullable Output<NodePoolAutoscalingArgs> autoscaling) {
            $.autoscaling = autoscaling;
            return this;
        }

        /**
         * @param autoscaling Configuration required by cluster autoscaler to adjust
         * the size of the node pool to the current cluster usage. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder autoscaling(NodePoolAutoscalingArgs autoscaling) {
            return autoscaling(Output.of(autoscaling));
        }

        /**
         * @param cluster The cluster to create the node pool for. Cluster must be present in `location` provided for clusters. May be specified in the format `projects/{{project}}/locations/{{location}}/clusters/{{cluster}}` or as just the name of the cluster.
         * 
         * ***
         * 
         * @return builder
         * 
         */
        public Builder cluster(@Nullable Output<String> cluster) {
            $.cluster = cluster;
            return this;
        }

        /**
         * @param cluster The cluster to create the node pool for. Cluster must be present in `location` provided for clusters. May be specified in the format `projects/{{project}}/locations/{{location}}/clusters/{{cluster}}` or as just the name of the cluster.
         * 
         * ***
         * 
         * @return builder
         * 
         */
        public Builder cluster(String cluster) {
            return cluster(Output.of(cluster));
        }

        /**
         * @param initialNodeCount The initial number of nodes for the pool. In
         * regional or multi-zonal clusters, this is the number of nodes per zone. Changing
         * this will force recreation of the resource. WARNING: Resizing your node pool manually
         * may change this value in your existing cluster, which will trigger destruction
         * and recreation on the next provider run (to rectify the discrepancy).  If you don&#39;t
         * need this value, don&#39;t set it.  If you do need it, you can use a lifecycle block to
         * ignore subsqeuent changes to this field.
         * 
         * @return builder
         * 
         */
        public Builder initialNodeCount(@Nullable Output<Integer> initialNodeCount) {
            $.initialNodeCount = initialNodeCount;
            return this;
        }

        /**
         * @param initialNodeCount The initial number of nodes for the pool. In
         * regional or multi-zonal clusters, this is the number of nodes per zone. Changing
         * this will force recreation of the resource. WARNING: Resizing your node pool manually
         * may change this value in your existing cluster, which will trigger destruction
         * and recreation on the next provider run (to rectify the discrepancy).  If you don&#39;t
         * need this value, don&#39;t set it.  If you do need it, you can use a lifecycle block to
         * ignore subsqeuent changes to this field.
         * 
         * @return builder
         * 
         */
        public Builder initialNodeCount(Integer initialNodeCount) {
            return initialNodeCount(Output.of(initialNodeCount));
        }

        /**
         * @param instanceGroupUrls The resource URLs of the managed instance groups associated with this node pool.
         * 
         * @return builder
         * 
         */
        public Builder instanceGroupUrls(@Nullable Output<List<String>> instanceGroupUrls) {
            $.instanceGroupUrls = instanceGroupUrls;
            return this;
        }

        /**
         * @param instanceGroupUrls The resource URLs of the managed instance groups associated with this node pool.
         * 
         * @return builder
         * 
         */
        public Builder instanceGroupUrls(List<String> instanceGroupUrls) {
            return instanceGroupUrls(Output.of(instanceGroupUrls));
        }

        /**
         * @param instanceGroupUrls The resource URLs of the managed instance groups associated with this node pool.
         * 
         * @return builder
         * 
         */
        public Builder instanceGroupUrls(String... instanceGroupUrls) {
            return instanceGroupUrls(List.of(instanceGroupUrls));
        }

        /**
         * @param location The location (region or zone) of the cluster.
         * 
         * ***
         * 
         * @return builder
         * 
         */
        public Builder location(@Nullable Output<String> location) {
            $.location = location;
            return this;
        }

        /**
         * @param location The location (region or zone) of the cluster.
         * 
         * ***
         * 
         * @return builder
         * 
         */
        public Builder location(String location) {
            return location(Output.of(location));
        }

        /**
         * @param managedInstanceGroupUrls List of instance group URLs which have been assigned to this node pool.
         * 
         * @return builder
         * 
         */
        public Builder managedInstanceGroupUrls(@Nullable Output<List<String>> managedInstanceGroupUrls) {
            $.managedInstanceGroupUrls = managedInstanceGroupUrls;
            return this;
        }

        /**
         * @param managedInstanceGroupUrls List of instance group URLs which have been assigned to this node pool.
         * 
         * @return builder
         * 
         */
        public Builder managedInstanceGroupUrls(List<String> managedInstanceGroupUrls) {
            return managedInstanceGroupUrls(Output.of(managedInstanceGroupUrls));
        }

        /**
         * @param managedInstanceGroupUrls List of instance group URLs which have been assigned to this node pool.
         * 
         * @return builder
         * 
         */
        public Builder managedInstanceGroupUrls(String... managedInstanceGroupUrls) {
            return managedInstanceGroupUrls(List.of(managedInstanceGroupUrls));
        }

        /**
         * @param management Node management configuration, wherein auto-repair and
         * auto-upgrade is configured. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder management(@Nullable Output<NodePoolManagementArgs> management) {
            $.management = management;
            return this;
        }

        /**
         * @param management Node management configuration, wherein auto-repair and
         * auto-upgrade is configured. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder management(NodePoolManagementArgs management) {
            return management(Output.of(management));
        }

        /**
         * @param maxPodsPerNode The maximum number of pods per node in this node pool.
         * Note that this does not work on node pools which are &#34;route-based&#34; - that is, node
         * pools belonging to clusters that do not have IP Aliasing enabled.
         * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/flexible-pod-cidr)
         * for more information.
         * 
         * @return builder
         * 
         */
        public Builder maxPodsPerNode(@Nullable Output<Integer> maxPodsPerNode) {
            $.maxPodsPerNode = maxPodsPerNode;
            return this;
        }

        /**
         * @param maxPodsPerNode The maximum number of pods per node in this node pool.
         * Note that this does not work on node pools which are &#34;route-based&#34; - that is, node
         * pools belonging to clusters that do not have IP Aliasing enabled.
         * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/flexible-pod-cidr)
         * for more information.
         * 
         * @return builder
         * 
         */
        public Builder maxPodsPerNode(Integer maxPodsPerNode) {
            return maxPodsPerNode(Output.of(maxPodsPerNode));
        }

        /**
         * @param name The name of the node pool. If left blank, the provider will
         * auto-generate a unique name.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the node pool. If left blank, the provider will
         * auto-generate a unique name.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param namePrefix Creates a unique name for the node pool beginning
         * with the specified prefix. Conflicts with `name`.
         * 
         * @return builder
         * 
         */
        public Builder namePrefix(@Nullable Output<String> namePrefix) {
            $.namePrefix = namePrefix;
            return this;
        }

        /**
         * @param namePrefix Creates a unique name for the node pool beginning
         * with the specified prefix. Conflicts with `name`.
         * 
         * @return builder
         * 
         */
        public Builder namePrefix(String namePrefix) {
            return namePrefix(Output.of(namePrefix));
        }

        /**
         * @param networkConfig The network configuration of the pool. Such as
         * configuration for [Adding Pod IP address ranges](https://cloud.google.com/kubernetes-engine/docs/how-to/multi-pod-cidr)) to the node pool. Or enabling private nodes. Structure is
         * documented below
         * 
         * @return builder
         * 
         */
        public Builder networkConfig(@Nullable Output<NodePoolNetworkConfigArgs> networkConfig) {
            $.networkConfig = networkConfig;
            return this;
        }

        /**
         * @param networkConfig The network configuration of the pool. Such as
         * configuration for [Adding Pod IP address ranges](https://cloud.google.com/kubernetes-engine/docs/how-to/multi-pod-cidr)) to the node pool. Or enabling private nodes. Structure is
         * documented below
         * 
         * @return builder
         * 
         */
        public Builder networkConfig(NodePoolNetworkConfigArgs networkConfig) {
            return networkConfig(Output.of(networkConfig));
        }

        /**
         * @param nodeConfig Parameters used in creating the node pool. See
         * gcp.container.Cluster for schema.
         * 
         * @return builder
         * 
         */
        public Builder nodeConfig(@Nullable Output<NodePoolNodeConfigArgs> nodeConfig) {
            $.nodeConfig = nodeConfig;
            return this;
        }

        /**
         * @param nodeConfig Parameters used in creating the node pool. See
         * gcp.container.Cluster for schema.
         * 
         * @return builder
         * 
         */
        public Builder nodeConfig(NodePoolNodeConfigArgs nodeConfig) {
            return nodeConfig(Output.of(nodeConfig));
        }

        /**
         * @param nodeCount The number of nodes per instance group. This field can be used to
         * update the number of nodes per instance group but should not be used alongside `autoscaling`.
         * 
         * @return builder
         * 
         */
        public Builder nodeCount(@Nullable Output<Integer> nodeCount) {
            $.nodeCount = nodeCount;
            return this;
        }

        /**
         * @param nodeCount The number of nodes per instance group. This field can be used to
         * update the number of nodes per instance group but should not be used alongside `autoscaling`.
         * 
         * @return builder
         * 
         */
        public Builder nodeCount(Integer nodeCount) {
            return nodeCount(Output.of(nodeCount));
        }

        /**
         * @param nodeLocations The list of zones in which the node pool&#39;s nodes should be located. Nodes must
         * be in the region of their regional cluster or in the same region as their
         * cluster&#39;s zone for zonal clusters. If unspecified, the cluster-level
         * `node_locations` will be used.
         * 
         * &gt; Note: `node_locations` will not revert to the cluster&#39;s default set of zones
         * upon being unset. You must manually reconcile the list of zones with your
         * cluster.
         * 
         * @return builder
         * 
         */
        public Builder nodeLocations(@Nullable Output<List<String>> nodeLocations) {
            $.nodeLocations = nodeLocations;
            return this;
        }

        /**
         * @param nodeLocations The list of zones in which the node pool&#39;s nodes should be located. Nodes must
         * be in the region of their regional cluster or in the same region as their
         * cluster&#39;s zone for zonal clusters. If unspecified, the cluster-level
         * `node_locations` will be used.
         * 
         * &gt; Note: `node_locations` will not revert to the cluster&#39;s default set of zones
         * upon being unset. You must manually reconcile the list of zones with your
         * cluster.
         * 
         * @return builder
         * 
         */
        public Builder nodeLocations(List<String> nodeLocations) {
            return nodeLocations(Output.of(nodeLocations));
        }

        /**
         * @param nodeLocations The list of zones in which the node pool&#39;s nodes should be located. Nodes must
         * be in the region of their regional cluster or in the same region as their
         * cluster&#39;s zone for zonal clusters. If unspecified, the cluster-level
         * `node_locations` will be used.
         * 
         * &gt; Note: `node_locations` will not revert to the cluster&#39;s default set of zones
         * upon being unset. You must manually reconcile the list of zones with your
         * cluster.
         * 
         * @return builder
         * 
         */
        public Builder nodeLocations(String... nodeLocations) {
            return nodeLocations(List.of(nodeLocations));
        }

        public Builder operation(@Nullable Output<String> operation) {
            $.operation = operation;
            return this;
        }

        public Builder operation(String operation) {
            return operation(Output.of(operation));
        }

        /**
         * @param placementPolicy Specifies a custom placement policy for the
         * nodes.
         * 
         * @return builder
         * 
         */
        public Builder placementPolicy(@Nullable Output<NodePoolPlacementPolicyArgs> placementPolicy) {
            $.placementPolicy = placementPolicy;
            return this;
        }

        /**
         * @param placementPolicy Specifies a custom placement policy for the
         * nodes.
         * 
         * @return builder
         * 
         */
        public Builder placementPolicy(NodePoolPlacementPolicyArgs placementPolicy) {
            return placementPolicy(Output.of(placementPolicy));
        }

        /**
         * @param project The ID of the project in which to create the node pool. If blank,
         * the provider-configured project will be used.
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The ID of the project in which to create the node pool. If blank,
         * the provider-configured project will be used.
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param queuedProvisioning Specifies node pool-level settings of queued provisioning.
         * Structure is documented below.
         * 
         * &lt;a name=&#34;nested_autoscaling&#34;&gt;&lt;/a&gt;The `autoscaling` block supports (either total or per zone limits are required):
         * 
         * @return builder
         * 
         */
        public Builder queuedProvisioning(@Nullable Output<NodePoolQueuedProvisioningArgs> queuedProvisioning) {
            $.queuedProvisioning = queuedProvisioning;
            return this;
        }

        /**
         * @param queuedProvisioning Specifies node pool-level settings of queued provisioning.
         * Structure is documented below.
         * 
         * &lt;a name=&#34;nested_autoscaling&#34;&gt;&lt;/a&gt;The `autoscaling` block supports (either total or per zone limits are required):
         * 
         * @return builder
         * 
         */
        public Builder queuedProvisioning(NodePoolQueuedProvisioningArgs queuedProvisioning) {
            return queuedProvisioning(Output.of(queuedProvisioning));
        }

        /**
         * @param upgradeSettings Specify node upgrade settings to change how GKE upgrades nodes.
         * The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder upgradeSettings(@Nullable Output<NodePoolUpgradeSettingsArgs> upgradeSettings) {
            $.upgradeSettings = upgradeSettings;
            return this;
        }

        /**
         * @param upgradeSettings Specify node upgrade settings to change how GKE upgrades nodes.
         * The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder upgradeSettings(NodePoolUpgradeSettingsArgs upgradeSettings) {
            return upgradeSettings(Output.of(upgradeSettings));
        }

        /**
         * @param version The Kubernetes version for the nodes in this pool. Note that if this field
         * and `auto_upgrade` are both specified, they will fight each other for what the node version should
         * be, so setting both is highly discouraged. While a fuzzy version can be specified, it&#39;s
         * recommended that you specify explicit versions as the provider will see spurious diffs
         * when fuzzy versions are used. See the `gcp.container.getEngineVersions` data source&#39;s
         * `version_prefix` field to approximate fuzzy versions in a provider-compatible way.
         * 
         * @return builder
         * 
         */
        public Builder version(@Nullable Output<String> version) {
            $.version = version;
            return this;
        }

        /**
         * @param version The Kubernetes version for the nodes in this pool. Note that if this field
         * and `auto_upgrade` are both specified, they will fight each other for what the node version should
         * be, so setting both is highly discouraged. While a fuzzy version can be specified, it&#39;s
         * recommended that you specify explicit versions as the provider will see spurious diffs
         * when fuzzy versions are used. See the `gcp.container.getEngineVersions` data source&#39;s
         * `version_prefix` field to approximate fuzzy versions in a provider-compatible way.
         * 
         * @return builder
         * 
         */
        public Builder version(String version) {
            return version(Output.of(version));
        }

        public NodePoolState build() {
            return $;
        }
    }

}
