// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.gkebackup.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.gcp.gkebackup.outputs.RestorePlanRestoreConfigClusterResourceRestoreScope;
import com.pulumi.gcp.gkebackup.outputs.RestorePlanRestoreConfigExcludedNamespaces;
import com.pulumi.gcp.gkebackup.outputs.RestorePlanRestoreConfigRestoreOrder;
import com.pulumi.gcp.gkebackup.outputs.RestorePlanRestoreConfigSelectedApplications;
import com.pulumi.gcp.gkebackup.outputs.RestorePlanRestoreConfigSelectedNamespaces;
import com.pulumi.gcp.gkebackup.outputs.RestorePlanRestoreConfigTransformationRule;
import com.pulumi.gcp.gkebackup.outputs.RestorePlanRestoreConfigVolumeDataRestorePolicyBinding;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class RestorePlanRestoreConfig {
    /**
     * @return If True, restore all namespaced resources in the Backup.
     * Setting this field to False will result in an error.
     * 
     */
    private @Nullable Boolean allNamespaces;
    /**
     * @return Defines the behavior for handling the situation where cluster-scoped resources
     * being restored already exist in the target cluster.
     * This MUST be set to a value other than `CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED`
     * if `clusterResourceRestoreScope` is anyting other than `noGroupKinds`.
     * See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#clusterresourceconflictpolicy
     * for more information on each policy option.
     * Possible values are: `USE_EXISTING_VERSION`, `USE_BACKUP_VERSION`.
     * 
     */
    private @Nullable String clusterResourceConflictPolicy;
    /**
     * @return Identifies the cluster-scoped resources to restore from the Backup.
     * Structure is documented below.
     * 
     */
    private @Nullable RestorePlanRestoreConfigClusterResourceRestoreScope clusterResourceRestoreScope;
    /**
     * @return A list of selected namespaces excluded from restoration.
     * All namespaces except those in this list will be restored.
     * Structure is documented below.
     * 
     */
    private @Nullable RestorePlanRestoreConfigExcludedNamespaces excludedNamespaces;
    /**
     * @return Defines the behavior for handling the situation where sets of namespaced resources
     * being restored already exist in the target cluster.
     * This MUST be set to a value other than `NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED`
     * if the `namespacedResourceRestoreScope` is anything other than `noNamespaces`.
     * See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#namespacedresourcerestoremode
     * for more information on each mode.
     * Possible values are: `DELETE_AND_RESTORE`, `FAIL_ON_CONFLICT`, `MERGE_SKIP_ON_CONFLICT`, `MERGE_REPLACE_VOLUME_ON_CONFLICT`, `MERGE_REPLACE_ON_CONFLICT`.
     * 
     */
    private @Nullable String namespacedResourceRestoreMode;
    /**
     * @return Do not restore any namespaced resources if set to &#34;True&#34;.
     * Specifying this field to &#34;False&#34; is not allowed.
     * 
     */
    private @Nullable Boolean noNamespaces;
    /**
     * @return It contains custom ordering to use on a Restore.
     * Structure is documented below.
     * 
     */
    private @Nullable RestorePlanRestoreConfigRestoreOrder restoreOrder;
    /**
     * @return A list of selected ProtectedApplications to restore.
     * The listed ProtectedApplications and all the resources
     * to which they refer will be restored.
     * Structure is documented below.
     * 
     */
    private @Nullable RestorePlanRestoreConfigSelectedApplications selectedApplications;
    /**
     * @return A list of selected namespaces to restore from the Backup.
     * The listed Namespaces and all resources contained in them will be restored.
     * Structure is documented below.
     * 
     */
    private @Nullable RestorePlanRestoreConfigSelectedNamespaces selectedNamespaces;
    /**
     * @return A list of transformation rules to be applied against Kubernetes
     * resources as they are selected for restoration from a Backup.
     * Rules are executed in order defined - this order matters,
     * as changes made by a rule may impact the filtering logic of subsequent
     * rules. An empty list means no transformation will occur.
     * Structure is documented below.
     * 
     */
    private @Nullable List<RestorePlanRestoreConfigTransformationRule> transformationRules;
    /**
     * @return Specifies the mechanism to be used to restore volume data.
     * This should be set to a value other than `NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED`
     * if the `namespacedResourceRestoreScope` is anything other than `noNamespaces`.
     * If not specified, it will be treated as `NO_VOLUME_DATA_RESTORATION`.
     * See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#VolumeDataRestorePolicy
     * for more information on each policy option.
     * Possible values are: `RESTORE_VOLUME_DATA_FROM_BACKUP`, `REUSE_VOLUME_HANDLE_FROM_BACKUP`, `NO_VOLUME_DATA_RESTORATION`.
     * 
     */
    private @Nullable String volumeDataRestorePolicy;
    /**
     * @return A table that binds volumes by their scope to a restore policy. Bindings
     * must have a unique scope. Any volumes not scoped in the bindings are
     * subject to the policy defined in volume_data_restore_policy.
     * Structure is documented below.
     * 
     */
    private @Nullable List<RestorePlanRestoreConfigVolumeDataRestorePolicyBinding> volumeDataRestorePolicyBindings;

    private RestorePlanRestoreConfig() {}
    /**
     * @return If True, restore all namespaced resources in the Backup.
     * Setting this field to False will result in an error.
     * 
     */
    public Optional<Boolean> allNamespaces() {
        return Optional.ofNullable(this.allNamespaces);
    }
    /**
     * @return Defines the behavior for handling the situation where cluster-scoped resources
     * being restored already exist in the target cluster.
     * This MUST be set to a value other than `CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED`
     * if `clusterResourceRestoreScope` is anyting other than `noGroupKinds`.
     * See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#clusterresourceconflictpolicy
     * for more information on each policy option.
     * Possible values are: `USE_EXISTING_VERSION`, `USE_BACKUP_VERSION`.
     * 
     */
    public Optional<String> clusterResourceConflictPolicy() {
        return Optional.ofNullable(this.clusterResourceConflictPolicy);
    }
    /**
     * @return Identifies the cluster-scoped resources to restore from the Backup.
     * Structure is documented below.
     * 
     */
    public Optional<RestorePlanRestoreConfigClusterResourceRestoreScope> clusterResourceRestoreScope() {
        return Optional.ofNullable(this.clusterResourceRestoreScope);
    }
    /**
     * @return A list of selected namespaces excluded from restoration.
     * All namespaces except those in this list will be restored.
     * Structure is documented below.
     * 
     */
    public Optional<RestorePlanRestoreConfigExcludedNamespaces> excludedNamespaces() {
        return Optional.ofNullable(this.excludedNamespaces);
    }
    /**
     * @return Defines the behavior for handling the situation where sets of namespaced resources
     * being restored already exist in the target cluster.
     * This MUST be set to a value other than `NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED`
     * if the `namespacedResourceRestoreScope` is anything other than `noNamespaces`.
     * See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#namespacedresourcerestoremode
     * for more information on each mode.
     * Possible values are: `DELETE_AND_RESTORE`, `FAIL_ON_CONFLICT`, `MERGE_SKIP_ON_CONFLICT`, `MERGE_REPLACE_VOLUME_ON_CONFLICT`, `MERGE_REPLACE_ON_CONFLICT`.
     * 
     */
    public Optional<String> namespacedResourceRestoreMode() {
        return Optional.ofNullable(this.namespacedResourceRestoreMode);
    }
    /**
     * @return Do not restore any namespaced resources if set to &#34;True&#34;.
     * Specifying this field to &#34;False&#34; is not allowed.
     * 
     */
    public Optional<Boolean> noNamespaces() {
        return Optional.ofNullable(this.noNamespaces);
    }
    /**
     * @return It contains custom ordering to use on a Restore.
     * Structure is documented below.
     * 
     */
    public Optional<RestorePlanRestoreConfigRestoreOrder> restoreOrder() {
        return Optional.ofNullable(this.restoreOrder);
    }
    /**
     * @return A list of selected ProtectedApplications to restore.
     * The listed ProtectedApplications and all the resources
     * to which they refer will be restored.
     * Structure is documented below.
     * 
     */
    public Optional<RestorePlanRestoreConfigSelectedApplications> selectedApplications() {
        return Optional.ofNullable(this.selectedApplications);
    }
    /**
     * @return A list of selected namespaces to restore from the Backup.
     * The listed Namespaces and all resources contained in them will be restored.
     * Structure is documented below.
     * 
     */
    public Optional<RestorePlanRestoreConfigSelectedNamespaces> selectedNamespaces() {
        return Optional.ofNullable(this.selectedNamespaces);
    }
    /**
     * @return A list of transformation rules to be applied against Kubernetes
     * resources as they are selected for restoration from a Backup.
     * Rules are executed in order defined - this order matters,
     * as changes made by a rule may impact the filtering logic of subsequent
     * rules. An empty list means no transformation will occur.
     * Structure is documented below.
     * 
     */
    public List<RestorePlanRestoreConfigTransformationRule> transformationRules() {
        return this.transformationRules == null ? List.of() : this.transformationRules;
    }
    /**
     * @return Specifies the mechanism to be used to restore volume data.
     * This should be set to a value other than `NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED`
     * if the `namespacedResourceRestoreScope` is anything other than `noNamespaces`.
     * If not specified, it will be treated as `NO_VOLUME_DATA_RESTORATION`.
     * See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#VolumeDataRestorePolicy
     * for more information on each policy option.
     * Possible values are: `RESTORE_VOLUME_DATA_FROM_BACKUP`, `REUSE_VOLUME_HANDLE_FROM_BACKUP`, `NO_VOLUME_DATA_RESTORATION`.
     * 
     */
    public Optional<String> volumeDataRestorePolicy() {
        return Optional.ofNullable(this.volumeDataRestorePolicy);
    }
    /**
     * @return A table that binds volumes by their scope to a restore policy. Bindings
     * must have a unique scope. Any volumes not scoped in the bindings are
     * subject to the policy defined in volume_data_restore_policy.
     * Structure is documented below.
     * 
     */
    public List<RestorePlanRestoreConfigVolumeDataRestorePolicyBinding> volumeDataRestorePolicyBindings() {
        return this.volumeDataRestorePolicyBindings == null ? List.of() : this.volumeDataRestorePolicyBindings;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(RestorePlanRestoreConfig defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable Boolean allNamespaces;
        private @Nullable String clusterResourceConflictPolicy;
        private @Nullable RestorePlanRestoreConfigClusterResourceRestoreScope clusterResourceRestoreScope;
        private @Nullable RestorePlanRestoreConfigExcludedNamespaces excludedNamespaces;
        private @Nullable String namespacedResourceRestoreMode;
        private @Nullable Boolean noNamespaces;
        private @Nullable RestorePlanRestoreConfigRestoreOrder restoreOrder;
        private @Nullable RestorePlanRestoreConfigSelectedApplications selectedApplications;
        private @Nullable RestorePlanRestoreConfigSelectedNamespaces selectedNamespaces;
        private @Nullable List<RestorePlanRestoreConfigTransformationRule> transformationRules;
        private @Nullable String volumeDataRestorePolicy;
        private @Nullable List<RestorePlanRestoreConfigVolumeDataRestorePolicyBinding> volumeDataRestorePolicyBindings;
        public Builder() {}
        public Builder(RestorePlanRestoreConfig defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.allNamespaces = defaults.allNamespaces;
    	      this.clusterResourceConflictPolicy = defaults.clusterResourceConflictPolicy;
    	      this.clusterResourceRestoreScope = defaults.clusterResourceRestoreScope;
    	      this.excludedNamespaces = defaults.excludedNamespaces;
    	      this.namespacedResourceRestoreMode = defaults.namespacedResourceRestoreMode;
    	      this.noNamespaces = defaults.noNamespaces;
    	      this.restoreOrder = defaults.restoreOrder;
    	      this.selectedApplications = defaults.selectedApplications;
    	      this.selectedNamespaces = defaults.selectedNamespaces;
    	      this.transformationRules = defaults.transformationRules;
    	      this.volumeDataRestorePolicy = defaults.volumeDataRestorePolicy;
    	      this.volumeDataRestorePolicyBindings = defaults.volumeDataRestorePolicyBindings;
        }

        @CustomType.Setter
        public Builder allNamespaces(@Nullable Boolean allNamespaces) {

            this.allNamespaces = allNamespaces;
            return this;
        }
        @CustomType.Setter
        public Builder clusterResourceConflictPolicy(@Nullable String clusterResourceConflictPolicy) {

            this.clusterResourceConflictPolicy = clusterResourceConflictPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder clusterResourceRestoreScope(@Nullable RestorePlanRestoreConfigClusterResourceRestoreScope clusterResourceRestoreScope) {

            this.clusterResourceRestoreScope = clusterResourceRestoreScope;
            return this;
        }
        @CustomType.Setter
        public Builder excludedNamespaces(@Nullable RestorePlanRestoreConfigExcludedNamespaces excludedNamespaces) {

            this.excludedNamespaces = excludedNamespaces;
            return this;
        }
        @CustomType.Setter
        public Builder namespacedResourceRestoreMode(@Nullable String namespacedResourceRestoreMode) {

            this.namespacedResourceRestoreMode = namespacedResourceRestoreMode;
            return this;
        }
        @CustomType.Setter
        public Builder noNamespaces(@Nullable Boolean noNamespaces) {

            this.noNamespaces = noNamespaces;
            return this;
        }
        @CustomType.Setter
        public Builder restoreOrder(@Nullable RestorePlanRestoreConfigRestoreOrder restoreOrder) {

            this.restoreOrder = restoreOrder;
            return this;
        }
        @CustomType.Setter
        public Builder selectedApplications(@Nullable RestorePlanRestoreConfigSelectedApplications selectedApplications) {

            this.selectedApplications = selectedApplications;
            return this;
        }
        @CustomType.Setter
        public Builder selectedNamespaces(@Nullable RestorePlanRestoreConfigSelectedNamespaces selectedNamespaces) {

            this.selectedNamespaces = selectedNamespaces;
            return this;
        }
        @CustomType.Setter
        public Builder transformationRules(@Nullable List<RestorePlanRestoreConfigTransformationRule> transformationRules) {

            this.transformationRules = transformationRules;
            return this;
        }
        public Builder transformationRules(RestorePlanRestoreConfigTransformationRule... transformationRules) {
            return transformationRules(List.of(transformationRules));
        }
        @CustomType.Setter
        public Builder volumeDataRestorePolicy(@Nullable String volumeDataRestorePolicy) {

            this.volumeDataRestorePolicy = volumeDataRestorePolicy;
            return this;
        }
        @CustomType.Setter
        public Builder volumeDataRestorePolicyBindings(@Nullable List<RestorePlanRestoreConfigVolumeDataRestorePolicyBinding> volumeDataRestorePolicyBindings) {

            this.volumeDataRestorePolicyBindings = volumeDataRestorePolicyBindings;
            return this;
        }
        public Builder volumeDataRestorePolicyBindings(RestorePlanRestoreConfigVolumeDataRestorePolicyBinding... volumeDataRestorePolicyBindings) {
            return volumeDataRestorePolicyBindings(List.of(volumeDataRestorePolicyBindings));
        }
        public RestorePlanRestoreConfig build() {
            final var _resultValue = new RestorePlanRestoreConfig();
            _resultValue.allNamespaces = allNamespaces;
            _resultValue.clusterResourceConflictPolicy = clusterResourceConflictPolicy;
            _resultValue.clusterResourceRestoreScope = clusterResourceRestoreScope;
            _resultValue.excludedNamespaces = excludedNamespaces;
            _resultValue.namespacedResourceRestoreMode = namespacedResourceRestoreMode;
            _resultValue.noNamespaces = noNamespaces;
            _resultValue.restoreOrder = restoreOrder;
            _resultValue.selectedApplications = selectedApplications;
            _resultValue.selectedNamespaces = selectedNamespaces;
            _resultValue.transformationRules = transformationRules;
            _resultValue.volumeDataRestorePolicy = volumeDataRestorePolicy;
            _resultValue.volumeDataRestorePolicyBindings = volumeDataRestorePolicyBindings;
            return _resultValue;
        }
    }
}
