// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.dataloss.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgs;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgs;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgs;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgs;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgs;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgs;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgs;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgs;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgs;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs extends com.pulumi.resources.ResourceArgs {

    public static final PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs Empty = new PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs();

    /**
     * Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 &gt; LOW 31-65 &gt; MEDIUM 66-100 &gt; HIGH
     * This can be used on data of type: number, long, string, timestamp.
     * If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
     * See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
     * Structure is documented below.
     * 
     */
    @Import(name="bucketingConfig")
    private @Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgs> bucketingConfig;

    /**
     * @return Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 &gt; LOW 31-65 &gt; MEDIUM 66-100 &gt; HIGH
     * This can be used on data of type: number, long, string, timestamp.
     * If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
     * See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
     * Structure is documented below.
     * 
     */
    public Optional<Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgs>> bucketingConfig() {
        return Optional.ofNullable(this.bucketingConfig);
    }

    /**
     * Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we&#39;ll attempt to preserve the original data&#39;s type. (This allows you to take a long like 123 and modify it to a string like **3).
     * Structure is documented below.
     * 
     */
    @Import(name="characterMaskConfig")
    private @Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgs> characterMaskConfig;

    /**
     * @return Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we&#39;ll attempt to preserve the original data&#39;s type. (This allows you to take a long like 123 and modify it to a string like **3).
     * Structure is documented below.
     * 
     */
    public Optional<Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgs>> characterMaskConfig() {
        return Optional.ofNullable(this.characterMaskConfig);
    }

    /**
     * Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
     * Structure is documented below.
     * 
     */
    @Import(name="cryptoDeterministicConfig")
    private @Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgs> cryptoDeterministicConfig;

    /**
     * @return Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
     * Structure is documented below.
     * 
     */
    public Optional<Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgs>> cryptoDeterministicConfig() {
        return Optional.ofNullable(this.cryptoDeterministicConfig);
    }

    /**
     * Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
     * Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
     * Currently, only string and integer values can be hashed.
     * See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
     * Structure is documented below.
     * 
     */
    @Import(name="cryptoHashConfig")
    private @Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgs> cryptoHashConfig;

    /**
     * @return Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
     * Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
     * Currently, only string and integer values can be hashed.
     * See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
     * Structure is documented below.
     * 
     */
    public Optional<Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgs>> cryptoHashConfig() {
        return Optional.ofNullable(this.cryptoHashConfig);
    }

    /**
     * Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
     * Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
     * Structure is documented below.
     * 
     */
    @Import(name="cryptoReplaceFfxFpeConfig")
    private @Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs> cryptoReplaceFfxFpeConfig;

    /**
     * @return Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
     * Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
     * Structure is documented below.
     * 
     */
    public Optional<Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs>> cryptoReplaceFfxFpeConfig() {
        return Optional.ofNullable(this.cryptoReplaceFfxFpeConfig);
    }

    /**
     * Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
     * Structure is documented below.
     * 
     */
    @Import(name="dateShiftConfig")
    private @Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgs> dateShiftConfig;

    /**
     * @return Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
     * Structure is documented below.
     * 
     */
    public Optional<Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgs>> dateShiftConfig() {
        return Optional.ofNullable(this.dateShiftConfig);
    }

    /**
     * Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
     * The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with &#34;10-20&#34;.
     * This can be used on data of type: double, long.
     * If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
     * See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
     * Structure is documented below.
     * 
     */
    @Import(name="fixedSizeBucketingConfig")
    private @Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs> fixedSizeBucketingConfig;

    /**
     * @return Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
     * The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with &#34;10-20&#34;.
     * This can be used on data of type: double, long.
     * If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
     * See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
     * Structure is documented below.
     * 
     */
    public Optional<Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs>> fixedSizeBucketingConfig() {
        return Optional.ofNullable(this.fixedSizeBucketingConfig);
    }

    /**
     * Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input &#39;My phone number is 206-555-0123&#39;, the output would be &#39;My phone number is &#39;.
     * 
     */
    @Import(name="redactConfig")
    private @Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgs> redactConfig;

    /**
     * @return Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input &#39;My phone number is 206-555-0123&#39;, the output would be &#39;My phone number is &#39;.
     * 
     */
    public Optional<Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgs>> redactConfig() {
        return Optional.ofNullable(this.redactConfig);
    }

    /**
     * Replace with a specified value.
     * Structure is documented below.
     * 
     */
    @Import(name="replaceConfig")
    private @Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgs> replaceConfig;

    /**
     * @return Replace with a specified value.
     * Structure is documented below.
     * 
     */
    public Optional<Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgs>> replaceConfig() {
        return Optional.ofNullable(this.replaceConfig);
    }

    /**
     * Replace with a value randomly drawn (with replacement) from a dictionary.
     * Structure is documented below.
     * 
     */
    @Import(name="replaceDictionaryConfig")
    private @Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgs> replaceDictionaryConfig;

    /**
     * @return Replace with a value randomly drawn (with replacement) from a dictionary.
     * Structure is documented below.
     * 
     */
    public Optional<Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgs>> replaceDictionaryConfig() {
        return Optional.ofNullable(this.replaceDictionaryConfig);
    }

    /**
     * For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
     * Structure is documented below.
     * 
     */
    @Import(name="timePartConfig")
    private @Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgs> timePartConfig;

    /**
     * @return For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
     * Structure is documented below.
     * 
     */
    public Optional<Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgs>> timePartConfig() {
        return Optional.ofNullable(this.timePartConfig);
    }

    private PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs() {}

    private PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs $) {
        this.bucketingConfig = $.bucketingConfig;
        this.characterMaskConfig = $.characterMaskConfig;
        this.cryptoDeterministicConfig = $.cryptoDeterministicConfig;
        this.cryptoHashConfig = $.cryptoHashConfig;
        this.cryptoReplaceFfxFpeConfig = $.cryptoReplaceFfxFpeConfig;
        this.dateShiftConfig = $.dateShiftConfig;
        this.fixedSizeBucketingConfig = $.fixedSizeBucketingConfig;
        this.redactConfig = $.redactConfig;
        this.replaceConfig = $.replaceConfig;
        this.replaceDictionaryConfig = $.replaceDictionaryConfig;
        this.timePartConfig = $.timePartConfig;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs $;

        public Builder() {
            $ = new PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs();
        }

        public Builder(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs defaults) {
            $ = new PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param bucketingConfig Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 &gt; LOW 31-65 &gt; MEDIUM 66-100 &gt; HIGH
         * This can be used on data of type: number, long, string, timestamp.
         * If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
         * See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder bucketingConfig(@Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgs> bucketingConfig) {
            $.bucketingConfig = bucketingConfig;
            return this;
        }

        /**
         * @param bucketingConfig Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 &gt; LOW 31-65 &gt; MEDIUM 66-100 &gt; HIGH
         * This can be used on data of type: number, long, string, timestamp.
         * If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
         * See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder bucketingConfig(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgs bucketingConfig) {
            return bucketingConfig(Output.of(bucketingConfig));
        }

        /**
         * @param characterMaskConfig Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we&#39;ll attempt to preserve the original data&#39;s type. (This allows you to take a long like 123 and modify it to a string like **3).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder characterMaskConfig(@Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgs> characterMaskConfig) {
            $.characterMaskConfig = characterMaskConfig;
            return this;
        }

        /**
         * @param characterMaskConfig Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we&#39;ll attempt to preserve the original data&#39;s type. (This allows you to take a long like 123 and modify it to a string like **3).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder characterMaskConfig(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgs characterMaskConfig) {
            return characterMaskConfig(Output.of(characterMaskConfig));
        }

        /**
         * @param cryptoDeterministicConfig Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder cryptoDeterministicConfig(@Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgs> cryptoDeterministicConfig) {
            $.cryptoDeterministicConfig = cryptoDeterministicConfig;
            return this;
        }

        /**
         * @param cryptoDeterministicConfig Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder cryptoDeterministicConfig(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgs cryptoDeterministicConfig) {
            return cryptoDeterministicConfig(Output.of(cryptoDeterministicConfig));
        }

        /**
         * @param cryptoHashConfig Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
         * Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
         * Currently, only string and integer values can be hashed.
         * See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder cryptoHashConfig(@Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgs> cryptoHashConfig) {
            $.cryptoHashConfig = cryptoHashConfig;
            return this;
        }

        /**
         * @param cryptoHashConfig Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
         * Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
         * Currently, only string and integer values can be hashed.
         * See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder cryptoHashConfig(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgs cryptoHashConfig) {
            return cryptoHashConfig(Output.of(cryptoHashConfig));
        }

        /**
         * @param cryptoReplaceFfxFpeConfig Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
         * Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder cryptoReplaceFfxFpeConfig(@Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs> cryptoReplaceFfxFpeConfig) {
            $.cryptoReplaceFfxFpeConfig = cryptoReplaceFfxFpeConfig;
            return this;
        }

        /**
         * @param cryptoReplaceFfxFpeConfig Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
         * Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder cryptoReplaceFfxFpeConfig(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs cryptoReplaceFfxFpeConfig) {
            return cryptoReplaceFfxFpeConfig(Output.of(cryptoReplaceFfxFpeConfig));
        }

        /**
         * @param dateShiftConfig Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder dateShiftConfig(@Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgs> dateShiftConfig) {
            $.dateShiftConfig = dateShiftConfig;
            return this;
        }

        /**
         * @param dateShiftConfig Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder dateShiftConfig(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgs dateShiftConfig) {
            return dateShiftConfig(Output.of(dateShiftConfig));
        }

        /**
         * @param fixedSizeBucketingConfig Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
         * The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with &#34;10-20&#34;.
         * This can be used on data of type: double, long.
         * If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
         * See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder fixedSizeBucketingConfig(@Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs> fixedSizeBucketingConfig) {
            $.fixedSizeBucketingConfig = fixedSizeBucketingConfig;
            return this;
        }

        /**
         * @param fixedSizeBucketingConfig Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
         * The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with &#34;10-20&#34;.
         * This can be used on data of type: double, long.
         * If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
         * See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder fixedSizeBucketingConfig(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs fixedSizeBucketingConfig) {
            return fixedSizeBucketingConfig(Output.of(fixedSizeBucketingConfig));
        }

        /**
         * @param redactConfig Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input &#39;My phone number is 206-555-0123&#39;, the output would be &#39;My phone number is &#39;.
         * 
         * @return builder
         * 
         */
        public Builder redactConfig(@Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgs> redactConfig) {
            $.redactConfig = redactConfig;
            return this;
        }

        /**
         * @param redactConfig Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input &#39;My phone number is 206-555-0123&#39;, the output would be &#39;My phone number is &#39;.
         * 
         * @return builder
         * 
         */
        public Builder redactConfig(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgs redactConfig) {
            return redactConfig(Output.of(redactConfig));
        }

        /**
         * @param replaceConfig Replace with a specified value.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder replaceConfig(@Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgs> replaceConfig) {
            $.replaceConfig = replaceConfig;
            return this;
        }

        /**
         * @param replaceConfig Replace with a specified value.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder replaceConfig(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgs replaceConfig) {
            return replaceConfig(Output.of(replaceConfig));
        }

        /**
         * @param replaceDictionaryConfig Replace with a value randomly drawn (with replacement) from a dictionary.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder replaceDictionaryConfig(@Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgs> replaceDictionaryConfig) {
            $.replaceDictionaryConfig = replaceDictionaryConfig;
            return this;
        }

        /**
         * @param replaceDictionaryConfig Replace with a value randomly drawn (with replacement) from a dictionary.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder replaceDictionaryConfig(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgs replaceDictionaryConfig) {
            return replaceDictionaryConfig(Output.of(replaceDictionaryConfig));
        }

        /**
         * @param timePartConfig For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder timePartConfig(@Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgs> timePartConfig) {
            $.timePartConfig = timePartConfig;
            return this;
        }

        /**
         * @param timePartConfig For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder timePartConfig(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgs timePartConfig) {
            return timePartConfig(Output.of(timePartConfig));
        }

        public PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs build() {
            return $;
        }
    }

}
