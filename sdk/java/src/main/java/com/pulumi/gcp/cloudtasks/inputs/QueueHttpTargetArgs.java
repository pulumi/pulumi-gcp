// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.cloudtasks.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.cloudtasks.inputs.QueueHttpTargetHeaderOverrideArgs;
import com.pulumi.gcp.cloudtasks.inputs.QueueHttpTargetOauthTokenArgs;
import com.pulumi.gcp.cloudtasks.inputs.QueueHttpTargetOidcTokenArgs;
import com.pulumi.gcp.cloudtasks.inputs.QueueHttpTargetUriOverrideArgs;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class QueueHttpTargetArgs extends com.pulumi.resources.ResourceArgs {

    public static final QueueHttpTargetArgs Empty = new QueueHttpTargetArgs();

    /**
     * HTTP target headers.
     * This map contains the header field names and values.
     * Headers will be set when running the CreateTask and/or BufferTask.
     * These headers represent a subset of the headers that will be configured for the task&#39;s HTTP request.
     * Some HTTP request headers will be ignored or replaced.
     * Headers which can have multiple values (according to RFC2616) can be specified using comma-separated values.
     * The size of the headers must be less than 80KB. Queue-level headers to override headers of all the tasks in the queue.
     * Structure is documented below.
     * 
     */
    @Import(name="headerOverrides")
    private @Nullable Output<List<QueueHttpTargetHeaderOverrideArgs>> headerOverrides;

    /**
     * @return HTTP target headers.
     * This map contains the header field names and values.
     * Headers will be set when running the CreateTask and/or BufferTask.
     * These headers represent a subset of the headers that will be configured for the task&#39;s HTTP request.
     * Some HTTP request headers will be ignored or replaced.
     * Headers which can have multiple values (according to RFC2616) can be specified using comma-separated values.
     * The size of the headers must be less than 80KB. Queue-level headers to override headers of all the tasks in the queue.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<QueueHttpTargetHeaderOverrideArgs>>> headerOverrides() {
        return Optional.ofNullable(this.headerOverrides);
    }

    /**
     * The HTTP method to use for the request.
     * When specified, it overrides HttpRequest for the task.
     * Note that if the value is set to GET the body of the task will be ignored at execution time.
     * Possible values are: `HTTP_METHOD_UNSPECIFIED`, `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
     * 
     */
    @Import(name="httpMethod")
    private @Nullable Output<String> httpMethod;

    /**
     * @return The HTTP method to use for the request.
     * When specified, it overrides HttpRequest for the task.
     * Note that if the value is set to GET the body of the task will be ignored at execution time.
     * Possible values are: `HTTP_METHOD_UNSPECIFIED`, `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
     * 
     */
    public Optional<Output<String>> httpMethod() {
        return Optional.ofNullable(this.httpMethod);
    }

    /**
     * If specified, an OAuth token is generated and attached as the Authorization header in the HTTP request.
     * This type of authorization should generally be used only when calling Google APIs hosted on *.googleapis.com.
     * Note that both the service account email and the scope MUST be specified when using the queue-level authorization override.
     * Structure is documented below.
     * 
     */
    @Import(name="oauthToken")
    private @Nullable Output<QueueHttpTargetOauthTokenArgs> oauthToken;

    /**
     * @return If specified, an OAuth token is generated and attached as the Authorization header in the HTTP request.
     * This type of authorization should generally be used only when calling Google APIs hosted on *.googleapis.com.
     * Note that both the service account email and the scope MUST be specified when using the queue-level authorization override.
     * Structure is documented below.
     * 
     */
    public Optional<Output<QueueHttpTargetOauthTokenArgs>> oauthToken() {
        return Optional.ofNullable(this.oauthToken);
    }

    /**
     * If specified, an OIDC token is generated and attached as an Authorization header in the HTTP request.
     * This type of authorization can be used for many scenarios, including calling Cloud Run, or endpoints where you intend to validate the token yourself.
     * Note that both the service account email and the audience MUST be specified when using the queue-level authorization override.
     * Structure is documented below.
     * 
     */
    @Import(name="oidcToken")
    private @Nullable Output<QueueHttpTargetOidcTokenArgs> oidcToken;

    /**
     * @return If specified, an OIDC token is generated and attached as an Authorization header in the HTTP request.
     * This type of authorization can be used for many scenarios, including calling Cloud Run, or endpoints where you intend to validate the token yourself.
     * Note that both the service account email and the audience MUST be specified when using the queue-level authorization override.
     * Structure is documented below.
     * 
     */
    public Optional<Output<QueueHttpTargetOidcTokenArgs>> oidcToken() {
        return Optional.ofNullable(this.oidcToken);
    }

    /**
     * URI override.
     * When specified, overrides the execution URI for all the tasks in the queue.
     * Structure is documented below.
     * 
     */
    @Import(name="uriOverride")
    private @Nullable Output<QueueHttpTargetUriOverrideArgs> uriOverride;

    /**
     * @return URI override.
     * When specified, overrides the execution URI for all the tasks in the queue.
     * Structure is documented below.
     * 
     */
    public Optional<Output<QueueHttpTargetUriOverrideArgs>> uriOverride() {
        return Optional.ofNullable(this.uriOverride);
    }

    private QueueHttpTargetArgs() {}

    private QueueHttpTargetArgs(QueueHttpTargetArgs $) {
        this.headerOverrides = $.headerOverrides;
        this.httpMethod = $.httpMethod;
        this.oauthToken = $.oauthToken;
        this.oidcToken = $.oidcToken;
        this.uriOverride = $.uriOverride;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(QueueHttpTargetArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private QueueHttpTargetArgs $;

        public Builder() {
            $ = new QueueHttpTargetArgs();
        }

        public Builder(QueueHttpTargetArgs defaults) {
            $ = new QueueHttpTargetArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param headerOverrides HTTP target headers.
         * This map contains the header field names and values.
         * Headers will be set when running the CreateTask and/or BufferTask.
         * These headers represent a subset of the headers that will be configured for the task&#39;s HTTP request.
         * Some HTTP request headers will be ignored or replaced.
         * Headers which can have multiple values (according to RFC2616) can be specified using comma-separated values.
         * The size of the headers must be less than 80KB. Queue-level headers to override headers of all the tasks in the queue.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder headerOverrides(@Nullable Output<List<QueueHttpTargetHeaderOverrideArgs>> headerOverrides) {
            $.headerOverrides = headerOverrides;
            return this;
        }

        /**
         * @param headerOverrides HTTP target headers.
         * This map contains the header field names and values.
         * Headers will be set when running the CreateTask and/or BufferTask.
         * These headers represent a subset of the headers that will be configured for the task&#39;s HTTP request.
         * Some HTTP request headers will be ignored or replaced.
         * Headers which can have multiple values (according to RFC2616) can be specified using comma-separated values.
         * The size of the headers must be less than 80KB. Queue-level headers to override headers of all the tasks in the queue.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder headerOverrides(List<QueueHttpTargetHeaderOverrideArgs> headerOverrides) {
            return headerOverrides(Output.of(headerOverrides));
        }

        /**
         * @param headerOverrides HTTP target headers.
         * This map contains the header field names and values.
         * Headers will be set when running the CreateTask and/or BufferTask.
         * These headers represent a subset of the headers that will be configured for the task&#39;s HTTP request.
         * Some HTTP request headers will be ignored or replaced.
         * Headers which can have multiple values (according to RFC2616) can be specified using comma-separated values.
         * The size of the headers must be less than 80KB. Queue-level headers to override headers of all the tasks in the queue.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder headerOverrides(QueueHttpTargetHeaderOverrideArgs... headerOverrides) {
            return headerOverrides(List.of(headerOverrides));
        }

        /**
         * @param httpMethod The HTTP method to use for the request.
         * When specified, it overrides HttpRequest for the task.
         * Note that if the value is set to GET the body of the task will be ignored at execution time.
         * Possible values are: `HTTP_METHOD_UNSPECIFIED`, `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
         * 
         * @return builder
         * 
         */
        public Builder httpMethod(@Nullable Output<String> httpMethod) {
            $.httpMethod = httpMethod;
            return this;
        }

        /**
         * @param httpMethod The HTTP method to use for the request.
         * When specified, it overrides HttpRequest for the task.
         * Note that if the value is set to GET the body of the task will be ignored at execution time.
         * Possible values are: `HTTP_METHOD_UNSPECIFIED`, `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
         * 
         * @return builder
         * 
         */
        public Builder httpMethod(String httpMethod) {
            return httpMethod(Output.of(httpMethod));
        }

        /**
         * @param oauthToken If specified, an OAuth token is generated and attached as the Authorization header in the HTTP request.
         * This type of authorization should generally be used only when calling Google APIs hosted on *.googleapis.com.
         * Note that both the service account email and the scope MUST be specified when using the queue-level authorization override.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder oauthToken(@Nullable Output<QueueHttpTargetOauthTokenArgs> oauthToken) {
            $.oauthToken = oauthToken;
            return this;
        }

        /**
         * @param oauthToken If specified, an OAuth token is generated and attached as the Authorization header in the HTTP request.
         * This type of authorization should generally be used only when calling Google APIs hosted on *.googleapis.com.
         * Note that both the service account email and the scope MUST be specified when using the queue-level authorization override.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder oauthToken(QueueHttpTargetOauthTokenArgs oauthToken) {
            return oauthToken(Output.of(oauthToken));
        }

        /**
         * @param oidcToken If specified, an OIDC token is generated and attached as an Authorization header in the HTTP request.
         * This type of authorization can be used for many scenarios, including calling Cloud Run, or endpoints where you intend to validate the token yourself.
         * Note that both the service account email and the audience MUST be specified when using the queue-level authorization override.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder oidcToken(@Nullable Output<QueueHttpTargetOidcTokenArgs> oidcToken) {
            $.oidcToken = oidcToken;
            return this;
        }

        /**
         * @param oidcToken If specified, an OIDC token is generated and attached as an Authorization header in the HTTP request.
         * This type of authorization can be used for many scenarios, including calling Cloud Run, or endpoints where you intend to validate the token yourself.
         * Note that both the service account email and the audience MUST be specified when using the queue-level authorization override.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder oidcToken(QueueHttpTargetOidcTokenArgs oidcToken) {
            return oidcToken(Output.of(oidcToken));
        }

        /**
         * @param uriOverride URI override.
         * When specified, overrides the execution URI for all the tasks in the queue.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder uriOverride(@Nullable Output<QueueHttpTargetUriOverrideArgs> uriOverride) {
            $.uriOverride = uriOverride;
            return this;
        }

        /**
         * @param uriOverride URI override.
         * When specified, overrides the execution URI for all the tasks in the queue.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder uriOverride(QueueHttpTargetUriOverrideArgs uriOverride) {
            return uriOverride(Output.of(uriOverride));
        }

        public QueueHttpTargetArgs build() {
            return $;
        }
    }

}
