// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.container.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigEphemeralStorageConfigArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigGcfsConfigArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigGuestAcceleratorArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigGvnicArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigKubeletConfigArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigLinuxNodeConfigArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigReservationAffinityArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigSandboxConfigArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigShieldedInstanceConfigArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigTaintArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigWorkloadMetadataConfigArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ClusterNodePoolNodeConfigArgs extends com.pulumi.resources.ResourceArgs {

    public static final ClusterNodePoolNodeConfigArgs Empty = new ClusterNodePoolNodeConfigArgs();

    /**
     * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: &lt;https://cloud.google.com/compute/docs/disks/customer-managed-encryption&gt;
     * 
     */
    @Import(name="bootDiskKmsKey")
    private @Nullable Output<String> bootDiskKmsKey;

    /**
     * @return The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: &lt;https://cloud.google.com/compute/docs/disks/customer-managed-encryption&gt;
     * 
     */
    public Optional<Output<String>> bootDiskKmsKey() {
        return Optional.ofNullable(this.bootDiskKmsKey);
    }

    /**
     * Size of the disk attached to each node, specified
     * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
     * 
     */
    @Import(name="diskSizeGb")
    private @Nullable Output<Integer> diskSizeGb;

    /**
     * @return Size of the disk attached to each node, specified
     * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
     * 
     */
    public Optional<Output<Integer>> diskSizeGb() {
        return Optional.ofNullable(this.diskSizeGb);
    }

    /**
     * Type of the disk attached to each node
     * (e.g. &#39;pd-standard&#39;, &#39;pd-balanced&#39; or &#39;pd-ssd&#39;). If unspecified, the default disk type is &#39;pd-standard&#39;
     * 
     */
    @Import(name="diskType")
    private @Nullable Output<String> diskType;

    /**
     * @return Type of the disk attached to each node
     * (e.g. &#39;pd-standard&#39;, &#39;pd-balanced&#39; or &#39;pd-ssd&#39;). If unspecified, the default disk type is &#39;pd-standard&#39;
     * 
     */
    public Optional<Output<String>> diskType() {
        return Optional.ofNullable(this.diskType);
    }

    /**
     * Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
     * 
     */
    @Import(name="ephemeralStorageConfig")
    private @Nullable Output<ClusterNodePoolNodeConfigEphemeralStorageConfigArgs> ephemeralStorageConfig;

    /**
     * @return Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
     * 
     */
    public Optional<Output<ClusterNodePoolNodeConfigEphemeralStorageConfigArgs>> ephemeralStorageConfig() {
        return Optional.ofNullable(this.ephemeralStorageConfig);
    }

    /**
     * ) The default Google Container Filesystem (GCFS) configuration at the cluster level. e.g. enable [image streaming](https://cloud.google.com/kubernetes-engine/docs/how-to/image-streaming) across all the node pools within the cluster. Structure is documented below.
     * 
     */
    @Import(name="gcfsConfig")
    private @Nullable Output<ClusterNodePoolNodeConfigGcfsConfigArgs> gcfsConfig;

    /**
     * @return ) The default Google Container Filesystem (GCFS) configuration at the cluster level. e.g. enable [image streaming](https://cloud.google.com/kubernetes-engine/docs/how-to/image-streaming) across all the node pools within the cluster. Structure is documented below.
     * 
     */
    public Optional<Output<ClusterNodePoolNodeConfigGcfsConfigArgs>> gcfsConfig() {
        return Optional.ofNullable(this.gcfsConfig);
    }

    /**
     * List of the type and count of accelerator cards attached to the instance.
     * Structure documented below.
     * 
     */
    @Import(name="guestAccelerators")
    private @Nullable Output<List<ClusterNodePoolNodeConfigGuestAcceleratorArgs>> guestAccelerators;

    /**
     * @return List of the type and count of accelerator cards attached to the instance.
     * Structure documented below.
     * 
     */
    public Optional<Output<List<ClusterNodePoolNodeConfigGuestAcceleratorArgs>>> guestAccelerators() {
        return Optional.ofNullable(this.guestAccelerators);
    }

    /**
     * Google Virtual NIC (gVNIC) is a virtual network interface.
     * Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
     * gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
     * GKE node version 1.15.11-gke.15 or later
     * Structure is documented below.
     * 
     */
    @Import(name="gvnic")
    private @Nullable Output<ClusterNodePoolNodeConfigGvnicArgs> gvnic;

    /**
     * @return Google Virtual NIC (gVNIC) is a virtual network interface.
     * Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
     * gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
     * GKE node version 1.15.11-gke.15 or later
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterNodePoolNodeConfigGvnicArgs>> gvnic() {
        return Optional.ofNullable(this.gvnic);
    }

    /**
     * The image type to use for this node. Note that changing the image type
     * will delete and recreate all nodes in the node pool.
     * 
     */
    @Import(name="imageType")
    private @Nullable Output<String> imageType;

    /**
     * @return The image type to use for this node. Note that changing the image type
     * will delete and recreate all nodes in the node pool.
     * 
     */
    public Optional<Output<String>> imageType() {
        return Optional.ofNullable(this.imageType);
    }

    /**
     * Kubelet configuration, currently supported attributes can be found [here](https://cloud.google.com/sdk/gcloud/reference/beta/container/node-pools/create#--system-config-from-file).
     * Structure is documented below.
     * 
     */
    @Import(name="kubeletConfig")
    private @Nullable Output<ClusterNodePoolNodeConfigKubeletConfigArgs> kubeletConfig;

    /**
     * @return Kubelet configuration, currently supported attributes can be found [here](https://cloud.google.com/sdk/gcloud/reference/beta/container/node-pools/create#--system-config-from-file).
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterNodePoolNodeConfigKubeletConfigArgs>> kubeletConfig() {
        return Optional.ofNullable(this.kubeletConfig);
    }

    /**
     * The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
     * reserved by Kubernetes Core components and cannot be specified.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    /**
     * @return The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
     * reserved by Kubernetes Core components and cannot be specified.
     * 
     */
    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * Linux node configuration, currently supported attributes can be found [here](https://cloud.google.com/sdk/gcloud/reference/beta/container/node-pools/create#--system-config-from-file).
     * Note that validations happen all server side. All attributes are optional.
     * Structure is documented below.
     * 
     */
    @Import(name="linuxNodeConfig")
    private @Nullable Output<ClusterNodePoolNodeConfigLinuxNodeConfigArgs> linuxNodeConfig;

    /**
     * @return Linux node configuration, currently supported attributes can be found [here](https://cloud.google.com/sdk/gcloud/reference/beta/container/node-pools/create#--system-config-from-file).
     * Note that validations happen all server side. All attributes are optional.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterNodePoolNodeConfigLinuxNodeConfigArgs>> linuxNodeConfig() {
        return Optional.ofNullable(this.linuxNodeConfig);
    }

    /**
     * Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD is 375 GB in size. If zero, it means to disable using local SSDs as ephemeral storage.
     * 
     */
    @Import(name="localSsdCount")
    private @Nullable Output<Integer> localSsdCount;

    /**
     * @return Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD is 375 GB in size. If zero, it means to disable using local SSDs as ephemeral storage.
     * 
     */
    public Optional<Output<Integer>> localSsdCount() {
        return Optional.ofNullable(this.localSsdCount);
    }

    /**
     * The type of logging agent that is deployed by default for newly created node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. See [Increasing logging agent throughput](https://cloud.google.com/stackdriver/docs/solutions/gke/managing-logs#throughput) for more information.
     * 
     */
    @Import(name="loggingVariant")
    private @Nullable Output<String> loggingVariant;

    /**
     * @return The type of logging agent that is deployed by default for newly created node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. See [Increasing logging agent throughput](https://cloud.google.com/stackdriver/docs/solutions/gke/managing-logs#throughput) for more information.
     * 
     */
    public Optional<Output<String>> loggingVariant() {
        return Optional.ofNullable(this.loggingVariant);
    }

    /**
     * The name of a Google Compute Engine machine type.
     * Defaults to `e2-medium`. To create a custom machine type, value should be set as specified
     * [here](https://cloud.google.com/compute/docs/reference/latest/instances#machineType).
     * 
     */
    @Import(name="machineType")
    private @Nullable Output<String> machineType;

    /**
     * @return The name of a Google Compute Engine machine type.
     * Defaults to `e2-medium`. To create a custom machine type, value should be set as specified
     * [here](https://cloud.google.com/compute/docs/reference/latest/instances#machineType).
     * 
     */
    public Optional<Output<String>> machineType() {
        return Optional.ofNullable(this.machineType);
    }

    /**
     * The metadata key/value pairs assigned to instances in
     * the cluster. From GKE `1.12` onwards, `disable-legacy-endpoints` is set to
     * `true` by the API; if `metadata` is set but that default value is not
     * included, the provider will attempt to unset the value. To avoid this, set the
     * value in your config.
     * 
     */
    @Import(name="metadata")
    private @Nullable Output<Map<String,String>> metadata;

    /**
     * @return The metadata key/value pairs assigned to instances in
     * the cluster. From GKE `1.12` onwards, `disable-legacy-endpoints` is set to
     * `true` by the API; if `metadata` is set but that default value is not
     * included, the provider will attempt to unset the value. To avoid this, set the
     * value in your config.
     * 
     */
    public Optional<Output<Map<String,String>>> metadata() {
        return Optional.ofNullable(this.metadata);
    }

    /**
     * Minimum CPU platform to be used by this instance.
     * The instance may be scheduled on the specified or newer CPU platform. Applicable
     * values are the friendly names of CPU platforms, such as `Intel Haswell`. See the
     * [official documentation](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
     * for more information.
     * 
     */
    @Import(name="minCpuPlatform")
    private @Nullable Output<String> minCpuPlatform;

    /**
     * @return Minimum CPU platform to be used by this instance.
     * The instance may be scheduled on the specified or newer CPU platform. Applicable
     * values are the friendly names of CPU platforms, such as `Intel Haswell`. See the
     * [official documentation](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
     * for more information.
     * 
     */
    public Optional<Output<String>> minCpuPlatform() {
        return Optional.ofNullable(this.minCpuPlatform);
    }

    /**
     * Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on [sole tenant nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
     * 
     */
    @Import(name="nodeGroup")
    private @Nullable Output<String> nodeGroup;

    /**
     * @return Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on [sole tenant nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
     * 
     */
    public Optional<Output<String>> nodeGroup() {
        return Optional.ofNullable(this.nodeGroup);
    }

    /**
     * The set of Google API scopes to be made available
     * on all of the node VMs under the &#34;default&#34; service account.
     * Use the &#34;https://www.googleapis.com/auth/cloud-platform&#34; scope to grant access to all APIs. It is recommended that you set `service_account` to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
     * 
     */
    @Import(name="oauthScopes")
    private @Nullable Output<List<String>> oauthScopes;

    /**
     * @return The set of Google API scopes to be made available
     * on all of the node VMs under the &#34;default&#34; service account.
     * Use the &#34;https://www.googleapis.com/auth/cloud-platform&#34; scope to grant access to all APIs. It is recommended that you set `service_account` to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
     * 
     */
    public Optional<Output<List<String>>> oauthScopes() {
        return Optional.ofNullable(this.oauthScopes);
    }

    /**
     * A boolean that represents whether or not the underlying node VMs
     * are preemptible. See the [official documentation](https://cloud.google.com/container-engine/docs/preemptible-vm)
     * for more information. Defaults to false.
     * 
     */
    @Import(name="preemptible")
    private @Nullable Output<Boolean> preemptible;

    /**
     * @return A boolean that represents whether or not the underlying node VMs
     * are preemptible. See the [official documentation](https://cloud.google.com/container-engine/docs/preemptible-vm)
     * for more information. Defaults to false.
     * 
     */
    public Optional<Output<Boolean>> preemptible() {
        return Optional.ofNullable(this.preemptible);
    }

    /**
     * The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
     * 
     */
    @Import(name="reservationAffinity")
    private @Nullable Output<ClusterNodePoolNodeConfigReservationAffinityArgs> reservationAffinity;

    /**
     * @return The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
     * 
     */
    public Optional<Output<ClusterNodePoolNodeConfigReservationAffinityArgs>> reservationAffinity() {
        return Optional.ofNullable(this.reservationAffinity);
    }

    @Import(name="sandboxConfig")
    private @Nullable Output<ClusterNodePoolNodeConfigSandboxConfigArgs> sandboxConfig;

    public Optional<Output<ClusterNodePoolNodeConfigSandboxConfigArgs>> sandboxConfig() {
        return Optional.ofNullable(this.sandboxConfig);
    }

    /**
     * The service account to be used by the Node VMs.
     * If not specified, the &#34;default&#34; service account is used.
     * 
     */
    @Import(name="serviceAccount")
    private @Nullable Output<String> serviceAccount;

    /**
     * @return The service account to be used by the Node VMs.
     * If not specified, the &#34;default&#34; service account is used.
     * 
     */
    public Optional<Output<String>> serviceAccount() {
        return Optional.ofNullable(this.serviceAccount);
    }

    /**
     * Shielded Instance options. Structure is documented below.
     * 
     */
    @Import(name="shieldedInstanceConfig")
    private @Nullable Output<ClusterNodePoolNodeConfigShieldedInstanceConfigArgs> shieldedInstanceConfig;

    /**
     * @return Shielded Instance options. Structure is documented below.
     * 
     */
    public Optional<Output<ClusterNodePoolNodeConfigShieldedInstanceConfigArgs>> shieldedInstanceConfig() {
        return Optional.ofNullable(this.shieldedInstanceConfig);
    }

    /**
     * A boolean that represents whether the underlying node VMs are spot.
     * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms)
     * for more information. Defaults to false.
     * 
     */
    @Import(name="spot")
    private @Nullable Output<Boolean> spot;

    /**
     * @return A boolean that represents whether the underlying node VMs are spot.
     * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms)
     * for more information. Defaults to false.
     * 
     */
    public Optional<Output<Boolean>> spot() {
        return Optional.ofNullable(this.spot);
    }

    /**
     * ) - List of network tags applied to auto-provisioned node pools.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<String>> tags;

    /**
     * @return ) - List of network tags applied to auto-provisioned node pools.
     * 
     */
    public Optional<Output<List<String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * A list of [Kubernetes taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/)
     * to apply to nodes. GKE&#39;s API can only set this field on cluster creation.
     * However, GKE will add taints to your nodes if you enable certain features such
     * as GPUs. If this field is set, any diffs on this field will cause the provider to
     * recreate the underlying resource. Taint values can be updated safely in
     * Kubernetes (eg. through `kubectl`), and it&#39;s recommended that you do not use
     * this field to manage taints. If you do, `lifecycle.ignore_changes` is
     * recommended. Structure is documented below.
     * 
     */
    @Import(name="taints")
    private @Nullable Output<List<ClusterNodePoolNodeConfigTaintArgs>> taints;

    /**
     * @return A list of [Kubernetes taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/)
     * to apply to nodes. GKE&#39;s API can only set this field on cluster creation.
     * However, GKE will add taints to your nodes if you enable certain features such
     * as GPUs. If this field is set, any diffs on this field will cause the provider to
     * recreate the underlying resource. Taint values can be updated safely in
     * Kubernetes (eg. through `kubectl`), and it&#39;s recommended that you do not use
     * this field to manage taints. If you do, `lifecycle.ignore_changes` is
     * recommended. Structure is documented below.
     * 
     */
    public Optional<Output<List<ClusterNodePoolNodeConfigTaintArgs>>> taints() {
        return Optional.ofNullable(this.taints);
    }

    /**
     * Metadata configuration to expose to workloads on the node pool.
     * Structure is documented below.
     * 
     */
    @Import(name="workloadMetadataConfig")
    private @Nullable Output<ClusterNodePoolNodeConfigWorkloadMetadataConfigArgs> workloadMetadataConfig;

    /**
     * @return Metadata configuration to expose to workloads on the node pool.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterNodePoolNodeConfigWorkloadMetadataConfigArgs>> workloadMetadataConfig() {
        return Optional.ofNullable(this.workloadMetadataConfig);
    }

    private ClusterNodePoolNodeConfigArgs() {}

    private ClusterNodePoolNodeConfigArgs(ClusterNodePoolNodeConfigArgs $) {
        this.bootDiskKmsKey = $.bootDiskKmsKey;
        this.diskSizeGb = $.diskSizeGb;
        this.diskType = $.diskType;
        this.ephemeralStorageConfig = $.ephemeralStorageConfig;
        this.gcfsConfig = $.gcfsConfig;
        this.guestAccelerators = $.guestAccelerators;
        this.gvnic = $.gvnic;
        this.imageType = $.imageType;
        this.kubeletConfig = $.kubeletConfig;
        this.labels = $.labels;
        this.linuxNodeConfig = $.linuxNodeConfig;
        this.localSsdCount = $.localSsdCount;
        this.loggingVariant = $.loggingVariant;
        this.machineType = $.machineType;
        this.metadata = $.metadata;
        this.minCpuPlatform = $.minCpuPlatform;
        this.nodeGroup = $.nodeGroup;
        this.oauthScopes = $.oauthScopes;
        this.preemptible = $.preemptible;
        this.reservationAffinity = $.reservationAffinity;
        this.sandboxConfig = $.sandboxConfig;
        this.serviceAccount = $.serviceAccount;
        this.shieldedInstanceConfig = $.shieldedInstanceConfig;
        this.spot = $.spot;
        this.tags = $.tags;
        this.taints = $.taints;
        this.workloadMetadataConfig = $.workloadMetadataConfig;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ClusterNodePoolNodeConfigArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ClusterNodePoolNodeConfigArgs $;

        public Builder() {
            $ = new ClusterNodePoolNodeConfigArgs();
        }

        public Builder(ClusterNodePoolNodeConfigArgs defaults) {
            $ = new ClusterNodePoolNodeConfigArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param bootDiskKmsKey The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: &lt;https://cloud.google.com/compute/docs/disks/customer-managed-encryption&gt;
         * 
         * @return builder
         * 
         */
        public Builder bootDiskKmsKey(@Nullable Output<String> bootDiskKmsKey) {
            $.bootDiskKmsKey = bootDiskKmsKey;
            return this;
        }

        /**
         * @param bootDiskKmsKey The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: &lt;https://cloud.google.com/compute/docs/disks/customer-managed-encryption&gt;
         * 
         * @return builder
         * 
         */
        public Builder bootDiskKmsKey(String bootDiskKmsKey) {
            return bootDiskKmsKey(Output.of(bootDiskKmsKey));
        }

        /**
         * @param diskSizeGb Size of the disk attached to each node, specified
         * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
         * 
         * @return builder
         * 
         */
        public Builder diskSizeGb(@Nullable Output<Integer> diskSizeGb) {
            $.diskSizeGb = diskSizeGb;
            return this;
        }

        /**
         * @param diskSizeGb Size of the disk attached to each node, specified
         * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
         * 
         * @return builder
         * 
         */
        public Builder diskSizeGb(Integer diskSizeGb) {
            return diskSizeGb(Output.of(diskSizeGb));
        }

        /**
         * @param diskType Type of the disk attached to each node
         * (e.g. &#39;pd-standard&#39;, &#39;pd-balanced&#39; or &#39;pd-ssd&#39;). If unspecified, the default disk type is &#39;pd-standard&#39;
         * 
         * @return builder
         * 
         */
        public Builder diskType(@Nullable Output<String> diskType) {
            $.diskType = diskType;
            return this;
        }

        /**
         * @param diskType Type of the disk attached to each node
         * (e.g. &#39;pd-standard&#39;, &#39;pd-balanced&#39; or &#39;pd-ssd&#39;). If unspecified, the default disk type is &#39;pd-standard&#39;
         * 
         * @return builder
         * 
         */
        public Builder diskType(String diskType) {
            return diskType(Output.of(diskType));
        }

        /**
         * @param ephemeralStorageConfig Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder ephemeralStorageConfig(@Nullable Output<ClusterNodePoolNodeConfigEphemeralStorageConfigArgs> ephemeralStorageConfig) {
            $.ephemeralStorageConfig = ephemeralStorageConfig;
            return this;
        }

        /**
         * @param ephemeralStorageConfig Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder ephemeralStorageConfig(ClusterNodePoolNodeConfigEphemeralStorageConfigArgs ephemeralStorageConfig) {
            return ephemeralStorageConfig(Output.of(ephemeralStorageConfig));
        }

        /**
         * @param gcfsConfig ) The default Google Container Filesystem (GCFS) configuration at the cluster level. e.g. enable [image streaming](https://cloud.google.com/kubernetes-engine/docs/how-to/image-streaming) across all the node pools within the cluster. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder gcfsConfig(@Nullable Output<ClusterNodePoolNodeConfigGcfsConfigArgs> gcfsConfig) {
            $.gcfsConfig = gcfsConfig;
            return this;
        }

        /**
         * @param gcfsConfig ) The default Google Container Filesystem (GCFS) configuration at the cluster level. e.g. enable [image streaming](https://cloud.google.com/kubernetes-engine/docs/how-to/image-streaming) across all the node pools within the cluster. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder gcfsConfig(ClusterNodePoolNodeConfigGcfsConfigArgs gcfsConfig) {
            return gcfsConfig(Output.of(gcfsConfig));
        }

        /**
         * @param guestAccelerators List of the type and count of accelerator cards attached to the instance.
         * Structure documented below.
         * 
         * @return builder
         * 
         */
        public Builder guestAccelerators(@Nullable Output<List<ClusterNodePoolNodeConfigGuestAcceleratorArgs>> guestAccelerators) {
            $.guestAccelerators = guestAccelerators;
            return this;
        }

        /**
         * @param guestAccelerators List of the type and count of accelerator cards attached to the instance.
         * Structure documented below.
         * 
         * @return builder
         * 
         */
        public Builder guestAccelerators(List<ClusterNodePoolNodeConfigGuestAcceleratorArgs> guestAccelerators) {
            return guestAccelerators(Output.of(guestAccelerators));
        }

        /**
         * @param guestAccelerators List of the type and count of accelerator cards attached to the instance.
         * Structure documented below.
         * 
         * @return builder
         * 
         */
        public Builder guestAccelerators(ClusterNodePoolNodeConfigGuestAcceleratorArgs... guestAccelerators) {
            return guestAccelerators(List.of(guestAccelerators));
        }

        /**
         * @param gvnic Google Virtual NIC (gVNIC) is a virtual network interface.
         * Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
         * gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
         * GKE node version 1.15.11-gke.15 or later
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder gvnic(@Nullable Output<ClusterNodePoolNodeConfigGvnicArgs> gvnic) {
            $.gvnic = gvnic;
            return this;
        }

        /**
         * @param gvnic Google Virtual NIC (gVNIC) is a virtual network interface.
         * Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
         * gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
         * GKE node version 1.15.11-gke.15 or later
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder gvnic(ClusterNodePoolNodeConfigGvnicArgs gvnic) {
            return gvnic(Output.of(gvnic));
        }

        /**
         * @param imageType The image type to use for this node. Note that changing the image type
         * will delete and recreate all nodes in the node pool.
         * 
         * @return builder
         * 
         */
        public Builder imageType(@Nullable Output<String> imageType) {
            $.imageType = imageType;
            return this;
        }

        /**
         * @param imageType The image type to use for this node. Note that changing the image type
         * will delete and recreate all nodes in the node pool.
         * 
         * @return builder
         * 
         */
        public Builder imageType(String imageType) {
            return imageType(Output.of(imageType));
        }

        /**
         * @param kubeletConfig Kubelet configuration, currently supported attributes can be found [here](https://cloud.google.com/sdk/gcloud/reference/beta/container/node-pools/create#--system-config-from-file).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder kubeletConfig(@Nullable Output<ClusterNodePoolNodeConfigKubeletConfigArgs> kubeletConfig) {
            $.kubeletConfig = kubeletConfig;
            return this;
        }

        /**
         * @param kubeletConfig Kubelet configuration, currently supported attributes can be found [here](https://cloud.google.com/sdk/gcloud/reference/beta/container/node-pools/create#--system-config-from-file).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder kubeletConfig(ClusterNodePoolNodeConfigKubeletConfigArgs kubeletConfig) {
            return kubeletConfig(Output.of(kubeletConfig));
        }

        /**
         * @param labels The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
         * reserved by Kubernetes Core components and cannot be specified.
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
         * reserved by Kubernetes Core components and cannot be specified.
         * 
         * @return builder
         * 
         */
        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        /**
         * @param linuxNodeConfig Linux node configuration, currently supported attributes can be found [here](https://cloud.google.com/sdk/gcloud/reference/beta/container/node-pools/create#--system-config-from-file).
         * Note that validations happen all server side. All attributes are optional.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder linuxNodeConfig(@Nullable Output<ClusterNodePoolNodeConfigLinuxNodeConfigArgs> linuxNodeConfig) {
            $.linuxNodeConfig = linuxNodeConfig;
            return this;
        }

        /**
         * @param linuxNodeConfig Linux node configuration, currently supported attributes can be found [here](https://cloud.google.com/sdk/gcloud/reference/beta/container/node-pools/create#--system-config-from-file).
         * Note that validations happen all server side. All attributes are optional.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder linuxNodeConfig(ClusterNodePoolNodeConfigLinuxNodeConfigArgs linuxNodeConfig) {
            return linuxNodeConfig(Output.of(linuxNodeConfig));
        }

        /**
         * @param localSsdCount Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD is 375 GB in size. If zero, it means to disable using local SSDs as ephemeral storage.
         * 
         * @return builder
         * 
         */
        public Builder localSsdCount(@Nullable Output<Integer> localSsdCount) {
            $.localSsdCount = localSsdCount;
            return this;
        }

        /**
         * @param localSsdCount Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD is 375 GB in size. If zero, it means to disable using local SSDs as ephemeral storage.
         * 
         * @return builder
         * 
         */
        public Builder localSsdCount(Integer localSsdCount) {
            return localSsdCount(Output.of(localSsdCount));
        }

        /**
         * @param loggingVariant The type of logging agent that is deployed by default for newly created node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. See [Increasing logging agent throughput](https://cloud.google.com/stackdriver/docs/solutions/gke/managing-logs#throughput) for more information.
         * 
         * @return builder
         * 
         */
        public Builder loggingVariant(@Nullable Output<String> loggingVariant) {
            $.loggingVariant = loggingVariant;
            return this;
        }

        /**
         * @param loggingVariant The type of logging agent that is deployed by default for newly created node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. See [Increasing logging agent throughput](https://cloud.google.com/stackdriver/docs/solutions/gke/managing-logs#throughput) for more information.
         * 
         * @return builder
         * 
         */
        public Builder loggingVariant(String loggingVariant) {
            return loggingVariant(Output.of(loggingVariant));
        }

        /**
         * @param machineType The name of a Google Compute Engine machine type.
         * Defaults to `e2-medium`. To create a custom machine type, value should be set as specified
         * [here](https://cloud.google.com/compute/docs/reference/latest/instances#machineType).
         * 
         * @return builder
         * 
         */
        public Builder machineType(@Nullable Output<String> machineType) {
            $.machineType = machineType;
            return this;
        }

        /**
         * @param machineType The name of a Google Compute Engine machine type.
         * Defaults to `e2-medium`. To create a custom machine type, value should be set as specified
         * [here](https://cloud.google.com/compute/docs/reference/latest/instances#machineType).
         * 
         * @return builder
         * 
         */
        public Builder machineType(String machineType) {
            return machineType(Output.of(machineType));
        }

        /**
         * @param metadata The metadata key/value pairs assigned to instances in
         * the cluster. From GKE `1.12` onwards, `disable-legacy-endpoints` is set to
         * `true` by the API; if `metadata` is set but that default value is not
         * included, the provider will attempt to unset the value. To avoid this, set the
         * value in your config.
         * 
         * @return builder
         * 
         */
        public Builder metadata(@Nullable Output<Map<String,String>> metadata) {
            $.metadata = metadata;
            return this;
        }

        /**
         * @param metadata The metadata key/value pairs assigned to instances in
         * the cluster. From GKE `1.12` onwards, `disable-legacy-endpoints` is set to
         * `true` by the API; if `metadata` is set but that default value is not
         * included, the provider will attempt to unset the value. To avoid this, set the
         * value in your config.
         * 
         * @return builder
         * 
         */
        public Builder metadata(Map<String,String> metadata) {
            return metadata(Output.of(metadata));
        }

        /**
         * @param minCpuPlatform Minimum CPU platform to be used by this instance.
         * The instance may be scheduled on the specified or newer CPU platform. Applicable
         * values are the friendly names of CPU platforms, such as `Intel Haswell`. See the
         * [official documentation](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for more information.
         * 
         * @return builder
         * 
         */
        public Builder minCpuPlatform(@Nullable Output<String> minCpuPlatform) {
            $.minCpuPlatform = minCpuPlatform;
            return this;
        }

        /**
         * @param minCpuPlatform Minimum CPU platform to be used by this instance.
         * The instance may be scheduled on the specified or newer CPU platform. Applicable
         * values are the friendly names of CPU platforms, such as `Intel Haswell`. See the
         * [official documentation](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for more information.
         * 
         * @return builder
         * 
         */
        public Builder minCpuPlatform(String minCpuPlatform) {
            return minCpuPlatform(Output.of(minCpuPlatform));
        }

        /**
         * @param nodeGroup Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on [sole tenant nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
         * 
         * @return builder
         * 
         */
        public Builder nodeGroup(@Nullable Output<String> nodeGroup) {
            $.nodeGroup = nodeGroup;
            return this;
        }

        /**
         * @param nodeGroup Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on [sole tenant nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
         * 
         * @return builder
         * 
         */
        public Builder nodeGroup(String nodeGroup) {
            return nodeGroup(Output.of(nodeGroup));
        }

        /**
         * @param oauthScopes The set of Google API scopes to be made available
         * on all of the node VMs under the &#34;default&#34; service account.
         * Use the &#34;https://www.googleapis.com/auth/cloud-platform&#34; scope to grant access to all APIs. It is recommended that you set `service_account` to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
         * 
         * @return builder
         * 
         */
        public Builder oauthScopes(@Nullable Output<List<String>> oauthScopes) {
            $.oauthScopes = oauthScopes;
            return this;
        }

        /**
         * @param oauthScopes The set of Google API scopes to be made available
         * on all of the node VMs under the &#34;default&#34; service account.
         * Use the &#34;https://www.googleapis.com/auth/cloud-platform&#34; scope to grant access to all APIs. It is recommended that you set `service_account` to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
         * 
         * @return builder
         * 
         */
        public Builder oauthScopes(List<String> oauthScopes) {
            return oauthScopes(Output.of(oauthScopes));
        }

        /**
         * @param oauthScopes The set of Google API scopes to be made available
         * on all of the node VMs under the &#34;default&#34; service account.
         * Use the &#34;https://www.googleapis.com/auth/cloud-platform&#34; scope to grant access to all APIs. It is recommended that you set `service_account` to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
         * 
         * @return builder
         * 
         */
        public Builder oauthScopes(String... oauthScopes) {
            return oauthScopes(List.of(oauthScopes));
        }

        /**
         * @param preemptible A boolean that represents whether or not the underlying node VMs
         * are preemptible. See the [official documentation](https://cloud.google.com/container-engine/docs/preemptible-vm)
         * for more information. Defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder preemptible(@Nullable Output<Boolean> preemptible) {
            $.preemptible = preemptible;
            return this;
        }

        /**
         * @param preemptible A boolean that represents whether or not the underlying node VMs
         * are preemptible. See the [official documentation](https://cloud.google.com/container-engine/docs/preemptible-vm)
         * for more information. Defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder preemptible(Boolean preemptible) {
            return preemptible(Output.of(preemptible));
        }

        /**
         * @param reservationAffinity The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder reservationAffinity(@Nullable Output<ClusterNodePoolNodeConfigReservationAffinityArgs> reservationAffinity) {
            $.reservationAffinity = reservationAffinity;
            return this;
        }

        /**
         * @param reservationAffinity The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder reservationAffinity(ClusterNodePoolNodeConfigReservationAffinityArgs reservationAffinity) {
            return reservationAffinity(Output.of(reservationAffinity));
        }

        public Builder sandboxConfig(@Nullable Output<ClusterNodePoolNodeConfigSandboxConfigArgs> sandboxConfig) {
            $.sandboxConfig = sandboxConfig;
            return this;
        }

        public Builder sandboxConfig(ClusterNodePoolNodeConfigSandboxConfigArgs sandboxConfig) {
            return sandboxConfig(Output.of(sandboxConfig));
        }

        /**
         * @param serviceAccount The service account to be used by the Node VMs.
         * If not specified, the &#34;default&#34; service account is used.
         * 
         * @return builder
         * 
         */
        public Builder serviceAccount(@Nullable Output<String> serviceAccount) {
            $.serviceAccount = serviceAccount;
            return this;
        }

        /**
         * @param serviceAccount The service account to be used by the Node VMs.
         * If not specified, the &#34;default&#34; service account is used.
         * 
         * @return builder
         * 
         */
        public Builder serviceAccount(String serviceAccount) {
            return serviceAccount(Output.of(serviceAccount));
        }

        /**
         * @param shieldedInstanceConfig Shielded Instance options. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder shieldedInstanceConfig(@Nullable Output<ClusterNodePoolNodeConfigShieldedInstanceConfigArgs> shieldedInstanceConfig) {
            $.shieldedInstanceConfig = shieldedInstanceConfig;
            return this;
        }

        /**
         * @param shieldedInstanceConfig Shielded Instance options. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder shieldedInstanceConfig(ClusterNodePoolNodeConfigShieldedInstanceConfigArgs shieldedInstanceConfig) {
            return shieldedInstanceConfig(Output.of(shieldedInstanceConfig));
        }

        /**
         * @param spot A boolean that represents whether the underlying node VMs are spot.
         * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms)
         * for more information. Defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder spot(@Nullable Output<Boolean> spot) {
            $.spot = spot;
            return this;
        }

        /**
         * @param spot A boolean that represents whether the underlying node VMs are spot.
         * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms)
         * for more information. Defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder spot(Boolean spot) {
            return spot(Output.of(spot));
        }

        /**
         * @param tags ) - List of network tags applied to auto-provisioned node pools.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<List<String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags ) - List of network tags applied to auto-provisioned node pools.
         * 
         * @return builder
         * 
         */
        public Builder tags(List<String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tags ) - List of network tags applied to auto-provisioned node pools.
         * 
         * @return builder
         * 
         */
        public Builder tags(String... tags) {
            return tags(List.of(tags));
        }

        /**
         * @param taints A list of [Kubernetes taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/)
         * to apply to nodes. GKE&#39;s API can only set this field on cluster creation.
         * However, GKE will add taints to your nodes if you enable certain features such
         * as GPUs. If this field is set, any diffs on this field will cause the provider to
         * recreate the underlying resource. Taint values can be updated safely in
         * Kubernetes (eg. through `kubectl`), and it&#39;s recommended that you do not use
         * this field to manage taints. If you do, `lifecycle.ignore_changes` is
         * recommended. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder taints(@Nullable Output<List<ClusterNodePoolNodeConfigTaintArgs>> taints) {
            $.taints = taints;
            return this;
        }

        /**
         * @param taints A list of [Kubernetes taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/)
         * to apply to nodes. GKE&#39;s API can only set this field on cluster creation.
         * However, GKE will add taints to your nodes if you enable certain features such
         * as GPUs. If this field is set, any diffs on this field will cause the provider to
         * recreate the underlying resource. Taint values can be updated safely in
         * Kubernetes (eg. through `kubectl`), and it&#39;s recommended that you do not use
         * this field to manage taints. If you do, `lifecycle.ignore_changes` is
         * recommended. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder taints(List<ClusterNodePoolNodeConfigTaintArgs> taints) {
            return taints(Output.of(taints));
        }

        /**
         * @param taints A list of [Kubernetes taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/)
         * to apply to nodes. GKE&#39;s API can only set this field on cluster creation.
         * However, GKE will add taints to your nodes if you enable certain features such
         * as GPUs. If this field is set, any diffs on this field will cause the provider to
         * recreate the underlying resource. Taint values can be updated safely in
         * Kubernetes (eg. through `kubectl`), and it&#39;s recommended that you do not use
         * this field to manage taints. If you do, `lifecycle.ignore_changes` is
         * recommended. Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder taints(ClusterNodePoolNodeConfigTaintArgs... taints) {
            return taints(List.of(taints));
        }

        /**
         * @param workloadMetadataConfig Metadata configuration to expose to workloads on the node pool.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder workloadMetadataConfig(@Nullable Output<ClusterNodePoolNodeConfigWorkloadMetadataConfigArgs> workloadMetadataConfig) {
            $.workloadMetadataConfig = workloadMetadataConfig;
            return this;
        }

        /**
         * @param workloadMetadataConfig Metadata configuration to expose to workloads on the node pool.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder workloadMetadataConfig(ClusterNodePoolNodeConfigWorkloadMetadataConfigArgs workloadMetadataConfig) {
            return workloadMetadataConfig(Output.of(workloadMetadataConfig));
        }

        public ClusterNodePoolNodeConfigArgs build() {
            return $;
        }
    }

}
