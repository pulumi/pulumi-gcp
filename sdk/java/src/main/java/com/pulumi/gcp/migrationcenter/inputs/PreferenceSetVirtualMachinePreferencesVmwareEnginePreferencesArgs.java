// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.migrationcenter.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Double;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs extends com.pulumi.resources.ResourceArgs {

    public static final PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs Empty = new PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs();

    /**
     * Commitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with. Possible values: `COMMITMENT_PLAN_UNSPECIFIED`, `ON_DEMAND`, `COMMITMENT_1_YEAR_MONTHLY_PAYMENTS`, `COMMITMENT_3_YEAR_MONTHLY_PAYMENTS`, `COMMITMENT_1_YEAR_UPFRONT_PAYMENT`, `COMMITMENT_3_YEAR_UPFRONT_PAYMENT`,
     * 
     */
    @Import(name="commitmentPlan")
    private @Nullable Output<String> commitmentPlan;

    /**
     * @return Commitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with. Possible values: `COMMITMENT_PLAN_UNSPECIFIED`, `ON_DEMAND`, `COMMITMENT_1_YEAR_MONTHLY_PAYMENTS`, `COMMITMENT_3_YEAR_MONTHLY_PAYMENTS`, `COMMITMENT_1_YEAR_UPFRONT_PAYMENT`, `COMMITMENT_3_YEAR_UPFRONT_PAYMENT`,
     * 
     */
    public Optional<Output<String>> commitmentPlan() {
        return Optional.ofNullable(this.commitmentPlan);
    }

    /**
     * CPU overcommit ratio. Acceptable values are between 1.0 and 8.0, with 0.1 increment.
     * 
     */
    @Import(name="cpuOvercommitRatio")
    private @Nullable Output<Double> cpuOvercommitRatio;

    /**
     * @return CPU overcommit ratio. Acceptable values are between 1.0 and 8.0, with 0.1 increment.
     * 
     */
    public Optional<Output<Double>> cpuOvercommitRatio() {
        return Optional.ofNullable(this.cpuOvercommitRatio);
    }

    /**
     * Memory overcommit ratio. Acceptable values are 1.0, 1.25, 1.5, 1.75 and 2.0.
     * 
     */
    @Import(name="memoryOvercommitRatio")
    private @Nullable Output<Double> memoryOvercommitRatio;

    /**
     * @return Memory overcommit ratio. Acceptable values are 1.0, 1.25, 1.5, 1.75 and 2.0.
     * 
     */
    public Optional<Output<Double>> memoryOvercommitRatio() {
        return Optional.ofNullable(this.memoryOvercommitRatio);
    }

    /**
     * The Deduplication and Compression ratio is based on the logical (Used Before) space required to store data before applying deduplication and compression, in relation to the physical (Used After) space required after applying deduplication and compression. Specifically, the ratio is the Used Before space divided by the Used After space. For example, if the Used Before space is 3 GB, but the physical Used After space is 1 GB, the deduplication and compression ratio is 3x. Acceptable values are between 1.0 and 4.0.
     * 
     */
    @Import(name="storageDeduplicationCompressionRatio")
    private @Nullable Output<Double> storageDeduplicationCompressionRatio;

    /**
     * @return The Deduplication and Compression ratio is based on the logical (Used Before) space required to store data before applying deduplication and compression, in relation to the physical (Used After) space required after applying deduplication and compression. Specifically, the ratio is the Used Before space divided by the Used After space. For example, if the Used Before space is 3 GB, but the physical Used After space is 1 GB, the deduplication and compression ratio is 3x. Acceptable values are between 1.0 and 4.0.
     * 
     */
    public Optional<Output<Double>> storageDeduplicationCompressionRatio() {
        return Optional.ofNullable(this.storageDeduplicationCompressionRatio);
    }

    private PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs() {}

    private PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs(PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs $) {
        this.commitmentPlan = $.commitmentPlan;
        this.cpuOvercommitRatio = $.cpuOvercommitRatio;
        this.memoryOvercommitRatio = $.memoryOvercommitRatio;
        this.storageDeduplicationCompressionRatio = $.storageDeduplicationCompressionRatio;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs $;

        public Builder() {
            $ = new PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs();
        }

        public Builder(PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs defaults) {
            $ = new PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param commitmentPlan Commitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with. Possible values: `COMMITMENT_PLAN_UNSPECIFIED`, `ON_DEMAND`, `COMMITMENT_1_YEAR_MONTHLY_PAYMENTS`, `COMMITMENT_3_YEAR_MONTHLY_PAYMENTS`, `COMMITMENT_1_YEAR_UPFRONT_PAYMENT`, `COMMITMENT_3_YEAR_UPFRONT_PAYMENT`,
         * 
         * @return builder
         * 
         */
        public Builder commitmentPlan(@Nullable Output<String> commitmentPlan) {
            $.commitmentPlan = commitmentPlan;
            return this;
        }

        /**
         * @param commitmentPlan Commitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with. Possible values: `COMMITMENT_PLAN_UNSPECIFIED`, `ON_DEMAND`, `COMMITMENT_1_YEAR_MONTHLY_PAYMENTS`, `COMMITMENT_3_YEAR_MONTHLY_PAYMENTS`, `COMMITMENT_1_YEAR_UPFRONT_PAYMENT`, `COMMITMENT_3_YEAR_UPFRONT_PAYMENT`,
         * 
         * @return builder
         * 
         */
        public Builder commitmentPlan(String commitmentPlan) {
            return commitmentPlan(Output.of(commitmentPlan));
        }

        /**
         * @param cpuOvercommitRatio CPU overcommit ratio. Acceptable values are between 1.0 and 8.0, with 0.1 increment.
         * 
         * @return builder
         * 
         */
        public Builder cpuOvercommitRatio(@Nullable Output<Double> cpuOvercommitRatio) {
            $.cpuOvercommitRatio = cpuOvercommitRatio;
            return this;
        }

        /**
         * @param cpuOvercommitRatio CPU overcommit ratio. Acceptable values are between 1.0 and 8.0, with 0.1 increment.
         * 
         * @return builder
         * 
         */
        public Builder cpuOvercommitRatio(Double cpuOvercommitRatio) {
            return cpuOvercommitRatio(Output.of(cpuOvercommitRatio));
        }

        /**
         * @param memoryOvercommitRatio Memory overcommit ratio. Acceptable values are 1.0, 1.25, 1.5, 1.75 and 2.0.
         * 
         * @return builder
         * 
         */
        public Builder memoryOvercommitRatio(@Nullable Output<Double> memoryOvercommitRatio) {
            $.memoryOvercommitRatio = memoryOvercommitRatio;
            return this;
        }

        /**
         * @param memoryOvercommitRatio Memory overcommit ratio. Acceptable values are 1.0, 1.25, 1.5, 1.75 and 2.0.
         * 
         * @return builder
         * 
         */
        public Builder memoryOvercommitRatio(Double memoryOvercommitRatio) {
            return memoryOvercommitRatio(Output.of(memoryOvercommitRatio));
        }

        /**
         * @param storageDeduplicationCompressionRatio The Deduplication and Compression ratio is based on the logical (Used Before) space required to store data before applying deduplication and compression, in relation to the physical (Used After) space required after applying deduplication and compression. Specifically, the ratio is the Used Before space divided by the Used After space. For example, if the Used Before space is 3 GB, but the physical Used After space is 1 GB, the deduplication and compression ratio is 3x. Acceptable values are between 1.0 and 4.0.
         * 
         * @return builder
         * 
         */
        public Builder storageDeduplicationCompressionRatio(@Nullable Output<Double> storageDeduplicationCompressionRatio) {
            $.storageDeduplicationCompressionRatio = storageDeduplicationCompressionRatio;
            return this;
        }

        /**
         * @param storageDeduplicationCompressionRatio The Deduplication and Compression ratio is based on the logical (Used Before) space required to store data before applying deduplication and compression, in relation to the physical (Used After) space required after applying deduplication and compression. Specifically, the ratio is the Used Before space divided by the Used After space. For example, if the Used Before space is 3 GB, but the physical Used After space is 1 GB, the deduplication and compression ratio is 3x. Acceptable values are between 1.0 and 4.0.
         * 
         * @return builder
         * 
         */
        public Builder storageDeduplicationCompressionRatio(Double storageDeduplicationCompressionRatio) {
            return storageDeduplicationCompressionRatio(Output.of(storageDeduplicationCompressionRatio));
        }

        public PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs build() {
            return $;
        }
    }

}
