// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.gcp.compute.outputs.BackendServiceCdnPolicyBypassCacheOnRequestHeader;
import com.pulumi.gcp.compute.outputs.BackendServiceCdnPolicyCacheKeyPolicy;
import com.pulumi.gcp.compute.outputs.BackendServiceCdnPolicyNegativeCachingPolicy;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class BackendServiceCdnPolicy {
    /**
     * @return Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
     * The cache is bypassed for all cdnPolicy.cacheMode settings.
     * Structure is documented below.
     * 
     */
    private @Nullable List<BackendServiceCdnPolicyBypassCacheOnRequestHeader> bypassCacheOnRequestHeaders;
    /**
     * @return The CacheKeyPolicy for this CdnPolicy.
     * Structure is documented below.
     * 
     */
    private @Nullable BackendServiceCdnPolicyCacheKeyPolicy cacheKeyPolicy;
    /**
     * @return Specifies the cache setting for all responses from this backend.
     * The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
     * Possible values are: `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, `CACHE_ALL_STATIC`.
     * 
     */
    private @Nullable String cacheMode;
    /**
     * @return Specifies the maximum allowed TTL for cached content served by this origin.
     * 
     */
    private @Nullable Integer clientTtl;
    /**
     * @return Specifies the default TTL for cached content served by this origin for responses
     * that do not have an existing valid TTL (max-age or s-max-age).
     * 
     */
    private @Nullable Integer defaultTtl;
    /**
     * @return Specifies the maximum allowed TTL for cached content served by this origin.
     * 
     */
    private @Nullable Integer maxTtl;
    /**
     * @return Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
     * 
     */
    private @Nullable Boolean negativeCaching;
    /**
     * @return Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
     * Omitting the policy and leaving negativeCaching enabled will use Cloud CDN&#39;s default cache TTLs.
     * Structure is documented below.
     * 
     */
    private @Nullable List<BackendServiceCdnPolicyNegativeCachingPolicy> negativeCachingPolicies;
    /**
     * @return If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests
     * to the origin.
     * 
     */
    private @Nullable Boolean requestCoalescing;
    /**
     * @return Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
     * 
     */
    private @Nullable Integer serveWhileStale;
    /**
     * @return Maximum number of seconds the response to a signed URL request
     * will be considered fresh, defaults to 1hr (3600s). After this
     * time period, the response will be revalidated before
     * being served.
     * When serving responses to signed URL requests, Cloud CDN will
     * internally behave as though all responses from this backend had a
     * &#34;Cache-Control: public, max-age=[TTL]&#34; header, regardless of any
     * existing Cache-Control header. The actual headers served in
     * responses will not be altered.
     * 
     */
    private @Nullable Integer signedUrlCacheMaxAgeSec;

    private BackendServiceCdnPolicy() {}
    /**
     * @return Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
     * The cache is bypassed for all cdnPolicy.cacheMode settings.
     * Structure is documented below.
     * 
     */
    public List<BackendServiceCdnPolicyBypassCacheOnRequestHeader> bypassCacheOnRequestHeaders() {
        return this.bypassCacheOnRequestHeaders == null ? List.of() : this.bypassCacheOnRequestHeaders;
    }
    /**
     * @return The CacheKeyPolicy for this CdnPolicy.
     * Structure is documented below.
     * 
     */
    public Optional<BackendServiceCdnPolicyCacheKeyPolicy> cacheKeyPolicy() {
        return Optional.ofNullable(this.cacheKeyPolicy);
    }
    /**
     * @return Specifies the cache setting for all responses from this backend.
     * The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
     * Possible values are: `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, `CACHE_ALL_STATIC`.
     * 
     */
    public Optional<String> cacheMode() {
        return Optional.ofNullable(this.cacheMode);
    }
    /**
     * @return Specifies the maximum allowed TTL for cached content served by this origin.
     * 
     */
    public Optional<Integer> clientTtl() {
        return Optional.ofNullable(this.clientTtl);
    }
    /**
     * @return Specifies the default TTL for cached content served by this origin for responses
     * that do not have an existing valid TTL (max-age or s-max-age).
     * 
     */
    public Optional<Integer> defaultTtl() {
        return Optional.ofNullable(this.defaultTtl);
    }
    /**
     * @return Specifies the maximum allowed TTL for cached content served by this origin.
     * 
     */
    public Optional<Integer> maxTtl() {
        return Optional.ofNullable(this.maxTtl);
    }
    /**
     * @return Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
     * 
     */
    public Optional<Boolean> negativeCaching() {
        return Optional.ofNullable(this.negativeCaching);
    }
    /**
     * @return Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
     * Omitting the policy and leaving negativeCaching enabled will use Cloud CDN&#39;s default cache TTLs.
     * Structure is documented below.
     * 
     */
    public List<BackendServiceCdnPolicyNegativeCachingPolicy> negativeCachingPolicies() {
        return this.negativeCachingPolicies == null ? List.of() : this.negativeCachingPolicies;
    }
    /**
     * @return If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests
     * to the origin.
     * 
     */
    public Optional<Boolean> requestCoalescing() {
        return Optional.ofNullable(this.requestCoalescing);
    }
    /**
     * @return Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
     * 
     */
    public Optional<Integer> serveWhileStale() {
        return Optional.ofNullable(this.serveWhileStale);
    }
    /**
     * @return Maximum number of seconds the response to a signed URL request
     * will be considered fresh, defaults to 1hr (3600s). After this
     * time period, the response will be revalidated before
     * being served.
     * When serving responses to signed URL requests, Cloud CDN will
     * internally behave as though all responses from this backend had a
     * &#34;Cache-Control: public, max-age=[TTL]&#34; header, regardless of any
     * existing Cache-Control header. The actual headers served in
     * responses will not be altered.
     * 
     */
    public Optional<Integer> signedUrlCacheMaxAgeSec() {
        return Optional.ofNullable(this.signedUrlCacheMaxAgeSec);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(BackendServiceCdnPolicy defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable List<BackendServiceCdnPolicyBypassCacheOnRequestHeader> bypassCacheOnRequestHeaders;
        private @Nullable BackendServiceCdnPolicyCacheKeyPolicy cacheKeyPolicy;
        private @Nullable String cacheMode;
        private @Nullable Integer clientTtl;
        private @Nullable Integer defaultTtl;
        private @Nullable Integer maxTtl;
        private @Nullable Boolean negativeCaching;
        private @Nullable List<BackendServiceCdnPolicyNegativeCachingPolicy> negativeCachingPolicies;
        private @Nullable Boolean requestCoalescing;
        private @Nullable Integer serveWhileStale;
        private @Nullable Integer signedUrlCacheMaxAgeSec;
        public Builder() {}
        public Builder(BackendServiceCdnPolicy defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.bypassCacheOnRequestHeaders = defaults.bypassCacheOnRequestHeaders;
    	      this.cacheKeyPolicy = defaults.cacheKeyPolicy;
    	      this.cacheMode = defaults.cacheMode;
    	      this.clientTtl = defaults.clientTtl;
    	      this.defaultTtl = defaults.defaultTtl;
    	      this.maxTtl = defaults.maxTtl;
    	      this.negativeCaching = defaults.negativeCaching;
    	      this.negativeCachingPolicies = defaults.negativeCachingPolicies;
    	      this.requestCoalescing = defaults.requestCoalescing;
    	      this.serveWhileStale = defaults.serveWhileStale;
    	      this.signedUrlCacheMaxAgeSec = defaults.signedUrlCacheMaxAgeSec;
        }

        @CustomType.Setter
        public Builder bypassCacheOnRequestHeaders(@Nullable List<BackendServiceCdnPolicyBypassCacheOnRequestHeader> bypassCacheOnRequestHeaders) {

            this.bypassCacheOnRequestHeaders = bypassCacheOnRequestHeaders;
            return this;
        }
        public Builder bypassCacheOnRequestHeaders(BackendServiceCdnPolicyBypassCacheOnRequestHeader... bypassCacheOnRequestHeaders) {
            return bypassCacheOnRequestHeaders(List.of(bypassCacheOnRequestHeaders));
        }
        @CustomType.Setter
        public Builder cacheKeyPolicy(@Nullable BackendServiceCdnPolicyCacheKeyPolicy cacheKeyPolicy) {

            this.cacheKeyPolicy = cacheKeyPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder cacheMode(@Nullable String cacheMode) {

            this.cacheMode = cacheMode;
            return this;
        }
        @CustomType.Setter
        public Builder clientTtl(@Nullable Integer clientTtl) {

            this.clientTtl = clientTtl;
            return this;
        }
        @CustomType.Setter
        public Builder defaultTtl(@Nullable Integer defaultTtl) {

            this.defaultTtl = defaultTtl;
            return this;
        }
        @CustomType.Setter
        public Builder maxTtl(@Nullable Integer maxTtl) {

            this.maxTtl = maxTtl;
            return this;
        }
        @CustomType.Setter
        public Builder negativeCaching(@Nullable Boolean negativeCaching) {

            this.negativeCaching = negativeCaching;
            return this;
        }
        @CustomType.Setter
        public Builder negativeCachingPolicies(@Nullable List<BackendServiceCdnPolicyNegativeCachingPolicy> negativeCachingPolicies) {

            this.negativeCachingPolicies = negativeCachingPolicies;
            return this;
        }
        public Builder negativeCachingPolicies(BackendServiceCdnPolicyNegativeCachingPolicy... negativeCachingPolicies) {
            return negativeCachingPolicies(List.of(negativeCachingPolicies));
        }
        @CustomType.Setter
        public Builder requestCoalescing(@Nullable Boolean requestCoalescing) {

            this.requestCoalescing = requestCoalescing;
            return this;
        }
        @CustomType.Setter
        public Builder serveWhileStale(@Nullable Integer serveWhileStale) {

            this.serveWhileStale = serveWhileStale;
            return this;
        }
        @CustomType.Setter
        public Builder signedUrlCacheMaxAgeSec(@Nullable Integer signedUrlCacheMaxAgeSec) {

            this.signedUrlCacheMaxAgeSec = signedUrlCacheMaxAgeSec;
            return this;
        }
        public BackendServiceCdnPolicy build() {
            final var _resultValue = new BackendServiceCdnPolicy();
            _resultValue.bypassCacheOnRequestHeaders = bypassCacheOnRequestHeaders;
            _resultValue.cacheKeyPolicy = cacheKeyPolicy;
            _resultValue.cacheMode = cacheMode;
            _resultValue.clientTtl = clientTtl;
            _resultValue.defaultTtl = defaultTtl;
            _resultValue.maxTtl = maxTtl;
            _resultValue.negativeCaching = negativeCaching;
            _resultValue.negativeCachingPolicies = negativeCachingPolicies;
            _resultValue.requestCoalescing = requestCoalescing;
            _resultValue.serveWhileStale = serveWhileStale;
            _resultValue.signedUrlCacheMaxAgeSec = signedUrlCacheMaxAgeSec;
            return _resultValue;
        }
    }
}
