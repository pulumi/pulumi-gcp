// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.pubsub;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.pubsub.inputs.SubscriptionBigqueryConfigArgs;
import com.pulumi.gcp.pubsub.inputs.SubscriptionCloudStorageConfigArgs;
import com.pulumi.gcp.pubsub.inputs.SubscriptionDeadLetterPolicyArgs;
import com.pulumi.gcp.pubsub.inputs.SubscriptionExpirationPolicyArgs;
import com.pulumi.gcp.pubsub.inputs.SubscriptionMessageTransformArgs;
import com.pulumi.gcp.pubsub.inputs.SubscriptionPushConfigArgs;
import com.pulumi.gcp.pubsub.inputs.SubscriptionRetryPolicyArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class SubscriptionArgs extends com.pulumi.resources.ResourceArgs {

    public static final SubscriptionArgs Empty = new SubscriptionArgs();

    /**
     * This value is the maximum time after a subscriber receives a message
     * before the subscriber should acknowledge the message. After message
     * delivery but before the ack deadline expires and before the message is
     * acknowledged, it is an outstanding message and will not be delivered
     * again during that time (on a best-effort basis).
     * For pull subscriptions, this value is used as the initial value for
     * the ack deadline. To override this value for a given message, call
     * subscriptions.modifyAckDeadline with the corresponding ackId if using
     * pull. The minimum custom deadline you can specify is 10 seconds. The
     * maximum custom deadline you can specify is 600 seconds (10 minutes).
     * If this parameter is 0, a default value of 10 seconds is used.
     * For push delivery, this value is also used to set the request timeout
     * for the call to the push endpoint.
     * If the subscriber never acknowledges the message, the Pub/Sub system
     * will eventually redeliver the message.
     * 
     */
    @Import(name="ackDeadlineSeconds")
    private @Nullable Output<Integer> ackDeadlineSeconds;

    /**
     * @return This value is the maximum time after a subscriber receives a message
     * before the subscriber should acknowledge the message. After message
     * delivery but before the ack deadline expires and before the message is
     * acknowledged, it is an outstanding message and will not be delivered
     * again during that time (on a best-effort basis).
     * For pull subscriptions, this value is used as the initial value for
     * the ack deadline. To override this value for a given message, call
     * subscriptions.modifyAckDeadline with the corresponding ackId if using
     * pull. The minimum custom deadline you can specify is 10 seconds. The
     * maximum custom deadline you can specify is 600 seconds (10 minutes).
     * If this parameter is 0, a default value of 10 seconds is used.
     * For push delivery, this value is also used to set the request timeout
     * for the call to the push endpoint.
     * If the subscriber never acknowledges the message, the Pub/Sub system
     * will eventually redeliver the message.
     * 
     */
    public Optional<Output<Integer>> ackDeadlineSeconds() {
        return Optional.ofNullable(this.ackDeadlineSeconds);
    }

    /**
     * If delivery to BigQuery is used with this subscription, this field is used to configure it.
     * Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
     * If all three are empty, then the subscriber will pull and ack messages using API methods.
     * Structure is documented below.
     * 
     */
    @Import(name="bigqueryConfig")
    private @Nullable Output<SubscriptionBigqueryConfigArgs> bigqueryConfig;

    /**
     * @return If delivery to BigQuery is used with this subscription, this field is used to configure it.
     * Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
     * If all three are empty, then the subscriber will pull and ack messages using API methods.
     * Structure is documented below.
     * 
     */
    public Optional<Output<SubscriptionBigqueryConfigArgs>> bigqueryConfig() {
        return Optional.ofNullable(this.bigqueryConfig);
    }

    /**
     * If delivery to Cloud Storage is used with this subscription, this field is used to configure it.
     * Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
     * If all three are empty, then the subscriber will pull and ack messages using API methods.
     * Structure is documented below.
     * 
     */
    @Import(name="cloudStorageConfig")
    private @Nullable Output<SubscriptionCloudStorageConfigArgs> cloudStorageConfig;

    /**
     * @return If delivery to Cloud Storage is used with this subscription, this field is used to configure it.
     * Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
     * If all three are empty, then the subscriber will pull and ack messages using API methods.
     * Structure is documented below.
     * 
     */
    public Optional<Output<SubscriptionCloudStorageConfigArgs>> cloudStorageConfig() {
        return Optional.ofNullable(this.cloudStorageConfig);
    }

    /**
     * A policy that specifies the conditions for dead lettering messages in
     * this subscription. If dead_letter_policy is not set, dead lettering
     * is disabled.
     * The Cloud Pub/Sub service account associated with this subscription&#39;s
     * parent project (i.e.,
     * service-{project_number}{@literal @}gcp-sa-pubsub.iam.gserviceaccount.com) must have
     * permission to Acknowledge() messages on this subscription.
     * Structure is documented below.
     * 
     */
    @Import(name="deadLetterPolicy")
    private @Nullable Output<SubscriptionDeadLetterPolicyArgs> deadLetterPolicy;

    /**
     * @return A policy that specifies the conditions for dead lettering messages in
     * this subscription. If dead_letter_policy is not set, dead lettering
     * is disabled.
     * The Cloud Pub/Sub service account associated with this subscription&#39;s
     * parent project (i.e.,
     * service-{project_number}{@literal @}gcp-sa-pubsub.iam.gserviceaccount.com) must have
     * permission to Acknowledge() messages on this subscription.
     * Structure is documented below.
     * 
     */
    public Optional<Output<SubscriptionDeadLetterPolicyArgs>> deadLetterPolicy() {
        return Optional.ofNullable(this.deadLetterPolicy);
    }

    /**
     * If `true`, Pub/Sub provides the following guarantees for the delivery
     * of a message with a given value of messageId on this Subscriptions&#39;:
     * - The message sent to a subscriber is guaranteed not to be resent before the message&#39;s acknowledgement deadline expires.
     * - An acknowledged message will not be resent to a subscriber.
     *   Note that subscribers may still receive multiple copies of a message when `enable_exactly_once_delivery`
     *   is true if the message was published multiple times by a publisher client. These copies are considered distinct by Pub/Sub and have distinct messageId values
     * 
     */
    @Import(name="enableExactlyOnceDelivery")
    private @Nullable Output<Boolean> enableExactlyOnceDelivery;

    /**
     * @return If `true`, Pub/Sub provides the following guarantees for the delivery
     * of a message with a given value of messageId on this Subscriptions&#39;:
     * - The message sent to a subscriber is guaranteed not to be resent before the message&#39;s acknowledgement deadline expires.
     * - An acknowledged message will not be resent to a subscriber.
     *   Note that subscribers may still receive multiple copies of a message when `enable_exactly_once_delivery`
     *   is true if the message was published multiple times by a publisher client. These copies are considered distinct by Pub/Sub and have distinct messageId values
     * 
     */
    public Optional<Output<Boolean>> enableExactlyOnceDelivery() {
        return Optional.ofNullable(this.enableExactlyOnceDelivery);
    }

    /**
     * If `true`, messages published with the same orderingKey in PubsubMessage will be delivered to
     * the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they
     * may be delivered in any order.
     * 
     */
    @Import(name="enableMessageOrdering")
    private @Nullable Output<Boolean> enableMessageOrdering;

    /**
     * @return If `true`, messages published with the same orderingKey in PubsubMessage will be delivered to
     * the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they
     * may be delivered in any order.
     * 
     */
    public Optional<Output<Boolean>> enableMessageOrdering() {
        return Optional.ofNullable(this.enableMessageOrdering);
    }

    /**
     * A policy that specifies the conditions for this subscription&#39;s expiration.
     * A subscription is considered active as long as any connected subscriber
     * is successfully consuming messages from the subscription or is issuing
     * operations on the subscription. If expirationPolicy is not set, a default
     * policy with ttl of 31 days will be used.  If it is set but ttl is &#34;&#34;, the
     * resource never expires.  The minimum allowed value for expirationPolicy.ttl
     * is 1 day.
     * Structure is documented below.
     * 
     */
    @Import(name="expirationPolicy")
    private @Nullable Output<SubscriptionExpirationPolicyArgs> expirationPolicy;

    /**
     * @return A policy that specifies the conditions for this subscription&#39;s expiration.
     * A subscription is considered active as long as any connected subscriber
     * is successfully consuming messages from the subscription or is issuing
     * operations on the subscription. If expirationPolicy is not set, a default
     * policy with ttl of 31 days will be used.  If it is set but ttl is &#34;&#34;, the
     * resource never expires.  The minimum allowed value for expirationPolicy.ttl
     * is 1 day.
     * Structure is documented below.
     * 
     */
    public Optional<Output<SubscriptionExpirationPolicyArgs>> expirationPolicy() {
        return Optional.ofNullable(this.expirationPolicy);
    }

    /**
     * The subscription only delivers the messages that match the filter.
     * Pub/Sub automatically acknowledges the messages that don&#39;t match the filter. You can filter messages
     * by their attributes. The maximum length of a filter is 256 bytes. After creating the subscription,
     * you can&#39;t modify the filter.
     * 
     */
    @Import(name="filter")
    private @Nullable Output<String> filter;

    /**
     * @return The subscription only delivers the messages that match the filter.
     * Pub/Sub automatically acknowledges the messages that don&#39;t match the filter. You can filter messages
     * by their attributes. The maximum length of a filter is 256 bytes. After creating the subscription,
     * you can&#39;t modify the filter.
     * 
     */
    public Optional<Output<String>> filter() {
        return Optional.ofNullable(this.filter);
    }

    /**
     * A set of key/value label pairs to assign to this Subscription.
     * 
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effective_labels` for all of the labels present on the resource.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    /**
     * @return A set of key/value label pairs to assign to this Subscription.
     * 
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effective_labels` for all of the labels present on the resource.
     * 
     */
    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * How long to retain unacknowledged messages in the subscription&#39;s
     * backlog, from the moment a message is published. If
     * retain_acked_messages is true, then this also configures the retention
     * of acknowledged messages, and thus configures how far back in time a
     * subscriptions.seek can be done. Defaults to 7 days. Cannot be more
     * than 31 days (`&#34;2678400s&#34;`) or less than 10 minutes (`&#34;600s&#34;`).
     * A duration in seconds with up to nine fractional digits, terminated
     * by &#39;s&#39;. Example: `&#34;600.5s&#34;`.
     * 
     */
    @Import(name="messageRetentionDuration")
    private @Nullable Output<String> messageRetentionDuration;

    /**
     * @return How long to retain unacknowledged messages in the subscription&#39;s
     * backlog, from the moment a message is published. If
     * retain_acked_messages is true, then this also configures the retention
     * of acknowledged messages, and thus configures how far back in time a
     * subscriptions.seek can be done. Defaults to 7 days. Cannot be more
     * than 31 days (`&#34;2678400s&#34;`) or less than 10 minutes (`&#34;600s&#34;`).
     * A duration in seconds with up to nine fractional digits, terminated
     * by &#39;s&#39;. Example: `&#34;600.5s&#34;`.
     * 
     */
    public Optional<Output<String>> messageRetentionDuration() {
        return Optional.ofNullable(this.messageRetentionDuration);
    }

    /**
     * Transforms to be applied to messages published to the topic. Transforms are applied in the
     * order specified.
     * Structure is documented below.
     * 
     */
    @Import(name="messageTransforms")
    private @Nullable Output<List<SubscriptionMessageTransformArgs>> messageTransforms;

    /**
     * @return Transforms to be applied to messages published to the topic. Transforms are applied in the
     * order specified.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<SubscriptionMessageTransformArgs>>> messageTransforms() {
        return Optional.ofNullable(this.messageTransforms);
    }

    /**
     * Name of the subscription.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return Name of the subscription.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * If push delivery is used with this subscription, this field is used to
     * configure it. An empty pushConfig signifies that the subscriber will
     * pull and ack messages using API methods.
     * Structure is documented below.
     * 
     */
    @Import(name="pushConfig")
    private @Nullable Output<SubscriptionPushConfigArgs> pushConfig;

    /**
     * @return If push delivery is used with this subscription, this field is used to
     * configure it. An empty pushConfig signifies that the subscriber will
     * pull and ack messages using API methods.
     * Structure is documented below.
     * 
     */
    public Optional<Output<SubscriptionPushConfigArgs>> pushConfig() {
        return Optional.ofNullable(this.pushConfig);
    }

    /**
     * Indicates whether to retain acknowledged messages. If `true`, then
     * messages are not expunged from the subscription&#39;s backlog, even if
     * they are acknowledged, until they fall out of the
     * messageRetentionDuration window.
     * 
     */
    @Import(name="retainAckedMessages")
    private @Nullable Output<Boolean> retainAckedMessages;

    /**
     * @return Indicates whether to retain acknowledged messages. If `true`, then
     * messages are not expunged from the subscription&#39;s backlog, even if
     * they are acknowledged, until they fall out of the
     * messageRetentionDuration window.
     * 
     */
    public Optional<Output<Boolean>> retainAckedMessages() {
        return Optional.ofNullable(this.retainAckedMessages);
    }

    /**
     * A policy that specifies how Pub/Sub retries message delivery for this subscription.
     * If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
     * RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
     * Structure is documented below.
     * 
     */
    @Import(name="retryPolicy")
    private @Nullable Output<SubscriptionRetryPolicyArgs> retryPolicy;

    /**
     * @return A policy that specifies how Pub/Sub retries message delivery for this subscription.
     * If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
     * RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
     * Structure is documented below.
     * 
     */
    public Optional<Output<SubscriptionRetryPolicyArgs>> retryPolicy() {
        return Optional.ofNullable(this.retryPolicy);
    }

    /**
     * Input only. Resource manager tags to be bound to the subscription. Tag
     * keys and values have the same definition as resource manager tags. Keys
     * must be in the format tagKeys/{tag_key_id}, and values are in the format
     * tagValues/456. The field is ignored when empty. The field is immutable and
     * causes resource replacement when mutated. This field is only set at create
     * time and modifying this field after creation will trigger recreation. To
     * apply tags to an existing resource, see the `gcp.tags.TagValue`
     * resource.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<Map<String,String>> tags;

    /**
     * @return Input only. Resource manager tags to be bound to the subscription. Tag
     * keys and values have the same definition as resource manager tags. Keys
     * must be in the format tagKeys/{tag_key_id}, and values are in the format
     * tagValues/456. The field is ignored when empty. The field is immutable and
     * causes resource replacement when mutated. This field is only set at create
     * time and modifying this field after creation will trigger recreation. To
     * apply tags to an existing resource, see the `gcp.tags.TagValue`
     * resource.
     * 
     */
    public Optional<Output<Map<String,String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * A reference to a Topic resource, of the form projects/{project}/topics/{{name}}
     * (as in the id property of a google_pubsub_topic), or just a topic name if
     * the topic is in the same project as the subscription.
     * 
     */
    @Import(name="topic", required=true)
    private Output<String> topic;

    /**
     * @return A reference to a Topic resource, of the form projects/{project}/topics/{{name}}
     * (as in the id property of a google_pubsub_topic), or just a topic name if
     * the topic is in the same project as the subscription.
     * 
     */
    public Output<String> topic() {
        return this.topic;
    }

    private SubscriptionArgs() {}

    private SubscriptionArgs(SubscriptionArgs $) {
        this.ackDeadlineSeconds = $.ackDeadlineSeconds;
        this.bigqueryConfig = $.bigqueryConfig;
        this.cloudStorageConfig = $.cloudStorageConfig;
        this.deadLetterPolicy = $.deadLetterPolicy;
        this.enableExactlyOnceDelivery = $.enableExactlyOnceDelivery;
        this.enableMessageOrdering = $.enableMessageOrdering;
        this.expirationPolicy = $.expirationPolicy;
        this.filter = $.filter;
        this.labels = $.labels;
        this.messageRetentionDuration = $.messageRetentionDuration;
        this.messageTransforms = $.messageTransforms;
        this.name = $.name;
        this.project = $.project;
        this.pushConfig = $.pushConfig;
        this.retainAckedMessages = $.retainAckedMessages;
        this.retryPolicy = $.retryPolicy;
        this.tags = $.tags;
        this.topic = $.topic;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(SubscriptionArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private SubscriptionArgs $;

        public Builder() {
            $ = new SubscriptionArgs();
        }

        public Builder(SubscriptionArgs defaults) {
            $ = new SubscriptionArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param ackDeadlineSeconds This value is the maximum time after a subscriber receives a message
         * before the subscriber should acknowledge the message. After message
         * delivery but before the ack deadline expires and before the message is
         * acknowledged, it is an outstanding message and will not be delivered
         * again during that time (on a best-effort basis).
         * For pull subscriptions, this value is used as the initial value for
         * the ack deadline. To override this value for a given message, call
         * subscriptions.modifyAckDeadline with the corresponding ackId if using
         * pull. The minimum custom deadline you can specify is 10 seconds. The
         * maximum custom deadline you can specify is 600 seconds (10 minutes).
         * If this parameter is 0, a default value of 10 seconds is used.
         * For push delivery, this value is also used to set the request timeout
         * for the call to the push endpoint.
         * If the subscriber never acknowledges the message, the Pub/Sub system
         * will eventually redeliver the message.
         * 
         * @return builder
         * 
         */
        public Builder ackDeadlineSeconds(@Nullable Output<Integer> ackDeadlineSeconds) {
            $.ackDeadlineSeconds = ackDeadlineSeconds;
            return this;
        }

        /**
         * @param ackDeadlineSeconds This value is the maximum time after a subscriber receives a message
         * before the subscriber should acknowledge the message. After message
         * delivery but before the ack deadline expires and before the message is
         * acknowledged, it is an outstanding message and will not be delivered
         * again during that time (on a best-effort basis).
         * For pull subscriptions, this value is used as the initial value for
         * the ack deadline. To override this value for a given message, call
         * subscriptions.modifyAckDeadline with the corresponding ackId if using
         * pull. The minimum custom deadline you can specify is 10 seconds. The
         * maximum custom deadline you can specify is 600 seconds (10 minutes).
         * If this parameter is 0, a default value of 10 seconds is used.
         * For push delivery, this value is also used to set the request timeout
         * for the call to the push endpoint.
         * If the subscriber never acknowledges the message, the Pub/Sub system
         * will eventually redeliver the message.
         * 
         * @return builder
         * 
         */
        public Builder ackDeadlineSeconds(Integer ackDeadlineSeconds) {
            return ackDeadlineSeconds(Output.of(ackDeadlineSeconds));
        }

        /**
         * @param bigqueryConfig If delivery to BigQuery is used with this subscription, this field is used to configure it.
         * Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
         * If all three are empty, then the subscriber will pull and ack messages using API methods.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder bigqueryConfig(@Nullable Output<SubscriptionBigqueryConfigArgs> bigqueryConfig) {
            $.bigqueryConfig = bigqueryConfig;
            return this;
        }

        /**
         * @param bigqueryConfig If delivery to BigQuery is used with this subscription, this field is used to configure it.
         * Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
         * If all three are empty, then the subscriber will pull and ack messages using API methods.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder bigqueryConfig(SubscriptionBigqueryConfigArgs bigqueryConfig) {
            return bigqueryConfig(Output.of(bigqueryConfig));
        }

        /**
         * @param cloudStorageConfig If delivery to Cloud Storage is used with this subscription, this field is used to configure it.
         * Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
         * If all three are empty, then the subscriber will pull and ack messages using API methods.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder cloudStorageConfig(@Nullable Output<SubscriptionCloudStorageConfigArgs> cloudStorageConfig) {
            $.cloudStorageConfig = cloudStorageConfig;
            return this;
        }

        /**
         * @param cloudStorageConfig If delivery to Cloud Storage is used with this subscription, this field is used to configure it.
         * Either pushConfig, bigQueryConfig or cloudStorageConfig can be set, but not combined.
         * If all three are empty, then the subscriber will pull and ack messages using API methods.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder cloudStorageConfig(SubscriptionCloudStorageConfigArgs cloudStorageConfig) {
            return cloudStorageConfig(Output.of(cloudStorageConfig));
        }

        /**
         * @param deadLetterPolicy A policy that specifies the conditions for dead lettering messages in
         * this subscription. If dead_letter_policy is not set, dead lettering
         * is disabled.
         * The Cloud Pub/Sub service account associated with this subscription&#39;s
         * parent project (i.e.,
         * service-{project_number}{@literal @}gcp-sa-pubsub.iam.gserviceaccount.com) must have
         * permission to Acknowledge() messages on this subscription.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder deadLetterPolicy(@Nullable Output<SubscriptionDeadLetterPolicyArgs> deadLetterPolicy) {
            $.deadLetterPolicy = deadLetterPolicy;
            return this;
        }

        /**
         * @param deadLetterPolicy A policy that specifies the conditions for dead lettering messages in
         * this subscription. If dead_letter_policy is not set, dead lettering
         * is disabled.
         * The Cloud Pub/Sub service account associated with this subscription&#39;s
         * parent project (i.e.,
         * service-{project_number}{@literal @}gcp-sa-pubsub.iam.gserviceaccount.com) must have
         * permission to Acknowledge() messages on this subscription.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder deadLetterPolicy(SubscriptionDeadLetterPolicyArgs deadLetterPolicy) {
            return deadLetterPolicy(Output.of(deadLetterPolicy));
        }

        /**
         * @param enableExactlyOnceDelivery If `true`, Pub/Sub provides the following guarantees for the delivery
         * of a message with a given value of messageId on this Subscriptions&#39;:
         * - The message sent to a subscriber is guaranteed not to be resent before the message&#39;s acknowledgement deadline expires.
         * - An acknowledged message will not be resent to a subscriber.
         *   Note that subscribers may still receive multiple copies of a message when `enable_exactly_once_delivery`
         *   is true if the message was published multiple times by a publisher client. These copies are considered distinct by Pub/Sub and have distinct messageId values
         * 
         * @return builder
         * 
         */
        public Builder enableExactlyOnceDelivery(@Nullable Output<Boolean> enableExactlyOnceDelivery) {
            $.enableExactlyOnceDelivery = enableExactlyOnceDelivery;
            return this;
        }

        /**
         * @param enableExactlyOnceDelivery If `true`, Pub/Sub provides the following guarantees for the delivery
         * of a message with a given value of messageId on this Subscriptions&#39;:
         * - The message sent to a subscriber is guaranteed not to be resent before the message&#39;s acknowledgement deadline expires.
         * - An acknowledged message will not be resent to a subscriber.
         *   Note that subscribers may still receive multiple copies of a message when `enable_exactly_once_delivery`
         *   is true if the message was published multiple times by a publisher client. These copies are considered distinct by Pub/Sub and have distinct messageId values
         * 
         * @return builder
         * 
         */
        public Builder enableExactlyOnceDelivery(Boolean enableExactlyOnceDelivery) {
            return enableExactlyOnceDelivery(Output.of(enableExactlyOnceDelivery));
        }

        /**
         * @param enableMessageOrdering If `true`, messages published with the same orderingKey in PubsubMessage will be delivered to
         * the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they
         * may be delivered in any order.
         * 
         * @return builder
         * 
         */
        public Builder enableMessageOrdering(@Nullable Output<Boolean> enableMessageOrdering) {
            $.enableMessageOrdering = enableMessageOrdering;
            return this;
        }

        /**
         * @param enableMessageOrdering If `true`, messages published with the same orderingKey in PubsubMessage will be delivered to
         * the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they
         * may be delivered in any order.
         * 
         * @return builder
         * 
         */
        public Builder enableMessageOrdering(Boolean enableMessageOrdering) {
            return enableMessageOrdering(Output.of(enableMessageOrdering));
        }

        /**
         * @param expirationPolicy A policy that specifies the conditions for this subscription&#39;s expiration.
         * A subscription is considered active as long as any connected subscriber
         * is successfully consuming messages from the subscription or is issuing
         * operations on the subscription. If expirationPolicy is not set, a default
         * policy with ttl of 31 days will be used.  If it is set but ttl is &#34;&#34;, the
         * resource never expires.  The minimum allowed value for expirationPolicy.ttl
         * is 1 day.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder expirationPolicy(@Nullable Output<SubscriptionExpirationPolicyArgs> expirationPolicy) {
            $.expirationPolicy = expirationPolicy;
            return this;
        }

        /**
         * @param expirationPolicy A policy that specifies the conditions for this subscription&#39;s expiration.
         * A subscription is considered active as long as any connected subscriber
         * is successfully consuming messages from the subscription or is issuing
         * operations on the subscription. If expirationPolicy is not set, a default
         * policy with ttl of 31 days will be used.  If it is set but ttl is &#34;&#34;, the
         * resource never expires.  The minimum allowed value for expirationPolicy.ttl
         * is 1 day.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder expirationPolicy(SubscriptionExpirationPolicyArgs expirationPolicy) {
            return expirationPolicy(Output.of(expirationPolicy));
        }

        /**
         * @param filter The subscription only delivers the messages that match the filter.
         * Pub/Sub automatically acknowledges the messages that don&#39;t match the filter. You can filter messages
         * by their attributes. The maximum length of a filter is 256 bytes. After creating the subscription,
         * you can&#39;t modify the filter.
         * 
         * @return builder
         * 
         */
        public Builder filter(@Nullable Output<String> filter) {
            $.filter = filter;
            return this;
        }

        /**
         * @param filter The subscription only delivers the messages that match the filter.
         * Pub/Sub automatically acknowledges the messages that don&#39;t match the filter. You can filter messages
         * by their attributes. The maximum length of a filter is 256 bytes. After creating the subscription,
         * you can&#39;t modify the filter.
         * 
         * @return builder
         * 
         */
        public Builder filter(String filter) {
            return filter(Output.of(filter));
        }

        /**
         * @param labels A set of key/value label pairs to assign to this Subscription.
         * 
         * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
         * Please refer to the field `effective_labels` for all of the labels present on the resource.
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels A set of key/value label pairs to assign to this Subscription.
         * 
         * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
         * Please refer to the field `effective_labels` for all of the labels present on the resource.
         * 
         * @return builder
         * 
         */
        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        /**
         * @param messageRetentionDuration How long to retain unacknowledged messages in the subscription&#39;s
         * backlog, from the moment a message is published. If
         * retain_acked_messages is true, then this also configures the retention
         * of acknowledged messages, and thus configures how far back in time a
         * subscriptions.seek can be done. Defaults to 7 days. Cannot be more
         * than 31 days (`&#34;2678400s&#34;`) or less than 10 minutes (`&#34;600s&#34;`).
         * A duration in seconds with up to nine fractional digits, terminated
         * by &#39;s&#39;. Example: `&#34;600.5s&#34;`.
         * 
         * @return builder
         * 
         */
        public Builder messageRetentionDuration(@Nullable Output<String> messageRetentionDuration) {
            $.messageRetentionDuration = messageRetentionDuration;
            return this;
        }

        /**
         * @param messageRetentionDuration How long to retain unacknowledged messages in the subscription&#39;s
         * backlog, from the moment a message is published. If
         * retain_acked_messages is true, then this also configures the retention
         * of acknowledged messages, and thus configures how far back in time a
         * subscriptions.seek can be done. Defaults to 7 days. Cannot be more
         * than 31 days (`&#34;2678400s&#34;`) or less than 10 minutes (`&#34;600s&#34;`).
         * A duration in seconds with up to nine fractional digits, terminated
         * by &#39;s&#39;. Example: `&#34;600.5s&#34;`.
         * 
         * @return builder
         * 
         */
        public Builder messageRetentionDuration(String messageRetentionDuration) {
            return messageRetentionDuration(Output.of(messageRetentionDuration));
        }

        /**
         * @param messageTransforms Transforms to be applied to messages published to the topic. Transforms are applied in the
         * order specified.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder messageTransforms(@Nullable Output<List<SubscriptionMessageTransformArgs>> messageTransforms) {
            $.messageTransforms = messageTransforms;
            return this;
        }

        /**
         * @param messageTransforms Transforms to be applied to messages published to the topic. Transforms are applied in the
         * order specified.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder messageTransforms(List<SubscriptionMessageTransformArgs> messageTransforms) {
            return messageTransforms(Output.of(messageTransforms));
        }

        /**
         * @param messageTransforms Transforms to be applied to messages published to the topic. Transforms are applied in the
         * order specified.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder messageTransforms(SubscriptionMessageTransformArgs... messageTransforms) {
            return messageTransforms(List.of(messageTransforms));
        }

        /**
         * @param name Name of the subscription.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name Name of the subscription.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param pushConfig If push delivery is used with this subscription, this field is used to
         * configure it. An empty pushConfig signifies that the subscriber will
         * pull and ack messages using API methods.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder pushConfig(@Nullable Output<SubscriptionPushConfigArgs> pushConfig) {
            $.pushConfig = pushConfig;
            return this;
        }

        /**
         * @param pushConfig If push delivery is used with this subscription, this field is used to
         * configure it. An empty pushConfig signifies that the subscriber will
         * pull and ack messages using API methods.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder pushConfig(SubscriptionPushConfigArgs pushConfig) {
            return pushConfig(Output.of(pushConfig));
        }

        /**
         * @param retainAckedMessages Indicates whether to retain acknowledged messages. If `true`, then
         * messages are not expunged from the subscription&#39;s backlog, even if
         * they are acknowledged, until they fall out of the
         * messageRetentionDuration window.
         * 
         * @return builder
         * 
         */
        public Builder retainAckedMessages(@Nullable Output<Boolean> retainAckedMessages) {
            $.retainAckedMessages = retainAckedMessages;
            return this;
        }

        /**
         * @param retainAckedMessages Indicates whether to retain acknowledged messages. If `true`, then
         * messages are not expunged from the subscription&#39;s backlog, even if
         * they are acknowledged, until they fall out of the
         * messageRetentionDuration window.
         * 
         * @return builder
         * 
         */
        public Builder retainAckedMessages(Boolean retainAckedMessages) {
            return retainAckedMessages(Output.of(retainAckedMessages));
        }

        /**
         * @param retryPolicy A policy that specifies how Pub/Sub retries message delivery for this subscription.
         * If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
         * RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder retryPolicy(@Nullable Output<SubscriptionRetryPolicyArgs> retryPolicy) {
            $.retryPolicy = retryPolicy;
            return this;
        }

        /**
         * @param retryPolicy A policy that specifies how Pub/Sub retries message delivery for this subscription.
         * If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
         * RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder retryPolicy(SubscriptionRetryPolicyArgs retryPolicy) {
            return retryPolicy(Output.of(retryPolicy));
        }

        /**
         * @param tags Input only. Resource manager tags to be bound to the subscription. Tag
         * keys and values have the same definition as resource manager tags. Keys
         * must be in the format tagKeys/{tag_key_id}, and values are in the format
         * tagValues/456. The field is ignored when empty. The field is immutable and
         * causes resource replacement when mutated. This field is only set at create
         * time and modifying this field after creation will trigger recreation. To
         * apply tags to an existing resource, see the `gcp.tags.TagValue`
         * resource.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<Map<String,String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags Input only. Resource manager tags to be bound to the subscription. Tag
         * keys and values have the same definition as resource manager tags. Keys
         * must be in the format tagKeys/{tag_key_id}, and values are in the format
         * tagValues/456. The field is ignored when empty. The field is immutable and
         * causes resource replacement when mutated. This field is only set at create
         * time and modifying this field after creation will trigger recreation. To
         * apply tags to an existing resource, see the `gcp.tags.TagValue`
         * resource.
         * 
         * @return builder
         * 
         */
        public Builder tags(Map<String,String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param topic A reference to a Topic resource, of the form projects/{project}/topics/{{name}}
         * (as in the id property of a google_pubsub_topic), or just a topic name if
         * the topic is in the same project as the subscription.
         * 
         * @return builder
         * 
         */
        public Builder topic(Output<String> topic) {
            $.topic = topic;
            return this;
        }

        /**
         * @param topic A reference to a Topic resource, of the form projects/{project}/topics/{{name}}
         * (as in the id property of a google_pubsub_topic), or just a topic name if
         * the topic is in the same project as the subscription.
         * 
         * @return builder
         * 
         */
        public Builder topic(String topic) {
            return topic(Output.of(topic));
        }

        public SubscriptionArgs build() {
            if ($.topic == null) {
                throw new MissingRequiredPropertyException("SubscriptionArgs", "topic");
            }
            return $;
        }
    }

}
