// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.vertex.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.vertex.outputs.AiIndexMetadataConfigAlgorithmConfig;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class AiIndexMetadataConfig {
    /**
     * @return The configuration with regard to the algorithms used for efficient search. This field may be required based on your configuration.
     * Structure is documented below.
     * 
     */
    private @Nullable AiIndexMetadataConfigAlgorithmConfig algorithmConfig;
    /**
     * @return The default number of neighbors to find via approximate search before exact reordering is
     * performed. Exact reordering is a procedure where results returned by an
     * approximate search algorithm are reordered via a more expensive distance computation.
     * Required if tree-AH algorithm is used.
     * 
     */
    private @Nullable Integer approximateNeighborsCount;
    /**
     * @return The number of dimensions of the input vectors.
     * 
     */
    private Integer dimensions;
    /**
     * @return The distance measure used in nearest neighbor search. The value must be one of the followings:
     * * SQUARED_L2_DISTANCE: Euclidean (L_2) Distance
     * * L1_DISTANCE: Manhattan (L_1) Distance
     * * COSINE_DISTANCE: Cosine Distance. Defined as 1 - cosine similarity.
     * * DOT_PRODUCT_DISTANCE: Dot Product Distance. Defined as a negative of the dot product
     * 
     */
    private @Nullable String distanceMeasureType;
    /**
     * @return Type of normalization to be carried out on each vector. The value must be one of the followings:
     * * UNIT_L2_NORM: Unit L2 normalization type
     * * NONE: No normalization type is specified.
     * 
     */
    private @Nullable String featureNormType;
    /**
     * @return Index data is split into equal parts to be processed. These are called &#34;shards&#34;.
     * The shard size must be specified when creating an index. The value must be one of the followings:
     * * SHARD_SIZE_SMALL: Small (2GB)
     * * SHARD_SIZE_MEDIUM: Medium (20GB)
     * * SHARD_SIZE_LARGE: Large (50GB)
     * 
     */
    private @Nullable String shardSize;

    private AiIndexMetadataConfig() {}
    /**
     * @return The configuration with regard to the algorithms used for efficient search. This field may be required based on your configuration.
     * Structure is documented below.
     * 
     */
    public Optional<AiIndexMetadataConfigAlgorithmConfig> algorithmConfig() {
        return Optional.ofNullable(this.algorithmConfig);
    }
    /**
     * @return The default number of neighbors to find via approximate search before exact reordering is
     * performed. Exact reordering is a procedure where results returned by an
     * approximate search algorithm are reordered via a more expensive distance computation.
     * Required if tree-AH algorithm is used.
     * 
     */
    public Optional<Integer> approximateNeighborsCount() {
        return Optional.ofNullable(this.approximateNeighborsCount);
    }
    /**
     * @return The number of dimensions of the input vectors.
     * 
     */
    public Integer dimensions() {
        return this.dimensions;
    }
    /**
     * @return The distance measure used in nearest neighbor search. The value must be one of the followings:
     * * SQUARED_L2_DISTANCE: Euclidean (L_2) Distance
     * * L1_DISTANCE: Manhattan (L_1) Distance
     * * COSINE_DISTANCE: Cosine Distance. Defined as 1 - cosine similarity.
     * * DOT_PRODUCT_DISTANCE: Dot Product Distance. Defined as a negative of the dot product
     * 
     */
    public Optional<String> distanceMeasureType() {
        return Optional.ofNullable(this.distanceMeasureType);
    }
    /**
     * @return Type of normalization to be carried out on each vector. The value must be one of the followings:
     * * UNIT_L2_NORM: Unit L2 normalization type
     * * NONE: No normalization type is specified.
     * 
     */
    public Optional<String> featureNormType() {
        return Optional.ofNullable(this.featureNormType);
    }
    /**
     * @return Index data is split into equal parts to be processed. These are called &#34;shards&#34;.
     * The shard size must be specified when creating an index. The value must be one of the followings:
     * * SHARD_SIZE_SMALL: Small (2GB)
     * * SHARD_SIZE_MEDIUM: Medium (20GB)
     * * SHARD_SIZE_LARGE: Large (50GB)
     * 
     */
    public Optional<String> shardSize() {
        return Optional.ofNullable(this.shardSize);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(AiIndexMetadataConfig defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable AiIndexMetadataConfigAlgorithmConfig algorithmConfig;
        private @Nullable Integer approximateNeighborsCount;
        private Integer dimensions;
        private @Nullable String distanceMeasureType;
        private @Nullable String featureNormType;
        private @Nullable String shardSize;
        public Builder() {}
        public Builder(AiIndexMetadataConfig defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.algorithmConfig = defaults.algorithmConfig;
    	      this.approximateNeighborsCount = defaults.approximateNeighborsCount;
    	      this.dimensions = defaults.dimensions;
    	      this.distanceMeasureType = defaults.distanceMeasureType;
    	      this.featureNormType = defaults.featureNormType;
    	      this.shardSize = defaults.shardSize;
        }

        @CustomType.Setter
        public Builder algorithmConfig(@Nullable AiIndexMetadataConfigAlgorithmConfig algorithmConfig) {

            this.algorithmConfig = algorithmConfig;
            return this;
        }
        @CustomType.Setter
        public Builder approximateNeighborsCount(@Nullable Integer approximateNeighborsCount) {

            this.approximateNeighborsCount = approximateNeighborsCount;
            return this;
        }
        @CustomType.Setter
        public Builder dimensions(Integer dimensions) {
            if (dimensions == null) {
              throw new MissingRequiredPropertyException("AiIndexMetadataConfig", "dimensions");
            }
            this.dimensions = dimensions;
            return this;
        }
        @CustomType.Setter
        public Builder distanceMeasureType(@Nullable String distanceMeasureType) {

            this.distanceMeasureType = distanceMeasureType;
            return this;
        }
        @CustomType.Setter
        public Builder featureNormType(@Nullable String featureNormType) {

            this.featureNormType = featureNormType;
            return this;
        }
        @CustomType.Setter
        public Builder shardSize(@Nullable String shardSize) {

            this.shardSize = shardSize;
            return this;
        }
        public AiIndexMetadataConfig build() {
            final var _resultValue = new AiIndexMetadataConfig();
            _resultValue.algorithmConfig = algorithmConfig;
            _resultValue.approximateNeighborsCount = approximateNeighborsCount;
            _resultValue.dimensions = dimensions;
            _resultValue.distanceMeasureType = distanceMeasureType;
            _resultValue.featureNormType = featureNormType;
            _resultValue.shardSize = shardSize;
            return _resultValue;
        }
    }
}
