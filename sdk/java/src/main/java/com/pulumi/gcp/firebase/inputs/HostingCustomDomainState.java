// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.firebase.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.firebase.inputs.HostingCustomDomainCertArgs;
import com.pulumi.gcp.firebase.inputs.HostingCustomDomainIssueArgs;
import com.pulumi.gcp.firebase.inputs.HostingCustomDomainRequiredDnsUpdateArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class HostingCustomDomainState extends com.pulumi.resources.ResourceArgs {

    public static final HostingCustomDomainState Empty = new HostingCustomDomainState();

    /**
     * A field that lets you specify which SSL certificate type Hosting creates
     * for your domain name. Spark plan `CustomDomain`s only have access to the
     * `GROUPED` cert type, while Blaze plan can select any option.
     * Possible values are: `GROUPED`, `PROJECT_GROUPED`, `DEDICATED`.
     * 
     */
    @Import(name="certPreference")
    private @Nullable Output<String> certPreference;

    /**
     * @return A field that lets you specify which SSL certificate type Hosting creates
     * for your domain name. Spark plan `CustomDomain`s only have access to the
     * `GROUPED` cert type, while Blaze plan can select any option.
     * Possible values are: `GROUPED`, `PROJECT_GROUPED`, `DEDICATED`.
     * 
     */
    public Optional<Output<String>> certPreference() {
        return Optional.ofNullable(this.certPreference);
    }

    /**
     * The SSL certificate Hosting has for this `CustomDomain`&#39;s domain name.
     * For new `CustomDomain`s, this often represents Hosting&#39;s intent to create
     * a certificate, rather than an actual cert. Check the `state` field for
     * more.
     * Structure is documented below.
     * 
     */
    @Import(name="certs")
    private @Nullable Output<List<HostingCustomDomainCertArgs>> certs;

    /**
     * @return The SSL certificate Hosting has for this `CustomDomain`&#39;s domain name.
     * For new `CustomDomain`s, this often represents Hosting&#39;s intent to create
     * a certificate, rather than an actual cert. Check the `state` field for
     * more.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<HostingCustomDomainCertArgs>>> certs() {
        return Optional.ofNullable(this.certs);
    }

    /**
     * The `CustomDomain`&#39;s create time.
     * 
     */
    @Import(name="createTime")
    private @Nullable Output<String> createTime;

    /**
     * @return The `CustomDomain`&#39;s create time.
     * 
     */
    public Optional<Output<String>> createTime() {
        return Optional.ofNullable(this.createTime);
    }

    /**
     * The ID of the `CustomDomain`, which is the domain name you&#39;d like to use with Firebase Hosting.
     * 
     */
    @Import(name="customDomain")
    private @Nullable Output<String> customDomain;

    /**
     * @return The ID of the `CustomDomain`, which is the domain name you&#39;d like to use with Firebase Hosting.
     * 
     */
    public Optional<Output<String>> customDomain() {
        return Optional.ofNullable(this.customDomain);
    }

    /**
     * The time the `CustomDomain` was deleted; null for `CustomDomains` that
     * haven&#39;t been deleted. Deleted `CustomDomains` persist for approximately 30
     * days, after which time Hosting removes them completely.
     * 
     */
    @Import(name="deleteTime")
    private @Nullable Output<String> deleteTime;

    /**
     * @return The time the `CustomDomain` was deleted; null for `CustomDomains` that
     * haven&#39;t been deleted. Deleted `CustomDomains` persist for approximately 30
     * days, after which time Hosting removes them completely.
     * 
     */
    public Optional<Output<String>> deleteTime() {
        return Optional.ofNullable(this.deleteTime);
    }

    /**
     * A string that represents the current state of the `CustomDomain` and
     * allows you to confirm its initial state in requests that would modify it.
     * 
     */
    @Import(name="etag")
    private @Nullable Output<String> etag;

    /**
     * @return A string that represents the current state of the `CustomDomain` and
     * allows you to confirm its initial state in requests that would modify it.
     * 
     */
    public Optional<Output<String>> etag() {
        return Optional.ofNullable(this.etag);
    }

    /**
     * The minimum time before a soft-deleted `CustomDomain` is completely removed
     * from Hosting; null for `CustomDomains` that haven&#39;t been deleted.
     * 
     */
    @Import(name="expireTime")
    private @Nullable Output<String> expireTime;

    /**
     * @return The minimum time before a soft-deleted `CustomDomain` is completely removed
     * from Hosting; null for `CustomDomains` that haven&#39;t been deleted.
     * 
     */
    public Optional<Output<String>> expireTime() {
        return Optional.ofNullable(this.expireTime);
    }

    /**
     * The host state of your domain name. Host state is determined by checking each
     * IP address associated with your domain name to see if it&#39;s serving
     * Hosting content.
     * HOST_UNHOSTED:
     * Your `CustomDomain`&#39;s domain name isn&#39;t associated with any IP addresses.
     * HOST_UNREACHABLE:
     * Your `CustomDomain`&#39;s domain name can&#39;t be reached. Hosting services&#39; DNS
     * queries to find your domain name&#39;s IP addresses resulted in errors. See
     * your `CustomDomain`&#39;s `issues` field for more details.
     * HOST_MISMATCH:
     * Your `CustomDomain`&#39;s domain name has IP addresses that don&#39;t ultimately
     * resolve to Hosting.
     * HOST_CONFLICT:
     * Your `CustomDomain`&#39;s domain name has IP addresses that resolve to both
     * Hosting and other services. To ensure consistent results, remove `A` and
     * `AAAA` records related to non-Hosting services.
     * HOST_ACTIVE:
     * All requests against your `CustomDomain`&#39;s domain name are served by
     * Hosting. If the `CustomDomain`&#39;s `OwnershipState` is also `ACTIVE`, Hosting
     * serves your Hosting Site&#39;s content on the domain name.
     * 
     */
    @Import(name="hostState")
    private @Nullable Output<String> hostState;

    /**
     * @return The host state of your domain name. Host state is determined by checking each
     * IP address associated with your domain name to see if it&#39;s serving
     * Hosting content.
     * HOST_UNHOSTED:
     * Your `CustomDomain`&#39;s domain name isn&#39;t associated with any IP addresses.
     * HOST_UNREACHABLE:
     * Your `CustomDomain`&#39;s domain name can&#39;t be reached. Hosting services&#39; DNS
     * queries to find your domain name&#39;s IP addresses resulted in errors. See
     * your `CustomDomain`&#39;s `issues` field for more details.
     * HOST_MISMATCH:
     * Your `CustomDomain`&#39;s domain name has IP addresses that don&#39;t ultimately
     * resolve to Hosting.
     * HOST_CONFLICT:
     * Your `CustomDomain`&#39;s domain name has IP addresses that resolve to both
     * Hosting and other services. To ensure consistent results, remove `A` and
     * `AAAA` records related to non-Hosting services.
     * HOST_ACTIVE:
     * All requests against your `CustomDomain`&#39;s domain name are served by
     * Hosting. If the `CustomDomain`&#39;s `OwnershipState` is also `ACTIVE`, Hosting
     * serves your Hosting Site&#39;s content on the domain name.
     * 
     */
    public Optional<Output<String>> hostState() {
        return Optional.ofNullable(this.hostState);
    }

    /**
     * A set of errors Hosting systems encountered when trying to establish
     * Hosting&#39;s ability to serve secure content for your domain name. Resolve
     * these issues to ensure your `CustomDomain` behaves properly.
     * Structure is documented below.
     * 
     */
    @Import(name="issues")
    private @Nullable Output<List<HostingCustomDomainIssueArgs>> issues;

    /**
     * @return A set of errors Hosting systems encountered when trying to establish
     * Hosting&#39;s ability to serve secure content for your domain name. Resolve
     * these issues to ensure your `CustomDomain` behaves properly.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<HostingCustomDomainIssueArgs>>> issues() {
        return Optional.ofNullable(this.issues);
    }

    /**
     * The fully-qualified name of the `CustomDomain`.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The fully-qualified name of the `CustomDomain`.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The ownership state of your domain name. Ownership is determined at a
     * Firebase project level, and established by adding `TXT` records to your
     * domain name&#39;s DNS records.
     * Ownership cascades to subdomains. Granting a project ownership of `foo.com`
     * also grants that project ownership over `bar.foo.com`, unless you add
     * specific `TXT` records to `bar.foo.com` that grant a different project
     * ownership.
     * If your `CustomDomain` is in an `OwnershipState` other than
     * `OWNERSHIP_ACTIVE` for more than 30 days and it hasn&#39;t been updated in at
     * least 30 days, Hosting&#39;s ownership systems delete the `CustomDomain`.
     * OWNERSHIP_MISSING:
     * Your `CustomDomain`&#39;s domain name has no Hosting-related ownership records;
     * no Firebase project has permission to act on the domain name&#39;s behalf.
     * OWNERSHIP_UNREACHABLE:
     * Your `CustomDomain`&#39;s domain name can&#39;t be reached. Hosting services&#39; DNS
     * queries to find your domain name&#39;s ownership records resulted in errors.
     * See your `CustomDomain`&#39;s `issues` field for more details.
     * OWNERSHIP_MISMATCH:
     * Your `CustomDomain`&#39;s domain name is owned by another Firebase project.
     * Remove the conflicting `TXT` records and replace them with project-specific
     * records for your current Firebase project.
     * OWNERSHIP_CONFLICT:
     * Your `CustomDomain`&#39;s domain name has conflicting `TXT` records that
     * indicate ownership by both your current Firebase project and another
     * project. Remove the other project&#39;s ownership records to grant the current
     * project ownership.
     * OWNERSHIP_PENDING:
     * Your `CustomDomain`&#39;s DNS records are configured correctly. Hosting will
     * transfer ownership of your domain to this `CustomDomain` within 24 hours.
     * OWNERSHIP_ACTIVE:
     * Your `CustomDomain`&#39;s domain name has `TXT` records that grant its project
     * permission to act on its behalf.
     * 
     */
    @Import(name="ownershipState")
    private @Nullable Output<String> ownershipState;

    /**
     * @return The ownership state of your domain name. Ownership is determined at a
     * Firebase project level, and established by adding `TXT` records to your
     * domain name&#39;s DNS records.
     * Ownership cascades to subdomains. Granting a project ownership of `foo.com`
     * also grants that project ownership over `bar.foo.com`, unless you add
     * specific `TXT` records to `bar.foo.com` that grant a different project
     * ownership.
     * If your `CustomDomain` is in an `OwnershipState` other than
     * `OWNERSHIP_ACTIVE` for more than 30 days and it hasn&#39;t been updated in at
     * least 30 days, Hosting&#39;s ownership systems delete the `CustomDomain`.
     * OWNERSHIP_MISSING:
     * Your `CustomDomain`&#39;s domain name has no Hosting-related ownership records;
     * no Firebase project has permission to act on the domain name&#39;s behalf.
     * OWNERSHIP_UNREACHABLE:
     * Your `CustomDomain`&#39;s domain name can&#39;t be reached. Hosting services&#39; DNS
     * queries to find your domain name&#39;s ownership records resulted in errors.
     * See your `CustomDomain`&#39;s `issues` field for more details.
     * OWNERSHIP_MISMATCH:
     * Your `CustomDomain`&#39;s domain name is owned by another Firebase project.
     * Remove the conflicting `TXT` records and replace them with project-specific
     * records for your current Firebase project.
     * OWNERSHIP_CONFLICT:
     * Your `CustomDomain`&#39;s domain name has conflicting `TXT` records that
     * indicate ownership by both your current Firebase project and another
     * project. Remove the other project&#39;s ownership records to grant the current
     * project ownership.
     * OWNERSHIP_PENDING:
     * Your `CustomDomain`&#39;s DNS records are configured correctly. Hosting will
     * transfer ownership of your domain to this `CustomDomain` within 24 hours.
     * OWNERSHIP_ACTIVE:
     * Your `CustomDomain`&#39;s domain name has `TXT` records that grant its project
     * permission to act on its behalf.
     * 
     */
    public Optional<Output<String>> ownershipState() {
        return Optional.ofNullable(this.ownershipState);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * if true, indicates that Hosting&#39;s systems are attempting to
     * make the `CustomDomain`&#39;s state match your preferred state. This is most
     * frequently `true` when initially provisioning a `CustomDomain` or when creating
     * a new SSL certificate to match an updated `certPreference`
     * 
     */
    @Import(name="reconciling")
    private @Nullable Output<Boolean> reconciling;

    /**
     * @return if true, indicates that Hosting&#39;s systems are attempting to
     * make the `CustomDomain`&#39;s state match your preferred state. This is most
     * frequently `true` when initially provisioning a `CustomDomain` or when creating
     * a new SSL certificate to match an updated `certPreference`
     * 
     */
    public Optional<Output<Boolean>> reconciling() {
        return Optional.ofNullable(this.reconciling);
    }

    /**
     * A domain name that this CustomDomain should direct traffic towards. If
     * specified, Hosting will respond to requests against this CustomDomain
     * with an HTTP 301 code, and route traffic to the specified `redirectTarget`
     * instead.
     * 
     */
    @Import(name="redirectTarget")
    private @Nullable Output<String> redirectTarget;

    /**
     * @return A domain name that this CustomDomain should direct traffic towards. If
     * specified, Hosting will respond to requests against this CustomDomain
     * with an HTTP 301 code, and route traffic to the specified `redirectTarget`
     * instead.
     * 
     */
    public Optional<Output<String>> redirectTarget() {
        return Optional.ofNullable(this.redirectTarget);
    }

    /**
     * A set of updates you should make to the domain name&#39;s DNS records to
     * let Hosting serve secure content on its behalf.
     * Structure is documented below.
     * 
     */
    @Import(name="requiredDnsUpdates")
    private @Nullable Output<List<HostingCustomDomainRequiredDnsUpdateArgs>> requiredDnsUpdates;

    /**
     * @return A set of updates you should make to the domain name&#39;s DNS records to
     * let Hosting serve secure content on its behalf.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<HostingCustomDomainRequiredDnsUpdateArgs>>> requiredDnsUpdates() {
        return Optional.ofNullable(this.requiredDnsUpdates);
    }

    /**
     * The ID of the site in which to create this custom domain association.
     * 
     */
    @Import(name="siteId")
    private @Nullable Output<String> siteId;

    /**
     * @return The ID of the site in which to create this custom domain association.
     * 
     */
    public Optional<Output<String>> siteId() {
        return Optional.ofNullable(this.siteId);
    }

    /**
     * The last time the `CustomDomain` was updated.
     * 
     */
    @Import(name="updateTime")
    private @Nullable Output<String> updateTime;

    /**
     * @return The last time the `CustomDomain` was updated.
     * 
     */
    public Optional<Output<String>> updateTime() {
        return Optional.ofNullable(this.updateTime);
    }

    @Import(name="waitDnsVerification")
    private @Nullable Output<Boolean> waitDnsVerification;

    public Optional<Output<Boolean>> waitDnsVerification() {
        return Optional.ofNullable(this.waitDnsVerification);
    }

    private HostingCustomDomainState() {}

    private HostingCustomDomainState(HostingCustomDomainState $) {
        this.certPreference = $.certPreference;
        this.certs = $.certs;
        this.createTime = $.createTime;
        this.customDomain = $.customDomain;
        this.deleteTime = $.deleteTime;
        this.etag = $.etag;
        this.expireTime = $.expireTime;
        this.hostState = $.hostState;
        this.issues = $.issues;
        this.name = $.name;
        this.ownershipState = $.ownershipState;
        this.project = $.project;
        this.reconciling = $.reconciling;
        this.redirectTarget = $.redirectTarget;
        this.requiredDnsUpdates = $.requiredDnsUpdates;
        this.siteId = $.siteId;
        this.updateTime = $.updateTime;
        this.waitDnsVerification = $.waitDnsVerification;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(HostingCustomDomainState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private HostingCustomDomainState $;

        public Builder() {
            $ = new HostingCustomDomainState();
        }

        public Builder(HostingCustomDomainState defaults) {
            $ = new HostingCustomDomainState(Objects.requireNonNull(defaults));
        }

        /**
         * @param certPreference A field that lets you specify which SSL certificate type Hosting creates
         * for your domain name. Spark plan `CustomDomain`s only have access to the
         * `GROUPED` cert type, while Blaze plan can select any option.
         * Possible values are: `GROUPED`, `PROJECT_GROUPED`, `DEDICATED`.
         * 
         * @return builder
         * 
         */
        public Builder certPreference(@Nullable Output<String> certPreference) {
            $.certPreference = certPreference;
            return this;
        }

        /**
         * @param certPreference A field that lets you specify which SSL certificate type Hosting creates
         * for your domain name. Spark plan `CustomDomain`s only have access to the
         * `GROUPED` cert type, while Blaze plan can select any option.
         * Possible values are: `GROUPED`, `PROJECT_GROUPED`, `DEDICATED`.
         * 
         * @return builder
         * 
         */
        public Builder certPreference(String certPreference) {
            return certPreference(Output.of(certPreference));
        }

        /**
         * @param certs The SSL certificate Hosting has for this `CustomDomain`&#39;s domain name.
         * For new `CustomDomain`s, this often represents Hosting&#39;s intent to create
         * a certificate, rather than an actual cert. Check the `state` field for
         * more.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder certs(@Nullable Output<List<HostingCustomDomainCertArgs>> certs) {
            $.certs = certs;
            return this;
        }

        /**
         * @param certs The SSL certificate Hosting has for this `CustomDomain`&#39;s domain name.
         * For new `CustomDomain`s, this often represents Hosting&#39;s intent to create
         * a certificate, rather than an actual cert. Check the `state` field for
         * more.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder certs(List<HostingCustomDomainCertArgs> certs) {
            return certs(Output.of(certs));
        }

        /**
         * @param certs The SSL certificate Hosting has for this `CustomDomain`&#39;s domain name.
         * For new `CustomDomain`s, this often represents Hosting&#39;s intent to create
         * a certificate, rather than an actual cert. Check the `state` field for
         * more.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder certs(HostingCustomDomainCertArgs... certs) {
            return certs(List.of(certs));
        }

        /**
         * @param createTime The `CustomDomain`&#39;s create time.
         * 
         * @return builder
         * 
         */
        public Builder createTime(@Nullable Output<String> createTime) {
            $.createTime = createTime;
            return this;
        }

        /**
         * @param createTime The `CustomDomain`&#39;s create time.
         * 
         * @return builder
         * 
         */
        public Builder createTime(String createTime) {
            return createTime(Output.of(createTime));
        }

        /**
         * @param customDomain The ID of the `CustomDomain`, which is the domain name you&#39;d like to use with Firebase Hosting.
         * 
         * @return builder
         * 
         */
        public Builder customDomain(@Nullable Output<String> customDomain) {
            $.customDomain = customDomain;
            return this;
        }

        /**
         * @param customDomain The ID of the `CustomDomain`, which is the domain name you&#39;d like to use with Firebase Hosting.
         * 
         * @return builder
         * 
         */
        public Builder customDomain(String customDomain) {
            return customDomain(Output.of(customDomain));
        }

        /**
         * @param deleteTime The time the `CustomDomain` was deleted; null for `CustomDomains` that
         * haven&#39;t been deleted. Deleted `CustomDomains` persist for approximately 30
         * days, after which time Hosting removes them completely.
         * 
         * @return builder
         * 
         */
        public Builder deleteTime(@Nullable Output<String> deleteTime) {
            $.deleteTime = deleteTime;
            return this;
        }

        /**
         * @param deleteTime The time the `CustomDomain` was deleted; null for `CustomDomains` that
         * haven&#39;t been deleted. Deleted `CustomDomains` persist for approximately 30
         * days, after which time Hosting removes them completely.
         * 
         * @return builder
         * 
         */
        public Builder deleteTime(String deleteTime) {
            return deleteTime(Output.of(deleteTime));
        }

        /**
         * @param etag A string that represents the current state of the `CustomDomain` and
         * allows you to confirm its initial state in requests that would modify it.
         * 
         * @return builder
         * 
         */
        public Builder etag(@Nullable Output<String> etag) {
            $.etag = etag;
            return this;
        }

        /**
         * @param etag A string that represents the current state of the `CustomDomain` and
         * allows you to confirm its initial state in requests that would modify it.
         * 
         * @return builder
         * 
         */
        public Builder etag(String etag) {
            return etag(Output.of(etag));
        }

        /**
         * @param expireTime The minimum time before a soft-deleted `CustomDomain` is completely removed
         * from Hosting; null for `CustomDomains` that haven&#39;t been deleted.
         * 
         * @return builder
         * 
         */
        public Builder expireTime(@Nullable Output<String> expireTime) {
            $.expireTime = expireTime;
            return this;
        }

        /**
         * @param expireTime The minimum time before a soft-deleted `CustomDomain` is completely removed
         * from Hosting; null for `CustomDomains` that haven&#39;t been deleted.
         * 
         * @return builder
         * 
         */
        public Builder expireTime(String expireTime) {
            return expireTime(Output.of(expireTime));
        }

        /**
         * @param hostState The host state of your domain name. Host state is determined by checking each
         * IP address associated with your domain name to see if it&#39;s serving
         * Hosting content.
         * HOST_UNHOSTED:
         * Your `CustomDomain`&#39;s domain name isn&#39;t associated with any IP addresses.
         * HOST_UNREACHABLE:
         * Your `CustomDomain`&#39;s domain name can&#39;t be reached. Hosting services&#39; DNS
         * queries to find your domain name&#39;s IP addresses resulted in errors. See
         * your `CustomDomain`&#39;s `issues` field for more details.
         * HOST_MISMATCH:
         * Your `CustomDomain`&#39;s domain name has IP addresses that don&#39;t ultimately
         * resolve to Hosting.
         * HOST_CONFLICT:
         * Your `CustomDomain`&#39;s domain name has IP addresses that resolve to both
         * Hosting and other services. To ensure consistent results, remove `A` and
         * `AAAA` records related to non-Hosting services.
         * HOST_ACTIVE:
         * All requests against your `CustomDomain`&#39;s domain name are served by
         * Hosting. If the `CustomDomain`&#39;s `OwnershipState` is also `ACTIVE`, Hosting
         * serves your Hosting Site&#39;s content on the domain name.
         * 
         * @return builder
         * 
         */
        public Builder hostState(@Nullable Output<String> hostState) {
            $.hostState = hostState;
            return this;
        }

        /**
         * @param hostState The host state of your domain name. Host state is determined by checking each
         * IP address associated with your domain name to see if it&#39;s serving
         * Hosting content.
         * HOST_UNHOSTED:
         * Your `CustomDomain`&#39;s domain name isn&#39;t associated with any IP addresses.
         * HOST_UNREACHABLE:
         * Your `CustomDomain`&#39;s domain name can&#39;t be reached. Hosting services&#39; DNS
         * queries to find your domain name&#39;s IP addresses resulted in errors. See
         * your `CustomDomain`&#39;s `issues` field for more details.
         * HOST_MISMATCH:
         * Your `CustomDomain`&#39;s domain name has IP addresses that don&#39;t ultimately
         * resolve to Hosting.
         * HOST_CONFLICT:
         * Your `CustomDomain`&#39;s domain name has IP addresses that resolve to both
         * Hosting and other services. To ensure consistent results, remove `A` and
         * `AAAA` records related to non-Hosting services.
         * HOST_ACTIVE:
         * All requests against your `CustomDomain`&#39;s domain name are served by
         * Hosting. If the `CustomDomain`&#39;s `OwnershipState` is also `ACTIVE`, Hosting
         * serves your Hosting Site&#39;s content on the domain name.
         * 
         * @return builder
         * 
         */
        public Builder hostState(String hostState) {
            return hostState(Output.of(hostState));
        }

        /**
         * @param issues A set of errors Hosting systems encountered when trying to establish
         * Hosting&#39;s ability to serve secure content for your domain name. Resolve
         * these issues to ensure your `CustomDomain` behaves properly.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder issues(@Nullable Output<List<HostingCustomDomainIssueArgs>> issues) {
            $.issues = issues;
            return this;
        }

        /**
         * @param issues A set of errors Hosting systems encountered when trying to establish
         * Hosting&#39;s ability to serve secure content for your domain name. Resolve
         * these issues to ensure your `CustomDomain` behaves properly.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder issues(List<HostingCustomDomainIssueArgs> issues) {
            return issues(Output.of(issues));
        }

        /**
         * @param issues A set of errors Hosting systems encountered when trying to establish
         * Hosting&#39;s ability to serve secure content for your domain name. Resolve
         * these issues to ensure your `CustomDomain` behaves properly.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder issues(HostingCustomDomainIssueArgs... issues) {
            return issues(List.of(issues));
        }

        /**
         * @param name The fully-qualified name of the `CustomDomain`.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The fully-qualified name of the `CustomDomain`.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param ownershipState The ownership state of your domain name. Ownership is determined at a
         * Firebase project level, and established by adding `TXT` records to your
         * domain name&#39;s DNS records.
         * Ownership cascades to subdomains. Granting a project ownership of `foo.com`
         * also grants that project ownership over `bar.foo.com`, unless you add
         * specific `TXT` records to `bar.foo.com` that grant a different project
         * ownership.
         * If your `CustomDomain` is in an `OwnershipState` other than
         * `OWNERSHIP_ACTIVE` for more than 30 days and it hasn&#39;t been updated in at
         * least 30 days, Hosting&#39;s ownership systems delete the `CustomDomain`.
         * OWNERSHIP_MISSING:
         * Your `CustomDomain`&#39;s domain name has no Hosting-related ownership records;
         * no Firebase project has permission to act on the domain name&#39;s behalf.
         * OWNERSHIP_UNREACHABLE:
         * Your `CustomDomain`&#39;s domain name can&#39;t be reached. Hosting services&#39; DNS
         * queries to find your domain name&#39;s ownership records resulted in errors.
         * See your `CustomDomain`&#39;s `issues` field for more details.
         * OWNERSHIP_MISMATCH:
         * Your `CustomDomain`&#39;s domain name is owned by another Firebase project.
         * Remove the conflicting `TXT` records and replace them with project-specific
         * records for your current Firebase project.
         * OWNERSHIP_CONFLICT:
         * Your `CustomDomain`&#39;s domain name has conflicting `TXT` records that
         * indicate ownership by both your current Firebase project and another
         * project. Remove the other project&#39;s ownership records to grant the current
         * project ownership.
         * OWNERSHIP_PENDING:
         * Your `CustomDomain`&#39;s DNS records are configured correctly. Hosting will
         * transfer ownership of your domain to this `CustomDomain` within 24 hours.
         * OWNERSHIP_ACTIVE:
         * Your `CustomDomain`&#39;s domain name has `TXT` records that grant its project
         * permission to act on its behalf.
         * 
         * @return builder
         * 
         */
        public Builder ownershipState(@Nullable Output<String> ownershipState) {
            $.ownershipState = ownershipState;
            return this;
        }

        /**
         * @param ownershipState The ownership state of your domain name. Ownership is determined at a
         * Firebase project level, and established by adding `TXT` records to your
         * domain name&#39;s DNS records.
         * Ownership cascades to subdomains. Granting a project ownership of `foo.com`
         * also grants that project ownership over `bar.foo.com`, unless you add
         * specific `TXT` records to `bar.foo.com` that grant a different project
         * ownership.
         * If your `CustomDomain` is in an `OwnershipState` other than
         * `OWNERSHIP_ACTIVE` for more than 30 days and it hasn&#39;t been updated in at
         * least 30 days, Hosting&#39;s ownership systems delete the `CustomDomain`.
         * OWNERSHIP_MISSING:
         * Your `CustomDomain`&#39;s domain name has no Hosting-related ownership records;
         * no Firebase project has permission to act on the domain name&#39;s behalf.
         * OWNERSHIP_UNREACHABLE:
         * Your `CustomDomain`&#39;s domain name can&#39;t be reached. Hosting services&#39; DNS
         * queries to find your domain name&#39;s ownership records resulted in errors.
         * See your `CustomDomain`&#39;s `issues` field for more details.
         * OWNERSHIP_MISMATCH:
         * Your `CustomDomain`&#39;s domain name is owned by another Firebase project.
         * Remove the conflicting `TXT` records and replace them with project-specific
         * records for your current Firebase project.
         * OWNERSHIP_CONFLICT:
         * Your `CustomDomain`&#39;s domain name has conflicting `TXT` records that
         * indicate ownership by both your current Firebase project and another
         * project. Remove the other project&#39;s ownership records to grant the current
         * project ownership.
         * OWNERSHIP_PENDING:
         * Your `CustomDomain`&#39;s DNS records are configured correctly. Hosting will
         * transfer ownership of your domain to this `CustomDomain` within 24 hours.
         * OWNERSHIP_ACTIVE:
         * Your `CustomDomain`&#39;s domain name has `TXT` records that grant its project
         * permission to act on its behalf.
         * 
         * @return builder
         * 
         */
        public Builder ownershipState(String ownershipState) {
            return ownershipState(Output.of(ownershipState));
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param reconciling if true, indicates that Hosting&#39;s systems are attempting to
         * make the `CustomDomain`&#39;s state match your preferred state. This is most
         * frequently `true` when initially provisioning a `CustomDomain` or when creating
         * a new SSL certificate to match an updated `certPreference`
         * 
         * @return builder
         * 
         */
        public Builder reconciling(@Nullable Output<Boolean> reconciling) {
            $.reconciling = reconciling;
            return this;
        }

        /**
         * @param reconciling if true, indicates that Hosting&#39;s systems are attempting to
         * make the `CustomDomain`&#39;s state match your preferred state. This is most
         * frequently `true` when initially provisioning a `CustomDomain` or when creating
         * a new SSL certificate to match an updated `certPreference`
         * 
         * @return builder
         * 
         */
        public Builder reconciling(Boolean reconciling) {
            return reconciling(Output.of(reconciling));
        }

        /**
         * @param redirectTarget A domain name that this CustomDomain should direct traffic towards. If
         * specified, Hosting will respond to requests against this CustomDomain
         * with an HTTP 301 code, and route traffic to the specified `redirectTarget`
         * instead.
         * 
         * @return builder
         * 
         */
        public Builder redirectTarget(@Nullable Output<String> redirectTarget) {
            $.redirectTarget = redirectTarget;
            return this;
        }

        /**
         * @param redirectTarget A domain name that this CustomDomain should direct traffic towards. If
         * specified, Hosting will respond to requests against this CustomDomain
         * with an HTTP 301 code, and route traffic to the specified `redirectTarget`
         * instead.
         * 
         * @return builder
         * 
         */
        public Builder redirectTarget(String redirectTarget) {
            return redirectTarget(Output.of(redirectTarget));
        }

        /**
         * @param requiredDnsUpdates A set of updates you should make to the domain name&#39;s DNS records to
         * let Hosting serve secure content on its behalf.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder requiredDnsUpdates(@Nullable Output<List<HostingCustomDomainRequiredDnsUpdateArgs>> requiredDnsUpdates) {
            $.requiredDnsUpdates = requiredDnsUpdates;
            return this;
        }

        /**
         * @param requiredDnsUpdates A set of updates you should make to the domain name&#39;s DNS records to
         * let Hosting serve secure content on its behalf.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder requiredDnsUpdates(List<HostingCustomDomainRequiredDnsUpdateArgs> requiredDnsUpdates) {
            return requiredDnsUpdates(Output.of(requiredDnsUpdates));
        }

        /**
         * @param requiredDnsUpdates A set of updates you should make to the domain name&#39;s DNS records to
         * let Hosting serve secure content on its behalf.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder requiredDnsUpdates(HostingCustomDomainRequiredDnsUpdateArgs... requiredDnsUpdates) {
            return requiredDnsUpdates(List.of(requiredDnsUpdates));
        }

        /**
         * @param siteId The ID of the site in which to create this custom domain association.
         * 
         * @return builder
         * 
         */
        public Builder siteId(@Nullable Output<String> siteId) {
            $.siteId = siteId;
            return this;
        }

        /**
         * @param siteId The ID of the site in which to create this custom domain association.
         * 
         * @return builder
         * 
         */
        public Builder siteId(String siteId) {
            return siteId(Output.of(siteId));
        }

        /**
         * @param updateTime The last time the `CustomDomain` was updated.
         * 
         * @return builder
         * 
         */
        public Builder updateTime(@Nullable Output<String> updateTime) {
            $.updateTime = updateTime;
            return this;
        }

        /**
         * @param updateTime The last time the `CustomDomain` was updated.
         * 
         * @return builder
         * 
         */
        public Builder updateTime(String updateTime) {
            return updateTime(Output.of(updateTime));
        }

        public Builder waitDnsVerification(@Nullable Output<Boolean> waitDnsVerification) {
            $.waitDnsVerification = waitDnsVerification;
            return this;
        }

        public Builder waitDnsVerification(Boolean waitDnsVerification) {
            return waitDnsVerification(Output.of(waitDnsVerification));
        }

        public HostingCustomDomainState build() {
            return $;
        }
    }

}
