// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.compute.inputs.RegionUrlMapDefaultRouteActionArgs;
import com.pulumi.gcp.compute.inputs.RegionUrlMapDefaultUrlRedirectArgs;
import com.pulumi.gcp.compute.inputs.RegionUrlMapHostRuleArgs;
import com.pulumi.gcp.compute.inputs.RegionUrlMapPathMatcherArgs;
import com.pulumi.gcp.compute.inputs.RegionUrlMapTestArgs;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class RegionUrlMapState extends com.pulumi.resources.ResourceArgs {

    public static final RegionUrlMapState Empty = new RegionUrlMapState();

    /**
     * Creation timestamp in RFC3339 text format.
     * 
     */
    @Import(name="creationTimestamp")
    private @Nullable Output<String> creationTimestamp;

    /**
     * @return Creation timestamp in RFC3339 text format.
     * 
     */
    public Optional<Output<String>> creationTimestamp() {
        return Optional.ofNullable(this.creationTimestamp);
    }

    /**
     * defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
     * Only one of defaultRouteAction or defaultUrlRedirect must be set.
     * URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
     * defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
     * Structure is documented below.
     * 
     */
    @Import(name="defaultRouteAction")
    private @Nullable Output<RegionUrlMapDefaultRouteActionArgs> defaultRouteAction;

    /**
     * @return defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
     * Only one of defaultRouteAction or defaultUrlRedirect must be set.
     * URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
     * defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
     * Structure is documented below.
     * 
     */
    public Optional<Output<RegionUrlMapDefaultRouteActionArgs>> defaultRouteAction() {
        return Optional.ofNullable(this.defaultRouteAction);
    }

    /**
     * The full or partial URL of the defaultService resource to which traffic is directed if
     * none of the hostRules match. If defaultRouteAction is additionally specified, advanced
     * routing actions like URL Rewrites, etc. take effect prior to sending the request to the
     * backend. However, if defaultService is specified, defaultRouteAction cannot contain any
     * weightedBackendServices. Conversely, if routeAction specifies any
     * weightedBackendServices, service must not be specified.  Only one of defaultService,
     * defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
     * 
     */
    @Import(name="defaultService")
    private @Nullable Output<String> defaultService;

    /**
     * @return The full or partial URL of the defaultService resource to which traffic is directed if
     * none of the hostRules match. If defaultRouteAction is additionally specified, advanced
     * routing actions like URL Rewrites, etc. take effect prior to sending the request to the
     * backend. However, if defaultService is specified, defaultRouteAction cannot contain any
     * weightedBackendServices. Conversely, if routeAction specifies any
     * weightedBackendServices, service must not be specified.  Only one of defaultService,
     * defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
     * 
     */
    public Optional<Output<String>> defaultService() {
        return Optional.ofNullable(this.defaultService);
    }

    /**
     * When none of the specified hostRules match, the request is redirected to a URL specified
     * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
     * defaultRouteAction must not be set.
     * Structure is documented below.
     * 
     */
    @Import(name="defaultUrlRedirect")
    private @Nullable Output<RegionUrlMapDefaultUrlRedirectArgs> defaultUrlRedirect;

    /**
     * @return When none of the specified hostRules match, the request is redirected to a URL specified
     * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
     * defaultRouteAction must not be set.
     * Structure is documented below.
     * 
     */
    public Optional<Output<RegionUrlMapDefaultUrlRedirectArgs>> defaultUrlRedirect() {
        return Optional.ofNullable(this.defaultUrlRedirect);
    }

    /**
     * An optional description of this resource. Provide this property when
     * you create the resource.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return An optional description of this resource. Provide this property when
     * you create the resource.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Fingerprint of this resource. This field is used internally during
     * updates of this resource.
     * 
     */
    @Import(name="fingerprint")
    private @Nullable Output<String> fingerprint;

    /**
     * @return Fingerprint of this resource. This field is used internally during
     * updates of this resource.
     * 
     */
    public Optional<Output<String>> fingerprint() {
        return Optional.ofNullable(this.fingerprint);
    }

    /**
     * The list of HostRules to use against the URL.
     * Structure is documented below.
     * 
     */
    @Import(name="hostRules")
    private @Nullable Output<List<RegionUrlMapHostRuleArgs>> hostRules;

    /**
     * @return The list of HostRules to use against the URL.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<RegionUrlMapHostRuleArgs>>> hostRules() {
        return Optional.ofNullable(this.hostRules);
    }

    /**
     * The unique identifier for the resource.
     * 
     */
    @Import(name="mapId")
    private @Nullable Output<Integer> mapId;

    /**
     * @return The unique identifier for the resource.
     * 
     */
    public Optional<Output<Integer>> mapId() {
        return Optional.ofNullable(this.mapId);
    }

    /**
     * Name of the resource. Provided by the client when the resource is
     * created. The name must be 1-63 characters long, and comply with
     * RFC1035. Specifically, the name must be 1-63 characters long and match
     * the regular expression `a-z?` which means the
     * first character must be a lowercase letter, and all following
     * characters must be a dash, lowercase letter, or digit, except the last
     * character, which cannot be a dash.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return Name of the resource. Provided by the client when the resource is
     * created. The name must be 1-63 characters long, and comply with
     * RFC1035. Specifically, the name must be 1-63 characters long and match
     * the regular expression `a-z?` which means the
     * first character must be a lowercase letter, and all following
     * characters must be a dash, lowercase letter, or digit, except the last
     * character, which cannot be a dash.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The list of named PathMatchers to use against the URL.
     * Structure is documented below.
     * 
     */
    @Import(name="pathMatchers")
    private @Nullable Output<List<RegionUrlMapPathMatcherArgs>> pathMatchers;

    /**
     * @return The list of named PathMatchers to use against the URL.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<RegionUrlMapPathMatcherArgs>>> pathMatchers() {
        return Optional.ofNullable(this.pathMatchers);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * The Region in which the url map should reside.
     * If it is not provided, the provider region is used.
     * 
     */
    @Import(name="region")
    private @Nullable Output<String> region;

    /**
     * @return The Region in which the url map should reside.
     * If it is not provided, the provider region is used.
     * 
     */
    public Optional<Output<String>> region() {
        return Optional.ofNullable(this.region);
    }

    /**
     * The URI of the created resource.
     * 
     */
    @Import(name="selfLink")
    private @Nullable Output<String> selfLink;

    /**
     * @return The URI of the created resource.
     * 
     */
    public Optional<Output<String>> selfLink() {
        return Optional.ofNullable(this.selfLink);
    }

    /**
     * The list of expected URL mappings. Requests to update this UrlMap will
     * succeed only if all of the test cases pass.
     * Structure is documented below.
     * 
     */
    @Import(name="tests")
    private @Nullable Output<List<RegionUrlMapTestArgs>> tests;

    /**
     * @return The list of expected URL mappings. Requests to update this UrlMap will
     * succeed only if all of the test cases pass.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<RegionUrlMapTestArgs>>> tests() {
        return Optional.ofNullable(this.tests);
    }

    private RegionUrlMapState() {}

    private RegionUrlMapState(RegionUrlMapState $) {
        this.creationTimestamp = $.creationTimestamp;
        this.defaultRouteAction = $.defaultRouteAction;
        this.defaultService = $.defaultService;
        this.defaultUrlRedirect = $.defaultUrlRedirect;
        this.description = $.description;
        this.fingerprint = $.fingerprint;
        this.hostRules = $.hostRules;
        this.mapId = $.mapId;
        this.name = $.name;
        this.pathMatchers = $.pathMatchers;
        this.project = $.project;
        this.region = $.region;
        this.selfLink = $.selfLink;
        this.tests = $.tests;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(RegionUrlMapState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private RegionUrlMapState $;

        public Builder() {
            $ = new RegionUrlMapState();
        }

        public Builder(RegionUrlMapState defaults) {
            $ = new RegionUrlMapState(Objects.requireNonNull(defaults));
        }

        /**
         * @param creationTimestamp Creation timestamp in RFC3339 text format.
         * 
         * @return builder
         * 
         */
        public Builder creationTimestamp(@Nullable Output<String> creationTimestamp) {
            $.creationTimestamp = creationTimestamp;
            return this;
        }

        /**
         * @param creationTimestamp Creation timestamp in RFC3339 text format.
         * 
         * @return builder
         * 
         */
        public Builder creationTimestamp(String creationTimestamp) {
            return creationTimestamp(Output.of(creationTimestamp));
        }

        /**
         * @param defaultRouteAction defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
         * Only one of defaultRouteAction or defaultUrlRedirect must be set.
         * URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
         * defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder defaultRouteAction(@Nullable Output<RegionUrlMapDefaultRouteActionArgs> defaultRouteAction) {
            $.defaultRouteAction = defaultRouteAction;
            return this;
        }

        /**
         * @param defaultRouteAction defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
         * Only one of defaultRouteAction or defaultUrlRedirect must be set.
         * URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
         * defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder defaultRouteAction(RegionUrlMapDefaultRouteActionArgs defaultRouteAction) {
            return defaultRouteAction(Output.of(defaultRouteAction));
        }

        /**
         * @param defaultService The full or partial URL of the defaultService resource to which traffic is directed if
         * none of the hostRules match. If defaultRouteAction is additionally specified, advanced
         * routing actions like URL Rewrites, etc. take effect prior to sending the request to the
         * backend. However, if defaultService is specified, defaultRouteAction cannot contain any
         * weightedBackendServices. Conversely, if routeAction specifies any
         * weightedBackendServices, service must not be specified.  Only one of defaultService,
         * defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
         * 
         * @return builder
         * 
         */
        public Builder defaultService(@Nullable Output<String> defaultService) {
            $.defaultService = defaultService;
            return this;
        }

        /**
         * @param defaultService The full or partial URL of the defaultService resource to which traffic is directed if
         * none of the hostRules match. If defaultRouteAction is additionally specified, advanced
         * routing actions like URL Rewrites, etc. take effect prior to sending the request to the
         * backend. However, if defaultService is specified, defaultRouteAction cannot contain any
         * weightedBackendServices. Conversely, if routeAction specifies any
         * weightedBackendServices, service must not be specified.  Only one of defaultService,
         * defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
         * 
         * @return builder
         * 
         */
        public Builder defaultService(String defaultService) {
            return defaultService(Output.of(defaultService));
        }

        /**
         * @param defaultUrlRedirect When none of the specified hostRules match, the request is redirected to a URL specified
         * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
         * defaultRouteAction must not be set.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder defaultUrlRedirect(@Nullable Output<RegionUrlMapDefaultUrlRedirectArgs> defaultUrlRedirect) {
            $.defaultUrlRedirect = defaultUrlRedirect;
            return this;
        }

        /**
         * @param defaultUrlRedirect When none of the specified hostRules match, the request is redirected to a URL specified
         * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
         * defaultRouteAction must not be set.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder defaultUrlRedirect(RegionUrlMapDefaultUrlRedirectArgs defaultUrlRedirect) {
            return defaultUrlRedirect(Output.of(defaultUrlRedirect));
        }

        /**
         * @param description An optional description of this resource. Provide this property when
         * you create the resource.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description An optional description of this resource. Provide this property when
         * you create the resource.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param fingerprint Fingerprint of this resource. This field is used internally during
         * updates of this resource.
         * 
         * @return builder
         * 
         */
        public Builder fingerprint(@Nullable Output<String> fingerprint) {
            $.fingerprint = fingerprint;
            return this;
        }

        /**
         * @param fingerprint Fingerprint of this resource. This field is used internally during
         * updates of this resource.
         * 
         * @return builder
         * 
         */
        public Builder fingerprint(String fingerprint) {
            return fingerprint(Output.of(fingerprint));
        }

        /**
         * @param hostRules The list of HostRules to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder hostRules(@Nullable Output<List<RegionUrlMapHostRuleArgs>> hostRules) {
            $.hostRules = hostRules;
            return this;
        }

        /**
         * @param hostRules The list of HostRules to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder hostRules(List<RegionUrlMapHostRuleArgs> hostRules) {
            return hostRules(Output.of(hostRules));
        }

        /**
         * @param hostRules The list of HostRules to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder hostRules(RegionUrlMapHostRuleArgs... hostRules) {
            return hostRules(List.of(hostRules));
        }

        /**
         * @param mapId The unique identifier for the resource.
         * 
         * @return builder
         * 
         */
        public Builder mapId(@Nullable Output<Integer> mapId) {
            $.mapId = mapId;
            return this;
        }

        /**
         * @param mapId The unique identifier for the resource.
         * 
         * @return builder
         * 
         */
        public Builder mapId(Integer mapId) {
            return mapId(Output.of(mapId));
        }

        /**
         * @param name Name of the resource. Provided by the client when the resource is
         * created. The name must be 1-63 characters long, and comply with
         * RFC1035. Specifically, the name must be 1-63 characters long and match
         * the regular expression `a-z?` which means the
         * first character must be a lowercase letter, and all following
         * characters must be a dash, lowercase letter, or digit, except the last
         * character, which cannot be a dash.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name Name of the resource. Provided by the client when the resource is
         * created. The name must be 1-63 characters long, and comply with
         * RFC1035. Specifically, the name must be 1-63 characters long and match
         * the regular expression `a-z?` which means the
         * first character must be a lowercase letter, and all following
         * characters must be a dash, lowercase letter, or digit, except the last
         * character, which cannot be a dash.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param pathMatchers The list of named PathMatchers to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder pathMatchers(@Nullable Output<List<RegionUrlMapPathMatcherArgs>> pathMatchers) {
            $.pathMatchers = pathMatchers;
            return this;
        }

        /**
         * @param pathMatchers The list of named PathMatchers to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder pathMatchers(List<RegionUrlMapPathMatcherArgs> pathMatchers) {
            return pathMatchers(Output.of(pathMatchers));
        }

        /**
         * @param pathMatchers The list of named PathMatchers to use against the URL.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder pathMatchers(RegionUrlMapPathMatcherArgs... pathMatchers) {
            return pathMatchers(List.of(pathMatchers));
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param region The Region in which the url map should reside.
         * If it is not provided, the provider region is used.
         * 
         * @return builder
         * 
         */
        public Builder region(@Nullable Output<String> region) {
            $.region = region;
            return this;
        }

        /**
         * @param region The Region in which the url map should reside.
         * If it is not provided, the provider region is used.
         * 
         * @return builder
         * 
         */
        public Builder region(String region) {
            return region(Output.of(region));
        }

        /**
         * @param selfLink The URI of the created resource.
         * 
         * @return builder
         * 
         */
        public Builder selfLink(@Nullable Output<String> selfLink) {
            $.selfLink = selfLink;
            return this;
        }

        /**
         * @param selfLink The URI of the created resource.
         * 
         * @return builder
         * 
         */
        public Builder selfLink(String selfLink) {
            return selfLink(Output.of(selfLink));
        }

        /**
         * @param tests The list of expected URL mappings. Requests to update this UrlMap will
         * succeed only if all of the test cases pass.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder tests(@Nullable Output<List<RegionUrlMapTestArgs>> tests) {
            $.tests = tests;
            return this;
        }

        /**
         * @param tests The list of expected URL mappings. Requests to update this UrlMap will
         * succeed only if all of the test cases pass.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder tests(List<RegionUrlMapTestArgs> tests) {
            return tests(Output.of(tests));
        }

        /**
         * @param tests The list of expected URL mappings. Requests to update this UrlMap will
         * succeed only if all of the test cases pass.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder tests(RegionUrlMapTestArgs... tests) {
            return tests(List.of(tests));
        }

        public RegionUrlMapState build() {
            return $;
        }
    }

}
