// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.vertex.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.vertex.inputs.AiIndexDeployedIndexArgs;
import com.pulumi.gcp.vertex.inputs.AiIndexIndexStatArgs;
import com.pulumi.gcp.vertex.inputs.AiIndexMetadataArgs;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class AiIndexState extends com.pulumi.resources.ResourceArgs {

    public static final AiIndexState Empty = new AiIndexState();

    /**
     * The timestamp of when the Index was created in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits.
     * 
     */
    @Import(name="createTime")
    private @Nullable Output<String> createTime;

    /**
     * @return The timestamp of when the Index was created in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits.
     * 
     */
    public Optional<Output<String>> createTime() {
        return Optional.ofNullable(this.createTime);
    }

    /**
     * The pointers to DeployedIndexes created from this Index. An Index can be only deleted if all its DeployedIndexes had been undeployed first.
     * Structure is documented below.
     * 
     */
    @Import(name="deployedIndexes")
    private @Nullable Output<List<AiIndexDeployedIndexArgs>> deployedIndexes;

    /**
     * @return The pointers to DeployedIndexes created from this Index. An Index can be only deleted if all its DeployedIndexes had been undeployed first.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<AiIndexDeployedIndexArgs>>> deployedIndexes() {
        return Optional.ofNullable(this.deployedIndexes);
    }

    /**
     * The description of the Index.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return The description of the Index.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
     * 
     */
    @Import(name="displayName")
    private @Nullable Output<String> displayName;

    /**
     * @return The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
     * 
     */
    public Optional<Output<String>> displayName() {
        return Optional.ofNullable(this.displayName);
    }

    /**
     * Used to perform consistent read-modify-write updates.
     * 
     */
    @Import(name="etag")
    private @Nullable Output<String> etag;

    /**
     * @return Used to perform consistent read-modify-write updates.
     * 
     */
    public Optional<Output<String>> etag() {
        return Optional.ofNullable(this.etag);
    }

    /**
     * Stats of the index resource.
     * Structure is documented below.
     * 
     */
    @Import(name="indexStats")
    private @Nullable Output<List<AiIndexIndexStatArgs>> indexStats;

    /**
     * @return Stats of the index resource.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<AiIndexIndexStatArgs>>> indexStats() {
        return Optional.ofNullable(this.indexStats);
    }

    /**
     * The update method to use with this Index. The value must be the followings. If not set, BATCH_UPDATE will be used by default.
     * * BATCH_UPDATE: user can call indexes.patch with files on Cloud Storage of datapoints to update.
     * * STREAM_UPDATE: user can call indexes.upsertDatapoints/DeleteDatapoints to update the Index and the updates will be applied in corresponding DeployedIndexes in nearly real-time.
     * 
     */
    @Import(name="indexUpdateMethod")
    private @Nullable Output<String> indexUpdateMethod;

    /**
     * @return The update method to use with this Index. The value must be the followings. If not set, BATCH_UPDATE will be used by default.
     * * BATCH_UPDATE: user can call indexes.patch with files on Cloud Storage of datapoints to update.
     * * STREAM_UPDATE: user can call indexes.upsertDatapoints/DeleteDatapoints to update the Index and the updates will be applied in corresponding DeployedIndexes in nearly real-time.
     * 
     */
    public Optional<Output<String>> indexUpdateMethod() {
        return Optional.ofNullable(this.indexUpdateMethod);
    }

    /**
     * The labels with user-defined metadata to organize your Indexes.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    /**
     * @return The labels with user-defined metadata to organize your Indexes.
     * 
     */
    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * An additional information about the Index
     * Structure is documented below.
     * 
     */
    @Import(name="metadata")
    private @Nullable Output<AiIndexMetadataArgs> metadata;

    /**
     * @return An additional information about the Index
     * Structure is documented below.
     * 
     */
    public Optional<Output<AiIndexMetadataArgs>> metadata() {
        return Optional.ofNullable(this.metadata);
    }

    /**
     * Points to a YAML file stored on Google Cloud Storage describing additional information about the Index, that is specific to it. Unset if the Index does not have any additional information.
     * 
     */
    @Import(name="metadataSchemaUri")
    private @Nullable Output<String> metadataSchemaUri;

    /**
     * @return Points to a YAML file stored on Google Cloud Storage describing additional information about the Index, that is specific to it. Unset if the Index does not have any additional information.
     * 
     */
    public Optional<Output<String>> metadataSchemaUri() {
        return Optional.ofNullable(this.metadataSchemaUri);
    }

    /**
     * The resource name of the Index.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The resource name of the Index.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * The region of the index. eg us-central1
     * 
     */
    @Import(name="region")
    private @Nullable Output<String> region;

    /**
     * @return The region of the index. eg us-central1
     * 
     */
    public Optional<Output<String>> region() {
        return Optional.ofNullable(this.region);
    }

    /**
     * The timestamp of when the Index was last updated in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits.
     * 
     */
    @Import(name="updateTime")
    private @Nullable Output<String> updateTime;

    /**
     * @return The timestamp of when the Index was last updated in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits.
     * 
     */
    public Optional<Output<String>> updateTime() {
        return Optional.ofNullable(this.updateTime);
    }

    private AiIndexState() {}

    private AiIndexState(AiIndexState $) {
        this.createTime = $.createTime;
        this.deployedIndexes = $.deployedIndexes;
        this.description = $.description;
        this.displayName = $.displayName;
        this.etag = $.etag;
        this.indexStats = $.indexStats;
        this.indexUpdateMethod = $.indexUpdateMethod;
        this.labels = $.labels;
        this.metadata = $.metadata;
        this.metadataSchemaUri = $.metadataSchemaUri;
        this.name = $.name;
        this.project = $.project;
        this.region = $.region;
        this.updateTime = $.updateTime;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(AiIndexState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private AiIndexState $;

        public Builder() {
            $ = new AiIndexState();
        }

        public Builder(AiIndexState defaults) {
            $ = new AiIndexState(Objects.requireNonNull(defaults));
        }

        /**
         * @param createTime The timestamp of when the Index was created in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits.
         * 
         * @return builder
         * 
         */
        public Builder createTime(@Nullable Output<String> createTime) {
            $.createTime = createTime;
            return this;
        }

        /**
         * @param createTime The timestamp of when the Index was created in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits.
         * 
         * @return builder
         * 
         */
        public Builder createTime(String createTime) {
            return createTime(Output.of(createTime));
        }

        /**
         * @param deployedIndexes The pointers to DeployedIndexes created from this Index. An Index can be only deleted if all its DeployedIndexes had been undeployed first.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder deployedIndexes(@Nullable Output<List<AiIndexDeployedIndexArgs>> deployedIndexes) {
            $.deployedIndexes = deployedIndexes;
            return this;
        }

        /**
         * @param deployedIndexes The pointers to DeployedIndexes created from this Index. An Index can be only deleted if all its DeployedIndexes had been undeployed first.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder deployedIndexes(List<AiIndexDeployedIndexArgs> deployedIndexes) {
            return deployedIndexes(Output.of(deployedIndexes));
        }

        /**
         * @param deployedIndexes The pointers to DeployedIndexes created from this Index. An Index can be only deleted if all its DeployedIndexes had been undeployed first.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder deployedIndexes(AiIndexDeployedIndexArgs... deployedIndexes) {
            return deployedIndexes(List.of(deployedIndexes));
        }

        /**
         * @param description The description of the Index.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description The description of the Index.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param displayName The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
         * 
         * @return builder
         * 
         */
        public Builder displayName(@Nullable Output<String> displayName) {
            $.displayName = displayName;
            return this;
        }

        /**
         * @param displayName The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
         * 
         * @return builder
         * 
         */
        public Builder displayName(String displayName) {
            return displayName(Output.of(displayName));
        }

        /**
         * @param etag Used to perform consistent read-modify-write updates.
         * 
         * @return builder
         * 
         */
        public Builder etag(@Nullable Output<String> etag) {
            $.etag = etag;
            return this;
        }

        /**
         * @param etag Used to perform consistent read-modify-write updates.
         * 
         * @return builder
         * 
         */
        public Builder etag(String etag) {
            return etag(Output.of(etag));
        }

        /**
         * @param indexStats Stats of the index resource.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder indexStats(@Nullable Output<List<AiIndexIndexStatArgs>> indexStats) {
            $.indexStats = indexStats;
            return this;
        }

        /**
         * @param indexStats Stats of the index resource.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder indexStats(List<AiIndexIndexStatArgs> indexStats) {
            return indexStats(Output.of(indexStats));
        }

        /**
         * @param indexStats Stats of the index resource.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder indexStats(AiIndexIndexStatArgs... indexStats) {
            return indexStats(List.of(indexStats));
        }

        /**
         * @param indexUpdateMethod The update method to use with this Index. The value must be the followings. If not set, BATCH_UPDATE will be used by default.
         * * BATCH_UPDATE: user can call indexes.patch with files on Cloud Storage of datapoints to update.
         * * STREAM_UPDATE: user can call indexes.upsertDatapoints/DeleteDatapoints to update the Index and the updates will be applied in corresponding DeployedIndexes in nearly real-time.
         * 
         * @return builder
         * 
         */
        public Builder indexUpdateMethod(@Nullable Output<String> indexUpdateMethod) {
            $.indexUpdateMethod = indexUpdateMethod;
            return this;
        }

        /**
         * @param indexUpdateMethod The update method to use with this Index. The value must be the followings. If not set, BATCH_UPDATE will be used by default.
         * * BATCH_UPDATE: user can call indexes.patch with files on Cloud Storage of datapoints to update.
         * * STREAM_UPDATE: user can call indexes.upsertDatapoints/DeleteDatapoints to update the Index and the updates will be applied in corresponding DeployedIndexes in nearly real-time.
         * 
         * @return builder
         * 
         */
        public Builder indexUpdateMethod(String indexUpdateMethod) {
            return indexUpdateMethod(Output.of(indexUpdateMethod));
        }

        /**
         * @param labels The labels with user-defined metadata to organize your Indexes.
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels The labels with user-defined metadata to organize your Indexes.
         * 
         * @return builder
         * 
         */
        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        /**
         * @param metadata An additional information about the Index
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder metadata(@Nullable Output<AiIndexMetadataArgs> metadata) {
            $.metadata = metadata;
            return this;
        }

        /**
         * @param metadata An additional information about the Index
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder metadata(AiIndexMetadataArgs metadata) {
            return metadata(Output.of(metadata));
        }

        /**
         * @param metadataSchemaUri Points to a YAML file stored on Google Cloud Storage describing additional information about the Index, that is specific to it. Unset if the Index does not have any additional information.
         * 
         * @return builder
         * 
         */
        public Builder metadataSchemaUri(@Nullable Output<String> metadataSchemaUri) {
            $.metadataSchemaUri = metadataSchemaUri;
            return this;
        }

        /**
         * @param metadataSchemaUri Points to a YAML file stored on Google Cloud Storage describing additional information about the Index, that is specific to it. Unset if the Index does not have any additional information.
         * 
         * @return builder
         * 
         */
        public Builder metadataSchemaUri(String metadataSchemaUri) {
            return metadataSchemaUri(Output.of(metadataSchemaUri));
        }

        /**
         * @param name The resource name of the Index.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The resource name of the Index.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param region The region of the index. eg us-central1
         * 
         * @return builder
         * 
         */
        public Builder region(@Nullable Output<String> region) {
            $.region = region;
            return this;
        }

        /**
         * @param region The region of the index. eg us-central1
         * 
         * @return builder
         * 
         */
        public Builder region(String region) {
            return region(Output.of(region));
        }

        /**
         * @param updateTime The timestamp of when the Index was last updated in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits.
         * 
         * @return builder
         * 
         */
        public Builder updateTime(@Nullable Output<String> updateTime) {
            $.updateTime = updateTime;
            return this;
        }

        /**
         * @param updateTime The timestamp of when the Index was last updated in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits.
         * 
         * @return builder
         * 
         */
        public Builder updateTime(String updateTime) {
            return updateTime(Output.of(updateTime));
        }

        public AiIndexState build() {
            return $;
        }
    }

}
