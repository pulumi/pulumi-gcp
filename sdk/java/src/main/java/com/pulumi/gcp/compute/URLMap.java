// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.compute.URLMapArgs;
import com.pulumi.gcp.compute.inputs.URLMapState;
import com.pulumi.gcp.compute.outputs.URLMapDefaultCustomErrorResponsePolicy;
import com.pulumi.gcp.compute.outputs.URLMapDefaultRouteAction;
import com.pulumi.gcp.compute.outputs.URLMapDefaultUrlRedirect;
import com.pulumi.gcp.compute.outputs.URLMapHeaderAction;
import com.pulumi.gcp.compute.outputs.URLMapHostRule;
import com.pulumi.gcp.compute.outputs.URLMapPathMatcher;
import com.pulumi.gcp.compute.outputs.URLMapTest;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * UrlMaps are used to route requests to a backend service based on rules
 * that you define for the host and path of an incoming URL.
 * 
 * To get more information about UrlMap, see:
 * 
 * * [API documentation](https://cloud.google.com/compute/docs/reference/rest/v1/urlMaps)
 * * How-to Guides
 *     * [Official Documentation](https://cloud.google.com/load-balancing/docs/url-map-concepts)
 * 
 * ## Example Usage
 * 
 * ### Url Map Bucket And Service
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HttpHealthCheck;
 * import com.pulumi.gcp.compute.HttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.storage.Bucket;
 * import com.pulumi.gcp.storage.BucketArgs;
 * import com.pulumi.gcp.compute.BackendBucket;
 * import com.pulumi.gcp.compute.BackendBucketArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapTestArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new HttpHealthCheck("default", HttpHealthCheckArgs.builder()
 *             .name("health-check")
 *             .requestPath("/")
 *             .checkIntervalSec(1)
 *             .timeoutSec(1)
 *             .build());
 * 
 *         var login = new BackendService("login", BackendServiceArgs.builder()
 *             .name("login")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .healthChecks(default_.id())
 *             .build());
 * 
 *         var staticBucket = new Bucket("staticBucket", BucketArgs.builder()
 *             .name("static-asset-bucket")
 *             .location("US")
 *             .build());
 * 
 *         var static_ = new BackendBucket("static", BackendBucketArgs.builder()
 *             .name("static-asset-backend-bucket")
 *             .bucketName(staticBucket.name())
 *             .enableCdn(true)
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("a description")
 *             .defaultService(static_.id())
 *             .hostRules(            
 *                 URLMapHostRuleArgs.builder()
 *                     .hosts("mysite.com")
 *                     .pathMatcher("mysite")
 *                     .build(),
 *                 URLMapHostRuleArgs.builder()
 *                     .hosts("myothersite.com")
 *                     .pathMatcher("otherpaths")
 *                     .build())
 *             .pathMatchers(            
 *                 URLMapPathMatcherArgs.builder()
 *                     .name("mysite")
 *                     .defaultService(static_.id())
 *                     .pathRules(                    
 *                         URLMapPathMatcherPathRuleArgs.builder()
 *                             .paths("/home")
 *                             .service(static_.id())
 *                             .build(),
 *                         URLMapPathMatcherPathRuleArgs.builder()
 *                             .paths("/login")
 *                             .service(login.id())
 *                             .build(),
 *                         URLMapPathMatcherPathRuleArgs.builder()
 *                             .paths("/static")
 *                             .service(static_.id())
 *                             .build())
 *                     .build(),
 *                 URLMapPathMatcherArgs.builder()
 *                     .name("otherpaths")
 *                     .defaultService(static_.id())
 *                     .build())
 *             .tests(URLMapTestArgs.builder()
 *                 .service(static_.id())
 *                 .host("example.com")
 *                 .path("/home")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Traffic Director Route
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapTestArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new HealthCheck("default", HealthCheckArgs.builder()
 *             .name("health-check")
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build());
 * 
 *         var home = new BackendService("home", BackendServiceArgs.builder()
 *             .name("home")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .healthChecks(default_.id())
 *             .loadBalancingScheme("INTERNAL_SELF_MANAGED")
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("a description")
 *             .defaultService(home.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("mysite.com")
 *                 .pathMatcher("allpaths")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("allpaths")
 *                 .defaultService(home.id())
 *                 .routeRules(URLMapPathMatcherRouteRuleArgs.builder()
 *                     .priority(1)
 *                     .headerAction(URLMapPathMatcherRouteRuleHeaderActionArgs.builder()
 *                         .requestHeadersToRemoves("RemoveMe2")
 *                         .requestHeadersToAdds(URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAddArgs.builder()
 *                             .headerName("AddSomethingElse")
 *                             .headerValue("MyOtherValue")
 *                             .replace(true)
 *                             .build())
 *                         .responseHeadersToRemoves("RemoveMe3")
 *                         .responseHeadersToAdds(URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAddArgs.builder()
 *                             .headerName("AddMe")
 *                             .headerValue("MyValue")
 *                             .replace(false)
 *                             .build())
 *                         .build())
 *                     .matchRules(URLMapPathMatcherRouteRuleMatchRuleArgs.builder()
 *                         .fullPathMatch("a full path")
 *                         .headerMatches(URLMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs.builder()
 *                             .headerName("someheader")
 *                             .exactMatch("match this exactly")
 *                             .invertMatch(true)
 *                             .build())
 *                         .ignoreCase(true)
 *                         .metadataFilters(URLMapPathMatcherRouteRuleMatchRuleMetadataFilterArgs.builder()
 *                             .filterMatchCriteria("MATCH_ANY")
 *                             .filterLabels(URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabelArgs.builder()
 *                                 .name("PLANET")
 *                                 .value("MARS")
 *                                 .build())
 *                             .build())
 *                         .queryParameterMatches(URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs.builder()
 *                             .name("a query parameter")
 *                             .presentMatch(true)
 *                             .build())
 *                         .build())
 *                     .urlRedirect(URLMapPathMatcherRouteRuleUrlRedirectArgs.builder()
 *                         .hostRedirect("A host")
 *                         .httpsRedirect(false)
 *                         .pathRedirect("some/path")
 *                         .redirectResponseCode("TEMPORARY_REDIRECT")
 *                         .stripQuery(true)
 *                         .build())
 *                     .build())
 *                 .build())
 *             .tests(URLMapTestArgs.builder()
 *                 .service(home.id())
 *                 .host("hi.com")
 *                 .path("/home")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Traffic Director Route Partial
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapTestArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new HealthCheck("default", HealthCheckArgs.builder()
 *             .name("health-check")
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build());
 * 
 *         var home = new BackendService("home", BackendServiceArgs.builder()
 *             .name("home")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .healthChecks(default_.id())
 *             .loadBalancingScheme("INTERNAL_SELF_MANAGED")
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("a description")
 *             .defaultService(home.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("mysite.com")
 *                 .pathMatcher("allpaths")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("allpaths")
 *                 .defaultService(home.id())
 *                 .routeRules(URLMapPathMatcherRouteRuleArgs.builder()
 *                     .priority(1)
 *                     .matchRules(URLMapPathMatcherRouteRuleMatchRuleArgs.builder()
 *                         .prefixMatch("/someprefix")
 *                         .headerMatches(URLMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs.builder()
 *                             .headerName("someheader")
 *                             .exactMatch("match this exactly")
 *                             .invertMatch(true)
 *                             .build())
 *                         .build())
 *                     .urlRedirect(URLMapPathMatcherRouteRuleUrlRedirectArgs.builder()
 *                         .pathRedirect("some/path")
 *                         .redirectResponseCode("TEMPORARY_REDIRECT")
 *                         .build())
 *                     .build())
 *                 .build())
 *             .tests(URLMapTestArgs.builder()
 *                 .service(home.id())
 *                 .host("hi.com")
 *                 .path("/home")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Traffic Director Path
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapTestArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new HealthCheck("default", HealthCheckArgs.builder()
 *             .name("health-check")
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build());
 * 
 *         var home = new BackendService("home", BackendServiceArgs.builder()
 *             .name("home")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .healthChecks(default_.id())
 *             .loadBalancingScheme("INTERNAL_SELF_MANAGED")
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("a description")
 *             .defaultService(home.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("mysite.com")
 *                 .pathMatcher("allpaths")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("allpaths")
 *                 .defaultService(home.id())
 *                 .pathRules(URLMapPathMatcherPathRuleArgs.builder()
 *                     .paths("/home")
 *                     .routeAction(URLMapPathMatcherPathRuleRouteActionArgs.builder()
 *                         .corsPolicy(URLMapPathMatcherPathRuleRouteActionCorsPolicyArgs.builder()
 *                             .allowCredentials(true)
 *                             .allowHeaders("Allowed content")
 *                             .allowMethods("GET")
 *                             .allowOriginRegexes("abc.*")
 *                             .allowOrigins("Allowed origin")
 *                             .exposeHeaders("Exposed header")
 *                             .maxAge(30)
 *                             .disabled(false)
 *                             .build())
 *                         .faultInjectionPolicy(URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyArgs.builder()
 *                             .abort(URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortArgs.builder()
 *                                 .httpStatus(234)
 *                                 .percentage(5.6)
 *                                 .build())
 *                             .delay(URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayArgs.builder()
 *                                 .fixedDelay(URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayArgs.builder()
 *                                     .seconds("0")
 *                                     .nanos(50000)
 *                                     .build())
 *                                 .percentage(7.8)
 *                                 .build())
 *                             .build())
 *                         .requestMirrorPolicy(URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicyArgs.builder()
 *                             .backendService(home.id())
 *                             .build())
 *                         .retryPolicy(URLMapPathMatcherPathRuleRouteActionRetryPolicyArgs.builder()
 *                             .numRetries(4)
 *                             .perTryTimeout(URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutArgs.builder()
 *                                 .seconds("30")
 *                                 .build())
 *                             .retryConditions(                            
 *                                 "5xx",
 *                                 "deadline-exceeded")
 *                             .build())
 *                         .timeout(URLMapPathMatcherPathRuleRouteActionTimeoutArgs.builder()
 *                             .seconds("20")
 *                             .nanos(750000000)
 *                             .build())
 *                         .urlRewrite(URLMapPathMatcherPathRuleRouteActionUrlRewriteArgs.builder()
 *                             .hostRewrite("dev.example.com")
 *                             .pathPrefixRewrite("/v1/api/")
 *                             .build())
 *                         .weightedBackendServices(URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceArgs.builder()
 *                             .backendService(home.id())
 *                             .weight(400)
 *                             .headerAction(URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionArgs.builder()
 *                                 .requestHeadersToRemoves("RemoveMe")
 *                                 .requestHeadersToAdds(URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs.builder()
 *                                     .headerName("AddMe")
 *                                     .headerValue("MyValue")
 *                                     .replace(true)
 *                                     .build())
 *                                 .responseHeadersToRemoves("RemoveMe")
 *                                 .responseHeadersToAdds(URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs.builder()
 *                                     .headerName("AddMe")
 *                                     .headerValue("MyValue")
 *                                     .replace(false)
 *                                     .build())
 *                                 .build())
 *                             .build())
 *                         .build())
 *                     .build())
 *                 .build())
 *             .tests(URLMapTestArgs.builder()
 *                 .service(home.id())
 *                 .host("hi.com")
 *                 .path("/home")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Traffic Director Path Partial
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapTestArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new HealthCheck("default", HealthCheckArgs.builder()
 *             .name("health-check")
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build());
 * 
 *         var home = new BackendService("home", BackendServiceArgs.builder()
 *             .name("home")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .healthChecks(default_.id())
 *             .loadBalancingScheme("INTERNAL_SELF_MANAGED")
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("a description")
 *             .defaultService(home.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("mysite.com")
 *                 .pathMatcher("allpaths")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("allpaths")
 *                 .defaultService(home.id())
 *                 .pathRules(URLMapPathMatcherPathRuleArgs.builder()
 *                     .paths("/home")
 *                     .routeAction(URLMapPathMatcherPathRuleRouteActionArgs.builder()
 *                         .corsPolicy(URLMapPathMatcherPathRuleRouteActionCorsPolicyArgs.builder()
 *                             .allowCredentials(true)
 *                             .allowHeaders("Allowed content")
 *                             .allowMethods("GET")
 *                             .allowOriginRegexes("abc.*")
 *                             .allowOrigins("Allowed origin")
 *                             .exposeHeaders("Exposed header")
 *                             .maxAge(30)
 *                             .disabled(false)
 *                             .build())
 *                         .weightedBackendServices(URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceArgs.builder()
 *                             .backendService(home.id())
 *                             .weight(400)
 *                             .headerAction(URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionArgs.builder()
 *                                 .requestHeadersToRemoves("RemoveMe")
 *                                 .requestHeadersToAdds(URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAddArgs.builder()
 *                                     .headerName("AddMe")
 *                                     .headerValue("MyValue")
 *                                     .replace(true)
 *                                     .build())
 *                                 .responseHeadersToRemoves("RemoveMe")
 *                                 .responseHeadersToAdds(URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAddArgs.builder()
 *                                     .headerName("AddMe")
 *                                     .headerValue("MyValue")
 *                                     .replace(false)
 *                                     .build())
 *                                 .build())
 *                             .build())
 *                         .maxStreamDuration(URLMapPathMatcherPathRuleRouteActionMaxStreamDurationArgs.builder()
 *                             .nanos(500000)
 *                             .seconds("9")
 *                             .build())
 *                         .build())
 *                     .build())
 *                 .build())
 *             .tests(URLMapTestArgs.builder()
 *                 .service(home.id())
 *                 .host("hi.com")
 *                 .path("/home")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Header Based Routing
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HttpHealthCheck;
 * import com.pulumi.gcp.compute.HttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var defaultHttpHealthCheck = new HttpHealthCheck("defaultHttpHealthCheck", HttpHealthCheckArgs.builder()
 *             .name("health-check")
 *             .requestPath("/")
 *             .checkIntervalSec(1)
 *             .timeoutSec(1)
 *             .build());
 * 
 *         var default_ = new BackendService("default", BackendServiceArgs.builder()
 *             .name("default")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .healthChecks(defaultHttpHealthCheck.id())
 *             .build());
 * 
 *         var service_a = new BackendService("service-a", BackendServiceArgs.builder()
 *             .name("service-a")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .healthChecks(defaultHttpHealthCheck.id())
 *             .build());
 * 
 *         var service_b = new BackendService("service-b", BackendServiceArgs.builder()
 *             .name("service-b")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .healthChecks(defaultHttpHealthCheck.id())
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("header-based routing example")
 *             .defaultService(default_.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("*")
 *                 .pathMatcher("allpaths")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("allpaths")
 *                 .defaultService(default_.id())
 *                 .routeRules(                
 *                     URLMapPathMatcherRouteRuleArgs.builder()
 *                         .priority(1)
 *                         .service(service_a.id())
 *                         .matchRules(URLMapPathMatcherRouteRuleMatchRuleArgs.builder()
 *                             .prefixMatch("/")
 *                             .ignoreCase(true)
 *                             .headerMatches(URLMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs.builder()
 *                                 .headerName("abtest")
 *                                 .exactMatch("a")
 *                                 .build())
 *                             .build())
 *                         .build(),
 *                     URLMapPathMatcherRouteRuleArgs.builder()
 *                         .priority(2)
 *                         .service(service_b.id())
 *                         .matchRules(URLMapPathMatcherRouteRuleMatchRuleArgs.builder()
 *                             .ignoreCase(true)
 *                             .prefixMatch("/")
 *                             .headerMatches(URLMapPathMatcherRouteRuleMatchRuleHeaderMatchArgs.builder()
 *                                 .headerName("abtest")
 *                                 .exactMatch("b")
 *                                 .build())
 *                             .build())
 *                         .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Parameter Based Routing
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HttpHealthCheck;
 * import com.pulumi.gcp.compute.HttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var defaultHttpHealthCheck = new HttpHealthCheck("defaultHttpHealthCheck", HttpHealthCheckArgs.builder()
 *             .name("health-check")
 *             .requestPath("/")
 *             .checkIntervalSec(1)
 *             .timeoutSec(1)
 *             .build());
 * 
 *         var default_ = new BackendService("default", BackendServiceArgs.builder()
 *             .name("default")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .healthChecks(defaultHttpHealthCheck.id())
 *             .build());
 * 
 *         var service_a = new BackendService("service-a", BackendServiceArgs.builder()
 *             .name("service-a")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .healthChecks(defaultHttpHealthCheck.id())
 *             .build());
 * 
 *         var service_b = new BackendService("service-b", BackendServiceArgs.builder()
 *             .name("service-b")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .healthChecks(defaultHttpHealthCheck.id())
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("parameter-based routing example")
 *             .defaultService(default_.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("*")
 *                 .pathMatcher("allpaths")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("allpaths")
 *                 .defaultService(default_.id())
 *                 .routeRules(                
 *                     URLMapPathMatcherRouteRuleArgs.builder()
 *                         .priority(1)
 *                         .service(service_a.id())
 *                         .matchRules(URLMapPathMatcherRouteRuleMatchRuleArgs.builder()
 *                             .prefixMatch("/")
 *                             .ignoreCase(true)
 *                             .queryParameterMatches(URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs.builder()
 *                                 .name("abtest")
 *                                 .exactMatch("a")
 *                                 .build())
 *                             .build())
 *                         .build(),
 *                     URLMapPathMatcherRouteRuleArgs.builder()
 *                         .priority(2)
 *                         .service(service_b.id())
 *                         .matchRules(URLMapPathMatcherRouteRuleMatchRuleArgs.builder()
 *                             .ignoreCase(true)
 *                             .prefixMatch("/")
 *                             .queryParameterMatches(URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs.builder()
 *                                 .name("abtest")
 *                                 .exactMatch("b")
 *                                 .build())
 *                             .build())
 *                         .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Default Mirror Percent
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapDefaultRouteActionArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapDefaultRouteActionRequestMirrorPolicyArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new HealthCheck("default", HealthCheckArgs.builder()
 *             .name("health-check")
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build());
 * 
 *         var home = new BackendService("home", BackendServiceArgs.builder()
 *             .name("home")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("EXTERNAL_MANAGED")
 *             .healthChecks(default_.id())
 *             .build());
 * 
 *         var mirror = new BackendService("mirror", BackendServiceArgs.builder()
 *             .name("mirror")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("EXTERNAL_MANAGED")
 *             .healthChecks(default_.id())
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("Test for default route action mirror percent")
 *             .defaultService(home.id())
 *             .defaultRouteAction(URLMapDefaultRouteActionArgs.builder()
 *                 .requestMirrorPolicy(URLMapDefaultRouteActionRequestMirrorPolicyArgs.builder()
 *                     .backendService(mirror.id())
 *                     .mirrorPercent(50.0)
 *                     .build())
 *                 .build())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("mysite.com")
 *                 .pathMatcher("allpaths")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("allpaths")
 *                 .defaultService(home.id())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Path Matcher Default Mirror Percent
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapDefaultRouteActionArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapDefaultRouteActionRequestMirrorPolicyArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new HealthCheck("default", HealthCheckArgs.builder()
 *             .name("health-check")
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build());
 * 
 *         var home = new BackendService("home", BackendServiceArgs.builder()
 *             .name("home")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("EXTERNAL_MANAGED")
 *             .healthChecks(default_.id())
 *             .build());
 * 
 *         var mirror = new BackendService("mirror", BackendServiceArgs.builder()
 *             .name("mirror")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("EXTERNAL_MANAGED")
 *             .healthChecks(default_.id())
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("Test for default route action mirror percent")
 *             .defaultService(home.id())
 *             .defaultRouteAction(URLMapDefaultRouteActionArgs.builder()
 *                 .requestMirrorPolicy(URLMapDefaultRouteActionRequestMirrorPolicyArgs.builder()
 *                     .backendService(mirror.id())
 *                     .mirrorPercent(50.0)
 *                     .build())
 *                 .build())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("mysite.com")
 *                 .pathMatcher("allpaths")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("allpaths")
 *                 .defaultService(home.id())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Path Rule Mirror Percent
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherDefaultRouteActionArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherDefaultRouteActionRequestMirrorPolicyArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new HealthCheck("default", HealthCheckArgs.builder()
 *             .name("health-check")
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build());
 * 
 *         var home = new BackendService("home", BackendServiceArgs.builder()
 *             .name("home")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("EXTERNAL_MANAGED")
 *             .healthChecks(default_.id())
 *             .build());
 * 
 *         var mirror = new BackendService("mirror", BackendServiceArgs.builder()
 *             .name("mirror")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("EXTERNAL_MANAGED")
 *             .healthChecks(default_.id())
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("Test for path matcher default route action mirror percent")
 *             .defaultService(home.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("mysite.com")
 *                 .pathMatcher("allpaths")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("allpaths")
 *                 .defaultService(home.id())
 *                 .defaultRouteAction(URLMapPathMatcherDefaultRouteActionArgs.builder()
 *                     .requestMirrorPolicy(URLMapPathMatcherDefaultRouteActionRequestMirrorPolicyArgs.builder()
 *                         .backendService(mirror.id())
 *                         .mirrorPercent(75.0)
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Route Rule Mirror Percent
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new HealthCheck("default", HealthCheckArgs.builder()
 *             .name("health-check")
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build());
 * 
 *         var home = new BackendService("home", BackendServiceArgs.builder()
 *             .name("home")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("EXTERNAL_MANAGED")
 *             .healthChecks(default_.id())
 *             .build());
 * 
 *         var mirror = new BackendService("mirror", BackendServiceArgs.builder()
 *             .name("mirror")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("EXTERNAL_MANAGED")
 *             .healthChecks(default_.id())
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("Test for path rule route action mirror percent")
 *             .defaultService(home.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("mysite.com")
 *                 .pathMatcher("allpaths")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("allpaths")
 *                 .defaultService(home.id())
 *                 .pathRules(URLMapPathMatcherPathRuleArgs.builder()
 *                     .paths("/home")
 *                     .service(home.id())
 *                     .routeAction(URLMapPathMatcherPathRuleRouteActionArgs.builder()
 *                         .requestMirrorPolicy(URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicyArgs.builder()
 *                             .backendService(mirror.id())
 *                             .mirrorPercent(25.0)
 *                             .build())
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Test Headers
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckTcpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapTestArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var health_check = new HealthCheck("health-check", HealthCheckArgs.builder()
 *             .name("health-check")
 *             .timeoutSec(1)
 *             .checkIntervalSec(1)
 *             .tcpHealthCheck(HealthCheckTcpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build());
 * 
 *         var backend = new BackendService("backend", BackendServiceArgs.builder()
 *             .name("backend")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .healthChecks(health_check.id())
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("URL map with test headers")
 *             .defaultService(backend.id())
 *             .tests(            
 *                 URLMapTestArgs.builder()
 *                     .description("Test with custom headers")
 *                     .host("example.com")
 *                     .path("/")
 *                     .service(backend.id())
 *                     .headers(                    
 *                         URLMapTestHeaderArgs.builder()
 *                             .name("User-Agent")
 *                             .value("TestBot/1.0")
 *                             .build(),
 *                         URLMapTestHeaderArgs.builder()
 *                             .name("X-Custom-Header")
 *                             .value("test-value")
 *                             .build())
 *                     .build(),
 *                 URLMapTestArgs.builder()
 *                     .description("Test with authorization headers")
 *                     .host("api.example.com")
 *                     .path("/v1/test")
 *                     .service(backend.id())
 *                     .headers(                    
 *                         URLMapTestHeaderArgs.builder()
 *                             .name("Authorization")
 *                             .value("Bearer token123")
 *                             .build(),
 *                         URLMapTestHeaderArgs.builder()
 *                             .name("Content-Type")
 *                             .value("application/json")
 *                             .build())
 *                     .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Test Expected Output Url
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckTcpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapTestArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var health_check = new HealthCheck("health-check", HealthCheckArgs.builder()
 *             .name("health-check")
 *             .timeoutSec(1)
 *             .checkIntervalSec(1)
 *             .tcpHealthCheck(HealthCheckTcpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build());
 * 
 *         var backend = new BackendService("backend", BackendServiceArgs.builder()
 *             .name("backend")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .healthChecks(health_check.id())
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("URL map with expected output URL tests")
 *             .defaultService(backend.id())
 *             .tests(            
 *                 URLMapTestArgs.builder()
 *                     .description("Test with expected output URL")
 *                     .host("example.com")
 *                     .path("/")
 *                     .service(backend.id())
 *                     .headers(URLMapTestHeaderArgs.builder()
 *                         .name("User-Agent")
 *                         .value("TestBot/1.0")
 *                         .build())
 *                     .expectedOutputUrl("http://example.com/")
 *                     .build(),
 *                 URLMapTestArgs.builder()
 *                     .description("Test API routing with expected output URL")
 *                     .host("api.example.com")
 *                     .path("/v1/users")
 *                     .service(backend.id())
 *                     .headers(URLMapTestHeaderArgs.builder()
 *                         .name("Authorization")
 *                         .value("Bearer token123")
 *                         .build())
 *                     .expectedOutputUrl("http://api.example.com/v1/users")
 *                     .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Test Redirect Response Code
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckTcpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapTestArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var health_check = new HealthCheck("health-check", HealthCheckArgs.builder()
 *             .name("health-check")
 *             .timeoutSec(1)
 *             .checkIntervalSec(1)
 *             .tcpHealthCheck(HealthCheckTcpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build());
 * 
 *         var backend = new BackendService("backend", BackendServiceArgs.builder()
 *             .name("backend")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .healthChecks(health_check.id())
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("URL map with redirect response code tests")
 *             .defaultService(backend.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("example.com")
 *                 .pathMatcher("allpaths")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("allpaths")
 *                 .defaultService(backend.id())
 *                 .pathRules(URLMapPathMatcherPathRuleArgs.builder()
 *                     .paths("/redirect/*")
 *                     .urlRedirect(URLMapPathMatcherPathRuleUrlRedirectArgs.builder()
 *                         .hostRedirect("newsite.com")
 *                         .pathRedirect("/new-path/")
 *                         .httpsRedirect(true)
 *                         .redirectResponseCode("MOVED_PERMANENTLY_DEFAULT")
 *                         .stripQuery(false)
 *                         .build())
 *                     .build())
 *                 .build())
 *             .tests(            
 *                 URLMapTestArgs.builder()
 *                     .description("Test redirect with expected response code")
 *                     .host("example.com")
 *                     .path("/redirect/old-page")
 *                     .headers(URLMapTestHeaderArgs.builder()
 *                         .name("Referer")
 *                         .value("https://oldsite.com")
 *                         .build())
 *                     .expectedOutputUrl("https://newsite.com/new-path/")
 *                     .expectedRedirectResponseCode(301)
 *                     .build(),
 *                 URLMapTestArgs.builder()
 *                     .description("Test another redirect scenario")
 *                     .host("example.com")
 *                     .path("/redirect/another-page")
 *                     .headers(URLMapTestHeaderArgs.builder()
 *                         .name("User-Agent")
 *                         .value("TestBot/1.0")
 *                         .build())
 *                     .expectedOutputUrl("https://newsite.com/new-path/")
 *                     .expectedRedirectResponseCode(301)
 *                     .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Path Template Match
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HttpHealthCheck;
 * import com.pulumi.gcp.compute.HttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.storage.Bucket;
 * import com.pulumi.gcp.storage.BucketArgs;
 * import com.pulumi.gcp.compute.BackendBucket;
 * import com.pulumi.gcp.compute.BackendBucketArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App }{{@code
 *     public static void main(String[] args) }{{@code
 *         Pulumi.run(App::stack);
 *     }}{@code
 * 
 *     public static void stack(Context ctx) }{{@code
 *         var default_ = new HttpHealthCheck("default", HttpHealthCheckArgs.builder()
 *             .name("health-check")
 *             .requestPath("/")
 *             .checkIntervalSec(1)
 *             .timeoutSec(1)
 *             .build());
 * 
 *         var cart_backend = new BackendService("cart-backend", BackendServiceArgs.builder()
 *             .name("cart-service")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("EXTERNAL_MANAGED")
 *             .healthChecks(default_.id())
 *             .build());
 * 
 *         var user_backend = new BackendService("user-backend", BackendServiceArgs.builder()
 *             .name("user-service")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("EXTERNAL_MANAGED")
 *             .healthChecks(default_.id())
 *             .build());
 * 
 *         var staticBucket = new Bucket("staticBucket", BucketArgs.builder()
 *             .name("static-asset-bucket")
 *             .location("US")
 *             .build());
 * 
 *         var static_ = new BackendBucket("static", BackendBucketArgs.builder()
 *             .name("static-asset-backend-bucket")
 *             .bucketName(staticBucket.name())
 *             .enableCdn(true)
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("a description")
 *             .defaultService(static_.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("mysite.com")
 *                 .pathMatcher("mysite")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("mysite")
 *                 .defaultService(static_.id())
 *                 .routeRules(                
 *                     URLMapPathMatcherRouteRuleArgs.builder()
 *                         .matchRules(URLMapPathMatcherRouteRuleMatchRuleArgs.builder()
 *                             .pathTemplateMatch("/xyzwebservices/v2/xyz/users/}{{@code username=*}}{@code /carts/}{{@code cartid=**}}{@code ")
 *                             .build())
 *                         .service(cart_backend.id())
 *                         .priority(1)
 *                         .routeAction(URLMapPathMatcherRouteRuleRouteActionArgs.builder()
 *                             .urlRewrite(URLMapPathMatcherRouteRuleRouteActionUrlRewriteArgs.builder()
 *                                 .pathTemplateRewrite("/}{{@code username}}{@code -}{{@code cartid}}{@code /")
 *                                 .build())
 *                             .build())
 *                         .build(),
 *                     URLMapPathMatcherRouteRuleArgs.builder()
 *                         .matchRules(URLMapPathMatcherRouteRuleMatchRuleArgs.builder()
 *                             .pathTemplateMatch("/xyzwebservices/v2/xyz/users/*}&#47;{@code accountinfo/*")
 *                             .build())
 *                         .service(user_backend.id())
 *                         .priority(2)
 *                         .build())
 *                 .build())
 *             .build());
 * 
 *     }}{@code
 * }}{@code
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Custom Error Response Policy
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HttpHealthCheck;
 * import com.pulumi.gcp.compute.HttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.storage.Bucket;
 * import com.pulumi.gcp.storage.BucketArgs;
 * import com.pulumi.gcp.compute.BackendBucket;
 * import com.pulumi.gcp.compute.BackendBucketArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapDefaultCustomErrorResponsePolicyArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherDefaultCustomErrorResponsePolicyArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new HttpHealthCheck("default", HttpHealthCheckArgs.builder()
 *             .name("health-check")
 *             .requestPath("/")
 *             .checkIntervalSec(1)
 *             .timeoutSec(1)
 *             .build());
 * 
 *         var example = new BackendService("example", BackendServiceArgs.builder()
 *             .name("login")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("EXTERNAL_MANAGED")
 *             .healthChecks(default_.id())
 *             .build());
 * 
 *         var errorBucket = new Bucket("errorBucket", BucketArgs.builder()
 *             .name("static-asset-bucket")
 *             .location("US")
 *             .build());
 * 
 *         var error = new BackendBucket("error", BackendBucketArgs.builder()
 *             .name("error-backend-bucket")
 *             .bucketName(errorBucket.name())
 *             .enableCdn(true)
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("a description")
 *             .defaultService(example.id())
 *             .defaultCustomErrorResponsePolicy(URLMapDefaultCustomErrorResponsePolicyArgs.builder()
 *                 .errorResponseRules(URLMapDefaultCustomErrorResponsePolicyErrorResponseRuleArgs.builder()
 *                     .matchResponseCodes("5xx")
 *                     .path("/internal_error.html")
 *                     .overrideResponseCode(502)
 *                     .build())
 *                 .errorService(error.id())
 *                 .build())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("mysite.com")
 *                 .pathMatcher("mysite")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("mysite")
 *                 .defaultService(example.id())
 *                 .defaultCustomErrorResponsePolicy(URLMapPathMatcherDefaultCustomErrorResponsePolicyArgs.builder()
 *                     .errorResponseRules(                    
 *                         URLMapPathMatcherDefaultCustomErrorResponsePolicyErrorResponseRuleArgs.builder()
 *                             .matchResponseCodes(                            
 *                                 "4xx",
 *                                 "5xx")
 *                             .path("/login_error.html")
 *                             .overrideResponseCode(404)
 *                             .build(),
 *                         URLMapPathMatcherDefaultCustomErrorResponsePolicyErrorResponseRuleArgs.builder()
 *                             .matchResponseCodes("503")
 *                             .path("/bad_gateway.html")
 *                             .overrideResponseCode(502)
 *                             .build())
 *                     .errorService(error.id())
 *                     .build())
 *                 .pathRules(URLMapPathMatcherPathRuleArgs.builder()
 *                     .paths("/private/*")
 *                     .service(example.id())
 *                     .customErrorResponsePolicy(URLMapPathMatcherPathRuleCustomErrorResponsePolicyArgs.builder()
 *                         .errorResponseRules(URLMapPathMatcherPathRuleCustomErrorResponsePolicyErrorResponseRuleArgs.builder()
 *                             .matchResponseCodes("4xx")
 *                             .path("/login.html")
 *                             .overrideResponseCode(401)
 *                             .build())
 *                         .errorService(error.id())
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Http Filter Configs
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapTestArgs;
 * import static com.pulumi.codegen.internal.Serialization.*;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var defaultHealthCheck = new HealthCheck("defaultHealthCheck", HealthCheckArgs.builder()
 *             .name("health-check")
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build());
 * 
 *         var default_ = new BackendService("default", BackendServiceArgs.builder()
 *             .name("default-backend")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("INTERNAL_SELF_MANAGED")
 *             .healthChecks(defaultHealthCheck.id())
 *             .build());
 * 
 *         var service_a = new BackendService("service-a", BackendServiceArgs.builder()
 *             .name("service-a-backend")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("INTERNAL_SELF_MANAGED")
 *             .healthChecks(defaultHealthCheck.id())
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("Test for httpFilterConfigs in route rules")
 *             .defaultService(default_.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("mysite.com")
 *                 .pathMatcher("allpaths")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("allpaths")
 *                 .defaultService(default_.id())
 *                 .routeRules(URLMapPathMatcherRouteRuleArgs.builder()
 *                     .priority(1)
 *                     .service(service_a.id())
 *                     .matchRules(URLMapPathMatcherRouteRuleMatchRuleArgs.builder()
 *                         .prefixMatch("/")
 *                         .ignoreCase(true)
 *                         .build())
 *                     .httpFilterConfigs(URLMapPathMatcherRouteRuleHttpFilterConfigArgs.builder()
 *                         .filterName("envoy.wasm")
 *                         .configTypeUrl("type.googleapis.com/google.protobuf.Struct")
 *                         .config(serializeJson(
 *                             jsonObject(
 *                                 jsonProperty("name", "my-filter"),
 *                                 jsonProperty("root_id", "my_root_id"),
 *                                 jsonProperty("vm_config", jsonObject(
 *                                     jsonProperty("vm_id", "my_vm_id"),
 *                                     jsonProperty("runtime", "envoy.wasm.runtime.v8"),
 *                                     jsonProperty("code", jsonObject(
 *                                         jsonProperty("local", jsonObject(
 *                                             jsonProperty("inline_string", "const WASM_BINARY = '...'")
 *                                         ))
 *                                     ))
 *                                 ))
 *                             )))
 *                         .build())
 *                     .build())
 *                 .build())
 *             .tests(URLMapTestArgs.builder()
 *                 .service(default_.id())
 *                 .host("mysite.com")
 *                 .path("/")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Url Map Http Filter Metadata
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.URLMap;
 * import com.pulumi.gcp.compute.URLMapArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapHostRuleArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapPathMatcherArgs;
 * import com.pulumi.gcp.compute.inputs.URLMapTestArgs;
 * import static com.pulumi.codegen.internal.Serialization.*;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var defaultHealthCheck = new HealthCheck("defaultHealthCheck", HealthCheckArgs.builder()
 *             .name("health-check")
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build());
 * 
 *         var default_ = new BackendService("default", BackendServiceArgs.builder()
 *             .name("default-backend")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("INTERNAL_SELF_MANAGED")
 *             .healthChecks(defaultHealthCheck.id())
 *             .build());
 * 
 *         var service_a = new BackendService("service-a", BackendServiceArgs.builder()
 *             .name("service-a-backend")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("INTERNAL_SELF_MANAGED")
 *             .healthChecks(defaultHealthCheck.id())
 *             .build());
 * 
 *         var service_b = new BackendService("service-b", BackendServiceArgs.builder()
 *             .name("service-b-backend")
 *             .portName("http")
 *             .protocol("HTTP")
 *             .timeoutSec(10)
 *             .loadBalancingScheme("INTERNAL_SELF_MANAGED")
 *             .healthChecks(defaultHealthCheck.id())
 *             .build());
 * 
 *         var urlmap = new URLMap("urlmap", URLMapArgs.builder()
 *             .name("urlmap")
 *             .description("Test for httpFilterMetadata in route rules")
 *             .defaultService(default_.id())
 *             .hostRules(URLMapHostRuleArgs.builder()
 *                 .hosts("mysite.com")
 *                 .pathMatcher("allpaths")
 *                 .build())
 *             .pathMatchers(URLMapPathMatcherArgs.builder()
 *                 .name("allpaths")
 *                 .defaultService(default_.id())
 *                 .routeRules(                
 *                     URLMapPathMatcherRouteRuleArgs.builder()
 *                         .priority(1)
 *                         .service(service_a.id())
 *                         .matchRules(URLMapPathMatcherRouteRuleMatchRuleArgs.builder()
 *                             .prefixMatch("/")
 *                             .ignoreCase(true)
 *                             .build())
 *                         .httpFilterMetadatas(URLMapPathMatcherRouteRuleHttpFilterMetadataArgs.builder()
 *                             .filterName("envoy.wasm")
 *                             .configTypeUrl("type.googleapis.com/google.protobuf.Struct")
 *                             .config(serializeJson(
 *                                 jsonObject(
 *                                     jsonProperty("fields", jsonObject(
 *                                         jsonProperty("timeout", jsonObject(
 *                                             jsonProperty("string_value", "30s")
 *                                         )),
 *                                         jsonProperty("retries", jsonObject(
 *                                             jsonProperty("number_value", 3)
 *                                         )),
 *                                         jsonProperty("debug", jsonObject(
 *                                             jsonProperty("bool_value", true)
 *                                         ))
 *                                     ))
 *                                 )))
 *                             .build())
 *                         .build(),
 *                     URLMapPathMatcherRouteRuleArgs.builder()
 *                         .priority(2)
 *                         .service(service_b.id())
 *                         .matchRules(URLMapPathMatcherRouteRuleMatchRuleArgs.builder()
 *                             .prefixMatch("/api")
 *                             .ignoreCase(true)
 *                             .build())
 *                         .httpFilterMetadatas(URLMapPathMatcherRouteRuleHttpFilterMetadataArgs.builder()
 *                             .filterName("envoy.rate_limit")
 *                             .configTypeUrl("type.googleapis.com/google.protobuf.Struct")
 *                             .config(serializeJson(
 *                                 jsonObject(
 *                                     jsonProperty("fields", jsonObject(
 *                                         jsonProperty("requests_per_unit", jsonObject(
 *                                             jsonProperty("number_value", 100)
 *                                         )),
 *                                         jsonProperty("unit", jsonObject(
 *                                             jsonProperty("string_value", "MINUTE")
 *                                         ))
 *                                     ))
 *                                 )))
 *                             .build())
 *                         .build())
 *                 .build())
 *             .tests(URLMapTestArgs.builder()
 *                 .service(default_.id())
 *                 .host("mysite.com")
 *                 .path("/")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Import
 * 
 * UrlMap can be imported using any of these accepted formats:
 * 
 * * `projects/{{project}}/global/urlMaps/{{name}}`
 * 
 * * `{{project}}/{{name}}`
 * 
 * * `{{name}}`
 * 
 * When using the `pulumi import` command, UrlMap can be imported using one of the formats above. For example:
 * 
 * ```sh
 * $ pulumi import gcp:compute/uRLMap:URLMap default projects/{{project}}/global/urlMaps/{{name}}
 * ```
 * 
 * ```sh
 * $ pulumi import gcp:compute/uRLMap:URLMap default {{project}}/{{name}}
 * ```
 * 
 * ```sh
 * $ pulumi import gcp:compute/uRLMap:URLMap default {{name}}
 * ```
 * 
 */
@ResourceType(type="gcp:compute/uRLMap:URLMap")
public class URLMap extends com.pulumi.resources.CustomResource {
    /**
     * Creation timestamp in RFC3339 text format.
     * 
     */
    @Export(name="creationTimestamp", refs={String.class}, tree="[0]")
    private Output<String> creationTimestamp;

    /**
     * @return Creation timestamp in RFC3339 text format.
     * 
     */
    public Output<String> creationTimestamp() {
        return this.creationTimestamp;
    }
    /**
     * defaultCustomErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
     * This policy takes effect at the PathMatcher level and applies only when no policy has been defined for the error code at lower levels like RouteRule and PathRule within this PathMatcher. If an error code does not have a policy defined in defaultCustomErrorResponsePolicy, then a policy defined for the error code in UrlMap.defaultCustomErrorResponsePolicy takes effect.
     * For example, consider a UrlMap with the following configuration:
     * UrlMap.defaultCustomErrorResponsePolicy is configured with policies for 5xx and 4xx errors
     * A RouteRule for /coming_soon/ is configured for the error code 404.
     * If the request is for www.myotherdomain.com and a 404 is encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404 response is encountered for the request www.example.com/current_events/, the pathMatcher&#39;s policy takes effect. If however, the request for www.example.com/coming_soon/ encounters a 404, the policy in RouteRule.customErrorResponsePolicy takes effect. If any of the requests in this example encounter a 500 error code, the policy at UrlMap.defaultCustomErrorResponsePolicy takes effect.
     * When used in conjunction with pathMatcher.defaultRouteAction.retryPolicy, retries take precedence. Only once all retries are exhausted, the defaultCustomErrorResponsePolicy is applied. While attempting a retry, if load balancer is successful in reaching the service, the defaultCustomErrorResponsePolicy is ignored and the response from the service is returned to the client.
     * defaultCustomErrorResponsePolicy is supported only for global external Application Load Balancers.
     * Structure is documented below.
     * 
     */
    @Export(name="defaultCustomErrorResponsePolicy", refs={URLMapDefaultCustomErrorResponsePolicy.class}, tree="[0]")
    private Output</* @Nullable */ URLMapDefaultCustomErrorResponsePolicy> defaultCustomErrorResponsePolicy;

    /**
     * @return defaultCustomErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
     * This policy takes effect at the PathMatcher level and applies only when no policy has been defined for the error code at lower levels like RouteRule and PathRule within this PathMatcher. If an error code does not have a policy defined in defaultCustomErrorResponsePolicy, then a policy defined for the error code in UrlMap.defaultCustomErrorResponsePolicy takes effect.
     * For example, consider a UrlMap with the following configuration:
     * UrlMap.defaultCustomErrorResponsePolicy is configured with policies for 5xx and 4xx errors
     * A RouteRule for /coming_soon/ is configured for the error code 404.
     * If the request is for www.myotherdomain.com and a 404 is encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404 response is encountered for the request www.example.com/current_events/, the pathMatcher&#39;s policy takes effect. If however, the request for www.example.com/coming_soon/ encounters a 404, the policy in RouteRule.customErrorResponsePolicy takes effect. If any of the requests in this example encounter a 500 error code, the policy at UrlMap.defaultCustomErrorResponsePolicy takes effect.
     * When used in conjunction with pathMatcher.defaultRouteAction.retryPolicy, retries take precedence. Only once all retries are exhausted, the defaultCustomErrorResponsePolicy is applied. While attempting a retry, if load balancer is successful in reaching the service, the defaultCustomErrorResponsePolicy is ignored and the response from the service is returned to the client.
     * defaultCustomErrorResponsePolicy is supported only for global external Application Load Balancers.
     * Structure is documented below.
     * 
     */
    public Output<Optional<URLMapDefaultCustomErrorResponsePolicy>> defaultCustomErrorResponsePolicy() {
        return Codegen.optional(this.defaultCustomErrorResponsePolicy);
    }
    /**
     * defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
     * like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
     * If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
     * is set, defaultRouteAction cannot contain any weightedBackendServices.
     * Only one of defaultRouteAction or defaultUrlRedirect must be set.
     * Structure is documented below.
     * 
     */
    @Export(name="defaultRouteAction", refs={URLMapDefaultRouteAction.class}, tree="[0]")
    private Output</* @Nullable */ URLMapDefaultRouteAction> defaultRouteAction;

    /**
     * @return defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions
     * like URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.
     * If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService
     * is set, defaultRouteAction cannot contain any weightedBackendServices.
     * Only one of defaultRouteAction or defaultUrlRedirect must be set.
     * Structure is documented below.
     * 
     */
    public Output<Optional<URLMapDefaultRouteAction>> defaultRouteAction() {
        return Codegen.optional(this.defaultRouteAction);
    }
    /**
     * The backend service or backend bucket to use when none of the given rules match.
     * 
     */
    @Export(name="defaultService", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> defaultService;

    /**
     * @return The backend service or backend bucket to use when none of the given rules match.
     * 
     */
    public Output<Optional<String>> defaultService() {
        return Codegen.optional(this.defaultService);
    }
    /**
     * When none of the specified hostRules match, the request is redirected to a URL specified
     * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
     * defaultRouteAction must not be set.
     * Structure is documented below.
     * 
     */
    @Export(name="defaultUrlRedirect", refs={URLMapDefaultUrlRedirect.class}, tree="[0]")
    private Output</* @Nullable */ URLMapDefaultUrlRedirect> defaultUrlRedirect;

    /**
     * @return When none of the specified hostRules match, the request is redirected to a URL specified
     * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
     * defaultRouteAction must not be set.
     * Structure is documented below.
     * 
     */
    public Output<Optional<URLMapDefaultUrlRedirect>> defaultUrlRedirect() {
        return Codegen.optional(this.defaultUrlRedirect);
    }
    /**
     * An optional description of this resource. Provide this property when you create
     * the resource.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return An optional description of this resource. Provide this property when you create
     * the resource.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Fingerprint of this resource. A hash of the contents stored in this object. This
     * field is used in optimistic locking.
     * 
     */
    @Export(name="fingerprint", refs={String.class}, tree="[0]")
    private Output<String> fingerprint;

    /**
     * @return Fingerprint of this resource. A hash of the contents stored in this object. This
     * field is used in optimistic locking.
     * 
     */
    public Output<String> fingerprint() {
        return this.fingerprint;
    }
    /**
     * Specifies changes to request and response headers that need to take effect for
     * the selected backendService. The headerAction specified here take effect after
     * headerAction specified under pathMatcher.
     * Structure is documented below.
     * 
     */
    @Export(name="headerAction", refs={URLMapHeaderAction.class}, tree="[0]")
    private Output</* @Nullable */ URLMapHeaderAction> headerAction;

    /**
     * @return Specifies changes to request and response headers that need to take effect for
     * the selected backendService. The headerAction specified here take effect after
     * headerAction specified under pathMatcher.
     * Structure is documented below.
     * 
     */
    public Output<Optional<URLMapHeaderAction>> headerAction() {
        return Codegen.optional(this.headerAction);
    }
    /**
     * The list of HostRules to use against the URL.
     * Structure is documented below.
     * 
     */
    @Export(name="hostRules", refs={List.class,URLMapHostRule.class}, tree="[0,1]")
    private Output</* @Nullable */ List<URLMapHostRule>> hostRules;

    /**
     * @return The list of HostRules to use against the URL.
     * Structure is documented below.
     * 
     */
    public Output<Optional<List<URLMapHostRule>>> hostRules() {
        return Codegen.optional(this.hostRules);
    }
    /**
     * The unique identifier for the resource.
     * 
     */
    @Export(name="mapId", refs={Integer.class}, tree="[0]")
    private Output<Integer> mapId;

    /**
     * @return The unique identifier for the resource.
     * 
     */
    public Output<Integer> mapId() {
        return this.mapId;
    }
    /**
     * Name of the resource. Provided by the client when the resource is created. The
     * name must be 1-63 characters long, and comply with RFC1035. Specifically, the
     * name must be 1-63 characters long and match the regular expression
     * `a-z?` which means the first character must be a lowercase
     * letter, and all following characters must be a dash, lowercase letter, or digit,
     * except the last character, which cannot be a dash.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return Name of the resource. Provided by the client when the resource is created. The
     * name must be 1-63 characters long, and comply with RFC1035. Specifically, the
     * name must be 1-63 characters long and match the regular expression
     * `a-z?` which means the first character must be a lowercase
     * letter, and all following characters must be a dash, lowercase letter, or digit,
     * except the last character, which cannot be a dash.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The list of named PathMatchers to use against the URL.
     * Structure is documented below.
     * 
     */
    @Export(name="pathMatchers", refs={List.class,URLMapPathMatcher.class}, tree="[0,1]")
    private Output</* @Nullable */ List<URLMapPathMatcher>> pathMatchers;

    /**
     * @return The list of named PathMatchers to use against the URL.
     * Structure is documented below.
     * 
     */
    public Output<Optional<List<URLMapPathMatcher>>> pathMatchers() {
        return Codegen.optional(this.pathMatchers);
    }
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Export(name="project", refs={String.class}, tree="[0]")
    private Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Output<String> project() {
        return this.project;
    }
    /**
     * The URI of the created resource.
     * 
     */
    @Export(name="selfLink", refs={String.class}, tree="[0]")
    private Output<String> selfLink;

    /**
     * @return The URI of the created resource.
     * 
     */
    public Output<String> selfLink() {
        return this.selfLink;
    }
    /**
     * The list of expected URL mapping tests. Request to update this UrlMap will
     * succeed only if all of the test cases pass. You can specify a maximum of 100
     * tests per UrlMap.
     * Structure is documented below.
     * 
     */
    @Export(name="tests", refs={List.class,URLMapTest.class}, tree="[0,1]")
    private Output</* @Nullable */ List<URLMapTest>> tests;

    /**
     * @return The list of expected URL mapping tests. Request to update this UrlMap will
     * succeed only if all of the test cases pass. You can specify a maximum of 100
     * tests per UrlMap.
     * Structure is documented below.
     * 
     */
    public Output<Optional<List<URLMapTest>>> tests() {
        return Codegen.optional(this.tests);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public URLMap(java.lang.String name) {
        this(name, URLMapArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public URLMap(java.lang.String name, @Nullable URLMapArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public URLMap(java.lang.String name, @Nullable URLMapArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:compute/uRLMap:URLMap", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private URLMap(java.lang.String name, Output<java.lang.String> id, @Nullable URLMapState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:compute/uRLMap:URLMap", name, state, makeResourceOptions(options, id), false);
    }

    private static URLMapArgs makeArgs(@Nullable URLMapArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? URLMapArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static URLMap get(java.lang.String name, Output<java.lang.String> id, @Nullable URLMapState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new URLMap(name, id, state, options);
    }
}
