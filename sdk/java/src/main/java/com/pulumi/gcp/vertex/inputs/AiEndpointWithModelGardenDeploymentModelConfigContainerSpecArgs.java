// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.vertex.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.vertex.inputs.AiEndpointWithModelGardenDeploymentModelConfigContainerSpecEnvArgs;
import com.pulumi.gcp.vertex.inputs.AiEndpointWithModelGardenDeploymentModelConfigContainerSpecGrpcPortArgs;
import com.pulumi.gcp.vertex.inputs.AiEndpointWithModelGardenDeploymentModelConfigContainerSpecHealthProbeArgs;
import com.pulumi.gcp.vertex.inputs.AiEndpointWithModelGardenDeploymentModelConfigContainerSpecLivenessProbeArgs;
import com.pulumi.gcp.vertex.inputs.AiEndpointWithModelGardenDeploymentModelConfigContainerSpecPortArgs;
import com.pulumi.gcp.vertex.inputs.AiEndpointWithModelGardenDeploymentModelConfigContainerSpecStartupProbeArgs;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class AiEndpointWithModelGardenDeploymentModelConfigContainerSpecArgs extends com.pulumi.resources.ResourceArgs {

    public static final AiEndpointWithModelGardenDeploymentModelConfigContainerSpecArgs Empty = new AiEndpointWithModelGardenDeploymentModelConfigContainerSpecArgs();

    /**
     * Specifies arguments for the command that runs when the container starts.
     * This overrides the container&#39;s
     * [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd). Specify
     * this field as an array of executable and arguments, similar to a Docker
     * `CMD`&#39;s &#34;default parameters&#34; form.
     * If you don&#39;t specify this field but do specify the
     * command field, then the command from the
     * `command` field runs without any additional arguments. See the
     * [Kubernetes documentation about how the
     * `command` and `args` fields interact with a container&#39;s `ENTRYPOINT` and
     * `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
     * If you don&#39;t specify this field and don&#39;t specify the `command` field,
     * then the container&#39;s
     * [`ENTRYPOINT`](https://docs.docker.com/engine/reference/builder/#cmd) and
     * `CMD` determine what runs based on their default behavior. See the Docker
     * documentation about [how `CMD` and `ENTRYPOINT`
     * interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
     * In this field, you can reference [environment variables
     * set by Vertex
     * AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
     * and environment variables set in the env field.
     * You cannot reference environment variables set in the Docker image. In
     * order for environment variables to be expanded, reference them by using the
     * following syntax:$(VARIABLE_NAME)
     * Note that this differs from Bash variable expansion, which does not use
     * parentheses. If a variable cannot be resolved, the reference in the input
     * string is used unchanged. To avoid variable expansion, you can escape this
     * syntax with `$$`; for example:$$(VARIABLE_NAME)
     * This field corresponds to the `args` field of the Kubernetes Containers
     * [v1 core
     * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
     * 
     */
    @Import(name="args")
    private @Nullable Output<List<String>> args;

    /**
     * @return Specifies arguments for the command that runs when the container starts.
     * This overrides the container&#39;s
     * [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd). Specify
     * this field as an array of executable and arguments, similar to a Docker
     * `CMD`&#39;s &#34;default parameters&#34; form.
     * If you don&#39;t specify this field but do specify the
     * command field, then the command from the
     * `command` field runs without any additional arguments. See the
     * [Kubernetes documentation about how the
     * `command` and `args` fields interact with a container&#39;s `ENTRYPOINT` and
     * `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
     * If you don&#39;t specify this field and don&#39;t specify the `command` field,
     * then the container&#39;s
     * [`ENTRYPOINT`](https://docs.docker.com/engine/reference/builder/#cmd) and
     * `CMD` determine what runs based on their default behavior. See the Docker
     * documentation about [how `CMD` and `ENTRYPOINT`
     * interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
     * In this field, you can reference [environment variables
     * set by Vertex
     * AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
     * and environment variables set in the env field.
     * You cannot reference environment variables set in the Docker image. In
     * order for environment variables to be expanded, reference them by using the
     * following syntax:$(VARIABLE_NAME)
     * Note that this differs from Bash variable expansion, which does not use
     * parentheses. If a variable cannot be resolved, the reference in the input
     * string is used unchanged. To avoid variable expansion, you can escape this
     * syntax with `$$`; for example:$$(VARIABLE_NAME)
     * This field corresponds to the `args` field of the Kubernetes Containers
     * [v1 core
     * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
     * 
     */
    public Optional<Output<List<String>>> args() {
        return Optional.ofNullable(this.args);
    }

    /**
     * Specifies the command that runs when the container starts. This overrides
     * the container&#39;s
     * [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint).
     * Specify this field as an array of executable and arguments, similar to a
     * Docker `ENTRYPOINT`&#39;s &#34;exec&#34; form, not its &#34;shell&#34; form.
     * If you do not specify this field, then the container&#39;s `ENTRYPOINT` runs,
     * in conjunction with the args field or the
     * container&#39;s [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd),
     * if either exists. If this field is not specified and the container does not
     * have an `ENTRYPOINT`, then refer to the Docker documentation about [how
     * `CMD` and `ENTRYPOINT`
     * interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
     * If you specify this field, then you can also specify the `args` field to
     * provide additional arguments for this command. However, if you specify this
     * field, then the container&#39;s `CMD` is ignored. See the
     * [Kubernetes documentation about how the
     * `command` and `args` fields interact with a container&#39;s `ENTRYPOINT` and
     * `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
     * In this field, you can reference [environment variables set by Vertex
     * AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
     * and environment variables set in the env field.
     * You cannot reference environment variables set in the Docker image. In
     * order for environment variables to be expanded, reference them by using the
     * following syntax:$(VARIABLE_NAME)
     * Note that this differs from Bash variable expansion, which does not use
     * parentheses. If a variable cannot be resolved, the reference in the input
     * string is used unchanged. To avoid variable expansion, you can escape this
     * syntax with `$$`; for example:$$(VARIABLE_NAME)
     * This field corresponds to the `command` field of the Kubernetes Containers
     * [v1 core
     * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
     * 
     */
    @Import(name="commands")
    private @Nullable Output<List<String>> commands;

    /**
     * @return Specifies the command that runs when the container starts. This overrides
     * the container&#39;s
     * [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint).
     * Specify this field as an array of executable and arguments, similar to a
     * Docker `ENTRYPOINT`&#39;s &#34;exec&#34; form, not its &#34;shell&#34; form.
     * If you do not specify this field, then the container&#39;s `ENTRYPOINT` runs,
     * in conjunction with the args field or the
     * container&#39;s [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd),
     * if either exists. If this field is not specified and the container does not
     * have an `ENTRYPOINT`, then refer to the Docker documentation about [how
     * `CMD` and `ENTRYPOINT`
     * interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
     * If you specify this field, then you can also specify the `args` field to
     * provide additional arguments for this command. However, if you specify this
     * field, then the container&#39;s `CMD` is ignored. See the
     * [Kubernetes documentation about how the
     * `command` and `args` fields interact with a container&#39;s `ENTRYPOINT` and
     * `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
     * In this field, you can reference [environment variables set by Vertex
     * AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
     * and environment variables set in the env field.
     * You cannot reference environment variables set in the Docker image. In
     * order for environment variables to be expanded, reference them by using the
     * following syntax:$(VARIABLE_NAME)
     * Note that this differs from Bash variable expansion, which does not use
     * parentheses. If a variable cannot be resolved, the reference in the input
     * string is used unchanged. To avoid variable expansion, you can escape this
     * syntax with `$$`; for example:$$(VARIABLE_NAME)
     * This field corresponds to the `command` field of the Kubernetes Containers
     * [v1 core
     * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
     * 
     */
    public Optional<Output<List<String>>> commands() {
        return Optional.ofNullable(this.commands);
    }

    /**
     * Deployment timeout.
     * Limit for deployment timeout is 2 hours.
     * 
     */
    @Import(name="deploymentTimeout")
    private @Nullable Output<String> deploymentTimeout;

    /**
     * @return Deployment timeout.
     * Limit for deployment timeout is 2 hours.
     * 
     */
    public Optional<Output<String>> deploymentTimeout() {
        return Optional.ofNullable(this.deploymentTimeout);
    }

    /**
     * List of environment variables to set in the container. After the container
     * starts running, code running in the container can read these environment
     * variables.
     * Additionally, the command and
     * args fields can reference these variables. Later
     * entries in this list can also reference earlier entries. For example, the
     * following example sets the variable `VAR_2` to have the value `foo bar`:
     * 
     * If you switch the order of the variables in the example, then the expansion
     * does not occur.
     * This field corresponds to the `env` field of the Kubernetes Containers
     * [v1 core
     * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
     * Structure is documented below.
     * 
     */
    @Import(name="envs")
    private @Nullable Output<List<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecEnvArgs>> envs;

    /**
     * @return List of environment variables to set in the container. After the container
     * starts running, code running in the container can read these environment
     * variables.
     * Additionally, the command and
     * args fields can reference these variables. Later
     * entries in this list can also reference earlier entries. For example, the
     * following example sets the variable `VAR_2` to have the value `foo bar`:
     * 
     * If you switch the order of the variables in the example, then the expansion
     * does not occur.
     * This field corresponds to the `env` field of the Kubernetes Containers
     * [v1 core
     * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecEnvArgs>>> envs() {
        return Optional.ofNullable(this.envs);
    }

    /**
     * List of ports to expose from the container. Vertex AI sends gRPC
     * prediction requests that it receives to the first port on this list. Vertex
     * AI also sends liveness and health checks to this port.
     * If you do not specify this field, gRPC requests to the container will be
     * disabled.
     * Vertex AI does not use ports other than the first one listed. This field
     * corresponds to the `ports` field of the Kubernetes Containers v1 core API.
     * Structure is documented below.
     * 
     */
    @Import(name="grpcPorts")
    private @Nullable Output<List<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecGrpcPortArgs>> grpcPorts;

    /**
     * @return List of ports to expose from the container. Vertex AI sends gRPC
     * prediction requests that it receives to the first port on this list. Vertex
     * AI also sends liveness and health checks to this port.
     * If you do not specify this field, gRPC requests to the container will be
     * disabled.
     * Vertex AI does not use ports other than the first one listed. This field
     * corresponds to the `ports` field of the Kubernetes Containers v1 core API.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecGrpcPortArgs>>> grpcPorts() {
        return Optional.ofNullable(this.grpcPorts);
    }

    /**
     * Probe describes a health check to be performed against a container to
     * determine whether it is alive or ready to receive traffic.
     * Structure is documented below.
     * 
     */
    @Import(name="healthProbe")
    private @Nullable Output<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecHealthProbeArgs> healthProbe;

    /**
     * @return Probe describes a health check to be performed against a container to
     * determine whether it is alive or ready to receive traffic.
     * Structure is documented below.
     * 
     */
    public Optional<Output<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecHealthProbeArgs>> healthProbe() {
        return Optional.ofNullable(this.healthProbe);
    }

    /**
     * HTTP path on the container to send health checks to. Vertex AI
     * intermittently sends GET requests to this path on the container&#39;s IP
     * address and port to check that the container is healthy. Read more about
     * [health
     * checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#health).
     * For example, if you set this field to `/bar`, then Vertex AI
     * intermittently sends a GET request to the `/bar` path on the port of your
     * container specified by the first value of this `ModelContainerSpec`&#39;s
     * ports field.
     * If you don&#39;t specify this field, it defaults to the following value when
     * you deploy this Model to an Endpoint:/v1/endpoints/ENDPOINT/deployedModels/DEPLOYED_MODEL:predict
     * The placeholders in this value are replaced as follows:
     * * ENDPOINT: The last segment (following `endpoints/`)of the
     *   Endpoint.name][] field of the Endpoint where this Model has been
     *   deployed. (Vertex AI makes this value available to your container code
     *   as the [`AIP_ENDPOINT_ID` environment
     *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
     * * DEPLOYED_MODEL: DeployedModel.id of the `DeployedModel`.
     *   (Vertex AI makes this value available to your container code as the
     *   [`AIP_DEPLOYED_MODEL_ID` environment
     *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
     * 
     */
    @Import(name="healthRoute")
    private @Nullable Output<String> healthRoute;

    /**
     * @return HTTP path on the container to send health checks to. Vertex AI
     * intermittently sends GET requests to this path on the container&#39;s IP
     * address and port to check that the container is healthy. Read more about
     * [health
     * checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#health).
     * For example, if you set this field to `/bar`, then Vertex AI
     * intermittently sends a GET request to the `/bar` path on the port of your
     * container specified by the first value of this `ModelContainerSpec`&#39;s
     * ports field.
     * If you don&#39;t specify this field, it defaults to the following value when
     * you deploy this Model to an Endpoint:/v1/endpoints/ENDPOINT/deployedModels/DEPLOYED_MODEL:predict
     * The placeholders in this value are replaced as follows:
     * * ENDPOINT: The last segment (following `endpoints/`)of the
     *   Endpoint.name][] field of the Endpoint where this Model has been
     *   deployed. (Vertex AI makes this value available to your container code
     *   as the [`AIP_ENDPOINT_ID` environment
     *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
     * * DEPLOYED_MODEL: DeployedModel.id of the `DeployedModel`.
     *   (Vertex AI makes this value available to your container code as the
     *   [`AIP_DEPLOYED_MODEL_ID` environment
     *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
     * 
     */
    public Optional<Output<String>> healthRoute() {
        return Optional.ofNullable(this.healthRoute);
    }

    /**
     * URI of the Docker image to be used as the custom container for serving
     * predictions. This URI must identify an image in Artifact Registry or
     * Container Registry. Learn more about the [container publishing
     * requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#publishing),
     * including permissions requirements for the Vertex AI Service Agent.
     * The container image is ingested upon ModelService.UploadModel, stored
     * internally, and this original path is afterwards not used.
     * To learn about the requirements for the Docker image itself, see
     * [Custom container
     * requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#).
     * You can use the URI to one of Vertex AI&#39;s [pre-built container images for
     * prediction](https://cloud.google.com/vertex-ai/docs/predictions/pre-built-containers)
     * in this field.
     * 
     */
    @Import(name="imageUri", required=true)
    private Output<String> imageUri;

    /**
     * @return URI of the Docker image to be used as the custom container for serving
     * predictions. This URI must identify an image in Artifact Registry or
     * Container Registry. Learn more about the [container publishing
     * requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#publishing),
     * including permissions requirements for the Vertex AI Service Agent.
     * The container image is ingested upon ModelService.UploadModel, stored
     * internally, and this original path is afterwards not used.
     * To learn about the requirements for the Docker image itself, see
     * [Custom container
     * requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#).
     * You can use the URI to one of Vertex AI&#39;s [pre-built container images for
     * prediction](https://cloud.google.com/vertex-ai/docs/predictions/pre-built-containers)
     * in this field.
     * 
     */
    public Output<String> imageUri() {
        return this.imageUri;
    }

    /**
     * Probe describes a health check to be performed against a container to
     * determine whether it is alive or ready to receive traffic.
     * Structure is documented below.
     * 
     */
    @Import(name="livenessProbe")
    private @Nullable Output<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecLivenessProbeArgs> livenessProbe;

    /**
     * @return Probe describes a health check to be performed against a container to
     * determine whether it is alive or ready to receive traffic.
     * Structure is documented below.
     * 
     */
    public Optional<Output<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecLivenessProbeArgs>> livenessProbe() {
        return Optional.ofNullable(this.livenessProbe);
    }

    /**
     * List of ports to expose from the container. Vertex AI sends any
     * prediction requests that it receives to the first port on this list. Vertex
     * AI also sends
     * [liveness and health
     * checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#liveness)
     * to this port.
     * If you do not specify this field, it defaults to following value:
     * 
     * Vertex AI does not use ports other than the first one listed. This field
     * corresponds to the `ports` field of the Kubernetes Containers
     * [v1 core
     * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
     * Structure is documented below.
     * 
     */
    @Import(name="ports")
    private @Nullable Output<List<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecPortArgs>> ports;

    /**
     * @return List of ports to expose from the container. Vertex AI sends any
     * prediction requests that it receives to the first port on this list. Vertex
     * AI also sends
     * [liveness and health
     * checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#liveness)
     * to this port.
     * If you do not specify this field, it defaults to following value:
     * 
     * Vertex AI does not use ports other than the first one listed. This field
     * corresponds to the `ports` field of the Kubernetes Containers
     * [v1 core
     * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecPortArgs>>> ports() {
        return Optional.ofNullable(this.ports);
    }

    /**
     * HTTP path on the container to send prediction requests to. Vertex AI
     * forwards requests sent using
     * projects.locations.endpoints.predict to this
     * path on the container&#39;s IP address and port. Vertex AI then returns the
     * container&#39;s response in the API response.
     * For example, if you set this field to `/foo`, then when Vertex AI
     * receives a prediction request, it forwards the request body in a POST
     * request to the `/foo` path on the port of your container specified by the
     * first value of this `ModelContainerSpec`&#39;s
     * ports field.
     * If you don&#39;t specify this field, it defaults to the following value when
     * you deploy this Model to an Endpoint:/v1/endpoints/ENDPOINT/deployedModels/DEPLOYED_MODEL:predict
     * The placeholders in this value are replaced as follows:
     * * ENDPOINT: The last segment (following `endpoints/`)of the
     *   Endpoint.name][] field of the Endpoint where this Model has been
     *   deployed. (Vertex AI makes this value available to your container code
     *   as the [`AIP_ENDPOINT_ID` environment
     *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
     * * DEPLOYED_MODEL: DeployedModel.id of the `DeployedModel`.
     *   (Vertex AI makes this value available to your container code
     *   as the [`AIP_DEPLOYED_MODEL_ID` environment
     *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
     * 
     */
    @Import(name="predictRoute")
    private @Nullable Output<String> predictRoute;

    /**
     * @return HTTP path on the container to send prediction requests to. Vertex AI
     * forwards requests sent using
     * projects.locations.endpoints.predict to this
     * path on the container&#39;s IP address and port. Vertex AI then returns the
     * container&#39;s response in the API response.
     * For example, if you set this field to `/foo`, then when Vertex AI
     * receives a prediction request, it forwards the request body in a POST
     * request to the `/foo` path on the port of your container specified by the
     * first value of this `ModelContainerSpec`&#39;s
     * ports field.
     * If you don&#39;t specify this field, it defaults to the following value when
     * you deploy this Model to an Endpoint:/v1/endpoints/ENDPOINT/deployedModels/DEPLOYED_MODEL:predict
     * The placeholders in this value are replaced as follows:
     * * ENDPOINT: The last segment (following `endpoints/`)of the
     *   Endpoint.name][] field of the Endpoint where this Model has been
     *   deployed. (Vertex AI makes this value available to your container code
     *   as the [`AIP_ENDPOINT_ID` environment
     *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
     * * DEPLOYED_MODEL: DeployedModel.id of the `DeployedModel`.
     *   (Vertex AI makes this value available to your container code
     *   as the [`AIP_DEPLOYED_MODEL_ID` environment
     *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
     * 
     */
    public Optional<Output<String>> predictRoute() {
        return Optional.ofNullable(this.predictRoute);
    }

    /**
     * The amount of the VM memory to reserve as the shared memory for the model
     * in megabytes.
     * 
     */
    @Import(name="sharedMemorySizeMb")
    private @Nullable Output<String> sharedMemorySizeMb;

    /**
     * @return The amount of the VM memory to reserve as the shared memory for the model
     * in megabytes.
     * 
     */
    public Optional<Output<String>> sharedMemorySizeMb() {
        return Optional.ofNullable(this.sharedMemorySizeMb);
    }

    /**
     * Probe describes a health check to be performed against a container to
     * determine whether it is alive or ready to receive traffic.
     * Structure is documented below.
     * 
     */
    @Import(name="startupProbe")
    private @Nullable Output<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecStartupProbeArgs> startupProbe;

    /**
     * @return Probe describes a health check to be performed against a container to
     * determine whether it is alive or ready to receive traffic.
     * Structure is documented below.
     * 
     */
    public Optional<Output<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecStartupProbeArgs>> startupProbe() {
        return Optional.ofNullable(this.startupProbe);
    }

    private AiEndpointWithModelGardenDeploymentModelConfigContainerSpecArgs() {}

    private AiEndpointWithModelGardenDeploymentModelConfigContainerSpecArgs(AiEndpointWithModelGardenDeploymentModelConfigContainerSpecArgs $) {
        this.args = $.args;
        this.commands = $.commands;
        this.deploymentTimeout = $.deploymentTimeout;
        this.envs = $.envs;
        this.grpcPorts = $.grpcPorts;
        this.healthProbe = $.healthProbe;
        this.healthRoute = $.healthRoute;
        this.imageUri = $.imageUri;
        this.livenessProbe = $.livenessProbe;
        this.ports = $.ports;
        this.predictRoute = $.predictRoute;
        this.sharedMemorySizeMb = $.sharedMemorySizeMb;
        this.startupProbe = $.startupProbe;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(AiEndpointWithModelGardenDeploymentModelConfigContainerSpecArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private AiEndpointWithModelGardenDeploymentModelConfigContainerSpecArgs $;

        public Builder() {
            $ = new AiEndpointWithModelGardenDeploymentModelConfigContainerSpecArgs();
        }

        public Builder(AiEndpointWithModelGardenDeploymentModelConfigContainerSpecArgs defaults) {
            $ = new AiEndpointWithModelGardenDeploymentModelConfigContainerSpecArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param args Specifies arguments for the command that runs when the container starts.
         * This overrides the container&#39;s
         * [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd). Specify
         * this field as an array of executable and arguments, similar to a Docker
         * `CMD`&#39;s &#34;default parameters&#34; form.
         * If you don&#39;t specify this field but do specify the
         * command field, then the command from the
         * `command` field runs without any additional arguments. See the
         * [Kubernetes documentation about how the
         * `command` and `args` fields interact with a container&#39;s `ENTRYPOINT` and
         * `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
         * If you don&#39;t specify this field and don&#39;t specify the `command` field,
         * then the container&#39;s
         * [`ENTRYPOINT`](https://docs.docker.com/engine/reference/builder/#cmd) and
         * `CMD` determine what runs based on their default behavior. See the Docker
         * documentation about [how `CMD` and `ENTRYPOINT`
         * interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
         * In this field, you can reference [environment variables
         * set by Vertex
         * AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
         * and environment variables set in the env field.
         * You cannot reference environment variables set in the Docker image. In
         * order for environment variables to be expanded, reference them by using the
         * following syntax:$(VARIABLE_NAME)
         * Note that this differs from Bash variable expansion, which does not use
         * parentheses. If a variable cannot be resolved, the reference in the input
         * string is used unchanged. To avoid variable expansion, you can escape this
         * syntax with `$$`; for example:$$(VARIABLE_NAME)
         * This field corresponds to the `args` field of the Kubernetes Containers
         * [v1 core
         * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
         * 
         * @return builder
         * 
         */
        public Builder args(@Nullable Output<List<String>> args) {
            $.args = args;
            return this;
        }

        /**
         * @param args Specifies arguments for the command that runs when the container starts.
         * This overrides the container&#39;s
         * [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd). Specify
         * this field as an array of executable and arguments, similar to a Docker
         * `CMD`&#39;s &#34;default parameters&#34; form.
         * If you don&#39;t specify this field but do specify the
         * command field, then the command from the
         * `command` field runs without any additional arguments. See the
         * [Kubernetes documentation about how the
         * `command` and `args` fields interact with a container&#39;s `ENTRYPOINT` and
         * `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
         * If you don&#39;t specify this field and don&#39;t specify the `command` field,
         * then the container&#39;s
         * [`ENTRYPOINT`](https://docs.docker.com/engine/reference/builder/#cmd) and
         * `CMD` determine what runs based on their default behavior. See the Docker
         * documentation about [how `CMD` and `ENTRYPOINT`
         * interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
         * In this field, you can reference [environment variables
         * set by Vertex
         * AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
         * and environment variables set in the env field.
         * You cannot reference environment variables set in the Docker image. In
         * order for environment variables to be expanded, reference them by using the
         * following syntax:$(VARIABLE_NAME)
         * Note that this differs from Bash variable expansion, which does not use
         * parentheses. If a variable cannot be resolved, the reference in the input
         * string is used unchanged. To avoid variable expansion, you can escape this
         * syntax with `$$`; for example:$$(VARIABLE_NAME)
         * This field corresponds to the `args` field of the Kubernetes Containers
         * [v1 core
         * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
         * 
         * @return builder
         * 
         */
        public Builder args(List<String> args) {
            return args(Output.of(args));
        }

        /**
         * @param args Specifies arguments for the command that runs when the container starts.
         * This overrides the container&#39;s
         * [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd). Specify
         * this field as an array of executable and arguments, similar to a Docker
         * `CMD`&#39;s &#34;default parameters&#34; form.
         * If you don&#39;t specify this field but do specify the
         * command field, then the command from the
         * `command` field runs without any additional arguments. See the
         * [Kubernetes documentation about how the
         * `command` and `args` fields interact with a container&#39;s `ENTRYPOINT` and
         * `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
         * If you don&#39;t specify this field and don&#39;t specify the `command` field,
         * then the container&#39;s
         * [`ENTRYPOINT`](https://docs.docker.com/engine/reference/builder/#cmd) and
         * `CMD` determine what runs based on their default behavior. See the Docker
         * documentation about [how `CMD` and `ENTRYPOINT`
         * interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
         * In this field, you can reference [environment variables
         * set by Vertex
         * AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
         * and environment variables set in the env field.
         * You cannot reference environment variables set in the Docker image. In
         * order for environment variables to be expanded, reference them by using the
         * following syntax:$(VARIABLE_NAME)
         * Note that this differs from Bash variable expansion, which does not use
         * parentheses. If a variable cannot be resolved, the reference in the input
         * string is used unchanged. To avoid variable expansion, you can escape this
         * syntax with `$$`; for example:$$(VARIABLE_NAME)
         * This field corresponds to the `args` field of the Kubernetes Containers
         * [v1 core
         * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
         * 
         * @return builder
         * 
         */
        public Builder args(String... args) {
            return args(List.of(args));
        }

        /**
         * @param commands Specifies the command that runs when the container starts. This overrides
         * the container&#39;s
         * [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint).
         * Specify this field as an array of executable and arguments, similar to a
         * Docker `ENTRYPOINT`&#39;s &#34;exec&#34; form, not its &#34;shell&#34; form.
         * If you do not specify this field, then the container&#39;s `ENTRYPOINT` runs,
         * in conjunction with the args field or the
         * container&#39;s [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd),
         * if either exists. If this field is not specified and the container does not
         * have an `ENTRYPOINT`, then refer to the Docker documentation about [how
         * `CMD` and `ENTRYPOINT`
         * interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
         * If you specify this field, then you can also specify the `args` field to
         * provide additional arguments for this command. However, if you specify this
         * field, then the container&#39;s `CMD` is ignored. See the
         * [Kubernetes documentation about how the
         * `command` and `args` fields interact with a container&#39;s `ENTRYPOINT` and
         * `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
         * In this field, you can reference [environment variables set by Vertex
         * AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
         * and environment variables set in the env field.
         * You cannot reference environment variables set in the Docker image. In
         * order for environment variables to be expanded, reference them by using the
         * following syntax:$(VARIABLE_NAME)
         * Note that this differs from Bash variable expansion, which does not use
         * parentheses. If a variable cannot be resolved, the reference in the input
         * string is used unchanged. To avoid variable expansion, you can escape this
         * syntax with `$$`; for example:$$(VARIABLE_NAME)
         * This field corresponds to the `command` field of the Kubernetes Containers
         * [v1 core
         * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
         * 
         * @return builder
         * 
         */
        public Builder commands(@Nullable Output<List<String>> commands) {
            $.commands = commands;
            return this;
        }

        /**
         * @param commands Specifies the command that runs when the container starts. This overrides
         * the container&#39;s
         * [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint).
         * Specify this field as an array of executable and arguments, similar to a
         * Docker `ENTRYPOINT`&#39;s &#34;exec&#34; form, not its &#34;shell&#34; form.
         * If you do not specify this field, then the container&#39;s `ENTRYPOINT` runs,
         * in conjunction with the args field or the
         * container&#39;s [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd),
         * if either exists. If this field is not specified and the container does not
         * have an `ENTRYPOINT`, then refer to the Docker documentation about [how
         * `CMD` and `ENTRYPOINT`
         * interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
         * If you specify this field, then you can also specify the `args` field to
         * provide additional arguments for this command. However, if you specify this
         * field, then the container&#39;s `CMD` is ignored. See the
         * [Kubernetes documentation about how the
         * `command` and `args` fields interact with a container&#39;s `ENTRYPOINT` and
         * `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
         * In this field, you can reference [environment variables set by Vertex
         * AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
         * and environment variables set in the env field.
         * You cannot reference environment variables set in the Docker image. In
         * order for environment variables to be expanded, reference them by using the
         * following syntax:$(VARIABLE_NAME)
         * Note that this differs from Bash variable expansion, which does not use
         * parentheses. If a variable cannot be resolved, the reference in the input
         * string is used unchanged. To avoid variable expansion, you can escape this
         * syntax with `$$`; for example:$$(VARIABLE_NAME)
         * This field corresponds to the `command` field of the Kubernetes Containers
         * [v1 core
         * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
         * 
         * @return builder
         * 
         */
        public Builder commands(List<String> commands) {
            return commands(Output.of(commands));
        }

        /**
         * @param commands Specifies the command that runs when the container starts. This overrides
         * the container&#39;s
         * [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint).
         * Specify this field as an array of executable and arguments, similar to a
         * Docker `ENTRYPOINT`&#39;s &#34;exec&#34; form, not its &#34;shell&#34; form.
         * If you do not specify this field, then the container&#39;s `ENTRYPOINT` runs,
         * in conjunction with the args field or the
         * container&#39;s [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd),
         * if either exists. If this field is not specified and the container does not
         * have an `ENTRYPOINT`, then refer to the Docker documentation about [how
         * `CMD` and `ENTRYPOINT`
         * interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
         * If you specify this field, then you can also specify the `args` field to
         * provide additional arguments for this command. However, if you specify this
         * field, then the container&#39;s `CMD` is ignored. See the
         * [Kubernetes documentation about how the
         * `command` and `args` fields interact with a container&#39;s `ENTRYPOINT` and
         * `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
         * In this field, you can reference [environment variables set by Vertex
         * AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
         * and environment variables set in the env field.
         * You cannot reference environment variables set in the Docker image. In
         * order for environment variables to be expanded, reference them by using the
         * following syntax:$(VARIABLE_NAME)
         * Note that this differs from Bash variable expansion, which does not use
         * parentheses. If a variable cannot be resolved, the reference in the input
         * string is used unchanged. To avoid variable expansion, you can escape this
         * syntax with `$$`; for example:$$(VARIABLE_NAME)
         * This field corresponds to the `command` field of the Kubernetes Containers
         * [v1 core
         * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
         * 
         * @return builder
         * 
         */
        public Builder commands(String... commands) {
            return commands(List.of(commands));
        }

        /**
         * @param deploymentTimeout Deployment timeout.
         * Limit for deployment timeout is 2 hours.
         * 
         * @return builder
         * 
         */
        public Builder deploymentTimeout(@Nullable Output<String> deploymentTimeout) {
            $.deploymentTimeout = deploymentTimeout;
            return this;
        }

        /**
         * @param deploymentTimeout Deployment timeout.
         * Limit for deployment timeout is 2 hours.
         * 
         * @return builder
         * 
         */
        public Builder deploymentTimeout(String deploymentTimeout) {
            return deploymentTimeout(Output.of(deploymentTimeout));
        }

        /**
         * @param envs List of environment variables to set in the container. After the container
         * starts running, code running in the container can read these environment
         * variables.
         * Additionally, the command and
         * args fields can reference these variables. Later
         * entries in this list can also reference earlier entries. For example, the
         * following example sets the variable `VAR_2` to have the value `foo bar`:
         * 
         * If you switch the order of the variables in the example, then the expansion
         * does not occur.
         * This field corresponds to the `env` field of the Kubernetes Containers
         * [v1 core
         * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder envs(@Nullable Output<List<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecEnvArgs>> envs) {
            $.envs = envs;
            return this;
        }

        /**
         * @param envs List of environment variables to set in the container. After the container
         * starts running, code running in the container can read these environment
         * variables.
         * Additionally, the command and
         * args fields can reference these variables. Later
         * entries in this list can also reference earlier entries. For example, the
         * following example sets the variable `VAR_2` to have the value `foo bar`:
         * 
         * If you switch the order of the variables in the example, then the expansion
         * does not occur.
         * This field corresponds to the `env` field of the Kubernetes Containers
         * [v1 core
         * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder envs(List<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecEnvArgs> envs) {
            return envs(Output.of(envs));
        }

        /**
         * @param envs List of environment variables to set in the container. After the container
         * starts running, code running in the container can read these environment
         * variables.
         * Additionally, the command and
         * args fields can reference these variables. Later
         * entries in this list can also reference earlier entries. For example, the
         * following example sets the variable `VAR_2` to have the value `foo bar`:
         * 
         * If you switch the order of the variables in the example, then the expansion
         * does not occur.
         * This field corresponds to the `env` field of the Kubernetes Containers
         * [v1 core
         * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder envs(AiEndpointWithModelGardenDeploymentModelConfigContainerSpecEnvArgs... envs) {
            return envs(List.of(envs));
        }

        /**
         * @param grpcPorts List of ports to expose from the container. Vertex AI sends gRPC
         * prediction requests that it receives to the first port on this list. Vertex
         * AI also sends liveness and health checks to this port.
         * If you do not specify this field, gRPC requests to the container will be
         * disabled.
         * Vertex AI does not use ports other than the first one listed. This field
         * corresponds to the `ports` field of the Kubernetes Containers v1 core API.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder grpcPorts(@Nullable Output<List<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecGrpcPortArgs>> grpcPorts) {
            $.grpcPorts = grpcPorts;
            return this;
        }

        /**
         * @param grpcPorts List of ports to expose from the container. Vertex AI sends gRPC
         * prediction requests that it receives to the first port on this list. Vertex
         * AI also sends liveness and health checks to this port.
         * If you do not specify this field, gRPC requests to the container will be
         * disabled.
         * Vertex AI does not use ports other than the first one listed. This field
         * corresponds to the `ports` field of the Kubernetes Containers v1 core API.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder grpcPorts(List<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecGrpcPortArgs> grpcPorts) {
            return grpcPorts(Output.of(grpcPorts));
        }

        /**
         * @param grpcPorts List of ports to expose from the container. Vertex AI sends gRPC
         * prediction requests that it receives to the first port on this list. Vertex
         * AI also sends liveness and health checks to this port.
         * If you do not specify this field, gRPC requests to the container will be
         * disabled.
         * Vertex AI does not use ports other than the first one listed. This field
         * corresponds to the `ports` field of the Kubernetes Containers v1 core API.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder grpcPorts(AiEndpointWithModelGardenDeploymentModelConfigContainerSpecGrpcPortArgs... grpcPorts) {
            return grpcPorts(List.of(grpcPorts));
        }

        /**
         * @param healthProbe Probe describes a health check to be performed against a container to
         * determine whether it is alive or ready to receive traffic.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder healthProbe(@Nullable Output<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecHealthProbeArgs> healthProbe) {
            $.healthProbe = healthProbe;
            return this;
        }

        /**
         * @param healthProbe Probe describes a health check to be performed against a container to
         * determine whether it is alive or ready to receive traffic.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder healthProbe(AiEndpointWithModelGardenDeploymentModelConfigContainerSpecHealthProbeArgs healthProbe) {
            return healthProbe(Output.of(healthProbe));
        }

        /**
         * @param healthRoute HTTP path on the container to send health checks to. Vertex AI
         * intermittently sends GET requests to this path on the container&#39;s IP
         * address and port to check that the container is healthy. Read more about
         * [health
         * checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#health).
         * For example, if you set this field to `/bar`, then Vertex AI
         * intermittently sends a GET request to the `/bar` path on the port of your
         * container specified by the first value of this `ModelContainerSpec`&#39;s
         * ports field.
         * If you don&#39;t specify this field, it defaults to the following value when
         * you deploy this Model to an Endpoint:/v1/endpoints/ENDPOINT/deployedModels/DEPLOYED_MODEL:predict
         * The placeholders in this value are replaced as follows:
         * * ENDPOINT: The last segment (following `endpoints/`)of the
         *   Endpoint.name][] field of the Endpoint where this Model has been
         *   deployed. (Vertex AI makes this value available to your container code
         *   as the [`AIP_ENDPOINT_ID` environment
         *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
         * * DEPLOYED_MODEL: DeployedModel.id of the `DeployedModel`.
         *   (Vertex AI makes this value available to your container code as the
         *   [`AIP_DEPLOYED_MODEL_ID` environment
         *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
         * 
         * @return builder
         * 
         */
        public Builder healthRoute(@Nullable Output<String> healthRoute) {
            $.healthRoute = healthRoute;
            return this;
        }

        /**
         * @param healthRoute HTTP path on the container to send health checks to. Vertex AI
         * intermittently sends GET requests to this path on the container&#39;s IP
         * address and port to check that the container is healthy. Read more about
         * [health
         * checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#health).
         * For example, if you set this field to `/bar`, then Vertex AI
         * intermittently sends a GET request to the `/bar` path on the port of your
         * container specified by the first value of this `ModelContainerSpec`&#39;s
         * ports field.
         * If you don&#39;t specify this field, it defaults to the following value when
         * you deploy this Model to an Endpoint:/v1/endpoints/ENDPOINT/deployedModels/DEPLOYED_MODEL:predict
         * The placeholders in this value are replaced as follows:
         * * ENDPOINT: The last segment (following `endpoints/`)of the
         *   Endpoint.name][] field of the Endpoint where this Model has been
         *   deployed. (Vertex AI makes this value available to your container code
         *   as the [`AIP_ENDPOINT_ID` environment
         *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
         * * DEPLOYED_MODEL: DeployedModel.id of the `DeployedModel`.
         *   (Vertex AI makes this value available to your container code as the
         *   [`AIP_DEPLOYED_MODEL_ID` environment
         *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
         * 
         * @return builder
         * 
         */
        public Builder healthRoute(String healthRoute) {
            return healthRoute(Output.of(healthRoute));
        }

        /**
         * @param imageUri URI of the Docker image to be used as the custom container for serving
         * predictions. This URI must identify an image in Artifact Registry or
         * Container Registry. Learn more about the [container publishing
         * requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#publishing),
         * including permissions requirements for the Vertex AI Service Agent.
         * The container image is ingested upon ModelService.UploadModel, stored
         * internally, and this original path is afterwards not used.
         * To learn about the requirements for the Docker image itself, see
         * [Custom container
         * requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#).
         * You can use the URI to one of Vertex AI&#39;s [pre-built container images for
         * prediction](https://cloud.google.com/vertex-ai/docs/predictions/pre-built-containers)
         * in this field.
         * 
         * @return builder
         * 
         */
        public Builder imageUri(Output<String> imageUri) {
            $.imageUri = imageUri;
            return this;
        }

        /**
         * @param imageUri URI of the Docker image to be used as the custom container for serving
         * predictions. This URI must identify an image in Artifact Registry or
         * Container Registry. Learn more about the [container publishing
         * requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#publishing),
         * including permissions requirements for the Vertex AI Service Agent.
         * The container image is ingested upon ModelService.UploadModel, stored
         * internally, and this original path is afterwards not used.
         * To learn about the requirements for the Docker image itself, see
         * [Custom container
         * requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#).
         * You can use the URI to one of Vertex AI&#39;s [pre-built container images for
         * prediction](https://cloud.google.com/vertex-ai/docs/predictions/pre-built-containers)
         * in this field.
         * 
         * @return builder
         * 
         */
        public Builder imageUri(String imageUri) {
            return imageUri(Output.of(imageUri));
        }

        /**
         * @param livenessProbe Probe describes a health check to be performed against a container to
         * determine whether it is alive or ready to receive traffic.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder livenessProbe(@Nullable Output<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecLivenessProbeArgs> livenessProbe) {
            $.livenessProbe = livenessProbe;
            return this;
        }

        /**
         * @param livenessProbe Probe describes a health check to be performed against a container to
         * determine whether it is alive or ready to receive traffic.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder livenessProbe(AiEndpointWithModelGardenDeploymentModelConfigContainerSpecLivenessProbeArgs livenessProbe) {
            return livenessProbe(Output.of(livenessProbe));
        }

        /**
         * @param ports List of ports to expose from the container. Vertex AI sends any
         * prediction requests that it receives to the first port on this list. Vertex
         * AI also sends
         * [liveness and health
         * checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#liveness)
         * to this port.
         * If you do not specify this field, it defaults to following value:
         * 
         * Vertex AI does not use ports other than the first one listed. This field
         * corresponds to the `ports` field of the Kubernetes Containers
         * [v1 core
         * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder ports(@Nullable Output<List<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecPortArgs>> ports) {
            $.ports = ports;
            return this;
        }

        /**
         * @param ports List of ports to expose from the container. Vertex AI sends any
         * prediction requests that it receives to the first port on this list. Vertex
         * AI also sends
         * [liveness and health
         * checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#liveness)
         * to this port.
         * If you do not specify this field, it defaults to following value:
         * 
         * Vertex AI does not use ports other than the first one listed. This field
         * corresponds to the `ports` field of the Kubernetes Containers
         * [v1 core
         * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder ports(List<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecPortArgs> ports) {
            return ports(Output.of(ports));
        }

        /**
         * @param ports List of ports to expose from the container. Vertex AI sends any
         * prediction requests that it receives to the first port on this list. Vertex
         * AI also sends
         * [liveness and health
         * checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#liveness)
         * to this port.
         * If you do not specify this field, it defaults to following value:
         * 
         * Vertex AI does not use ports other than the first one listed. This field
         * corresponds to the `ports` field of the Kubernetes Containers
         * [v1 core
         * API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder ports(AiEndpointWithModelGardenDeploymentModelConfigContainerSpecPortArgs... ports) {
            return ports(List.of(ports));
        }

        /**
         * @param predictRoute HTTP path on the container to send prediction requests to. Vertex AI
         * forwards requests sent using
         * projects.locations.endpoints.predict to this
         * path on the container&#39;s IP address and port. Vertex AI then returns the
         * container&#39;s response in the API response.
         * For example, if you set this field to `/foo`, then when Vertex AI
         * receives a prediction request, it forwards the request body in a POST
         * request to the `/foo` path on the port of your container specified by the
         * first value of this `ModelContainerSpec`&#39;s
         * ports field.
         * If you don&#39;t specify this field, it defaults to the following value when
         * you deploy this Model to an Endpoint:/v1/endpoints/ENDPOINT/deployedModels/DEPLOYED_MODEL:predict
         * The placeholders in this value are replaced as follows:
         * * ENDPOINT: The last segment (following `endpoints/`)of the
         *   Endpoint.name][] field of the Endpoint where this Model has been
         *   deployed. (Vertex AI makes this value available to your container code
         *   as the [`AIP_ENDPOINT_ID` environment
         *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
         * * DEPLOYED_MODEL: DeployedModel.id of the `DeployedModel`.
         *   (Vertex AI makes this value available to your container code
         *   as the [`AIP_DEPLOYED_MODEL_ID` environment
         *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
         * 
         * @return builder
         * 
         */
        public Builder predictRoute(@Nullable Output<String> predictRoute) {
            $.predictRoute = predictRoute;
            return this;
        }

        /**
         * @param predictRoute HTTP path on the container to send prediction requests to. Vertex AI
         * forwards requests sent using
         * projects.locations.endpoints.predict to this
         * path on the container&#39;s IP address and port. Vertex AI then returns the
         * container&#39;s response in the API response.
         * For example, if you set this field to `/foo`, then when Vertex AI
         * receives a prediction request, it forwards the request body in a POST
         * request to the `/foo` path on the port of your container specified by the
         * first value of this `ModelContainerSpec`&#39;s
         * ports field.
         * If you don&#39;t specify this field, it defaults to the following value when
         * you deploy this Model to an Endpoint:/v1/endpoints/ENDPOINT/deployedModels/DEPLOYED_MODEL:predict
         * The placeholders in this value are replaced as follows:
         * * ENDPOINT: The last segment (following `endpoints/`)of the
         *   Endpoint.name][] field of the Endpoint where this Model has been
         *   deployed. (Vertex AI makes this value available to your container code
         *   as the [`AIP_ENDPOINT_ID` environment
         *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
         * * DEPLOYED_MODEL: DeployedModel.id of the `DeployedModel`.
         *   (Vertex AI makes this value available to your container code
         *   as the [`AIP_DEPLOYED_MODEL_ID` environment
         *   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
         * 
         * @return builder
         * 
         */
        public Builder predictRoute(String predictRoute) {
            return predictRoute(Output.of(predictRoute));
        }

        /**
         * @param sharedMemorySizeMb The amount of the VM memory to reserve as the shared memory for the model
         * in megabytes.
         * 
         * @return builder
         * 
         */
        public Builder sharedMemorySizeMb(@Nullable Output<String> sharedMemorySizeMb) {
            $.sharedMemorySizeMb = sharedMemorySizeMb;
            return this;
        }

        /**
         * @param sharedMemorySizeMb The amount of the VM memory to reserve as the shared memory for the model
         * in megabytes.
         * 
         * @return builder
         * 
         */
        public Builder sharedMemorySizeMb(String sharedMemorySizeMb) {
            return sharedMemorySizeMb(Output.of(sharedMemorySizeMb));
        }

        /**
         * @param startupProbe Probe describes a health check to be performed against a container to
         * determine whether it is alive or ready to receive traffic.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder startupProbe(@Nullable Output<AiEndpointWithModelGardenDeploymentModelConfigContainerSpecStartupProbeArgs> startupProbe) {
            $.startupProbe = startupProbe;
            return this;
        }

        /**
         * @param startupProbe Probe describes a health check to be performed against a container to
         * determine whether it is alive or ready to receive traffic.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder startupProbe(AiEndpointWithModelGardenDeploymentModelConfigContainerSpecStartupProbeArgs startupProbe) {
            return startupProbe(Output.of(startupProbe));
        }

        public AiEndpointWithModelGardenDeploymentModelConfigContainerSpecArgs build() {
            if ($.imageUri == null) {
                throw new MissingRequiredPropertyException("AiEndpointWithModelGardenDeploymentModelConfigContainerSpecArgs", "imageUri");
            }
            return $;
        }
    }

}
