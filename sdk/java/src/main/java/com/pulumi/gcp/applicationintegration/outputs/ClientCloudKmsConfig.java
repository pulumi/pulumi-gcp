// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.applicationintegration.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class ClientCloudKmsConfig {
    /**
     * @return A Cloud KMS key is a named object containing one or more key versions, along
     * with metadata for the key. A key exists on exactly one key ring tied to a
     * specific location.
     * 
     */
    private String key;
    /**
     * @return Each version of a key contains key material used for encryption or signing.
     * A key&#39;s version is represented by an integer, starting at 1. To decrypt data
     * or verify a signature, you must use the same key version that was used to
     * encrypt or sign the data.
     * 
     */
    private @Nullable String keyVersion;
    /**
     * @return Location name of the key ring, e.g. &#34;us-west1&#34;.
     * 
     */
    private String kmsLocation;
    /**
     * @return The Google Cloud project id of the project where the kms key stored. If empty,
     * the kms key is stored at the same project as customer&#39;s project and ecrypted
     * with CMEK, otherwise, the kms key is stored in the tenant project and
     * encrypted with GMEK.
     * 
     */
    private @Nullable String kmsProjectId;
    /**
     * @return A key ring organizes keys in a specific Google Cloud location and allows you to
     * manage access control on groups of keys. A key ring&#39;s name does not need to be
     * unique across a Google Cloud project, but must be unique within a given location.
     * 
     */
    private String kmsRing;

    private ClientCloudKmsConfig() {}
    /**
     * @return A Cloud KMS key is a named object containing one or more key versions, along
     * with metadata for the key. A key exists on exactly one key ring tied to a
     * specific location.
     * 
     */
    public String key() {
        return this.key;
    }
    /**
     * @return Each version of a key contains key material used for encryption or signing.
     * A key&#39;s version is represented by an integer, starting at 1. To decrypt data
     * or verify a signature, you must use the same key version that was used to
     * encrypt or sign the data.
     * 
     */
    public Optional<String> keyVersion() {
        return Optional.ofNullable(this.keyVersion);
    }
    /**
     * @return Location name of the key ring, e.g. &#34;us-west1&#34;.
     * 
     */
    public String kmsLocation() {
        return this.kmsLocation;
    }
    /**
     * @return The Google Cloud project id of the project where the kms key stored. If empty,
     * the kms key is stored at the same project as customer&#39;s project and ecrypted
     * with CMEK, otherwise, the kms key is stored in the tenant project and
     * encrypted with GMEK.
     * 
     */
    public Optional<String> kmsProjectId() {
        return Optional.ofNullable(this.kmsProjectId);
    }
    /**
     * @return A key ring organizes keys in a specific Google Cloud location and allows you to
     * manage access control on groups of keys. A key ring&#39;s name does not need to be
     * unique across a Google Cloud project, but must be unique within a given location.
     * 
     */
    public String kmsRing() {
        return this.kmsRing;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ClientCloudKmsConfig defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String key;
        private @Nullable String keyVersion;
        private String kmsLocation;
        private @Nullable String kmsProjectId;
        private String kmsRing;
        public Builder() {}
        public Builder(ClientCloudKmsConfig defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.key = defaults.key;
    	      this.keyVersion = defaults.keyVersion;
    	      this.kmsLocation = defaults.kmsLocation;
    	      this.kmsProjectId = defaults.kmsProjectId;
    	      this.kmsRing = defaults.kmsRing;
        }

        @CustomType.Setter
        public Builder key(String key) {
            if (key == null) {
              throw new MissingRequiredPropertyException("ClientCloudKmsConfig", "key");
            }
            this.key = key;
            return this;
        }
        @CustomType.Setter
        public Builder keyVersion(@Nullable String keyVersion) {

            this.keyVersion = keyVersion;
            return this;
        }
        @CustomType.Setter
        public Builder kmsLocation(String kmsLocation) {
            if (kmsLocation == null) {
              throw new MissingRequiredPropertyException("ClientCloudKmsConfig", "kmsLocation");
            }
            this.kmsLocation = kmsLocation;
            return this;
        }
        @CustomType.Setter
        public Builder kmsProjectId(@Nullable String kmsProjectId) {

            this.kmsProjectId = kmsProjectId;
            return this;
        }
        @CustomType.Setter
        public Builder kmsRing(String kmsRing) {
            if (kmsRing == null) {
              throw new MissingRequiredPropertyException("ClientCloudKmsConfig", "kmsRing");
            }
            this.kmsRing = kmsRing;
            return this;
        }
        public ClientCloudKmsConfig build() {
            final var _resultValue = new ClientCloudKmsConfig();
            _resultValue.key = key;
            _resultValue.keyVersion = keyVersion;
            _resultValue.kmsLocation = kmsLocation;
            _resultValue.kmsProjectId = kmsProjectId;
            _resultValue.kmsRing = kmsRing;
            return _resultValue;
        }
    }
}
