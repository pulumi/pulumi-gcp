// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.vertex;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.vertex.AiIndexEndpointDeployedIndexArgs;
import com.pulumi.gcp.vertex.inputs.AiIndexEndpointDeployedIndexState;
import com.pulumi.gcp.vertex.outputs.AiIndexEndpointDeployedIndexAutomaticResources;
import com.pulumi.gcp.vertex.outputs.AiIndexEndpointDeployedIndexDedicatedResources;
import com.pulumi.gcp.vertex.outputs.AiIndexEndpointDeployedIndexDeployedIndexAuthConfig;
import com.pulumi.gcp.vertex.outputs.AiIndexEndpointDeployedIndexPrivateEndpoint;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * An endpoint indexes are deployed into. An index endpoint can have multiple deployed indexes.
 * 
 * To get more information about IndexEndpointDeployedIndex, see:
 * 
 * * [API documentation](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#DeployedIndex)
 * 
 * ## Example Usage
 * 
 * ### Vertex Ai Index Endpoint Deployed Index Basic
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.storage.Bucket;
 * import com.pulumi.gcp.storage.BucketArgs;
 * import com.pulumi.gcp.vertex.AiIndex;
 * import com.pulumi.gcp.vertex.AiIndexArgs;
 * import com.pulumi.gcp.vertex.inputs.AiIndexMetadataArgs;
 * import com.pulumi.gcp.vertex.inputs.AiIndexMetadataConfigArgs;
 * import com.pulumi.gcp.vertex.inputs.AiIndexMetadataConfigAlgorithmConfigArgs;
 * import com.pulumi.gcp.vertex.inputs.AiIndexMetadataConfigAlgorithmConfigTreeAhConfigArgs;
 * import com.pulumi.gcp.compute.ComputeFunctions;
 * import com.pulumi.gcp.compute.inputs.GetNetworkArgs;
 * import com.pulumi.gcp.organizations.OrganizationsFunctions;
 * import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
 * import com.pulumi.gcp.vertex.AiIndexEndpoint;
 * import com.pulumi.gcp.vertex.AiIndexEndpointArgs;
 * import com.pulumi.gcp.serviceaccount.Account;
 * import com.pulumi.gcp.serviceaccount.AccountArgs;
 * import com.pulumi.gcp.vertex.AiIndexEndpointDeployedIndex;
 * import com.pulumi.gcp.vertex.AiIndexEndpointDeployedIndexArgs;
 * import com.pulumi.gcp.vertex.inputs.AiIndexEndpointDeployedIndexDeployedIndexAuthConfigArgs;
 * import com.pulumi.gcp.vertex.inputs.AiIndexEndpointDeployedIndexDeployedIndexAuthConfigAuthProviderArgs;
 * import com.pulumi.gcp.storage.BucketObject;
 * import com.pulumi.gcp.storage.BucketObjectArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var bucket = new Bucket("bucket", BucketArgs.builder()
 *             .name("bucket-name")
 *             .location("us-central1")
 *             .uniformBucketLevelAccess(true)
 *             .build());
 * 
 *         var index = new AiIndex("index", AiIndexArgs.builder()
 *             .region("us-central1")
 *             .displayName("test-index")
 *             .description("index for test")
 *             .indexUpdateMethod("BATCH_UPDATE")
 *             .labels(Map.of("foo", "bar"))
 *             .metadata(AiIndexMetadataArgs.builder()
 *                 .contentsDeltaUri(bucket.name().applyValue(_name -> String.format("gs://%s/contents", _name)))
 *                 .config(AiIndexMetadataConfigArgs.builder()
 *                     .dimensions(2)
 *                     .approximateNeighborsCount(150)
 *                     .shardSize("SHARD_SIZE_SMALL")
 *                     .distanceMeasureType("DOT_PRODUCT_DISTANCE")
 *                     .algorithmConfig(AiIndexMetadataConfigAlgorithmConfigArgs.builder()
 *                         .treeAhConfig(AiIndexMetadataConfigAlgorithmConfigTreeAhConfigArgs.builder()
 *                             .leafNodeEmbeddingCount(500)
 *                             .leafNodesToSearchPercent(7)
 *                             .build())
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *         final var vertexNetwork = ComputeFunctions.getNetwork(GetNetworkArgs.builder()
 *             .name("network-name")
 *             .build());
 * 
 *         final var project = OrganizationsFunctions.getProject(GetProjectArgs.builder()
 *             .build());
 * 
 *         var vertexIndexEndpointDeployed = new AiIndexEndpoint("vertexIndexEndpointDeployed", AiIndexEndpointArgs.builder()
 *             .displayName("sample-endpoint")
 *             .description("A sample vertex endpoint")
 *             .region("us-central1")
 *             .network(String.format("projects/%s/global/networks/%s", project.number(),vertexNetwork.name()))
 *             .labels(Map.of("label-one", "value-one"))
 *             .build());
 * 
 *         var sa = new Account("sa", AccountArgs.builder()
 *             .accountId("vertex-sa")
 *             .build());
 * 
 *         var basicDeployedIndex = new AiIndexEndpointDeployedIndex("basicDeployedIndex", AiIndexEndpointDeployedIndexArgs.builder()
 *             .deployedIndexId("deployed_index_id")
 *             .displayName("vertex-deployed-index")
 *             .region("us-central1")
 *             .index(index.id())
 *             .indexEndpoint(vertexIndexEndpointDeployed.id())
 *             .enableAccessLogging(false)
 *             .reservedIpRanges("vertex-ai-range")
 *             .deployedIndexAuthConfig(AiIndexEndpointDeployedIndexDeployedIndexAuthConfigArgs.builder()
 *                 .authProvider(AiIndexEndpointDeployedIndexDeployedIndexAuthConfigAuthProviderArgs.builder()
 *                     .audiences("123456-my-app")
 *                     .allowedIssuers(sa.email())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *         // The sample data comes from the following link:
 *         // https://cloud.google.com/vertex-ai/docs/matching-engine/filtering#specify-namespaces-tokens
 *         var data = new BucketObject("data", BucketObjectArgs.builder()
 *             .name("contents/data.json")
 *             .bucket(bucket.name())
 *             .content("""
 * {"id": "42", "embedding": [0.5, 1.0], "restricts": [{"namespace": "class", "allow": ["cat", "pet"]},{"namespace": "category", "allow": ["feline"]}]}
 * {"id": "43", "embedding": [0.6, 1.0], "restricts": [{"namespace": "class", "allow": ["dog", "pet"]},{"namespace": "category", "allow": ["canine"]}]}
 *             """)
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * ### Vertex Ai Index Endpoint Deployed Index Basic Two
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.serviceaccount.Account;
 * import com.pulumi.gcp.serviceaccount.AccountArgs;
 * import com.pulumi.gcp.storage.Bucket;
 * import com.pulumi.gcp.storage.BucketArgs;
 * import com.pulumi.gcp.vertex.AiIndex;
 * import com.pulumi.gcp.vertex.AiIndexArgs;
 * import com.pulumi.gcp.vertex.inputs.AiIndexMetadataArgs;
 * import com.pulumi.gcp.vertex.inputs.AiIndexMetadataConfigArgs;
 * import com.pulumi.gcp.vertex.inputs.AiIndexMetadataConfigAlgorithmConfigArgs;
 * import com.pulumi.gcp.vertex.inputs.AiIndexMetadataConfigAlgorithmConfigTreeAhConfigArgs;
 * import com.pulumi.gcp.compute.ComputeFunctions;
 * import com.pulumi.gcp.compute.inputs.GetNetworkArgs;
 * import com.pulumi.gcp.organizations.OrganizationsFunctions;
 * import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
 * import com.pulumi.gcp.vertex.AiIndexEndpoint;
 * import com.pulumi.gcp.vertex.AiIndexEndpointArgs;
 * import com.pulumi.gcp.vertex.AiIndexEndpointDeployedIndex;
 * import com.pulumi.gcp.vertex.AiIndexEndpointDeployedIndexArgs;
 * import com.pulumi.gcp.vertex.inputs.AiIndexEndpointDeployedIndexDeployedIndexAuthConfigArgs;
 * import com.pulumi.gcp.vertex.inputs.AiIndexEndpointDeployedIndexDeployedIndexAuthConfigAuthProviderArgs;
 * import com.pulumi.gcp.vertex.inputs.AiIndexEndpointDeployedIndexAutomaticResourcesArgs;
 * import com.pulumi.gcp.storage.BucketObject;
 * import com.pulumi.gcp.storage.BucketObjectArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var sa = new Account("sa", AccountArgs.builder()
 *             .accountId("vertex-sa")
 *             .build());
 * 
 *         var bucket = new Bucket("bucket", BucketArgs.builder()
 *             .name("bucket-name")
 *             .location("us-central1")
 *             .uniformBucketLevelAccess(true)
 *             .build());
 * 
 *         var index = new AiIndex("index", AiIndexArgs.builder()
 *             .region("us-central1")
 *             .displayName("test-index")
 *             .description("index for test")
 *             .indexUpdateMethod("BATCH_UPDATE")
 *             .labels(Map.of("foo", "bar"))
 *             .metadata(AiIndexMetadataArgs.builder()
 *                 .contentsDeltaUri(bucket.name().applyValue(_name -> String.format("gs://%s/contents", _name)))
 *                 .config(AiIndexMetadataConfigArgs.builder()
 *                     .dimensions(2)
 *                     .approximateNeighborsCount(150)
 *                     .shardSize("SHARD_SIZE_SMALL")
 *                     .distanceMeasureType("DOT_PRODUCT_DISTANCE")
 *                     .algorithmConfig(AiIndexMetadataConfigAlgorithmConfigArgs.builder()
 *                         .treeAhConfig(AiIndexMetadataConfigAlgorithmConfigTreeAhConfigArgs.builder()
 *                             .leafNodeEmbeddingCount(500)
 *                             .leafNodesToSearchPercent(7)
 *                             .build())
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *         final var vertexNetwork = ComputeFunctions.getNetwork(GetNetworkArgs.builder()
 *             .name("network-name")
 *             .build());
 * 
 *         final var project = OrganizationsFunctions.getProject(GetProjectArgs.builder()
 *             .build());
 * 
 *         var vertexIndexEndpointDeployed = new AiIndexEndpoint("vertexIndexEndpointDeployed", AiIndexEndpointArgs.builder()
 *             .displayName("sample-endpoint")
 *             .description("A sample vertex endpoint")
 *             .region("us-central1")
 *             .network(String.format("projects/%s/global/networks/%s", project.number(),vertexNetwork.name()))
 *             .labels(Map.of("label-one", "value-one"))
 *             .build());
 * 
 *         var basicDeployedIndex = new AiIndexEndpointDeployedIndex("basicDeployedIndex", AiIndexEndpointDeployedIndexArgs.builder()
 *             .deployedIndexId("deployed_index_id")
 *             .displayName("vertex-deployed-index")
 *             .region("us-central1")
 *             .index(index.id())
 *             .indexEndpoint(vertexIndexEndpointDeployed.id())
 *             .reservedIpRanges("vertex-ai-range")
 *             .enableAccessLogging(false)
 *             .deployedIndexAuthConfig(AiIndexEndpointDeployedIndexDeployedIndexAuthConfigArgs.builder()
 *                 .authProvider(AiIndexEndpointDeployedIndexDeployedIndexAuthConfigAuthProviderArgs.builder()
 *                     .audiences("123456-my-app")
 *                     .allowedIssuers(sa.email())
 *                     .build())
 *                 .build())
 *             .automaticResources(AiIndexEndpointDeployedIndexAutomaticResourcesArgs.builder()
 *                 .maxReplicaCount(4)
 *                 .build())
 *             .build());
 * 
 *         // The sample data comes from the following link:
 *         // https://cloud.google.com/vertex-ai/docs/matching-engine/filtering#specify-namespaces-tokens
 *         var data = new BucketObject("data", BucketObjectArgs.builder()
 *             .name("contents/data.json")
 *             .bucket(bucket.name())
 *             .content("""
 * {"id": "42", "embedding": [0.5, 1.0], "restricts": [{"namespace": "class", "allow": ["cat", "pet"]},{"namespace": "category", "allow": ["feline"]}]}
 * {"id": "43", "embedding": [0.6, 1.0], "restricts": [{"namespace": "class", "allow": ["dog", "pet"]},{"namespace": "category", "allow": ["canine"]}]}
 *             """)
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Import
 * 
 * IndexEndpointDeployedIndex can be imported using any of these accepted formats:
 * 
 * * `projects/{{project}}/locations/{{region}}/indexEndpoints/{{index_endpoint}}/deployedIndex/{{deployed_index_id}}`
 * 
 * * `{{project}}/{{region}}/{{index_endpoint}}/{{deployed_index_id}}`
 * 
 * * `{{region}}/{{index_endpoint}}/{{deployed_index_id}}`
 * 
 * * `{{index_endpoint}}/{{deployed_index_id}}`
 * 
 * When using the `pulumi import` command, IndexEndpointDeployedIndex can be imported using one of the formats above. For example:
 * 
 * ```sh
 * $ pulumi import gcp:vertex/aiIndexEndpointDeployedIndex:AiIndexEndpointDeployedIndex default projects/{{project}}/locations/{{region}}/indexEndpoints/{{index_endpoint}}/deployedIndex/{{deployed_index_id}}
 * ```
 * 
 * ```sh
 * $ pulumi import gcp:vertex/aiIndexEndpointDeployedIndex:AiIndexEndpointDeployedIndex default {{project}}/{{region}}/{{index_endpoint}}/{{deployed_index_id}}
 * ```
 * 
 * ```sh
 * $ pulumi import gcp:vertex/aiIndexEndpointDeployedIndex:AiIndexEndpointDeployedIndex default {{region}}/{{index_endpoint}}/{{deployed_index_id}}
 * ```
 * 
 * ```sh
 * $ pulumi import gcp:vertex/aiIndexEndpointDeployedIndex:AiIndexEndpointDeployedIndex default {{index_endpoint}}/{{deployed_index_id}}
 * ```
 * 
 */
@ResourceType(type="gcp:vertex/aiIndexEndpointDeployedIndex:AiIndexEndpointDeployedIndex")
public class AiIndexEndpointDeployedIndex extends com.pulumi.resources.CustomResource {
    /**
     * A description of resources that the DeployedIndex uses, which to large degree are decided by Vertex AI, and optionally allows only a modest additional configuration.
     * Structure is documented below.
     * 
     */
    @Export(name="automaticResources", refs={AiIndexEndpointDeployedIndexAutomaticResources.class}, tree="[0]")
    private Output<AiIndexEndpointDeployedIndexAutomaticResources> automaticResources;

    /**
     * @return A description of resources that the DeployedIndex uses, which to large degree are decided by Vertex AI, and optionally allows only a modest additional configuration.
     * Structure is documented below.
     * 
     */
    public Output<AiIndexEndpointDeployedIndexAutomaticResources> automaticResources() {
        return this.automaticResources;
    }
    /**
     * The timestamp of when the Index was created in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits.
     * 
     */
    @Export(name="createTime", refs={String.class}, tree="[0]")
    private Output<String> createTime;

    /**
     * @return The timestamp of when the Index was created in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits.
     * 
     */
    public Output<String> createTime() {
        return this.createTime;
    }
    /**
     * A description of resources that are dedicated to the DeployedIndex, and that need a higher degree of manual configuration. The field minReplicaCount must be set to a value strictly greater than 0, or else validation will fail. We don&#39;t provide SLA when minReplicaCount=1. If maxReplicaCount is not set, the default value is minReplicaCount. The max allowed replica count is 1000.
     * Available machine types for SMALL shard: e2-standard-2 and all machine types available for MEDIUM and LARGE shard.
     * Available machine types for MEDIUM shard: e2-standard-16 and all machine types available for LARGE shard.
     * Available machine types for LARGE shard: e2-highmem-16, n2d-standard-32.
     * n1-standard-16 and n1-standard-32 are still available, but we recommend e2-standard-16 and e2-highmem-16 for cost efficiency.
     * Structure is documented below.
     * 
     */
    @Export(name="dedicatedResources", refs={AiIndexEndpointDeployedIndexDedicatedResources.class}, tree="[0]")
    private Output</* @Nullable */ AiIndexEndpointDeployedIndexDedicatedResources> dedicatedResources;

    /**
     * @return A description of resources that are dedicated to the DeployedIndex, and that need a higher degree of manual configuration. The field minReplicaCount must be set to a value strictly greater than 0, or else validation will fail. We don&#39;t provide SLA when minReplicaCount=1. If maxReplicaCount is not set, the default value is minReplicaCount. The max allowed replica count is 1000.
     * Available machine types for SMALL shard: e2-standard-2 and all machine types available for MEDIUM and LARGE shard.
     * Available machine types for MEDIUM shard: e2-standard-16 and all machine types available for LARGE shard.
     * Available machine types for LARGE shard: e2-highmem-16, n2d-standard-32.
     * n1-standard-16 and n1-standard-32 are still available, but we recommend e2-standard-16 and e2-highmem-16 for cost efficiency.
     * Structure is documented below.
     * 
     */
    public Output<Optional<AiIndexEndpointDeployedIndexDedicatedResources>> dedicatedResources() {
        return Codegen.optional(this.dedicatedResources);
    }
    /**
     * If set, the authentication is enabled for the private endpoint.
     * Structure is documented below.
     * 
     */
    @Export(name="deployedIndexAuthConfig", refs={AiIndexEndpointDeployedIndexDeployedIndexAuthConfig.class}, tree="[0]")
    private Output</* @Nullable */ AiIndexEndpointDeployedIndexDeployedIndexAuthConfig> deployedIndexAuthConfig;

    /**
     * @return If set, the authentication is enabled for the private endpoint.
     * Structure is documented below.
     * 
     */
    public Output<Optional<AiIndexEndpointDeployedIndexDeployedIndexAuthConfig>> deployedIndexAuthConfig() {
        return Codegen.optional(this.deployedIndexAuthConfig);
    }
    /**
     * The user specified ID of the DeployedIndex. The ID can be up to 128 characters long and must start with a letter and only contain letters, numbers, and underscores. The ID must be unique within the project it is created in.
     * 
     */
    @Export(name="deployedIndexId", refs={String.class}, tree="[0]")
    private Output<String> deployedIndexId;

    /**
     * @return The user specified ID of the DeployedIndex. The ID can be up to 128 characters long and must start with a letter and only contain letters, numbers, and underscores. The ID must be unique within the project it is created in.
     * 
     */
    public Output<String> deployedIndexId() {
        return this.deployedIndexId;
    }
    /**
     * The deployment group can be no longer than 64 characters (eg: &#39;test&#39;, &#39;prod&#39;). If not set, we will use the &#39;default&#39; deployment group.
     * Creating deployment_groups with reserved_ip_ranges is a recommended practice when the peered network has multiple peering ranges. This creates your deployments from predictable IP spaces for easier traffic administration. Also, one deployment_group (except &#39;default&#39;) can only be used with the same reserved_ip_ranges which means if the deployment_group has been used with reserved_ip_ranges: [a, b, c], using it with [a, b] or [d, e] is disallowed. [See the official documentation here](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#DeployedIndex.FIELDS.deployment_group).
     * Note: we only support up to 5 deployment groups (not including &#39;default&#39;).
     * 
     */
    @Export(name="deploymentGroup", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> deploymentGroup;

    /**
     * @return The deployment group can be no longer than 64 characters (eg: &#39;test&#39;, &#39;prod&#39;). If not set, we will use the &#39;default&#39; deployment group.
     * Creating deployment_groups with reserved_ip_ranges is a recommended practice when the peered network has multiple peering ranges. This creates your deployments from predictable IP spaces for easier traffic administration. Also, one deployment_group (except &#39;default&#39;) can only be used with the same reserved_ip_ranges which means if the deployment_group has been used with reserved_ip_ranges: [a, b, c], using it with [a, b] or [d, e] is disallowed. [See the official documentation here](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#DeployedIndex.FIELDS.deployment_group).
     * Note: we only support up to 5 deployment groups (not including &#39;default&#39;).
     * 
     */
    public Output<Optional<String>> deploymentGroup() {
        return Codegen.optional(this.deploymentGroup);
    }
    /**
     * The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
     * 
     */
    @Export(name="displayName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> displayName;

    /**
     * @return The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
     * 
     */
    public Output<Optional<String>> displayName() {
        return Codegen.optional(this.displayName);
    }
    /**
     * If true, private endpoint&#39;s access logs are sent to Cloud Logging.
     * 
     */
    @Export(name="enableAccessLogging", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableAccessLogging;

    /**
     * @return If true, private endpoint&#39;s access logs are sent to Cloud Logging.
     * 
     */
    public Output<Optional<Boolean>> enableAccessLogging() {
        return Codegen.optional(this.enableAccessLogging);
    }
    /**
     * The name of the Index this is the deployment of.
     * 
     */
    @Export(name="index", refs={String.class}, tree="[0]")
    private Output<String> index;

    /**
     * @return The name of the Index this is the deployment of.
     * 
     */
    public Output<String> index() {
        return this.index;
    }
    /**
     * Identifies the index endpoint. Must be in the format
     * &#39;projects/{{project}}/locations/{{region}}/indexEndpoints/{{indexEndpoint}}&#39;
     * 
     */
    @Export(name="indexEndpoint", refs={String.class}, tree="[0]")
    private Output<String> indexEndpoint;

    /**
     * @return Identifies the index endpoint. Must be in the format
     * &#39;projects/{{project}}/locations/{{region}}/indexEndpoints/{{indexEndpoint}}&#39;
     * 
     */
    public Output<String> indexEndpoint() {
        return this.indexEndpoint;
    }
    /**
     * The DeployedIndex may depend on various data on its original Index. Additionally when certain changes to the original Index are being done (e.g. when what the Index contains is being changed) the DeployedIndex may be asynchronously updated in the background to reflect these changes. If this timestamp&#39;s value is at least the [Index.update_time](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexes#Index.FIELDS.update_time) of the original Index, it means that this DeployedIndex and the original Index are in sync. If this timestamp is older, then to see which updates this DeployedIndex already contains (and which it does not), one must [list](https://cloud.google.com/vertex-ai/docs/reference/rest/v1beta1/projects.locations.operations/list#google.longrunning.Operations.ListOperations) the operations that are running on the original Index. Only the successfully completed Operations with updateTime equal or before this sync time are contained in this DeployedIndex.
     * A timestamp in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits. Examples: &#34;2014-10-02T15:01:23Z&#34; and &#34;2014-10-02T15:01:23.045123456Z&#34;.
     * 
     */
    @Export(name="indexSyncTime", refs={String.class}, tree="[0]")
    private Output<String> indexSyncTime;

    /**
     * @return The DeployedIndex may depend on various data on its original Index. Additionally when certain changes to the original Index are being done (e.g. when what the Index contains is being changed) the DeployedIndex may be asynchronously updated in the background to reflect these changes. If this timestamp&#39;s value is at least the [Index.update_time](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexes#Index.FIELDS.update_time) of the original Index, it means that this DeployedIndex and the original Index are in sync. If this timestamp is older, then to see which updates this DeployedIndex already contains (and which it does not), one must [list](https://cloud.google.com/vertex-ai/docs/reference/rest/v1beta1/projects.locations.operations/list#google.longrunning.Operations.ListOperations) the operations that are running on the original Index. Only the successfully completed Operations with updateTime equal or before this sync time are contained in this DeployedIndex.
     * A timestamp in RFC3339 UTC &#34;Zulu&#34; format, with nanosecond resolution and up to nine fractional digits. Examples: &#34;2014-10-02T15:01:23Z&#34; and &#34;2014-10-02T15:01:23.045123456Z&#34;.
     * 
     */
    public Output<String> indexSyncTime() {
        return this.indexSyncTime;
    }
    /**
     * The name of the DeployedIndex resource.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the DeployedIndex resource.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Provides paths for users to send requests directly to the deployed index services running on Cloud via private services access. This field is populated if [network](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#IndexEndpoint.FIELDS.network) is configured.
     * Structure is documented below.
     * 
     */
    @Export(name="privateEndpoints", refs={List.class,AiIndexEndpointDeployedIndexPrivateEndpoint.class}, tree="[0,1]")
    private Output<List<AiIndexEndpointDeployedIndexPrivateEndpoint>> privateEndpoints;

    /**
     * @return Provides paths for users to send requests directly to the deployed index services running on Cloud via private services access. This field is populated if [network](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#IndexEndpoint.FIELDS.network) is configured.
     * Structure is documented below.
     * 
     */
    public Output<List<AiIndexEndpointDeployedIndexPrivateEndpoint>> privateEndpoints() {
        return this.privateEndpoints;
    }
    /**
     * The region of the index endpoint deployment. eg us-central1
     * 
     */
    @Export(name="region", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> region;

    /**
     * @return The region of the index endpoint deployment. eg us-central1
     * 
     */
    public Output<Optional<String>> region() {
        return Codegen.optional(this.region);
    }
    /**
     * A list of reserved ip ranges under the VPC network that can be used for this DeployedIndex.
     * If set, we will deploy the index within the provided ip ranges. Otherwise, the index might be deployed to any ip ranges under the provided VPC network.
     * The value should be the name of the address (https://cloud.google.com/compute/docs/reference/rest/v1/addresses) Example: [&#39;vertex-ai-ip-range&#39;].
     * For more information about subnets and network IP ranges, please see https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges.
     * 
     */
    @Export(name="reservedIpRanges", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> reservedIpRanges;

    /**
     * @return A list of reserved ip ranges under the VPC network that can be used for this DeployedIndex.
     * If set, we will deploy the index within the provided ip ranges. Otherwise, the index might be deployed to any ip ranges under the provided VPC network.
     * The value should be the name of the address (https://cloud.google.com/compute/docs/reference/rest/v1/addresses) Example: [&#39;vertex-ai-ip-range&#39;].
     * For more information about subnets and network IP ranges, please see https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges.
     * 
     */
    public Output<Optional<List<String>>> reservedIpRanges() {
        return Codegen.optional(this.reservedIpRanges);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public AiIndexEndpointDeployedIndex(java.lang.String name) {
        this(name, AiIndexEndpointDeployedIndexArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public AiIndexEndpointDeployedIndex(java.lang.String name, AiIndexEndpointDeployedIndexArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public AiIndexEndpointDeployedIndex(java.lang.String name, AiIndexEndpointDeployedIndexArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:vertex/aiIndexEndpointDeployedIndex:AiIndexEndpointDeployedIndex", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private AiIndexEndpointDeployedIndex(java.lang.String name, Output<java.lang.String> id, @Nullable AiIndexEndpointDeployedIndexState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:vertex/aiIndexEndpointDeployedIndex:AiIndexEndpointDeployedIndex", name, state, makeResourceOptions(options, id), false);
    }

    private static AiIndexEndpointDeployedIndexArgs makeArgs(AiIndexEndpointDeployedIndexArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? AiIndexEndpointDeployedIndexArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static AiIndexEndpointDeployedIndex get(java.lang.String name, Output<java.lang.String> id, @Nullable AiIndexEndpointDeployedIndexState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new AiIndexEndpointDeployedIndex(name, id, state, options);
    }
}
