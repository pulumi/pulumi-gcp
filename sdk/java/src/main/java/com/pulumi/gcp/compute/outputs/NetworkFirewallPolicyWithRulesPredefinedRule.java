// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.gcp.compute.outputs.NetworkFirewallPolicyWithRulesPredefinedRuleMatch;
import com.pulumi.gcp.compute.outputs.NetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class NetworkFirewallPolicyWithRulesPredefinedRule {
    /**
     * @return (Output)
     * The Action to perform when the client connection triggers the rule. Can currently be either
     * &#34;allow&#34;, &#34;deny&#34;, &#34;apply_security_profile_group&#34; or &#34;goto_next&#34;.
     * 
     */
    private @Nullable String action;
    /**
     * @return An optional description of this resource.
     * 
     */
    private @Nullable String description;
    /**
     * @return (Output)
     * The direction in which this rule applies. If unspecified an INGRESS rule is created.
     * 
     */
    private @Nullable String direction;
    /**
     * @return (Output)
     * Denotes whether the firewall policy rule is disabled. When set to true,
     * the firewall policy rule is not enforced and traffic behaves as if it did
     * not exist. If this is unspecified, the firewall policy rule will be
     * enabled.
     * 
     */
    private @Nullable Boolean disabled;
    /**
     * @return (Output)
     * Denotes whether to enable logging for a particular rule.
     * If logging is enabled, logs will be exported to the
     * configured export destination in Stackdriver.
     * 
     */
    private @Nullable Boolean enableLogging;
    /**
     * @return (Output)
     * A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding &#39;action&#39; is enforced.
     * Structure is documented below.
     * 
     */
    private @Nullable List<NetworkFirewallPolicyWithRulesPredefinedRuleMatch> matches;
    /**
     * @return (Output)
     * An integer indicating the priority of a rule in the list. The priority must be a value
     * between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
     * highest priority and 2147483647 is the lowest priority.
     * 
     */
    private @Nullable Integer priority;
    /**
     * @return (Output)
     * An optional name for the rule. This field is not a unique identifier
     * and can be updated.
     * 
     */
    private @Nullable String ruleName;
    /**
     * @return (Output)
     * A fully-qualified URL of a SecurityProfile resource instance.
     * Example:
     * https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
     * Must be specified if action is &#39;apply_security_profile_group&#39;.
     * 
     */
    private @Nullable String securityProfileGroup;
    /**
     * @return (Output)
     * A list of secure tags that controls which instances the firewall rule
     * applies to. If &lt;code&gt;targetSecureTag&lt;/code&gt; are specified, then the
     * firewall rule applies only to instances in the VPC network that have one
     * of those EFFECTIVE secure tags, if all the target_secure_tag are in
     * INEFFECTIVE state, then this rule will be ignored.
     * &lt;code&gt;targetSecureTag&lt;/code&gt; may not be set at the same time as
     * &lt;code&gt;targetServiceAccounts&lt;/code&gt;.
     * If neither &lt;code&gt;targetServiceAccounts&lt;/code&gt; nor
     * &lt;code&gt;targetSecureTag&lt;/code&gt; are specified, the firewall rule applies
     * to all instances on the specified network.
     * Maximum number of target label tags allowed is 256.
     * Structure is documented below.
     * 
     */
    private @Nullable List<NetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag> targetSecureTags;
    /**
     * @return (Output)
     * A list of service accounts indicating the sets of
     * instances that are applied with this rule.
     * 
     */
    private @Nullable List<String> targetServiceAccounts;
    /**
     * @return (Output)
     * Boolean flag indicating if the traffic should be TLS decrypted.
     * It can be set only if action = &#39;apply_security_profile_group&#39; and cannot be set for other actions.
     * 
     */
    private @Nullable Boolean tlsInspect;

    private NetworkFirewallPolicyWithRulesPredefinedRule() {}
    /**
     * @return (Output)
     * The Action to perform when the client connection triggers the rule. Can currently be either
     * &#34;allow&#34;, &#34;deny&#34;, &#34;apply_security_profile_group&#34; or &#34;goto_next&#34;.
     * 
     */
    public Optional<String> action() {
        return Optional.ofNullable(this.action);
    }
    /**
     * @return An optional description of this resource.
     * 
     */
    public Optional<String> description() {
        return Optional.ofNullable(this.description);
    }
    /**
     * @return (Output)
     * The direction in which this rule applies. If unspecified an INGRESS rule is created.
     * 
     */
    public Optional<String> direction() {
        return Optional.ofNullable(this.direction);
    }
    /**
     * @return (Output)
     * Denotes whether the firewall policy rule is disabled. When set to true,
     * the firewall policy rule is not enforced and traffic behaves as if it did
     * not exist. If this is unspecified, the firewall policy rule will be
     * enabled.
     * 
     */
    public Optional<Boolean> disabled() {
        return Optional.ofNullable(this.disabled);
    }
    /**
     * @return (Output)
     * Denotes whether to enable logging for a particular rule.
     * If logging is enabled, logs will be exported to the
     * configured export destination in Stackdriver.
     * 
     */
    public Optional<Boolean> enableLogging() {
        return Optional.ofNullable(this.enableLogging);
    }
    /**
     * @return (Output)
     * A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding &#39;action&#39; is enforced.
     * Structure is documented below.
     * 
     */
    public List<NetworkFirewallPolicyWithRulesPredefinedRuleMatch> matches() {
        return this.matches == null ? List.of() : this.matches;
    }
    /**
     * @return (Output)
     * An integer indicating the priority of a rule in the list. The priority must be a value
     * between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
     * highest priority and 2147483647 is the lowest priority.
     * 
     */
    public Optional<Integer> priority() {
        return Optional.ofNullable(this.priority);
    }
    /**
     * @return (Output)
     * An optional name for the rule. This field is not a unique identifier
     * and can be updated.
     * 
     */
    public Optional<String> ruleName() {
        return Optional.ofNullable(this.ruleName);
    }
    /**
     * @return (Output)
     * A fully-qualified URL of a SecurityProfile resource instance.
     * Example:
     * https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
     * Must be specified if action is &#39;apply_security_profile_group&#39;.
     * 
     */
    public Optional<String> securityProfileGroup() {
        return Optional.ofNullable(this.securityProfileGroup);
    }
    /**
     * @return (Output)
     * A list of secure tags that controls which instances the firewall rule
     * applies to. If &lt;code&gt;targetSecureTag&lt;/code&gt; are specified, then the
     * firewall rule applies only to instances in the VPC network that have one
     * of those EFFECTIVE secure tags, if all the target_secure_tag are in
     * INEFFECTIVE state, then this rule will be ignored.
     * &lt;code&gt;targetSecureTag&lt;/code&gt; may not be set at the same time as
     * &lt;code&gt;targetServiceAccounts&lt;/code&gt;.
     * If neither &lt;code&gt;targetServiceAccounts&lt;/code&gt; nor
     * &lt;code&gt;targetSecureTag&lt;/code&gt; are specified, the firewall rule applies
     * to all instances on the specified network.
     * Maximum number of target label tags allowed is 256.
     * Structure is documented below.
     * 
     */
    public List<NetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag> targetSecureTags() {
        return this.targetSecureTags == null ? List.of() : this.targetSecureTags;
    }
    /**
     * @return (Output)
     * A list of service accounts indicating the sets of
     * instances that are applied with this rule.
     * 
     */
    public List<String> targetServiceAccounts() {
        return this.targetServiceAccounts == null ? List.of() : this.targetServiceAccounts;
    }
    /**
     * @return (Output)
     * Boolean flag indicating if the traffic should be TLS decrypted.
     * It can be set only if action = &#39;apply_security_profile_group&#39; and cannot be set for other actions.
     * 
     */
    public Optional<Boolean> tlsInspect() {
        return Optional.ofNullable(this.tlsInspect);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(NetworkFirewallPolicyWithRulesPredefinedRule defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable String action;
        private @Nullable String description;
        private @Nullable String direction;
        private @Nullable Boolean disabled;
        private @Nullable Boolean enableLogging;
        private @Nullable List<NetworkFirewallPolicyWithRulesPredefinedRuleMatch> matches;
        private @Nullable Integer priority;
        private @Nullable String ruleName;
        private @Nullable String securityProfileGroup;
        private @Nullable List<NetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag> targetSecureTags;
        private @Nullable List<String> targetServiceAccounts;
        private @Nullable Boolean tlsInspect;
        public Builder() {}
        public Builder(NetworkFirewallPolicyWithRulesPredefinedRule defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.action = defaults.action;
    	      this.description = defaults.description;
    	      this.direction = defaults.direction;
    	      this.disabled = defaults.disabled;
    	      this.enableLogging = defaults.enableLogging;
    	      this.matches = defaults.matches;
    	      this.priority = defaults.priority;
    	      this.ruleName = defaults.ruleName;
    	      this.securityProfileGroup = defaults.securityProfileGroup;
    	      this.targetSecureTags = defaults.targetSecureTags;
    	      this.targetServiceAccounts = defaults.targetServiceAccounts;
    	      this.tlsInspect = defaults.tlsInspect;
        }

        @CustomType.Setter
        public Builder action(@Nullable String action) {

            this.action = action;
            return this;
        }
        @CustomType.Setter
        public Builder description(@Nullable String description) {

            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder direction(@Nullable String direction) {

            this.direction = direction;
            return this;
        }
        @CustomType.Setter
        public Builder disabled(@Nullable Boolean disabled) {

            this.disabled = disabled;
            return this;
        }
        @CustomType.Setter
        public Builder enableLogging(@Nullable Boolean enableLogging) {

            this.enableLogging = enableLogging;
            return this;
        }
        @CustomType.Setter
        public Builder matches(@Nullable List<NetworkFirewallPolicyWithRulesPredefinedRuleMatch> matches) {

            this.matches = matches;
            return this;
        }
        public Builder matches(NetworkFirewallPolicyWithRulesPredefinedRuleMatch... matches) {
            return matches(List.of(matches));
        }
        @CustomType.Setter
        public Builder priority(@Nullable Integer priority) {

            this.priority = priority;
            return this;
        }
        @CustomType.Setter
        public Builder ruleName(@Nullable String ruleName) {

            this.ruleName = ruleName;
            return this;
        }
        @CustomType.Setter
        public Builder securityProfileGroup(@Nullable String securityProfileGroup) {

            this.securityProfileGroup = securityProfileGroup;
            return this;
        }
        @CustomType.Setter
        public Builder targetSecureTags(@Nullable List<NetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag> targetSecureTags) {

            this.targetSecureTags = targetSecureTags;
            return this;
        }
        public Builder targetSecureTags(NetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag... targetSecureTags) {
            return targetSecureTags(List.of(targetSecureTags));
        }
        @CustomType.Setter
        public Builder targetServiceAccounts(@Nullable List<String> targetServiceAccounts) {

            this.targetServiceAccounts = targetServiceAccounts;
            return this;
        }
        public Builder targetServiceAccounts(String... targetServiceAccounts) {
            return targetServiceAccounts(List.of(targetServiceAccounts));
        }
        @CustomType.Setter
        public Builder tlsInspect(@Nullable Boolean tlsInspect) {

            this.tlsInspect = tlsInspect;
            return this;
        }
        public NetworkFirewallPolicyWithRulesPredefinedRule build() {
            final var _resultValue = new NetworkFirewallPolicyWithRulesPredefinedRule();
            _resultValue.action = action;
            _resultValue.description = description;
            _resultValue.direction = direction;
            _resultValue.disabled = disabled;
            _resultValue.enableLogging = enableLogging;
            _resultValue.matches = matches;
            _resultValue.priority = priority;
            _resultValue.ruleName = ruleName;
            _resultValue.securityProfileGroup = securityProfileGroup;
            _resultValue.targetSecureTags = targetSecureTags;
            _resultValue.targetServiceAccounts = targetServiceAccounts;
            _resultValue.tlsInspect = tlsInspect;
            return _resultValue;
        }
    }
}
