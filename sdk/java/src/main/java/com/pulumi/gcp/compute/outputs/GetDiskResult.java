// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.gcp.compute.outputs.GetDiskAsyncPrimaryDisk;
import com.pulumi.gcp.compute.outputs.GetDiskDiskEncryptionKey;
import com.pulumi.gcp.compute.outputs.GetDiskGuestOsFeature;
import com.pulumi.gcp.compute.outputs.GetDiskSourceImageEncryptionKey;
import com.pulumi.gcp.compute.outputs.GetDiskSourceSnapshotEncryptionKey;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetDiskResult {
    private List<GetDiskAsyncPrimaryDisk> asyncPrimaryDisks;
    /**
     * @return Creation timestamp in RFC3339 text format.
     * 
     */
    private String creationTimestamp;
    /**
     * @return The optional description of this resource.
     * 
     */
    private String description;
    private List<GetDiskDiskEncryptionKey> diskEncryptionKeys;
    private List<GetDiskGuestOsFeature> guestOsFeatures;
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    private String id;
    /**
     * @return The image from which to initialize this disk.
     * 
     */
    private String image;
    private String interface_;
    /**
     * @return The fingerprint used for optimistic locking of this resource.  Used
     * internally during updates.
     * 
     */
    private String labelFingerprint;
    /**
     * @return A map of labels applied to this disk.
     * 
     */
    private Map<String,String> labels;
    /**
     * @return Last attach timestamp in RFC3339 text format.
     * 
     */
    private String lastAttachTimestamp;
    /**
     * @return Last detach timestamp in RFC3339 text format.
     * 
     */
    private String lastDetachTimestamp;
    private List<String> licenses;
    private Boolean multiWriter;
    private String name;
    /**
     * @return Physical block size of the persistent disk, in bytes.
     * 
     */
    private Integer physicalBlockSizeBytes;
    private @Nullable String project;
    private Integer provisionedIops;
    private Integer provisionedThroughput;
    private List<String> resourcePolicies;
    /**
     * @return The URI of the created resource.
     * 
     */
    private String selfLink;
    /**
     * @return Size of the persistent disk, specified in GB.
     * 
     */
    private Integer size;
    /**
     * @return The source snapshot used to create this disk.
     * 
     */
    private String snapshot;
    private String sourceDisk;
    private String sourceDiskId;
    /**
     * @return The customer-supplied encryption key of the source image.
     * 
     */
    private List<GetDiskSourceImageEncryptionKey> sourceImageEncryptionKeys;
    /**
     * @return The ID value of the image used to create this disk. This value
     * identifies the exact image that was used to create this persistent
     * disk. For example, if you created the persistent disk from an image
     * that was later deleted and recreated under the same name, the source
     * image ID would identify the exact version of the image that was used.
     * 
     */
    private String sourceImageId;
    /**
     * @return The customer-supplied encryption key of the source snapshot.
     * 
     */
    private List<GetDiskSourceSnapshotEncryptionKey> sourceSnapshotEncryptionKeys;
    /**
     * @return The unique ID of the snapshot used to create this disk. This value
     * identifies the exact snapshot that was used to create this persistent
     * disk. For example, if you created the persistent disk from a snapshot
     * that was later deleted and recreated under the same name, the source
     * snapshot ID would identify the exact version of the snapshot that was
     * used.
     * 
     */
    private String sourceSnapshotId;
    /**
     * @return URL of the disk type resource describing which disk type to use to
     * create the disk.
     * 
     */
    private String type;
    /**
     * @return Links to the users of the disk (attached instances) in form:
     * project/zones/zone/instances/instance
     * 
     */
    private List<String> users;
    /**
     * @return A reference to the zone where the disk resides.
     * 
     */
    private @Nullable String zone;

    private GetDiskResult() {}
    public List<GetDiskAsyncPrimaryDisk> asyncPrimaryDisks() {
        return this.asyncPrimaryDisks;
    }
    /**
     * @return Creation timestamp in RFC3339 text format.
     * 
     */
    public String creationTimestamp() {
        return this.creationTimestamp;
    }
    /**
     * @return The optional description of this resource.
     * 
     */
    public String description() {
        return this.description;
    }
    public List<GetDiskDiskEncryptionKey> diskEncryptionKeys() {
        return this.diskEncryptionKeys;
    }
    public List<GetDiskGuestOsFeature> guestOsFeatures() {
        return this.guestOsFeatures;
    }
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return The image from which to initialize this disk.
     * 
     */
    public String image() {
        return this.image;
    }
    public String interface_() {
        return this.interface_;
    }
    /**
     * @return The fingerprint used for optimistic locking of this resource.  Used
     * internally during updates.
     * 
     */
    public String labelFingerprint() {
        return this.labelFingerprint;
    }
    /**
     * @return A map of labels applied to this disk.
     * 
     */
    public Map<String,String> labels() {
        return this.labels;
    }
    /**
     * @return Last attach timestamp in RFC3339 text format.
     * 
     */
    public String lastAttachTimestamp() {
        return this.lastAttachTimestamp;
    }
    /**
     * @return Last detach timestamp in RFC3339 text format.
     * 
     */
    public String lastDetachTimestamp() {
        return this.lastDetachTimestamp;
    }
    public List<String> licenses() {
        return this.licenses;
    }
    public Boolean multiWriter() {
        return this.multiWriter;
    }
    public String name() {
        return this.name;
    }
    /**
     * @return Physical block size of the persistent disk, in bytes.
     * 
     */
    public Integer physicalBlockSizeBytes() {
        return this.physicalBlockSizeBytes;
    }
    public Optional<String> project() {
        return Optional.ofNullable(this.project);
    }
    public Integer provisionedIops() {
        return this.provisionedIops;
    }
    public Integer provisionedThroughput() {
        return this.provisionedThroughput;
    }
    public List<String> resourcePolicies() {
        return this.resourcePolicies;
    }
    /**
     * @return The URI of the created resource.
     * 
     */
    public String selfLink() {
        return this.selfLink;
    }
    /**
     * @return Size of the persistent disk, specified in GB.
     * 
     */
    public Integer size() {
        return this.size;
    }
    /**
     * @return The source snapshot used to create this disk.
     * 
     */
    public String snapshot() {
        return this.snapshot;
    }
    public String sourceDisk() {
        return this.sourceDisk;
    }
    public String sourceDiskId() {
        return this.sourceDiskId;
    }
    /**
     * @return The customer-supplied encryption key of the source image.
     * 
     */
    public List<GetDiskSourceImageEncryptionKey> sourceImageEncryptionKeys() {
        return this.sourceImageEncryptionKeys;
    }
    /**
     * @return The ID value of the image used to create this disk. This value
     * identifies the exact image that was used to create this persistent
     * disk. For example, if you created the persistent disk from an image
     * that was later deleted and recreated under the same name, the source
     * image ID would identify the exact version of the image that was used.
     * 
     */
    public String sourceImageId() {
        return this.sourceImageId;
    }
    /**
     * @return The customer-supplied encryption key of the source snapshot.
     * 
     */
    public List<GetDiskSourceSnapshotEncryptionKey> sourceSnapshotEncryptionKeys() {
        return this.sourceSnapshotEncryptionKeys;
    }
    /**
     * @return The unique ID of the snapshot used to create this disk. This value
     * identifies the exact snapshot that was used to create this persistent
     * disk. For example, if you created the persistent disk from a snapshot
     * that was later deleted and recreated under the same name, the source
     * snapshot ID would identify the exact version of the snapshot that was
     * used.
     * 
     */
    public String sourceSnapshotId() {
        return this.sourceSnapshotId;
    }
    /**
     * @return URL of the disk type resource describing which disk type to use to
     * create the disk.
     * 
     */
    public String type() {
        return this.type;
    }
    /**
     * @return Links to the users of the disk (attached instances) in form:
     * project/zones/zone/instances/instance
     * 
     */
    public List<String> users() {
        return this.users;
    }
    /**
     * @return A reference to the zone where the disk resides.
     * 
     */
    public Optional<String> zone() {
        return Optional.ofNullable(this.zone);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetDiskResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private List<GetDiskAsyncPrimaryDisk> asyncPrimaryDisks;
        private String creationTimestamp;
        private String description;
        private List<GetDiskDiskEncryptionKey> diskEncryptionKeys;
        private List<GetDiskGuestOsFeature> guestOsFeatures;
        private String id;
        private String image;
        private String interface_;
        private String labelFingerprint;
        private Map<String,String> labels;
        private String lastAttachTimestamp;
        private String lastDetachTimestamp;
        private List<String> licenses;
        private Boolean multiWriter;
        private String name;
        private Integer physicalBlockSizeBytes;
        private @Nullable String project;
        private Integer provisionedIops;
        private Integer provisionedThroughput;
        private List<String> resourcePolicies;
        private String selfLink;
        private Integer size;
        private String snapshot;
        private String sourceDisk;
        private String sourceDiskId;
        private List<GetDiskSourceImageEncryptionKey> sourceImageEncryptionKeys;
        private String sourceImageId;
        private List<GetDiskSourceSnapshotEncryptionKey> sourceSnapshotEncryptionKeys;
        private String sourceSnapshotId;
        private String type;
        private List<String> users;
        private @Nullable String zone;
        public Builder() {}
        public Builder(GetDiskResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.asyncPrimaryDisks = defaults.asyncPrimaryDisks;
    	      this.creationTimestamp = defaults.creationTimestamp;
    	      this.description = defaults.description;
    	      this.diskEncryptionKeys = defaults.diskEncryptionKeys;
    	      this.guestOsFeatures = defaults.guestOsFeatures;
    	      this.id = defaults.id;
    	      this.image = defaults.image;
    	      this.interface_ = defaults.interface_;
    	      this.labelFingerprint = defaults.labelFingerprint;
    	      this.labels = defaults.labels;
    	      this.lastAttachTimestamp = defaults.lastAttachTimestamp;
    	      this.lastDetachTimestamp = defaults.lastDetachTimestamp;
    	      this.licenses = defaults.licenses;
    	      this.multiWriter = defaults.multiWriter;
    	      this.name = defaults.name;
    	      this.physicalBlockSizeBytes = defaults.physicalBlockSizeBytes;
    	      this.project = defaults.project;
    	      this.provisionedIops = defaults.provisionedIops;
    	      this.provisionedThroughput = defaults.provisionedThroughput;
    	      this.resourcePolicies = defaults.resourcePolicies;
    	      this.selfLink = defaults.selfLink;
    	      this.size = defaults.size;
    	      this.snapshot = defaults.snapshot;
    	      this.sourceDisk = defaults.sourceDisk;
    	      this.sourceDiskId = defaults.sourceDiskId;
    	      this.sourceImageEncryptionKeys = defaults.sourceImageEncryptionKeys;
    	      this.sourceImageId = defaults.sourceImageId;
    	      this.sourceSnapshotEncryptionKeys = defaults.sourceSnapshotEncryptionKeys;
    	      this.sourceSnapshotId = defaults.sourceSnapshotId;
    	      this.type = defaults.type;
    	      this.users = defaults.users;
    	      this.zone = defaults.zone;
        }

        @CustomType.Setter
        public Builder asyncPrimaryDisks(List<GetDiskAsyncPrimaryDisk> asyncPrimaryDisks) {
            this.asyncPrimaryDisks = Objects.requireNonNull(asyncPrimaryDisks);
            return this;
        }
        public Builder asyncPrimaryDisks(GetDiskAsyncPrimaryDisk... asyncPrimaryDisks) {
            return asyncPrimaryDisks(List.of(asyncPrimaryDisks));
        }
        @CustomType.Setter
        public Builder creationTimestamp(String creationTimestamp) {
            this.creationTimestamp = Objects.requireNonNull(creationTimestamp);
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            this.description = Objects.requireNonNull(description);
            return this;
        }
        @CustomType.Setter
        public Builder diskEncryptionKeys(List<GetDiskDiskEncryptionKey> diskEncryptionKeys) {
            this.diskEncryptionKeys = Objects.requireNonNull(diskEncryptionKeys);
            return this;
        }
        public Builder diskEncryptionKeys(GetDiskDiskEncryptionKey... diskEncryptionKeys) {
            return diskEncryptionKeys(List.of(diskEncryptionKeys));
        }
        @CustomType.Setter
        public Builder guestOsFeatures(List<GetDiskGuestOsFeature> guestOsFeatures) {
            this.guestOsFeatures = Objects.requireNonNull(guestOsFeatures);
            return this;
        }
        public Builder guestOsFeatures(GetDiskGuestOsFeature... guestOsFeatures) {
            return guestOsFeatures(List.of(guestOsFeatures));
        }
        @CustomType.Setter
        public Builder id(String id) {
            this.id = Objects.requireNonNull(id);
            return this;
        }
        @CustomType.Setter
        public Builder image(String image) {
            this.image = Objects.requireNonNull(image);
            return this;
        }
        @CustomType.Setter("interface")
        public Builder interface_(String interface_) {
            this.interface_ = Objects.requireNonNull(interface_);
            return this;
        }
        @CustomType.Setter
        public Builder labelFingerprint(String labelFingerprint) {
            this.labelFingerprint = Objects.requireNonNull(labelFingerprint);
            return this;
        }
        @CustomType.Setter
        public Builder labels(Map<String,String> labels) {
            this.labels = Objects.requireNonNull(labels);
            return this;
        }
        @CustomType.Setter
        public Builder lastAttachTimestamp(String lastAttachTimestamp) {
            this.lastAttachTimestamp = Objects.requireNonNull(lastAttachTimestamp);
            return this;
        }
        @CustomType.Setter
        public Builder lastDetachTimestamp(String lastDetachTimestamp) {
            this.lastDetachTimestamp = Objects.requireNonNull(lastDetachTimestamp);
            return this;
        }
        @CustomType.Setter
        public Builder licenses(List<String> licenses) {
            this.licenses = Objects.requireNonNull(licenses);
            return this;
        }
        public Builder licenses(String... licenses) {
            return licenses(List.of(licenses));
        }
        @CustomType.Setter
        public Builder multiWriter(Boolean multiWriter) {
            this.multiWriter = Objects.requireNonNull(multiWriter);
            return this;
        }
        @CustomType.Setter
        public Builder name(String name) {
            this.name = Objects.requireNonNull(name);
            return this;
        }
        @CustomType.Setter
        public Builder physicalBlockSizeBytes(Integer physicalBlockSizeBytes) {
            this.physicalBlockSizeBytes = Objects.requireNonNull(physicalBlockSizeBytes);
            return this;
        }
        @CustomType.Setter
        public Builder project(@Nullable String project) {
            this.project = project;
            return this;
        }
        @CustomType.Setter
        public Builder provisionedIops(Integer provisionedIops) {
            this.provisionedIops = Objects.requireNonNull(provisionedIops);
            return this;
        }
        @CustomType.Setter
        public Builder provisionedThroughput(Integer provisionedThroughput) {
            this.provisionedThroughput = Objects.requireNonNull(provisionedThroughput);
            return this;
        }
        @CustomType.Setter
        public Builder resourcePolicies(List<String> resourcePolicies) {
            this.resourcePolicies = Objects.requireNonNull(resourcePolicies);
            return this;
        }
        public Builder resourcePolicies(String... resourcePolicies) {
            return resourcePolicies(List.of(resourcePolicies));
        }
        @CustomType.Setter
        public Builder selfLink(String selfLink) {
            this.selfLink = Objects.requireNonNull(selfLink);
            return this;
        }
        @CustomType.Setter
        public Builder size(Integer size) {
            this.size = Objects.requireNonNull(size);
            return this;
        }
        @CustomType.Setter
        public Builder snapshot(String snapshot) {
            this.snapshot = Objects.requireNonNull(snapshot);
            return this;
        }
        @CustomType.Setter
        public Builder sourceDisk(String sourceDisk) {
            this.sourceDisk = Objects.requireNonNull(sourceDisk);
            return this;
        }
        @CustomType.Setter
        public Builder sourceDiskId(String sourceDiskId) {
            this.sourceDiskId = Objects.requireNonNull(sourceDiskId);
            return this;
        }
        @CustomType.Setter
        public Builder sourceImageEncryptionKeys(List<GetDiskSourceImageEncryptionKey> sourceImageEncryptionKeys) {
            this.sourceImageEncryptionKeys = Objects.requireNonNull(sourceImageEncryptionKeys);
            return this;
        }
        public Builder sourceImageEncryptionKeys(GetDiskSourceImageEncryptionKey... sourceImageEncryptionKeys) {
            return sourceImageEncryptionKeys(List.of(sourceImageEncryptionKeys));
        }
        @CustomType.Setter
        public Builder sourceImageId(String sourceImageId) {
            this.sourceImageId = Objects.requireNonNull(sourceImageId);
            return this;
        }
        @CustomType.Setter
        public Builder sourceSnapshotEncryptionKeys(List<GetDiskSourceSnapshotEncryptionKey> sourceSnapshotEncryptionKeys) {
            this.sourceSnapshotEncryptionKeys = Objects.requireNonNull(sourceSnapshotEncryptionKeys);
            return this;
        }
        public Builder sourceSnapshotEncryptionKeys(GetDiskSourceSnapshotEncryptionKey... sourceSnapshotEncryptionKeys) {
            return sourceSnapshotEncryptionKeys(List.of(sourceSnapshotEncryptionKeys));
        }
        @CustomType.Setter
        public Builder sourceSnapshotId(String sourceSnapshotId) {
            this.sourceSnapshotId = Objects.requireNonNull(sourceSnapshotId);
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            this.type = Objects.requireNonNull(type);
            return this;
        }
        @CustomType.Setter
        public Builder users(List<String> users) {
            this.users = Objects.requireNonNull(users);
            return this;
        }
        public Builder users(String... users) {
            return users(List.of(users));
        }
        @CustomType.Setter
        public Builder zone(@Nullable String zone) {
            this.zone = zone;
            return this;
        }
        public GetDiskResult build() {
            final var o = new GetDiskResult();
            o.asyncPrimaryDisks = asyncPrimaryDisks;
            o.creationTimestamp = creationTimestamp;
            o.description = description;
            o.diskEncryptionKeys = diskEncryptionKeys;
            o.guestOsFeatures = guestOsFeatures;
            o.id = id;
            o.image = image;
            o.interface_ = interface_;
            o.labelFingerprint = labelFingerprint;
            o.labels = labels;
            o.lastAttachTimestamp = lastAttachTimestamp;
            o.lastDetachTimestamp = lastDetachTimestamp;
            o.licenses = licenses;
            o.multiWriter = multiWriter;
            o.name = name;
            o.physicalBlockSizeBytes = physicalBlockSizeBytes;
            o.project = project;
            o.provisionedIops = provisionedIops;
            o.provisionedThroughput = provisionedThroughput;
            o.resourcePolicies = resourcePolicies;
            o.selfLink = selfLink;
            o.size = size;
            o.snapshot = snapshot;
            o.sourceDisk = sourceDisk;
            o.sourceDiskId = sourceDiskId;
            o.sourceImageEncryptionKeys = sourceImageEncryptionKeys;
            o.sourceImageId = sourceImageId;
            o.sourceSnapshotEncryptionKeys = sourceSnapshotEncryptionKeys;
            o.sourceSnapshotId = sourceSnapshotId;
            o.type = type;
            o.users = users;
            o.zone = zone;
            return o;
        }
    }
}
