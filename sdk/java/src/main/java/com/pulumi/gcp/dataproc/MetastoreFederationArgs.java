// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.dataproc;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.dataproc.inputs.MetastoreFederationBackendMetastoreArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class MetastoreFederationArgs extends com.pulumi.resources.ResourceArgs {

    public static final MetastoreFederationArgs Empty = new MetastoreFederationArgs();

    /**
     * A map from BackendMetastore rank to BackendMetastores from which the federation service serves metadata at query time. The map key represents the order in which BackendMetastores should be evaluated to resolve database names at query time and should be greater than or equal to zero. A BackendMetastore with a lower number will be evaluated before a BackendMetastore with a higher number.
     * Structure is documented below.
     * 
     */
    @Import(name="backendMetastores", required=true)
    private Output<List<MetastoreFederationBackendMetastoreArgs>> backendMetastores;

    /**
     * @return A map from BackendMetastore rank to BackendMetastores from which the federation service serves metadata at query time. The map key represents the order in which BackendMetastores should be evaluated to resolve database names at query time and should be greater than or equal to zero. A BackendMetastore with a lower number will be evaluated before a BackendMetastore with a higher number.
     * Structure is documented below.
     * 
     */
    public Output<List<MetastoreFederationBackendMetastoreArgs>> backendMetastores() {
        return this.backendMetastores;
    }

    @Import(name="deletionProtection")
    private @Nullable Output<Boolean> deletionProtection;

    public Optional<Output<Boolean>> deletionProtection() {
        return Optional.ofNullable(this.deletionProtection);
    }

    /**
     * The ID of the metastore federation. The id must contain only letters (a-z, A-Z), numbers (0-9), underscores (_),
     * and hyphens (-). Cannot begin or end with underscore or hyphen. Must consist of between
     * 3 and 63 characters.
     * 
     */
    @Import(name="federationId", required=true)
    private Output<String> federationId;

    /**
     * @return The ID of the metastore federation. The id must contain only letters (a-z, A-Z), numbers (0-9), underscores (_),
     * and hyphens (-). Cannot begin or end with underscore or hyphen. Must consist of between
     * 3 and 63 characters.
     * 
     */
    public Output<String> federationId() {
        return this.federationId;
    }

    /**
     * User-defined labels for the metastore federation. **Note**: This field is non-authoritative, and will only manage the
     * labels present in your configuration. Please refer to the field &#39;effective_labels&#39; for all of the labels present on the
     * resource.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    /**
     * @return User-defined labels for the metastore federation. **Note**: This field is non-authoritative, and will only manage the
     * labels present in your configuration. Please refer to the field &#39;effective_labels&#39; for all of the labels present on the
     * resource.
     * 
     */
    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * The location where the metastore federation should reside.
     * 
     */
    @Import(name="location")
    private @Nullable Output<String> location;

    /**
     * @return The location where the metastore federation should reside.
     * 
     */
    public Optional<Output<String>> location() {
        return Optional.ofNullable(this.location);
    }

    @Import(name="project")
    private @Nullable Output<String> project;

    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * The Apache Hive metastore version of the federation. All backend metastore versions must be compatible with the federation version.
     * 
     */
    @Import(name="version", required=true)
    private Output<String> version;

    /**
     * @return The Apache Hive metastore version of the federation. All backend metastore versions must be compatible with the federation version.
     * 
     */
    public Output<String> version() {
        return this.version;
    }

    private MetastoreFederationArgs() {}

    private MetastoreFederationArgs(MetastoreFederationArgs $) {
        this.backendMetastores = $.backendMetastores;
        this.deletionProtection = $.deletionProtection;
        this.federationId = $.federationId;
        this.labels = $.labels;
        this.location = $.location;
        this.project = $.project;
        this.version = $.version;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(MetastoreFederationArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private MetastoreFederationArgs $;

        public Builder() {
            $ = new MetastoreFederationArgs();
        }

        public Builder(MetastoreFederationArgs defaults) {
            $ = new MetastoreFederationArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param backendMetastores A map from BackendMetastore rank to BackendMetastores from which the federation service serves metadata at query time. The map key represents the order in which BackendMetastores should be evaluated to resolve database names at query time and should be greater than or equal to zero. A BackendMetastore with a lower number will be evaluated before a BackendMetastore with a higher number.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder backendMetastores(Output<List<MetastoreFederationBackendMetastoreArgs>> backendMetastores) {
            $.backendMetastores = backendMetastores;
            return this;
        }

        /**
         * @param backendMetastores A map from BackendMetastore rank to BackendMetastores from which the federation service serves metadata at query time. The map key represents the order in which BackendMetastores should be evaluated to resolve database names at query time and should be greater than or equal to zero. A BackendMetastore with a lower number will be evaluated before a BackendMetastore with a higher number.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder backendMetastores(List<MetastoreFederationBackendMetastoreArgs> backendMetastores) {
            return backendMetastores(Output.of(backendMetastores));
        }

        /**
         * @param backendMetastores A map from BackendMetastore rank to BackendMetastores from which the federation service serves metadata at query time. The map key represents the order in which BackendMetastores should be evaluated to resolve database names at query time and should be greater than or equal to zero. A BackendMetastore with a lower number will be evaluated before a BackendMetastore with a higher number.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder backendMetastores(MetastoreFederationBackendMetastoreArgs... backendMetastores) {
            return backendMetastores(List.of(backendMetastores));
        }

        public Builder deletionProtection(@Nullable Output<Boolean> deletionProtection) {
            $.deletionProtection = deletionProtection;
            return this;
        }

        public Builder deletionProtection(Boolean deletionProtection) {
            return deletionProtection(Output.of(deletionProtection));
        }

        /**
         * @param federationId The ID of the metastore federation. The id must contain only letters (a-z, A-Z), numbers (0-9), underscores (_),
         * and hyphens (-). Cannot begin or end with underscore or hyphen. Must consist of between
         * 3 and 63 characters.
         * 
         * @return builder
         * 
         */
        public Builder federationId(Output<String> federationId) {
            $.federationId = federationId;
            return this;
        }

        /**
         * @param federationId The ID of the metastore federation. The id must contain only letters (a-z, A-Z), numbers (0-9), underscores (_),
         * and hyphens (-). Cannot begin or end with underscore or hyphen. Must consist of between
         * 3 and 63 characters.
         * 
         * @return builder
         * 
         */
        public Builder federationId(String federationId) {
            return federationId(Output.of(federationId));
        }

        /**
         * @param labels User-defined labels for the metastore federation. **Note**: This field is non-authoritative, and will only manage the
         * labels present in your configuration. Please refer to the field &#39;effective_labels&#39; for all of the labels present on the
         * resource.
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels User-defined labels for the metastore federation. **Note**: This field is non-authoritative, and will only manage the
         * labels present in your configuration. Please refer to the field &#39;effective_labels&#39; for all of the labels present on the
         * resource.
         * 
         * @return builder
         * 
         */
        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        /**
         * @param location The location where the metastore federation should reside.
         * 
         * @return builder
         * 
         */
        public Builder location(@Nullable Output<String> location) {
            $.location = location;
            return this;
        }

        /**
         * @param location The location where the metastore federation should reside.
         * 
         * @return builder
         * 
         */
        public Builder location(String location) {
            return location(Output.of(location));
        }

        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param version The Apache Hive metastore version of the federation. All backend metastore versions must be compatible with the federation version.
         * 
         * @return builder
         * 
         */
        public Builder version(Output<String> version) {
            $.version = version;
            return this;
        }

        /**
         * @param version The Apache Hive metastore version of the federation. All backend metastore versions must be compatible with the federation version.
         * 
         * @return builder
         * 
         */
        public Builder version(String version) {
            return version(Output.of(version));
        }

        public MetastoreFederationArgs build() {
            if ($.backendMetastores == null) {
                throw new MissingRequiredPropertyException("MetastoreFederationArgs", "backendMetastores");
            }
            if ($.federationId == null) {
                throw new MissingRequiredPropertyException("MetastoreFederationArgs", "federationId");
            }
            if ($.version == null) {
                throw new MissingRequiredPropertyException("MetastoreFederationArgs", "version");
            }
            return $;
        }
    }

}
