// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.compute.outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKey;
import com.pulumi.gcp.compute.outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabel;
import com.pulumi.gcp.compute.outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTag;
import com.pulumi.gcp.compute.outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKey;
import com.pulumi.gcp.compute.outputs.GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKey;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk {
    /**
     * @return The architecture of the image. Allowed values are ARM64 or X86_64.
     * 
     */
    private String architecture;
    /**
     * @return Whether or not the disk should be auto-deleted. This defaults to true.
     * 
     */
    private Boolean autoDelete;
    /**
     * @return Indicates that this is a boot disk. This defaults to false.
     * 
     */
    private Boolean boot;
    /**
     * @return A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance. If not specified, the server chooses a default device name to apply to this disk.
     * 
     */
    private String deviceName;
    /**
     * @return Encrypts or decrypts a disk using a customer-supplied encryption key.
     * 
     */
    private List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKey> diskEncryptionKeys;
    /**
     * @return Name of the disk. When not provided, this defaults to the name of the instance.
     * 
     */
    private String diskName;
    /**
     * @return The size of the image in gigabytes. If not specified, it will inherit the size of its base image. For SCRATCH disks, the size must be one of 375 or 3000 GB, with a default of 375 GB.
     * 
     */
    private Integer diskSizeGb;
    /**
     * @return The Google Compute Engine disk type. Such as &#34;pd-ssd&#34;, &#34;local-ssd&#34;, &#34;pd-balanced&#34; or &#34;pd-standard&#34;.
     * 
     */
    private String diskType;
    /**
     * @return A list of features to enable on the guest operating system. Applicable only for bootable images.
     * 
     */
    private List<String> guestOsFeatures;
    /**
     * @return Specifies the disk interface to use for attaching this disk.
     * 
     */
    private String interface_;
    /**
     * @return A set of key/value label pairs to assign to disks.
     * 
     */
    private List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabel> labels;
    /**
     * @return The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If you are attaching or creating a boot disk, this must read-write mode.
     * 
     */
    private String mode;
    /**
     * @return Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle. For more details, see the [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk) or the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks) depending on the selected disk_type.
     * 
     */
    private Integer provisionedIops;
    /**
     * @return Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
     * 
     */
    private Integer provisionedThroughput;
    /**
     * @return A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT &amp; PATCH) when empty.
     * 
     */
    private List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTag> resourceManagerTags;
    /**
     * @return A list (short name or id) of resource policies to attach to this disk. Currently a max of 1 resource policy is supported.
     * 
     */
    private List<String> resourcePolicies;
    /**
     * @return The name (not self_link) of the disk (such as those managed by google_compute_disk) to attach. &gt; Note: Either source or sourceImage is required when creating a new instance except for when creating a local SSD.
     * 
     */
    private String source;
    /**
     * @return The image from which to initialize this disk. This can be one of: the image&#39;s self_link, projects/{project}/global/images/{image}, projects/{project}/global/images/family/{family}, global/images/{image}, global/images/family/{family}, family/{family}, {project}/{family}, {project}/{image}, {family}, or {image}. &gt; Note: Either source or sourceImage is required when creating a new instance except for when creating a local SSD.
     * 
     */
    private String sourceImage;
    /**
     * @return The customer-supplied encryption key of the source image. Required if the source image is protected by a customer-supplied encryption key. Instance templates do not store customer-supplied encryption keys, so you cannot create disks for instances in a managed instance group if the source images are encrypted with your own keys.
     * 
     */
    private List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKey> sourceImageEncryptionKeys;
    /**
     * @return The source snapshot to create this disk. When creating a new instance, one of initializeParams.sourceSnapshot, initializeParams.sourceImage, or disks.source is required except for local SSD.
     * 
     */
    private String sourceSnapshot;
    /**
     * @return The customer-supplied encryption key of the source snapshot.
     * 
     */
    private List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKey> sourceSnapshotEncryptionKeys;
    /**
     * @return The type of Google Compute Engine disk, can be either &#34;SCRATCH&#34; or &#34;PERSISTENT&#34;.
     * 
     */
    private String type;

    private GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk() {}
    /**
     * @return The architecture of the image. Allowed values are ARM64 or X86_64.
     * 
     */
    public String architecture() {
        return this.architecture;
    }
    /**
     * @return Whether or not the disk should be auto-deleted. This defaults to true.
     * 
     */
    public Boolean autoDelete() {
        return this.autoDelete;
    }
    /**
     * @return Indicates that this is a boot disk. This defaults to false.
     * 
     */
    public Boolean boot() {
        return this.boot;
    }
    /**
     * @return A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance. If not specified, the server chooses a default device name to apply to this disk.
     * 
     */
    public String deviceName() {
        return this.deviceName;
    }
    /**
     * @return Encrypts or decrypts a disk using a customer-supplied encryption key.
     * 
     */
    public List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKey> diskEncryptionKeys() {
        return this.diskEncryptionKeys;
    }
    /**
     * @return Name of the disk. When not provided, this defaults to the name of the instance.
     * 
     */
    public String diskName() {
        return this.diskName;
    }
    /**
     * @return The size of the image in gigabytes. If not specified, it will inherit the size of its base image. For SCRATCH disks, the size must be one of 375 or 3000 GB, with a default of 375 GB.
     * 
     */
    public Integer diskSizeGb() {
        return this.diskSizeGb;
    }
    /**
     * @return The Google Compute Engine disk type. Such as &#34;pd-ssd&#34;, &#34;local-ssd&#34;, &#34;pd-balanced&#34; or &#34;pd-standard&#34;.
     * 
     */
    public String diskType() {
        return this.diskType;
    }
    /**
     * @return A list of features to enable on the guest operating system. Applicable only for bootable images.
     * 
     */
    public List<String> guestOsFeatures() {
        return this.guestOsFeatures;
    }
    /**
     * @return Specifies the disk interface to use for attaching this disk.
     * 
     */
    public String interface_() {
        return this.interface_;
    }
    /**
     * @return A set of key/value label pairs to assign to disks.
     * 
     */
    public List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabel> labels() {
        return this.labels;
    }
    /**
     * @return The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If you are attaching or creating a boot disk, this must read-write mode.
     * 
     */
    public String mode() {
        return this.mode;
    }
    /**
     * @return Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle. For more details, see the [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk) or the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks) depending on the selected disk_type.
     * 
     */
    public Integer provisionedIops() {
        return this.provisionedIops;
    }
    /**
     * @return Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
     * 
     */
    public Integer provisionedThroughput() {
        return this.provisionedThroughput;
    }
    /**
     * @return A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT &amp; PATCH) when empty.
     * 
     */
    public List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTag> resourceManagerTags() {
        return this.resourceManagerTags;
    }
    /**
     * @return A list (short name or id) of resource policies to attach to this disk. Currently a max of 1 resource policy is supported.
     * 
     */
    public List<String> resourcePolicies() {
        return this.resourcePolicies;
    }
    /**
     * @return The name (not self_link) of the disk (such as those managed by google_compute_disk) to attach. &gt; Note: Either source or sourceImage is required when creating a new instance except for when creating a local SSD.
     * 
     */
    public String source() {
        return this.source;
    }
    /**
     * @return The image from which to initialize this disk. This can be one of: the image&#39;s self_link, projects/{project}/global/images/{image}, projects/{project}/global/images/family/{family}, global/images/{image}, global/images/family/{family}, family/{family}, {project}/{family}, {project}/{image}, {family}, or {image}. &gt; Note: Either source or sourceImage is required when creating a new instance except for when creating a local SSD.
     * 
     */
    public String sourceImage() {
        return this.sourceImage;
    }
    /**
     * @return The customer-supplied encryption key of the source image. Required if the source image is protected by a customer-supplied encryption key. Instance templates do not store customer-supplied encryption keys, so you cannot create disks for instances in a managed instance group if the source images are encrypted with your own keys.
     * 
     */
    public List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKey> sourceImageEncryptionKeys() {
        return this.sourceImageEncryptionKeys;
    }
    /**
     * @return The source snapshot to create this disk. When creating a new instance, one of initializeParams.sourceSnapshot, initializeParams.sourceImage, or disks.source is required except for local SSD.
     * 
     */
    public String sourceSnapshot() {
        return this.sourceSnapshot;
    }
    /**
     * @return The customer-supplied encryption key of the source snapshot.
     * 
     */
    public List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKey> sourceSnapshotEncryptionKeys() {
        return this.sourceSnapshotEncryptionKeys;
    }
    /**
     * @return The type of Google Compute Engine disk, can be either &#34;SCRATCH&#34; or &#34;PERSISTENT&#34;.
     * 
     */
    public String type() {
        return this.type;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String architecture;
        private Boolean autoDelete;
        private Boolean boot;
        private String deviceName;
        private List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKey> diskEncryptionKeys;
        private String diskName;
        private Integer diskSizeGb;
        private String diskType;
        private List<String> guestOsFeatures;
        private String interface_;
        private List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabel> labels;
        private String mode;
        private Integer provisionedIops;
        private Integer provisionedThroughput;
        private List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTag> resourceManagerTags;
        private List<String> resourcePolicies;
        private String source;
        private String sourceImage;
        private List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKey> sourceImageEncryptionKeys;
        private String sourceSnapshot;
        private List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKey> sourceSnapshotEncryptionKeys;
        private String type;
        public Builder() {}
        public Builder(GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.architecture = defaults.architecture;
    	      this.autoDelete = defaults.autoDelete;
    	      this.boot = defaults.boot;
    	      this.deviceName = defaults.deviceName;
    	      this.diskEncryptionKeys = defaults.diskEncryptionKeys;
    	      this.diskName = defaults.diskName;
    	      this.diskSizeGb = defaults.diskSizeGb;
    	      this.diskType = defaults.diskType;
    	      this.guestOsFeatures = defaults.guestOsFeatures;
    	      this.interface_ = defaults.interface_;
    	      this.labels = defaults.labels;
    	      this.mode = defaults.mode;
    	      this.provisionedIops = defaults.provisionedIops;
    	      this.provisionedThroughput = defaults.provisionedThroughput;
    	      this.resourceManagerTags = defaults.resourceManagerTags;
    	      this.resourcePolicies = defaults.resourcePolicies;
    	      this.source = defaults.source;
    	      this.sourceImage = defaults.sourceImage;
    	      this.sourceImageEncryptionKeys = defaults.sourceImageEncryptionKeys;
    	      this.sourceSnapshot = defaults.sourceSnapshot;
    	      this.sourceSnapshotEncryptionKeys = defaults.sourceSnapshotEncryptionKeys;
    	      this.type = defaults.type;
        }

        @CustomType.Setter
        public Builder architecture(String architecture) {
            if (architecture == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "architecture");
            }
            this.architecture = architecture;
            return this;
        }
        @CustomType.Setter
        public Builder autoDelete(Boolean autoDelete) {
            if (autoDelete == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "autoDelete");
            }
            this.autoDelete = autoDelete;
            return this;
        }
        @CustomType.Setter
        public Builder boot(Boolean boot) {
            if (boot == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "boot");
            }
            this.boot = boot;
            return this;
        }
        @CustomType.Setter
        public Builder deviceName(String deviceName) {
            if (deviceName == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "deviceName");
            }
            this.deviceName = deviceName;
            return this;
        }
        @CustomType.Setter
        public Builder diskEncryptionKeys(List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKey> diskEncryptionKeys) {
            if (diskEncryptionKeys == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "diskEncryptionKeys");
            }
            this.diskEncryptionKeys = diskEncryptionKeys;
            return this;
        }
        public Builder diskEncryptionKeys(GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskDiskEncryptionKey... diskEncryptionKeys) {
            return diskEncryptionKeys(List.of(diskEncryptionKeys));
        }
        @CustomType.Setter
        public Builder diskName(String diskName) {
            if (diskName == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "diskName");
            }
            this.diskName = diskName;
            return this;
        }
        @CustomType.Setter
        public Builder diskSizeGb(Integer diskSizeGb) {
            if (diskSizeGb == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "diskSizeGb");
            }
            this.diskSizeGb = diskSizeGb;
            return this;
        }
        @CustomType.Setter
        public Builder diskType(String diskType) {
            if (diskType == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "diskType");
            }
            this.diskType = diskType;
            return this;
        }
        @CustomType.Setter
        public Builder guestOsFeatures(List<String> guestOsFeatures) {
            if (guestOsFeatures == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "guestOsFeatures");
            }
            this.guestOsFeatures = guestOsFeatures;
            return this;
        }
        public Builder guestOsFeatures(String... guestOsFeatures) {
            return guestOsFeatures(List.of(guestOsFeatures));
        }
        @CustomType.Setter("interface")
        public Builder interface_(String interface_) {
            if (interface_ == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "interface_");
            }
            this.interface_ = interface_;
            return this;
        }
        @CustomType.Setter
        public Builder labels(List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabel> labels) {
            if (labels == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "labels");
            }
            this.labels = labels;
            return this;
        }
        public Builder labels(GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskLabel... labels) {
            return labels(List.of(labels));
        }
        @CustomType.Setter
        public Builder mode(String mode) {
            if (mode == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "mode");
            }
            this.mode = mode;
            return this;
        }
        @CustomType.Setter
        public Builder provisionedIops(Integer provisionedIops) {
            if (provisionedIops == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "provisionedIops");
            }
            this.provisionedIops = provisionedIops;
            return this;
        }
        @CustomType.Setter
        public Builder provisionedThroughput(Integer provisionedThroughput) {
            if (provisionedThroughput == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "provisionedThroughput");
            }
            this.provisionedThroughput = provisionedThroughput;
            return this;
        }
        @CustomType.Setter
        public Builder resourceManagerTags(List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTag> resourceManagerTags) {
            if (resourceManagerTags == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "resourceManagerTags");
            }
            this.resourceManagerTags = resourceManagerTags;
            return this;
        }
        public Builder resourceManagerTags(GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskResourceManagerTag... resourceManagerTags) {
            return resourceManagerTags(List.of(resourceManagerTags));
        }
        @CustomType.Setter
        public Builder resourcePolicies(List<String> resourcePolicies) {
            if (resourcePolicies == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "resourcePolicies");
            }
            this.resourcePolicies = resourcePolicies;
            return this;
        }
        public Builder resourcePolicies(String... resourcePolicies) {
            return resourcePolicies(List.of(resourcePolicies));
        }
        @CustomType.Setter
        public Builder source(String source) {
            if (source == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "source");
            }
            this.source = source;
            return this;
        }
        @CustomType.Setter
        public Builder sourceImage(String sourceImage) {
            if (sourceImage == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "sourceImage");
            }
            this.sourceImage = sourceImage;
            return this;
        }
        @CustomType.Setter
        public Builder sourceImageEncryptionKeys(List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKey> sourceImageEncryptionKeys) {
            if (sourceImageEncryptionKeys == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "sourceImageEncryptionKeys");
            }
            this.sourceImageEncryptionKeys = sourceImageEncryptionKeys;
            return this;
        }
        public Builder sourceImageEncryptionKeys(GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceImageEncryptionKey... sourceImageEncryptionKeys) {
            return sourceImageEncryptionKeys(List.of(sourceImageEncryptionKeys));
        }
        @CustomType.Setter
        public Builder sourceSnapshot(String sourceSnapshot) {
            if (sourceSnapshot == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "sourceSnapshot");
            }
            this.sourceSnapshot = sourceSnapshot;
            return this;
        }
        @CustomType.Setter
        public Builder sourceSnapshotEncryptionKeys(List<GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKey> sourceSnapshotEncryptionKeys) {
            if (sourceSnapshotEncryptionKeys == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "sourceSnapshotEncryptionKeys");
            }
            this.sourceSnapshotEncryptionKeys = sourceSnapshotEncryptionKeys;
            return this;
        }
        public Builder sourceSnapshotEncryptionKeys(GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDiskSourceSnapshotEncryptionKey... sourceSnapshotEncryptionKeys) {
            return sourceSnapshotEncryptionKeys(List.of(sourceSnapshotEncryptionKeys));
        }
        @CustomType.Setter
        public Builder type(String type) {
            if (type == null) {
              throw new MissingRequiredPropertyException("GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk", "type");
            }
            this.type = type;
            return this;
        }
        public GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk build() {
            final var _resultValue = new GetRegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelectionDisk();
            _resultValue.architecture = architecture;
            _resultValue.autoDelete = autoDelete;
            _resultValue.boot = boot;
            _resultValue.deviceName = deviceName;
            _resultValue.diskEncryptionKeys = diskEncryptionKeys;
            _resultValue.diskName = diskName;
            _resultValue.diskSizeGb = diskSizeGb;
            _resultValue.diskType = diskType;
            _resultValue.guestOsFeatures = guestOsFeatures;
            _resultValue.interface_ = interface_;
            _resultValue.labels = labels;
            _resultValue.mode = mode;
            _resultValue.provisionedIops = provisionedIops;
            _resultValue.provisionedThroughput = provisionedThroughput;
            _resultValue.resourceManagerTags = resourceManagerTags;
            _resultValue.resourcePolicies = resourcePolicies;
            _resultValue.source = source;
            _resultValue.sourceImage = sourceImage;
            _resultValue.sourceImageEncryptionKeys = sourceImageEncryptionKeys;
            _resultValue.sourceSnapshot = sourceSnapshot;
            _resultValue.sourceSnapshotEncryptionKeys = sourceSnapshotEncryptionKeys;
            _resultValue.type = type;
            return _resultValue;
        }
    }
}
