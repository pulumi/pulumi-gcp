// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.redis;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.redis.InstanceArgs;
import com.pulumi.gcp.redis.inputs.InstanceState;
import com.pulumi.gcp.redis.outputs.InstanceMaintenancePolicy;
import com.pulumi.gcp.redis.outputs.InstanceMaintenanceSchedule;
import com.pulumi.gcp.redis.outputs.InstanceNode;
import com.pulumi.gcp.redis.outputs.InstancePersistenceConfig;
import com.pulumi.gcp.redis.outputs.InstanceServerCaCert;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * A Google Cloud Redis instance.
 * 
 * To get more information about Instance, see:
 * 
 * * [API documentation](https://cloud.google.com/memorystore/docs/redis/reference/rest/v1/projects.locations.instances)
 * * How-to Guides
 *     * [Official Documentation](https://cloud.google.com/memorystore/docs/redis/)
 * 
 * ## Example Usage
 * 
 * ### Redis Instance Basic
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.redis.Instance;
 * import com.pulumi.gcp.redis.InstanceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var cache = new Instance("cache", InstanceArgs.builder()
 *             .name("memory-cache")
 *             .memorySizeGb(1)
 *             .deletionProtection(false)
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * ### Redis Instance Full
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.ComputeFunctions;
 * import com.pulumi.gcp.compute.inputs.GetNetworkArgs;
 * import com.pulumi.gcp.redis.Instance;
 * import com.pulumi.gcp.redis.InstanceArgs;
 * import com.pulumi.gcp.redis.inputs.InstanceMaintenancePolicyArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         // This example assumes this network already exists.
 *         // The API creates a tenant network per network authorized for a
 *         // Redis instance and that network is not deleted when the user-created
 *         // network (authorized_network) is deleted, so this prevents issues
 *         // with tenant network quota.
 *         // If this network hasn't been created and you are using this example in your
 *         // config, add an additional network resource or change
 *         // this from "data"to "resource"
 *         final var redis-network = ComputeFunctions.getNetwork(GetNetworkArgs.builder()
 *             .name("redis-test-network")
 *             .build());
 * 
 *         var cache = new Instance("cache", InstanceArgs.builder()
 *             .name("ha-memory-cache")
 *             .tier("STANDARD_HA")
 *             .memorySizeGb(1)
 *             .locationId("us-central1-a")
 *             .alternativeLocationId("us-central1-f")
 *             .authorizedNetwork(redis_network.id())
 *             .redisVersion("REDIS_7_2")
 *             .displayName("Test Instance")
 *             .reservedIpRange("192.168.0.0/29")
 *             .labels(Map.ofEntries(
 *                 Map.entry("my_key", "my_val"),
 *                 Map.entry("other_key", "other_val")
 *             ))
 *             .maintenancePolicy(InstanceMaintenancePolicyArgs.builder()
 *                 .weeklyMaintenanceWindows(InstanceMaintenancePolicyWeeklyMaintenanceWindowArgs.builder()
 *                     .day("TUESDAY")
 *                     .startTime(InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeArgs.builder()
 *                         .hours(0)
 *                         .minutes(30)
 *                         .seconds(0)
 *                         .nanos(0)
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * ### Redis Instance Full With Persistence Config
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.redis.Instance;
 * import com.pulumi.gcp.redis.InstanceArgs;
 * import com.pulumi.gcp.redis.inputs.InstancePersistenceConfigArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var cache_persis = new Instance("cache-persis", InstanceArgs.builder()
 *             .name("ha-memory-cache-persis")
 *             .tier("STANDARD_HA")
 *             .memorySizeGb(1)
 *             .locationId("us-central1-a")
 *             .alternativeLocationId("us-central1-f")
 *             .persistenceConfig(InstancePersistenceConfigArgs.builder()
 *                 .persistenceMode("RDB")
 *                 .rdbSnapshotPeriod("TWELVE_HOURS")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * ### Redis Instance Private Service
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.Network;
 * import com.pulumi.gcp.compute.NetworkArgs;
 * import com.pulumi.gcp.compute.GlobalAddress;
 * import com.pulumi.gcp.compute.GlobalAddressArgs;
 * import com.pulumi.gcp.servicenetworking.Connection;
 * import com.pulumi.gcp.servicenetworking.ConnectionArgs;
 * import com.pulumi.gcp.redis.Instance;
 * import com.pulumi.gcp.redis.InstanceArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         // This example assumes this network already exists.
 *         // The API creates a tenant network per network authorized for a
 *         // Redis instance and that network is not deleted when the user-created
 *         // network (authorized_network) is deleted, so this prevents issues
 *         // with tenant network quota.
 *         // If this network hasn't been created and you are using this example in your
 *         // config, add an additional network resource or change
 *         // this from "data"to "resource"
 *         var redis_network = new Network("redis-network", NetworkArgs.builder()
 *             .name("redis-test-network")
 *             .build());
 * 
 *         var serviceRange = new GlobalAddress("serviceRange", GlobalAddressArgs.builder()
 *             .name("address")
 *             .purpose("VPC_PEERING")
 *             .addressType("INTERNAL")
 *             .prefixLength(16)
 *             .network(redis_network.id())
 *             .build());
 * 
 *         var privateServiceConnection = new Connection("privateServiceConnection", ConnectionArgs.builder()
 *             .network(redis_network.id())
 *             .service("servicenetworking.googleapis.com")
 *             .reservedPeeringRanges(serviceRange.name())
 *             .build());
 * 
 *         var cache = new Instance("cache", InstanceArgs.builder()
 *             .name("private-cache")
 *             .tier("STANDARD_HA")
 *             .memorySizeGb(1)
 *             .locationId("us-central1-a")
 *             .alternativeLocationId("us-central1-f")
 *             .authorizedNetwork(redis_network.id())
 *             .connectMode("PRIVATE_SERVICE_ACCESS")
 *             .redisVersion("REDIS_7_2")
 *             .displayName("Test Instance")
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(privateServiceConnection)
 *                 .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * ### Redis Instance Mrr
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.ComputeFunctions;
 * import com.pulumi.gcp.compute.inputs.GetNetworkArgs;
 * import com.pulumi.gcp.redis.Instance;
 * import com.pulumi.gcp.redis.InstanceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         // This example assumes this network already exists.
 *         // The API creates a tenant network per network authorized for a
 *         // Redis instance and that network is not deleted when the user-created
 *         // network (authorized_network) is deleted, so this prevents issues
 *         // with tenant network quota.
 *         // If this network hasn't been created and you are using this example in your
 *         // config, add an additional network resource or change
 *         // this from "data"to "resource"
 *         final var redis-network = ComputeFunctions.getNetwork(GetNetworkArgs.builder()
 *             .name("redis-test-network")
 *             .build());
 * 
 *         var cache = new Instance("cache", InstanceArgs.builder()
 *             .name("mrr-memory-cache")
 *             .tier("STANDARD_HA")
 *             .memorySizeGb(5)
 *             .locationId("us-central1-a")
 *             .alternativeLocationId("us-central1-f")
 *             .authorizedNetwork(redis_network.id())
 *             .redisVersion("REDIS_7_2")
 *             .displayName("Terraform Test Instance")
 *             .replicaCount(5)
 *             .readReplicasMode("READ_REPLICAS_ENABLED")
 *             .labels(Map.ofEntries(
 *                 Map.entry("my_key", "my_val"),
 *                 Map.entry("other_key", "other_val")
 *             ))
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * ### Redis Instance Cmek
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.kms.KeyRing;
 * import com.pulumi.gcp.kms.KeyRingArgs;
 * import com.pulumi.gcp.kms.CryptoKey;
 * import com.pulumi.gcp.kms.CryptoKeyArgs;
 * import com.pulumi.gcp.compute.ComputeFunctions;
 * import com.pulumi.gcp.compute.inputs.GetNetworkArgs;
 * import com.pulumi.gcp.redis.Instance;
 * import com.pulumi.gcp.redis.InstanceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var redisKeyring = new KeyRing("redisKeyring", KeyRingArgs.builder()
 *             .name("redis-keyring")
 *             .location("us-central1")
 *             .build());
 * 
 *         var redisKey = new CryptoKey("redisKey", CryptoKeyArgs.builder()
 *             .name("redis-key")
 *             .keyRing(redisKeyring.id())
 *             .build());
 * 
 *         // This example assumes this network already exists.
 *         // The API creates a tenant network per network authorized for a
 *         // Redis instance and that network is not deleted when the user-created
 *         // network (authorized_network) is deleted, so this prevents issues
 *         // with tenant network quota.
 *         // If this network hasn't been created and you are using this example in your
 *         // config, add an additional network resource or change
 *         // this from "data"to "resource"
 *         final var redis-network = ComputeFunctions.getNetwork(GetNetworkArgs.builder()
 *             .name("redis-test-network")
 *             .build());
 * 
 *         var cache = new Instance("cache", InstanceArgs.builder()
 *             .name("cmek-memory-cache")
 *             .tier("STANDARD_HA")
 *             .memorySizeGb(1)
 *             .locationId("us-central1-a")
 *             .alternativeLocationId("us-central1-f")
 *             .authorizedNetwork(redis_network.id())
 *             .redisVersion("REDIS_7_2")
 *             .displayName("Terraform Test Instance")
 *             .labels(Map.ofEntries(
 *                 Map.entry("my_key", "my_val"),
 *                 Map.entry("other_key", "other_val")
 *             ))
 *             .customerManagedKey(redisKey.id())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Import
 * 
 * Instance can be imported using any of these accepted formats:
 * 
 * * `projects/{{project}}/locations/{{region}}/instances/{{name}}`
 * * `{{project}}/{{region}}/{{name}}`
 * * `{{region}}/{{name}}`
 * * `{{name}}`
 * 
 * When using the `pulumi import` command, Instance can be imported using one of the formats above. For example:
 * 
 * ```sh
 * $ pulumi import gcp:redis/instance:Instance default projects/{{project}}/locations/{{region}}/instances/{{name}}
 * $ pulumi import gcp:redis/instance:Instance default {{project}}/{{region}}/{{name}}
 * $ pulumi import gcp:redis/instance:Instance default {{region}}/{{name}}
 * $ pulumi import gcp:redis/instance:Instance default {{name}}
 * ```
 * 
 */
@ResourceType(type="gcp:redis/instance:Instance")
public class Instance extends com.pulumi.resources.CustomResource {
    /**
     * Only applicable to STANDARD_HA tier which protects the instance
     * against zonal failures by provisioning it across two zones.
     * If provided, it must be a different zone from the one provided in
     * [locationId].
     * 
     */
    @Export(name="alternativeLocationId", refs={String.class}, tree="[0]")
    private Output<String> alternativeLocationId;

    /**
     * @return Only applicable to STANDARD_HA tier which protects the instance
     * against zonal failures by provisioning it across two zones.
     * If provided, it must be a different zone from the one provided in
     * [locationId].
     * 
     */
    public Output<String> alternativeLocationId() {
        return this.alternativeLocationId;
    }
    /**
     * Optional. Indicates whether OSS Redis AUTH is enabled for the
     * instance. If set to &#34;true&#34; AUTH is enabled on the instance.
     * Default value is &#34;false&#34; meaning AUTH is disabled.
     * 
     */
    @Export(name="authEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> authEnabled;

    /**
     * @return Optional. Indicates whether OSS Redis AUTH is enabled for the
     * instance. If set to &#34;true&#34; AUTH is enabled on the instance.
     * Default value is &#34;false&#34; meaning AUTH is disabled.
     * 
     */
    public Output<Optional<Boolean>> authEnabled() {
        return Codegen.optional(this.authEnabled);
    }
    /**
     * AUTH String set on the instance. This field will only be populated if authEnabled is true.
     * 
     */
    @Export(name="authString", refs={String.class}, tree="[0]")
    private Output<String> authString;

    /**
     * @return AUTH String set on the instance. This field will only be populated if authEnabled is true.
     * 
     */
    public Output<String> authString() {
        return this.authString;
    }
    /**
     * The full name of the Google Compute Engine network to which the
     * instance is connected. If left unspecified, the default network
     * will be used.
     * 
     */
    @Export(name="authorizedNetwork", refs={String.class}, tree="[0]")
    private Output<String> authorizedNetwork;

    /**
     * @return The full name of the Google Compute Engine network to which the
     * instance is connected. If left unspecified, the default network
     * will be used.
     * 
     */
    public Output<String> authorizedNetwork() {
        return this.authorizedNetwork;
    }
    /**
     * The connection mode of the Redis instance.
     * Default value is `DIRECT_PEERING`.
     * Possible values are: `DIRECT_PEERING`, `PRIVATE_SERVICE_ACCESS`.
     * 
     */
    @Export(name="connectMode", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> connectMode;

    /**
     * @return The connection mode of the Redis instance.
     * Default value is `DIRECT_PEERING`.
     * Possible values are: `DIRECT_PEERING`, `PRIVATE_SERVICE_ACCESS`.
     * 
     */
    public Output<Optional<String>> connectMode() {
        return Codegen.optional(this.connectMode);
    }
    /**
     * (Output)
     * The time when the certificate was created.
     * 
     */
    @Export(name="createTime", refs={String.class}, tree="[0]")
    private Output<String> createTime;

    /**
     * @return (Output)
     * The time when the certificate was created.
     * 
     */
    public Output<String> createTime() {
        return this.createTime;
    }
    /**
     * The current zone where the Redis endpoint is placed.
     * For Basic Tier instances, this will always be the same as the
     * [locationId] provided by the user at creation time. For Standard Tier
     * instances, this can be either [locationId] or [alternativeLocationId]
     * and can change after a failover event.
     * 
     */
    @Export(name="currentLocationId", refs={String.class}, tree="[0]")
    private Output<String> currentLocationId;

    /**
     * @return The current zone where the Redis endpoint is placed.
     * For Basic Tier instances, this will always be the same as the
     * [locationId] provided by the user at creation time. For Standard Tier
     * instances, this can be either [locationId] or [alternativeLocationId]
     * and can change after a failover event.
     * 
     */
    public Output<String> currentLocationId() {
        return this.currentLocationId;
    }
    /**
     * Optional. The KMS key reference that you want to use to encrypt the data at rest for this Redis
     * instance. If this is provided, CMEK is enabled.
     * 
     */
    @Export(name="customerManagedKey", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> customerManagedKey;

    /**
     * @return Optional. The KMS key reference that you want to use to encrypt the data at rest for this Redis
     * instance. If this is provided, CMEK is enabled.
     * 
     */
    public Output<Optional<String>> customerManagedKey() {
        return Codegen.optional(this.customerManagedKey);
    }
    /**
     * Whether Terraform will be prevented from destroying the instance.
     * When a`terraform destroy` or `pulumi up` would delete the instance,
     * the command will fail if this field is not set to false in Terraform state.
     * When the field is set to true or unset in Terraform state, a `pulumi up`
     * or `terraform destroy` that would delete the instance will fail.
     * When the field is set to false, deleting the instance is allowed.
     * 
     */
    @Export(name="deletionProtection", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> deletionProtection;

    /**
     * @return Whether Terraform will be prevented from destroying the instance.
     * When a`terraform destroy` or `pulumi up` would delete the instance,
     * the command will fail if this field is not set to false in Terraform state.
     * When the field is set to true or unset in Terraform state, a `pulumi up`
     * or `terraform destroy` that would delete the instance will fail.
     * When the field is set to false, deleting the instance is allowed.
     * 
     */
    public Output<Optional<Boolean>> deletionProtection() {
        return Codegen.optional(this.deletionProtection);
    }
    /**
     * An arbitrary and optional user-provided name for the instance.
     * 
     */
    @Export(name="displayName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> displayName;

    /**
     * @return An arbitrary and optional user-provided name for the instance.
     * 
     */
    public Output<Optional<String>> displayName() {
        return Codegen.optional(this.displayName);
    }
    /**
     * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     * 
     */
    @Export(name="effectiveLabels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> effectiveLabels;

    /**
     * @return All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     * 
     */
    public Output<Map<String,String>> effectiveLabels() {
        return this.effectiveLabels;
    }
    /**
     * The CIDR range of internal addresses that are reserved for this
     * instance. If not provided, the service will choose an unused /29
     * block, for example, 10.0.0.0/29 or 192.168.0.0/29. Ranges must be
     * unique and non-overlapping with existing subnets in an authorized
     * network.
     * 
     */
    @Export(name="effectiveReservedIpRange", refs={String.class}, tree="[0]")
    private Output<String> effectiveReservedIpRange;

    /**
     * @return The CIDR range of internal addresses that are reserved for this
     * instance. If not provided, the service will choose an unused /29
     * block, for example, 10.0.0.0/29 or 192.168.0.0/29. Ranges must be
     * unique and non-overlapping with existing subnets in an authorized
     * network.
     * 
     */
    public Output<String> effectiveReservedIpRange() {
        return this.effectiveReservedIpRange;
    }
    /**
     * Hostname or IP address of the exposed Redis endpoint used by clients
     * to connect to the service.
     * 
     */
    @Export(name="host", refs={String.class}, tree="[0]")
    private Output<String> host;

    /**
     * @return Hostname or IP address of the exposed Redis endpoint used by clients
     * to connect to the service.
     * 
     */
    public Output<String> host() {
        return this.host;
    }
    /**
     * Resource labels to represent user provided metadata.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     * 
     */
    @Export(name="labels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> labels;

    /**
     * @return Resource labels to represent user provided metadata.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> labels() {
        return Codegen.optional(this.labels);
    }
    /**
     * The zone where the instance will be provisioned. If not provided,
     * the service will choose a zone for the instance. For STANDARD_HA tier,
     * instances will be created across two zones for protection against
     * zonal failures. If [alternativeLocationId] is also provided, it must
     * be different from [locationId].
     * 
     */
    @Export(name="locationId", refs={String.class}, tree="[0]")
    private Output<String> locationId;

    /**
     * @return The zone where the instance will be provisioned. If not provided,
     * the service will choose a zone for the instance. For STANDARD_HA tier,
     * instances will be created across two zones for protection against
     * zonal failures. If [alternativeLocationId] is also provided, it must
     * be different from [locationId].
     * 
     */
    public Output<String> locationId() {
        return this.locationId;
    }
    /**
     * Maintenance policy for an instance.
     * Structure is documented below.
     * 
     */
    @Export(name="maintenancePolicy", refs={InstanceMaintenancePolicy.class}, tree="[0]")
    private Output</* @Nullable */ InstanceMaintenancePolicy> maintenancePolicy;

    /**
     * @return Maintenance policy for an instance.
     * Structure is documented below.
     * 
     */
    public Output<Optional<InstanceMaintenancePolicy>> maintenancePolicy() {
        return Codegen.optional(this.maintenancePolicy);
    }
    /**
     * Upcoming maintenance schedule.
     * Structure is documented below.
     * 
     */
    @Export(name="maintenanceSchedules", refs={List.class,InstanceMaintenanceSchedule.class}, tree="[0,1]")
    private Output<List<InstanceMaintenanceSchedule>> maintenanceSchedules;

    /**
     * @return Upcoming maintenance schedule.
     * Structure is documented below.
     * 
     */
    public Output<List<InstanceMaintenanceSchedule>> maintenanceSchedules() {
        return this.maintenanceSchedules;
    }
    /**
     * The self service update maintenance version.
     * 
     */
    @Export(name="maintenanceVersion", refs={String.class}, tree="[0]")
    private Output<String> maintenanceVersion;

    /**
     * @return The self service update maintenance version.
     * 
     */
    public Output<String> maintenanceVersion() {
        return this.maintenanceVersion;
    }
    /**
     * Redis memory size in GiB.
     * 
     */
    @Export(name="memorySizeGb", refs={Integer.class}, tree="[0]")
    private Output<Integer> memorySizeGb;

    /**
     * @return Redis memory size in GiB.
     * 
     */
    public Output<Integer> memorySizeGb() {
        return this.memorySizeGb;
    }
    /**
     * The ID of the instance or a fully qualified identifier for the instance.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The ID of the instance or a fully qualified identifier for the instance.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Output only. Info per node.
     * Structure is documented below.
     * 
     */
    @Export(name="nodes", refs={List.class,InstanceNode.class}, tree="[0,1]")
    private Output<List<InstanceNode>> nodes;

    /**
     * @return Output only. Info per node.
     * Structure is documented below.
     * 
     */
    public Output<List<InstanceNode>> nodes() {
        return this.nodes;
    }
    /**
     * Persistence configuration for an instance.
     * Structure is documented below.
     * 
     */
    @Export(name="persistenceConfig", refs={InstancePersistenceConfig.class}, tree="[0]")
    private Output<InstancePersistenceConfig> persistenceConfig;

    /**
     * @return Persistence configuration for an instance.
     * Structure is documented below.
     * 
     */
    public Output<InstancePersistenceConfig> persistenceConfig() {
        return this.persistenceConfig;
    }
    /**
     * Output only. Cloud IAM identity used by import / export operations
     * to transfer data to/from Cloud Storage. Format is &#34;serviceAccount:&#34;.
     * The value may change over time for a given instance so should be
     * checked before each import/export operation.
     * 
     */
    @Export(name="persistenceIamIdentity", refs={String.class}, tree="[0]")
    private Output<String> persistenceIamIdentity;

    /**
     * @return Output only. Cloud IAM identity used by import / export operations
     * to transfer data to/from Cloud Storage. Format is &#34;serviceAccount:&#34;.
     * The value may change over time for a given instance so should be
     * checked before each import/export operation.
     * 
     */
    public Output<String> persistenceIamIdentity() {
        return this.persistenceIamIdentity;
    }
    /**
     * The port number of the exposed Redis endpoint.
     * 
     */
    @Export(name="port", refs={Integer.class}, tree="[0]")
    private Output<Integer> port;

    /**
     * @return The port number of the exposed Redis endpoint.
     * 
     */
    public Output<Integer> port() {
        return this.port;
    }
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Export(name="project", refs={String.class}, tree="[0]")
    private Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Output<String> project() {
        return this.project;
    }
    /**
     * The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     * 
     */
    @Export(name="pulumiLabels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> pulumiLabels;

    /**
     * @return The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     * 
     */
    public Output<Map<String,String>> pulumiLabels() {
        return this.pulumiLabels;
    }
    /**
     * Output only. Hostname or IP address of the exposed readonly Redis endpoint. Standard tier only.
     * Targets all healthy replica nodes in instance. Replication is asynchronous and replica nodes
     * will exhibit some lag behind the primary. Write requests must target &#39;host&#39;.
     * 
     */
    @Export(name="readEndpoint", refs={String.class}, tree="[0]")
    private Output<String> readEndpoint;

    /**
     * @return Output only. Hostname or IP address of the exposed readonly Redis endpoint. Standard tier only.
     * Targets all healthy replica nodes in instance. Replication is asynchronous and replica nodes
     * will exhibit some lag behind the primary. Write requests must target &#39;host&#39;.
     * 
     */
    public Output<String> readEndpoint() {
        return this.readEndpoint;
    }
    /**
     * Output only. The port number of the exposed readonly redis endpoint. Standard tier only.
     * Write requests should target &#39;port&#39;.
     * 
     */
    @Export(name="readEndpointPort", refs={Integer.class}, tree="[0]")
    private Output<Integer> readEndpointPort;

    /**
     * @return Output only. The port number of the exposed readonly redis endpoint. Standard tier only.
     * Write requests should target &#39;port&#39;.
     * 
     */
    public Output<Integer> readEndpointPort() {
        return this.readEndpointPort;
    }
    /**
     * Optional. Read replica mode. Can only be specified when trying to create the instance.
     * If not set, Memorystore Redis backend will default to READ_REPLICAS_DISABLED.
     * - READ_REPLICAS_DISABLED: If disabled, read endpoint will not be provided and the
     *   instance cannot scale up or down the number of replicas.
     * - READ_REPLICAS_ENABLED: If enabled, read endpoint will be provided and the instance
     *   can scale up and down the number of replicas.
     *   Possible values are: `READ_REPLICAS_DISABLED`, `READ_REPLICAS_ENABLED`.
     * 
     */
    @Export(name="readReplicasMode", refs={String.class}, tree="[0]")
    private Output<String> readReplicasMode;

    /**
     * @return Optional. Read replica mode. Can only be specified when trying to create the instance.
     * If not set, Memorystore Redis backend will default to READ_REPLICAS_DISABLED.
     * - READ_REPLICAS_DISABLED: If disabled, read endpoint will not be provided and the
     *   instance cannot scale up or down the number of replicas.
     * - READ_REPLICAS_ENABLED: If enabled, read endpoint will be provided and the instance
     *   can scale up and down the number of replicas.
     *   Possible values are: `READ_REPLICAS_DISABLED`, `READ_REPLICAS_ENABLED`.
     * 
     */
    public Output<String> readReplicasMode() {
        return this.readReplicasMode;
    }
    /**
     * Redis configuration parameters, according to http://redis.io/topics/config.
     * Please check Memorystore documentation for the list of supported parameters:
     * https://cloud.google.com/memorystore/docs/redis/reference/rest/v1/projects.locations.instances#Instance.FIELDS.redis_configs
     * 
     */
    @Export(name="redisConfigs", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> redisConfigs;

    /**
     * @return Redis configuration parameters, according to http://redis.io/topics/config.
     * Please check Memorystore documentation for the list of supported parameters:
     * https://cloud.google.com/memorystore/docs/redis/reference/rest/v1/projects.locations.instances#Instance.FIELDS.redis_configs
     * 
     */
    public Output<Optional<Map<String,String>>> redisConfigs() {
        return Codegen.optional(this.redisConfigs);
    }
    /**
     * The version of Redis software. If not provided, latest supported
     * version will be used. Please check the API documentation linked
     * at the top for the latest valid values.
     * 
     */
    @Export(name="redisVersion", refs={String.class}, tree="[0]")
    private Output<String> redisVersion;

    /**
     * @return The version of Redis software. If not provided, latest supported
     * version will be used. Please check the API documentation linked
     * at the top for the latest valid values.
     * 
     */
    public Output<String> redisVersion() {
        return this.redisVersion;
    }
    /**
     * The name of the Redis region of the instance.
     * 
     */
    @Export(name="region", refs={String.class}, tree="[0]")
    private Output<String> region;

    /**
     * @return The name of the Redis region of the instance.
     * 
     */
    public Output<String> region() {
        return this.region;
    }
    /**
     * Optional. The number of replica nodes. The valid range for the Standard Tier with
     * read replicas enabled is [1-5] and defaults to 2. If read replicas are not enabled
     * for a Standard Tier instance, the only valid value is 1 and the default is 1.
     * The valid value for basic tier is 0 and the default is also 0.
     * 
     */
    @Export(name="replicaCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> replicaCount;

    /**
     * @return Optional. The number of replica nodes. The valid range for the Standard Tier with
     * read replicas enabled is [1-5] and defaults to 2. If read replicas are not enabled
     * for a Standard Tier instance, the only valid value is 1 and the default is 1.
     * The valid value for basic tier is 0 and the default is also 0.
     * 
     */
    public Output<Integer> replicaCount() {
        return this.replicaCount;
    }
    /**
     * The CIDR range of internal addresses that are reserved for this
     * instance. If not provided, the service will choose an unused /29
     * block, for example, 10.0.0.0/29 or 192.168.0.0/29. Ranges must be
     * unique and non-overlapping with existing subnets in an authorized
     * network.
     * 
     */
    @Export(name="reservedIpRange", refs={String.class}, tree="[0]")
    private Output<String> reservedIpRange;

    /**
     * @return The CIDR range of internal addresses that are reserved for this
     * instance. If not provided, the service will choose an unused /29
     * block, for example, 10.0.0.0/29 or 192.168.0.0/29. Ranges must be
     * unique and non-overlapping with existing subnets in an authorized
     * network.
     * 
     */
    public Output<String> reservedIpRange() {
        return this.reservedIpRange;
    }
    /**
     * Optional. Additional IP range for node placement. Required when enabling read replicas on
     * an existing instance. For DIRECT_PEERING mode value must be a CIDR range of size /28, or
     * &#34;auto&#34;. For PRIVATE_SERVICE_ACCESS mode value must be the name of an allocated address
     * range associated with the private service access connection, or &#34;auto&#34;.
     * 
     */
    @Export(name="secondaryIpRange", refs={String.class}, tree="[0]")
    private Output<String> secondaryIpRange;

    /**
     * @return Optional. Additional IP range for node placement. Required when enabling read replicas on
     * an existing instance. For DIRECT_PEERING mode value must be a CIDR range of size /28, or
     * &#34;auto&#34;. For PRIVATE_SERVICE_ACCESS mode value must be the name of an allocated address
     * range associated with the private service access connection, or &#34;auto&#34;.
     * 
     */
    public Output<String> secondaryIpRange() {
        return this.secondaryIpRange;
    }
    /**
     * List of server CA certificates for the instance.
     * Structure is documented below.
     * 
     */
    @Export(name="serverCaCerts", refs={List.class,InstanceServerCaCert.class}, tree="[0,1]")
    private Output<List<InstanceServerCaCert>> serverCaCerts;

    /**
     * @return List of server CA certificates for the instance.
     * Structure is documented below.
     * 
     */
    public Output<List<InstanceServerCaCert>> serverCaCerts() {
        return this.serverCaCerts;
    }
    /**
     * The service tier of the instance. Must be one of these values:
     * - BASIC: standalone instance
     * - STANDARD_HA: highly available primary/replica instances
     *   Default value is `BASIC`.
     *   Possible values are: `BASIC`, `STANDARD_HA`.
     * 
     */
    @Export(name="tier", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tier;

    /**
     * @return The service tier of the instance. Must be one of these values:
     * - BASIC: standalone instance
     * - STANDARD_HA: highly available primary/replica instances
     *   Default value is `BASIC`.
     *   Possible values are: `BASIC`, `STANDARD_HA`.
     * 
     */
    public Output<Optional<String>> tier() {
        return Codegen.optional(this.tier);
    }
    /**
     * The TLS mode of the Redis instance, If not provided, TLS is disabled for the instance.
     * - SERVER_AUTHENTICATION: Client to Server traffic encryption enabled with server authentication
     *   Default value is `DISABLED`.
     *   Possible values are: `SERVER_AUTHENTICATION`, `DISABLED`.
     * 
     */
    @Export(name="transitEncryptionMode", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> transitEncryptionMode;

    /**
     * @return The TLS mode of the Redis instance, If not provided, TLS is disabled for the instance.
     * - SERVER_AUTHENTICATION: Client to Server traffic encryption enabled with server authentication
     *   Default value is `DISABLED`.
     *   Possible values are: `SERVER_AUTHENTICATION`, `DISABLED`.
     * 
     */
    public Output<Optional<String>> transitEncryptionMode() {
        return Codegen.optional(this.transitEncryptionMode);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Instance(java.lang.String name) {
        this(name, InstanceArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Instance(java.lang.String name, InstanceArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Instance(java.lang.String name, InstanceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:redis/instance:Instance", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Instance(java.lang.String name, Output<java.lang.String> id, @Nullable InstanceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:redis/instance:Instance", name, state, makeResourceOptions(options, id), false);
    }

    private static InstanceArgs makeArgs(InstanceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? InstanceArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "authString",
                "effectiveLabels",
                "pulumiLabels"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Instance get(java.lang.String name, Output<java.lang.String> id, @Nullable InstanceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Instance(name, id, state, options);
    }
}
