// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.dataloss.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgs;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgs;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgs;
import com.pulumi.gcp.dataloss.inputs.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs extends com.pulumi.resources.ResourceArgs {

    public static final PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs Empty = new PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs();

    /**
     * Only apply the transformation if the condition evaluates to true for the given RecordCondition. The conditions are allowed to reference fields that are not used in the actual transformation.
     * Example Use Cases:
     * - Apply a different bucket transformation to an age column if the zip code column for the same record is within a specific range.
     * - Redact a field if the date of birth field is greater than 85.
     *   Structure is documented below.
     * 
     */
    @Import(name="condition")
    private @Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgs> condition;

    /**
     * @return Only apply the transformation if the condition evaluates to true for the given RecordCondition. The conditions are allowed to reference fields that are not used in the actual transformation.
     * Example Use Cases:
     * - Apply a different bucket transformation to an age column if the zip code column for the same record is within a specific range.
     * - Redact a field if the date of birth field is greater than 85.
     *   Structure is documented below.
     * 
     */
    public Optional<Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgs>> condition() {
        return Optional.ofNullable(this.condition);
    }

    /**
     * Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId.
     * FieldId name matching ignores the index. For example, instead of &#34;contact.nums[0].type&#34;, use &#34;contact.nums.type&#34;.
     * Structure is documented below.
     * 
     */
    @Import(name="fields", required=true)
    private Output<List<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgs>> fields;

    /**
     * @return Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId.
     * FieldId name matching ignores the index. For example, instead of &#34;contact.nums[0].type&#34;, use &#34;contact.nums.type&#34;.
     * Structure is documented below.
     * 
     */
    public Output<List<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgs>> fields() {
        return this.fields;
    }

    /**
     * Treat the contents of the field as free text, and selectively transform content that matches an InfoType.
     * Only one of `primitiveTransformation` or `infoTypeTransformations` must be specified.
     * Structure is documented below.
     * 
     */
    @Import(name="infoTypeTransformations")
    private @Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgs> infoTypeTransformations;

    /**
     * @return Treat the contents of the field as free text, and selectively transform content that matches an InfoType.
     * Only one of `primitiveTransformation` or `infoTypeTransformations` must be specified.
     * Structure is documented below.
     * 
     */
    public Optional<Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgs>> infoTypeTransformations() {
        return Optional.ofNullable(this.infoTypeTransformations);
    }

    /**
     * Apply the transformation to the entire field.
     * The `primitiveTransformation` block must only contain one argument, corresponding to the type of transformation.
     * Only one of `primitiveTransformation` or `infoTypeTransformations` must be specified.
     * Structure is documented below.
     * 
     */
    @Import(name="primitiveTransformation")
    private @Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs> primitiveTransformation;

    /**
     * @return Apply the transformation to the entire field.
     * The `primitiveTransformation` block must only contain one argument, corresponding to the type of transformation.
     * Only one of `primitiveTransformation` or `infoTypeTransformations` must be specified.
     * Structure is documented below.
     * 
     */
    public Optional<Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs>> primitiveTransformation() {
        return Optional.ofNullable(this.primitiveTransformation);
    }

    private PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs() {}

    private PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs $) {
        this.condition = $.condition;
        this.fields = $.fields;
        this.infoTypeTransformations = $.infoTypeTransformations;
        this.primitiveTransformation = $.primitiveTransformation;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs $;

        public Builder() {
            $ = new PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs();
        }

        public Builder(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs defaults) {
            $ = new PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param condition Only apply the transformation if the condition evaluates to true for the given RecordCondition. The conditions are allowed to reference fields that are not used in the actual transformation.
         * Example Use Cases:
         * - Apply a different bucket transformation to an age column if the zip code column for the same record is within a specific range.
         * - Redact a field if the date of birth field is greater than 85.
         *   Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder condition(@Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgs> condition) {
            $.condition = condition;
            return this;
        }

        /**
         * @param condition Only apply the transformation if the condition evaluates to true for the given RecordCondition. The conditions are allowed to reference fields that are not used in the actual transformation.
         * Example Use Cases:
         * - Apply a different bucket transformation to an age column if the zip code column for the same record is within a specific range.
         * - Redact a field if the date of birth field is greater than 85.
         *   Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder condition(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgs condition) {
            return condition(Output.of(condition));
        }

        /**
         * @param fields Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId.
         * FieldId name matching ignores the index. For example, instead of &#34;contact.nums[0].type&#34;, use &#34;contact.nums.type&#34;.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder fields(Output<List<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgs>> fields) {
            $.fields = fields;
            return this;
        }

        /**
         * @param fields Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId.
         * FieldId name matching ignores the index. For example, instead of &#34;contact.nums[0].type&#34;, use &#34;contact.nums.type&#34;.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder fields(List<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgs> fields) {
            return fields(Output.of(fields));
        }

        /**
         * @param fields Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId.
         * FieldId name matching ignores the index. For example, instead of &#34;contact.nums[0].type&#34;, use &#34;contact.nums.type&#34;.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder fields(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgs... fields) {
            return fields(List.of(fields));
        }

        /**
         * @param infoTypeTransformations Treat the contents of the field as free text, and selectively transform content that matches an InfoType.
         * Only one of `primitiveTransformation` or `infoTypeTransformations` must be specified.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder infoTypeTransformations(@Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgs> infoTypeTransformations) {
            $.infoTypeTransformations = infoTypeTransformations;
            return this;
        }

        /**
         * @param infoTypeTransformations Treat the contents of the field as free text, and selectively transform content that matches an InfoType.
         * Only one of `primitiveTransformation` or `infoTypeTransformations` must be specified.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder infoTypeTransformations(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgs infoTypeTransformations) {
            return infoTypeTransformations(Output.of(infoTypeTransformations));
        }

        /**
         * @param primitiveTransformation Apply the transformation to the entire field.
         * The `primitiveTransformation` block must only contain one argument, corresponding to the type of transformation.
         * Only one of `primitiveTransformation` or `infoTypeTransformations` must be specified.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder primitiveTransformation(@Nullable Output<PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs> primitiveTransformation) {
            $.primitiveTransformation = primitiveTransformation;
            return this;
        }

        /**
         * @param primitiveTransformation Apply the transformation to the entire field.
         * The `primitiveTransformation` block must only contain one argument, corresponding to the type of transformation.
         * Only one of `primitiveTransformation` or `infoTypeTransformations` must be specified.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder primitiveTransformation(PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs primitiveTransformation) {
            return primitiveTransformation(Output.of(primitiveTransformation));
        }

        public PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs build() {
            if ($.fields == null) {
                throw new MissingRequiredPropertyException("PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs", "fields");
            }
            return $;
        }
    }

}
