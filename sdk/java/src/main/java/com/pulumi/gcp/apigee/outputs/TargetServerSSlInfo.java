// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.apigee.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.apigee.outputs.TargetServerSSlInfoCommonName;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class TargetServerSSlInfo {
    /**
     * @return The SSL/TLS cipher suites to be used. For programmable proxies, it must be one of the cipher suite names listed in: http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#ciphersuites. For configurable proxies, it must follow the configuration specified in: https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration. This setting has no effect for configurable proxies when negotiating TLS 1.3.
     * 
     */
    private @Nullable List<String> ciphers;
    /**
     * @return Enables two-way TLS.
     * 
     */
    private @Nullable Boolean clientAuthEnabled;
    /**
     * @return The TLS Common Name of the certificate.
     * Structure is documented below.
     * 
     */
    private @Nullable TargetServerSSlInfoCommonName commonName;
    /**
     * @return Enables TLS. If false, neither one-way nor two-way TLS will be enabled.
     * 
     */
    private Boolean enabled;
    /**
     * @return If true, TLS is strictly enforced.
     * 
     */
    private @Nullable Boolean enforce;
    /**
     * @return If true, Edge ignores TLS certificate errors. Valid when configuring TLS for target servers and target endpoints, and when configuring virtual hosts that use 2-way TLS. When used with a target endpoint/target server, if the backend system uses SNI and returns a cert with a subject Distinguished Name (DN) that does not match the hostname, there is no way to ignore the error and the connection fails.
     * 
     */
    private @Nullable Boolean ignoreValidationErrors;
    /**
     * @return Required if clientAuthEnabled is true. The resource ID for the alias containing the private key and cert.
     * 
     */
    private @Nullable String keyAlias;
    /**
     * @return Required if clientAuthEnabled is true. The resource ID of the keystore.
     * 
     */
    private @Nullable String keyStore;
    /**
     * @return The TLS versioins to be used.
     * 
     */
    private @Nullable List<String> protocols;
    /**
     * @return The resource ID of the truststore.
     * 
     */
    private @Nullable String trustStore;

    private TargetServerSSlInfo() {}
    /**
     * @return The SSL/TLS cipher suites to be used. For programmable proxies, it must be one of the cipher suite names listed in: http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#ciphersuites. For configurable proxies, it must follow the configuration specified in: https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration. This setting has no effect for configurable proxies when negotiating TLS 1.3.
     * 
     */
    public List<String> ciphers() {
        return this.ciphers == null ? List.of() : this.ciphers;
    }
    /**
     * @return Enables two-way TLS.
     * 
     */
    public Optional<Boolean> clientAuthEnabled() {
        return Optional.ofNullable(this.clientAuthEnabled);
    }
    /**
     * @return The TLS Common Name of the certificate.
     * Structure is documented below.
     * 
     */
    public Optional<TargetServerSSlInfoCommonName> commonName() {
        return Optional.ofNullable(this.commonName);
    }
    /**
     * @return Enables TLS. If false, neither one-way nor two-way TLS will be enabled.
     * 
     */
    public Boolean enabled() {
        return this.enabled;
    }
    /**
     * @return If true, TLS is strictly enforced.
     * 
     */
    public Optional<Boolean> enforce() {
        return Optional.ofNullable(this.enforce);
    }
    /**
     * @return If true, Edge ignores TLS certificate errors. Valid when configuring TLS for target servers and target endpoints, and when configuring virtual hosts that use 2-way TLS. When used with a target endpoint/target server, if the backend system uses SNI and returns a cert with a subject Distinguished Name (DN) that does not match the hostname, there is no way to ignore the error and the connection fails.
     * 
     */
    public Optional<Boolean> ignoreValidationErrors() {
        return Optional.ofNullable(this.ignoreValidationErrors);
    }
    /**
     * @return Required if clientAuthEnabled is true. The resource ID for the alias containing the private key and cert.
     * 
     */
    public Optional<String> keyAlias() {
        return Optional.ofNullable(this.keyAlias);
    }
    /**
     * @return Required if clientAuthEnabled is true. The resource ID of the keystore.
     * 
     */
    public Optional<String> keyStore() {
        return Optional.ofNullable(this.keyStore);
    }
    /**
     * @return The TLS versioins to be used.
     * 
     */
    public List<String> protocols() {
        return this.protocols == null ? List.of() : this.protocols;
    }
    /**
     * @return The resource ID of the truststore.
     * 
     */
    public Optional<String> trustStore() {
        return Optional.ofNullable(this.trustStore);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(TargetServerSSlInfo defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable List<String> ciphers;
        private @Nullable Boolean clientAuthEnabled;
        private @Nullable TargetServerSSlInfoCommonName commonName;
        private Boolean enabled;
        private @Nullable Boolean enforce;
        private @Nullable Boolean ignoreValidationErrors;
        private @Nullable String keyAlias;
        private @Nullable String keyStore;
        private @Nullable List<String> protocols;
        private @Nullable String trustStore;
        public Builder() {}
        public Builder(TargetServerSSlInfo defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.ciphers = defaults.ciphers;
    	      this.clientAuthEnabled = defaults.clientAuthEnabled;
    	      this.commonName = defaults.commonName;
    	      this.enabled = defaults.enabled;
    	      this.enforce = defaults.enforce;
    	      this.ignoreValidationErrors = defaults.ignoreValidationErrors;
    	      this.keyAlias = defaults.keyAlias;
    	      this.keyStore = defaults.keyStore;
    	      this.protocols = defaults.protocols;
    	      this.trustStore = defaults.trustStore;
        }

        @CustomType.Setter
        public Builder ciphers(@Nullable List<String> ciphers) {

            this.ciphers = ciphers;
            return this;
        }
        public Builder ciphers(String... ciphers) {
            return ciphers(List.of(ciphers));
        }
        @CustomType.Setter
        public Builder clientAuthEnabled(@Nullable Boolean clientAuthEnabled) {

            this.clientAuthEnabled = clientAuthEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder commonName(@Nullable TargetServerSSlInfoCommonName commonName) {

            this.commonName = commonName;
            return this;
        }
        @CustomType.Setter
        public Builder enabled(Boolean enabled) {
            if (enabled == null) {
              throw new MissingRequiredPropertyException("TargetServerSSlInfo", "enabled");
            }
            this.enabled = enabled;
            return this;
        }
        @CustomType.Setter
        public Builder enforce(@Nullable Boolean enforce) {

            this.enforce = enforce;
            return this;
        }
        @CustomType.Setter
        public Builder ignoreValidationErrors(@Nullable Boolean ignoreValidationErrors) {

            this.ignoreValidationErrors = ignoreValidationErrors;
            return this;
        }
        @CustomType.Setter
        public Builder keyAlias(@Nullable String keyAlias) {

            this.keyAlias = keyAlias;
            return this;
        }
        @CustomType.Setter
        public Builder keyStore(@Nullable String keyStore) {

            this.keyStore = keyStore;
            return this;
        }
        @CustomType.Setter
        public Builder protocols(@Nullable List<String> protocols) {

            this.protocols = protocols;
            return this;
        }
        public Builder protocols(String... protocols) {
            return protocols(List.of(protocols));
        }
        @CustomType.Setter
        public Builder trustStore(@Nullable String trustStore) {

            this.trustStore = trustStore;
            return this;
        }
        public TargetServerSSlInfo build() {
            final var _resultValue = new TargetServerSSlInfo();
            _resultValue.ciphers = ciphers;
            _resultValue.clientAuthEnabled = clientAuthEnabled;
            _resultValue.commonName = commonName;
            _resultValue.enabled = enabled;
            _resultValue.enforce = enforce;
            _resultValue.ignoreValidationErrors = ignoreValidationErrors;
            _resultValue.keyAlias = keyAlias;
            _resultValue.keyStore = keyStore;
            _resultValue.protocols = protocols;
            _resultValue.trustStore = trustStore;
            return _resultValue;
        }
    }
}
