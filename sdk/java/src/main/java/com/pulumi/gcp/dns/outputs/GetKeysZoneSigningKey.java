// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.dns.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.dns.outputs.GetKeysZoneSigningKeyDigest;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetKeysZoneSigningKey {
    /**
     * @return String mnemonic specifying the DNSSEC algorithm of this key. Immutable after creation time. Possible values are `ecdsap256sha256`, `ecdsap384sha384`, `rsasha1`, `rsasha256`, and `rsasha512`.
     * 
     */
    private String algorithm;
    /**
     * @return The time that this resource was created in the control plane. This is in RFC3339 text format.
     * 
     */
    private String creationTime;
    /**
     * @return A mutable string of at most 1024 characters associated with this resource for the user&#39;s convenience.
     * 
     */
    private String description;
    /**
     * @return A list of cryptographic hashes of the DNSKEY resource record associated with this DnsKey. These digests are needed to construct a DS record that points at this DNS key. Each contains:
     * 
     */
    private List<GetKeysZoneSigningKeyDigest> digests;
    /**
     * @return Unique identifier for the resource; defined by the server.
     * 
     */
    private String id;
    /**
     * @return Active keys will be used to sign subsequent changes to the ManagedZone. Inactive keys will still be present as DNSKEY Resource Records for the use of resolvers validating existing signatures.
     * 
     */
    private Boolean isActive;
    /**
     * @return Length of the key in bits. Specified at creation time then immutable.
     * 
     */
    private Integer keyLength;
    /**
     * @return The key tag is a non-cryptographic hash of the a DNSKEY resource record associated with this DnsKey. The key tag can be used to identify a DNSKEY more quickly (but it is not a unique identifier). In particular, the key tag is used in a parent zone&#39;s DS record to point at the DNSKEY in this child ManagedZone. The key tag is a number in the range [0, 65535] and the algorithm to calculate it is specified in RFC4034 Appendix B.
     * 
     */
    private Integer keyTag;
    /**
     * @return Base64 encoded public half of this key.
     * 
     */
    private String publicKey;

    private GetKeysZoneSigningKey() {}
    /**
     * @return String mnemonic specifying the DNSSEC algorithm of this key. Immutable after creation time. Possible values are `ecdsap256sha256`, `ecdsap384sha384`, `rsasha1`, `rsasha256`, and `rsasha512`.
     * 
     */
    public String algorithm() {
        return this.algorithm;
    }
    /**
     * @return The time that this resource was created in the control plane. This is in RFC3339 text format.
     * 
     */
    public String creationTime() {
        return this.creationTime;
    }
    /**
     * @return A mutable string of at most 1024 characters associated with this resource for the user&#39;s convenience.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return A list of cryptographic hashes of the DNSKEY resource record associated with this DnsKey. These digests are needed to construct a DS record that points at this DNS key. Each contains:
     * 
     */
    public List<GetKeysZoneSigningKeyDigest> digests() {
        return this.digests;
    }
    /**
     * @return Unique identifier for the resource; defined by the server.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return Active keys will be used to sign subsequent changes to the ManagedZone. Inactive keys will still be present as DNSKEY Resource Records for the use of resolvers validating existing signatures.
     * 
     */
    public Boolean isActive() {
        return this.isActive;
    }
    /**
     * @return Length of the key in bits. Specified at creation time then immutable.
     * 
     */
    public Integer keyLength() {
        return this.keyLength;
    }
    /**
     * @return The key tag is a non-cryptographic hash of the a DNSKEY resource record associated with this DnsKey. The key tag can be used to identify a DNSKEY more quickly (but it is not a unique identifier). In particular, the key tag is used in a parent zone&#39;s DS record to point at the DNSKEY in this child ManagedZone. The key tag is a number in the range [0, 65535] and the algorithm to calculate it is specified in RFC4034 Appendix B.
     * 
     */
    public Integer keyTag() {
        return this.keyTag;
    }
    /**
     * @return Base64 encoded public half of this key.
     * 
     */
    public String publicKey() {
        return this.publicKey;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetKeysZoneSigningKey defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String algorithm;
        private String creationTime;
        private String description;
        private List<GetKeysZoneSigningKeyDigest> digests;
        private String id;
        private Boolean isActive;
        private Integer keyLength;
        private Integer keyTag;
        private String publicKey;
        public Builder() {}
        public Builder(GetKeysZoneSigningKey defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.algorithm = defaults.algorithm;
    	      this.creationTime = defaults.creationTime;
    	      this.description = defaults.description;
    	      this.digests = defaults.digests;
    	      this.id = defaults.id;
    	      this.isActive = defaults.isActive;
    	      this.keyLength = defaults.keyLength;
    	      this.keyTag = defaults.keyTag;
    	      this.publicKey = defaults.publicKey;
        }

        @CustomType.Setter
        public Builder algorithm(String algorithm) {
            if (algorithm == null) {
              throw new MissingRequiredPropertyException("GetKeysZoneSigningKey", "algorithm");
            }
            this.algorithm = algorithm;
            return this;
        }
        @CustomType.Setter
        public Builder creationTime(String creationTime) {
            if (creationTime == null) {
              throw new MissingRequiredPropertyException("GetKeysZoneSigningKey", "creationTime");
            }
            this.creationTime = creationTime;
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            if (description == null) {
              throw new MissingRequiredPropertyException("GetKeysZoneSigningKey", "description");
            }
            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder digests(List<GetKeysZoneSigningKeyDigest> digests) {
            if (digests == null) {
              throw new MissingRequiredPropertyException("GetKeysZoneSigningKey", "digests");
            }
            this.digests = digests;
            return this;
        }
        public Builder digests(GetKeysZoneSigningKeyDigest... digests) {
            return digests(List.of(digests));
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetKeysZoneSigningKey", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder isActive(Boolean isActive) {
            if (isActive == null) {
              throw new MissingRequiredPropertyException("GetKeysZoneSigningKey", "isActive");
            }
            this.isActive = isActive;
            return this;
        }
        @CustomType.Setter
        public Builder keyLength(Integer keyLength) {
            if (keyLength == null) {
              throw new MissingRequiredPropertyException("GetKeysZoneSigningKey", "keyLength");
            }
            this.keyLength = keyLength;
            return this;
        }
        @CustomType.Setter
        public Builder keyTag(Integer keyTag) {
            if (keyTag == null) {
              throw new MissingRequiredPropertyException("GetKeysZoneSigningKey", "keyTag");
            }
            this.keyTag = keyTag;
            return this;
        }
        @CustomType.Setter
        public Builder publicKey(String publicKey) {
            if (publicKey == null) {
              throw new MissingRequiredPropertyException("GetKeysZoneSigningKey", "publicKey");
            }
            this.publicKey = publicKey;
            return this;
        }
        public GetKeysZoneSigningKey build() {
            final var _resultValue = new GetKeysZoneSigningKey();
            _resultValue.algorithm = algorithm;
            _resultValue.creationTime = creationTime;
            _resultValue.description = description;
            _resultValue.digests = digests;
            _resultValue.id = id;
            _resultValue.isActive = isActive;
            _resultValue.keyLength = keyLength;
            _resultValue.keyTag = keyTag;
            _resultValue.publicKey = publicKey;
            return _resultValue;
        }
    }
}
