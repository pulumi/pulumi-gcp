// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.colab;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.colab.inputs.ScheduleCreateNotebookExecutionJobRequestArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ScheduleArgs extends com.pulumi.resources.ResourceArgs {

    public static final ScheduleArgs Empty = new ScheduleArgs();

    /**
     * Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
     * 
     */
    @Import(name="allowQueueing")
    private @Nullable Output<Boolean> allowQueueing;

    /**
     * @return Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
     * 
     */
    public Optional<Output<Boolean>> allowQueueing() {
        return Optional.ofNullable(this.allowQueueing);
    }

    /**
     * Request for google_colab_notebook_execution.
     * Structure is documented below.
     * 
     */
    @Import(name="createNotebookExecutionJobRequest", required=true)
    private Output<ScheduleCreateNotebookExecutionJobRequestArgs> createNotebookExecutionJobRequest;

    /**
     * @return Request for google_colab_notebook_execution.
     * Structure is documented below.
     * 
     */
    public Output<ScheduleCreateNotebookExecutionJobRequestArgs> createNotebookExecutionJobRequest() {
        return this.createNotebookExecutionJobRequest;
    }

    /**
     * Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
     * 
     */
    @Import(name="cron", required=true)
    private Output<String> cron;

    /**
     * @return Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
     * 
     */
    public Output<String> cron() {
        return this.cron;
    }

    /**
     * Desired state of the Colab Schedule. Set this field to `ACTIVE` to start/resume the schedule, and `PAUSED` to pause the schedule.
     * 
     */
    @Import(name="desiredState")
    private @Nullable Output<String> desiredState;

    /**
     * @return Desired state of the Colab Schedule. Set this field to `ACTIVE` to start/resume the schedule, and `PAUSED` to pause the schedule.
     * 
     */
    public Optional<Output<String>> desiredState() {
        return Optional.ofNullable(this.desiredState);
    }

    /**
     * Required. The display name of the Schedule.
     * 
     */
    @Import(name="displayName", required=true)
    private Output<String> displayName;

    /**
     * @return Required. The display name of the Schedule.
     * 
     */
    public Output<String> displayName() {
        return this.displayName;
    }

    /**
     * Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either end_time is reached or when scheduled_run_count &gt;= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     * 
     */
    @Import(name="endTime")
    private @Nullable Output<String> endTime;

    /**
     * @return Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either end_time is reached or when scheduled_run_count &gt;= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     * 
     */
    public Optional<Output<String>> endTime() {
        return Optional.ofNullable(this.endTime);
    }

    /**
     * The location for the resource: https://cloud.google.com/colab/docs/locations
     * 
     */
    @Import(name="location", required=true)
    private Output<String> location;

    /**
     * @return The location for the resource: https://cloud.google.com/colab/docs/locations
     * 
     */
    public Output<String> location() {
        return this.location;
    }

    /**
     * Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
     * 
     */
    @Import(name="maxConcurrentRunCount", required=true)
    private Output<String> maxConcurrentRunCount;

    /**
     * @return Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
     * 
     */
    public Output<String> maxConcurrentRunCount() {
        return this.maxConcurrentRunCount;
    }

    /**
     * Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount &gt;= maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
     * 
     */
    @Import(name="maxRunCount")
    private @Nullable Output<String> maxRunCount;

    /**
     * @return Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount &gt;= maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
     * 
     */
    public Optional<Output<String>> maxRunCount() {
        return Optional.ofNullable(this.maxRunCount);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     * 
     */
    @Import(name="startTime")
    private @Nullable Output<String> startTime;

    /**
     * @return The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     * 
     */
    public Optional<Output<String>> startTime() {
        return Optional.ofNullable(this.startTime);
    }

    private ScheduleArgs() {}

    private ScheduleArgs(ScheduleArgs $) {
        this.allowQueueing = $.allowQueueing;
        this.createNotebookExecutionJobRequest = $.createNotebookExecutionJobRequest;
        this.cron = $.cron;
        this.desiredState = $.desiredState;
        this.displayName = $.displayName;
        this.endTime = $.endTime;
        this.location = $.location;
        this.maxConcurrentRunCount = $.maxConcurrentRunCount;
        this.maxRunCount = $.maxRunCount;
        this.project = $.project;
        this.startTime = $.startTime;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ScheduleArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ScheduleArgs $;

        public Builder() {
            $ = new ScheduleArgs();
        }

        public Builder(ScheduleArgs defaults) {
            $ = new ScheduleArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowQueueing Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
         * 
         * @return builder
         * 
         */
        public Builder allowQueueing(@Nullable Output<Boolean> allowQueueing) {
            $.allowQueueing = allowQueueing;
            return this;
        }

        /**
         * @param allowQueueing Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
         * 
         * @return builder
         * 
         */
        public Builder allowQueueing(Boolean allowQueueing) {
            return allowQueueing(Output.of(allowQueueing));
        }

        /**
         * @param createNotebookExecutionJobRequest Request for google_colab_notebook_execution.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder createNotebookExecutionJobRequest(Output<ScheduleCreateNotebookExecutionJobRequestArgs> createNotebookExecutionJobRequest) {
            $.createNotebookExecutionJobRequest = createNotebookExecutionJobRequest;
            return this;
        }

        /**
         * @param createNotebookExecutionJobRequest Request for google_colab_notebook_execution.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder createNotebookExecutionJobRequest(ScheduleCreateNotebookExecutionJobRequestArgs createNotebookExecutionJobRequest) {
            return createNotebookExecutionJobRequest(Output.of(createNotebookExecutionJobRequest));
        }

        /**
         * @param cron Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
         * 
         * @return builder
         * 
         */
        public Builder cron(Output<String> cron) {
            $.cron = cron;
            return this;
        }

        /**
         * @param cron Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
         * 
         * @return builder
         * 
         */
        public Builder cron(String cron) {
            return cron(Output.of(cron));
        }

        /**
         * @param desiredState Desired state of the Colab Schedule. Set this field to `ACTIVE` to start/resume the schedule, and `PAUSED` to pause the schedule.
         * 
         * @return builder
         * 
         */
        public Builder desiredState(@Nullable Output<String> desiredState) {
            $.desiredState = desiredState;
            return this;
        }

        /**
         * @param desiredState Desired state of the Colab Schedule. Set this field to `ACTIVE` to start/resume the schedule, and `PAUSED` to pause the schedule.
         * 
         * @return builder
         * 
         */
        public Builder desiredState(String desiredState) {
            return desiredState(Output.of(desiredState));
        }

        /**
         * @param displayName Required. The display name of the Schedule.
         * 
         * @return builder
         * 
         */
        public Builder displayName(Output<String> displayName) {
            $.displayName = displayName;
            return this;
        }

        /**
         * @param displayName Required. The display name of the Schedule.
         * 
         * @return builder
         * 
         */
        public Builder displayName(String displayName) {
            return displayName(Output.of(displayName));
        }

        /**
         * @param endTime Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either end_time is reached or when scheduled_run_count &gt;= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
         * 
         * @return builder
         * 
         */
        public Builder endTime(@Nullable Output<String> endTime) {
            $.endTime = endTime;
            return this;
        }

        /**
         * @param endTime Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either end_time is reached or when scheduled_run_count &gt;= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
         * 
         * @return builder
         * 
         */
        public Builder endTime(String endTime) {
            return endTime(Output.of(endTime));
        }

        /**
         * @param location The location for the resource: https://cloud.google.com/colab/docs/locations
         * 
         * @return builder
         * 
         */
        public Builder location(Output<String> location) {
            $.location = location;
            return this;
        }

        /**
         * @param location The location for the resource: https://cloud.google.com/colab/docs/locations
         * 
         * @return builder
         * 
         */
        public Builder location(String location) {
            return location(Output.of(location));
        }

        /**
         * @param maxConcurrentRunCount Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
         * 
         * @return builder
         * 
         */
        public Builder maxConcurrentRunCount(Output<String> maxConcurrentRunCount) {
            $.maxConcurrentRunCount = maxConcurrentRunCount;
            return this;
        }

        /**
         * @param maxConcurrentRunCount Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
         * 
         * @return builder
         * 
         */
        public Builder maxConcurrentRunCount(String maxConcurrentRunCount) {
            return maxConcurrentRunCount(Output.of(maxConcurrentRunCount));
        }

        /**
         * @param maxRunCount Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount &gt;= maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
         * 
         * @return builder
         * 
         */
        public Builder maxRunCount(@Nullable Output<String> maxRunCount) {
            $.maxRunCount = maxRunCount;
            return this;
        }

        /**
         * @param maxRunCount Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount &gt;= maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
         * 
         * @return builder
         * 
         */
        public Builder maxRunCount(String maxRunCount) {
            return maxRunCount(Output.of(maxRunCount));
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param startTime The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
         * 
         * @return builder
         * 
         */
        public Builder startTime(@Nullable Output<String> startTime) {
            $.startTime = startTime;
            return this;
        }

        /**
         * @param startTime The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
         * 
         * @return builder
         * 
         */
        public Builder startTime(String startTime) {
            return startTime(Output.of(startTime));
        }

        public ScheduleArgs build() {
            if ($.createNotebookExecutionJobRequest == null) {
                throw new MissingRequiredPropertyException("ScheduleArgs", "createNotebookExecutionJobRequest");
            }
            if ($.cron == null) {
                throw new MissingRequiredPropertyException("ScheduleArgs", "cron");
            }
            if ($.displayName == null) {
                throw new MissingRequiredPropertyException("ScheduleArgs", "displayName");
            }
            if ($.location == null) {
                throw new MissingRequiredPropertyException("ScheduleArgs", "location");
            }
            if ($.maxConcurrentRunCount == null) {
                throw new MissingRequiredPropertyException("ScheduleArgs", "maxConcurrentRunCount");
            }
            return $;
        }
    }

}
