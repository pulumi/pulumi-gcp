// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.networkmanagement.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.networkmanagement.outputs.GetConnectivityTestsConnectivityTestDestination;
import com.pulumi.gcp.networkmanagement.outputs.GetConnectivityTestsConnectivityTestSource;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetConnectivityTestsConnectivityTest {
    /**
     * @return Whether the analysis should skip firewall checking.
     * 
     */
    private Boolean bypassFirewallChecks;
    /**
     * @return The user-supplied description of the Connectivity Test.
     * 
     */
    private String description;
    /**
     * @return Destination specification of the Connectivity Test.
     * Structure is documented below.
     * 
     */
    private List<GetConnectivityTestsConnectivityTestDestination> destinations;
    private Map<String,String> effectiveLabels;
    /**
     * @return Resource labels to represent user-provided metadata.
     * 
     */
    private Map<String,String> labels;
    /**
     * @return Unique name for the connectivity test.
     * 
     */
    private String name;
    /**
     * @return The ID of the project.
     * 
     */
    private String project;
    /**
     * @return IP Protocol of the test.
     * 
     */
    private String protocol;
    /**
     * @return The combination of labels configured directly on the resource
     *  and default labels configured on the provider.
     * 
     */
    private Map<String,String> pulumiLabels;
    /**
     * @return Other projects that may be relevant for reachability analysis.
     * 
     */
    private List<String> relatedProjects;
    /**
     * @return Whether run analysis for the return path from destination to source.
     * 
     */
    private Boolean roundTrip;
    /**
     * @return Source specification of the Connectivity Test.
     * Structure is documented below.
     * 
     */
    private List<GetConnectivityTestsConnectivityTestSource> sources;

    private GetConnectivityTestsConnectivityTest() {}
    /**
     * @return Whether the analysis should skip firewall checking.
     * 
     */
    public Boolean bypassFirewallChecks() {
        return this.bypassFirewallChecks;
    }
    /**
     * @return The user-supplied description of the Connectivity Test.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return Destination specification of the Connectivity Test.
     * Structure is documented below.
     * 
     */
    public List<GetConnectivityTestsConnectivityTestDestination> destinations() {
        return this.destinations;
    }
    public Map<String,String> effectiveLabels() {
        return this.effectiveLabels;
    }
    /**
     * @return Resource labels to represent user-provided metadata.
     * 
     */
    public Map<String,String> labels() {
        return this.labels;
    }
    /**
     * @return Unique name for the connectivity test.
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return The ID of the project.
     * 
     */
    public String project() {
        return this.project;
    }
    /**
     * @return IP Protocol of the test.
     * 
     */
    public String protocol() {
        return this.protocol;
    }
    /**
     * @return The combination of labels configured directly on the resource
     *  and default labels configured on the provider.
     * 
     */
    public Map<String,String> pulumiLabels() {
        return this.pulumiLabels;
    }
    /**
     * @return Other projects that may be relevant for reachability analysis.
     * 
     */
    public List<String> relatedProjects() {
        return this.relatedProjects;
    }
    /**
     * @return Whether run analysis for the return path from destination to source.
     * 
     */
    public Boolean roundTrip() {
        return this.roundTrip;
    }
    /**
     * @return Source specification of the Connectivity Test.
     * Structure is documented below.
     * 
     */
    public List<GetConnectivityTestsConnectivityTestSource> sources() {
        return this.sources;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetConnectivityTestsConnectivityTest defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private Boolean bypassFirewallChecks;
        private String description;
        private List<GetConnectivityTestsConnectivityTestDestination> destinations;
        private Map<String,String> effectiveLabels;
        private Map<String,String> labels;
        private String name;
        private String project;
        private String protocol;
        private Map<String,String> pulumiLabels;
        private List<String> relatedProjects;
        private Boolean roundTrip;
        private List<GetConnectivityTestsConnectivityTestSource> sources;
        public Builder() {}
        public Builder(GetConnectivityTestsConnectivityTest defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.bypassFirewallChecks = defaults.bypassFirewallChecks;
    	      this.description = defaults.description;
    	      this.destinations = defaults.destinations;
    	      this.effectiveLabels = defaults.effectiveLabels;
    	      this.labels = defaults.labels;
    	      this.name = defaults.name;
    	      this.project = defaults.project;
    	      this.protocol = defaults.protocol;
    	      this.pulumiLabels = defaults.pulumiLabels;
    	      this.relatedProjects = defaults.relatedProjects;
    	      this.roundTrip = defaults.roundTrip;
    	      this.sources = defaults.sources;
        }

        @CustomType.Setter
        public Builder bypassFirewallChecks(Boolean bypassFirewallChecks) {
            if (bypassFirewallChecks == null) {
              throw new MissingRequiredPropertyException("GetConnectivityTestsConnectivityTest", "bypassFirewallChecks");
            }
            this.bypassFirewallChecks = bypassFirewallChecks;
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            if (description == null) {
              throw new MissingRequiredPropertyException("GetConnectivityTestsConnectivityTest", "description");
            }
            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder destinations(List<GetConnectivityTestsConnectivityTestDestination> destinations) {
            if (destinations == null) {
              throw new MissingRequiredPropertyException("GetConnectivityTestsConnectivityTest", "destinations");
            }
            this.destinations = destinations;
            return this;
        }
        public Builder destinations(GetConnectivityTestsConnectivityTestDestination... destinations) {
            return destinations(List.of(destinations));
        }
        @CustomType.Setter
        public Builder effectiveLabels(Map<String,String> effectiveLabels) {
            if (effectiveLabels == null) {
              throw new MissingRequiredPropertyException("GetConnectivityTestsConnectivityTest", "effectiveLabels");
            }
            this.effectiveLabels = effectiveLabels;
            return this;
        }
        @CustomType.Setter
        public Builder labels(Map<String,String> labels) {
            if (labels == null) {
              throw new MissingRequiredPropertyException("GetConnectivityTestsConnectivityTest", "labels");
            }
            this.labels = labels;
            return this;
        }
        @CustomType.Setter
        public Builder name(String name) {
            if (name == null) {
              throw new MissingRequiredPropertyException("GetConnectivityTestsConnectivityTest", "name");
            }
            this.name = name;
            return this;
        }
        @CustomType.Setter
        public Builder project(String project) {
            if (project == null) {
              throw new MissingRequiredPropertyException("GetConnectivityTestsConnectivityTest", "project");
            }
            this.project = project;
            return this;
        }
        @CustomType.Setter
        public Builder protocol(String protocol) {
            if (protocol == null) {
              throw new MissingRequiredPropertyException("GetConnectivityTestsConnectivityTest", "protocol");
            }
            this.protocol = protocol;
            return this;
        }
        @CustomType.Setter
        public Builder pulumiLabels(Map<String,String> pulumiLabels) {
            if (pulumiLabels == null) {
              throw new MissingRequiredPropertyException("GetConnectivityTestsConnectivityTest", "pulumiLabels");
            }
            this.pulumiLabels = pulumiLabels;
            return this;
        }
        @CustomType.Setter
        public Builder relatedProjects(List<String> relatedProjects) {
            if (relatedProjects == null) {
              throw new MissingRequiredPropertyException("GetConnectivityTestsConnectivityTest", "relatedProjects");
            }
            this.relatedProjects = relatedProjects;
            return this;
        }
        public Builder relatedProjects(String... relatedProjects) {
            return relatedProjects(List.of(relatedProjects));
        }
        @CustomType.Setter
        public Builder roundTrip(Boolean roundTrip) {
            if (roundTrip == null) {
              throw new MissingRequiredPropertyException("GetConnectivityTestsConnectivityTest", "roundTrip");
            }
            this.roundTrip = roundTrip;
            return this;
        }
        @CustomType.Setter
        public Builder sources(List<GetConnectivityTestsConnectivityTestSource> sources) {
            if (sources == null) {
              throw new MissingRequiredPropertyException("GetConnectivityTestsConnectivityTest", "sources");
            }
            this.sources = sources;
            return this;
        }
        public Builder sources(GetConnectivityTestsConnectivityTestSource... sources) {
            return sources(List.of(sources));
        }
        public GetConnectivityTestsConnectivityTest build() {
            final var _resultValue = new GetConnectivityTestsConnectivityTest();
            _resultValue.bypassFirewallChecks = bypassFirewallChecks;
            _resultValue.description = description;
            _resultValue.destinations = destinations;
            _resultValue.effectiveLabels = effectiveLabels;
            _resultValue.labels = labels;
            _resultValue.name = name;
            _resultValue.project = project;
            _resultValue.protocol = protocol;
            _resultValue.pulumiLabels = pulumiLabels;
            _resultValue.relatedProjects = relatedProjects;
            _resultValue.roundTrip = roundTrip;
            _resultValue.sources = sources;
            return _resultValue;
        }
    }
}
