// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.container;

import com.pulumi.core.Output;
import com.pulumi.core.TypeShape;
import com.pulumi.deployment.Deployment;
import com.pulumi.deployment.InvokeOptions;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.container.inputs.GetAwsVersionsArgs;
import com.pulumi.gcp.container.inputs.GetAwsVersionsPlainArgs;
import com.pulumi.gcp.container.inputs.GetAzureVersionsArgs;
import com.pulumi.gcp.container.inputs.GetAzureVersionsPlainArgs;
import com.pulumi.gcp.container.inputs.GetClusterArgs;
import com.pulumi.gcp.container.inputs.GetClusterPlainArgs;
import com.pulumi.gcp.container.inputs.GetEngineVersionsArgs;
import com.pulumi.gcp.container.inputs.GetEngineVersionsPlainArgs;
import com.pulumi.gcp.container.inputs.GetRegistryImageArgs;
import com.pulumi.gcp.container.inputs.GetRegistryImagePlainArgs;
import com.pulumi.gcp.container.inputs.GetRegistryRepositoryArgs;
import com.pulumi.gcp.container.inputs.GetRegistryRepositoryPlainArgs;
import com.pulumi.gcp.container.outputs.GetAwsVersionsResult;
import com.pulumi.gcp.container.outputs.GetAzureVersionsResult;
import com.pulumi.gcp.container.outputs.GetClusterResult;
import com.pulumi.gcp.container.outputs.GetEngineVersionsResult;
import com.pulumi.gcp.container.outputs.GetRegistryImageResult;
import com.pulumi.gcp.container.outputs.GetRegistryRepositoryResult;
import java.util.concurrent.CompletableFuture;

public final class ContainerFunctions {
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getAwsVersions(GetAwsVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, data.google_container_aws_versions().versions().valid_versions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAwsVersionsResult> getAwsVersions() {
        return getAwsVersions(GetAwsVersionsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getAwsVersions(GetAwsVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, data.google_container_aws_versions().versions().valid_versions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAwsVersionsResult> getAwsVersionsPlain() {
        return getAwsVersionsPlain(GetAwsVersionsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getAwsVersions(GetAwsVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, data.google_container_aws_versions().versions().valid_versions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAwsVersionsResult> getAwsVersions(GetAwsVersionsArgs args) {
        return getAwsVersions(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getAwsVersions(GetAwsVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, data.google_container_aws_versions().versions().valid_versions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAwsVersionsResult> getAwsVersionsPlain(GetAwsVersionsPlainArgs args) {
        return getAwsVersionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getAwsVersions(GetAwsVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, data.google_container_aws_versions().versions().valid_versions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAwsVersionsResult> getAwsVersions(GetAwsVersionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("gcp:container/getAwsVersions:getAwsVersions", TypeShape.of(GetAwsVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getAwsVersions(GetAwsVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, data.google_container_aws_versions().versions().valid_versions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAwsVersionsResult> getAwsVersionsPlain(GetAwsVersionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("gcp:container/getAwsVersions:getAwsVersions", TypeShape.of(GetAwsVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getAzureVersions(GetAzureVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, data.google_container_azure_versions().versions().valid_versions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAzureVersionsResult> getAzureVersions() {
        return getAzureVersions(GetAzureVersionsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getAzureVersions(GetAzureVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, data.google_container_azure_versions().versions().valid_versions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAzureVersionsResult> getAzureVersionsPlain() {
        return getAzureVersionsPlain(GetAzureVersionsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getAzureVersions(GetAzureVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, data.google_container_azure_versions().versions().valid_versions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAzureVersionsResult> getAzureVersions(GetAzureVersionsArgs args) {
        return getAzureVersions(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getAzureVersions(GetAzureVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, data.google_container_azure_versions().versions().valid_versions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAzureVersionsResult> getAzureVersionsPlain(GetAzureVersionsPlainArgs args) {
        return getAzureVersionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getAzureVersions(GetAzureVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, data.google_container_azure_versions().versions().valid_versions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAzureVersionsResult> getAzureVersions(GetAzureVersionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("gcp:container/getAzureVersions:getAzureVersions", TypeShape.of(GetAzureVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getAzureVersions(GetAzureVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, data.google_container_azure_versions().versions().valid_versions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAzureVersionsResult> getAzureVersionsPlain(GetAzureVersionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("gcp:container/getAzureVersions:getAzureVersions", TypeShape.of(GetAzureVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Get info about a GKE cluster from its name and location.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myCluster = Output.of(ContainerFunctions.getCluster(GetClusterArgs.builder()
     *             .name(&#34;my-cluster&#34;)
     *             .location(&#34;us-east1-a&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;endpoint&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.endpoint()));
     *         ctx.export(&#34;instanceGroupUrls&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.nodePools()[0].instanceGroupUrls()));
     *         ctx.export(&#34;nodeConfig&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.nodeConfigs()));
     *         ctx.export(&#34;nodePools&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.nodePools()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetClusterResult> getCluster(GetClusterArgs args) {
        return getCluster(args, InvokeOptions.Empty);
    }
    /**
     * Get info about a GKE cluster from its name and location.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myCluster = Output.of(ContainerFunctions.getCluster(GetClusterArgs.builder()
     *             .name(&#34;my-cluster&#34;)
     *             .location(&#34;us-east1-a&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;endpoint&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.endpoint()));
     *         ctx.export(&#34;instanceGroupUrls&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.nodePools()[0].instanceGroupUrls()));
     *         ctx.export(&#34;nodeConfig&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.nodeConfigs()));
     *         ctx.export(&#34;nodePools&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.nodePools()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetClusterResult> getClusterPlain(GetClusterPlainArgs args) {
        return getClusterPlain(args, InvokeOptions.Empty);
    }
    /**
     * Get info about a GKE cluster from its name and location.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myCluster = Output.of(ContainerFunctions.getCluster(GetClusterArgs.builder()
     *             .name(&#34;my-cluster&#34;)
     *             .location(&#34;us-east1-a&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;endpoint&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.endpoint()));
     *         ctx.export(&#34;instanceGroupUrls&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.nodePools()[0].instanceGroupUrls()));
     *         ctx.export(&#34;nodeConfig&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.nodeConfigs()));
     *         ctx.export(&#34;nodePools&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.nodePools()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetClusterResult> getCluster(GetClusterArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("gcp:container/getCluster:getCluster", TypeShape.of(GetClusterResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Get info about a GKE cluster from its name and location.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myCluster = Output.of(ContainerFunctions.getCluster(GetClusterArgs.builder()
     *             .name(&#34;my-cluster&#34;)
     *             .location(&#34;us-east1-a&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;endpoint&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.endpoint()));
     *         ctx.export(&#34;instanceGroupUrls&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.nodePools()[0].instanceGroupUrls()));
     *         ctx.export(&#34;nodeConfig&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.nodeConfigs()));
     *         ctx.export(&#34;nodePools&#34;, myCluster.apply(getClusterResult -&gt; getClusterResult.nodePools()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetClusterResult> getClusterPlain(GetClusterPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("gcp:container/getCluster:getCluster", TypeShape.of(GetClusterResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides access to available Google Kubernetes Engine versions in a zone or region for a given project.
     * 
     * &gt; If you are using the `gcp.container.getEngineVersions` datasource with a
     * regional cluster, ensure that you have provided a region as the `location` to
     * the datasource. A region can have a different set of supported versions than
     * its component zones, and not all zones in a region are guaranteed to
     * support the same version.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getEngineVersions(GetEngineVersionsArgs.builder()
     *             .location(&#34;us-central1-b&#34;)
     *             .versionPrefix(&#34;1.12.&#34;)
     *             .build()));
     * 
     *         var foo = new Cluster(&#34;foo&#34;, ClusterArgs.builder()        
     *             .location(&#34;us-central1-b&#34;)
     *             .nodeVersion(central1b.apply(getEngineVersionsResult -&gt; getEngineVersionsResult.latestNodeVersion()))
     *             .initialNodeCount(1)
     *             .build());
     * 
     *         ctx.export(&#34;stableChannelVersion&#34;, central1b.apply(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelDefaultVersion().STABLE()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetEngineVersionsResult> getEngineVersions() {
        return getEngineVersions(GetEngineVersionsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Google Kubernetes Engine versions in a zone or region for a given project.
     * 
     * &gt; If you are using the `gcp.container.getEngineVersions` datasource with a
     * regional cluster, ensure that you have provided a region as the `location` to
     * the datasource. A region can have a different set of supported versions than
     * its component zones, and not all zones in a region are guaranteed to
     * support the same version.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getEngineVersions(GetEngineVersionsArgs.builder()
     *             .location(&#34;us-central1-b&#34;)
     *             .versionPrefix(&#34;1.12.&#34;)
     *             .build()));
     * 
     *         var foo = new Cluster(&#34;foo&#34;, ClusterArgs.builder()        
     *             .location(&#34;us-central1-b&#34;)
     *             .nodeVersion(central1b.apply(getEngineVersionsResult -&gt; getEngineVersionsResult.latestNodeVersion()))
     *             .initialNodeCount(1)
     *             .build());
     * 
     *         ctx.export(&#34;stableChannelVersion&#34;, central1b.apply(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelDefaultVersion().STABLE()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetEngineVersionsResult> getEngineVersionsPlain() {
        return getEngineVersionsPlain(GetEngineVersionsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Google Kubernetes Engine versions in a zone or region for a given project.
     * 
     * &gt; If you are using the `gcp.container.getEngineVersions` datasource with a
     * regional cluster, ensure that you have provided a region as the `location` to
     * the datasource. A region can have a different set of supported versions than
     * its component zones, and not all zones in a region are guaranteed to
     * support the same version.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getEngineVersions(GetEngineVersionsArgs.builder()
     *             .location(&#34;us-central1-b&#34;)
     *             .versionPrefix(&#34;1.12.&#34;)
     *             .build()));
     * 
     *         var foo = new Cluster(&#34;foo&#34;, ClusterArgs.builder()        
     *             .location(&#34;us-central1-b&#34;)
     *             .nodeVersion(central1b.apply(getEngineVersionsResult -&gt; getEngineVersionsResult.latestNodeVersion()))
     *             .initialNodeCount(1)
     *             .build());
     * 
     *         ctx.export(&#34;stableChannelVersion&#34;, central1b.apply(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelDefaultVersion().STABLE()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetEngineVersionsResult> getEngineVersions(GetEngineVersionsArgs args) {
        return getEngineVersions(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Google Kubernetes Engine versions in a zone or region for a given project.
     * 
     * &gt; If you are using the `gcp.container.getEngineVersions` datasource with a
     * regional cluster, ensure that you have provided a region as the `location` to
     * the datasource. A region can have a different set of supported versions than
     * its component zones, and not all zones in a region are guaranteed to
     * support the same version.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getEngineVersions(GetEngineVersionsArgs.builder()
     *             .location(&#34;us-central1-b&#34;)
     *             .versionPrefix(&#34;1.12.&#34;)
     *             .build()));
     * 
     *         var foo = new Cluster(&#34;foo&#34;, ClusterArgs.builder()        
     *             .location(&#34;us-central1-b&#34;)
     *             .nodeVersion(central1b.apply(getEngineVersionsResult -&gt; getEngineVersionsResult.latestNodeVersion()))
     *             .initialNodeCount(1)
     *             .build());
     * 
     *         ctx.export(&#34;stableChannelVersion&#34;, central1b.apply(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelDefaultVersion().STABLE()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetEngineVersionsResult> getEngineVersionsPlain(GetEngineVersionsPlainArgs args) {
        return getEngineVersionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Google Kubernetes Engine versions in a zone or region for a given project.
     * 
     * &gt; If you are using the `gcp.container.getEngineVersions` datasource with a
     * regional cluster, ensure that you have provided a region as the `location` to
     * the datasource. A region can have a different set of supported versions than
     * its component zones, and not all zones in a region are guaranteed to
     * support the same version.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getEngineVersions(GetEngineVersionsArgs.builder()
     *             .location(&#34;us-central1-b&#34;)
     *             .versionPrefix(&#34;1.12.&#34;)
     *             .build()));
     * 
     *         var foo = new Cluster(&#34;foo&#34;, ClusterArgs.builder()        
     *             .location(&#34;us-central1-b&#34;)
     *             .nodeVersion(central1b.apply(getEngineVersionsResult -&gt; getEngineVersionsResult.latestNodeVersion()))
     *             .initialNodeCount(1)
     *             .build());
     * 
     *         ctx.export(&#34;stableChannelVersion&#34;, central1b.apply(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelDefaultVersion().STABLE()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetEngineVersionsResult> getEngineVersions(GetEngineVersionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("gcp:container/getEngineVersions:getEngineVersions", TypeShape.of(GetEngineVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides access to available Google Kubernetes Engine versions in a zone or region for a given project.
     * 
     * &gt; If you are using the `gcp.container.getEngineVersions` datasource with a
     * regional cluster, ensure that you have provided a region as the `location` to
     * the datasource. A region can have a different set of supported versions than
     * its component zones, and not all zones in a region are guaranteed to
     * support the same version.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = Output.of(ContainerFunctions.getEngineVersions(GetEngineVersionsArgs.builder()
     *             .location(&#34;us-central1-b&#34;)
     *             .versionPrefix(&#34;1.12.&#34;)
     *             .build()));
     * 
     *         var foo = new Cluster(&#34;foo&#34;, ClusterArgs.builder()        
     *             .location(&#34;us-central1-b&#34;)
     *             .nodeVersion(central1b.apply(getEngineVersionsResult -&gt; getEngineVersionsResult.latestNodeVersion()))
     *             .initialNodeCount(1)
     *             .build());
     * 
     *         ctx.export(&#34;stableChannelVersion&#34;, central1b.apply(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelDefaultVersion().STABLE()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetEngineVersionsResult> getEngineVersionsPlain(GetEngineVersionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("gcp:container/getEngineVersions:getEngineVersions", TypeShape.of(GetEngineVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var debian = Output.of(ContainerFunctions.getRegistryImage(GetRegistryImageArgs.builder()
     *             .name(&#34;debian&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;gcrLocation&#34;, debian.apply(getRegistryImageResult -&gt; getRegistryImageResult.imageUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetRegistryImageResult> getRegistryImage(GetRegistryImageArgs args) {
        return getRegistryImage(args, InvokeOptions.Empty);
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var debian = Output.of(ContainerFunctions.getRegistryImage(GetRegistryImageArgs.builder()
     *             .name(&#34;debian&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;gcrLocation&#34;, debian.apply(getRegistryImageResult -&gt; getRegistryImageResult.imageUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetRegistryImageResult> getRegistryImagePlain(GetRegistryImagePlainArgs args) {
        return getRegistryImagePlain(args, InvokeOptions.Empty);
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var debian = Output.of(ContainerFunctions.getRegistryImage(GetRegistryImageArgs.builder()
     *             .name(&#34;debian&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;gcrLocation&#34;, debian.apply(getRegistryImageResult -&gt; getRegistryImageResult.imageUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetRegistryImageResult> getRegistryImage(GetRegistryImageArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("gcp:container/getRegistryImage:getRegistryImage", TypeShape.of(GetRegistryImageResult.class), args, Utilities.withVersion(options));
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var debian = Output.of(ContainerFunctions.getRegistryImage(GetRegistryImageArgs.builder()
     *             .name(&#34;debian&#34;)
     *             .build()));
     * 
     *         ctx.export(&#34;gcrLocation&#34;, debian.apply(getRegistryImageResult -&gt; getRegistryImageResult.imageUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetRegistryImageResult> getRegistryImagePlain(GetRegistryImagePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("gcp:container/getRegistryImage:getRegistryImage", TypeShape.of(GetRegistryImageResult.class), args, Utilities.withVersion(options));
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = Output.of(ContainerFunctions.getRegistryRepository());
     * 
     *         ctx.export(&#34;gcrLocation&#34;, foo.apply(getRegistryRepositoryResult -&gt; getRegistryRepositoryResult.repositoryUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetRegistryRepositoryResult> getRegistryRepository() {
        return getRegistryRepository(GetRegistryRepositoryArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = Output.of(ContainerFunctions.getRegistryRepository());
     * 
     *         ctx.export(&#34;gcrLocation&#34;, foo.apply(getRegistryRepositoryResult -&gt; getRegistryRepositoryResult.repositoryUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetRegistryRepositoryResult> getRegistryRepositoryPlain() {
        return getRegistryRepositoryPlain(GetRegistryRepositoryPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = Output.of(ContainerFunctions.getRegistryRepository());
     * 
     *         ctx.export(&#34;gcrLocation&#34;, foo.apply(getRegistryRepositoryResult -&gt; getRegistryRepositoryResult.repositoryUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetRegistryRepositoryResult> getRegistryRepository(GetRegistryRepositoryArgs args) {
        return getRegistryRepository(args, InvokeOptions.Empty);
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = Output.of(ContainerFunctions.getRegistryRepository());
     * 
     *         ctx.export(&#34;gcrLocation&#34;, foo.apply(getRegistryRepositoryResult -&gt; getRegistryRepositoryResult.repositoryUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetRegistryRepositoryResult> getRegistryRepositoryPlain(GetRegistryRepositoryPlainArgs args) {
        return getRegistryRepositoryPlain(args, InvokeOptions.Empty);
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = Output.of(ContainerFunctions.getRegistryRepository());
     * 
     *         ctx.export(&#34;gcrLocation&#34;, foo.apply(getRegistryRepositoryResult -&gt; getRegistryRepositoryResult.repositoryUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetRegistryRepositoryResult> getRegistryRepository(GetRegistryRepositoryArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("gcp:container/getRegistryRepository:getRegistryRepository", TypeShape.of(GetRegistryRepositoryResult.class), args, Utilities.withVersion(options));
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import java.util.*;
     * import java.io.*;
     * import java.nio.*;
     * import com.pulumi.*;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = Output.of(ContainerFunctions.getRegistryRepository());
     * 
     *         ctx.export(&#34;gcrLocation&#34;, foo.apply(getRegistryRepositoryResult -&gt; getRegistryRepositoryResult.repositoryUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetRegistryRepositoryResult> getRegistryRepositoryPlain(GetRegistryRepositoryPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("gcp:container/getRegistryRepository:getRegistryRepository", TypeShape.of(GetRegistryRepositoryResult.class), args, Utilities.withVersion(options));
    }
}
