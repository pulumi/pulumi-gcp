// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.container;

import com.pulumi.core.Output;
import com.pulumi.core.TypeShape;
import com.pulumi.deployment.Deployment;
import com.pulumi.deployment.InvokeOptions;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.container.inputs.GetAttachedInstallManifestArgs;
import com.pulumi.gcp.container.inputs.GetAttachedInstallManifestPlainArgs;
import com.pulumi.gcp.container.inputs.GetAttachedVersionsArgs;
import com.pulumi.gcp.container.inputs.GetAttachedVersionsPlainArgs;
import com.pulumi.gcp.container.inputs.GetAwsVersionsArgs;
import com.pulumi.gcp.container.inputs.GetAwsVersionsPlainArgs;
import com.pulumi.gcp.container.inputs.GetAzureVersionsArgs;
import com.pulumi.gcp.container.inputs.GetAzureVersionsPlainArgs;
import com.pulumi.gcp.container.inputs.GetClusterArgs;
import com.pulumi.gcp.container.inputs.GetClusterPlainArgs;
import com.pulumi.gcp.container.inputs.GetEngineVersionsArgs;
import com.pulumi.gcp.container.inputs.GetEngineVersionsPlainArgs;
import com.pulumi.gcp.container.inputs.GetRegistryImageArgs;
import com.pulumi.gcp.container.inputs.GetRegistryImagePlainArgs;
import com.pulumi.gcp.container.inputs.GetRegistryRepositoryArgs;
import com.pulumi.gcp.container.inputs.GetRegistryRepositoryPlainArgs;
import com.pulumi.gcp.container.outputs.GetAttachedInstallManifestResult;
import com.pulumi.gcp.container.outputs.GetAttachedVersionsResult;
import com.pulumi.gcp.container.outputs.GetAwsVersionsResult;
import com.pulumi.gcp.container.outputs.GetAzureVersionsResult;
import com.pulumi.gcp.container.outputs.GetClusterResult;
import com.pulumi.gcp.container.outputs.GetEngineVersionsResult;
import com.pulumi.gcp.container.outputs.GetRegistryImageResult;
import com.pulumi.gcp.container.outputs.GetRegistryRepositoryResult;
import java.util.concurrent.CompletableFuture;

public final class ContainerFunctions {
    /**
     * Provides access to available platform versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAttachedInstallManifestArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var manifest = ContainerFunctions.getAttachedInstallManifest(GetAttachedInstallManifestArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .clusterId(&#34;test-cluster-1&#34;)
     *             .platformVersion(&#34;1.25.0-gke.1&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;installManifest&#34;, manifest.applyValue(getAttachedInstallManifestResult -&gt; getAttachedInstallManifestResult));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAttachedInstallManifestResult> getAttachedInstallManifest(GetAttachedInstallManifestArgs args) {
        return getAttachedInstallManifest(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available platform versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAttachedInstallManifestArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var manifest = ContainerFunctions.getAttachedInstallManifest(GetAttachedInstallManifestArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .clusterId(&#34;test-cluster-1&#34;)
     *             .platformVersion(&#34;1.25.0-gke.1&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;installManifest&#34;, manifest.applyValue(getAttachedInstallManifestResult -&gt; getAttachedInstallManifestResult));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAttachedInstallManifestResult> getAttachedInstallManifestPlain(GetAttachedInstallManifestPlainArgs args) {
        return getAttachedInstallManifestPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available platform versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAttachedInstallManifestArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var manifest = ContainerFunctions.getAttachedInstallManifest(GetAttachedInstallManifestArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .clusterId(&#34;test-cluster-1&#34;)
     *             .platformVersion(&#34;1.25.0-gke.1&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;installManifest&#34;, manifest.applyValue(getAttachedInstallManifestResult -&gt; getAttachedInstallManifestResult));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAttachedInstallManifestResult> getAttachedInstallManifest(GetAttachedInstallManifestArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("gcp:container/getAttachedInstallManifest:getAttachedInstallManifest", TypeShape.of(GetAttachedInstallManifestResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides access to available platform versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAttachedInstallManifestArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var manifest = ContainerFunctions.getAttachedInstallManifest(GetAttachedInstallManifestArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .clusterId(&#34;test-cluster-1&#34;)
     *             .platformVersion(&#34;1.25.0-gke.1&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;installManifest&#34;, manifest.applyValue(getAttachedInstallManifestResult -&gt; getAttachedInstallManifestResult));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAttachedInstallManifestResult> getAttachedInstallManifestPlain(GetAttachedInstallManifestPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("gcp:container/getAttachedInstallManifest:getAttachedInstallManifest", TypeShape.of(GetAttachedInstallManifestResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides access to available platform versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAttachedVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var uswest = ContainerFunctions.getAttachedVersions(GetAttachedVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAttachedVersionsResult> getAttachedVersions(GetAttachedVersionsArgs args) {
        return getAttachedVersions(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available platform versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAttachedVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var uswest = ContainerFunctions.getAttachedVersions(GetAttachedVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAttachedVersionsResult> getAttachedVersionsPlain(GetAttachedVersionsPlainArgs args) {
        return getAttachedVersionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available platform versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAttachedVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var uswest = ContainerFunctions.getAttachedVersions(GetAttachedVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAttachedVersionsResult> getAttachedVersions(GetAttachedVersionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("gcp:container/getAttachedVersions:getAttachedVersions", TypeShape.of(GetAttachedVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides access to available platform versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAttachedVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var uswest = ContainerFunctions.getAttachedVersions(GetAttachedVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAttachedVersionsResult> getAttachedVersionsPlain(GetAttachedVersionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("gcp:container/getAttachedVersions:getAttachedVersions", TypeShape.of(GetAttachedVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAwsVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getAwsVersions(GetAwsVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAwsVersionsResult> getAwsVersions() {
        return getAwsVersions(GetAwsVersionsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAwsVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getAwsVersions(GetAwsVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAwsVersionsResult> getAwsVersionsPlain() {
        return getAwsVersionsPlain(GetAwsVersionsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAwsVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getAwsVersions(GetAwsVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAwsVersionsResult> getAwsVersions(GetAwsVersionsArgs args) {
        return getAwsVersions(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAwsVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getAwsVersions(GetAwsVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAwsVersionsResult> getAwsVersionsPlain(GetAwsVersionsPlainArgs args) {
        return getAwsVersionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAwsVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getAwsVersions(GetAwsVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAwsVersionsResult> getAwsVersions(GetAwsVersionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("gcp:container/getAwsVersions:getAwsVersions", TypeShape.of(GetAwsVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAwsVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getAwsVersions(GetAwsVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAwsVersionsResult> getAwsVersionsPlain(GetAwsVersionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("gcp:container/getAwsVersions:getAwsVersions", TypeShape.of(GetAwsVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAzureVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getAzureVersions(GetAzureVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAzureVersionsResult> getAzureVersions() {
        return getAzureVersions(GetAzureVersionsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAzureVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getAzureVersions(GetAzureVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAzureVersionsResult> getAzureVersionsPlain() {
        return getAzureVersionsPlain(GetAzureVersionsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAzureVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getAzureVersions(GetAzureVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAzureVersionsResult> getAzureVersions(GetAzureVersionsArgs args) {
        return getAzureVersions(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAzureVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getAzureVersions(GetAzureVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAzureVersionsResult> getAzureVersionsPlain(GetAzureVersionsPlainArgs args) {
        return getAzureVersionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAzureVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getAzureVersions(GetAzureVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAzureVersionsResult> getAzureVersions(GetAzureVersionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("gcp:container/getAzureVersions:getAzureVersions", TypeShape.of(GetAzureVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides access to available Kubernetes versions in a location for a given project.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetAzureVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getAzureVersions(GetAzureVersionsArgs.builder()
     *             .location(&#34;us-west1&#34;)
     *             .project(&#34;my-project&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;firstAvailableVersion&#34;, versions.validVersions()[0]);
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAzureVersionsResult> getAzureVersionsPlain(GetAzureVersionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("gcp:container/getAzureVersions:getAzureVersions", TypeShape.of(GetAzureVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Get info about a GKE cluster from its name and location.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myCluster = ContainerFunctions.getCluster(GetClusterArgs.builder()
     *             .name(&#34;my-cluster&#34;)
     *             .location(&#34;us-east1-a&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;endpoint&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.endpoint()));
     *         ctx.export(&#34;instanceGroupUrls&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.nodePools()[0].instanceGroupUrls()));
     *         ctx.export(&#34;nodeConfig&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.nodeConfigs()));
     *         ctx.export(&#34;nodePools&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.nodePools()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetClusterResult> getCluster(GetClusterArgs args) {
        return getCluster(args, InvokeOptions.Empty);
    }
    /**
     * Get info about a GKE cluster from its name and location.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myCluster = ContainerFunctions.getCluster(GetClusterArgs.builder()
     *             .name(&#34;my-cluster&#34;)
     *             .location(&#34;us-east1-a&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;endpoint&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.endpoint()));
     *         ctx.export(&#34;instanceGroupUrls&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.nodePools()[0].instanceGroupUrls()));
     *         ctx.export(&#34;nodeConfig&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.nodeConfigs()));
     *         ctx.export(&#34;nodePools&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.nodePools()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetClusterResult> getClusterPlain(GetClusterPlainArgs args) {
        return getClusterPlain(args, InvokeOptions.Empty);
    }
    /**
     * Get info about a GKE cluster from its name and location.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myCluster = ContainerFunctions.getCluster(GetClusterArgs.builder()
     *             .name(&#34;my-cluster&#34;)
     *             .location(&#34;us-east1-a&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;endpoint&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.endpoint()));
     *         ctx.export(&#34;instanceGroupUrls&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.nodePools()[0].instanceGroupUrls()));
     *         ctx.export(&#34;nodeConfig&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.nodeConfigs()));
     *         ctx.export(&#34;nodePools&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.nodePools()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetClusterResult> getCluster(GetClusterArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("gcp:container/getCluster:getCluster", TypeShape.of(GetClusterResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Get info about a GKE cluster from its name and location.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myCluster = ContainerFunctions.getCluster(GetClusterArgs.builder()
     *             .name(&#34;my-cluster&#34;)
     *             .location(&#34;us-east1-a&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;endpoint&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.endpoint()));
     *         ctx.export(&#34;instanceGroupUrls&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.nodePools()[0].instanceGroupUrls()));
     *         ctx.export(&#34;nodeConfig&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.nodeConfigs()));
     *         ctx.export(&#34;nodePools&#34;, myCluster.applyValue(getClusterResult -&gt; getClusterResult.nodePools()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetClusterResult> getClusterPlain(GetClusterPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("gcp:container/getCluster:getCluster", TypeShape.of(GetClusterResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides access to available Google Kubernetes Engine versions in a zone or region for a given project.
     * 
     * &gt; If you are using the `gcp.container.getEngineVersions` datasource with a
     * regional cluster, ensure that you have provided a region as the `location` to
     * the datasource. A region can have a different set of supported versions than
     * its component zones, and not all zones in a region are guaranteed to
     * support the same version.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetEngineVersionsArgs;
     * import com.pulumi.gcp.container.Cluster;
     * import com.pulumi.gcp.container.ClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getEngineVersions(GetEngineVersionsArgs.builder()
     *             .location(&#34;us-central1-b&#34;)
     *             .versionPrefix(&#34;1.12.&#34;)
     *             .build());
     * 
     *         var foo = new Cluster(&#34;foo&#34;, ClusterArgs.builder()        
     *             .name(&#34;test-cluster&#34;)
     *             .location(&#34;us-central1-b&#34;)
     *             .nodeVersion(central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.latestNodeVersion()))
     *             .initialNodeCount(1)
     *             .build());
     * 
     *         ctx.export(&#34;stableChannelDefaultVersion&#34;, central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelDefaultVersion().STABLE()));
     *         ctx.export(&#34;stableChannelLatestVersion&#34;, central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelLatestVersion().STABLE()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetEngineVersionsResult> getEngineVersions() {
        return getEngineVersions(GetEngineVersionsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Google Kubernetes Engine versions in a zone or region for a given project.
     * 
     * &gt; If you are using the `gcp.container.getEngineVersions` datasource with a
     * regional cluster, ensure that you have provided a region as the `location` to
     * the datasource. A region can have a different set of supported versions than
     * its component zones, and not all zones in a region are guaranteed to
     * support the same version.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetEngineVersionsArgs;
     * import com.pulumi.gcp.container.Cluster;
     * import com.pulumi.gcp.container.ClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getEngineVersions(GetEngineVersionsArgs.builder()
     *             .location(&#34;us-central1-b&#34;)
     *             .versionPrefix(&#34;1.12.&#34;)
     *             .build());
     * 
     *         var foo = new Cluster(&#34;foo&#34;, ClusterArgs.builder()        
     *             .name(&#34;test-cluster&#34;)
     *             .location(&#34;us-central1-b&#34;)
     *             .nodeVersion(central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.latestNodeVersion()))
     *             .initialNodeCount(1)
     *             .build());
     * 
     *         ctx.export(&#34;stableChannelDefaultVersion&#34;, central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelDefaultVersion().STABLE()));
     *         ctx.export(&#34;stableChannelLatestVersion&#34;, central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelLatestVersion().STABLE()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetEngineVersionsResult> getEngineVersionsPlain() {
        return getEngineVersionsPlain(GetEngineVersionsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Google Kubernetes Engine versions in a zone or region for a given project.
     * 
     * &gt; If you are using the `gcp.container.getEngineVersions` datasource with a
     * regional cluster, ensure that you have provided a region as the `location` to
     * the datasource. A region can have a different set of supported versions than
     * its component zones, and not all zones in a region are guaranteed to
     * support the same version.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetEngineVersionsArgs;
     * import com.pulumi.gcp.container.Cluster;
     * import com.pulumi.gcp.container.ClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getEngineVersions(GetEngineVersionsArgs.builder()
     *             .location(&#34;us-central1-b&#34;)
     *             .versionPrefix(&#34;1.12.&#34;)
     *             .build());
     * 
     *         var foo = new Cluster(&#34;foo&#34;, ClusterArgs.builder()        
     *             .name(&#34;test-cluster&#34;)
     *             .location(&#34;us-central1-b&#34;)
     *             .nodeVersion(central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.latestNodeVersion()))
     *             .initialNodeCount(1)
     *             .build());
     * 
     *         ctx.export(&#34;stableChannelDefaultVersion&#34;, central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelDefaultVersion().STABLE()));
     *         ctx.export(&#34;stableChannelLatestVersion&#34;, central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelLatestVersion().STABLE()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetEngineVersionsResult> getEngineVersions(GetEngineVersionsArgs args) {
        return getEngineVersions(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Google Kubernetes Engine versions in a zone or region for a given project.
     * 
     * &gt; If you are using the `gcp.container.getEngineVersions` datasource with a
     * regional cluster, ensure that you have provided a region as the `location` to
     * the datasource. A region can have a different set of supported versions than
     * its component zones, and not all zones in a region are guaranteed to
     * support the same version.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetEngineVersionsArgs;
     * import com.pulumi.gcp.container.Cluster;
     * import com.pulumi.gcp.container.ClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getEngineVersions(GetEngineVersionsArgs.builder()
     *             .location(&#34;us-central1-b&#34;)
     *             .versionPrefix(&#34;1.12.&#34;)
     *             .build());
     * 
     *         var foo = new Cluster(&#34;foo&#34;, ClusterArgs.builder()        
     *             .name(&#34;test-cluster&#34;)
     *             .location(&#34;us-central1-b&#34;)
     *             .nodeVersion(central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.latestNodeVersion()))
     *             .initialNodeCount(1)
     *             .build());
     * 
     *         ctx.export(&#34;stableChannelDefaultVersion&#34;, central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelDefaultVersion().STABLE()));
     *         ctx.export(&#34;stableChannelLatestVersion&#34;, central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelLatestVersion().STABLE()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetEngineVersionsResult> getEngineVersionsPlain(GetEngineVersionsPlainArgs args) {
        return getEngineVersionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides access to available Google Kubernetes Engine versions in a zone or region for a given project.
     * 
     * &gt; If you are using the `gcp.container.getEngineVersions` datasource with a
     * regional cluster, ensure that you have provided a region as the `location` to
     * the datasource. A region can have a different set of supported versions than
     * its component zones, and not all zones in a region are guaranteed to
     * support the same version.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetEngineVersionsArgs;
     * import com.pulumi.gcp.container.Cluster;
     * import com.pulumi.gcp.container.ClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getEngineVersions(GetEngineVersionsArgs.builder()
     *             .location(&#34;us-central1-b&#34;)
     *             .versionPrefix(&#34;1.12.&#34;)
     *             .build());
     * 
     *         var foo = new Cluster(&#34;foo&#34;, ClusterArgs.builder()        
     *             .name(&#34;test-cluster&#34;)
     *             .location(&#34;us-central1-b&#34;)
     *             .nodeVersion(central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.latestNodeVersion()))
     *             .initialNodeCount(1)
     *             .build());
     * 
     *         ctx.export(&#34;stableChannelDefaultVersion&#34;, central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelDefaultVersion().STABLE()));
     *         ctx.export(&#34;stableChannelLatestVersion&#34;, central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelLatestVersion().STABLE()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetEngineVersionsResult> getEngineVersions(GetEngineVersionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("gcp:container/getEngineVersions:getEngineVersions", TypeShape.of(GetEngineVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides access to available Google Kubernetes Engine versions in a zone or region for a given project.
     * 
     * &gt; If you are using the `gcp.container.getEngineVersions` datasource with a
     * regional cluster, ensure that you have provided a region as the `location` to
     * the datasource. A region can have a different set of supported versions than
     * its component zones, and not all zones in a region are guaranteed to
     * support the same version.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetEngineVersionsArgs;
     * import com.pulumi.gcp.container.Cluster;
     * import com.pulumi.gcp.container.ClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var central1b = ContainerFunctions.getEngineVersions(GetEngineVersionsArgs.builder()
     *             .location(&#34;us-central1-b&#34;)
     *             .versionPrefix(&#34;1.12.&#34;)
     *             .build());
     * 
     *         var foo = new Cluster(&#34;foo&#34;, ClusterArgs.builder()        
     *             .name(&#34;test-cluster&#34;)
     *             .location(&#34;us-central1-b&#34;)
     *             .nodeVersion(central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.latestNodeVersion()))
     *             .initialNodeCount(1)
     *             .build());
     * 
     *         ctx.export(&#34;stableChannelDefaultVersion&#34;, central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelDefaultVersion().STABLE()));
     *         ctx.export(&#34;stableChannelLatestVersion&#34;, central1b.applyValue(getEngineVersionsResult -&gt; getEngineVersionsResult.releaseChannelLatestVersion().STABLE()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetEngineVersionsResult> getEngineVersionsPlain(GetEngineVersionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("gcp:container/getEngineVersions:getEngineVersions", TypeShape.of(GetEngineVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetRegistryImageArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var debian = ContainerFunctions.getRegistryImage(GetRegistryImageArgs.builder()
     *             .name(&#34;debian&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;gcrLocation&#34;, debian.applyValue(getRegistryImageResult -&gt; getRegistryImageResult.imageUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetRegistryImageResult> getRegistryImage(GetRegistryImageArgs args) {
        return getRegistryImage(args, InvokeOptions.Empty);
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetRegistryImageArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var debian = ContainerFunctions.getRegistryImage(GetRegistryImageArgs.builder()
     *             .name(&#34;debian&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;gcrLocation&#34;, debian.applyValue(getRegistryImageResult -&gt; getRegistryImageResult.imageUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetRegistryImageResult> getRegistryImagePlain(GetRegistryImagePlainArgs args) {
        return getRegistryImagePlain(args, InvokeOptions.Empty);
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetRegistryImageArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var debian = ContainerFunctions.getRegistryImage(GetRegistryImageArgs.builder()
     *             .name(&#34;debian&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;gcrLocation&#34;, debian.applyValue(getRegistryImageResult -&gt; getRegistryImageResult.imageUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetRegistryImageResult> getRegistryImage(GetRegistryImageArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("gcp:container/getRegistryImage:getRegistryImage", TypeShape.of(GetRegistryImageResult.class), args, Utilities.withVersion(options));
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetRegistryImageArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var debian = ContainerFunctions.getRegistryImage(GetRegistryImageArgs.builder()
     *             .name(&#34;debian&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;gcrLocation&#34;, debian.applyValue(getRegistryImageResult -&gt; getRegistryImageResult.imageUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetRegistryImageResult> getRegistryImagePlain(GetRegistryImagePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("gcp:container/getRegistryImage:getRegistryImage", TypeShape.of(GetRegistryImageResult.class), args, Utilities.withVersion(options));
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetRegistryRepositoryArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = ContainerFunctions.getRegistryRepository();
     * 
     *         ctx.export(&#34;gcrLocation&#34;, foo.applyValue(getRegistryRepositoryResult -&gt; getRegistryRepositoryResult.repositoryUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetRegistryRepositoryResult> getRegistryRepository() {
        return getRegistryRepository(GetRegistryRepositoryArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetRegistryRepositoryArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = ContainerFunctions.getRegistryRepository();
     * 
     *         ctx.export(&#34;gcrLocation&#34;, foo.applyValue(getRegistryRepositoryResult -&gt; getRegistryRepositoryResult.repositoryUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetRegistryRepositoryResult> getRegistryRepositoryPlain() {
        return getRegistryRepositoryPlain(GetRegistryRepositoryPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetRegistryRepositoryArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = ContainerFunctions.getRegistryRepository();
     * 
     *         ctx.export(&#34;gcrLocation&#34;, foo.applyValue(getRegistryRepositoryResult -&gt; getRegistryRepositoryResult.repositoryUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetRegistryRepositoryResult> getRegistryRepository(GetRegistryRepositoryArgs args) {
        return getRegistryRepository(args, InvokeOptions.Empty);
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetRegistryRepositoryArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = ContainerFunctions.getRegistryRepository();
     * 
     *         ctx.export(&#34;gcrLocation&#34;, foo.applyValue(getRegistryRepositoryResult -&gt; getRegistryRepositoryResult.repositoryUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetRegistryRepositoryResult> getRegistryRepositoryPlain(GetRegistryRepositoryPlainArgs args) {
        return getRegistryRepositoryPlain(args, InvokeOptions.Empty);
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetRegistryRepositoryArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = ContainerFunctions.getRegistryRepository();
     * 
     *         ctx.export(&#34;gcrLocation&#34;, foo.applyValue(getRegistryRepositoryResult -&gt; getRegistryRepositoryResult.repositoryUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetRegistryRepositoryResult> getRegistryRepository(GetRegistryRepositoryArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("gcp:container/getRegistryRepository:getRegistryRepository", TypeShape.of(GetRegistryRepositoryResult.class), args, Utilities.withVersion(options));
    }
    /**
     * This data source fetches the project name, and provides the appropriate URLs to use for container registry for this project.
     * 
     * The URLs are computed entirely offline - as long as the project exists, they will be valid, but this data source does not contact Google Container Registry (GCR) at any point.
     * 
     * ## Example Usage
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.gcp.container.ContainerFunctions;
     * import com.pulumi.gcp.container.inputs.GetRegistryRepositoryArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = ContainerFunctions.getRegistryRepository();
     * 
     *         ctx.export(&#34;gcrLocation&#34;, foo.applyValue(getRegistryRepositoryResult -&gt; getRegistryRepositoryResult.repositoryUrl()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetRegistryRepositoryResult> getRegistryRepositoryPlain(GetRegistryRepositoryPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("gcp:container/getRegistryRepository:getRegistryRepository", TypeShape.of(GetRegistryRepositoryResult.class), args, Utilities.withVersion(options));
    }
}
