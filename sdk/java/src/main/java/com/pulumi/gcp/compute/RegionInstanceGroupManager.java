// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.compute.RegionInstanceGroupManagerArgs;
import com.pulumi.gcp.compute.inputs.RegionInstanceGroupManagerState;
import com.pulumi.gcp.compute.outputs.RegionInstanceGroupManagerAllInstancesConfig;
import com.pulumi.gcp.compute.outputs.RegionInstanceGroupManagerAutoHealingPolicies;
import com.pulumi.gcp.compute.outputs.RegionInstanceGroupManagerInstanceFlexibilityPolicy;
import com.pulumi.gcp.compute.outputs.RegionInstanceGroupManagerInstanceLifecyclePolicy;
import com.pulumi.gcp.compute.outputs.RegionInstanceGroupManagerNamedPort;
import com.pulumi.gcp.compute.outputs.RegionInstanceGroupManagerParams;
import com.pulumi.gcp.compute.outputs.RegionInstanceGroupManagerStandbyPolicy;
import com.pulumi.gcp.compute.outputs.RegionInstanceGroupManagerStatefulDisk;
import com.pulumi.gcp.compute.outputs.RegionInstanceGroupManagerStatefulExternalIp;
import com.pulumi.gcp.compute.outputs.RegionInstanceGroupManagerStatefulInternalIp;
import com.pulumi.gcp.compute.outputs.RegionInstanceGroupManagerStatus;
import com.pulumi.gcp.compute.outputs.RegionInstanceGroupManagerUpdatePolicy;
import com.pulumi.gcp.compute.outputs.RegionInstanceGroupManagerVersion;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * The Google Compute Engine Regional Instance Group Manager API creates and manages pools
 * of homogeneous Compute Engine virtual machine instances from a common instance
 * template.
 * 
 * To get more information about regionInstanceGroupManagers, see:
 * 
 * * [API documentation](https://cloud.google.com/compute/docs/reference/latest/regionInstanceGroupManagers)
 * * How-to Guides
 *     * [Regional Instance Groups Guide](https://cloud.google.com/compute/docs/instance-groups/distributing-instances-with-regional-instance-groups)
 * 
 * &gt; **Note:** Use [gcp.compute.InstanceGroupManager](https://www.terraform.io/docs/providers/google/r/compute_instance_group_manager.html) to create a zonal instance group manager.
 * 
 * ## Example Usage
 * 
 * ### With Top Level Instance Template (`Google` Provider)
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.RegionInstanceGroupManager;
 * import com.pulumi.gcp.compute.RegionInstanceGroupManagerArgs;
 * import com.pulumi.gcp.compute.inputs.RegionInstanceGroupManagerVersionArgs;
 * import com.pulumi.gcp.compute.inputs.RegionInstanceGroupManagerAllInstancesConfigArgs;
 * import com.pulumi.gcp.compute.inputs.RegionInstanceGroupManagerNamedPortArgs;
 * import com.pulumi.gcp.compute.inputs.RegionInstanceGroupManagerAutoHealingPoliciesArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var autohealing = new HealthCheck("autohealing", HealthCheckArgs.builder()
 *             .name("autohealing-health-check")
 *             .checkIntervalSec(5)
 *             .timeoutSec(5)
 *             .healthyThreshold(2)
 *             .unhealthyThreshold(10)
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .requestPath("/healthz")
 *                 .port(8080)
 *                 .build())
 *             .build());
 * 
 *         var appserver = new RegionInstanceGroupManager("appserver", RegionInstanceGroupManagerArgs.builder()
 *             .name("appserver-igm")
 *             .baseInstanceName("app")
 *             .region("us-central1")
 *             .distributionPolicyZones(            
 *                 "us-central1-a",
 *                 "us-central1-f")
 *             .versions(RegionInstanceGroupManagerVersionArgs.builder()
 *                 .instanceTemplate(appserverGoogleComputeInstanceTemplate.selfLinkUnique())
 *                 .build())
 *             .allInstancesConfig(RegionInstanceGroupManagerAllInstancesConfigArgs.builder()
 *                 .metadata(Map.of("metadata_key", "metadata_value"))
 *                 .labels(Map.of("label_key", "label_value"))
 *                 .build())
 *             .targetPools(appserverGoogleComputeTargetPool.id())
 *             .targetSize(2)
 *             .namedPorts(RegionInstanceGroupManagerNamedPortArgs.builder()
 *                 .name("custom")
 *                 .port(8888)
 *                 .build())
 *             .autoHealingPolicies(RegionInstanceGroupManagerAutoHealingPoliciesArgs.builder()
 *                 .healthCheck(autohealing.id())
 *                 .initialDelaySec(300)
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### With Multiple Versions
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.RegionInstanceGroupManager;
 * import com.pulumi.gcp.compute.RegionInstanceGroupManagerArgs;
 * import com.pulumi.gcp.compute.inputs.RegionInstanceGroupManagerVersionArgs;
 * import com.pulumi.gcp.compute.inputs.RegionInstanceGroupManagerVersionTargetSizeArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var appserver = new RegionInstanceGroupManager("appserver", RegionInstanceGroupManagerArgs.builder()
 *             .name("appserver-igm")
 *             .baseInstanceName("app")
 *             .region("us-central1")
 *             .targetSize(5)
 *             .versions(            
 *                 RegionInstanceGroupManagerVersionArgs.builder()
 *                     .instanceTemplate(appserverGoogleComputeInstanceTemplate.selfLinkUnique())
 *                     .build(),
 *                 RegionInstanceGroupManagerVersionArgs.builder()
 *                     .instanceTemplate(appserver_canary.selfLinkUnique())
 *                     .targetSize(RegionInstanceGroupManagerVersionTargetSizeArgs.builder()
 *                         .fixed(1)
 *                         .build())
 *                     .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### With Standby Policy (`Google` Provider)
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.RegionInstanceGroupManager;
 * import com.pulumi.gcp.compute.RegionInstanceGroupManagerArgs;
 * import com.pulumi.gcp.compute.inputs.RegionInstanceGroupManagerVersionArgs;
 * import com.pulumi.gcp.compute.inputs.RegionInstanceGroupManagerStandbyPolicyArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var igm_sr = new RegionInstanceGroupManager("igm-sr", RegionInstanceGroupManagerArgs.builder()
 *             .name("tf-sr-igm")
 *             .baseInstanceName("tf-sr-igm-instance")
 *             .region("us-central1")
 *             .targetSize(5)
 *             .versions(RegionInstanceGroupManagerVersionArgs.builder()
 *                 .instanceTemplate(sr_igm.selfLink())
 *                 .name("primary")
 *                 .build())
 *             .standbyPolicy(RegionInstanceGroupManagerStandbyPolicyArgs.builder()
 *                 .initialDelaySec(50)
 *                 .mode("SCALE_OUT_POOL")
 *                 .build())
 *             .targetSuspendedSize(1)
 *             .targetStoppedSize(1)
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Import
 * 
 * Instance group managers can be imported using any of these accepted formats:
 * 
 * * `{{name}}`
 * 
 * When using the `pulumi import` command, instance group managers can be imported using one of the formats above. For example:
 * 
 * ```sh
 * $ pulumi import gcp:compute/regionInstanceGroupManager:RegionInstanceGroupManager default {{name}}
 * ```
 * 
 */
@ResourceType(type="gcp:compute/regionInstanceGroupManager:RegionInstanceGroupManager")
public class RegionInstanceGroupManager extends com.pulumi.resources.CustomResource {
    /**
     * Properties to set on all instances in the group. After setting
     * allInstancesConfig on the group, you must update the group&#39;s instances to
     * apply the configuration.
     * 
     */
    @Export(name="allInstancesConfig", refs={RegionInstanceGroupManagerAllInstancesConfig.class}, tree="[0]")
    private Output</* @Nullable */ RegionInstanceGroupManagerAllInstancesConfig> allInstancesConfig;

    /**
     * @return Properties to set on all instances in the group. After setting
     * allInstancesConfig on the group, you must update the group&#39;s instances to
     * apply the configuration.
     * 
     */
    public Output<Optional<RegionInstanceGroupManagerAllInstancesConfig>> allInstancesConfig() {
        return Codegen.optional(this.allInstancesConfig);
    }
    /**
     * The autohealing policies for this managed instance
     * group. You can specify only one value. Structure is documented below. For more information, see the [official documentation](https://cloud.google.com/compute/docs/instance-groups/creating-groups-of-managed-instances#monitoring_groups).
     * 
     */
    @Export(name="autoHealingPolicies", refs={RegionInstanceGroupManagerAutoHealingPolicies.class}, tree="[0]")
    private Output</* @Nullable */ RegionInstanceGroupManagerAutoHealingPolicies> autoHealingPolicies;

    /**
     * @return The autohealing policies for this managed instance
     * group. You can specify only one value. Structure is documented below. For more information, see the [official documentation](https://cloud.google.com/compute/docs/instance-groups/creating-groups-of-managed-instances#monitoring_groups).
     * 
     */
    public Output<Optional<RegionInstanceGroupManagerAutoHealingPolicies>> autoHealingPolicies() {
        return Codegen.optional(this.autoHealingPolicies);
    }
    /**
     * The base instance name to use for
     * instances in this group. The value must be a valid
     * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt) name. Supported characters
     * are lowercase letters, numbers, and hyphens (-). Instances are named by
     * appending a hyphen and a random four-character string to the base instance
     * name.
     * 
     */
    @Export(name="baseInstanceName", refs={String.class}, tree="[0]")
    private Output<String> baseInstanceName;

    /**
     * @return The base instance name to use for
     * instances in this group. The value must be a valid
     * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt) name. Supported characters
     * are lowercase letters, numbers, and hyphens (-). Instances are named by
     * appending a hyphen and a random four-character string to the base instance
     * name.
     * 
     */
    public Output<String> baseInstanceName() {
        return this.baseInstanceName;
    }
    /**
     * Creation timestamp in RFC3339 text format.
     * 
     */
    @Export(name="creationTimestamp", refs={String.class}, tree="[0]")
    private Output<String> creationTimestamp;

    /**
     * @return Creation timestamp in RFC3339 text format.
     * 
     */
    public Output<String> creationTimestamp() {
        return this.creationTimestamp;
    }
    /**
     * An optional textual description of the instance
     * group manager.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return An optional textual description of the instance
     * group manager.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * The shape to which the group converges either proactively or on resize events (depending on the value set in update_policy.0.instance_redistribution_type). For more information see the [official documentation](https://cloud.google.com/compute/docs/instance-groups/regional-mig-distribution-shape).
     * 
     */
    @Export(name="distributionPolicyTargetShape", refs={String.class}, tree="[0]")
    private Output<String> distributionPolicyTargetShape;

    /**
     * @return The shape to which the group converges either proactively or on resize events (depending on the value set in update_policy.0.instance_redistribution_type). For more information see the [official documentation](https://cloud.google.com/compute/docs/instance-groups/regional-mig-distribution-shape).
     * 
     */
    public Output<String> distributionPolicyTargetShape() {
        return this.distributionPolicyTargetShape;
    }
    /**
     * The distribution policy for this managed instance
     * group. You can specify one or more values. For more information, see the [official documentation](https://cloud.google.com/compute/docs/instance-groups/distributing-instances-with-regional-instance-groups#selectingzones).
     * 
     */
    @Export(name="distributionPolicyZones", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> distributionPolicyZones;

    /**
     * @return The distribution policy for this managed instance
     * group. You can specify one or more values. For more information, see the [official documentation](https://cloud.google.com/compute/docs/instance-groups/distributing-instances-with-regional-instance-groups#selectingzones).
     * 
     */
    public Output<List<String>> distributionPolicyZones() {
        return this.distributionPolicyZones;
    }
    /**
     * The fingerprint of the instance group manager.
     * 
     */
    @Export(name="fingerprint", refs={String.class}, tree="[0]")
    private Output<String> fingerprint;

    /**
     * @return The fingerprint of the instance group manager.
     * 
     */
    public Output<String> fingerprint() {
        return this.fingerprint;
    }
    /**
     * The flexibility policy for managed instance group. Instance flexibility allows managed instance group to create VMs from multiple types of machines. Instance flexibility configuration on managed instance group overrides instance template configuration. Structure is documented below.
     * ***
     * 
     */
    @Export(name="instanceFlexibilityPolicy", refs={RegionInstanceGroupManagerInstanceFlexibilityPolicy.class}, tree="[0]")
    private Output</* @Nullable */ RegionInstanceGroupManagerInstanceFlexibilityPolicy> instanceFlexibilityPolicy;

    /**
     * @return The flexibility policy for managed instance group. Instance flexibility allows managed instance group to create VMs from multiple types of machines. Instance flexibility configuration on managed instance group overrides instance template configuration. Structure is documented below.
     * ***
     * 
     */
    public Output<Optional<RegionInstanceGroupManagerInstanceFlexibilityPolicy>> instanceFlexibilityPolicy() {
        return Codegen.optional(this.instanceFlexibilityPolicy);
    }
    /**
     * The full URL of the instance group created by the manager.
     * 
     */
    @Export(name="instanceGroup", refs={String.class}, tree="[0]")
    private Output<String> instanceGroup;

    /**
     * @return The full URL of the instance group created by the manager.
     * 
     */
    public Output<String> instanceGroup() {
        return this.instanceGroup;
    }
    /**
     * The unique identifier number for the resource. This identifier is defined by the server.
     * 
     */
    @Export(name="instanceGroupManagerId", refs={Integer.class}, tree="[0]")
    private Output<Integer> instanceGroupManagerId;

    /**
     * @return The unique identifier number for the resource. This identifier is defined by the server.
     * 
     */
    public Output<Integer> instanceGroupManagerId() {
        return this.instanceGroupManagerId;
    }
    /**
     * The instance lifecycle policy for this managed instance group.
     * 
     */
    @Export(name="instanceLifecyclePolicy", refs={RegionInstanceGroupManagerInstanceLifecyclePolicy.class}, tree="[0]")
    private Output<RegionInstanceGroupManagerInstanceLifecyclePolicy> instanceLifecyclePolicy;

    /**
     * @return The instance lifecycle policy for this managed instance group.
     * 
     */
    public Output<RegionInstanceGroupManagerInstanceLifecyclePolicy> instanceLifecyclePolicy() {
        return this.instanceLifecyclePolicy;
    }
    /**
     * Pagination behavior of the `listManagedInstances` API
     * method for this managed instance group. Valid values are: `PAGELESS`, `PAGINATED`.
     * If `PAGELESS` (default), Pagination is disabled for the group&#39;s `listManagedInstances` API method.
     * `maxResults` and `pageToken` query parameters are ignored and all instances are returned in a single
     * response. If `PAGINATED`, pagination is enabled, `maxResults` and `pageToken` query parameters are
     * respected.
     * 
     */
    @Export(name="listManagedInstancesResults", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> listManagedInstancesResults;

    /**
     * @return Pagination behavior of the `listManagedInstances` API
     * method for this managed instance group. Valid values are: `PAGELESS`, `PAGINATED`.
     * If `PAGELESS` (default), Pagination is disabled for the group&#39;s `listManagedInstances` API method.
     * `maxResults` and `pageToken` query parameters are ignored and all instances are returned in a single
     * response. If `PAGINATED`, pagination is enabled, `maxResults` and `pageToken` query parameters are
     * respected.
     * 
     */
    public Output<Optional<String>> listManagedInstancesResults() {
        return Codegen.optional(this.listManagedInstancesResults);
    }
    /**
     * The name of the instance group manager. Must be 1-63
     * characters long and comply with
     * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
     * include lowercase letters, numbers, and hyphens.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the instance group manager. Must be 1-63
     * characters long and comply with
     * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
     * include lowercase letters, numbers, and hyphens.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The named port configuration. See the section below
     * for details on configuration.
     * 
     */
    @Export(name="namedPorts", refs={List.class,RegionInstanceGroupManagerNamedPort.class}, tree="[0,1]")
    private Output</* @Nullable */ List<RegionInstanceGroupManagerNamedPort>> namedPorts;

    /**
     * @return The named port configuration. See the section below
     * for details on configuration.
     * 
     */
    public Output<Optional<List<RegionInstanceGroupManagerNamedPort>>> namedPorts() {
        return Codegen.optional(this.namedPorts);
    }
    /**
     * ) Input only additional params for instance group manager creation. Structure is documented below. For more information, see [API](https://cloud.google.com/compute/docs/reference/rest/beta/instanceGroupManagers/insert).
     * 
     */
    @Export(name="params", refs={RegionInstanceGroupManagerParams.class}, tree="[0]")
    private Output</* @Nullable */ RegionInstanceGroupManagerParams> params;

    /**
     * @return ) Input only additional params for instance group manager creation. Structure is documented below. For more information, see [API](https://cloud.google.com/compute/docs/reference/rest/beta/instanceGroupManagers/insert).
     * 
     */
    public Output<Optional<RegionInstanceGroupManagerParams>> params() {
        return Codegen.optional(this.params);
    }
    /**
     * The ID of the project in which the resource belongs. If it
     * is not provided, the provider project is used.
     * 
     */
    @Export(name="project", refs={String.class}, tree="[0]")
    private Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs. If it
     * is not provided, the provider project is used.
     * 
     */
    public Output<String> project() {
        return this.project;
    }
    /**
     * The region where the managed instance group resides. If not provided, the provider region is used.
     * 
     * ***
     * 
     */
    @Export(name="region", refs={String.class}, tree="[0]")
    private Output<String> region;

    /**
     * @return The region where the managed instance group resides. If not provided, the provider region is used.
     * 
     * ***
     * 
     */
    public Output<String> region() {
        return this.region;
    }
    /**
     * The URL of the created resource.
     * 
     */
    @Export(name="selfLink", refs={String.class}, tree="[0]")
    private Output<String> selfLink;

    /**
     * @return The URL of the created resource.
     * 
     */
    public Output<String> selfLink() {
        return this.selfLink;
    }
    /**
     * The standby policy for stopped and suspended instances. Structure is documented below. For more information, see the [official documentation](https://cloud.google.com/compute/docs/instance-groups/suspended-and-stopped-vms-in-mig).
     * 
     */
    @Export(name="standbyPolicy", refs={RegionInstanceGroupManagerStandbyPolicy.class}, tree="[0]")
    private Output<RegionInstanceGroupManagerStandbyPolicy> standbyPolicy;

    /**
     * @return The standby policy for stopped and suspended instances. Structure is documented below. For more information, see the [official documentation](https://cloud.google.com/compute/docs/instance-groups/suspended-and-stopped-vms-in-mig).
     * 
     */
    public Output<RegionInstanceGroupManagerStandbyPolicy> standbyPolicy() {
        return this.standbyPolicy;
    }
    /**
     * Disks created on the instances that will be preserved on instance delete, update, etc. Structure is documented below. For more information see the [official documentation](https://cloud.google.com/compute/docs/instance-groups/configuring-stateful-disks-in-migs). Proactive cross zone instance redistribution must be disabled before you can update stateful disks on existing instance group managers. This can be controlled via the `updatePolicy`.
     * 
     */
    @Export(name="statefulDisks", refs={List.class,RegionInstanceGroupManagerStatefulDisk.class}, tree="[0,1]")
    private Output</* @Nullable */ List<RegionInstanceGroupManagerStatefulDisk>> statefulDisks;

    /**
     * @return Disks created on the instances that will be preserved on instance delete, update, etc. Structure is documented below. For more information see the [official documentation](https://cloud.google.com/compute/docs/instance-groups/configuring-stateful-disks-in-migs). Proactive cross zone instance redistribution must be disabled before you can update stateful disks on existing instance group managers. This can be controlled via the `updatePolicy`.
     * 
     */
    public Output<Optional<List<RegionInstanceGroupManagerStatefulDisk>>> statefulDisks() {
        return Codegen.optional(this.statefulDisks);
    }
    /**
     * External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
     * 
     */
    @Export(name="statefulExternalIps", refs={List.class,RegionInstanceGroupManagerStatefulExternalIp.class}, tree="[0,1]")
    private Output</* @Nullable */ List<RegionInstanceGroupManagerStatefulExternalIp>> statefulExternalIps;

    /**
     * @return External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
     * 
     */
    public Output<Optional<List<RegionInstanceGroupManagerStatefulExternalIp>>> statefulExternalIps() {
        return Codegen.optional(this.statefulExternalIps);
    }
    /**
     * Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
     * 
     */
    @Export(name="statefulInternalIps", refs={List.class,RegionInstanceGroupManagerStatefulInternalIp.class}, tree="[0,1]")
    private Output</* @Nullable */ List<RegionInstanceGroupManagerStatefulInternalIp>> statefulInternalIps;

    /**
     * @return Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name. Structure is documented below.
     * 
     */
    public Output<Optional<List<RegionInstanceGroupManagerStatefulInternalIp>>> statefulInternalIps() {
        return Codegen.optional(this.statefulInternalIps);
    }
    /**
     * The status of this managed instance group.
     * 
     */
    @Export(name="statuses", refs={List.class,RegionInstanceGroupManagerStatus.class}, tree="[0,1]")
    private Output<List<RegionInstanceGroupManagerStatus>> statuses;

    /**
     * @return The status of this managed instance group.
     * 
     */
    public Output<List<RegionInstanceGroupManagerStatus>> statuses() {
        return this.statuses;
    }
    /**
     * The full URL of all target pools to which new
     * instances in the group are added. Updating the target pools attribute does
     * not affect existing instances.
     * 
     */
    @Export(name="targetPools", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> targetPools;

    /**
     * @return The full URL of all target pools to which new
     * instances in the group are added. Updating the target pools attribute does
     * not affect existing instances.
     * 
     */
    public Output<Optional<List<String>>> targetPools() {
        return Codegen.optional(this.targetPools);
    }
    /**
     * The target number of running instances for this managed
     * instance group. This value will fight with autoscaler settings when set, and generally shouldn&#39;t be set
     * when using one. If a value is required, such as to specify a creation-time target size for the MIG,
     * `lifecycle.ignore_changes` can be used to prevent Terraform from modifying the value. Defaults to `0`.
     * 
     */
    @Export(name="targetSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> targetSize;

    /**
     * @return The target number of running instances for this managed
     * instance group. This value will fight with autoscaler settings when set, and generally shouldn&#39;t be set
     * when using one. If a value is required, such as to specify a creation-time target size for the MIG,
     * `lifecycle.ignore_changes` can be used to prevent Terraform from modifying the value. Defaults to `0`.
     * 
     */
    public Output<Integer> targetSize() {
        return this.targetSize;
    }
    /**
     * The target number of stopped instances for this managed instance group.
     * 
     */
    @Export(name="targetStoppedSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> targetStoppedSize;

    /**
     * @return The target number of stopped instances for this managed instance group.
     * 
     */
    public Output<Integer> targetStoppedSize() {
        return this.targetStoppedSize;
    }
    /**
     * The target number of suspended instances for this managed instance group.
     * 
     */
    @Export(name="targetSuspendedSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> targetSuspendedSize;

    /**
     * @return The target number of suspended instances for this managed instance group.
     * 
     */
    public Output<Integer> targetSuspendedSize() {
        return this.targetSuspendedSize;
    }
    /**
     * The update policy for this managed instance group. Structure is documented below. For more information, see the [official documentation](https://cloud.google.com/compute/docs/instance-groups/updating-managed-instance-groups) and [API](https://cloud.google.com/compute/docs/reference/rest/beta/regionInstanceGroupManagers/patch)
     * 
     */
    @Export(name="updatePolicy", refs={RegionInstanceGroupManagerUpdatePolicy.class}, tree="[0]")
    private Output<RegionInstanceGroupManagerUpdatePolicy> updatePolicy;

    /**
     * @return The update policy for this managed instance group. Structure is documented below. For more information, see the [official documentation](https://cloud.google.com/compute/docs/instance-groups/updating-managed-instance-groups) and [API](https://cloud.google.com/compute/docs/reference/rest/beta/regionInstanceGroupManagers/patch)
     * 
     */
    public Output<RegionInstanceGroupManagerUpdatePolicy> updatePolicy() {
        return this.updatePolicy;
    }
    /**
     * Application versions managed by this instance group. Each
     * version deals with a specific instance template, allowing canary release scenarios.
     * Structure is documented below.
     * 
     */
    @Export(name="versions", refs={List.class,RegionInstanceGroupManagerVersion.class}, tree="[0,1]")
    private Output<List<RegionInstanceGroupManagerVersion>> versions;

    /**
     * @return Application versions managed by this instance group. Each
     * version deals with a specific instance template, allowing canary release scenarios.
     * Structure is documented below.
     * 
     */
    public Output<List<RegionInstanceGroupManagerVersion>> versions() {
        return this.versions;
    }
    /**
     * Whether to wait for all instances to be created/updated before
     * returning. Note that if this is set to true and the operation does not succeed, the provider will
     * continue trying until it times out.
     * 
     */
    @Export(name="waitForInstances", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> waitForInstances;

    /**
     * @return Whether to wait for all instances to be created/updated before
     * returning. Note that if this is set to true and the operation does not succeed, the provider will
     * continue trying until it times out.
     * 
     */
    public Output<Optional<Boolean>> waitForInstances() {
        return Codegen.optional(this.waitForInstances);
    }
    /**
     * When used with `waitForInstances` it specifies the status to wait for.
     * When `STABLE` is specified this resource will wait until the instances are stable before returning. When `UPDATED` is
     * set, it will wait for the version target to be reached and any per instance configs to be effective as well as all
     * instances to be stable before returning. The possible values are `STABLE` and `UPDATED`
     * 
     */
    @Export(name="waitForInstancesStatus", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> waitForInstancesStatus;

    /**
     * @return When used with `waitForInstances` it specifies the status to wait for.
     * When `STABLE` is specified this resource will wait until the instances are stable before returning. When `UPDATED` is
     * set, it will wait for the version target to be reached and any per instance configs to be effective as well as all
     * instances to be stable before returning. The possible values are `STABLE` and `UPDATED`
     * 
     */
    public Output<Optional<String>> waitForInstancesStatus() {
        return Codegen.optional(this.waitForInstancesStatus);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public RegionInstanceGroupManager(java.lang.String name) {
        this(name, RegionInstanceGroupManagerArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public RegionInstanceGroupManager(java.lang.String name, RegionInstanceGroupManagerArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public RegionInstanceGroupManager(java.lang.String name, RegionInstanceGroupManagerArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:compute/regionInstanceGroupManager:RegionInstanceGroupManager", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private RegionInstanceGroupManager(java.lang.String name, Output<java.lang.String> id, @Nullable RegionInstanceGroupManagerState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:compute/regionInstanceGroupManager:RegionInstanceGroupManager", name, state, makeResourceOptions(options, id), false);
    }

    private static RegionInstanceGroupManagerArgs makeArgs(RegionInstanceGroupManagerArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? RegionInstanceGroupManagerArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static RegionInstanceGroupManager get(java.lang.String name, Output<java.lang.String> id, @Nullable RegionInstanceGroupManagerState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new RegionInstanceGroupManager(name, id, state, options);
    }
}
