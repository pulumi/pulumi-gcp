// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.container;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.container.ClusterArgs;
import com.pulumi.gcp.container.inputs.ClusterState;
import com.pulumi.gcp.container.outputs.ClusterAddonsConfig;
import com.pulumi.gcp.container.outputs.ClusterAnonymousAuthenticationConfig;
import com.pulumi.gcp.container.outputs.ClusterAuthenticatorGroupsConfig;
import com.pulumi.gcp.container.outputs.ClusterBinaryAuthorization;
import com.pulumi.gcp.container.outputs.ClusterClusterAutoscaling;
import com.pulumi.gcp.container.outputs.ClusterClusterTelemetry;
import com.pulumi.gcp.container.outputs.ClusterConfidentialNodes;
import com.pulumi.gcp.container.outputs.ClusterControlPlaneEndpointsConfig;
import com.pulumi.gcp.container.outputs.ClusterCostManagementConfig;
import com.pulumi.gcp.container.outputs.ClusterDatabaseEncryption;
import com.pulumi.gcp.container.outputs.ClusterDefaultSnatStatus;
import com.pulumi.gcp.container.outputs.ClusterDnsConfig;
import com.pulumi.gcp.container.outputs.ClusterEnableK8sBetaApis;
import com.pulumi.gcp.container.outputs.ClusterEnterpriseConfig;
import com.pulumi.gcp.container.outputs.ClusterFleet;
import com.pulumi.gcp.container.outputs.ClusterGatewayApiConfig;
import com.pulumi.gcp.container.outputs.ClusterGkeAutoUpgradeConfig;
import com.pulumi.gcp.container.outputs.ClusterIdentityServiceConfig;
import com.pulumi.gcp.container.outputs.ClusterIpAllocationPolicy;
import com.pulumi.gcp.container.outputs.ClusterLoggingConfig;
import com.pulumi.gcp.container.outputs.ClusterMaintenancePolicy;
import com.pulumi.gcp.container.outputs.ClusterManagedOpentelemetryConfig;
import com.pulumi.gcp.container.outputs.ClusterMasterAuth;
import com.pulumi.gcp.container.outputs.ClusterMasterAuthorizedNetworksConfig;
import com.pulumi.gcp.container.outputs.ClusterMeshCertificates;
import com.pulumi.gcp.container.outputs.ClusterMonitoringConfig;
import com.pulumi.gcp.container.outputs.ClusterNetworkPerformanceConfig;
import com.pulumi.gcp.container.outputs.ClusterNetworkPolicy;
import com.pulumi.gcp.container.outputs.ClusterNodeConfig;
import com.pulumi.gcp.container.outputs.ClusterNodePool;
import com.pulumi.gcp.container.outputs.ClusterNodePoolAutoConfig;
import com.pulumi.gcp.container.outputs.ClusterNodePoolDefaults;
import com.pulumi.gcp.container.outputs.ClusterNotificationConfig;
import com.pulumi.gcp.container.outputs.ClusterPodAutoscaling;
import com.pulumi.gcp.container.outputs.ClusterPodSecurityPolicyConfig;
import com.pulumi.gcp.container.outputs.ClusterPrivateClusterConfig;
import com.pulumi.gcp.container.outputs.ClusterProtectConfig;
import com.pulumi.gcp.container.outputs.ClusterRbacBindingConfig;
import com.pulumi.gcp.container.outputs.ClusterReleaseChannel;
import com.pulumi.gcp.container.outputs.ClusterResourceUsageExportConfig;
import com.pulumi.gcp.container.outputs.ClusterSecretManagerConfig;
import com.pulumi.gcp.container.outputs.ClusterSecretSyncConfig;
import com.pulumi.gcp.container.outputs.ClusterSecurityPostureConfig;
import com.pulumi.gcp.container.outputs.ClusterServiceExternalIpsConfig;
import com.pulumi.gcp.container.outputs.ClusterTpuConfig;
import com.pulumi.gcp.container.outputs.ClusterUserManagedKeysConfig;
import com.pulumi.gcp.container.outputs.ClusterVerticalPodAutoscaling;
import com.pulumi.gcp.container.outputs.ClusterWorkloadAltsConfig;
import com.pulumi.gcp.container.outputs.ClusterWorkloadIdentityConfig;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages a Google Kubernetes Engine (GKE) cluster.
 * 
 * To get more information about GKE clusters, see:
 *   * [The API reference](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.locations.clusters)
 *   * How-to guides
 *     * [GKE overview](https://cloud.google.com/kubernetes-engine/docs/concepts/kubernetes-engine-overview)
 *     * [About cluster configuration choices](https://cloud.google.com/kubernetes-engine/docs/concepts/types-of-clusters)
 *   * Terraform guidance
 *     * Using GKE with Terraform
 *     * Provision a GKE Cluster (Google Cloud) Learn tutorial
 * 
 * &gt; On version 5.0.0+ of the provider, you must explicitly set `deletionProtection = false`
 * and run `pulumi up` to write the field to state in order to destroy a cluster.
 * 
 * &gt; All arguments and attributes (including certificate outputs) will be stored in the raw state as
 * plaintext. Read more about sensitive data in state.
 * 
 * ## Example Usage
 * 
 * ### With A Separately Managed Node Pool (Recommended)
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.serviceaccount.Account;
 * import com.pulumi.gcp.serviceaccount.AccountArgs;
 * import com.pulumi.gcp.container.Cluster;
 * import com.pulumi.gcp.container.ClusterArgs;
 * import com.pulumi.gcp.container.NodePool;
 * import com.pulumi.gcp.container.NodePoolArgs;
 * import com.pulumi.gcp.container.inputs.NodePoolNodeConfigArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new Account("default", AccountArgs.builder()
 *             .accountId("service-account-id")
 *             .displayName("Service Account")
 *             .build());
 * 
 *         var primary = new Cluster("primary", ClusterArgs.builder()
 *             .name("my-gke-cluster")
 *             .location("us-central1")
 *             .removeDefaultNodePool(true)
 *             .initialNodeCount(1)
 *             .build());
 * 
 *         var primaryPreemptibleNodes = new NodePool("primaryPreemptibleNodes", NodePoolArgs.builder()
 *             .name("my-node-pool")
 *             .location("us-central1")
 *             .cluster(primary.name())
 *             .nodeCount(1)
 *             .nodeConfig(NodePoolNodeConfigArgs.builder()
 *                 .preemptible(true)
 *                 .machineType("e2-medium")
 *                 .serviceAccount(default_.email())
 *                 .oauthScopes("https://www.googleapis.com/auth/cloud-platform")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * &gt; **Note:** It is recommended that node pools be created and managed as separate resources as in the example above.
 * This allows node pools to be added and removed without recreating the cluster.  Node pools defined directly in the
 * `gcp.container.Cluster` resource cannot be removed without re-creating the cluster.
 * 
 * ### With The Default Node Pool
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.serviceaccount.Account;
 * import com.pulumi.gcp.serviceaccount.AccountArgs;
 * import com.pulumi.gcp.container.Cluster;
 * import com.pulumi.gcp.container.ClusterArgs;
 * import com.pulumi.gcp.container.inputs.ClusterNodeConfigArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new Account("default", AccountArgs.builder()
 *             .accountId("service-account-id")
 *             .displayName("Service Account")
 *             .build());
 * 
 *         var primary = new Cluster("primary", ClusterArgs.builder()
 *             .name("marcellus-wallace")
 *             .location("us-central1-a")
 *             .initialNodeCount(3)
 *             .nodeConfig(ClusterNodeConfigArgs.builder()
 *                 .serviceAccount(default_.email())
 *                 .oauthScopes("https://www.googleapis.com/auth/cloud-platform")
 *                 .labels(Map.of("foo", "bar"))
 *                 .tags(                
 *                     "foo",
 *                     "bar")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 */
@ResourceType(type="gcp:container/cluster:Cluster")
public class Cluster extends com.pulumi.resources.CustomResource {
    /**
     * The configuration for addons supported by GKE.
     * Structure is documented below.
     * 
     */
    @Export(name="addonsConfig", refs={ClusterAddonsConfig.class}, tree="[0]")
    private Output<ClusterAddonsConfig> addonsConfig;

    /**
     * @return The configuration for addons supported by GKE.
     * Structure is documented below.
     * 
     */
    public Output<ClusterAddonsConfig> addonsConfig() {
        return this.addonsConfig;
    }
    /**
     * Enable NET_ADMIN for the cluster. Defaults to
     * `false`. This field should only be enabled for Autopilot clusters (`enableAutopilot`
     * set to `true`).
     * 
     */
    @Export(name="allowNetAdmin", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowNetAdmin;

    /**
     * @return Enable NET_ADMIN for the cluster. Defaults to
     * `false`. This field should only be enabled for Autopilot clusters (`enableAutopilot`
     * set to `true`).
     * 
     */
    public Output<Optional<Boolean>> allowNetAdmin() {
        return Codegen.optional(this.allowNetAdmin);
    }
    /**
     * Configuration for [anonymous authentication restrictions](https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#restrict-anon-access). Structure is documented below.
     * 
     */
    @Export(name="anonymousAuthenticationConfig", refs={ClusterAnonymousAuthenticationConfig.class}, tree="[0]")
    private Output<ClusterAnonymousAuthenticationConfig> anonymousAuthenticationConfig;

    /**
     * @return Configuration for [anonymous authentication restrictions](https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#restrict-anon-access). Structure is documented below.
     * 
     */
    public Output<ClusterAnonymousAuthenticationConfig> anonymousAuthenticationConfig() {
        return this.anonymousAuthenticationConfig;
    }
    /**
     * Configuration for the
     * [Google Groups for GKE](https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control#groups-setup-gsuite) feature.
     * Structure is documented below.
     * 
     */
    @Export(name="authenticatorGroupsConfig", refs={ClusterAuthenticatorGroupsConfig.class}, tree="[0]")
    private Output<ClusterAuthenticatorGroupsConfig> authenticatorGroupsConfig;

    /**
     * @return Configuration for the
     * [Google Groups for GKE](https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control#groups-setup-gsuite) feature.
     * Structure is documented below.
     * 
     */
    public Output<ClusterAuthenticatorGroupsConfig> authenticatorGroupsConfig() {
        return this.authenticatorGroupsConfig;
    }
    /**
     * Configuration options for the Binary
     * Authorization feature. Structure is documented below.
     * 
     */
    @Export(name="binaryAuthorization", refs={ClusterBinaryAuthorization.class}, tree="[0]")
    private Output</* @Nullable */ ClusterBinaryAuthorization> binaryAuthorization;

    /**
     * @return Configuration options for the Binary
     * Authorization feature. Structure is documented below.
     * 
     */
    public Output<Optional<ClusterBinaryAuthorization>> binaryAuthorization() {
        return Codegen.optional(this.binaryAuthorization);
    }
    /**
     * Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
     * automatically adjust the size of the cluster and create/delete node pools based
     * on the current needs of the cluster&#39;s workload. See the
     * [guide to using Node Auto-Provisioning](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning)
     * for more details. Structure is documented below.
     * 
     */
    @Export(name="clusterAutoscaling", refs={ClusterClusterAutoscaling.class}, tree="[0]")
    private Output<ClusterClusterAutoscaling> clusterAutoscaling;

    /**
     * @return Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
     * automatically adjust the size of the cluster and create/delete node pools based
     * on the current needs of the cluster&#39;s workload. See the
     * [guide to using Node Auto-Provisioning](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning)
     * for more details. Structure is documented below.
     * 
     */
    public Output<ClusterClusterAutoscaling> clusterAutoscaling() {
        return this.clusterAutoscaling;
    }
    /**
     * The IP address range of the Kubernetes pods
     * in this cluster in CIDR notation (e.g. `10.96.0.0/14`). Leave blank to have one
     * automatically chosen or specify a `/14` block in `10.0.0.0/8`. This field will
     * default a new cluster to routes-based, where `ipAllocationPolicy` is not defined.
     * 
     */
    @Export(name="clusterIpv4Cidr", refs={String.class}, tree="[0]")
    private Output<String> clusterIpv4Cidr;

    /**
     * @return The IP address range of the Kubernetes pods
     * in this cluster in CIDR notation (e.g. `10.96.0.0/14`). Leave blank to have one
     * automatically chosen or specify a `/14` block in `10.0.0.0/8`. This field will
     * default a new cluster to routes-based, where `ipAllocationPolicy` is not defined.
     * 
     */
    public Output<String> clusterIpv4Cidr() {
        return this.clusterIpv4Cidr;
    }
    /**
     * ) Configuration for
     * [ClusterTelemetry](https://cloud.google.com/monitoring/kubernetes-engine/installing#controlling_the_collection_of_application_logs) feature,
     * Structure is documented below.
     * 
     */
    @Export(name="clusterTelemetry", refs={ClusterClusterTelemetry.class}, tree="[0]")
    private Output<ClusterClusterTelemetry> clusterTelemetry;

    /**
     * @return ) Configuration for
     * [ClusterTelemetry](https://cloud.google.com/monitoring/kubernetes-engine/installing#controlling_the_collection_of_application_logs) feature,
     * Structure is documented below.
     * 
     */
    public Output<ClusterClusterTelemetry> clusterTelemetry() {
        return this.clusterTelemetry;
    }
    /**
     * Configuration for [Confidential Nodes](https://cloud.google.com/kubernetes-engine/docs/how-to/confidential-gke-nodes) feature. Structure is documented below documented below.
     * 
     */
    @Export(name="confidentialNodes", refs={ClusterConfidentialNodes.class}, tree="[0]")
    private Output<ClusterConfidentialNodes> confidentialNodes;

    /**
     * @return Configuration for [Confidential Nodes](https://cloud.google.com/kubernetes-engine/docs/how-to/confidential-gke-nodes) feature. Structure is documented below documented below.
     * 
     */
    public Output<ClusterConfidentialNodes> confidentialNodes() {
        return this.confidentialNodes;
    }
    /**
     * Configuration for all of the cluster&#39;s control plane endpoints.
     * Structure is documented below.
     * 
     */
    @Export(name="controlPlaneEndpointsConfig", refs={ClusterControlPlaneEndpointsConfig.class}, tree="[0]")
    private Output<ClusterControlPlaneEndpointsConfig> controlPlaneEndpointsConfig;

    /**
     * @return Configuration for all of the cluster&#39;s control plane endpoints.
     * Structure is documented below.
     * 
     */
    public Output<ClusterControlPlaneEndpointsConfig> controlPlaneEndpointsConfig() {
        return this.controlPlaneEndpointsConfig;
    }
    /**
     * Configuration for the
     * [Cost Allocation](https://cloud.google.com/kubernetes-engine/docs/how-to/cost-allocations) feature.
     * Structure is documented below.
     * 
     */
    @Export(name="costManagementConfig", refs={ClusterCostManagementConfig.class}, tree="[0]")
    private Output<ClusterCostManagementConfig> costManagementConfig;

    /**
     * @return Configuration for the
     * [Cost Allocation](https://cloud.google.com/kubernetes-engine/docs/how-to/cost-allocations) feature.
     * Structure is documented below.
     * 
     */
    public Output<ClusterCostManagementConfig> costManagementConfig() {
        return this.costManagementConfig;
    }
    /**
     * Structure is documented below.
     * 
     */
    @Export(name="databaseEncryption", refs={ClusterDatabaseEncryption.class}, tree="[0]")
    private Output<ClusterDatabaseEncryption> databaseEncryption;

    /**
     * @return Structure is documented below.
     * 
     */
    public Output<ClusterDatabaseEncryption> databaseEncryption() {
        return this.databaseEncryption;
    }
    /**
     * The desired datapath provider for this cluster. This is set to `LEGACY_DATAPATH` by default, which uses the IPTables-based kube-proxy implementation. Set to `ADVANCED_DATAPATH` to enable Dataplane v2.
     * 
     */
    @Export(name="datapathProvider", refs={String.class}, tree="[0]")
    private Output<String> datapathProvider;

    /**
     * @return The desired datapath provider for this cluster. This is set to `LEGACY_DATAPATH` by default, which uses the IPTables-based kube-proxy implementation. Set to `ADVANCED_DATAPATH` to enable Dataplane v2.
     * 
     */
    public Output<String> datapathProvider() {
        return this.datapathProvider;
    }
    /**
     * The default maximum number of pods
     * per node in this cluster. This doesn&#39;t work on &#34;routes-based&#34; clusters, clusters
     * that don&#39;t have IP Aliasing enabled. See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/flexible-pod-cidr)
     * for more information.
     * 
     */
    @Export(name="defaultMaxPodsPerNode", refs={Integer.class}, tree="[0]")
    private Output<Integer> defaultMaxPodsPerNode;

    /**
     * @return The default maximum number of pods
     * per node in this cluster. This doesn&#39;t work on &#34;routes-based&#34; clusters, clusters
     * that don&#39;t have IP Aliasing enabled. See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/flexible-pod-cidr)
     * for more information.
     * 
     */
    public Output<Integer> defaultMaxPodsPerNode() {
        return this.defaultMaxPodsPerNode;
    }
    /**
     * [GKE SNAT](https://cloud.google.com/kubernetes-engine/docs/how-to/ip-masquerade-agent#how_ipmasq_works) DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, [API doc](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.locations.clusters#networkconfig). Structure is documented below
     * 
     */
    @Export(name="defaultSnatStatus", refs={ClusterDefaultSnatStatus.class}, tree="[0]")
    private Output<ClusterDefaultSnatStatus> defaultSnatStatus;

    /**
     * @return [GKE SNAT](https://cloud.google.com/kubernetes-engine/docs/how-to/ip-masquerade-agent#how_ipmasq_works) DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, [API doc](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.locations.clusters#networkconfig). Structure is documented below
     * 
     */
    public Output<ClusterDefaultSnatStatus> defaultSnatStatus() {
        return this.defaultSnatStatus;
    }
    /**
     * Whether Terraform will be prevented from
     * destroying the cluster.  Deleting this cluster via `terraform destroy` or
     * `pulumi up` will only succeed if this field is `false` in the Terraform
     * state.
     * 
     */
    @Export(name="deletionProtection", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> deletionProtection;

    /**
     * @return Whether Terraform will be prevented from
     * destroying the cluster.  Deleting this cluster via `terraform destroy` or
     * `pulumi up` will only succeed if this field is `false` in the Terraform
     * state.
     * 
     */
    public Output<Optional<Boolean>> deletionProtection() {
        return Codegen.optional(this.deletionProtection);
    }
    /**
     * Description of the cluster.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return Description of the cluster.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Disable L4 load balancer VPC firewalls to enable firewall policies.
     * 
     */
    @Export(name="disableL4LbFirewallReconciliation", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> disableL4LbFirewallReconciliation;

    /**
     * @return Disable L4 load balancer VPC firewalls to enable firewall policies.
     * 
     */
    public Output<Optional<Boolean>> disableL4LbFirewallReconciliation() {
        return Codegen.optional(this.disableL4LbFirewallReconciliation);
    }
    /**
     * Configuration for [Using Cloud DNS for GKE](https://cloud.google.com/kubernetes-engine/docs/how-to/cloud-dns). Structure is documented below.
     * 
     */
    @Export(name="dnsConfig", refs={ClusterDnsConfig.class}, tree="[0]")
    private Output</* @Nullable */ ClusterDnsConfig> dnsConfig;

    /**
     * @return Configuration for [Using Cloud DNS for GKE](https://cloud.google.com/kubernetes-engine/docs/how-to/cloud-dns). Structure is documented below.
     * 
     */
    public Output<Optional<ClusterDnsConfig>> dnsConfig() {
        return Codegen.optional(this.dnsConfig);
    }
    /**
     * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     * 
     */
    @Export(name="effectiveLabels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> effectiveLabels;

    /**
     * @return All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     * 
     */
    public Output<Map<String,String>> effectiveLabels() {
        return this.effectiveLabels;
    }
    /**
     * Enable Autopilot for this cluster. Defaults to `false`.
     * Note that when this option is enabled, certain features of Standard GKE are not available.
     * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-overview#comparison)
     * for available features.
     * 
     */
    @Export(name="enableAutopilot", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableAutopilot;

    /**
     * @return Enable Autopilot for this cluster. Defaults to `false`.
     * Note that when this option is enabled, certain features of Standard GKE are not available.
     * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-overview#comparison)
     * for available features.
     * 
     */
    public Output<Optional<Boolean>> enableAutopilot() {
        return Codegen.optional(this.enableAutopilot);
    }
    /**
     * Whether CiliumClusterWideNetworkPolicy is enabled on this cluster. Defaults to false.
     * 
     */
    @Export(name="enableCiliumClusterwideNetworkPolicy", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableCiliumClusterwideNetworkPolicy;

    /**
     * @return Whether CiliumClusterWideNetworkPolicy is enabled on this cluster. Defaults to false.
     * 
     */
    public Output<Optional<Boolean>> enableCiliumClusterwideNetworkPolicy() {
        return Codegen.optional(this.enableCiliumClusterwideNetworkPolicy);
    }
    /**
     * Whether FQDN Network Policy is enabled on this cluster. Users who enable this feature for existing Standard clusters must restart the GKE Dataplane V2 `anetd` DaemonSet after enabling it. See the [Enable FQDN Network Policy in an existing cluster](https://cloud.google.com/kubernetes-engine/docs/how-to/fqdn-network-policies#enable_fqdn_network_policy_in_an_existing_cluster) for more information.
     * 
     */
    @Export(name="enableFqdnNetworkPolicy", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableFqdnNetworkPolicy;

    /**
     * @return Whether FQDN Network Policy is enabled on this cluster. Users who enable this feature for existing Standard clusters must restart the GKE Dataplane V2 `anetd` DaemonSet after enabling it. See the [Enable FQDN Network Policy in an existing cluster](https://cloud.google.com/kubernetes-engine/docs/how-to/fqdn-network-policies#enable_fqdn_network_policy_in_an_existing_cluster) for more information.
     * 
     */
    public Output<Optional<Boolean>> enableFqdnNetworkPolicy() {
        return Codegen.optional(this.enableFqdnNetworkPolicy);
    }
    /**
     * Whether Intra-node visibility is enabled for this cluster. This makes same node pod to pod traffic visible for VPC network.
     * 
     */
    @Export(name="enableIntranodeVisibility", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> enableIntranodeVisibility;

    /**
     * @return Whether Intra-node visibility is enabled for this cluster. This makes same node pod to pod traffic visible for VPC network.
     * 
     */
    public Output<Boolean> enableIntranodeVisibility() {
        return this.enableIntranodeVisibility;
    }
    /**
     * Configuration for Kubernetes Beta APIs.
     * Structure is documented below.
     * 
     */
    @Export(name="enableK8sBetaApis", refs={ClusterEnableK8sBetaApis.class}, tree="[0]")
    private Output</* @Nullable */ ClusterEnableK8sBetaApis> enableK8sBetaApis;

    /**
     * @return Configuration for Kubernetes Beta APIs.
     * Structure is documented below.
     * 
     */
    public Output<Optional<ClusterEnableK8sBetaApis>> enableK8sBetaApis() {
        return Codegen.optional(this.enableK8sBetaApis);
    }
    /**
     * Whether to enable Kubernetes Alpha features for
     * this cluster. Note that when this option is enabled, the cluster cannot be upgraded
     * and will be automatically deleted after 30 days.
     * 
     */
    @Export(name="enableKubernetesAlpha", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableKubernetesAlpha;

    /**
     * @return Whether to enable Kubernetes Alpha features for
     * this cluster. Note that when this option is enabled, the cluster cannot be upgraded
     * and will be automatically deleted after 30 days.
     * 
     */
    public Output<Optional<Boolean>> enableKubernetesAlpha() {
        return Codegen.optional(this.enableKubernetesAlpha);
    }
    /**
     * Whether L4ILB Subsetting is enabled for this cluster.
     * 
     */
    @Export(name="enableL4IlbSubsetting", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> enableL4IlbSubsetting;

    /**
     * @return Whether L4ILB Subsetting is enabled for this cluster.
     * 
     */
    public Output<Boolean> enableL4IlbSubsetting() {
        return this.enableL4IlbSubsetting;
    }
    /**
     * Whether the ABAC authorizer is enabled for this cluster.
     * When enabled, identities in the system, including service accounts, nodes, and controllers,
     * will have statically granted permissions beyond those provided by the RBAC configuration or IAM.
     * Defaults to `false`
     * 
     */
    @Export(name="enableLegacyAbac", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableLegacyAbac;

    /**
     * @return Whether the ABAC authorizer is enabled for this cluster.
     * When enabled, identities in the system, including service accounts, nodes, and controllers,
     * will have statically granted permissions beyond those provided by the RBAC configuration or IAM.
     * Defaults to `false`
     * 
     */
    public Output<Optional<Boolean>> enableLegacyAbac() {
        return Codegen.optional(this.enableLegacyAbac);
    }
    /**
     * Whether multi-networking is enabled for this cluster.
     * 
     */
    @Export(name="enableMultiNetworking", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableMultiNetworking;

    /**
     * @return Whether multi-networking is enabled for this cluster.
     * 
     */
    public Output<Optional<Boolean>> enableMultiNetworking() {
        return Codegen.optional(this.enableMultiNetworking);
    }
    /**
     * Enable Shielded Nodes features on all nodes in this cluster.  Defaults to `true`.
     * 
     */
    @Export(name="enableShieldedNodes", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableShieldedNodes;

    /**
     * @return Enable Shielded Nodes features on all nodes in this cluster.  Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> enableShieldedNodes() {
        return Codegen.optional(this.enableShieldedNodes);
    }
    /**
     * Whether to enable Cloud TPU resources in this cluster.
     * See the [official documentation](https://cloud.google.com/tpu/docs/kubernetes-engine-setup).
     * 
     */
    @Export(name="enableTpu", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> enableTpu;

    /**
     * @return Whether to enable Cloud TPU resources in this cluster.
     * See the [official documentation](https://cloud.google.com/tpu/docs/kubernetes-engine-setup).
     * 
     */
    public Output<Boolean> enableTpu() {
        return this.enableTpu;
    }
    /**
     * The IP address of this cluster&#39;s Kubernetes master.
     * 
     */
    @Export(name="endpoint", refs={String.class}, tree="[0]")
    private Output<String> endpoint;

    /**
     * @return The IP address of this cluster&#39;s Kubernetes master.
     * 
     */
    public Output<String> endpoint() {
        return this.endpoint;
    }
    /**
     * (DEPRECATED) Configuration for [Enterprise edition].(https://cloud.google.com/kubernetes-engine/enterprise/docs/concepts/gke-editions). Structure is documented below. Deprecated as GKE Enterprise features are now available without an Enterprise tier. See https://cloud.google.com/blog/products/containers-kubernetes/gke-gets-new-pricing-and-capabilities-on-10th-birthday for the announcement of this change.
     * 
     * @deprecated
     * GKE Enterprise features are now available without an Enterprise tier. This field is deprecated and will be removed in a future major release
     * 
     */
    @Deprecated /* GKE Enterprise features are now available without an Enterprise tier. This field is deprecated and will be removed in a future major release */
    @Export(name="enterpriseConfig", refs={ClusterEnterpriseConfig.class}, tree="[0]")
    private Output<ClusterEnterpriseConfig> enterpriseConfig;

    /**
     * @return (DEPRECATED) Configuration for [Enterprise edition].(https://cloud.google.com/kubernetes-engine/enterprise/docs/concepts/gke-editions). Structure is documented below. Deprecated as GKE Enterprise features are now available without an Enterprise tier. See https://cloud.google.com/blog/products/containers-kubernetes/gke-gets-new-pricing-and-capabilities-on-10th-birthday for the announcement of this change.
     * 
     */
    public Output<ClusterEnterpriseConfig> enterpriseConfig() {
        return this.enterpriseConfig;
    }
    /**
     * Fleet configuration for the cluster. Structure is documented below.
     * 
     */
    @Export(name="fleet", refs={ClusterFleet.class}, tree="[0]")
    private Output</* @Nullable */ ClusterFleet> fleet;

    /**
     * @return Fleet configuration for the cluster. Structure is documented below.
     * 
     */
    public Output<Optional<ClusterFleet>> fleet() {
        return Codegen.optional(this.fleet);
    }
    /**
     * Configuration for [GKE Gateway API controller](https://cloud.google.com/kubernetes-engine/docs/concepts/gateway-api). Structure is documented below.
     * 
     */
    @Export(name="gatewayApiConfig", refs={ClusterGatewayApiConfig.class}, tree="[0]")
    private Output<ClusterGatewayApiConfig> gatewayApiConfig;

    /**
     * @return Configuration for [GKE Gateway API controller](https://cloud.google.com/kubernetes-engine/docs/concepts/gateway-api). Structure is documented below.
     * 
     */
    public Output<ClusterGatewayApiConfig> gatewayApiConfig() {
        return this.gatewayApiConfig;
    }
    /**
     * Configuration options for the auto-upgrade patch type feature, which provide more control over the speed of automatic upgrades of your GKE clusters.
     * Structure is documented below.
     * 
     */
    @Export(name="gkeAutoUpgradeConfig", refs={ClusterGkeAutoUpgradeConfig.class}, tree="[0]")
    private Output<ClusterGkeAutoUpgradeConfig> gkeAutoUpgradeConfig;

    /**
     * @return Configuration options for the auto-upgrade patch type feature, which provide more control over the speed of automatic upgrades of your GKE clusters.
     * Structure is documented below.
     * 
     */
    public Output<ClusterGkeAutoUpgradeConfig> gkeAutoUpgradeConfig() {
        return this.gkeAutoUpgradeConfig;
    }
    /**
     * . Structure is documented below.
     * 
     */
    @Export(name="identityServiceConfig", refs={ClusterIdentityServiceConfig.class}, tree="[0]")
    private Output<ClusterIdentityServiceConfig> identityServiceConfig;

    /**
     * @return . Structure is documented below.
     * 
     */
    public Output<ClusterIdentityServiceConfig> identityServiceConfig() {
        return this.identityServiceConfig;
    }
    /**
     * Defines the config of in-transit encryption. Valid values are `IN_TRANSIT_ENCRYPTION_DISABLED` and `IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT`.
     * 
     */
    @Export(name="inTransitEncryptionConfig", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> inTransitEncryptionConfig;

    /**
     * @return Defines the config of in-transit encryption. Valid values are `IN_TRANSIT_ENCRYPTION_DISABLED` and `IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT`.
     * 
     */
    public Output<Optional<String>> inTransitEncryptionConfig() {
        return Codegen.optional(this.inTransitEncryptionConfig);
    }
    /**
     * The number of nodes to create in this
     * cluster&#39;s default node pool. In regional or multi-zonal clusters, this is the
     * number of nodes per zone. Must be set if `nodePool` is not set. If you&#39;re using
     * `gcp.container.NodePool` objects with no default node pool, you&#39;ll need to
     * set this to a value of at least `1`, alongside setting
     * `removeDefaultNodePool` to `true`.
     * 
     */
    @Export(name="initialNodeCount", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> initialNodeCount;

    /**
     * @return The number of nodes to create in this
     * cluster&#39;s default node pool. In regional or multi-zonal clusters, this is the
     * number of nodes per zone. Must be set if `nodePool` is not set. If you&#39;re using
     * `gcp.container.NodePool` objects with no default node pool, you&#39;ll need to
     * set this to a value of at least `1`, alongside setting
     * `removeDefaultNodePool` to `true`.
     * 
     */
    public Output<Optional<Integer>> initialNodeCount() {
        return Codegen.optional(this.initialNodeCount);
    }
    /**
     * Configuration of cluster IP allocation for
     * VPC-native clusters. If this block is unset during creation, it will be set by the GKE backend.
     * Structure is documented below.
     * 
     */
    @Export(name="ipAllocationPolicy", refs={ClusterIpAllocationPolicy.class}, tree="[0]")
    private Output<ClusterIpAllocationPolicy> ipAllocationPolicy;

    /**
     * @return Configuration of cluster IP allocation for
     * VPC-native clusters. If this block is unset during creation, it will be set by the GKE backend.
     * Structure is documented below.
     * 
     */
    public Output<ClusterIpAllocationPolicy> ipAllocationPolicy() {
        return this.ipAllocationPolicy;
    }
    /**
     * The fingerprint of the set of labels for this cluster.
     * 
     */
    @Export(name="labelFingerprint", refs={String.class}, tree="[0]")
    private Output<String> labelFingerprint;

    /**
     * @return The fingerprint of the set of labels for this cluster.
     * 
     */
    public Output<String> labelFingerprint() {
        return this.labelFingerprint;
    }
    /**
     * The location (region or zone) in which the cluster
     * master will be created, as well as the default node location. If you specify a
     * zone (such as `us-central1-a`), the cluster will be a zonal cluster with a
     * single cluster master. If you specify a region (such as `us-west1`), the
     * cluster will be a regional cluster with multiple masters spread across zones in
     * the region, and with default node locations in those zones as well
     * 
     */
    @Export(name="location", refs={String.class}, tree="[0]")
    private Output<String> location;

    /**
     * @return The location (region or zone) in which the cluster
     * master will be created, as well as the default node location. If you specify a
     * zone (such as `us-central1-a`), the cluster will be a zonal cluster with a
     * single cluster master. If you specify a region (such as `us-west1`), the
     * cluster will be a regional cluster with multiple masters spread across zones in
     * the region, and with default node locations in those zones as well
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * Logging configuration for the cluster.
     * Structure is documented below.
     * 
     */
    @Export(name="loggingConfig", refs={ClusterLoggingConfig.class}, tree="[0]")
    private Output<ClusterLoggingConfig> loggingConfig;

    /**
     * @return Logging configuration for the cluster.
     * Structure is documented below.
     * 
     */
    public Output<ClusterLoggingConfig> loggingConfig() {
        return this.loggingConfig;
    }
    /**
     * The logging service that the cluster should
     * write logs to. Available options include `logging.googleapis.com`(Legacy Stackdriver),
     * `logging.googleapis.com/kubernetes`(Stackdriver Kubernetes Engine Logging), and `none`. Defaults to `logging.googleapis.com/kubernetes`
     * 
     */
    @Export(name="loggingService", refs={String.class}, tree="[0]")
    private Output<String> loggingService;

    /**
     * @return The logging service that the cluster should
     * write logs to. Available options include `logging.googleapis.com`(Legacy Stackdriver),
     * `logging.googleapis.com/kubernetes`(Stackdriver Kubernetes Engine Logging), and `none`. Defaults to `logging.googleapis.com/kubernetes`
     * 
     */
    public Output<String> loggingService() {
        return this.loggingService;
    }
    /**
     * The maintenance policy to use for the cluster. Structure is
     * documented below.
     * 
     */
    @Export(name="maintenancePolicy", refs={ClusterMaintenancePolicy.class}, tree="[0]")
    private Output</* @Nullable */ ClusterMaintenancePolicy> maintenancePolicy;

    /**
     * @return The maintenance policy to use for the cluster. Structure is
     * documented below.
     * 
     */
    public Output<Optional<ClusterMaintenancePolicy>> maintenancePolicy() {
        return Codegen.optional(this.maintenancePolicy);
    }
    /**
     * ) Configuration for the [GKE Managed OpenTelemetry](https://docs.cloud.google.com/kubernetes-engine/docs/concepts/managed-otel-gke) feature. Structure is documented below.
     * 
     */
    @Export(name="managedOpentelemetryConfig", refs={ClusterManagedOpentelemetryConfig.class}, tree="[0]")
    private Output<ClusterManagedOpentelemetryConfig> managedOpentelemetryConfig;

    /**
     * @return ) Configuration for the [GKE Managed OpenTelemetry](https://docs.cloud.google.com/kubernetes-engine/docs/concepts/managed-otel-gke) feature. Structure is documented below.
     * 
     */
    public Output<ClusterManagedOpentelemetryConfig> managedOpentelemetryConfig() {
        return this.managedOpentelemetryConfig;
    }
    /**
     * The authentication information for accessing the
     * Kubernetes master. Some values in this block are only returned by the API if
     * your service account has permission to get credentials for your GKE cluster. If
     * you see an unexpected diff unsetting your client cert, ensure you have the
     * `container.clusters.getCredentials` permission.
     * Structure is documented below.
     * 
     */
    @Export(name="masterAuth", refs={ClusterMasterAuth.class}, tree="[0]")
    private Output<ClusterMasterAuth> masterAuth;

    /**
     * @return The authentication information for accessing the
     * Kubernetes master. Some values in this block are only returned by the API if
     * your service account has permission to get credentials for your GKE cluster. If
     * you see an unexpected diff unsetting your client cert, ensure you have the
     * `container.clusters.getCredentials` permission.
     * Structure is documented below.
     * 
     */
    public Output<ClusterMasterAuth> masterAuth() {
        return this.masterAuth;
    }
    /**
     * The desired
     * configuration options for master authorized networks. Omit the
     * nested `cidrBlocks` attribute to disallow external access (except
     * the cluster node IPs, which GKE automatically whitelists).
     * Structure is documented below.
     * 
     */
    @Export(name="masterAuthorizedNetworksConfig", refs={ClusterMasterAuthorizedNetworksConfig.class}, tree="[0]")
    private Output<ClusterMasterAuthorizedNetworksConfig> masterAuthorizedNetworksConfig;

    /**
     * @return The desired
     * configuration options for master authorized networks. Omit the
     * nested `cidrBlocks` attribute to disallow external access (except
     * the cluster node IPs, which GKE automatically whitelists).
     * Structure is documented below.
     * 
     */
    public Output<ClusterMasterAuthorizedNetworksConfig> masterAuthorizedNetworksConfig() {
        return this.masterAuthorizedNetworksConfig;
    }
    /**
     * The current version of the master in the cluster. This may be different than the minMasterVersion set in the config if the master has been updated by GKE.
     * 
     */
    @Export(name="masterVersion", refs={String.class}, tree="[0]")
    private Output<String> masterVersion;

    /**
     * @return The current version of the master in the cluster. This may be different than the minMasterVersion set in the config if the master has been updated by GKE.
     * 
     */
    public Output<String> masterVersion() {
        return this.masterVersion;
    }
    /**
     * Structure is documented below.
     * 
     */
    @Export(name="meshCertificates", refs={ClusterMeshCertificates.class}, tree="[0]")
    private Output<ClusterMeshCertificates> meshCertificates;

    /**
     * @return Structure is documented below.
     * 
     */
    public Output<ClusterMeshCertificates> meshCertificates() {
        return this.meshCertificates;
    }
    /**
     * The minimum version of the master. GKE
     * will auto-update the master to new versions, so this does not guarantee the
     * current master version--use the read-only `masterVersion` field to obtain that.
     * If unset, the cluster&#39;s version will be set by GKE to the version of the most recent
     * official release (which is not necessarily the latest version).  Most users will find
     * the `gcp.container.getEngineVersions` data source useful - it indicates which versions
     * are available, and can be use to approximate fuzzy versions in a
     * Terraform-compatible way. If you intend to specify versions manually,
     * [the docs](https://cloud.google.com/kubernetes-engine/versioning-and-upgrades#specifying_cluster_version)
     * describe the various acceptable formats for this field.
     * 
     * &gt; If you are using the `gcp.container.getEngineVersions` datasource with a regional cluster, ensure that you have provided a `location`
     * to the datasource. A region can have a different set of supported versions than its corresponding zones, and not all zones in a
     * region are guaranteed to support the same version.
     * 
     */
    @Export(name="minMasterVersion", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> minMasterVersion;

    /**
     * @return The minimum version of the master. GKE
     * will auto-update the master to new versions, so this does not guarantee the
     * current master version--use the read-only `masterVersion` field to obtain that.
     * If unset, the cluster&#39;s version will be set by GKE to the version of the most recent
     * official release (which is not necessarily the latest version).  Most users will find
     * the `gcp.container.getEngineVersions` data source useful - it indicates which versions
     * are available, and can be use to approximate fuzzy versions in a
     * Terraform-compatible way. If you intend to specify versions manually,
     * [the docs](https://cloud.google.com/kubernetes-engine/versioning-and-upgrades#specifying_cluster_version)
     * describe the various acceptable formats for this field.
     * 
     * &gt; If you are using the `gcp.container.getEngineVersions` datasource with a regional cluster, ensure that you have provided a `location`
     * to the datasource. A region can have a different set of supported versions than its corresponding zones, and not all zones in a
     * region are guaranteed to support the same version.
     * 
     */
    public Output<Optional<String>> minMasterVersion() {
        return Codegen.optional(this.minMasterVersion);
    }
    /**
     * Monitoring configuration for the cluster.
     * Structure is documented below.
     * 
     */
    @Export(name="monitoringConfig", refs={ClusterMonitoringConfig.class}, tree="[0]")
    private Output<ClusterMonitoringConfig> monitoringConfig;

    /**
     * @return Monitoring configuration for the cluster.
     * Structure is documented below.
     * 
     */
    public Output<ClusterMonitoringConfig> monitoringConfig() {
        return this.monitoringConfig;
    }
    /**
     * The monitoring service that the cluster
     * should write metrics to.
     * Automatically send metrics from pods in the cluster to the Google Cloud Monitoring API.
     * VM metrics will be collected by Google Compute Engine regardless of this setting
     * Available options include
     * `monitoring.googleapis.com`(Legacy Stackdriver), `monitoring.googleapis.com/kubernetes`(Stackdriver Kubernetes Engine Monitoring), and `none`.
     * Defaults to `monitoring.googleapis.com/kubernetes`
     * 
     */
    @Export(name="monitoringService", refs={String.class}, tree="[0]")
    private Output<String> monitoringService;

    /**
     * @return The monitoring service that the cluster
     * should write metrics to.
     * Automatically send metrics from pods in the cluster to the Google Cloud Monitoring API.
     * VM metrics will be collected by Google Compute Engine regardless of this setting
     * Available options include
     * `monitoring.googleapis.com`(Legacy Stackdriver), `monitoring.googleapis.com/kubernetes`(Stackdriver Kubernetes Engine Monitoring), and `none`.
     * Defaults to `monitoring.googleapis.com/kubernetes`
     * 
     */
    public Output<String> monitoringService() {
        return this.monitoringService;
    }
    /**
     * The name of the cluster, unique within the project and
     * location.
     * 
     * ***
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the cluster, unique within the project and
     * location.
     * 
     * ***
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The name or selfLink of the Google Compute Engine
     * network to which the cluster is connected. For Shared VPC, set this to the self link of the
     * shared network.
     * 
     */
    @Export(name="network", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> network;

    /**
     * @return The name or selfLink of the Google Compute Engine
     * network to which the cluster is connected. For Shared VPC, set this to the self link of the
     * shared network.
     * 
     */
    public Output<Optional<String>> network() {
        return Codegen.optional(this.network);
    }
    /**
     * Network bandwidth tier configuration.
     * 
     */
    @Export(name="networkPerformanceConfig", refs={ClusterNetworkPerformanceConfig.class}, tree="[0]")
    private Output</* @Nullable */ ClusterNetworkPerformanceConfig> networkPerformanceConfig;

    /**
     * @return Network bandwidth tier configuration.
     * 
     */
    public Output<Optional<ClusterNetworkPerformanceConfig>> networkPerformanceConfig() {
        return Codegen.optional(this.networkPerformanceConfig);
    }
    /**
     * Configuration options for the
     * [NetworkPolicy](https://kubernetes.io/docs/concepts/services-networking/networkpolicies/)
     * feature. Structure is documented below.
     * 
     */
    @Export(name="networkPolicy", refs={ClusterNetworkPolicy.class}, tree="[0]")
    private Output</* @Nullable */ ClusterNetworkPolicy> networkPolicy;

    /**
     * @return Configuration options for the
     * [NetworkPolicy](https://kubernetes.io/docs/concepts/services-networking/networkpolicies/)
     * feature. Structure is documented below.
     * 
     */
    public Output<Optional<ClusterNetworkPolicy>> networkPolicy() {
        return Codegen.optional(this.networkPolicy);
    }
    /**
     * Determines whether alias IPs or routes will be used for pod IPs in the cluster.
     * Options are `VPC_NATIVE` or `ROUTES`. `VPC_NATIVE` enables [IP aliasing](https://cloud.google.com/kubernetes-engine/docs/how-to/ip-aliases). Newly created clusters will default to `VPC_NATIVE`.
     * 
     */
    @Export(name="networkingMode", refs={String.class}, tree="[0]")
    private Output<String> networkingMode;

    /**
     * @return Determines whether alias IPs or routes will be used for pod IPs in the cluster.
     * Options are `VPC_NATIVE` or `ROUTES`. `VPC_NATIVE` enables [IP aliasing](https://cloud.google.com/kubernetes-engine/docs/how-to/ip-aliases). Newly created clusters will default to `VPC_NATIVE`.
     * 
     */
    public Output<String> networkingMode() {
        return this.networkingMode;
    }
    /**
     * Parameters used in creating the default node pool.
     * Generally, this field should not be used at the same time as a
     * `gcp.container.NodePool` or a `nodePool` block; this configuration
     * manages the default node pool, which isn&#39;t recommended to be used with
     * Terraform. Structure is documented below.
     * 
     */
    @Export(name="nodeConfig", refs={ClusterNodeConfig.class}, tree="[0]")
    private Output<ClusterNodeConfig> nodeConfig;

    /**
     * @return Parameters used in creating the default node pool.
     * Generally, this field should not be used at the same time as a
     * `gcp.container.NodePool` or a `nodePool` block; this configuration
     * manages the default node pool, which isn&#39;t recommended to be used with
     * Terraform. Structure is documented below.
     * 
     */
    public Output<ClusterNodeConfig> nodeConfig() {
        return this.nodeConfig;
    }
    /**
     * The list of zones in which the cluster&#39;s nodes
     * are located. Nodes must be in the region of their regional cluster or in the
     * same region as their cluster&#39;s zone for zonal clusters. If this is specified for
     * a zonal cluster, omit the cluster&#39;s zone.
     * 
     * &gt; A &#34;multi-zonal&#34; cluster is a zonal cluster with at least one additional zone
     * defined; in a multi-zonal cluster, the cluster master is only present in a
     * single zone while nodes are present in each of the primary zone and the node
     * locations. In contrast, in a regional cluster, cluster master nodes are present
     * in multiple zones in the region. For that reason, regional clusters should be
     * preferred.
     * 
     */
    @Export(name="nodeLocations", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> nodeLocations;

    /**
     * @return The list of zones in which the cluster&#39;s nodes
     * are located. Nodes must be in the region of their regional cluster or in the
     * same region as their cluster&#39;s zone for zonal clusters. If this is specified for
     * a zonal cluster, omit the cluster&#39;s zone.
     * 
     * &gt; A &#34;multi-zonal&#34; cluster is a zonal cluster with at least one additional zone
     * defined; in a multi-zonal cluster, the cluster master is only present in a
     * single zone while nodes are present in each of the primary zone and the node
     * locations. In contrast, in a regional cluster, cluster master nodes are present
     * in multiple zones in the region. For that reason, regional clusters should be
     * preferred.
     * 
     */
    public Output<List<String>> nodeLocations() {
        return this.nodeLocations;
    }
    /**
     * Node pool configs that apply to auto-provisioned node pools in
     * [autopilot](https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-overview#comparison) clusters and
     * [node auto-provisioning](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning)-enabled clusters. Structure is documented below.
     * 
     */
    @Export(name="nodePoolAutoConfig", refs={ClusterNodePoolAutoConfig.class}, tree="[0]")
    private Output<ClusterNodePoolAutoConfig> nodePoolAutoConfig;

    /**
     * @return Node pool configs that apply to auto-provisioned node pools in
     * [autopilot](https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-overview#comparison) clusters and
     * [node auto-provisioning](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning)-enabled clusters. Structure is documented below.
     * 
     */
    public Output<ClusterNodePoolAutoConfig> nodePoolAutoConfig() {
        return this.nodePoolAutoConfig;
    }
    /**
     * Default NodePool settings for the entire cluster. These settings are overridden if specified on the specific NodePool object. Structure is documented below.
     * 
     */
    @Export(name="nodePoolDefaults", refs={ClusterNodePoolDefaults.class}, tree="[0]")
    private Output<ClusterNodePoolDefaults> nodePoolDefaults;

    /**
     * @return Default NodePool settings for the entire cluster. These settings are overridden if specified on the specific NodePool object. Structure is documented below.
     * 
     */
    public Output<ClusterNodePoolDefaults> nodePoolDefaults() {
        return this.nodePoolDefaults;
    }
    /**
     * List of node pools associated with this cluster.
     * See gcp.container.NodePool for schema.
     * **Warning:** node pools defined inside a cluster can&#39;t be changed (or added/removed) after
     * cluster creation without deleting and recreating the entire cluster. Unless you absolutely need the ability
     * to say &#34;these are the _only_ node pools associated with this cluster&#34;, use the
     * gcp.container.NodePool resource instead of this property.
     * 
     */
    @Export(name="nodePools", refs={List.class,ClusterNodePool.class}, tree="[0,1]")
    private Output<List<ClusterNodePool>> nodePools;

    /**
     * @return List of node pools associated with this cluster.
     * See gcp.container.NodePool for schema.
     * **Warning:** node pools defined inside a cluster can&#39;t be changed (or added/removed) after
     * cluster creation without deleting and recreating the entire cluster. Unless you absolutely need the ability
     * to say &#34;these are the _only_ node pools associated with this cluster&#34;, use the
     * gcp.container.NodePool resource instead of this property.
     * 
     */
    public Output<List<ClusterNodePool>> nodePools() {
        return this.nodePools;
    }
    /**
     * The Kubernetes version on the nodes. Must either be unset
     * or set to the same value as `minMasterVersion` on create. Defaults to the default
     * version set by GKE which is not necessarily the latest version. This only affects
     * nodes in the default node pool. While a fuzzy version can be specified, it&#39;s
     * recommended that you specify explicit versions as Terraform will see spurious diffs
     * when fuzzy versions are used. See the `gcp.container.getEngineVersions` data source&#39;s
     * `versionPrefix` field to approximate fuzzy versions in a Terraform-compatible way.
     * To update nodes in other node pools, use the `version` attribute on the node pool.
     * 
     */
    @Export(name="nodeVersion", refs={String.class}, tree="[0]")
    private Output<String> nodeVersion;

    /**
     * @return The Kubernetes version on the nodes. Must either be unset
     * or set to the same value as `minMasterVersion` on create. Defaults to the default
     * version set by GKE which is not necessarily the latest version. This only affects
     * nodes in the default node pool. While a fuzzy version can be specified, it&#39;s
     * recommended that you specify explicit versions as Terraform will see spurious diffs
     * when fuzzy versions are used. See the `gcp.container.getEngineVersions` data source&#39;s
     * `versionPrefix` field to approximate fuzzy versions in a Terraform-compatible way.
     * To update nodes in other node pools, use the `version` attribute on the node pool.
     * 
     */
    public Output<String> nodeVersion() {
        return this.nodeVersion;
    }
    /**
     * Configuration for the [cluster upgrade notifications](https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-upgrade-notifications) feature. Structure is documented below.
     * 
     */
    @Export(name="notificationConfig", refs={ClusterNotificationConfig.class}, tree="[0]")
    private Output<ClusterNotificationConfig> notificationConfig;

    /**
     * @return Configuration for the [cluster upgrade notifications](https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-upgrade-notifications) feature. Structure is documented below.
     * 
     */
    public Output<ClusterNotificationConfig> notificationConfig() {
        return this.notificationConfig;
    }
    @Export(name="operation", refs={String.class}, tree="[0]")
    private Output<String> operation;

    public Output<String> operation() {
        return this.operation;
    }
    /**
     * Configuration for the
     * Structure is documented below.
     * 
     */
    @Export(name="podAutoscaling", refs={ClusterPodAutoscaling.class}, tree="[0]")
    private Output<ClusterPodAutoscaling> podAutoscaling;

    /**
     * @return Configuration for the
     * Structure is documented below.
     * 
     */
    public Output<ClusterPodAutoscaling> podAutoscaling() {
        return this.podAutoscaling;
    }
    /**
     * ) Configuration for the
     * [PodSecurityPolicy](https://cloud.google.com/kubernetes-engine/docs/how-to/pod-security-policies) feature.
     * Structure is documented below.
     * 
     */
    @Export(name="podSecurityPolicyConfig", refs={ClusterPodSecurityPolicyConfig.class}, tree="[0]")
    private Output</* @Nullable */ ClusterPodSecurityPolicyConfig> podSecurityPolicyConfig;

    /**
     * @return ) Configuration for the
     * [PodSecurityPolicy](https://cloud.google.com/kubernetes-engine/docs/how-to/pod-security-policies) feature.
     * Structure is documented below.
     * 
     */
    public Output<Optional<ClusterPodSecurityPolicyConfig>> podSecurityPolicyConfig() {
        return Codegen.optional(this.podSecurityPolicyConfig);
    }
    /**
     * Configuration for [private clusters](https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters),
     * clusters with private nodes. Structure is documented below.
     * 
     */
    @Export(name="privateClusterConfig", refs={ClusterPrivateClusterConfig.class}, tree="[0]")
    private Output<ClusterPrivateClusterConfig> privateClusterConfig;

    /**
     * @return Configuration for [private clusters](https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters),
     * clusters with private nodes. Structure is documented below.
     * 
     */
    public Output<ClusterPrivateClusterConfig> privateClusterConfig() {
        return this.privateClusterConfig;
    }
    /**
     * The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4).
     * 
     */
    @Export(name="privateIpv6GoogleAccess", refs={String.class}, tree="[0]")
    private Output<String> privateIpv6GoogleAccess;

    /**
     * @return The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4).
     * 
     */
    public Output<String> privateIpv6GoogleAccess() {
        return this.privateIpv6GoogleAccess;
    }
    /**
     * The ID of the project in which the resource belongs. If it
     * is not provided, the provider project is used.
     * 
     */
    @Export(name="project", refs={String.class}, tree="[0]")
    private Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs. If it
     * is not provided, the provider project is used.
     * 
     */
    public Output<String> project() {
        return this.project;
    }
    /**
     * )
     * Enable/Disable Protect API features for the cluster. Structure is documented below.
     * 
     */
    @Export(name="protectConfig", refs={ClusterProtectConfig.class}, tree="[0]")
    private Output<ClusterProtectConfig> protectConfig;

    /**
     * @return )
     * Enable/Disable Protect API features for the cluster. Structure is documented below.
     * 
     */
    public Output<ClusterProtectConfig> protectConfig() {
        return this.protectConfig;
    }
    /**
     * The combination of labels configured directly on the resource and default labels configured on the provider.
     * 
     */
    @Export(name="pulumiLabels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> pulumiLabels;

    /**
     * @return The combination of labels configured directly on the resource and default labels configured on the provider.
     * 
     */
    public Output<Map<String,String>> pulumiLabels() {
        return this.pulumiLabels;
    }
    /**
     * RBACBindingConfig allows user to restrict ClusterRoleBindings an RoleBindings that can be created. Structure is documented below.
     * 
     * &lt;a name=&#34;nestedDefaultSnatStatus&#34;&gt;&lt;/a&gt;The `defaultSnatStatus` block supports
     * 
     */
    @Export(name="rbacBindingConfig", refs={ClusterRbacBindingConfig.class}, tree="[0]")
    private Output<ClusterRbacBindingConfig> rbacBindingConfig;

    /**
     * @return RBACBindingConfig allows user to restrict ClusterRoleBindings an RoleBindings that can be created. Structure is documented below.
     * 
     * &lt;a name=&#34;nestedDefaultSnatStatus&#34;&gt;&lt;/a&gt;The `defaultSnatStatus` block supports
     * 
     */
    public Output<ClusterRbacBindingConfig> rbacBindingConfig() {
        return this.rbacBindingConfig;
    }
    /**
     * Configuration options for the [Release channel](https://cloud.google.com/kubernetes-engine/docs/concepts/release-channels)
     * feature, which provide more control over automatic upgrades of your GKE clusters.
     * When updating this field, GKE imposes specific version requirements. See
     * [Selecting a new release channel](https://cloud.google.com/kubernetes-engine/docs/concepts/release-channels#selecting_a_new_release_channel)
     * for more details; the `gcp.container.getEngineVersions` datasource can provide
     * the default version for a channel. Note that removing the `releaseChannel`
     * field from your config will cause Terraform to stop managing your cluster&#39;s
     * release channel, but will not unenroll it. Instead, use the `&#34;UNSPECIFIED&#34;`
     * channel. Structure is documented below.
     * 
     */
    @Export(name="releaseChannel", refs={ClusterReleaseChannel.class}, tree="[0]")
    private Output<ClusterReleaseChannel> releaseChannel;

    /**
     * @return Configuration options for the [Release channel](https://cloud.google.com/kubernetes-engine/docs/concepts/release-channels)
     * feature, which provide more control over automatic upgrades of your GKE clusters.
     * When updating this field, GKE imposes specific version requirements. See
     * [Selecting a new release channel](https://cloud.google.com/kubernetes-engine/docs/concepts/release-channels#selecting_a_new_release_channel)
     * for more details; the `gcp.container.getEngineVersions` datasource can provide
     * the default version for a channel. Note that removing the `releaseChannel`
     * field from your config will cause Terraform to stop managing your cluster&#39;s
     * release channel, but will not unenroll it. Instead, use the `&#34;UNSPECIFIED&#34;`
     * channel. Structure is documented below.
     * 
     */
    public Output<ClusterReleaseChannel> releaseChannel() {
        return this.releaseChannel;
    }
    /**
     * If `true`, deletes the default node
     * pool upon cluster creation. If you&#39;re using `gcp.container.NodePool`
     * resources with no default node pool, this should be set to `true`, alongside
     * setting `initialNodeCount` to at least `1`.
     * 
     */
    @Export(name="removeDefaultNodePool", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> removeDefaultNodePool;

    /**
     * @return If `true`, deletes the default node
     * pool upon cluster creation. If you&#39;re using `gcp.container.NodePool`
     * resources with no default node pool, this should be set to `true`, alongside
     * setting `initialNodeCount` to at least `1`.
     * 
     */
    public Output<Optional<Boolean>> removeDefaultNodePool() {
        return Codegen.optional(this.removeDefaultNodePool);
    }
    /**
     * The GCE resource labels (a map of key/value pairs) to be applied to the cluster.
     * 
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field &#39;effective_labels&#39; for all of the labels present on the resource.
     * 
     */
    @Export(name="resourceLabels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> resourceLabels;

    /**
     * @return The GCE resource labels (a map of key/value pairs) to be applied to the cluster.
     * 
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field &#39;effective_labels&#39; for all of the labels present on the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> resourceLabels() {
        return Codegen.optional(this.resourceLabels);
    }
    /**
     * Configuration for the
     * [ResourceUsageExportConfig](https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-usage-metering) feature.
     * Structure is documented below.
     * 
     */
    @Export(name="resourceUsageExportConfig", refs={ClusterResourceUsageExportConfig.class}, tree="[0]")
    private Output</* @Nullable */ ClusterResourceUsageExportConfig> resourceUsageExportConfig;

    /**
     * @return Configuration for the
     * [ResourceUsageExportConfig](https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-usage-metering) feature.
     * Structure is documented below.
     * 
     */
    public Output<Optional<ClusterResourceUsageExportConfig>> resourceUsageExportConfig() {
        return Codegen.optional(this.resourceUsageExportConfig);
    }
    /**
     * Configuration for the
     * [SecretManagerConfig](https://cloud.google.com/secret-manager/docs/secret-manager-managed-csi-component) feature.
     * Structure is documented below.
     * 
     */
    @Export(name="secretManagerConfig", refs={ClusterSecretManagerConfig.class}, tree="[0]")
    private Output</* @Nullable */ ClusterSecretManagerConfig> secretManagerConfig;

    /**
     * @return Configuration for the
     * [SecretManagerConfig](https://cloud.google.com/secret-manager/docs/secret-manager-managed-csi-component) feature.
     * Structure is documented below.
     * 
     */
    public Output<Optional<ClusterSecretManagerConfig>> secretManagerConfig() {
        return Codegen.optional(this.secretManagerConfig);
    }
    /**
     * ) Configuration for the
     * [SecretSyncConfig](https://cloud.google.com/secret-manager/docs/sync-k8-secrets) feature.
     * Structure is documented below.
     * 
     */
    @Export(name="secretSyncConfig", refs={ClusterSecretSyncConfig.class}, tree="[0]")
    private Output</* @Nullable */ ClusterSecretSyncConfig> secretSyncConfig;

    /**
     * @return ) Configuration for the
     * [SecretSyncConfig](https://cloud.google.com/secret-manager/docs/sync-k8-secrets) feature.
     * Structure is documented below.
     * 
     */
    public Output<Optional<ClusterSecretSyncConfig>> secretSyncConfig() {
        return Codegen.optional(this.secretSyncConfig);
    }
    /**
     * Enable/Disable Security Posture API features for the cluster. Structure is documented below.
     * 
     */
    @Export(name="securityPostureConfig", refs={ClusterSecurityPostureConfig.class}, tree="[0]")
    private Output<ClusterSecurityPostureConfig> securityPostureConfig;

    /**
     * @return Enable/Disable Security Posture API features for the cluster. Structure is documented below.
     * 
     */
    public Output<ClusterSecurityPostureConfig> securityPostureConfig() {
        return this.securityPostureConfig;
    }
    /**
     * Server-defined URL for the resource.
     * 
     */
    @Export(name="selfLink", refs={String.class}, tree="[0]")
    private Output<String> selfLink;

    /**
     * @return Server-defined URL for the resource.
     * 
     */
    public Output<String> selfLink() {
        return this.selfLink;
    }
    /**
     * Structure is documented below.
     * 
     */
    @Export(name="serviceExternalIpsConfig", refs={ClusterServiceExternalIpsConfig.class}, tree="[0]")
    private Output<ClusterServiceExternalIpsConfig> serviceExternalIpsConfig;

    /**
     * @return Structure is documented below.
     * 
     */
    public Output<ClusterServiceExternalIpsConfig> serviceExternalIpsConfig() {
        return this.serviceExternalIpsConfig;
    }
    /**
     * The IP address range of the Kubernetes services in this cluster, in CIDR notation (e.g. 1.2.3.4/29). Service addresses are typically put in the last /16 from the container CIDR.
     * 
     */
    @Export(name="servicesIpv4Cidr", refs={String.class}, tree="[0]")
    private Output<String> servicesIpv4Cidr;

    /**
     * @return The IP address range of the Kubernetes services in this cluster, in CIDR notation (e.g. 1.2.3.4/29). Service addresses are typically put in the last /16 from the container CIDR.
     * 
     */
    public Output<String> servicesIpv4Cidr() {
        return this.servicesIpv4Cidr;
    }
    /**
     * The name or selfLink of the Google Compute Engine
     * subnetwork in which the cluster&#39;s instances are launched.
     * 
     */
    @Export(name="subnetwork", refs={String.class}, tree="[0]")
    private Output<String> subnetwork;

    /**
     * @return The name or selfLink of the Google Compute Engine
     * subnetwork in which the cluster&#39;s instances are launched.
     * 
     */
    public Output<String> subnetwork() {
        return this.subnetwork;
    }
    /**
     * TPU configuration for the cluster.
     * 
     */
    @Export(name="tpuConfig", refs={ClusterTpuConfig.class}, tree="[0]")
    private Output<ClusterTpuConfig> tpuConfig;

    /**
     * @return TPU configuration for the cluster.
     * 
     */
    public Output<ClusterTpuConfig> tpuConfig() {
        return this.tpuConfig;
    }
    /**
     * The IP address range of the Cloud TPUs in this cluster, in CIDR notation (e.g. 1.2.3.4/29).
     * 
     */
    @Export(name="tpuIpv4CidrBlock", refs={String.class}, tree="[0]")
    private Output<String> tpuIpv4CidrBlock;

    /**
     * @return The IP address range of the Cloud TPUs in this cluster, in CIDR notation (e.g. 1.2.3.4/29).
     * 
     */
    public Output<String> tpuIpv4CidrBlock() {
        return this.tpuIpv4CidrBlock;
    }
    /**
     * The custom keys configuration of the cluster Structure is documented below.
     * 
     */
    @Export(name="userManagedKeysConfig", refs={ClusterUserManagedKeysConfig.class}, tree="[0]")
    private Output</* @Nullable */ ClusterUserManagedKeysConfig> userManagedKeysConfig;

    /**
     * @return The custom keys configuration of the cluster Structure is documented below.
     * 
     */
    public Output<Optional<ClusterUserManagedKeysConfig>> userManagedKeysConfig() {
        return Codegen.optional(this.userManagedKeysConfig);
    }
    /**
     * Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
     * Structure is documented below.
     * 
     */
    @Export(name="verticalPodAutoscaling", refs={ClusterVerticalPodAutoscaling.class}, tree="[0]")
    private Output<ClusterVerticalPodAutoscaling> verticalPodAutoscaling;

    /**
     * @return Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
     * Structure is documented below.
     * 
     */
    public Output<ClusterVerticalPodAutoscaling> verticalPodAutoscaling() {
        return this.verticalPodAutoscaling;
    }
    /**
     * )
     * Configuration for [direct-path (via ALTS) with workload identity.](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.locations.clusters#workloadaltsconfig). Structure is documented below.
     * 
     */
    @Export(name="workloadAltsConfig", refs={ClusterWorkloadAltsConfig.class}, tree="[0]")
    private Output<ClusterWorkloadAltsConfig> workloadAltsConfig;

    /**
     * @return )
     * Configuration for [direct-path (via ALTS) with workload identity.](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.locations.clusters#workloadaltsconfig). Structure is documented below.
     * 
     */
    public Output<ClusterWorkloadAltsConfig> workloadAltsConfig() {
        return this.workloadAltsConfig;
    }
    /**
     * Workload Identity allows Kubernetes service accounts to act as a user-managed
     * [Google IAM Service Account](https://cloud.google.com/iam/docs/service-accounts#user-managed_service_accounts).
     * Structure is documented below.
     * 
     */
    @Export(name="workloadIdentityConfig", refs={ClusterWorkloadIdentityConfig.class}, tree="[0]")
    private Output<ClusterWorkloadIdentityConfig> workloadIdentityConfig;

    /**
     * @return Workload Identity allows Kubernetes service accounts to act as a user-managed
     * [Google IAM Service Account](https://cloud.google.com/iam/docs/service-accounts#user-managed_service_accounts).
     * Structure is documented below.
     * 
     */
    public Output<ClusterWorkloadIdentityConfig> workloadIdentityConfig() {
        return this.workloadIdentityConfig;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Cluster(java.lang.String name) {
        this(name, ClusterArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Cluster(java.lang.String name, @Nullable ClusterArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Cluster(java.lang.String name, @Nullable ClusterArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:container/cluster:Cluster", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Cluster(java.lang.String name, Output<java.lang.String> id, @Nullable ClusterState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:container/cluster:Cluster", name, state, makeResourceOptions(options, id), false);
    }

    private static ClusterArgs makeArgs(@Nullable ClusterArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? ClusterArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "effectiveLabels",
                "pulumiLabels"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Cluster get(java.lang.String name, Output<java.lang.String> id, @Nullable ClusterState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Cluster(name, id, state, options);
    }
}
