// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.compute.outputs.GetBackendServiceCdnPolicyBypassCacheOnRequestHeader;
import com.pulumi.gcp.compute.outputs.GetBackendServiceCdnPolicyCacheKeyPolicy;
import com.pulumi.gcp.compute.outputs.GetBackendServiceCdnPolicyNegativeCachingPolicy;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetBackendServiceCdnPolicy {
    /**
     * @return Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
     * The cache is bypassed for all cdnPolicy.cacheMode settings.
     * 
     */
    private List<GetBackendServiceCdnPolicyBypassCacheOnRequestHeader> bypassCacheOnRequestHeaders;
    /**
     * @return The CacheKeyPolicy for this CdnPolicy.
     * 
     */
    private List<GetBackendServiceCdnPolicyCacheKeyPolicy> cacheKeyPolicies;
    /**
     * @return Specifies the cache setting for all responses from this backend.
     * The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC Possible values: [&#34;USE_ORIGIN_HEADERS&#34;, &#34;FORCE_CACHE_ALL&#34;, &#34;CACHE_ALL_STATIC&#34;]
     * 
     */
    private String cacheMode;
    /**
     * @return Specifies the maximum allowed TTL for cached content served by this origin.
     * 
     */
    private Integer clientTtl;
    /**
     * @return Specifies the default TTL for cached content served by this origin for responses
     * that do not have an existing valid TTL (max-age or s-max-age).
     * 
     */
    private Integer defaultTtl;
    /**
     * @return Specifies the maximum allowed TTL for cached content served by this origin.
     * 
     */
    private Integer maxTtl;
    /**
     * @return Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
     * 
     */
    private Boolean negativeCaching;
    /**
     * @return Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
     * Omitting the policy and leaving negativeCaching enabled will use Cloud CDN&#39;s default cache TTLs.
     * 
     */
    private List<GetBackendServiceCdnPolicyNegativeCachingPolicy> negativeCachingPolicies;
    /**
     * @return If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests
     * to the origin.
     * 
     */
    private Boolean requestCoalescing;
    /**
     * @return Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
     * 
     */
    private Integer serveWhileStale;
    /**
     * @return Maximum number of seconds the response to a signed URL request
     * will be considered fresh, defaults to 1hr (3600s). After this
     * time period, the response will be revalidated before
     * being served.
     * 
     * When serving responses to signed URL requests, Cloud CDN will
     * internally behave as though all responses from this backend had a
     * &#34;Cache-Control: public, max-age=[TTL]&#34; header, regardless of any
     * existing Cache-Control header. The actual headers served in
     * responses will not be altered.
     * 
     */
    private Integer signedUrlCacheMaxAgeSec;

    private GetBackendServiceCdnPolicy() {}
    /**
     * @return Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
     * The cache is bypassed for all cdnPolicy.cacheMode settings.
     * 
     */
    public List<GetBackendServiceCdnPolicyBypassCacheOnRequestHeader> bypassCacheOnRequestHeaders() {
        return this.bypassCacheOnRequestHeaders;
    }
    /**
     * @return The CacheKeyPolicy for this CdnPolicy.
     * 
     */
    public List<GetBackendServiceCdnPolicyCacheKeyPolicy> cacheKeyPolicies() {
        return this.cacheKeyPolicies;
    }
    /**
     * @return Specifies the cache setting for all responses from this backend.
     * The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC Possible values: [&#34;USE_ORIGIN_HEADERS&#34;, &#34;FORCE_CACHE_ALL&#34;, &#34;CACHE_ALL_STATIC&#34;]
     * 
     */
    public String cacheMode() {
        return this.cacheMode;
    }
    /**
     * @return Specifies the maximum allowed TTL for cached content served by this origin.
     * 
     */
    public Integer clientTtl() {
        return this.clientTtl;
    }
    /**
     * @return Specifies the default TTL for cached content served by this origin for responses
     * that do not have an existing valid TTL (max-age or s-max-age).
     * 
     */
    public Integer defaultTtl() {
        return this.defaultTtl;
    }
    /**
     * @return Specifies the maximum allowed TTL for cached content served by this origin.
     * 
     */
    public Integer maxTtl() {
        return this.maxTtl;
    }
    /**
     * @return Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
     * 
     */
    public Boolean negativeCaching() {
        return this.negativeCaching;
    }
    /**
     * @return Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
     * Omitting the policy and leaving negativeCaching enabled will use Cloud CDN&#39;s default cache TTLs.
     * 
     */
    public List<GetBackendServiceCdnPolicyNegativeCachingPolicy> negativeCachingPolicies() {
        return this.negativeCachingPolicies;
    }
    /**
     * @return If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests
     * to the origin.
     * 
     */
    public Boolean requestCoalescing() {
        return this.requestCoalescing;
    }
    /**
     * @return Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
     * 
     */
    public Integer serveWhileStale() {
        return this.serveWhileStale;
    }
    /**
     * @return Maximum number of seconds the response to a signed URL request
     * will be considered fresh, defaults to 1hr (3600s). After this
     * time period, the response will be revalidated before
     * being served.
     * 
     * When serving responses to signed URL requests, Cloud CDN will
     * internally behave as though all responses from this backend had a
     * &#34;Cache-Control: public, max-age=[TTL]&#34; header, regardless of any
     * existing Cache-Control header. The actual headers served in
     * responses will not be altered.
     * 
     */
    public Integer signedUrlCacheMaxAgeSec() {
        return this.signedUrlCacheMaxAgeSec;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetBackendServiceCdnPolicy defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private List<GetBackendServiceCdnPolicyBypassCacheOnRequestHeader> bypassCacheOnRequestHeaders;
        private List<GetBackendServiceCdnPolicyCacheKeyPolicy> cacheKeyPolicies;
        private String cacheMode;
        private Integer clientTtl;
        private Integer defaultTtl;
        private Integer maxTtl;
        private Boolean negativeCaching;
        private List<GetBackendServiceCdnPolicyNegativeCachingPolicy> negativeCachingPolicies;
        private Boolean requestCoalescing;
        private Integer serveWhileStale;
        private Integer signedUrlCacheMaxAgeSec;
        public Builder() {}
        public Builder(GetBackendServiceCdnPolicy defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.bypassCacheOnRequestHeaders = defaults.bypassCacheOnRequestHeaders;
    	      this.cacheKeyPolicies = defaults.cacheKeyPolicies;
    	      this.cacheMode = defaults.cacheMode;
    	      this.clientTtl = defaults.clientTtl;
    	      this.defaultTtl = defaults.defaultTtl;
    	      this.maxTtl = defaults.maxTtl;
    	      this.negativeCaching = defaults.negativeCaching;
    	      this.negativeCachingPolicies = defaults.negativeCachingPolicies;
    	      this.requestCoalescing = defaults.requestCoalescing;
    	      this.serveWhileStale = defaults.serveWhileStale;
    	      this.signedUrlCacheMaxAgeSec = defaults.signedUrlCacheMaxAgeSec;
        }

        @CustomType.Setter
        public Builder bypassCacheOnRequestHeaders(List<GetBackendServiceCdnPolicyBypassCacheOnRequestHeader> bypassCacheOnRequestHeaders) {
            if (bypassCacheOnRequestHeaders == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceCdnPolicy", "bypassCacheOnRequestHeaders");
            }
            this.bypassCacheOnRequestHeaders = bypassCacheOnRequestHeaders;
            return this;
        }
        public Builder bypassCacheOnRequestHeaders(GetBackendServiceCdnPolicyBypassCacheOnRequestHeader... bypassCacheOnRequestHeaders) {
            return bypassCacheOnRequestHeaders(List.of(bypassCacheOnRequestHeaders));
        }
        @CustomType.Setter
        public Builder cacheKeyPolicies(List<GetBackendServiceCdnPolicyCacheKeyPolicy> cacheKeyPolicies) {
            if (cacheKeyPolicies == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceCdnPolicy", "cacheKeyPolicies");
            }
            this.cacheKeyPolicies = cacheKeyPolicies;
            return this;
        }
        public Builder cacheKeyPolicies(GetBackendServiceCdnPolicyCacheKeyPolicy... cacheKeyPolicies) {
            return cacheKeyPolicies(List.of(cacheKeyPolicies));
        }
        @CustomType.Setter
        public Builder cacheMode(String cacheMode) {
            if (cacheMode == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceCdnPolicy", "cacheMode");
            }
            this.cacheMode = cacheMode;
            return this;
        }
        @CustomType.Setter
        public Builder clientTtl(Integer clientTtl) {
            if (clientTtl == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceCdnPolicy", "clientTtl");
            }
            this.clientTtl = clientTtl;
            return this;
        }
        @CustomType.Setter
        public Builder defaultTtl(Integer defaultTtl) {
            if (defaultTtl == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceCdnPolicy", "defaultTtl");
            }
            this.defaultTtl = defaultTtl;
            return this;
        }
        @CustomType.Setter
        public Builder maxTtl(Integer maxTtl) {
            if (maxTtl == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceCdnPolicy", "maxTtl");
            }
            this.maxTtl = maxTtl;
            return this;
        }
        @CustomType.Setter
        public Builder negativeCaching(Boolean negativeCaching) {
            if (negativeCaching == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceCdnPolicy", "negativeCaching");
            }
            this.negativeCaching = negativeCaching;
            return this;
        }
        @CustomType.Setter
        public Builder negativeCachingPolicies(List<GetBackendServiceCdnPolicyNegativeCachingPolicy> negativeCachingPolicies) {
            if (negativeCachingPolicies == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceCdnPolicy", "negativeCachingPolicies");
            }
            this.negativeCachingPolicies = negativeCachingPolicies;
            return this;
        }
        public Builder negativeCachingPolicies(GetBackendServiceCdnPolicyNegativeCachingPolicy... negativeCachingPolicies) {
            return negativeCachingPolicies(List.of(negativeCachingPolicies));
        }
        @CustomType.Setter
        public Builder requestCoalescing(Boolean requestCoalescing) {
            if (requestCoalescing == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceCdnPolicy", "requestCoalescing");
            }
            this.requestCoalescing = requestCoalescing;
            return this;
        }
        @CustomType.Setter
        public Builder serveWhileStale(Integer serveWhileStale) {
            if (serveWhileStale == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceCdnPolicy", "serveWhileStale");
            }
            this.serveWhileStale = serveWhileStale;
            return this;
        }
        @CustomType.Setter
        public Builder signedUrlCacheMaxAgeSec(Integer signedUrlCacheMaxAgeSec) {
            if (signedUrlCacheMaxAgeSec == null) {
              throw new MissingRequiredPropertyException("GetBackendServiceCdnPolicy", "signedUrlCacheMaxAgeSec");
            }
            this.signedUrlCacheMaxAgeSec = signedUrlCacheMaxAgeSec;
            return this;
        }
        public GetBackendServiceCdnPolicy build() {
            final var _resultValue = new GetBackendServiceCdnPolicy();
            _resultValue.bypassCacheOnRequestHeaders = bypassCacheOnRequestHeaders;
            _resultValue.cacheKeyPolicies = cacheKeyPolicies;
            _resultValue.cacheMode = cacheMode;
            _resultValue.clientTtl = clientTtl;
            _resultValue.defaultTtl = defaultTtl;
            _resultValue.maxTtl = maxTtl;
            _resultValue.negativeCaching = negativeCaching;
            _resultValue.negativeCachingPolicies = negativeCachingPolicies;
            _resultValue.requestCoalescing = requestCoalescing;
            _resultValue.serveWhileStale = serveWhileStale;
            _resultValue.signedUrlCacheMaxAgeSec = signedUrlCacheMaxAgeSec;
            return _resultValue;
        }
    }
}
