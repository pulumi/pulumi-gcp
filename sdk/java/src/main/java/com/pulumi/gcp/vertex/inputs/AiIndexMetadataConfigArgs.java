// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.vertex.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.vertex.inputs.AiIndexMetadataConfigAlgorithmConfigArgs;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class AiIndexMetadataConfigArgs extends com.pulumi.resources.ResourceArgs {

    public static final AiIndexMetadataConfigArgs Empty = new AiIndexMetadataConfigArgs();

    /**
     * The configuration with regard to the algorithms used for efficient search. This field may be required based on your configuration.
     * Structure is documented below.
     * 
     */
    @Import(name="algorithmConfig")
    private @Nullable Output<AiIndexMetadataConfigAlgorithmConfigArgs> algorithmConfig;

    /**
     * @return The configuration with regard to the algorithms used for efficient search. This field may be required based on your configuration.
     * Structure is documented below.
     * 
     */
    public Optional<Output<AiIndexMetadataConfigAlgorithmConfigArgs>> algorithmConfig() {
        return Optional.ofNullable(this.algorithmConfig);
    }

    /**
     * The default number of neighbors to find via approximate search before exact reordering is
     * performed. Exact reordering is a procedure where results returned by an
     * approximate search algorithm are reordered via a more expensive distance computation.
     * Required if tree-AH algorithm is used.
     * 
     */
    @Import(name="approximateNeighborsCount")
    private @Nullable Output<Integer> approximateNeighborsCount;

    /**
     * @return The default number of neighbors to find via approximate search before exact reordering is
     * performed. Exact reordering is a procedure where results returned by an
     * approximate search algorithm are reordered via a more expensive distance computation.
     * Required if tree-AH algorithm is used.
     * 
     */
    public Optional<Output<Integer>> approximateNeighborsCount() {
        return Optional.ofNullable(this.approximateNeighborsCount);
    }

    /**
     * The number of dimensions of the input vectors.
     * 
     */
    @Import(name="dimensions", required=true)
    private Output<Integer> dimensions;

    /**
     * @return The number of dimensions of the input vectors.
     * 
     */
    public Output<Integer> dimensions() {
        return this.dimensions;
    }

    /**
     * The distance measure used in nearest neighbor search. The value must be one of the followings:
     * * SQUARED_L2_DISTANCE: Euclidean (L_2) Distance
     * * L1_DISTANCE: Manhattan (L_1) Distance
     * * COSINE_DISTANCE: Cosine Distance. Defined as 1 - cosine similarity.
     * * DOT_PRODUCT_DISTANCE: Dot Product Distance. Defined as a negative of the dot product
     * 
     */
    @Import(name="distanceMeasureType")
    private @Nullable Output<String> distanceMeasureType;

    /**
     * @return The distance measure used in nearest neighbor search. The value must be one of the followings:
     * * SQUARED_L2_DISTANCE: Euclidean (L_2) Distance
     * * L1_DISTANCE: Manhattan (L_1) Distance
     * * COSINE_DISTANCE: Cosine Distance. Defined as 1 - cosine similarity.
     * * DOT_PRODUCT_DISTANCE: Dot Product Distance. Defined as a negative of the dot product
     * 
     */
    public Optional<Output<String>> distanceMeasureType() {
        return Optional.ofNullable(this.distanceMeasureType);
    }

    /**
     * Type of normalization to be carried out on each vector. The value must be one of the followings:
     * * UNIT_L2_NORM: Unit L2 normalization type
     * * NONE: No normalization type is specified.
     * 
     */
    @Import(name="featureNormType")
    private @Nullable Output<String> featureNormType;

    /**
     * @return Type of normalization to be carried out on each vector. The value must be one of the followings:
     * * UNIT_L2_NORM: Unit L2 normalization type
     * * NONE: No normalization type is specified.
     * 
     */
    public Optional<Output<String>> featureNormType() {
        return Optional.ofNullable(this.featureNormType);
    }

    /**
     * Index data is split into equal parts to be processed. These are called &#34;shards&#34;.
     * The shard size must be specified when creating an index. The value must be one of the followings:
     * * SHARD_SIZE_SMALL: Small (2GB)
     * * SHARD_SIZE_MEDIUM: Medium (20GB)
     * * SHARD_SIZE_LARGE: Large (50GB)
     * 
     */
    @Import(name="shardSize")
    private @Nullable Output<String> shardSize;

    /**
     * @return Index data is split into equal parts to be processed. These are called &#34;shards&#34;.
     * The shard size must be specified when creating an index. The value must be one of the followings:
     * * SHARD_SIZE_SMALL: Small (2GB)
     * * SHARD_SIZE_MEDIUM: Medium (20GB)
     * * SHARD_SIZE_LARGE: Large (50GB)
     * 
     */
    public Optional<Output<String>> shardSize() {
        return Optional.ofNullable(this.shardSize);
    }

    private AiIndexMetadataConfigArgs() {}

    private AiIndexMetadataConfigArgs(AiIndexMetadataConfigArgs $) {
        this.algorithmConfig = $.algorithmConfig;
        this.approximateNeighborsCount = $.approximateNeighborsCount;
        this.dimensions = $.dimensions;
        this.distanceMeasureType = $.distanceMeasureType;
        this.featureNormType = $.featureNormType;
        this.shardSize = $.shardSize;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(AiIndexMetadataConfigArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private AiIndexMetadataConfigArgs $;

        public Builder() {
            $ = new AiIndexMetadataConfigArgs();
        }

        public Builder(AiIndexMetadataConfigArgs defaults) {
            $ = new AiIndexMetadataConfigArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param algorithmConfig The configuration with regard to the algorithms used for efficient search. This field may be required based on your configuration.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder algorithmConfig(@Nullable Output<AiIndexMetadataConfigAlgorithmConfigArgs> algorithmConfig) {
            $.algorithmConfig = algorithmConfig;
            return this;
        }

        /**
         * @param algorithmConfig The configuration with regard to the algorithms used for efficient search. This field may be required based on your configuration.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder algorithmConfig(AiIndexMetadataConfigAlgorithmConfigArgs algorithmConfig) {
            return algorithmConfig(Output.of(algorithmConfig));
        }

        /**
         * @param approximateNeighborsCount The default number of neighbors to find via approximate search before exact reordering is
         * performed. Exact reordering is a procedure where results returned by an
         * approximate search algorithm are reordered via a more expensive distance computation.
         * Required if tree-AH algorithm is used.
         * 
         * @return builder
         * 
         */
        public Builder approximateNeighborsCount(@Nullable Output<Integer> approximateNeighborsCount) {
            $.approximateNeighborsCount = approximateNeighborsCount;
            return this;
        }

        /**
         * @param approximateNeighborsCount The default number of neighbors to find via approximate search before exact reordering is
         * performed. Exact reordering is a procedure where results returned by an
         * approximate search algorithm are reordered via a more expensive distance computation.
         * Required if tree-AH algorithm is used.
         * 
         * @return builder
         * 
         */
        public Builder approximateNeighborsCount(Integer approximateNeighborsCount) {
            return approximateNeighborsCount(Output.of(approximateNeighborsCount));
        }

        /**
         * @param dimensions The number of dimensions of the input vectors.
         * 
         * @return builder
         * 
         */
        public Builder dimensions(Output<Integer> dimensions) {
            $.dimensions = dimensions;
            return this;
        }

        /**
         * @param dimensions The number of dimensions of the input vectors.
         * 
         * @return builder
         * 
         */
        public Builder dimensions(Integer dimensions) {
            return dimensions(Output.of(dimensions));
        }

        /**
         * @param distanceMeasureType The distance measure used in nearest neighbor search. The value must be one of the followings:
         * * SQUARED_L2_DISTANCE: Euclidean (L_2) Distance
         * * L1_DISTANCE: Manhattan (L_1) Distance
         * * COSINE_DISTANCE: Cosine Distance. Defined as 1 - cosine similarity.
         * * DOT_PRODUCT_DISTANCE: Dot Product Distance. Defined as a negative of the dot product
         * 
         * @return builder
         * 
         */
        public Builder distanceMeasureType(@Nullable Output<String> distanceMeasureType) {
            $.distanceMeasureType = distanceMeasureType;
            return this;
        }

        /**
         * @param distanceMeasureType The distance measure used in nearest neighbor search. The value must be one of the followings:
         * * SQUARED_L2_DISTANCE: Euclidean (L_2) Distance
         * * L1_DISTANCE: Manhattan (L_1) Distance
         * * COSINE_DISTANCE: Cosine Distance. Defined as 1 - cosine similarity.
         * * DOT_PRODUCT_DISTANCE: Dot Product Distance. Defined as a negative of the dot product
         * 
         * @return builder
         * 
         */
        public Builder distanceMeasureType(String distanceMeasureType) {
            return distanceMeasureType(Output.of(distanceMeasureType));
        }

        /**
         * @param featureNormType Type of normalization to be carried out on each vector. The value must be one of the followings:
         * * UNIT_L2_NORM: Unit L2 normalization type
         * * NONE: No normalization type is specified.
         * 
         * @return builder
         * 
         */
        public Builder featureNormType(@Nullable Output<String> featureNormType) {
            $.featureNormType = featureNormType;
            return this;
        }

        /**
         * @param featureNormType Type of normalization to be carried out on each vector. The value must be one of the followings:
         * * UNIT_L2_NORM: Unit L2 normalization type
         * * NONE: No normalization type is specified.
         * 
         * @return builder
         * 
         */
        public Builder featureNormType(String featureNormType) {
            return featureNormType(Output.of(featureNormType));
        }

        /**
         * @param shardSize Index data is split into equal parts to be processed. These are called &#34;shards&#34;.
         * The shard size must be specified when creating an index. The value must be one of the followings:
         * * SHARD_SIZE_SMALL: Small (2GB)
         * * SHARD_SIZE_MEDIUM: Medium (20GB)
         * * SHARD_SIZE_LARGE: Large (50GB)
         * 
         * @return builder
         * 
         */
        public Builder shardSize(@Nullable Output<String> shardSize) {
            $.shardSize = shardSize;
            return this;
        }

        /**
         * @param shardSize Index data is split into equal parts to be processed. These are called &#34;shards&#34;.
         * The shard size must be specified when creating an index. The value must be one of the followings:
         * * SHARD_SIZE_SMALL: Small (2GB)
         * * SHARD_SIZE_MEDIUM: Medium (20GB)
         * * SHARD_SIZE_LARGE: Large (50GB)
         * 
         * @return builder
         * 
         */
        public Builder shardSize(String shardSize) {
            return shardSize(Output.of(shardSize));
        }

        public AiIndexMetadataConfigArgs build() {
            if ($.dimensions == null) {
                throw new MissingRequiredPropertyException("AiIndexMetadataConfigArgs", "dimensions");
            }
            return $;
        }
    }

}
