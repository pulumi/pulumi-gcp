// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.vertex.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.vertex.inputs.AiDeploymentResourcePoolDedicatedResourcesAutoscalingMetricSpecArgs;
import com.pulumi.gcp.vertex.inputs.AiDeploymentResourcePoolDedicatedResourcesMachineSpecArgs;
import java.lang.Integer;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class AiDeploymentResourcePoolDedicatedResourcesArgs extends com.pulumi.resources.ResourceArgs {

    public static final AiDeploymentResourcePoolDedicatedResourcesArgs Empty = new AiDeploymentResourcePoolDedicatedResourcesArgs();

    /**
     * A list of the metric specifications that overrides a resource utilization metric.
     * Structure is documented below.
     * 
     */
    @Import(name="autoscalingMetricSpecs")
    private @Nullable Output<List<AiDeploymentResourcePoolDedicatedResourcesAutoscalingMetricSpecArgs>> autoscalingMetricSpecs;

    /**
     * @return A list of the metric specifications that overrides a resource utilization metric.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<AiDeploymentResourcePoolDedicatedResourcesAutoscalingMetricSpecArgs>>> autoscalingMetricSpecs() {
        return Optional.ofNullable(this.autoscalingMetricSpecs);
    }

    /**
     * The specification of a single machine used by the prediction
     * Structure is documented below.
     * 
     */
    @Import(name="machineSpec", required=true)
    private Output<AiDeploymentResourcePoolDedicatedResourcesMachineSpecArgs> machineSpec;

    /**
     * @return The specification of a single machine used by the prediction
     * Structure is documented below.
     * 
     */
    public Output<AiDeploymentResourcePoolDedicatedResourcesMachineSpecArgs> machineSpec() {
        return this.machineSpec;
    }

    /**
     * The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, will use minReplicaCount as the default value. The value of this field impacts the charge against Vertex CPU and GPU quotas. Specifically, you will be charged for maxReplicaCount * number of cores in the selected machine type) and (max_replica_count * number of GPUs per replica in the selected machine type).
     * 
     */
    @Import(name="maxReplicaCount")
    private @Nullable Output<Integer> maxReplicaCount;

    /**
     * @return The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, will use minReplicaCount as the default value. The value of this field impacts the charge against Vertex CPU and GPU quotas. Specifically, you will be charged for maxReplicaCount * number of cores in the selected machine type) and (max_replica_count * number of GPUs per replica in the selected machine type).
     * 
     */
    public Optional<Output<Integer>> maxReplicaCount() {
        return Optional.ofNullable(this.maxReplicaCount);
    }

    /**
     * The minimum number of machine replicas this DeployedModel will be always deployed on. This value must be greater than or equal to 1. If traffic against the DeployedModel increases, it may dynamically be deployed onto more replicas, and as traffic decreases, some of these extra replicas may be freed.
     * 
     */
    @Import(name="minReplicaCount", required=true)
    private Output<Integer> minReplicaCount;

    /**
     * @return The minimum number of machine replicas this DeployedModel will be always deployed on. This value must be greater than or equal to 1. If traffic against the DeployedModel increases, it may dynamically be deployed onto more replicas, and as traffic decreases, some of these extra replicas may be freed.
     * 
     */
    public Output<Integer> minReplicaCount() {
        return this.minReplicaCount;
    }

    private AiDeploymentResourcePoolDedicatedResourcesArgs() {}

    private AiDeploymentResourcePoolDedicatedResourcesArgs(AiDeploymentResourcePoolDedicatedResourcesArgs $) {
        this.autoscalingMetricSpecs = $.autoscalingMetricSpecs;
        this.machineSpec = $.machineSpec;
        this.maxReplicaCount = $.maxReplicaCount;
        this.minReplicaCount = $.minReplicaCount;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(AiDeploymentResourcePoolDedicatedResourcesArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private AiDeploymentResourcePoolDedicatedResourcesArgs $;

        public Builder() {
            $ = new AiDeploymentResourcePoolDedicatedResourcesArgs();
        }

        public Builder(AiDeploymentResourcePoolDedicatedResourcesArgs defaults) {
            $ = new AiDeploymentResourcePoolDedicatedResourcesArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param autoscalingMetricSpecs A list of the metric specifications that overrides a resource utilization metric.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder autoscalingMetricSpecs(@Nullable Output<List<AiDeploymentResourcePoolDedicatedResourcesAutoscalingMetricSpecArgs>> autoscalingMetricSpecs) {
            $.autoscalingMetricSpecs = autoscalingMetricSpecs;
            return this;
        }

        /**
         * @param autoscalingMetricSpecs A list of the metric specifications that overrides a resource utilization metric.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder autoscalingMetricSpecs(List<AiDeploymentResourcePoolDedicatedResourcesAutoscalingMetricSpecArgs> autoscalingMetricSpecs) {
            return autoscalingMetricSpecs(Output.of(autoscalingMetricSpecs));
        }

        /**
         * @param autoscalingMetricSpecs A list of the metric specifications that overrides a resource utilization metric.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder autoscalingMetricSpecs(AiDeploymentResourcePoolDedicatedResourcesAutoscalingMetricSpecArgs... autoscalingMetricSpecs) {
            return autoscalingMetricSpecs(List.of(autoscalingMetricSpecs));
        }

        /**
         * @param machineSpec The specification of a single machine used by the prediction
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder machineSpec(Output<AiDeploymentResourcePoolDedicatedResourcesMachineSpecArgs> machineSpec) {
            $.machineSpec = machineSpec;
            return this;
        }

        /**
         * @param machineSpec The specification of a single machine used by the prediction
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder machineSpec(AiDeploymentResourcePoolDedicatedResourcesMachineSpecArgs machineSpec) {
            return machineSpec(Output.of(machineSpec));
        }

        /**
         * @param maxReplicaCount The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, will use minReplicaCount as the default value. The value of this field impacts the charge against Vertex CPU and GPU quotas. Specifically, you will be charged for maxReplicaCount * number of cores in the selected machine type) and (max_replica_count * number of GPUs per replica in the selected machine type).
         * 
         * @return builder
         * 
         */
        public Builder maxReplicaCount(@Nullable Output<Integer> maxReplicaCount) {
            $.maxReplicaCount = maxReplicaCount;
            return this;
        }

        /**
         * @param maxReplicaCount The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, will use minReplicaCount as the default value. The value of this field impacts the charge against Vertex CPU and GPU quotas. Specifically, you will be charged for maxReplicaCount * number of cores in the selected machine type) and (max_replica_count * number of GPUs per replica in the selected machine type).
         * 
         * @return builder
         * 
         */
        public Builder maxReplicaCount(Integer maxReplicaCount) {
            return maxReplicaCount(Output.of(maxReplicaCount));
        }

        /**
         * @param minReplicaCount The minimum number of machine replicas this DeployedModel will be always deployed on. This value must be greater than or equal to 1. If traffic against the DeployedModel increases, it may dynamically be deployed onto more replicas, and as traffic decreases, some of these extra replicas may be freed.
         * 
         * @return builder
         * 
         */
        public Builder minReplicaCount(Output<Integer> minReplicaCount) {
            $.minReplicaCount = minReplicaCount;
            return this;
        }

        /**
         * @param minReplicaCount The minimum number of machine replicas this DeployedModel will be always deployed on. This value must be greater than or equal to 1. If traffic against the DeployedModel increases, it may dynamically be deployed onto more replicas, and as traffic decreases, some of these extra replicas may be freed.
         * 
         * @return builder
         * 
         */
        public Builder minReplicaCount(Integer minReplicaCount) {
            return minReplicaCount(Output.of(minReplicaCount));
        }

        public AiDeploymentResourcePoolDedicatedResourcesArgs build() {
            if ($.machineSpec == null) {
                throw new MissingRequiredPropertyException("AiDeploymentResourcePoolDedicatedResourcesArgs", "machineSpec");
            }
            if ($.minReplicaCount == null) {
                throw new MissingRequiredPropertyException("AiDeploymentResourcePoolDedicatedResourcesArgs", "minReplicaCount");
            }
            return $;
        }
    }

}
