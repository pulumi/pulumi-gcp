// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.container.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.container.outputs.GetClusterNodeConfigKubeletConfigEvictionMinimumReclaim;
import com.pulumi.gcp.container.outputs.GetClusterNodeConfigKubeletConfigEvictionSoft;
import com.pulumi.gcp.container.outputs.GetClusterNodeConfigKubeletConfigEvictionSoftGracePeriod;
import com.pulumi.gcp.container.outputs.GetClusterNodeConfigKubeletConfigMemoryManager;
import com.pulumi.gcp.container.outputs.GetClusterNodeConfigKubeletConfigTopologyManager;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetClusterNodeConfigKubeletConfig {
    /**
     * @return Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods.
     * 
     */
    private List<String> allowedUnsafeSysctls;
    /**
     * @return Defines the maximum number of container log files that can be present for a container.
     * 
     */
    private Integer containerLogMaxFiles;
    /**
     * @return Defines the maximum size of the container log file before it is rotated.
     * 
     */
    private String containerLogMaxSize;
    /**
     * @return Enable CPU CFS quota enforcement for containers that specify CPU limits.
     * 
     */
    private Boolean cpuCfsQuota;
    /**
     * @return Set the CPU CFS quota period value &#39;cpu.cfs_period_us&#39;.
     * 
     */
    private String cpuCfsQuotaPeriod;
    /**
     * @return Control the CPU management policy on the node.
     * 
     */
    private String cpuManagerPolicy;
    /**
     * @return Defines the maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.
     * 
     */
    private Integer evictionMaxPodGracePeriodSeconds;
    /**
     * @return Defines a map of signal names to percentage that defines minimum reclaims. It describes the minimum amount of a given resource the kubelet will reclaim when performing a pod eviction.
     * 
     */
    private List<GetClusterNodeConfigKubeletConfigEvictionMinimumReclaim> evictionMinimumReclaims;
    /**
     * @return Defines a map of signal names to durations that defines grace periods for soft eviction thresholds. Each soft eviction threshold must have a corresponding grace period.
     * 
     */
    private List<GetClusterNodeConfigKubeletConfigEvictionSoftGracePeriod> evictionSoftGracePeriods;
    /**
     * @return Defines a map of signal names to quantities or percentage that defines soft eviction thresholds.
     * 
     */
    private List<GetClusterNodeConfigKubeletConfigEvictionSoft> evictionSofts;
    /**
     * @return Defines the percent of disk usage after which image garbage collection is always run.
     * 
     */
    private Integer imageGcHighThresholdPercent;
    /**
     * @return Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to.
     * 
     */
    private Integer imageGcLowThresholdPercent;
    /**
     * @return Defines the maximum age an image can be unused before it is garbage collected.
     * 
     */
    private String imageMaximumGcAge;
    /**
     * @return Defines the minimum age for an unused image before it is garbage collected.
     * 
     */
    private String imageMinimumGcAge;
    /**
     * @return Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to `FALSE`. Possible values: `TRUE`, `FALSE`.
     * 
     */
    private String insecureKubeletReadonlyPortEnabled;
    /**
     * @return Set the maximum number of image pulls in parallel.
     * 
     */
    private Integer maxParallelImagePulls;
    /**
     * @return Configuration for the Memory Manager on the node. The memory manager optimizes memory and hugepages allocation for pods, especially those in the Guaranteed QoS class, by influencing NUMA affinity.
     * 
     */
    private List<GetClusterNodeConfigKubeletConfigMemoryManager> memoryManagers;
    /**
     * @return Controls the maximum number of processes allowed to run in a pod.
     * 
     */
    private Integer podPidsLimit;
    /**
     * @return Defines whether to enable single process OOM killer.
     * 
     */
    private Boolean singleProcessOomKill;
    /**
     * @return Configuration for the Topology Manager on the node. The Topology Manager aligns CPU, memory, and device resources on a node to optimize performance, especially for NUMA-aware workloads, by ensuring resource co-location.
     * 
     */
    private List<GetClusterNodeConfigKubeletConfigTopologyManager> topologyManagers;

    private GetClusterNodeConfigKubeletConfig() {}
    /**
     * @return Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods.
     * 
     */
    public List<String> allowedUnsafeSysctls() {
        return this.allowedUnsafeSysctls;
    }
    /**
     * @return Defines the maximum number of container log files that can be present for a container.
     * 
     */
    public Integer containerLogMaxFiles() {
        return this.containerLogMaxFiles;
    }
    /**
     * @return Defines the maximum size of the container log file before it is rotated.
     * 
     */
    public String containerLogMaxSize() {
        return this.containerLogMaxSize;
    }
    /**
     * @return Enable CPU CFS quota enforcement for containers that specify CPU limits.
     * 
     */
    public Boolean cpuCfsQuota() {
        return this.cpuCfsQuota;
    }
    /**
     * @return Set the CPU CFS quota period value &#39;cpu.cfs_period_us&#39;.
     * 
     */
    public String cpuCfsQuotaPeriod() {
        return this.cpuCfsQuotaPeriod;
    }
    /**
     * @return Control the CPU management policy on the node.
     * 
     */
    public String cpuManagerPolicy() {
        return this.cpuManagerPolicy;
    }
    /**
     * @return Defines the maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.
     * 
     */
    public Integer evictionMaxPodGracePeriodSeconds() {
        return this.evictionMaxPodGracePeriodSeconds;
    }
    /**
     * @return Defines a map of signal names to percentage that defines minimum reclaims. It describes the minimum amount of a given resource the kubelet will reclaim when performing a pod eviction.
     * 
     */
    public List<GetClusterNodeConfigKubeletConfigEvictionMinimumReclaim> evictionMinimumReclaims() {
        return this.evictionMinimumReclaims;
    }
    /**
     * @return Defines a map of signal names to durations that defines grace periods for soft eviction thresholds. Each soft eviction threshold must have a corresponding grace period.
     * 
     */
    public List<GetClusterNodeConfigKubeletConfigEvictionSoftGracePeriod> evictionSoftGracePeriods() {
        return this.evictionSoftGracePeriods;
    }
    /**
     * @return Defines a map of signal names to quantities or percentage that defines soft eviction thresholds.
     * 
     */
    public List<GetClusterNodeConfigKubeletConfigEvictionSoft> evictionSofts() {
        return this.evictionSofts;
    }
    /**
     * @return Defines the percent of disk usage after which image garbage collection is always run.
     * 
     */
    public Integer imageGcHighThresholdPercent() {
        return this.imageGcHighThresholdPercent;
    }
    /**
     * @return Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to.
     * 
     */
    public Integer imageGcLowThresholdPercent() {
        return this.imageGcLowThresholdPercent;
    }
    /**
     * @return Defines the maximum age an image can be unused before it is garbage collected.
     * 
     */
    public String imageMaximumGcAge() {
        return this.imageMaximumGcAge;
    }
    /**
     * @return Defines the minimum age for an unused image before it is garbage collected.
     * 
     */
    public String imageMinimumGcAge() {
        return this.imageMinimumGcAge;
    }
    /**
     * @return Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to `FALSE`. Possible values: `TRUE`, `FALSE`.
     * 
     */
    public String insecureKubeletReadonlyPortEnabled() {
        return this.insecureKubeletReadonlyPortEnabled;
    }
    /**
     * @return Set the maximum number of image pulls in parallel.
     * 
     */
    public Integer maxParallelImagePulls() {
        return this.maxParallelImagePulls;
    }
    /**
     * @return Configuration for the Memory Manager on the node. The memory manager optimizes memory and hugepages allocation for pods, especially those in the Guaranteed QoS class, by influencing NUMA affinity.
     * 
     */
    public List<GetClusterNodeConfigKubeletConfigMemoryManager> memoryManagers() {
        return this.memoryManagers;
    }
    /**
     * @return Controls the maximum number of processes allowed to run in a pod.
     * 
     */
    public Integer podPidsLimit() {
        return this.podPidsLimit;
    }
    /**
     * @return Defines whether to enable single process OOM killer.
     * 
     */
    public Boolean singleProcessOomKill() {
        return this.singleProcessOomKill;
    }
    /**
     * @return Configuration for the Topology Manager on the node. The Topology Manager aligns CPU, memory, and device resources on a node to optimize performance, especially for NUMA-aware workloads, by ensuring resource co-location.
     * 
     */
    public List<GetClusterNodeConfigKubeletConfigTopologyManager> topologyManagers() {
        return this.topologyManagers;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetClusterNodeConfigKubeletConfig defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private List<String> allowedUnsafeSysctls;
        private Integer containerLogMaxFiles;
        private String containerLogMaxSize;
        private Boolean cpuCfsQuota;
        private String cpuCfsQuotaPeriod;
        private String cpuManagerPolicy;
        private Integer evictionMaxPodGracePeriodSeconds;
        private List<GetClusterNodeConfigKubeletConfigEvictionMinimumReclaim> evictionMinimumReclaims;
        private List<GetClusterNodeConfigKubeletConfigEvictionSoftGracePeriod> evictionSoftGracePeriods;
        private List<GetClusterNodeConfigKubeletConfigEvictionSoft> evictionSofts;
        private Integer imageGcHighThresholdPercent;
        private Integer imageGcLowThresholdPercent;
        private String imageMaximumGcAge;
        private String imageMinimumGcAge;
        private String insecureKubeletReadonlyPortEnabled;
        private Integer maxParallelImagePulls;
        private List<GetClusterNodeConfigKubeletConfigMemoryManager> memoryManagers;
        private Integer podPidsLimit;
        private Boolean singleProcessOomKill;
        private List<GetClusterNodeConfigKubeletConfigTopologyManager> topologyManagers;
        public Builder() {}
        public Builder(GetClusterNodeConfigKubeletConfig defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.allowedUnsafeSysctls = defaults.allowedUnsafeSysctls;
    	      this.containerLogMaxFiles = defaults.containerLogMaxFiles;
    	      this.containerLogMaxSize = defaults.containerLogMaxSize;
    	      this.cpuCfsQuota = defaults.cpuCfsQuota;
    	      this.cpuCfsQuotaPeriod = defaults.cpuCfsQuotaPeriod;
    	      this.cpuManagerPolicy = defaults.cpuManagerPolicy;
    	      this.evictionMaxPodGracePeriodSeconds = defaults.evictionMaxPodGracePeriodSeconds;
    	      this.evictionMinimumReclaims = defaults.evictionMinimumReclaims;
    	      this.evictionSoftGracePeriods = defaults.evictionSoftGracePeriods;
    	      this.evictionSofts = defaults.evictionSofts;
    	      this.imageGcHighThresholdPercent = defaults.imageGcHighThresholdPercent;
    	      this.imageGcLowThresholdPercent = defaults.imageGcLowThresholdPercent;
    	      this.imageMaximumGcAge = defaults.imageMaximumGcAge;
    	      this.imageMinimumGcAge = defaults.imageMinimumGcAge;
    	      this.insecureKubeletReadonlyPortEnabled = defaults.insecureKubeletReadonlyPortEnabled;
    	      this.maxParallelImagePulls = defaults.maxParallelImagePulls;
    	      this.memoryManagers = defaults.memoryManagers;
    	      this.podPidsLimit = defaults.podPidsLimit;
    	      this.singleProcessOomKill = defaults.singleProcessOomKill;
    	      this.topologyManagers = defaults.topologyManagers;
        }

        @CustomType.Setter
        public Builder allowedUnsafeSysctls(List<String> allowedUnsafeSysctls) {
            if (allowedUnsafeSysctls == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "allowedUnsafeSysctls");
            }
            this.allowedUnsafeSysctls = allowedUnsafeSysctls;
            return this;
        }
        public Builder allowedUnsafeSysctls(String... allowedUnsafeSysctls) {
            return allowedUnsafeSysctls(List.of(allowedUnsafeSysctls));
        }
        @CustomType.Setter
        public Builder containerLogMaxFiles(Integer containerLogMaxFiles) {
            if (containerLogMaxFiles == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "containerLogMaxFiles");
            }
            this.containerLogMaxFiles = containerLogMaxFiles;
            return this;
        }
        @CustomType.Setter
        public Builder containerLogMaxSize(String containerLogMaxSize) {
            if (containerLogMaxSize == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "containerLogMaxSize");
            }
            this.containerLogMaxSize = containerLogMaxSize;
            return this;
        }
        @CustomType.Setter
        public Builder cpuCfsQuota(Boolean cpuCfsQuota) {
            if (cpuCfsQuota == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "cpuCfsQuota");
            }
            this.cpuCfsQuota = cpuCfsQuota;
            return this;
        }
        @CustomType.Setter
        public Builder cpuCfsQuotaPeriod(String cpuCfsQuotaPeriod) {
            if (cpuCfsQuotaPeriod == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "cpuCfsQuotaPeriod");
            }
            this.cpuCfsQuotaPeriod = cpuCfsQuotaPeriod;
            return this;
        }
        @CustomType.Setter
        public Builder cpuManagerPolicy(String cpuManagerPolicy) {
            if (cpuManagerPolicy == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "cpuManagerPolicy");
            }
            this.cpuManagerPolicy = cpuManagerPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder evictionMaxPodGracePeriodSeconds(Integer evictionMaxPodGracePeriodSeconds) {
            if (evictionMaxPodGracePeriodSeconds == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "evictionMaxPodGracePeriodSeconds");
            }
            this.evictionMaxPodGracePeriodSeconds = evictionMaxPodGracePeriodSeconds;
            return this;
        }
        @CustomType.Setter
        public Builder evictionMinimumReclaims(List<GetClusterNodeConfigKubeletConfigEvictionMinimumReclaim> evictionMinimumReclaims) {
            if (evictionMinimumReclaims == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "evictionMinimumReclaims");
            }
            this.evictionMinimumReclaims = evictionMinimumReclaims;
            return this;
        }
        public Builder evictionMinimumReclaims(GetClusterNodeConfigKubeletConfigEvictionMinimumReclaim... evictionMinimumReclaims) {
            return evictionMinimumReclaims(List.of(evictionMinimumReclaims));
        }
        @CustomType.Setter
        public Builder evictionSoftGracePeriods(List<GetClusterNodeConfigKubeletConfigEvictionSoftGracePeriod> evictionSoftGracePeriods) {
            if (evictionSoftGracePeriods == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "evictionSoftGracePeriods");
            }
            this.evictionSoftGracePeriods = evictionSoftGracePeriods;
            return this;
        }
        public Builder evictionSoftGracePeriods(GetClusterNodeConfigKubeletConfigEvictionSoftGracePeriod... evictionSoftGracePeriods) {
            return evictionSoftGracePeriods(List.of(evictionSoftGracePeriods));
        }
        @CustomType.Setter
        public Builder evictionSofts(List<GetClusterNodeConfigKubeletConfigEvictionSoft> evictionSofts) {
            if (evictionSofts == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "evictionSofts");
            }
            this.evictionSofts = evictionSofts;
            return this;
        }
        public Builder evictionSofts(GetClusterNodeConfigKubeletConfigEvictionSoft... evictionSofts) {
            return evictionSofts(List.of(evictionSofts));
        }
        @CustomType.Setter
        public Builder imageGcHighThresholdPercent(Integer imageGcHighThresholdPercent) {
            if (imageGcHighThresholdPercent == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "imageGcHighThresholdPercent");
            }
            this.imageGcHighThresholdPercent = imageGcHighThresholdPercent;
            return this;
        }
        @CustomType.Setter
        public Builder imageGcLowThresholdPercent(Integer imageGcLowThresholdPercent) {
            if (imageGcLowThresholdPercent == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "imageGcLowThresholdPercent");
            }
            this.imageGcLowThresholdPercent = imageGcLowThresholdPercent;
            return this;
        }
        @CustomType.Setter
        public Builder imageMaximumGcAge(String imageMaximumGcAge) {
            if (imageMaximumGcAge == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "imageMaximumGcAge");
            }
            this.imageMaximumGcAge = imageMaximumGcAge;
            return this;
        }
        @CustomType.Setter
        public Builder imageMinimumGcAge(String imageMinimumGcAge) {
            if (imageMinimumGcAge == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "imageMinimumGcAge");
            }
            this.imageMinimumGcAge = imageMinimumGcAge;
            return this;
        }
        @CustomType.Setter
        public Builder insecureKubeletReadonlyPortEnabled(String insecureKubeletReadonlyPortEnabled) {
            if (insecureKubeletReadonlyPortEnabled == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "insecureKubeletReadonlyPortEnabled");
            }
            this.insecureKubeletReadonlyPortEnabled = insecureKubeletReadonlyPortEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder maxParallelImagePulls(Integer maxParallelImagePulls) {
            if (maxParallelImagePulls == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "maxParallelImagePulls");
            }
            this.maxParallelImagePulls = maxParallelImagePulls;
            return this;
        }
        @CustomType.Setter
        public Builder memoryManagers(List<GetClusterNodeConfigKubeletConfigMemoryManager> memoryManagers) {
            if (memoryManagers == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "memoryManagers");
            }
            this.memoryManagers = memoryManagers;
            return this;
        }
        public Builder memoryManagers(GetClusterNodeConfigKubeletConfigMemoryManager... memoryManagers) {
            return memoryManagers(List.of(memoryManagers));
        }
        @CustomType.Setter
        public Builder podPidsLimit(Integer podPidsLimit) {
            if (podPidsLimit == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "podPidsLimit");
            }
            this.podPidsLimit = podPidsLimit;
            return this;
        }
        @CustomType.Setter
        public Builder singleProcessOomKill(Boolean singleProcessOomKill) {
            if (singleProcessOomKill == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "singleProcessOomKill");
            }
            this.singleProcessOomKill = singleProcessOomKill;
            return this;
        }
        @CustomType.Setter
        public Builder topologyManagers(List<GetClusterNodeConfigKubeletConfigTopologyManager> topologyManagers) {
            if (topologyManagers == null) {
              throw new MissingRequiredPropertyException("GetClusterNodeConfigKubeletConfig", "topologyManagers");
            }
            this.topologyManagers = topologyManagers;
            return this;
        }
        public Builder topologyManagers(GetClusterNodeConfigKubeletConfigTopologyManager... topologyManagers) {
            return topologyManagers(List.of(topologyManagers));
        }
        public GetClusterNodeConfigKubeletConfig build() {
            final var _resultValue = new GetClusterNodeConfigKubeletConfig();
            _resultValue.allowedUnsafeSysctls = allowedUnsafeSysctls;
            _resultValue.containerLogMaxFiles = containerLogMaxFiles;
            _resultValue.containerLogMaxSize = containerLogMaxSize;
            _resultValue.cpuCfsQuota = cpuCfsQuota;
            _resultValue.cpuCfsQuotaPeriod = cpuCfsQuotaPeriod;
            _resultValue.cpuManagerPolicy = cpuManagerPolicy;
            _resultValue.evictionMaxPodGracePeriodSeconds = evictionMaxPodGracePeriodSeconds;
            _resultValue.evictionMinimumReclaims = evictionMinimumReclaims;
            _resultValue.evictionSoftGracePeriods = evictionSoftGracePeriods;
            _resultValue.evictionSofts = evictionSofts;
            _resultValue.imageGcHighThresholdPercent = imageGcHighThresholdPercent;
            _resultValue.imageGcLowThresholdPercent = imageGcLowThresholdPercent;
            _resultValue.imageMaximumGcAge = imageMaximumGcAge;
            _resultValue.imageMinimumGcAge = imageMinimumGcAge;
            _resultValue.insecureKubeletReadonlyPortEnabled = insecureKubeletReadonlyPortEnabled;
            _resultValue.maxParallelImagePulls = maxParallelImagePulls;
            _resultValue.memoryManagers = memoryManagers;
            _resultValue.podPidsLimit = podPidsLimit;
            _resultValue.singleProcessOomKill = singleProcessOomKill;
            _resultValue.topologyManagers = topologyManagers;
            return _resultValue;
        }
    }
}
