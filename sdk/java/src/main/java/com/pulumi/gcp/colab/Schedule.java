// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.colab;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.colab.ScheduleArgs;
import com.pulumi.gcp.colab.inputs.ScheduleState;
import com.pulumi.gcp.colab.outputs.ScheduleCreateNotebookExecutionJobRequest;
import java.lang.Boolean;
import java.lang.String;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * &#39;Colab Enterprise Notebook Execution Schedules.&#39;
 * 
 * To get more information about Schedule, see:
 * 
 * * [API documentation](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.schedules)
 * * How-to Guides
 *     * [Schedule a notebook run](https://cloud.google.com/colab/docs/schedule-notebook-run)
 * 
 * ## Example Usage
 * 
 * ### Colab Schedule Basic
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.colab.RuntimeTemplate;
 * import com.pulumi.gcp.colab.RuntimeTemplateArgs;
 * import com.pulumi.gcp.colab.inputs.RuntimeTemplateMachineSpecArgs;
 * import com.pulumi.gcp.colab.inputs.RuntimeTemplateNetworkSpecArgs;
 * import com.pulumi.gcp.storage.Bucket;
 * import com.pulumi.gcp.storage.BucketArgs;
 * import com.pulumi.gcp.storage.BucketObject;
 * import com.pulumi.gcp.storage.BucketObjectArgs;
 * import com.pulumi.gcp.colab.Schedule;
 * import com.pulumi.gcp.colab.ScheduleArgs;
 * import com.pulumi.gcp.colab.inputs.ScheduleCreateNotebookExecutionJobRequestArgs;
 * import com.pulumi.gcp.colab.inputs.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobArgs;
 * import com.pulumi.gcp.colab.inputs.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App }{{@code
 *     public static void main(String[] args) }{{@code
 *         Pulumi.run(App::stack);
 *     }}{@code
 * 
 *     public static void stack(Context ctx) }{{@code
 *         var myRuntimeTemplate = new RuntimeTemplate("myRuntimeTemplate", RuntimeTemplateArgs.builder()
 *             .name("runtime-template")
 *             .displayName("Runtime template")
 *             .location("us-central1")
 *             .machineSpec(RuntimeTemplateMachineSpecArgs.builder()
 *                 .machineType("e2-standard-4")
 *                 .build())
 *             .networkSpec(RuntimeTemplateNetworkSpecArgs.builder()
 *                 .enableInternetAccess(true)
 *                 .build())
 *             .build());
 * 
 *         var outputBucket = new Bucket("outputBucket", BucketArgs.builder()
 *             .name("my_bucket")
 *             .location("US")
 *             .forceDestroy(true)
 *             .uniformBucketLevelAccess(true)
 *             .build());
 * 
 *         var notebook = new BucketObject("notebook", BucketObjectArgs.builder()
 *             .name("hello_world.ipynb")
 *             .bucket(outputBucket.name())
 *             .content("""
 *     }{{@code
 *       "cells": [
 *         }{{@code
 *           "cell_type": "code",
 *           "execution_count": null,
 *           "metadata": }{}{@code ,
 *           "outputs": [],
 *           "source": [
 *             "print(\"Hello, World!\")"
 *           ]
 *         }}{@code
 *       ],
 *       "metadata": }{{@code
 *         "kernelspec": }{{@code
 *           "display_name": "Python 3",
 *           "language": "python",
 *           "name": "python3"
 *         }}{@code ,
 *         "language_info": }{{@code
 *           "codemirror_mode": }{{@code
 *             "name": "ipython",
 *             "version": 3
 *           }}{@code ,
 *           "file_extension": ".py",
 *           "mimetype": "text/x-python",
 *           "name": "python",
 *           "nbconvert_exporter": "python",
 *           "pygments_lexer": "ipython3",
 *           "version": "3.8.5"
 *         }}{@code
 *       }}{@code ,
 *       "nbformat": 4,
 *       "nbformat_minor": 4
 *     }}{@code
 *             """)
 *             .build());
 * 
 *         var schedule = new Schedule("schedule", ScheduleArgs.builder()
 *             .displayName("basic-schedule")
 *             .location("us-west1")
 *             .maxConcurrentRunCount("2")
 *             .cron("TZ=America/Los_Angeles * * * * *")
 *             .createNotebookExecutionJobRequest(ScheduleCreateNotebookExecutionJobRequestArgs.builder()
 *                 .notebookExecutionJob(ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobArgs.builder()
 *                     .displayName("Notebook execution")
 *                     .gcsNotebookSource(ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceArgs.builder()
 *                         .uri(Output.tuple(notebook.bucket(), notebook.name()).applyValue(values -> }{{@code
 *                             var bucket = values.t1;
 *                             var name = values.t2;
 *                             return String.format("gs://%s/%s", bucket,name);
 *                         }}{@code ))
 *                         .generation(notebook.generation())
 *                         .build())
 *                     .notebookRuntimeTemplateResourceName(Output.tuple(myRuntimeTemplate.project(), myRuntimeTemplate.location(), myRuntimeTemplate.name()).applyValue(values -> }{{@code
 *                         var project = values.t1;
 *                         var location = values.t2;
 *                         var name = values.t3;
 *                         return String.format("projects/%s/locations/%s/notebookRuntimeTemplates/%s", project,location,name);
 *                     }}{@code ))
 *                     .gcsOutputUri(outputBucket.name().applyValue(_name -> String.format("gs://%s", _name)))
 *                     .serviceAccount("my}{@literal @}{@code service-account.com")
 *                     .build())
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(                
 *                     myRuntimeTemplate,
 *                     outputBucket)
 *                 .build());
 * 
 *     }}{@code
 * }}{@code
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Colab Schedule Paused
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.colab.RuntimeTemplate;
 * import com.pulumi.gcp.colab.RuntimeTemplateArgs;
 * import com.pulumi.gcp.colab.inputs.RuntimeTemplateMachineSpecArgs;
 * import com.pulumi.gcp.colab.inputs.RuntimeTemplateNetworkSpecArgs;
 * import com.pulumi.gcp.storage.Bucket;
 * import com.pulumi.gcp.storage.BucketArgs;
 * import com.pulumi.gcp.storage.BucketObject;
 * import com.pulumi.gcp.storage.BucketObjectArgs;
 * import com.pulumi.gcp.colab.Schedule;
 * import com.pulumi.gcp.colab.ScheduleArgs;
 * import com.pulumi.gcp.colab.inputs.ScheduleCreateNotebookExecutionJobRequestArgs;
 * import com.pulumi.gcp.colab.inputs.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobArgs;
 * import com.pulumi.gcp.colab.inputs.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App }{{@code
 *     public static void main(String[] args) }{{@code
 *         Pulumi.run(App::stack);
 *     }}{@code
 * 
 *     public static void stack(Context ctx) }{{@code
 *         var myRuntimeTemplate = new RuntimeTemplate("myRuntimeTemplate", RuntimeTemplateArgs.builder()
 *             .name("runtime-template")
 *             .displayName("Runtime template")
 *             .location("us-central1")
 *             .machineSpec(RuntimeTemplateMachineSpecArgs.builder()
 *                 .machineType("e2-standard-4")
 *                 .build())
 *             .networkSpec(RuntimeTemplateNetworkSpecArgs.builder()
 *                 .enableInternetAccess(true)
 *                 .build())
 *             .build());
 * 
 *         var outputBucket = new Bucket("outputBucket", BucketArgs.builder()
 *             .name("my_bucket")
 *             .location("US")
 *             .forceDestroy(true)
 *             .uniformBucketLevelAccess(true)
 *             .build());
 * 
 *         var notebook = new BucketObject("notebook", BucketObjectArgs.builder()
 *             .name("hello_world.ipynb")
 *             .bucket(outputBucket.name())
 *             .content("""
 *     }{{@code
 *       "cells": [
 *         }{{@code
 *           "cell_type": "code",
 *           "execution_count": null,
 *           "metadata": }{}{@code ,
 *           "outputs": [],
 *           "source": [
 *             "print(\"Hello, World!\")"
 *           ]
 *         }}{@code
 *       ],
 *       "metadata": }{{@code
 *         "kernelspec": }{{@code
 *           "display_name": "Python 3",
 *           "language": "python",
 *           "name": "python3"
 *         }}{@code ,
 *         "language_info": }{{@code
 *           "codemirror_mode": }{{@code
 *             "name": "ipython",
 *             "version": 3
 *           }}{@code ,
 *           "file_extension": ".py",
 *           "mimetype": "text/x-python",
 *           "name": "python",
 *           "nbconvert_exporter": "python",
 *           "pygments_lexer": "ipython3",
 *           "version": "3.8.5"
 *         }}{@code
 *       }}{@code ,
 *       "nbformat": 4,
 *       "nbformat_minor": 4
 *     }}{@code
 *             """)
 *             .build());
 * 
 *         var schedule = new Schedule("schedule", ScheduleArgs.builder()
 *             .displayName("paused-schedule")
 *             .location("us-west1")
 *             .maxConcurrentRunCount("2")
 *             .cron("TZ=America/Los_Angeles * * * * *")
 *             .desiredState("PAUSED")
 *             .createNotebookExecutionJobRequest(ScheduleCreateNotebookExecutionJobRequestArgs.builder()
 *                 .notebookExecutionJob(ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobArgs.builder()
 *                     .displayName("Notebook execution")
 *                     .gcsNotebookSource(ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceArgs.builder()
 *                         .uri(Output.tuple(notebook.bucket(), notebook.name()).applyValue(values -> }{{@code
 *                             var bucket = values.t1;
 *                             var name = values.t2;
 *                             return String.format("gs://%s/%s", bucket,name);
 *                         }}{@code ))
 *                         .generation(notebook.generation())
 *                         .build())
 *                     .notebookRuntimeTemplateResourceName(Output.tuple(myRuntimeTemplate.project(), myRuntimeTemplate.location(), myRuntimeTemplate.name()).applyValue(values -> }{{@code
 *                         var project = values.t1;
 *                         var location = values.t2;
 *                         var name = values.t3;
 *                         return String.format("projects/%s/locations/%s/notebookRuntimeTemplates/%s", project,location,name);
 *                     }}{@code ))
 *                     .gcsOutputUri(outputBucket.name().applyValue(_name -> String.format("gs://%s", _name)))
 *                     .serviceAccount("my}{@literal @}{@code service-account.com")
 *                     .build())
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(                
 *                     myRuntimeTemplate,
 *                     outputBucket)
 *                 .build());
 * 
 *     }}{@code
 * }}{@code
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Colab Schedule Full
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.colab.RuntimeTemplate;
 * import com.pulumi.gcp.colab.RuntimeTemplateArgs;
 * import com.pulumi.gcp.colab.inputs.RuntimeTemplateMachineSpecArgs;
 * import com.pulumi.gcp.colab.inputs.RuntimeTemplateNetworkSpecArgs;
 * import com.pulumi.gcp.storage.Bucket;
 * import com.pulumi.gcp.storage.BucketArgs;
 * import com.pulumi.gcp.secretmanager.Secret;
 * import com.pulumi.gcp.secretmanager.SecretArgs;
 * import com.pulumi.gcp.secretmanager.inputs.SecretReplicationArgs;
 * import com.pulumi.gcp.secretmanager.inputs.SecretReplicationAutoArgs;
 * import com.pulumi.gcp.secretmanager.SecretVersion;
 * import com.pulumi.gcp.secretmanager.SecretVersionArgs;
 * import com.pulumi.gcp.dataform.Repository;
 * import com.pulumi.gcp.dataform.RepositoryArgs;
 * import com.pulumi.gcp.dataform.inputs.RepositoryGitRemoteSettingsArgs;
 * import com.pulumi.gcp.dataform.inputs.RepositoryWorkspaceCompilationOverridesArgs;
 * import com.pulumi.gcp.colab.Schedule;
 * import com.pulumi.gcp.colab.ScheduleArgs;
 * import com.pulumi.gcp.colab.inputs.ScheduleCreateNotebookExecutionJobRequestArgs;
 * import com.pulumi.gcp.colab.inputs.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobArgs;
 * import com.pulumi.gcp.colab.inputs.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySourceArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App }{{@code
 *     public static void main(String[] args) }{{@code
 *         Pulumi.run(App::stack);
 *     }}{@code
 * 
 *     public static void stack(Context ctx) }{{@code
 *         var myRuntimeTemplate = new RuntimeTemplate("myRuntimeTemplate", RuntimeTemplateArgs.builder()
 *             .name("runtime-template")
 *             .displayName("Runtime template")
 *             .location("us-central1")
 *             .machineSpec(RuntimeTemplateMachineSpecArgs.builder()
 *                 .machineType("e2-standard-4")
 *                 .build())
 *             .networkSpec(RuntimeTemplateNetworkSpecArgs.builder()
 *                 .enableInternetAccess(true)
 *                 .build())
 *             .build());
 * 
 *         var outputBucket = new Bucket("outputBucket", BucketArgs.builder()
 *             .name("my_bucket")
 *             .location("US")
 *             .forceDestroy(true)
 *             .uniformBucketLevelAccess(true)
 *             .build());
 * 
 *         var secret = new Secret("secret", SecretArgs.builder()
 *             .secretId("secret")
 *             .replication(SecretReplicationArgs.builder()
 *                 .auto(SecretReplicationAutoArgs.builder()
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *         var secretVersion = new SecretVersion("secretVersion", SecretVersionArgs.builder()
 *             .secret(secret.id())
 *             .secretData("secret-data")
 *             .build());
 * 
 *         var dataformRepository = new Repository("dataformRepository", RepositoryArgs.builder()
 *             .name("dataform-repository")
 *             .displayName("dataform_repository")
 *             .npmrcEnvironmentVariablesSecretVersion(secretVersion.id())
 *             .kmsKeyName("")
 *             .labels(Map.of("label_foo1", "label-bar1"))
 *             .gitRemoteSettings(RepositoryGitRemoteSettingsArgs.builder()
 *                 .url("https://github.com/OWNER/REPOSITORY.git")
 *                 .defaultBranch("main")
 *                 .authenticationTokenSecretVersion(secretVersion.id())
 *                 .build())
 *             .workspaceCompilationOverrides(RepositoryWorkspaceCompilationOverridesArgs.builder()
 *                 .defaultDatabase("database")
 *                 .schemaSuffix("_suffix")
 *                 .tablePrefix("prefix_")
 *                 .build())
 *             .build());
 * 
 *         var schedule = new Schedule("schedule", ScheduleArgs.builder()
 *             .displayName("full-schedule")
 *             .location("us-west1")
 *             .allowQueueing(true)
 *             .maxConcurrentRunCount("2")
 *             .cron("TZ=America/Los_Angeles * * * * *")
 *             .maxRunCount("5")
 *             .startTime("2014-10-02T15:01:23Z")
 *             .endTime("2014-10-10T15:01:23Z")
 *             .desiredState("ACTIVE")
 *             .createNotebookExecutionJobRequest(ScheduleCreateNotebookExecutionJobRequestArgs.builder()
 *                 .notebookExecutionJob(ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobArgs.builder()
 *                     .displayName("Notebook execution")
 *                     .executionTimeout("86400s")
 *                     .dataformRepositorySource(ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySourceArgs.builder()
 *                         .commitSha("randomsha123")
 *                         .dataformRepositoryResourceName(dataformRepository.name().applyValue(_name -> String.format("projects/my-project-name/locations/us-west1/repositories/%s", _name)))
 *                         .build())
 *                     .notebookRuntimeTemplateResourceName(Output.tuple(myRuntimeTemplate.project(), myRuntimeTemplate.location(), myRuntimeTemplate.name()).applyValue(values -> }{{@code
 *                         var project = values.t1;
 *                         var location = values.t2;
 *                         var name = values.t3;
 *                         return String.format("projects/%s/locations/%s/notebookRuntimeTemplates/%s", project,location,name);
 *                     }}{@code ))
 *                     .gcsOutputUri(outputBucket.name().applyValue(_name -> String.format("gs://%s", _name)))
 *                     .serviceAccount("my}{@literal @}{@code service-account.com")
 *                     .build())
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(                
 *                     myRuntimeTemplate,
 *                     outputBucket,
 *                     secretVersion,
 *                     dataformRepository)
 *                 .build());
 * 
 *     }}{@code
 * }}{@code
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Import
 * 
 * Schedule can be imported using any of these accepted formats:
 * 
 * * `projects/{{project}}/locations/{{location}}/schedules/{{name}}`
 * 
 * * `{{project}}/{{location}}/{{name}}`
 * 
 * * `{{location}}/{{name}}`
 * 
 * When using the `pulumi import` command, Schedule can be imported using one of the formats above. For example:
 * 
 * ```sh
 * $ pulumi import gcp:colab/schedule:Schedule default projects/{{project}}/locations/{{location}}/schedules/{{name}}
 * ```
 * 
 * ```sh
 * $ pulumi import gcp:colab/schedule:Schedule default {{project}}/{{location}}/{{name}}
 * ```
 * 
 * ```sh
 * $ pulumi import gcp:colab/schedule:Schedule default {{location}}/{{name}}
 * ```
 * 
 */
@ResourceType(type="gcp:colab/schedule:Schedule")
public class Schedule extends com.pulumi.resources.CustomResource {
    /**
     * Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be
     * queued instead of skipped. Default to false.
     * 
     */
    @Export(name="allowQueueing", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowQueueing;

    /**
     * @return Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be
     * queued instead of skipped. Default to false.
     * 
     */
    public Output<Optional<Boolean>> allowQueueing() {
        return Codegen.optional(this.allowQueueing);
    }
    /**
     * Request for google_colab_notebook_execution.
     * Structure is documented below.
     * 
     */
    @Export(name="createNotebookExecutionJobRequest", refs={ScheduleCreateNotebookExecutionJobRequest.class}, tree="[0]")
    private Output<ScheduleCreateNotebookExecutionJobRequest> createNotebookExecutionJobRequest;

    /**
     * @return Request for google_colab_notebook_execution.
     * Structure is documented below.
     * 
     */
    public Output<ScheduleCreateNotebookExecutionJobRequest> createNotebookExecutionJobRequest() {
        return this.createNotebookExecutionJobRequest;
    }
    /**
     * Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
     * 
     */
    @Export(name="cron", refs={String.class}, tree="[0]")
    private Output<String> cron;

    /**
     * @return Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
     * 
     */
    public Output<String> cron() {
        return this.cron;
    }
    /**
     * Desired state of the Colab Schedule. Set this field to &#39;ACTIVE&#39; to start/resume the schedule, and &#39;PAUSED&#39; to pause the
     * schedule.
     * 
     */
    @Export(name="desiredState", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> desiredState;

    /**
     * @return Desired state of the Colab Schedule. Set this field to &#39;ACTIVE&#39; to start/resume the schedule, and &#39;PAUSED&#39; to pause the
     * schedule.
     * 
     */
    public Output<Optional<String>> desiredState() {
        return Codegen.optional(this.desiredState);
    }
    /**
     * Required. The display name of the Schedule.
     * 
     */
    @Export(name="displayName", refs={String.class}, tree="[0]")
    private Output<String> displayName;

    /**
     * @return Required. The display name of the Schedule.
     * 
     */
    public Output<String> displayName() {
        return this.displayName;
    }
    /**
     * Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either end_time is
     * reached or when scheduled_run_count &gt;= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt)
     * format.
     * 
     */
    @Export(name="endTime", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> endTime;

    /**
     * @return Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either end_time is
     * reached or when scheduled_run_count &gt;= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt)
     * format.
     * 
     */
    public Output<Optional<String>> endTime() {
        return Codegen.optional(this.endTime);
    }
    /**
     * The location for the resource: https://cloud.google.com/colab/docs/locations
     * 
     */
    @Export(name="location", refs={String.class}, tree="[0]")
    private Output<String> location;

    /**
     * @return The location for the resource: https://cloud.google.com/colab/docs/locations
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
     * 
     */
    @Export(name="maxConcurrentRunCount", refs={String.class}, tree="[0]")
    private Output<String> maxConcurrentRunCount;

    /**
     * @return Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
     * 
     */
    public Output<String> maxConcurrentRunCount() {
        return this.maxConcurrentRunCount;
    }
    /**
     * Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount &gt;=
     * maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is
     * paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
     * 
     */
    @Export(name="maxRunCount", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> maxRunCount;

    /**
     * @return Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount &gt;=
     * maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is
     * paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
     * 
     */
    public Output<Optional<String>> maxRunCount() {
        return Codegen.optional(this.maxRunCount);
    }
    /**
     * The resource name of the Schedule
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The resource name of the Schedule
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    @Export(name="project", refs={String.class}, tree="[0]")
    private Output<String> project;

    public Output<String> project() {
        return this.project;
    }
    /**
     * The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC
     * 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     * 
     */
    @Export(name="startTime", refs={String.class}, tree="[0]")
    private Output<String> startTime;

    /**
     * @return The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC
     * 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     * 
     */
    public Output<String> startTime() {
        return this.startTime;
    }
    /**
     * Output only. The state of the schedule.
     * 
     */
    @Export(name="state", refs={String.class}, tree="[0]")
    private Output<String> state;

    /**
     * @return Output only. The state of the schedule.
     * 
     */
    public Output<String> state() {
        return this.state;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Schedule(java.lang.String name) {
        this(name, ScheduleArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Schedule(java.lang.String name, ScheduleArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Schedule(java.lang.String name, ScheduleArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:colab/schedule:Schedule", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Schedule(java.lang.String name, Output<java.lang.String> id, @Nullable ScheduleState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:colab/schedule:Schedule", name, state, makeResourceOptions(options, id), false);
    }

    private static ScheduleArgs makeArgs(ScheduleArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? ScheduleArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Schedule get(java.lang.String name, Output<java.lang.String> id, @Nullable ScheduleState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Schedule(name, id, state, options);
    }
}
