// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.vertex.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.vertex.outputs.GetAiIndexMetadataConfigAlgorithmConfig;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetAiIndexMetadataConfig {
    /**
     * @return The configuration with regard to the algorithms used for efficient search. This field may be required based on your configuration.
     * 
     */
    private List<GetAiIndexMetadataConfigAlgorithmConfig> algorithmConfigs;
    /**
     * @return The default number of neighbors to find via approximate search before exact reordering is
     * performed. Exact reordering is a procedure where results returned by an
     * approximate search algorithm are reordered via a more expensive distance computation.
     * Required if tree-AH algorithm is used.
     * 
     */
    private Integer approximateNeighborsCount;
    /**
     * @return The number of dimensions of the input vectors.
     * 
     */
    private Integer dimensions;
    /**
     * @return The distance measure used in nearest neighbor search. The value must be one of the followings:
     * * SQUARED_L2_DISTANCE: Euclidean (L_2) Distance
     * * L1_DISTANCE: Manhattan (L_1) Distance
     * * COSINE_DISTANCE: Cosine Distance. Defined as 1 - cosine similarity.
     * * DOT_PRODUCT_DISTANCE: Dot Product Distance. Defined as a negative of the dot product
     * 
     */
    private String distanceMeasureType;
    /**
     * @return Type of normalization to be carried out on each vector. The value must be one of the followings:
     * * UNIT_L2_NORM: Unit L2 normalization type
     * * NONE: No normalization type is specified.
     * 
     */
    private String featureNormType;
    /**
     * @return Index data is split into equal parts to be processed. These are called &#34;shards&#34;.
     * The shard size must be specified when creating an index. The value must be one of the followings:
     * * SHARD_SIZE_SMALL: Small (2GB)
     * * SHARD_SIZE_MEDIUM: Medium (20GB)
     * * SHARD_SIZE_LARGE: Large (50GB)
     * 
     */
    private String shardSize;

    private GetAiIndexMetadataConfig() {}
    /**
     * @return The configuration with regard to the algorithms used for efficient search. This field may be required based on your configuration.
     * 
     */
    public List<GetAiIndexMetadataConfigAlgorithmConfig> algorithmConfigs() {
        return this.algorithmConfigs;
    }
    /**
     * @return The default number of neighbors to find via approximate search before exact reordering is
     * performed. Exact reordering is a procedure where results returned by an
     * approximate search algorithm are reordered via a more expensive distance computation.
     * Required if tree-AH algorithm is used.
     * 
     */
    public Integer approximateNeighborsCount() {
        return this.approximateNeighborsCount;
    }
    /**
     * @return The number of dimensions of the input vectors.
     * 
     */
    public Integer dimensions() {
        return this.dimensions;
    }
    /**
     * @return The distance measure used in nearest neighbor search. The value must be one of the followings:
     * * SQUARED_L2_DISTANCE: Euclidean (L_2) Distance
     * * L1_DISTANCE: Manhattan (L_1) Distance
     * * COSINE_DISTANCE: Cosine Distance. Defined as 1 - cosine similarity.
     * * DOT_PRODUCT_DISTANCE: Dot Product Distance. Defined as a negative of the dot product
     * 
     */
    public String distanceMeasureType() {
        return this.distanceMeasureType;
    }
    /**
     * @return Type of normalization to be carried out on each vector. The value must be one of the followings:
     * * UNIT_L2_NORM: Unit L2 normalization type
     * * NONE: No normalization type is specified.
     * 
     */
    public String featureNormType() {
        return this.featureNormType;
    }
    /**
     * @return Index data is split into equal parts to be processed. These are called &#34;shards&#34;.
     * The shard size must be specified when creating an index. The value must be one of the followings:
     * * SHARD_SIZE_SMALL: Small (2GB)
     * * SHARD_SIZE_MEDIUM: Medium (20GB)
     * * SHARD_SIZE_LARGE: Large (50GB)
     * 
     */
    public String shardSize() {
        return this.shardSize;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetAiIndexMetadataConfig defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private List<GetAiIndexMetadataConfigAlgorithmConfig> algorithmConfigs;
        private Integer approximateNeighborsCount;
        private Integer dimensions;
        private String distanceMeasureType;
        private String featureNormType;
        private String shardSize;
        public Builder() {}
        public Builder(GetAiIndexMetadataConfig defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.algorithmConfigs = defaults.algorithmConfigs;
    	      this.approximateNeighborsCount = defaults.approximateNeighborsCount;
    	      this.dimensions = defaults.dimensions;
    	      this.distanceMeasureType = defaults.distanceMeasureType;
    	      this.featureNormType = defaults.featureNormType;
    	      this.shardSize = defaults.shardSize;
        }

        @CustomType.Setter
        public Builder algorithmConfigs(List<GetAiIndexMetadataConfigAlgorithmConfig> algorithmConfigs) {
            if (algorithmConfigs == null) {
              throw new MissingRequiredPropertyException("GetAiIndexMetadataConfig", "algorithmConfigs");
            }
            this.algorithmConfigs = algorithmConfigs;
            return this;
        }
        public Builder algorithmConfigs(GetAiIndexMetadataConfigAlgorithmConfig... algorithmConfigs) {
            return algorithmConfigs(List.of(algorithmConfigs));
        }
        @CustomType.Setter
        public Builder approximateNeighborsCount(Integer approximateNeighborsCount) {
            if (approximateNeighborsCount == null) {
              throw new MissingRequiredPropertyException("GetAiIndexMetadataConfig", "approximateNeighborsCount");
            }
            this.approximateNeighborsCount = approximateNeighborsCount;
            return this;
        }
        @CustomType.Setter
        public Builder dimensions(Integer dimensions) {
            if (dimensions == null) {
              throw new MissingRequiredPropertyException("GetAiIndexMetadataConfig", "dimensions");
            }
            this.dimensions = dimensions;
            return this;
        }
        @CustomType.Setter
        public Builder distanceMeasureType(String distanceMeasureType) {
            if (distanceMeasureType == null) {
              throw new MissingRequiredPropertyException("GetAiIndexMetadataConfig", "distanceMeasureType");
            }
            this.distanceMeasureType = distanceMeasureType;
            return this;
        }
        @CustomType.Setter
        public Builder featureNormType(String featureNormType) {
            if (featureNormType == null) {
              throw new MissingRequiredPropertyException("GetAiIndexMetadataConfig", "featureNormType");
            }
            this.featureNormType = featureNormType;
            return this;
        }
        @CustomType.Setter
        public Builder shardSize(String shardSize) {
            if (shardSize == null) {
              throw new MissingRequiredPropertyException("GetAiIndexMetadataConfig", "shardSize");
            }
            this.shardSize = shardSize;
            return this;
        }
        public GetAiIndexMetadataConfig build() {
            final var _resultValue = new GetAiIndexMetadataConfig();
            _resultValue.algorithmConfigs = algorithmConfigs;
            _resultValue.approximateNeighborsCount = approximateNeighborsCount;
            _resultValue.dimensions = dimensions;
            _resultValue.distanceMeasureType = distanceMeasureType;
            _resultValue.featureNormType = featureNormType;
            _resultValue.shardSize = shardSize;
            return _resultValue;
        }
    }
}
