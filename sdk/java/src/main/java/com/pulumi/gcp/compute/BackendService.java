// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.compute.BackendServiceArgs;
import com.pulumi.gcp.compute.inputs.BackendServiceState;
import com.pulumi.gcp.compute.outputs.BackendServiceBackend;
import com.pulumi.gcp.compute.outputs.BackendServiceCdnPolicy;
import com.pulumi.gcp.compute.outputs.BackendServiceCircuitBreakers;
import com.pulumi.gcp.compute.outputs.BackendServiceConsistentHash;
import com.pulumi.gcp.compute.outputs.BackendServiceIap;
import com.pulumi.gcp.compute.outputs.BackendServiceLocalityLbPolicy;
import com.pulumi.gcp.compute.outputs.BackendServiceLogConfig;
import com.pulumi.gcp.compute.outputs.BackendServiceOutlierDetection;
import com.pulumi.gcp.compute.outputs.BackendServiceSecuritySettings;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * A Backend Service defines a group of virtual machines that will serve
 * traffic for load balancing. This resource is a global backend service,
 * appropriate for external load balancing or self-managed internal load balancing.
 * For managed internal load balancing, use a regional backend service instead.
 * 
 * Currently self-managed internal load balancing is only available in beta.
 * 
 * To get more information about BackendService, see:
 * 
 * * [API documentation](https://cloud.google.com/compute/docs/reference/v1/backendServices)
 * * How-to Guides
 *     * [Official Documentation](https://cloud.google.com/compute/docs/load-balancing/http/backend-service)
 * 
 * &gt; **Warning:** All arguments including `iap.oauth2_client_secret` and `iap.oauth2_client_secret_sha256` will be stored in the raw
 * state as plain-text.
 * 
 * ## Example Usage
 * ### Backend Service Basic
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HttpHealthCheck;
 * import com.pulumi.gcp.compute.HttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var defaultHttpHealthCheck = new HttpHealthCheck(&#34;defaultHttpHealthCheck&#34;, HttpHealthCheckArgs.builder()        
 *             .requestPath(&#34;/&#34;)
 *             .checkIntervalSec(1)
 *             .timeoutSec(1)
 *             .build());
 * 
 *         var defaultBackendService = new BackendService(&#34;defaultBackendService&#34;, BackendServiceArgs.builder()        
 *             .healthChecks(defaultHttpHealthCheck.id())
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### Backend Service Cache Simple
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HttpHealthCheck;
 * import com.pulumi.gcp.compute.HttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceCdnPolicyArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var defaultHttpHealthCheck = new HttpHealthCheck(&#34;defaultHttpHealthCheck&#34;, HttpHealthCheckArgs.builder()        
 *             .requestPath(&#34;/&#34;)
 *             .checkIntervalSec(1)
 *             .timeoutSec(1)
 *             .build());
 * 
 *         var defaultBackendService = new BackendService(&#34;defaultBackendService&#34;, BackendServiceArgs.builder()        
 *             .healthChecks(defaultHttpHealthCheck.id())
 *             .enableCdn(true)
 *             .cdnPolicy(BackendServiceCdnPolicyArgs.builder()
 *                 .signedUrlCacheMaxAgeSec(7200)
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### Backend Service Cache Include Http Headers
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceCdnPolicyArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceCdnPolicyCacheKeyPolicyArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new BackendService(&#34;default&#34;, BackendServiceArgs.builder()        
 *             .cdnPolicy(BackendServiceCdnPolicyArgs.builder()
 *                 .cacheKeyPolicy(BackendServiceCdnPolicyCacheKeyPolicyArgs.builder()
 *                     .includeHost(true)
 *                     .includeHttpHeaders(&#34;X-My-Header-Field&#34;)
 *                     .includeProtocol(true)
 *                     .includeQueryString(true)
 *                     .build())
 *                 .cacheMode(&#34;USE_ORIGIN_HEADERS&#34;)
 *                 .build())
 *             .enableCdn(true)
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### Backend Service Cache Include Named Cookies
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceCdnPolicyArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceCdnPolicyCacheKeyPolicyArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new BackendService(&#34;default&#34;, BackendServiceArgs.builder()        
 *             .cdnPolicy(BackendServiceCdnPolicyArgs.builder()
 *                 .cacheKeyPolicy(BackendServiceCdnPolicyCacheKeyPolicyArgs.builder()
 *                     .includeHost(true)
 *                     .includeNamedCookies(                    
 *                         &#34;__next_preview_data&#34;,
 *                         &#34;__prerender_bypass&#34;)
 *                     .includeProtocol(true)
 *                     .includeQueryString(true)
 *                     .build())
 *                 .cacheMode(&#34;CACHE_ALL_STATIC&#34;)
 *                 .clientTtl(7200)
 *                 .defaultTtl(3600)
 *                 .maxTtl(10800)
 *                 .build())
 *             .enableCdn(true)
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### Backend Service Cache
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HttpHealthCheck;
 * import com.pulumi.gcp.compute.HttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceCdnPolicyArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var defaultHttpHealthCheck = new HttpHealthCheck(&#34;defaultHttpHealthCheck&#34;, HttpHealthCheckArgs.builder()        
 *             .requestPath(&#34;/&#34;)
 *             .checkIntervalSec(1)
 *             .timeoutSec(1)
 *             .build());
 * 
 *         var defaultBackendService = new BackendService(&#34;defaultBackendService&#34;, BackendServiceArgs.builder()        
 *             .healthChecks(defaultHttpHealthCheck.id())
 *             .enableCdn(true)
 *             .cdnPolicy(BackendServiceCdnPolicyArgs.builder()
 *                 .cacheMode(&#34;CACHE_ALL_STATIC&#34;)
 *                 .defaultTtl(3600)
 *                 .clientTtl(7200)
 *                 .maxTtl(10800)
 *                 .negativeCaching(true)
 *                 .signedUrlCacheMaxAgeSec(7200)
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### Backend Service Traffic Director Round Robin
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var healthCheck = new HealthCheck(&#34;healthCheck&#34;, HealthCheckArgs.builder()        
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var default_ = new BackendService(&#34;default&#34;, BackendServiceArgs.builder()        
 *             .healthChecks(healthCheck.id())
 *             .loadBalancingScheme(&#34;INTERNAL_SELF_MANAGED&#34;)
 *             .localityLbPolicy(&#34;ROUND_ROBIN&#34;)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *     }
 * }
 * ```
 * ### Backend Service Traffic Director Ring Hash
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceCircuitBreakersArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceConsistentHashArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceConsistentHashHttpCookieArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceConsistentHashHttpCookieTtlArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceOutlierDetectionArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var healthCheck = new HealthCheck(&#34;healthCheck&#34;, HealthCheckArgs.builder()        
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var default_ = new BackendService(&#34;default&#34;, BackendServiceArgs.builder()        
 *             .healthChecks(healthCheck.id())
 *             .loadBalancingScheme(&#34;INTERNAL_SELF_MANAGED&#34;)
 *             .localityLbPolicy(&#34;RING_HASH&#34;)
 *             .sessionAffinity(&#34;HTTP_COOKIE&#34;)
 *             .circuitBreakers(BackendServiceCircuitBreakersArgs.builder()
 *                 .maxConnections(10)
 *                 .build())
 *             .consistentHash(BackendServiceConsistentHashArgs.builder()
 *                 .httpCookie(BackendServiceConsistentHashHttpCookieArgs.builder()
 *                     .ttl(BackendServiceConsistentHashHttpCookieTtlArgs.builder()
 *                         .seconds(11)
 *                         .nanos(1111)
 *                         .build())
 *                     .name(&#34;mycookie&#34;)
 *                     .build())
 *                 .build())
 *             .outlierDetection(BackendServiceOutlierDetectionArgs.builder()
 *                 .consecutiveErrors(2)
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *     }
 * }
 * ```
 * ### Backend Service Network Endpoint
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.GlobalNetworkEndpointGroup;
 * import com.pulumi.gcp.compute.GlobalNetworkEndpointGroupArgs;
 * import com.pulumi.gcp.compute.GlobalNetworkEndpoint;
 * import com.pulumi.gcp.compute.GlobalNetworkEndpointArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import com.pulumi.gcp.compute.inputs.BackendServiceBackendArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var externalProxy = new GlobalNetworkEndpointGroup(&#34;externalProxy&#34;, GlobalNetworkEndpointGroupArgs.builder()        
 *             .networkEndpointType(&#34;INTERNET_FQDN_PORT&#34;)
 *             .defaultPort(&#34;443&#34;)
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var proxy = new GlobalNetworkEndpoint(&#34;proxy&#34;, GlobalNetworkEndpointArgs.builder()        
 *             .globalNetworkEndpointGroup(externalProxy.id())
 *             .fqdn(&#34;test.example.com&#34;)
 *             .port(externalProxy.defaultPort())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *         var default_ = new BackendService(&#34;default&#34;, BackendServiceArgs.builder()        
 *             .enableCdn(true)
 *             .timeoutSec(10)
 *             .connectionDrainingTimeoutSec(10)
 *             .customRequestHeaders(proxy.fqdn().applyValue(fqdn -&gt; String.format(&#34;host: %s&#34;, fqdn)))
 *             .customResponseHeaders(&#34;X-Cache-Hit: {cdn_cache_status}&#34;)
 *             .backends(BackendServiceBackendArgs.builder()
 *                 .group(externalProxy.id())
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .provider(google_beta)
 *                 .build());
 * 
 *     }
 * }
 * ```
 * ### Backend Service External Managed
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.HealthCheck;
 * import com.pulumi.gcp.compute.HealthCheckArgs;
 * import com.pulumi.gcp.compute.inputs.HealthCheckHttpHealthCheckArgs;
 * import com.pulumi.gcp.compute.BackendService;
 * import com.pulumi.gcp.compute.BackendServiceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var defaultHealthCheck = new HealthCheck(&#34;defaultHealthCheck&#34;, HealthCheckArgs.builder()        
 *             .httpHealthCheck(HealthCheckHttpHealthCheckArgs.builder()
 *                 .port(80)
 *                 .build())
 *             .build());
 * 
 *         var defaultBackendService = new BackendService(&#34;defaultBackendService&#34;, BackendServiceArgs.builder()        
 *             .healthChecks(defaultHealthCheck.id())
 *             .loadBalancingScheme(&#34;EXTERNAL_MANAGED&#34;)
 *             .build());
 * 
 *     }
 * }
 * ```
 * 
 * ## Import
 * 
 * BackendService can be imported using any of these accepted formats
 * 
 * ```sh
 *  $ pulumi import gcp:compute/backendService:BackendService default projects/{{project}}/global/backendServices/{{name}}
 * ```
 * 
 * ```sh
 *  $ pulumi import gcp:compute/backendService:BackendService default {{project}}/{{name}}
 * ```
 * 
 * ```sh
 *  $ pulumi import gcp:compute/backendService:BackendService default {{name}}
 * ```
 * 
 */
@ResourceType(type="gcp:compute/backendService:BackendService")
public class BackendService extends com.pulumi.resources.CustomResource {
    /**
     * Lifetime of cookies in seconds if session_affinity is
     * GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
     * only until the end of the browser session (or equivalent). The
     * maximum allowed value for TTL is one day.
     * When the load balancing scheme is INTERNAL, this field is not used.
     * 
     */
    @Export(name="affinityCookieTtlSec", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> affinityCookieTtlSec;

    /**
     * @return Lifetime of cookies in seconds if session_affinity is
     * GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
     * only until the end of the browser session (or equivalent). The
     * maximum allowed value for TTL is one day.
     * When the load balancing scheme is INTERNAL, this field is not used.
     * 
     */
    public Output<Optional<Integer>> affinityCookieTtlSec() {
        return Codegen.optional(this.affinityCookieTtlSec);
    }
    /**
     * The set of backends that serve this BackendService.
     * Structure is documented below.
     * 
     */
    @Export(name="backends", type=List.class, parameters={BackendServiceBackend.class})
    private Output</* @Nullable */ List<BackendServiceBackend>> backends;

    /**
     * @return The set of backends that serve this BackendService.
     * Structure is documented below.
     * 
     */
    public Output<Optional<List<BackendServiceBackend>>> backends() {
        return Codegen.optional(this.backends);
    }
    /**
     * Cloud CDN configuration for this BackendService.
     * Structure is documented below.
     * 
     */
    @Export(name="cdnPolicy", type=BackendServiceCdnPolicy.class, parameters={})
    private Output<BackendServiceCdnPolicy> cdnPolicy;

    /**
     * @return Cloud CDN configuration for this BackendService.
     * Structure is documented below.
     * 
     */
    public Output<BackendServiceCdnPolicy> cdnPolicy() {
        return this.cdnPolicy;
    }
    /**
     * Settings controlling the volume of connections to a backend service. This field
     * is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
     * Structure is documented below.
     * 
     */
    @Export(name="circuitBreakers", type=BackendServiceCircuitBreakers.class, parameters={})
    private Output</* @Nullable */ BackendServiceCircuitBreakers> circuitBreakers;

    /**
     * @return Settings controlling the volume of connections to a backend service. This field
     * is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
     * Structure is documented below.
     * 
     */
    public Output<Optional<BackendServiceCircuitBreakers>> circuitBreakers() {
        return Codegen.optional(this.circuitBreakers);
    }
    /**
     * Compress text responses using Brotli or gzip compression, based on the client&#39;s Accept-Encoding header.
     * Possible values are `AUTOMATIC` and `DISABLED`.
     * 
     */
    @Export(name="compressionMode", type=String.class, parameters={})
    private Output</* @Nullable */ String> compressionMode;

    /**
     * @return Compress text responses using Brotli or gzip compression, based on the client&#39;s Accept-Encoding header.
     * Possible values are `AUTOMATIC` and `DISABLED`.
     * 
     */
    public Output<Optional<String>> compressionMode() {
        return Codegen.optional(this.compressionMode);
    }
    /**
     * Time for which instance will be drained (not accept new
     * connections, but still work to finish started).
     * 
     */
    @Export(name="connectionDrainingTimeoutSec", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> connectionDrainingTimeoutSec;

    /**
     * @return Time for which instance will be drained (not accept new
     * connections, but still work to finish started).
     * 
     */
    public Output<Optional<Integer>> connectionDrainingTimeoutSec() {
        return Codegen.optional(this.connectionDrainingTimeoutSec);
    }
    /**
     * Consistent Hash-based load balancing can be used to provide soft session
     * affinity based on HTTP headers, cookies or other properties. This load balancing
     * policy is applicable only for HTTP connections. The affinity to a particular
     * destination host will be lost when one or more hosts are added/removed from the
     * destination service. This field specifies parameters that control consistent
     * hashing. This field only applies if the load_balancing_scheme is set to
     * INTERNAL_SELF_MANAGED. This field is only applicable when locality_lb_policy is
     * set to MAGLEV or RING_HASH.
     * Structure is documented below.
     * 
     */
    @Export(name="consistentHash", type=BackendServiceConsistentHash.class, parameters={})
    private Output</* @Nullable */ BackendServiceConsistentHash> consistentHash;

    /**
     * @return Consistent Hash-based load balancing can be used to provide soft session
     * affinity based on HTTP headers, cookies or other properties. This load balancing
     * policy is applicable only for HTTP connections. The affinity to a particular
     * destination host will be lost when one or more hosts are added/removed from the
     * destination service. This field specifies parameters that control consistent
     * hashing. This field only applies if the load_balancing_scheme is set to
     * INTERNAL_SELF_MANAGED. This field is only applicable when locality_lb_policy is
     * set to MAGLEV or RING_HASH.
     * Structure is documented below.
     * 
     */
    public Output<Optional<BackendServiceConsistentHash>> consistentHash() {
        return Codegen.optional(this.consistentHash);
    }
    /**
     * Creation timestamp in RFC3339 text format.
     * 
     */
    @Export(name="creationTimestamp", type=String.class, parameters={})
    private Output<String> creationTimestamp;

    /**
     * @return Creation timestamp in RFC3339 text format.
     * 
     */
    public Output<String> creationTimestamp() {
        return this.creationTimestamp;
    }
    /**
     * Headers that the HTTP/S load balancer should add to proxied
     * requests.
     * 
     */
    @Export(name="customRequestHeaders", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> customRequestHeaders;

    /**
     * @return Headers that the HTTP/S load balancer should add to proxied
     * requests.
     * 
     */
    public Output<Optional<List<String>>> customRequestHeaders() {
        return Codegen.optional(this.customRequestHeaders);
    }
    /**
     * Headers that the HTTP/S load balancer should add to proxied
     * responses.
     * 
     */
    @Export(name="customResponseHeaders", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> customResponseHeaders;

    /**
     * @return Headers that the HTTP/S load balancer should add to proxied
     * responses.
     * 
     */
    public Output<Optional<List<String>>> customResponseHeaders() {
        return Codegen.optional(this.customResponseHeaders);
    }
    /**
     * An optional description of this resource.
     * 
     */
    @Export(name="description", type=String.class, parameters={})
    private Output</* @Nullable */ String> description;

    /**
     * @return An optional description of this resource.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * The resource URL for the edge security policy associated with this backend service.
     * 
     */
    @Export(name="edgeSecurityPolicy", type=String.class, parameters={})
    private Output</* @Nullable */ String> edgeSecurityPolicy;

    /**
     * @return The resource URL for the edge security policy associated with this backend service.
     * 
     */
    public Output<Optional<String>> edgeSecurityPolicy() {
        return Codegen.optional(this.edgeSecurityPolicy);
    }
    /**
     * If true, enable Cloud CDN for this BackendService.
     * 
     */
    @Export(name="enableCdn", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> enableCdn;

    /**
     * @return If true, enable Cloud CDN for this BackendService.
     * 
     */
    public Output<Optional<Boolean>> enableCdn() {
        return Codegen.optional(this.enableCdn);
    }
    /**
     * Fingerprint of this resource. A hash of the contents stored in this
     * object. This field is used in optimistic locking.
     * 
     */
    @Export(name="fingerprint", type=String.class, parameters={})
    private Output<String> fingerprint;

    /**
     * @return Fingerprint of this resource. A hash of the contents stored in this
     * object. This field is used in optimistic locking.
     * 
     */
    public Output<String> fingerprint() {
        return this.fingerprint;
    }
    /**
     * The unique identifier for the resource. This identifier is defined by the server.
     * 
     */
    @Export(name="generatedId", type=Integer.class, parameters={})
    private Output<Integer> generatedId;

    /**
     * @return The unique identifier for the resource. This identifier is defined by the server.
     * 
     */
    public Output<Integer> generatedId() {
        return this.generatedId;
    }
    /**
     * The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource
     * for health checking this BackendService. Currently at most one health
     * check can be specified.
     * A health check must be specified unless the backend service uses an internet
     * or serverless NEG as a backend.
     * For internal load balancing, a URL to a HealthCheck resource must be specified instead.
     * 
     */
    @Export(name="healthChecks", type=String.class, parameters={})
    private Output</* @Nullable */ String> healthChecks;

    /**
     * @return The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource
     * for health checking this BackendService. Currently at most one health
     * check can be specified.
     * A health check must be specified unless the backend service uses an internet
     * or serverless NEG as a backend.
     * For internal load balancing, a URL to a HealthCheck resource must be specified instead.
     * 
     */
    public Output<Optional<String>> healthChecks() {
        return Codegen.optional(this.healthChecks);
    }
    /**
     * Settings for enabling Cloud Identity Aware Proxy
     * Structure is documented below.
     * 
     */
    @Export(name="iap", type=BackendServiceIap.class, parameters={})
    private Output</* @Nullable */ BackendServiceIap> iap;

    /**
     * @return Settings for enabling Cloud Identity Aware Proxy
     * Structure is documented below.
     * 
     */
    public Output<Optional<BackendServiceIap>> iap() {
        return Codegen.optional(this.iap);
    }
    /**
     * Indicates whether the backend service will be used with internal or
     * external load balancing. A backend service created for one type of
     * load balancing cannot be used with the other. For more information, refer to
     * [Choosing a load balancer](https://cloud.google.com/load-balancing/docs/backend-service).
     * Default value is `EXTERNAL`.
     * Possible values are `EXTERNAL`, `INTERNAL_SELF_MANAGED`, and `EXTERNAL_MANAGED`.
     * 
     */
    @Export(name="loadBalancingScheme", type=String.class, parameters={})
    private Output</* @Nullable */ String> loadBalancingScheme;

    /**
     * @return Indicates whether the backend service will be used with internal or
     * external load balancing. A backend service created for one type of
     * load balancing cannot be used with the other. For more information, refer to
     * [Choosing a load balancer](https://cloud.google.com/load-balancing/docs/backend-service).
     * Default value is `EXTERNAL`.
     * Possible values are `EXTERNAL`, `INTERNAL_SELF_MANAGED`, and `EXTERNAL_MANAGED`.
     * 
     */
    public Output<Optional<String>> loadBalancingScheme() {
        return Codegen.optional(this.loadBalancingScheme);
    }
    /**
     * A list of locality load balancing policies to be used in order of
     * preference. Either the policy or the customPolicy field should be set.
     * Overrides any value set in the localityLbPolicy field.
     * localityLbPolicies is only supported when the BackendService is referenced
     * by a URL Map that is referenced by a target gRPC proxy that has the
     * validateForProxyless field set to true.
     * Structure is documented below.
     * 
     */
    @Export(name="localityLbPolicies", type=List.class, parameters={BackendServiceLocalityLbPolicy.class})
    private Output</* @Nullable */ List<BackendServiceLocalityLbPolicy>> localityLbPolicies;

    /**
     * @return A list of locality load balancing policies to be used in order of
     * preference. Either the policy or the customPolicy field should be set.
     * Overrides any value set in the localityLbPolicy field.
     * localityLbPolicies is only supported when the BackendService is referenced
     * by a URL Map that is referenced by a target gRPC proxy that has the
     * validateForProxyless field set to true.
     * Structure is documented below.
     * 
     */
    public Output<Optional<List<BackendServiceLocalityLbPolicy>>> localityLbPolicies() {
        return Codegen.optional(this.localityLbPolicies);
    }
    /**
     * The load balancing algorithm used within the scope of the locality.
     * The possible values are:
     * 
     */
    @Export(name="localityLbPolicy", type=String.class, parameters={})
    private Output</* @Nullable */ String> localityLbPolicy;

    /**
     * @return The load balancing algorithm used within the scope of the locality.
     * The possible values are:
     * 
     */
    public Output<Optional<String>> localityLbPolicy() {
        return Codegen.optional(this.localityLbPolicy);
    }
    /**
     * This field denotes the logging options for the load balancer traffic served by this backend service.
     * If logging is enabled, logs will be exported to Stackdriver.
     * Structure is documented below.
     * 
     */
    @Export(name="logConfig", type=BackendServiceLogConfig.class, parameters={})
    private Output<BackendServiceLogConfig> logConfig;

    /**
     * @return This field denotes the logging options for the load balancer traffic served by this backend service.
     * If logging is enabled, logs will be exported to Stackdriver.
     * Structure is documented below.
     * 
     */
    public Output<BackendServiceLogConfig> logConfig() {
        return this.logConfig;
    }
    /**
     * Name of the resource. Provided by the client when the resource is
     * created. The name must be 1-63 characters long, and comply with
     * RFC1035. Specifically, the name must be 1-63 characters long and match
     * the regular expression `a-z?` which means the
     * first character must be a lowercase letter, and all following
     * characters must be a dash, lowercase letter, or digit, except the last
     * character, which cannot be a dash.
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return Name of the resource. Provided by the client when the resource is
     * created. The name must be 1-63 characters long, and comply with
     * RFC1035. Specifically, the name must be 1-63 characters long and match
     * the regular expression `a-z?` which means the
     * first character must be a lowercase letter, and all following
     * characters must be a dash, lowercase letter, or digit, except the last
     * character, which cannot be a dash.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Settings controlling eviction of unhealthy hosts from the load balancing pool.
     * This field is applicable only when the load_balancing_scheme is set
     * to INTERNAL_SELF_MANAGED.
     * Structure is documented below.
     * 
     */
    @Export(name="outlierDetection", type=BackendServiceOutlierDetection.class, parameters={})
    private Output</* @Nullable */ BackendServiceOutlierDetection> outlierDetection;

    /**
     * @return Settings controlling eviction of unhealthy hosts from the load balancing pool.
     * This field is applicable only when the load_balancing_scheme is set
     * to INTERNAL_SELF_MANAGED.
     * Structure is documented below.
     * 
     */
    public Output<Optional<BackendServiceOutlierDetection>> outlierDetection() {
        return Codegen.optional(this.outlierDetection);
    }
    /**
     * Name of backend port. The same name should appear in the instance
     * groups referenced by this service. Required when the load balancing
     * scheme is EXTERNAL.
     * 
     */
    @Export(name="portName", type=String.class, parameters={})
    private Output<String> portName;

    /**
     * @return Name of backend port. The same name should appear in the instance
     * groups referenced by this service. Required when the load balancing
     * scheme is EXTERNAL.
     * 
     */
    public Output<String> portName() {
        return this.portName;
    }
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Export(name="project", type=String.class, parameters={})
    private Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Output<String> project() {
        return this.project;
    }
    /**
     * The protocol this BackendService uses to communicate with backends.
     * The default is HTTP. **NOTE**: HTTP2 is only valid for beta HTTP/2 load balancer
     * types and may result in errors if used with the GA API.
     * Possible values are `HTTP`, `HTTPS`, `HTTP2`, `TCP`, `SSL`, and `GRPC`.
     * 
     */
    @Export(name="protocol", type=String.class, parameters={})
    private Output<String> protocol;

    /**
     * @return The protocol this BackendService uses to communicate with backends.
     * The default is HTTP. **NOTE**: HTTP2 is only valid for beta HTTP/2 load balancer
     * types and may result in errors if used with the GA API.
     * Possible values are `HTTP`, `HTTPS`, `HTTP2`, `TCP`, `SSL`, and `GRPC`.
     * 
     */
    public Output<String> protocol() {
        return this.protocol;
    }
    /**
     * The security policy associated with this backend service.
     * 
     */
    @Export(name="securityPolicy", type=String.class, parameters={})
    private Output</* @Nullable */ String> securityPolicy;

    /**
     * @return The security policy associated with this backend service.
     * 
     */
    public Output<Optional<String>> securityPolicy() {
        return Codegen.optional(this.securityPolicy);
    }
    /**
     * The security settings that apply to this backend service. This field is applicable to either
     * a regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and
     * load_balancing_scheme set to INTERNAL_MANAGED; or a global backend service with the
     * load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Structure is documented below.
     * 
     */
    @Export(name="securitySettings", type=BackendServiceSecuritySettings.class, parameters={})
    private Output</* @Nullable */ BackendServiceSecuritySettings> securitySettings;

    /**
     * @return The security settings that apply to this backend service. This field is applicable to either
     * a regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and
     * load_balancing_scheme set to INTERNAL_MANAGED; or a global backend service with the
     * load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Structure is documented below.
     * 
     */
    public Output<Optional<BackendServiceSecuritySettings>> securitySettings() {
        return Codegen.optional(this.securitySettings);
    }
    /**
     * The URI of the created resource.
     * 
     */
    @Export(name="selfLink", type=String.class, parameters={})
    private Output<String> selfLink;

    /**
     * @return The URI of the created resource.
     * 
     */
    public Output<String> selfLink() {
        return this.selfLink;
    }
    /**
     * Type of session affinity to use. The default is NONE. Session affinity is
     * not applicable if the protocol is UDP.
     * Possible values are `NONE`, `CLIENT_IP`, `CLIENT_IP_PORT_PROTO`, `CLIENT_IP_PROTO`, `GENERATED_COOKIE`, `HEADER_FIELD`, and `HTTP_COOKIE`.
     * 
     */
    @Export(name="sessionAffinity", type=String.class, parameters={})
    private Output<String> sessionAffinity;

    /**
     * @return Type of session affinity to use. The default is NONE. Session affinity is
     * not applicable if the protocol is UDP.
     * Possible values are `NONE`, `CLIENT_IP`, `CLIENT_IP_PORT_PROTO`, `CLIENT_IP_PROTO`, `GENERATED_COOKIE`, `HEADER_FIELD`, and `HTTP_COOKIE`.
     * 
     */
    public Output<String> sessionAffinity() {
        return this.sessionAffinity;
    }
    /**
     * How many seconds to wait for the backend before considering it a
     * failed request. Default is 30 seconds. Valid range is [1, 86400].
     * 
     */
    @Export(name="timeoutSec", type=Integer.class, parameters={})
    private Output<Integer> timeoutSec;

    /**
     * @return How many seconds to wait for the backend before considering it a
     * failed request. Default is 30 seconds. Valid range is [1, 86400].
     * 
     */
    public Output<Integer> timeoutSec() {
        return this.timeoutSec;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public BackendService(String name) {
        this(name, BackendServiceArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public BackendService(String name, @Nullable BackendServiceArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public BackendService(String name, @Nullable BackendServiceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:compute/backendService:BackendService", name, args == null ? BackendServiceArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private BackendService(String name, Output<String> id, @Nullable BackendServiceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:compute/backendService:BackendService", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static BackendService get(String name, Output<String> id, @Nullable BackendServiceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new BackendService(name, id, state, options);
    }
}
