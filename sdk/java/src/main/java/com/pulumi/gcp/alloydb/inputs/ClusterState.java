// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.alloydb.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.alloydb.inputs.ClusterAutomatedBackupPolicyArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterBackupSourceArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterBackupdrBackupSourceArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterContinuousBackupConfigArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterContinuousBackupInfoArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterEncryptionConfigArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterEncryptionInfoArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterInitialUserArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterMaintenanceUpdatePolicyArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterMigrationSourceArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterNetworkConfigArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterPscConfigArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterRestoreBackupSourceArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterRestoreBackupdrBackupSourceArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterRestoreBackupdrPitrSourceArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterRestoreContinuousBackupSourceArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterSecondaryConfigArgs;
import com.pulumi.gcp.alloydb.inputs.ClusterTrialMetadataArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ClusterState extends com.pulumi.resources.ResourceArgs {

    public static final ClusterState Empty = new ClusterState();

    /**
     * Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
     * An object containing a list of &#34;key&#34;: value pairs. Example: { &#34;name&#34;: &#34;wrench&#34;, &#34;mass&#34;: &#34;1.3kg&#34;, &#34;count&#34;: &#34;3&#34; }.
     * 
     * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
     * Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
     * 
     */
    @Import(name="annotations")
    private @Nullable Output<Map<String,String>> annotations;

    /**
     * @return Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
     * An object containing a list of &#34;key&#34;: value pairs. Example: { &#34;name&#34;: &#34;wrench&#34;, &#34;mass&#34;: &#34;1.3kg&#34;, &#34;count&#34;: &#34;3&#34; }.
     * 
     * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
     * Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
     * 
     */
    public Optional<Output<Map<String,String>>> annotations() {
        return Optional.ofNullable(this.annotations);
    }

    /**
     * The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
     * Structure is documented below.
     * 
     */
    @Import(name="automatedBackupPolicy")
    private @Nullable Output<ClusterAutomatedBackupPolicyArgs> automatedBackupPolicy;

    /**
     * @return The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterAutomatedBackupPolicyArgs>> automatedBackupPolicy() {
        return Optional.ofNullable(this.automatedBackupPolicy);
    }

    /**
     * Cluster created from backup.
     * Structure is documented below.
     * 
     */
    @Import(name="backupSources")
    private @Nullable Output<List<ClusterBackupSourceArgs>> backupSources;

    /**
     * @return Cluster created from backup.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<ClusterBackupSourceArgs>>> backupSources() {
        return Optional.ofNullable(this.backupSources);
    }

    /**
     * Cluster created from a BackupDR backup.
     * Structure is documented below.
     * 
     */
    @Import(name="backupdrBackupSources")
    private @Nullable Output<List<ClusterBackupdrBackupSourceArgs>> backupdrBackupSources;

    /**
     * @return Cluster created from a BackupDR backup.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<ClusterBackupdrBackupSourceArgs>>> backupdrBackupSources() {
        return Optional.ofNullable(this.backupdrBackupSources);
    }

    /**
     * The ID of the alloydb cluster.
     * 
     */
    @Import(name="clusterId")
    private @Nullable Output<String> clusterId;

    /**
     * @return The ID of the alloydb cluster.
     * 
     */
    public Optional<Output<String>> clusterId() {
        return Optional.ofNullable(this.clusterId);
    }

    /**
     * The type of cluster. If not set, defaults to PRIMARY.
     * Default value is `PRIMARY`.
     * Possible values are: `PRIMARY`, `SECONDARY`.
     * 
     */
    @Import(name="clusterType")
    private @Nullable Output<String> clusterType;

    /**
     * @return The type of cluster. If not set, defaults to PRIMARY.
     * Default value is `PRIMARY`.
     * Possible values are: `PRIMARY`, `SECONDARY`.
     * 
     */
    public Optional<Output<String>> clusterType() {
        return Optional.ofNullable(this.clusterType);
    }

    /**
     * The continuous backup config for this cluster.
     * If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
     * Structure is documented below.
     * 
     */
    @Import(name="continuousBackupConfig")
    private @Nullable Output<ClusterContinuousBackupConfigArgs> continuousBackupConfig;

    /**
     * @return The continuous backup config for this cluster.
     * If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterContinuousBackupConfigArgs>> continuousBackupConfig() {
        return Optional.ofNullable(this.continuousBackupConfig);
    }

    /**
     * ContinuousBackupInfo describes the continuous backup properties of a cluster.
     * Structure is documented below.
     * 
     */
    @Import(name="continuousBackupInfos")
    private @Nullable Output<List<ClusterContinuousBackupInfoArgs>> continuousBackupInfos;

    /**
     * @return ContinuousBackupInfo describes the continuous backup properties of a cluster.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<ClusterContinuousBackupInfoArgs>>> continuousBackupInfos() {
        return Optional.ofNullable(this.continuousBackupInfos);
    }

    /**
     * The database engine major version. This is an optional field and it&#39;s populated at the Cluster creation time.
     * Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
     * 
     */
    @Import(name="databaseVersion")
    private @Nullable Output<String> databaseVersion;

    /**
     * @return The database engine major version. This is an optional field and it&#39;s populated at the Cluster creation time.
     * Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
     * 
     */
    public Optional<Output<String>> databaseVersion() {
        return Optional.ofNullable(this.databaseVersion);
    }

    /**
     * Policy to determine if the cluster should be deleted forcefully.
     * Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
     * Deleting a Secondary cluster with a secondary instance REQUIRES setting deletionPolicy = &#34;FORCE&#34; otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
     * Possible values: DEFAULT, FORCE
     * 
     */
    @Import(name="deletionPolicy")
    private @Nullable Output<String> deletionPolicy;

    /**
     * @return Policy to determine if the cluster should be deleted forcefully.
     * Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
     * Deleting a Secondary cluster with a secondary instance REQUIRES setting deletionPolicy = &#34;FORCE&#34; otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
     * Possible values: DEFAULT, FORCE
     * 
     */
    public Optional<Output<String>> deletionPolicy() {
        return Optional.ofNullable(this.deletionPolicy);
    }

    @Import(name="deletionProtection")
    private @Nullable Output<Boolean> deletionProtection;

    public Optional<Output<Boolean>> deletionProtection() {
        return Optional.ofNullable(this.deletionProtection);
    }

    /**
     * User-settable and human-readable display name for the Cluster.
     * 
     */
    @Import(name="displayName")
    private @Nullable Output<String> displayName;

    /**
     * @return User-settable and human-readable display name for the Cluster.
     * 
     */
    public Optional<Output<String>> displayName() {
        return Optional.ofNullable(this.displayName);
    }

    @Import(name="effectiveAnnotations")
    private @Nullable Output<Map<String,String>> effectiveAnnotations;

    public Optional<Output<Map<String,String>>> effectiveAnnotations() {
        return Optional.ofNullable(this.effectiveAnnotations);
    }

    /**
     * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     * 
     */
    @Import(name="effectiveLabels")
    private @Nullable Output<Map<String,String>> effectiveLabels;

    /**
     * @return All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     * 
     */
    public Optional<Output<Map<String,String>>> effectiveLabels() {
        return Optional.ofNullable(this.effectiveLabels);
    }

    /**
     * EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
     * Structure is documented below.
     * 
     */
    @Import(name="encryptionConfig")
    private @Nullable Output<ClusterEncryptionConfigArgs> encryptionConfig;

    /**
     * @return EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterEncryptionConfigArgs>> encryptionConfig() {
        return Optional.ofNullable(this.encryptionConfig);
    }

    /**
     * (Output)
     * Output only. The encryption information for the WALs and backups required for ContinuousBackup.
     * Structure is documented below.
     * 
     */
    @Import(name="encryptionInfos")
    private @Nullable Output<List<ClusterEncryptionInfoArgs>> encryptionInfos;

    /**
     * @return (Output)
     * Output only. The encryption information for the WALs and backups required for ContinuousBackup.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<ClusterEncryptionInfoArgs>>> encryptionInfos() {
        return Optional.ofNullable(this.encryptionInfos);
    }

    /**
     * For Resource freshness validation (https://google.aip.dev/154)
     * 
     */
    @Import(name="etag")
    private @Nullable Output<String> etag;

    /**
     * @return For Resource freshness validation (https://google.aip.dev/154)
     * 
     */
    public Optional<Output<String>> etag() {
        return Optional.ofNullable(this.etag);
    }

    /**
     * Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
     * Structure is documented below.
     * 
     */
    @Import(name="initialUser")
    private @Nullable Output<ClusterInitialUserArgs> initialUser;

    /**
     * @return Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterInitialUserArgs>> initialUser() {
        return Optional.ofNullable(this.initialUser);
    }

    /**
     * User-defined labels for the alloydb cluster.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    /**
     * @return User-defined labels for the alloydb cluster.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     * 
     */
    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * The location where the alloydb cluster should reside.
     * 
     */
    @Import(name="location")
    private @Nullable Output<String> location;

    /**
     * @return The location where the alloydb cluster should reside.
     * 
     */
    public Optional<Output<String>> location() {
        return Optional.ofNullable(this.location);
    }

    /**
     * MaintenanceUpdatePolicy defines the policy for system updates.
     * Structure is documented below.
     * 
     */
    @Import(name="maintenanceUpdatePolicy")
    private @Nullable Output<ClusterMaintenanceUpdatePolicyArgs> maintenanceUpdatePolicy;

    /**
     * @return MaintenanceUpdatePolicy defines the policy for system updates.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterMaintenanceUpdatePolicyArgs>> maintenanceUpdatePolicy() {
        return Optional.ofNullable(this.maintenanceUpdatePolicy);
    }

    /**
     * Cluster created via DMS migration.
     * Structure is documented below.
     * 
     */
    @Import(name="migrationSources")
    private @Nullable Output<List<ClusterMigrationSourceArgs>> migrationSources;

    /**
     * @return Cluster created via DMS migration.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<ClusterMigrationSourceArgs>>> migrationSources() {
        return Optional.ofNullable(this.migrationSources);
    }

    /**
     * The name of the cluster resource.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the cluster resource.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Metadata related to network configuration.
     * Structure is documented below.
     * 
     */
    @Import(name="networkConfig")
    private @Nullable Output<ClusterNetworkConfigArgs> networkConfig;

    /**
     * @return Metadata related to network configuration.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterNetworkConfigArgs>> networkConfig() {
        return Optional.ofNullable(this.networkConfig);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * Configuration for Private Service Connect (PSC) for the cluster.
     * Structure is documented below.
     * 
     */
    @Import(name="pscConfig")
    private @Nullable Output<ClusterPscConfigArgs> pscConfig;

    /**
     * @return Configuration for Private Service Connect (PSC) for the cluster.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterPscConfigArgs>> pscConfig() {
        return Optional.ofNullable(this.pscConfig);
    }

    /**
     * The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     * 
     */
    @Import(name="pulumiLabels")
    private @Nullable Output<Map<String,String>> pulumiLabels;

    /**
     * @return The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     * 
     */
    public Optional<Output<Map<String,String>>> pulumiLabels() {
        return Optional.ofNullable(this.pulumiLabels);
    }

    /**
     * Output only. Reconciling (https://google.aip.dev/128#reconciliation).
     * Set to true if the current state of Cluster does not match the user&#39;s intended state, and the service is actively updating the resource to reconcile them.
     * This can happen due to user-triggered updates or system actions like failover or maintenance.
     * 
     */
    @Import(name="reconciling")
    private @Nullable Output<Boolean> reconciling;

    /**
     * @return Output only. Reconciling (https://google.aip.dev/128#reconciliation).
     * Set to true if the current state of Cluster does not match the user&#39;s intended state, and the service is actively updating the resource to reconcile them.
     * This can happen due to user-triggered updates or system actions like failover or maintenance.
     * 
     */
    public Optional<Output<Boolean>> reconciling() {
        return Optional.ofNullable(this.reconciling);
    }

    /**
     * The source when restoring from a backup. Conflicts with &#39;restore_continuous_backup_source&#39;, &#39;restore_backupdr_backup_source&#39; and &#39;restore_backupdr_pitr_source&#39;, they can&#39;t be set together.
     * Structure is documented below.
     * 
     */
    @Import(name="restoreBackupSource")
    private @Nullable Output<ClusterRestoreBackupSourceArgs> restoreBackupSource;

    /**
     * @return The source when restoring from a backup. Conflicts with &#39;restore_continuous_backup_source&#39;, &#39;restore_backupdr_backup_source&#39; and &#39;restore_backupdr_pitr_source&#39;, they can&#39;t be set together.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterRestoreBackupSourceArgs>> restoreBackupSource() {
        return Optional.ofNullable(this.restoreBackupSource);
    }

    /**
     * The source when restoring from a backup. Conflicts with &#39;restore_continuous_backup_source&#39;,  &#39;restore_backup_source&#39; and &#39;restore_backupdr_pitr_source&#39;, they can&#39;t be set together.
     * Structure is documented below.
     * 
     */
    @Import(name="restoreBackupdrBackupSource")
    private @Nullable Output<ClusterRestoreBackupdrBackupSourceArgs> restoreBackupdrBackupSource;

    /**
     * @return The source when restoring from a backup. Conflicts with &#39;restore_continuous_backup_source&#39;,  &#39;restore_backup_source&#39; and &#39;restore_backupdr_pitr_source&#39;, they can&#39;t be set together.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterRestoreBackupdrBackupSourceArgs>> restoreBackupdrBackupSource() {
        return Optional.ofNullable(this.restoreBackupdrBackupSource);
    }

    /**
     * The BackupDR source used for point in time recovery. Conflicts with &#39;restore_backupdr_backup_source&#39;, &#39;restore_continuous_backup_source&#39; and &#39;restore_backupdr_backup_source&#39;, they can&#39;t be set togeter.
     * Structure is documented below.
     * 
     */
    @Import(name="restoreBackupdrPitrSource")
    private @Nullable Output<ClusterRestoreBackupdrPitrSourceArgs> restoreBackupdrPitrSource;

    /**
     * @return The BackupDR source used for point in time recovery. Conflicts with &#39;restore_backupdr_backup_source&#39;, &#39;restore_continuous_backup_source&#39; and &#39;restore_backupdr_backup_source&#39;, they can&#39;t be set togeter.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterRestoreBackupdrPitrSourceArgs>> restoreBackupdrPitrSource() {
        return Optional.ofNullable(this.restoreBackupdrPitrSource);
    }

    /**
     * The source when restoring via point in time recovery (PITR). Conflicts with &#39;restore_backup_source&#39;, &#39;restore_backupdr_backup_source&#39; and &#39;restore_backupdr_pitr_source&#39;, they can&#39;t be set together.
     * Structure is documented below.
     * 
     */
    @Import(name="restoreContinuousBackupSource")
    private @Nullable Output<ClusterRestoreContinuousBackupSourceArgs> restoreContinuousBackupSource;

    /**
     * @return The source when restoring via point in time recovery (PITR). Conflicts with &#39;restore_backup_source&#39;, &#39;restore_backupdr_backup_source&#39; and &#39;restore_backupdr_pitr_source&#39;, they can&#39;t be set together.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterRestoreContinuousBackupSourceArgs>> restoreContinuousBackupSource() {
        return Optional.ofNullable(this.restoreContinuousBackupSource);
    }

    /**
     * Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
     * Structure is documented below.
     * 
     */
    @Import(name="secondaryConfig")
    private @Nullable Output<ClusterSecondaryConfigArgs> secondaryConfig;

    /**
     * @return Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterSecondaryConfigArgs>> secondaryConfig() {
        return Optional.ofNullable(this.secondaryConfig);
    }

    /**
     * Set to true to skip awaiting on the major version upgrade of the cluster.
     * Possible values: true, false
     * Default value: &#34;true&#34;
     * 
     */
    @Import(name="skipAwaitMajorVersionUpgrade")
    private @Nullable Output<Boolean> skipAwaitMajorVersionUpgrade;

    /**
     * @return Set to true to skip awaiting on the major version upgrade of the cluster.
     * Possible values: true, false
     * Default value: &#34;true&#34;
     * 
     */
    public Optional<Output<Boolean>> skipAwaitMajorVersionUpgrade() {
        return Optional.ofNullable(this.skipAwaitMajorVersionUpgrade);
    }

    /**
     * Output only. The current serving state of the cluster.
     * 
     */
    @Import(name="state")
    private @Nullable Output<String> state;

    /**
     * @return Output only. The current serving state of the cluster.
     * 
     */
    public Optional<Output<String>> state() {
        return Optional.ofNullable(this.state);
    }

    /**
     * The subscrition type of cluster.
     * Possible values are: `TRIAL`, `STANDARD`.
     * 
     */
    @Import(name="subscriptionType")
    private @Nullable Output<String> subscriptionType;

    /**
     * @return The subscrition type of cluster.
     * Possible values are: `TRIAL`, `STANDARD`.
     * 
     */
    public Optional<Output<String>> subscriptionType() {
        return Optional.ofNullable(this.subscriptionType);
    }

    /**
     * Contains information and all metadata related to TRIAL clusters.
     * Structure is documented below.
     * 
     */
    @Import(name="trialMetadatas")
    private @Nullable Output<List<ClusterTrialMetadataArgs>> trialMetadatas;

    /**
     * @return Contains information and all metadata related to TRIAL clusters.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<ClusterTrialMetadataArgs>>> trialMetadatas() {
        return Optional.ofNullable(this.trialMetadatas);
    }

    /**
     * The system-generated UID of the resource.
     * 
     */
    @Import(name="uid")
    private @Nullable Output<String> uid;

    /**
     * @return The system-generated UID of the resource.
     * 
     */
    public Optional<Output<String>> uid() {
        return Optional.ofNullable(this.uid);
    }

    private ClusterState() {}

    private ClusterState(ClusterState $) {
        this.annotations = $.annotations;
        this.automatedBackupPolicy = $.automatedBackupPolicy;
        this.backupSources = $.backupSources;
        this.backupdrBackupSources = $.backupdrBackupSources;
        this.clusterId = $.clusterId;
        this.clusterType = $.clusterType;
        this.continuousBackupConfig = $.continuousBackupConfig;
        this.continuousBackupInfos = $.continuousBackupInfos;
        this.databaseVersion = $.databaseVersion;
        this.deletionPolicy = $.deletionPolicy;
        this.deletionProtection = $.deletionProtection;
        this.displayName = $.displayName;
        this.effectiveAnnotations = $.effectiveAnnotations;
        this.effectiveLabels = $.effectiveLabels;
        this.encryptionConfig = $.encryptionConfig;
        this.encryptionInfos = $.encryptionInfos;
        this.etag = $.etag;
        this.initialUser = $.initialUser;
        this.labels = $.labels;
        this.location = $.location;
        this.maintenanceUpdatePolicy = $.maintenanceUpdatePolicy;
        this.migrationSources = $.migrationSources;
        this.name = $.name;
        this.networkConfig = $.networkConfig;
        this.project = $.project;
        this.pscConfig = $.pscConfig;
        this.pulumiLabels = $.pulumiLabels;
        this.reconciling = $.reconciling;
        this.restoreBackupSource = $.restoreBackupSource;
        this.restoreBackupdrBackupSource = $.restoreBackupdrBackupSource;
        this.restoreBackupdrPitrSource = $.restoreBackupdrPitrSource;
        this.restoreContinuousBackupSource = $.restoreContinuousBackupSource;
        this.secondaryConfig = $.secondaryConfig;
        this.skipAwaitMajorVersionUpgrade = $.skipAwaitMajorVersionUpgrade;
        this.state = $.state;
        this.subscriptionType = $.subscriptionType;
        this.trialMetadatas = $.trialMetadatas;
        this.uid = $.uid;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ClusterState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ClusterState $;

        public Builder() {
            $ = new ClusterState();
        }

        public Builder(ClusterState defaults) {
            $ = new ClusterState(Objects.requireNonNull(defaults));
        }

        /**
         * @param annotations Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
         * An object containing a list of &#34;key&#34;: value pairs. Example: { &#34;name&#34;: &#34;wrench&#34;, &#34;mass&#34;: &#34;1.3kg&#34;, &#34;count&#34;: &#34;3&#34; }.
         * 
         * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
         * Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
         * 
         * @return builder
         * 
         */
        public Builder annotations(@Nullable Output<Map<String,String>> annotations) {
            $.annotations = annotations;
            return this;
        }

        /**
         * @param annotations Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
         * An object containing a list of &#34;key&#34;: value pairs. Example: { &#34;name&#34;: &#34;wrench&#34;, &#34;mass&#34;: &#34;1.3kg&#34;, &#34;count&#34;: &#34;3&#34; }.
         * 
         * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
         * Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
         * 
         * @return builder
         * 
         */
        public Builder annotations(Map<String,String> annotations) {
            return annotations(Output.of(annotations));
        }

        /**
         * @param automatedBackupPolicy The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder automatedBackupPolicy(@Nullable Output<ClusterAutomatedBackupPolicyArgs> automatedBackupPolicy) {
            $.automatedBackupPolicy = automatedBackupPolicy;
            return this;
        }

        /**
         * @param automatedBackupPolicy The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder automatedBackupPolicy(ClusterAutomatedBackupPolicyArgs automatedBackupPolicy) {
            return automatedBackupPolicy(Output.of(automatedBackupPolicy));
        }

        /**
         * @param backupSources Cluster created from backup.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder backupSources(@Nullable Output<List<ClusterBackupSourceArgs>> backupSources) {
            $.backupSources = backupSources;
            return this;
        }

        /**
         * @param backupSources Cluster created from backup.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder backupSources(List<ClusterBackupSourceArgs> backupSources) {
            return backupSources(Output.of(backupSources));
        }

        /**
         * @param backupSources Cluster created from backup.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder backupSources(ClusterBackupSourceArgs... backupSources) {
            return backupSources(List.of(backupSources));
        }

        /**
         * @param backupdrBackupSources Cluster created from a BackupDR backup.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder backupdrBackupSources(@Nullable Output<List<ClusterBackupdrBackupSourceArgs>> backupdrBackupSources) {
            $.backupdrBackupSources = backupdrBackupSources;
            return this;
        }

        /**
         * @param backupdrBackupSources Cluster created from a BackupDR backup.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder backupdrBackupSources(List<ClusterBackupdrBackupSourceArgs> backupdrBackupSources) {
            return backupdrBackupSources(Output.of(backupdrBackupSources));
        }

        /**
         * @param backupdrBackupSources Cluster created from a BackupDR backup.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder backupdrBackupSources(ClusterBackupdrBackupSourceArgs... backupdrBackupSources) {
            return backupdrBackupSources(List.of(backupdrBackupSources));
        }

        /**
         * @param clusterId The ID of the alloydb cluster.
         * 
         * @return builder
         * 
         */
        public Builder clusterId(@Nullable Output<String> clusterId) {
            $.clusterId = clusterId;
            return this;
        }

        /**
         * @param clusterId The ID of the alloydb cluster.
         * 
         * @return builder
         * 
         */
        public Builder clusterId(String clusterId) {
            return clusterId(Output.of(clusterId));
        }

        /**
         * @param clusterType The type of cluster. If not set, defaults to PRIMARY.
         * Default value is `PRIMARY`.
         * Possible values are: `PRIMARY`, `SECONDARY`.
         * 
         * @return builder
         * 
         */
        public Builder clusterType(@Nullable Output<String> clusterType) {
            $.clusterType = clusterType;
            return this;
        }

        /**
         * @param clusterType The type of cluster. If not set, defaults to PRIMARY.
         * Default value is `PRIMARY`.
         * Possible values are: `PRIMARY`, `SECONDARY`.
         * 
         * @return builder
         * 
         */
        public Builder clusterType(String clusterType) {
            return clusterType(Output.of(clusterType));
        }

        /**
         * @param continuousBackupConfig The continuous backup config for this cluster.
         * If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder continuousBackupConfig(@Nullable Output<ClusterContinuousBackupConfigArgs> continuousBackupConfig) {
            $.continuousBackupConfig = continuousBackupConfig;
            return this;
        }

        /**
         * @param continuousBackupConfig The continuous backup config for this cluster.
         * If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder continuousBackupConfig(ClusterContinuousBackupConfigArgs continuousBackupConfig) {
            return continuousBackupConfig(Output.of(continuousBackupConfig));
        }

        /**
         * @param continuousBackupInfos ContinuousBackupInfo describes the continuous backup properties of a cluster.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder continuousBackupInfos(@Nullable Output<List<ClusterContinuousBackupInfoArgs>> continuousBackupInfos) {
            $.continuousBackupInfos = continuousBackupInfos;
            return this;
        }

        /**
         * @param continuousBackupInfos ContinuousBackupInfo describes the continuous backup properties of a cluster.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder continuousBackupInfos(List<ClusterContinuousBackupInfoArgs> continuousBackupInfos) {
            return continuousBackupInfos(Output.of(continuousBackupInfos));
        }

        /**
         * @param continuousBackupInfos ContinuousBackupInfo describes the continuous backup properties of a cluster.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder continuousBackupInfos(ClusterContinuousBackupInfoArgs... continuousBackupInfos) {
            return continuousBackupInfos(List.of(continuousBackupInfos));
        }

        /**
         * @param databaseVersion The database engine major version. This is an optional field and it&#39;s populated at the Cluster creation time.
         * Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
         * 
         * @return builder
         * 
         */
        public Builder databaseVersion(@Nullable Output<String> databaseVersion) {
            $.databaseVersion = databaseVersion;
            return this;
        }

        /**
         * @param databaseVersion The database engine major version. This is an optional field and it&#39;s populated at the Cluster creation time.
         * Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
         * 
         * @return builder
         * 
         */
        public Builder databaseVersion(String databaseVersion) {
            return databaseVersion(Output.of(databaseVersion));
        }

        /**
         * @param deletionPolicy Policy to determine if the cluster should be deleted forcefully.
         * Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
         * Deleting a Secondary cluster with a secondary instance REQUIRES setting deletionPolicy = &#34;FORCE&#34; otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
         * Possible values: DEFAULT, FORCE
         * 
         * @return builder
         * 
         */
        public Builder deletionPolicy(@Nullable Output<String> deletionPolicy) {
            $.deletionPolicy = deletionPolicy;
            return this;
        }

        /**
         * @param deletionPolicy Policy to determine if the cluster should be deleted forcefully.
         * Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
         * Deleting a Secondary cluster with a secondary instance REQUIRES setting deletionPolicy = &#34;FORCE&#34; otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
         * Possible values: DEFAULT, FORCE
         * 
         * @return builder
         * 
         */
        public Builder deletionPolicy(String deletionPolicy) {
            return deletionPolicy(Output.of(deletionPolicy));
        }

        public Builder deletionProtection(@Nullable Output<Boolean> deletionProtection) {
            $.deletionProtection = deletionProtection;
            return this;
        }

        public Builder deletionProtection(Boolean deletionProtection) {
            return deletionProtection(Output.of(deletionProtection));
        }

        /**
         * @param displayName User-settable and human-readable display name for the Cluster.
         * 
         * @return builder
         * 
         */
        public Builder displayName(@Nullable Output<String> displayName) {
            $.displayName = displayName;
            return this;
        }

        /**
         * @param displayName User-settable and human-readable display name for the Cluster.
         * 
         * @return builder
         * 
         */
        public Builder displayName(String displayName) {
            return displayName(Output.of(displayName));
        }

        public Builder effectiveAnnotations(@Nullable Output<Map<String,String>> effectiveAnnotations) {
            $.effectiveAnnotations = effectiveAnnotations;
            return this;
        }

        public Builder effectiveAnnotations(Map<String,String> effectiveAnnotations) {
            return effectiveAnnotations(Output.of(effectiveAnnotations));
        }

        /**
         * @param effectiveLabels All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
         * 
         * @return builder
         * 
         */
        public Builder effectiveLabels(@Nullable Output<Map<String,String>> effectiveLabels) {
            $.effectiveLabels = effectiveLabels;
            return this;
        }

        /**
         * @param effectiveLabels All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
         * 
         * @return builder
         * 
         */
        public Builder effectiveLabels(Map<String,String> effectiveLabels) {
            return effectiveLabels(Output.of(effectiveLabels));
        }

        /**
         * @param encryptionConfig EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder encryptionConfig(@Nullable Output<ClusterEncryptionConfigArgs> encryptionConfig) {
            $.encryptionConfig = encryptionConfig;
            return this;
        }

        /**
         * @param encryptionConfig EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder encryptionConfig(ClusterEncryptionConfigArgs encryptionConfig) {
            return encryptionConfig(Output.of(encryptionConfig));
        }

        /**
         * @param encryptionInfos (Output)
         * Output only. The encryption information for the WALs and backups required for ContinuousBackup.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder encryptionInfos(@Nullable Output<List<ClusterEncryptionInfoArgs>> encryptionInfos) {
            $.encryptionInfos = encryptionInfos;
            return this;
        }

        /**
         * @param encryptionInfos (Output)
         * Output only. The encryption information for the WALs and backups required for ContinuousBackup.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder encryptionInfos(List<ClusterEncryptionInfoArgs> encryptionInfos) {
            return encryptionInfos(Output.of(encryptionInfos));
        }

        /**
         * @param encryptionInfos (Output)
         * Output only. The encryption information for the WALs and backups required for ContinuousBackup.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder encryptionInfos(ClusterEncryptionInfoArgs... encryptionInfos) {
            return encryptionInfos(List.of(encryptionInfos));
        }

        /**
         * @param etag For Resource freshness validation (https://google.aip.dev/154)
         * 
         * @return builder
         * 
         */
        public Builder etag(@Nullable Output<String> etag) {
            $.etag = etag;
            return this;
        }

        /**
         * @param etag For Resource freshness validation (https://google.aip.dev/154)
         * 
         * @return builder
         * 
         */
        public Builder etag(String etag) {
            return etag(Output.of(etag));
        }

        /**
         * @param initialUser Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder initialUser(@Nullable Output<ClusterInitialUserArgs> initialUser) {
            $.initialUser = initialUser;
            return this;
        }

        /**
         * @param initialUser Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder initialUser(ClusterInitialUserArgs initialUser) {
            return initialUser(Output.of(initialUser));
        }

        /**
         * @param labels User-defined labels for the alloydb cluster.
         * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
         * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels User-defined labels for the alloydb cluster.
         * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
         * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
         * 
         * @return builder
         * 
         */
        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        /**
         * @param location The location where the alloydb cluster should reside.
         * 
         * @return builder
         * 
         */
        public Builder location(@Nullable Output<String> location) {
            $.location = location;
            return this;
        }

        /**
         * @param location The location where the alloydb cluster should reside.
         * 
         * @return builder
         * 
         */
        public Builder location(String location) {
            return location(Output.of(location));
        }

        /**
         * @param maintenanceUpdatePolicy MaintenanceUpdatePolicy defines the policy for system updates.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder maintenanceUpdatePolicy(@Nullable Output<ClusterMaintenanceUpdatePolicyArgs> maintenanceUpdatePolicy) {
            $.maintenanceUpdatePolicy = maintenanceUpdatePolicy;
            return this;
        }

        /**
         * @param maintenanceUpdatePolicy MaintenanceUpdatePolicy defines the policy for system updates.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder maintenanceUpdatePolicy(ClusterMaintenanceUpdatePolicyArgs maintenanceUpdatePolicy) {
            return maintenanceUpdatePolicy(Output.of(maintenanceUpdatePolicy));
        }

        /**
         * @param migrationSources Cluster created via DMS migration.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder migrationSources(@Nullable Output<List<ClusterMigrationSourceArgs>> migrationSources) {
            $.migrationSources = migrationSources;
            return this;
        }

        /**
         * @param migrationSources Cluster created via DMS migration.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder migrationSources(List<ClusterMigrationSourceArgs> migrationSources) {
            return migrationSources(Output.of(migrationSources));
        }

        /**
         * @param migrationSources Cluster created via DMS migration.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder migrationSources(ClusterMigrationSourceArgs... migrationSources) {
            return migrationSources(List.of(migrationSources));
        }

        /**
         * @param name The name of the cluster resource.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the cluster resource.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param networkConfig Metadata related to network configuration.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder networkConfig(@Nullable Output<ClusterNetworkConfigArgs> networkConfig) {
            $.networkConfig = networkConfig;
            return this;
        }

        /**
         * @param networkConfig Metadata related to network configuration.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder networkConfig(ClusterNetworkConfigArgs networkConfig) {
            return networkConfig(Output.of(networkConfig));
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param pscConfig Configuration for Private Service Connect (PSC) for the cluster.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder pscConfig(@Nullable Output<ClusterPscConfigArgs> pscConfig) {
            $.pscConfig = pscConfig;
            return this;
        }

        /**
         * @param pscConfig Configuration for Private Service Connect (PSC) for the cluster.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder pscConfig(ClusterPscConfigArgs pscConfig) {
            return pscConfig(Output.of(pscConfig));
        }

        /**
         * @param pulumiLabels The combination of labels configured directly on the resource
         * and default labels configured on the provider.
         * 
         * @return builder
         * 
         */
        public Builder pulumiLabels(@Nullable Output<Map<String,String>> pulumiLabels) {
            $.pulumiLabels = pulumiLabels;
            return this;
        }

        /**
         * @param pulumiLabels The combination of labels configured directly on the resource
         * and default labels configured on the provider.
         * 
         * @return builder
         * 
         */
        public Builder pulumiLabels(Map<String,String> pulumiLabels) {
            return pulumiLabels(Output.of(pulumiLabels));
        }

        /**
         * @param reconciling Output only. Reconciling (https://google.aip.dev/128#reconciliation).
         * Set to true if the current state of Cluster does not match the user&#39;s intended state, and the service is actively updating the resource to reconcile them.
         * This can happen due to user-triggered updates or system actions like failover or maintenance.
         * 
         * @return builder
         * 
         */
        public Builder reconciling(@Nullable Output<Boolean> reconciling) {
            $.reconciling = reconciling;
            return this;
        }

        /**
         * @param reconciling Output only. Reconciling (https://google.aip.dev/128#reconciliation).
         * Set to true if the current state of Cluster does not match the user&#39;s intended state, and the service is actively updating the resource to reconcile them.
         * This can happen due to user-triggered updates or system actions like failover or maintenance.
         * 
         * @return builder
         * 
         */
        public Builder reconciling(Boolean reconciling) {
            return reconciling(Output.of(reconciling));
        }

        /**
         * @param restoreBackupSource The source when restoring from a backup. Conflicts with &#39;restore_continuous_backup_source&#39;, &#39;restore_backupdr_backup_source&#39; and &#39;restore_backupdr_pitr_source&#39;, they can&#39;t be set together.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder restoreBackupSource(@Nullable Output<ClusterRestoreBackupSourceArgs> restoreBackupSource) {
            $.restoreBackupSource = restoreBackupSource;
            return this;
        }

        /**
         * @param restoreBackupSource The source when restoring from a backup. Conflicts with &#39;restore_continuous_backup_source&#39;, &#39;restore_backupdr_backup_source&#39; and &#39;restore_backupdr_pitr_source&#39;, they can&#39;t be set together.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder restoreBackupSource(ClusterRestoreBackupSourceArgs restoreBackupSource) {
            return restoreBackupSource(Output.of(restoreBackupSource));
        }

        /**
         * @param restoreBackupdrBackupSource The source when restoring from a backup. Conflicts with &#39;restore_continuous_backup_source&#39;,  &#39;restore_backup_source&#39; and &#39;restore_backupdr_pitr_source&#39;, they can&#39;t be set together.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder restoreBackupdrBackupSource(@Nullable Output<ClusterRestoreBackupdrBackupSourceArgs> restoreBackupdrBackupSource) {
            $.restoreBackupdrBackupSource = restoreBackupdrBackupSource;
            return this;
        }

        /**
         * @param restoreBackupdrBackupSource The source when restoring from a backup. Conflicts with &#39;restore_continuous_backup_source&#39;,  &#39;restore_backup_source&#39; and &#39;restore_backupdr_pitr_source&#39;, they can&#39;t be set together.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder restoreBackupdrBackupSource(ClusterRestoreBackupdrBackupSourceArgs restoreBackupdrBackupSource) {
            return restoreBackupdrBackupSource(Output.of(restoreBackupdrBackupSource));
        }

        /**
         * @param restoreBackupdrPitrSource The BackupDR source used for point in time recovery. Conflicts with &#39;restore_backupdr_backup_source&#39;, &#39;restore_continuous_backup_source&#39; and &#39;restore_backupdr_backup_source&#39;, they can&#39;t be set togeter.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder restoreBackupdrPitrSource(@Nullable Output<ClusterRestoreBackupdrPitrSourceArgs> restoreBackupdrPitrSource) {
            $.restoreBackupdrPitrSource = restoreBackupdrPitrSource;
            return this;
        }

        /**
         * @param restoreBackupdrPitrSource The BackupDR source used for point in time recovery. Conflicts with &#39;restore_backupdr_backup_source&#39;, &#39;restore_continuous_backup_source&#39; and &#39;restore_backupdr_backup_source&#39;, they can&#39;t be set togeter.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder restoreBackupdrPitrSource(ClusterRestoreBackupdrPitrSourceArgs restoreBackupdrPitrSource) {
            return restoreBackupdrPitrSource(Output.of(restoreBackupdrPitrSource));
        }

        /**
         * @param restoreContinuousBackupSource The source when restoring via point in time recovery (PITR). Conflicts with &#39;restore_backup_source&#39;, &#39;restore_backupdr_backup_source&#39; and &#39;restore_backupdr_pitr_source&#39;, they can&#39;t be set together.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder restoreContinuousBackupSource(@Nullable Output<ClusterRestoreContinuousBackupSourceArgs> restoreContinuousBackupSource) {
            $.restoreContinuousBackupSource = restoreContinuousBackupSource;
            return this;
        }

        /**
         * @param restoreContinuousBackupSource The source when restoring via point in time recovery (PITR). Conflicts with &#39;restore_backup_source&#39;, &#39;restore_backupdr_backup_source&#39; and &#39;restore_backupdr_pitr_source&#39;, they can&#39;t be set together.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder restoreContinuousBackupSource(ClusterRestoreContinuousBackupSourceArgs restoreContinuousBackupSource) {
            return restoreContinuousBackupSource(Output.of(restoreContinuousBackupSource));
        }

        /**
         * @param secondaryConfig Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder secondaryConfig(@Nullable Output<ClusterSecondaryConfigArgs> secondaryConfig) {
            $.secondaryConfig = secondaryConfig;
            return this;
        }

        /**
         * @param secondaryConfig Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder secondaryConfig(ClusterSecondaryConfigArgs secondaryConfig) {
            return secondaryConfig(Output.of(secondaryConfig));
        }

        /**
         * @param skipAwaitMajorVersionUpgrade Set to true to skip awaiting on the major version upgrade of the cluster.
         * Possible values: true, false
         * Default value: &#34;true&#34;
         * 
         * @return builder
         * 
         */
        public Builder skipAwaitMajorVersionUpgrade(@Nullable Output<Boolean> skipAwaitMajorVersionUpgrade) {
            $.skipAwaitMajorVersionUpgrade = skipAwaitMajorVersionUpgrade;
            return this;
        }

        /**
         * @param skipAwaitMajorVersionUpgrade Set to true to skip awaiting on the major version upgrade of the cluster.
         * Possible values: true, false
         * Default value: &#34;true&#34;
         * 
         * @return builder
         * 
         */
        public Builder skipAwaitMajorVersionUpgrade(Boolean skipAwaitMajorVersionUpgrade) {
            return skipAwaitMajorVersionUpgrade(Output.of(skipAwaitMajorVersionUpgrade));
        }

        /**
         * @param state Output only. The current serving state of the cluster.
         * 
         * @return builder
         * 
         */
        public Builder state(@Nullable Output<String> state) {
            $.state = state;
            return this;
        }

        /**
         * @param state Output only. The current serving state of the cluster.
         * 
         * @return builder
         * 
         */
        public Builder state(String state) {
            return state(Output.of(state));
        }

        /**
         * @param subscriptionType The subscrition type of cluster.
         * Possible values are: `TRIAL`, `STANDARD`.
         * 
         * @return builder
         * 
         */
        public Builder subscriptionType(@Nullable Output<String> subscriptionType) {
            $.subscriptionType = subscriptionType;
            return this;
        }

        /**
         * @param subscriptionType The subscrition type of cluster.
         * Possible values are: `TRIAL`, `STANDARD`.
         * 
         * @return builder
         * 
         */
        public Builder subscriptionType(String subscriptionType) {
            return subscriptionType(Output.of(subscriptionType));
        }

        /**
         * @param trialMetadatas Contains information and all metadata related to TRIAL clusters.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder trialMetadatas(@Nullable Output<List<ClusterTrialMetadataArgs>> trialMetadatas) {
            $.trialMetadatas = trialMetadatas;
            return this;
        }

        /**
         * @param trialMetadatas Contains information and all metadata related to TRIAL clusters.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder trialMetadatas(List<ClusterTrialMetadataArgs> trialMetadatas) {
            return trialMetadatas(Output.of(trialMetadatas));
        }

        /**
         * @param trialMetadatas Contains information and all metadata related to TRIAL clusters.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder trialMetadatas(ClusterTrialMetadataArgs... trialMetadatas) {
            return trialMetadatas(List.of(trialMetadatas));
        }

        /**
         * @param uid The system-generated UID of the resource.
         * 
         * @return builder
         * 
         */
        public Builder uid(@Nullable Output<String> uid) {
            $.uid = uid;
            return this;
        }

        /**
         * @param uid The system-generated UID of the resource.
         * 
         * @return builder
         * 
         */
        public Builder uid(String uid) {
            return uid(Output.of(uid));
        }

        public ClusterState build() {
            return $;
        }
    }

}
