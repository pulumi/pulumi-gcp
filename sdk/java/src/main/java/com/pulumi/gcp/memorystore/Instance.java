// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.memorystore;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.memorystore.InstanceArgs;
import com.pulumi.gcp.memorystore.inputs.InstanceState;
import com.pulumi.gcp.memorystore.outputs.InstanceAutomatedBackupConfig;
import com.pulumi.gcp.memorystore.outputs.InstanceCrossInstanceReplicationConfig;
import com.pulumi.gcp.memorystore.outputs.InstanceDesiredAutoCreatedEndpoint;
import com.pulumi.gcp.memorystore.outputs.InstanceDesiredPscAutoConnection;
import com.pulumi.gcp.memorystore.outputs.InstanceDiscoveryEndpoint;
import com.pulumi.gcp.memorystore.outputs.InstanceEndpoint;
import com.pulumi.gcp.memorystore.outputs.InstanceGcsSource;
import com.pulumi.gcp.memorystore.outputs.InstanceMaintenancePolicy;
import com.pulumi.gcp.memorystore.outputs.InstanceMaintenanceSchedule;
import com.pulumi.gcp.memorystore.outputs.InstanceManagedBackupSource;
import com.pulumi.gcp.memorystore.outputs.InstanceManagedServerCa;
import com.pulumi.gcp.memorystore.outputs.InstanceNodeConfig;
import com.pulumi.gcp.memorystore.outputs.InstancePersistenceConfig;
import com.pulumi.gcp.memorystore.outputs.InstancePscAttachmentDetail;
import com.pulumi.gcp.memorystore.outputs.InstancePscAutoConnection;
import com.pulumi.gcp.memorystore.outputs.InstanceStateInfo;
import com.pulumi.gcp.memorystore.outputs.InstanceZoneDistributionConfig;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * A Google Cloud Memorystore instance.
 * 
 * To get more information about Instance, see:
 * 
 * * [API documentation](https://cloud.google.com/memorystore/docs/valkey/reference/rest/v1/projects.locations.instances)
 * * How-to Guides
 *     * [Official Documentation](https://cloud.google.com/memorystore/docs/valkey/create-instances)
 * 
 * ## Example Usage
 * 
 * ### Memorystore Instance Basic
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.Network;
 * import com.pulumi.gcp.compute.NetworkArgs;
 * import com.pulumi.gcp.compute.Subnetwork;
 * import com.pulumi.gcp.compute.SubnetworkArgs;
 * import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicy;
 * import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicyArgs;
 * import com.pulumi.gcp.networkconnectivity.inputs.ServiceConnectionPolicyPscConfigArgs;
 * import com.pulumi.gcp.organizations.OrganizationsFunctions;
 * import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
 * import com.pulumi.gcp.memorystore.Instance;
 * import com.pulumi.gcp.memorystore.InstanceArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstanceDesiredAutoCreatedEndpointArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstanceMaintenancePolicyArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var producerNet = new Network("producerNet", NetworkArgs.builder()
 *             .name("my-network")
 *             .autoCreateSubnetworks(false)
 *             .build());
 * 
 *         var producerSubnet = new Subnetwork("producerSubnet", SubnetworkArgs.builder()
 *             .name("my-subnet")
 *             .ipCidrRange("10.0.0.248/29")
 *             .region("us-central1")
 *             .network(producerNet.id())
 *             .build());
 * 
 *         var default_ = new ServiceConnectionPolicy("default", ServiceConnectionPolicyArgs.builder()
 *             .name("my-policy")
 *             .location("us-central1")
 *             .serviceClass("gcp-memorystore")
 *             .description("my basic service connection policy")
 *             .network(producerNet.id())
 *             .pscConfig(ServiceConnectionPolicyPscConfigArgs.builder()
 *                 .subnetworks(producerSubnet.id())
 *                 .build())
 *             .build());
 * 
 *         final var project = OrganizationsFunctions.getProject(GetProjectArgs.builder()
 *             .build());
 * 
 *         var instance_basic = new Instance("instance-basic", InstanceArgs.builder()
 *             .instanceId("basic-instance")
 *             .shardCount(1)
 *             .desiredAutoCreatedEndpoints(InstanceDesiredAutoCreatedEndpointArgs.builder()
 *                 .network(producerNet.id())
 *                 .projectId(project.projectId())
 *                 .build())
 *             .location("us-central1")
 *             .deletionProtectionEnabled(false)
 *             .maintenancePolicy(InstanceMaintenancePolicyArgs.builder()
 *                 .weeklyMaintenanceWindows(InstanceMaintenancePolicyWeeklyMaintenanceWindowArgs.builder()
 *                     .day("MONDAY")
 *                     .startTime(InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeArgs.builder()
 *                         .hours(1)
 *                         .minutes(0)
 *                         .seconds(0)
 *                         .nanos(0)
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(default_)
 *                 .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * ### Memorystore Instance Full
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.Network;
 * import com.pulumi.gcp.compute.NetworkArgs;
 * import com.pulumi.gcp.compute.Subnetwork;
 * import com.pulumi.gcp.compute.SubnetworkArgs;
 * import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicy;
 * import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicyArgs;
 * import com.pulumi.gcp.networkconnectivity.inputs.ServiceConnectionPolicyPscConfigArgs;
 * import com.pulumi.gcp.organizations.OrganizationsFunctions;
 * import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
 * import com.pulumi.gcp.memorystore.Instance;
 * import com.pulumi.gcp.memorystore.InstanceArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstanceDesiredAutoCreatedEndpointArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstanceZoneDistributionConfigArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstanceMaintenancePolicyArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstancePersistenceConfigArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstancePersistenceConfigRdbConfigArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var producerNet = new Network("producerNet", NetworkArgs.builder()
 *             .name("my-network")
 *             .autoCreateSubnetworks(false)
 *             .build());
 * 
 *         var producerSubnet = new Subnetwork("producerSubnet", SubnetworkArgs.builder()
 *             .name("my-subnet")
 *             .ipCidrRange("10.0.0.248/29")
 *             .region("us-central1")
 *             .network(producerNet.id())
 *             .build());
 * 
 *         var default_ = new ServiceConnectionPolicy("default", ServiceConnectionPolicyArgs.builder()
 *             .name("my-policy")
 *             .location("us-central1")
 *             .serviceClass("gcp-memorystore")
 *             .description("my basic service connection policy")
 *             .network(producerNet.id())
 *             .pscConfig(ServiceConnectionPolicyPscConfigArgs.builder()
 *                 .subnetworks(producerSubnet.id())
 *                 .build())
 *             .build());
 * 
 *         final var project = OrganizationsFunctions.getProject(GetProjectArgs.builder()
 *             .build());
 * 
 *         var instance_full = new Instance("instance-full", InstanceArgs.builder()
 *             .instanceId("full-instance")
 *             .shardCount(1)
 *             .desiredAutoCreatedEndpoints(InstanceDesiredAutoCreatedEndpointArgs.builder()
 *                 .network(producerNet.id())
 *                 .projectId(project.projectId())
 *                 .build())
 *             .location("us-central1")
 *             .replicaCount(1)
 *             .nodeType("SHARED_CORE_NANO")
 *             .transitEncryptionMode("TRANSIT_ENCRYPTION_DISABLED")
 *             .authorizationMode("AUTH_DISABLED")
 *             .kmsKey("my-key")
 *             .engineConfigs(Map.of("maxmemory-policy", "volatile-ttl"))
 *             .zoneDistributionConfig(InstanceZoneDistributionConfigArgs.builder()
 *                 .mode("SINGLE_ZONE")
 *                 .zone("us-central1-b")
 *                 .build())
 *             .maintenancePolicy(InstanceMaintenancePolicyArgs.builder()
 *                 .weeklyMaintenanceWindows(InstanceMaintenancePolicyWeeklyMaintenanceWindowArgs.builder()
 *                     .day("MONDAY")
 *                     .startTime(InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeArgs.builder()
 *                         .hours(1)
 *                         .minutes(0)
 *                         .seconds(0)
 *                         .nanos(0)
 *                         .build())
 *                     .build())
 *                 .build())
 *             .engineVersion("VALKEY_7_2")
 *             .deletionProtectionEnabled(false)
 *             .mode("CLUSTER")
 *             .persistenceConfig(InstancePersistenceConfigArgs.builder()
 *                 .mode("RDB")
 *                 .rdbConfig(InstancePersistenceConfigRdbConfigArgs.builder()
 *                     .rdbSnapshotPeriod("ONE_HOUR")
 *                     .rdbSnapshotStartTime("2024-10-02T15:01:23Z")
 *                     .build())
 *                 .build())
 *             .labels(Map.of("abc", "xyz"))
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(default_)
 *                 .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * ### Memorystore Instance Persistence Aof
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.Network;
 * import com.pulumi.gcp.compute.NetworkArgs;
 * import com.pulumi.gcp.compute.Subnetwork;
 * import com.pulumi.gcp.compute.SubnetworkArgs;
 * import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicy;
 * import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicyArgs;
 * import com.pulumi.gcp.networkconnectivity.inputs.ServiceConnectionPolicyPscConfigArgs;
 * import com.pulumi.gcp.organizations.OrganizationsFunctions;
 * import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
 * import com.pulumi.gcp.memorystore.Instance;
 * import com.pulumi.gcp.memorystore.InstanceArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstanceDesiredAutoCreatedEndpointArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstancePersistenceConfigArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstancePersistenceConfigAofConfigArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var producerNet = new Network("producerNet", NetworkArgs.builder()
 *             .name("my-network")
 *             .autoCreateSubnetworks(false)
 *             .build());
 * 
 *         var producerSubnet = new Subnetwork("producerSubnet", SubnetworkArgs.builder()
 *             .name("my-subnet")
 *             .ipCidrRange("10.0.0.248/29")
 *             .region("us-central1")
 *             .network(producerNet.id())
 *             .build());
 * 
 *         var default_ = new ServiceConnectionPolicy("default", ServiceConnectionPolicyArgs.builder()
 *             .name("my-policy")
 *             .location("us-central1")
 *             .serviceClass("gcp-memorystore")
 *             .description("my basic service connection policy")
 *             .network(producerNet.id())
 *             .pscConfig(ServiceConnectionPolicyPscConfigArgs.builder()
 *                 .subnetworks(producerSubnet.id())
 *                 .build())
 *             .build());
 * 
 *         final var project = OrganizationsFunctions.getProject(GetProjectArgs.builder()
 *             .build());
 * 
 *         var instance_persistence_aof = new Instance("instance-persistence-aof", InstanceArgs.builder()
 *             .instanceId("aof-instance")
 *             .shardCount(1)
 *             .desiredAutoCreatedEndpoints(InstanceDesiredAutoCreatedEndpointArgs.builder()
 *                 .network(producerNet.id())
 *                 .projectId(project.projectId())
 *                 .build())
 *             .location("us-central1")
 *             .persistenceConfig(InstancePersistenceConfigArgs.builder()
 *                 .mode("AOF")
 *                 .aofConfig(InstancePersistenceConfigAofConfigArgs.builder()
 *                     .appendFsync("EVERY_SEC")
 *                     .build())
 *                 .build())
 *             .deletionProtectionEnabled(false)
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(default_)
 *                 .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * ### Memorystore Instance Secondary Instance
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.compute.Network;
 * import com.pulumi.gcp.compute.NetworkArgs;
 * import com.pulumi.gcp.compute.Subnetwork;
 * import com.pulumi.gcp.compute.SubnetworkArgs;
 * import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicy;
 * import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicyArgs;
 * import com.pulumi.gcp.networkconnectivity.inputs.ServiceConnectionPolicyPscConfigArgs;
 * import com.pulumi.gcp.organizations.OrganizationsFunctions;
 * import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
 * import com.pulumi.gcp.memorystore.Instance;
 * import com.pulumi.gcp.memorystore.InstanceArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstanceDesiredAutoCreatedEndpointArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstanceZoneDistributionConfigArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstancePersistenceConfigArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstancePersistenceConfigRdbConfigArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstanceCrossInstanceReplicationConfigArgs;
 * import com.pulumi.gcp.memorystore.inputs.InstanceCrossInstanceReplicationConfigPrimaryInstanceArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var primaryProducerNet = new Network("primaryProducerNet", NetworkArgs.builder()
 *             .name("my-network-primary-instance")
 *             .autoCreateSubnetworks(false)
 *             .build());
 * 
 *         var primaryProducerSubnet = new Subnetwork("primaryProducerSubnet", SubnetworkArgs.builder()
 *             .name("my-subnet-primary-instance")
 *             .ipCidrRange("10.0.1.0/29")
 *             .region("asia-east1")
 *             .network(primaryProducerNet.id())
 *             .build());
 * 
 *         var primaryPolicy = new ServiceConnectionPolicy("primaryPolicy", ServiceConnectionPolicyArgs.builder()
 *             .name("my-policy-primary-instance")
 *             .location("asia-east1")
 *             .serviceClass("gcp-memorystore")
 *             .description("my basic service connection policy")
 *             .network(primaryProducerNet.id())
 *             .pscConfig(ServiceConnectionPolicyPscConfigArgs.builder()
 *                 .subnetworks(primaryProducerSubnet.id())
 *                 .build())
 *             .build());
 * 
 *         final var project = OrganizationsFunctions.getProject(GetProjectArgs.builder()
 *             .build());
 * 
 *         // Primary instance
 *         var primaryInstance = new Instance("primaryInstance", InstanceArgs.builder()
 *             .instanceId("primary-instance")
 *             .shardCount(1)
 *             .desiredAutoCreatedEndpoints(InstanceDesiredAutoCreatedEndpointArgs.builder()
 *                 .network(primaryProducerNet.id())
 *                 .projectId(project.projectId())
 *                 .build())
 *             .location("asia-east1")
 *             .replicaCount(1)
 *             .nodeType("SHARED_CORE_NANO")
 *             .transitEncryptionMode("TRANSIT_ENCRYPTION_DISABLED")
 *             .authorizationMode("AUTH_DISABLED")
 *             .engineConfigs(Map.of("maxmemory-policy", "volatile-ttl"))
 *             .zoneDistributionConfig(InstanceZoneDistributionConfigArgs.builder()
 *                 .mode("SINGLE_ZONE")
 *                 .zone("asia-east1-c")
 *                 .build())
 *             .deletionProtectionEnabled(true)
 *             .persistenceConfig(InstancePersistenceConfigArgs.builder()
 *                 .mode("RDB")
 *                 .rdbConfig(InstancePersistenceConfigRdbConfigArgs.builder()
 *                     .rdbSnapshotPeriod("ONE_HOUR")
 *                     .rdbSnapshotStartTime("2024-10-02T15:01:23Z")
 *                     .build())
 *                 .build())
 *             .labels(Map.of("abc", "xyz"))
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(primaryPolicy)
 *                 .build());
 * 
 *         var secondaryProducerNet = new Network("secondaryProducerNet", NetworkArgs.builder()
 *             .name("my-network-secondary-instance")
 *             .autoCreateSubnetworks(false)
 *             .build());
 * 
 *         var secondaryProducerSubnet = new Subnetwork("secondaryProducerSubnet", SubnetworkArgs.builder()
 *             .name("my-subnet-secondary-instance")
 *             .ipCidrRange("10.0.2.0/29")
 *             .region("europe-north1")
 *             .network(secondaryProducerNet.id())
 *             .build());
 * 
 *         var secondaryPolicy = new ServiceConnectionPolicy("secondaryPolicy", ServiceConnectionPolicyArgs.builder()
 *             .name("my-policy-secondary-instance")
 *             .location("europe-north1")
 *             .serviceClass("gcp-memorystore")
 *             .description("my basic service connection policy")
 *             .network(secondaryProducerNet.id())
 *             .pscConfig(ServiceConnectionPolicyPscConfigArgs.builder()
 *                 .subnetworks(secondaryProducerSubnet.id())
 *                 .build())
 *             .build());
 * 
 *         // Secondary instance
 *         var secondaryInstance = new Instance("secondaryInstance", InstanceArgs.builder()
 *             .instanceId("secondary-instance")
 *             .shardCount(1)
 *             .desiredAutoCreatedEndpoints(InstanceDesiredAutoCreatedEndpointArgs.builder()
 *                 .network(secondaryProducerNet.id())
 *                 .projectId(project.projectId())
 *                 .build())
 *             .location("europe-north1")
 *             .replicaCount(1)
 *             .nodeType("SHARED_CORE_NANO")
 *             .transitEncryptionMode("TRANSIT_ENCRYPTION_DISABLED")
 *             .authorizationMode("AUTH_DISABLED")
 *             .engineConfigs(Map.of("maxmemory-policy", "volatile-ttl"))
 *             .zoneDistributionConfig(InstanceZoneDistributionConfigArgs.builder()
 *                 .mode("SINGLE_ZONE")
 *                 .zone("europe-north1-c")
 *                 .build())
 *             .deletionProtectionEnabled(true)
 *             .crossInstanceReplicationConfig(InstanceCrossInstanceReplicationConfigArgs.builder()
 *                 .instanceRole("SECONDARY")
 *                 .primaryInstance(InstanceCrossInstanceReplicationConfigPrimaryInstanceArgs.builder()
 *                     .instance(primaryInstance.id())
 *                     .build())
 *                 .build())
 *             .persistenceConfig(InstancePersistenceConfigArgs.builder()
 *                 .mode("RDB")
 *                 .rdbConfig(InstancePersistenceConfigRdbConfigArgs.builder()
 *                     .rdbSnapshotPeriod("ONE_HOUR")
 *                     .rdbSnapshotStartTime("2024-10-02T15:01:23Z")
 *                     .build())
 *                 .build())
 *             .labels(Map.of("abc", "xyz"))
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(secondaryPolicy)
 *                 .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Import
 * 
 * Instance can be imported using any of these accepted formats:
 * 
 * * `projects/{{project}}/locations/{{location}}/instances/{{instance_id}}`
 * 
 * * `{{project}}/{{location}}/{{instance_id}}`
 * 
 * * `{{location}}/{{instance_id}}`
 * 
 * When using the `pulumi import` command, Instance can be imported using one of the formats above. For example:
 * 
 * ```sh
 * $ pulumi import gcp:memorystore/instance:Instance default projects/{{project}}/locations/{{location}}/instances/{{instance_id}}
 * ```
 * 
 * ```sh
 * $ pulumi import gcp:memorystore/instance:Instance default {{project}}/{{location}}/{{instance_id}}
 * ```
 * 
 * ```sh
 * $ pulumi import gcp:memorystore/instance:Instance default {{location}}/{{instance_id}}
 * ```
 * 
 */
@ResourceType(type="gcp:memorystore/instance:Instance")
public class Instance extends com.pulumi.resources.CustomResource {
    /**
     * Optional. Immutable. Authorization mode of the instance. Possible values:
     * AUTH_DISABLED
     * IAM_AUTH
     * 
     */
    @Export(name="authorizationMode", refs={String.class}, tree="[0]")
    private Output<String> authorizationMode;

    /**
     * @return Optional. Immutable. Authorization mode of the instance. Possible values:
     * AUTH_DISABLED
     * IAM_AUTH
     * 
     */
    public Output<String> authorizationMode() {
        return this.authorizationMode;
    }
    /**
     * The automated backup config for a instance.
     * Structure is documented below.
     * 
     */
    @Export(name="automatedBackupConfig", refs={InstanceAutomatedBackupConfig.class}, tree="[0]")
    private Output</* @Nullable */ InstanceAutomatedBackupConfig> automatedBackupConfig;

    /**
     * @return The automated backup config for a instance.
     * Structure is documented below.
     * 
     */
    public Output<Optional<InstanceAutomatedBackupConfig>> automatedBackupConfig() {
        return Codegen.optional(this.automatedBackupConfig);
    }
    /**
     * This field is used to determine the available maintenance versions for the self service update.
     * 
     */
    @Export(name="availableMaintenanceVersions", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> availableMaintenanceVersions;

    /**
     * @return This field is used to determine the available maintenance versions for the self service update.
     * 
     */
    public Output<List<String>> availableMaintenanceVersions() {
        return this.availableMaintenanceVersions;
    }
    /**
     * The backup collection full resource name.
     * Example: projects/{project}/locations/{location}/backupCollections/{collection}
     * 
     */
    @Export(name="backupCollection", refs={String.class}, tree="[0]")
    private Output<String> backupCollection;

    /**
     * @return The backup collection full resource name.
     * Example: projects/{project}/locations/{location}/backupCollections/{collection}
     * 
     */
    public Output<String> backupCollection() {
        return this.backupCollection;
    }
    /**
     * Output only. Creation timestamp of the instance.
     * 
     */
    @Export(name="createTime", refs={String.class}, tree="[0]")
    private Output<String> createTime;

    /**
     * @return Output only. Creation timestamp of the instance.
     * 
     */
    public Output<String> createTime() {
        return this.createTime;
    }
    /**
     * Cross instance replication config
     * Structure is documented below.
     * 
     */
    @Export(name="crossInstanceReplicationConfig", refs={InstanceCrossInstanceReplicationConfig.class}, tree="[0]")
    private Output<InstanceCrossInstanceReplicationConfig> crossInstanceReplicationConfig;

    /**
     * @return Cross instance replication config
     * Structure is documented below.
     * 
     */
    public Output<InstanceCrossInstanceReplicationConfig> crossInstanceReplicationConfig() {
        return this.crossInstanceReplicationConfig;
    }
    /**
     * Optional. If set to true deletion of the instance will fail.
     * 
     */
    @Export(name="deletionProtectionEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> deletionProtectionEnabled;

    /**
     * @return Optional. If set to true deletion of the instance will fail.
     * 
     */
    public Output<Optional<Boolean>> deletionProtectionEnabled() {
        return Codegen.optional(this.deletionProtectionEnabled);
    }
    /**
     * Immutable. User inputs for the auto-created endpoints connections.
     * 
     */
    @Export(name="desiredAutoCreatedEndpoints", refs={List.class,InstanceDesiredAutoCreatedEndpoint.class}, tree="[0,1]")
    private Output</* @Nullable */ List<InstanceDesiredAutoCreatedEndpoint>> desiredAutoCreatedEndpoints;

    /**
     * @return Immutable. User inputs for the auto-created endpoints connections.
     * 
     */
    public Output<Optional<List<InstanceDesiredAutoCreatedEndpoint>>> desiredAutoCreatedEndpoints() {
        return Codegen.optional(this.desiredAutoCreatedEndpoints);
    }
    /**
     * `desiredPscAutoConnections` is deprecated  Use `desiredAutoCreatedEndpoints` instead `pulumi import` will only work with desiredAutoCreatedEndpoints`.
     * 
     * @deprecated
     * `desiredPscAutoConnections` is deprecated. Use `desiredAutoCreatedEndpoints` instead. `terraform import` will only work with desiredAutoCreatedEndpoints`.
     * 
     */
    @Deprecated /* `desiredPscAutoConnections` is deprecated. Use `desiredAutoCreatedEndpoints` instead. `terraform import` will only work with desiredAutoCreatedEndpoints`. */
    @Export(name="desiredPscAutoConnections", refs={List.class,InstanceDesiredPscAutoConnection.class}, tree="[0,1]")
    private Output</* @Nullable */ List<InstanceDesiredPscAutoConnection>> desiredPscAutoConnections;

    /**
     * @return `desiredPscAutoConnections` is deprecated  Use `desiredAutoCreatedEndpoints` instead `pulumi import` will only work with desiredAutoCreatedEndpoints`.
     * 
     */
    public Output<Optional<List<InstanceDesiredPscAutoConnection>>> desiredPscAutoConnections() {
        return Codegen.optional(this.desiredPscAutoConnections);
    }
    /**
     * (Deprecated)
     * Deprecated. Output only. Endpoints clients can connect to the instance through.
     * Structure is documented below.
     * 
     * @deprecated
     * This field is deprecated. As a result it will not be populated if the connections are created using `desiredAutoCreatedEndpoints` parameter or `gcp.memorystore.InstanceDesiredUserCreatedEndpoints` resource. Instead of this parameter, for discovery, use `endpoints.connections.pscConnection` and `endpoints.connections.pscAutoConnection` with `connectionType` CONNECTION_TYPE_DISCOVERY.
     * 
     */
    @Deprecated /* This field is deprecated. As a result it will not be populated if the connections are created using `desiredAutoCreatedEndpoints` parameter or `gcp.memorystore.InstanceDesiredUserCreatedEndpoints` resource. Instead of this parameter, for discovery, use `endpoints.connections.pscConnection` and `endpoints.connections.pscAutoConnection` with `connectionType` CONNECTION_TYPE_DISCOVERY. */
    @Export(name="discoveryEndpoints", refs={List.class,InstanceDiscoveryEndpoint.class}, tree="[0,1]")
    private Output<List<InstanceDiscoveryEndpoint>> discoveryEndpoints;

    /**
     * @return (Deprecated)
     * Deprecated. Output only. Endpoints clients can connect to the instance through.
     * Structure is documented below.
     * 
     */
    public Output<List<InstanceDiscoveryEndpoint>> discoveryEndpoints() {
        return this.discoveryEndpoints;
    }
    /**
     * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     * 
     */
    @Export(name="effectiveLabels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> effectiveLabels;

    /**
     * @return All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     * 
     */
    public Output<Map<String,String>> effectiveLabels() {
        return this.effectiveLabels;
    }
    /**
     * This field represents the actual maintenance version of the cluster.
     * 
     */
    @Export(name="effectiveMaintenanceVersion", refs={String.class}, tree="[0]")
    private Output<String> effectiveMaintenanceVersion;

    /**
     * @return This field represents the actual maintenance version of the cluster.
     * 
     */
    public Output<String> effectiveMaintenanceVersion() {
        return this.effectiveMaintenanceVersion;
    }
    /**
     * Endpoints for the instance.
     * Structure is documented below.
     * 
     */
    @Export(name="endpoints", refs={List.class,InstanceEndpoint.class}, tree="[0,1]")
    private Output<List<InstanceEndpoint>> endpoints;

    /**
     * @return Endpoints for the instance.
     * Structure is documented below.
     * 
     */
    public Output<List<InstanceEndpoint>> endpoints() {
        return this.endpoints;
    }
    /**
     * Optional. User-provided engine configurations for the instance.
     * 
     */
    @Export(name="engineConfigs", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> engineConfigs;

    /**
     * @return Optional. User-provided engine configurations for the instance.
     * 
     */
    public Output<Optional<Map<String,String>>> engineConfigs() {
        return Codegen.optional(this.engineConfigs);
    }
    /**
     * Optional. Engine version of the instance.
     * 
     */
    @Export(name="engineVersion", refs={String.class}, tree="[0]")
    private Output<String> engineVersion;

    /**
     * @return Optional. Engine version of the instance.
     * 
     */
    public Output<String> engineVersion() {
        return this.engineVersion;
    }
    /**
     * GCS source for the instance.
     * Structure is documented below.
     * 
     */
    @Export(name="gcsSource", refs={InstanceGcsSource.class}, tree="[0]")
    private Output</* @Nullable */ InstanceGcsSource> gcsSource;

    /**
     * @return GCS source for the instance.
     * Structure is documented below.
     * 
     */
    public Output<Optional<InstanceGcsSource>> gcsSource() {
        return Codegen.optional(this.gcsSource);
    }
    /**
     * Required. The ID to use for the instance, which will become the final component of
     * the instance&#39;s resource name.
     * This value is subject to the following restrictions:
     * * Must be 4-63 characters in length
     * * Must begin with a letter or digit
     * * Must contain only lowercase letters, digits, and hyphens
     * * Must not end with a hyphen
     * * Must be unique within a location
     * 
     */
    @Export(name="instanceId", refs={String.class}, tree="[0]")
    private Output<String> instanceId;

    /**
     * @return Required. The ID to use for the instance, which will become the final component of
     * the instance&#39;s resource name.
     * This value is subject to the following restrictions:
     * * Must be 4-63 characters in length
     * * Must begin with a letter or digit
     * * Must contain only lowercase letters, digits, and hyphens
     * * Must not end with a hyphen
     * * Must be unique within a location
     * 
     */
    public Output<String> instanceId() {
        return this.instanceId;
    }
    /**
     * The KMS key used to encrypt the at-rest data of the cluster
     * 
     */
    @Export(name="kmsKey", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> kmsKey;

    /**
     * @return The KMS key used to encrypt the at-rest data of the cluster
     * 
     */
    public Output<Optional<String>> kmsKey() {
        return Codegen.optional(this.kmsKey);
    }
    /**
     * Optional. Labels to represent user-provided metadata.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     * 
     */
    @Export(name="labels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> labels;

    /**
     * @return Optional. Labels to represent user-provided metadata.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> labels() {
        return Codegen.optional(this.labels);
    }
    /**
     * Resource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `memorystore.googleapis.com/CertificateAuthority`.
     * 
     */
    @Export(name="location", refs={String.class}, tree="[0]")
    private Output<String> location;

    /**
     * @return Resource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `memorystore.googleapis.com/CertificateAuthority`.
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * Maintenance policy for a cluster
     * Structure is documented below.
     * 
     */
    @Export(name="maintenancePolicy", refs={InstanceMaintenancePolicy.class}, tree="[0]")
    private Output</* @Nullable */ InstanceMaintenancePolicy> maintenancePolicy;

    /**
     * @return Maintenance policy for a cluster
     * Structure is documented below.
     * 
     */
    public Output<Optional<InstanceMaintenancePolicy>> maintenancePolicy() {
        return Codegen.optional(this.maintenancePolicy);
    }
    /**
     * Upcoming maintenance schedule.
     * Structure is documented below.
     * 
     */
    @Export(name="maintenanceSchedules", refs={List.class,InstanceMaintenanceSchedule.class}, tree="[0,1]")
    private Output<List<InstanceMaintenanceSchedule>> maintenanceSchedules;

    /**
     * @return Upcoming maintenance schedule.
     * Structure is documented below.
     * 
     */
    public Output<List<InstanceMaintenanceSchedule>> maintenanceSchedules() {
        return this.maintenanceSchedules;
    }
    /**
     * This field can be used to trigger self service update to indicate the desired maintenance version. The input to this field can be determined by the availableMaintenanceVersions field.
     * *Note*: This field can only be specified when updating an existing cluster to a newer version. Downgrades are currently not supported!
     * 
     */
    @Export(name="maintenanceVersion", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> maintenanceVersion;

    /**
     * @return This field can be used to trigger self service update to indicate the desired maintenance version. The input to this field can be determined by the availableMaintenanceVersions field.
     * *Note*: This field can only be specified when updating an existing cluster to a newer version. Downgrades are currently not supported!
     * 
     */
    public Output<Optional<String>> maintenanceVersion() {
        return Codegen.optional(this.maintenanceVersion);
    }
    /**
     * Managed backup source for the instance.
     * Structure is documented below.
     * 
     */
    @Export(name="managedBackupSource", refs={InstanceManagedBackupSource.class}, tree="[0]")
    private Output</* @Nullable */ InstanceManagedBackupSource> managedBackupSource;

    /**
     * @return Managed backup source for the instance.
     * Structure is documented below.
     * 
     */
    public Output<Optional<InstanceManagedBackupSource>> managedBackupSource() {
        return Codegen.optional(this.managedBackupSource);
    }
    /**
     * Instance&#39;s Certificate Authority. This field will only be populated if instance&#39;s transitEncryptionMode is SERVER_AUTHENTICATION
     * Structure is documented below.
     * 
     */
    @Export(name="managedServerCas", refs={List.class,InstanceManagedServerCa.class}, tree="[0,1]")
    private Output<List<InstanceManagedServerCa>> managedServerCas;

    /**
     * @return Instance&#39;s Certificate Authority. This field will only be populated if instance&#39;s transitEncryptionMode is SERVER_AUTHENTICATION
     * Structure is documented below.
     * 
     */
    public Output<List<InstanceManagedServerCa>> managedServerCas() {
        return this.managedServerCas;
    }
    /**
     * Optional. cluster or cluster-disabled.
     * Possible values:
     * CLUSTER
     * CLUSTER_DISABLED
     * Possible values are: `CLUSTER`, `CLUSTER_DISABLED`.
     * 
     */
    @Export(name="mode", refs={String.class}, tree="[0]")
    private Output<String> mode;

    /**
     * @return Optional. cluster or cluster-disabled.
     * Possible values:
     * CLUSTER
     * CLUSTER_DISABLED
     * Possible values are: `CLUSTER`, `CLUSTER_DISABLED`.
     * 
     */
    public Output<String> mode() {
        return this.mode;
    }
    /**
     * Identifier. Unique name of the instance.
     * Format: projects/{project}/locations/{location}/instances/{instance}
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return Identifier. Unique name of the instance.
     * Format: projects/{project}/locations/{location}/instances/{instance}
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Represents configuration for nodes of the instance.
     * Structure is documented below.
     * 
     */
    @Export(name="nodeConfigs", refs={List.class,InstanceNodeConfig.class}, tree="[0,1]")
    private Output<List<InstanceNodeConfig>> nodeConfigs;

    /**
     * @return Represents configuration for nodes of the instance.
     * Structure is documented below.
     * 
     */
    public Output<List<InstanceNodeConfig>> nodeConfigs() {
        return this.nodeConfigs;
    }
    /**
     * Optional. Machine type for individual nodes of the instance.
     * Possible values:
     * SHARED_CORE_NANO
     * HIGHMEM_MEDIUM
     * HIGHMEM_XLARGE
     * STANDARD_SMALL
     * 
     */
    @Export(name="nodeType", refs={String.class}, tree="[0]")
    private Output<String> nodeType;

    /**
     * @return Optional. Machine type for individual nodes of the instance.
     * Possible values:
     * SHARED_CORE_NANO
     * HIGHMEM_MEDIUM
     * HIGHMEM_XLARGE
     * STANDARD_SMALL
     * 
     */
    public Output<String> nodeType() {
        return this.nodeType;
    }
    /**
     * Represents persistence configuration for a instance.
     * Structure is documented below.
     * 
     */
    @Export(name="persistenceConfig", refs={InstancePersistenceConfig.class}, tree="[0]")
    private Output<InstancePersistenceConfig> persistenceConfig;

    /**
     * @return Represents persistence configuration for a instance.
     * Structure is documented below.
     * 
     */
    public Output<InstancePersistenceConfig> persistenceConfig() {
        return this.persistenceConfig;
    }
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Export(name="project", refs={String.class}, tree="[0]")
    private Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Output<String> project() {
        return this.project;
    }
    /**
     * Configuration of a service attachment of the cluster, for creating PSC connections.
     * Structure is documented below.
     * 
     */
    @Export(name="pscAttachmentDetails", refs={List.class,InstancePscAttachmentDetail.class}, tree="[0,1]")
    private Output<List<InstancePscAttachmentDetail>> pscAttachmentDetails;

    /**
     * @return Configuration of a service attachment of the cluster, for creating PSC connections.
     * Structure is documented below.
     * 
     */
    public Output<List<InstancePscAttachmentDetail>> pscAttachmentDetails() {
        return this.pscAttachmentDetails;
    }
    /**
     * (Deprecated)
     * Output only. User inputs and resource details of the auto-created PSC connections.
     * Structure is documented below.
     * 
     * @deprecated
     * `pscAutoConnections` is deprecated  Use `endpoints.connections.pscAutoConnections` instead.
     * 
     */
    @Deprecated /* `pscAutoConnections` is deprecated  Use `endpoints.connections.pscAutoConnections` instead. */
    @Export(name="pscAutoConnections", refs={List.class,InstancePscAutoConnection.class}, tree="[0,1]")
    private Output<List<InstancePscAutoConnection>> pscAutoConnections;

    /**
     * @return (Deprecated)
     * Output only. User inputs and resource details of the auto-created PSC connections.
     * Structure is documented below.
     * 
     */
    public Output<List<InstancePscAutoConnection>> pscAutoConnections() {
        return this.pscAutoConnections;
    }
    /**
     * The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     * 
     */
    @Export(name="pulumiLabels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> pulumiLabels;

    /**
     * @return The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     * 
     */
    public Output<Map<String,String>> pulumiLabels() {
        return this.pulumiLabels;
    }
    /**
     * Optional. Number of replica nodes per shard. If omitted the default is 0 replicas.
     * 
     */
    @Export(name="replicaCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> replicaCount;

    /**
     * @return Optional. Number of replica nodes per shard. If omitted the default is 0 replicas.
     * 
     */
    public Output<Integer> replicaCount() {
        return this.replicaCount;
    }
    /**
     * Required. Number of shards for the instance.
     * 
     */
    @Export(name="shardCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> shardCount;

    /**
     * @return Required. Number of shards for the instance.
     * 
     */
    public Output<Integer> shardCount() {
        return this.shardCount;
    }
    /**
     * Output only. Current state of the instance.
     * Possible values:
     * CREATING
     * ACTIVE
     * UPDATING
     * DELETING
     * 
     */
    @Export(name="state", refs={String.class}, tree="[0]")
    private Output<String> state;

    /**
     * @return Output only. Current state of the instance.
     * Possible values:
     * CREATING
     * ACTIVE
     * UPDATING
     * DELETING
     * 
     */
    public Output<String> state() {
        return this.state;
    }
    /**
     * Additional information about the state of the instance.
     * Structure is documented below.
     * 
     */
    @Export(name="stateInfos", refs={List.class,InstanceStateInfo.class}, tree="[0,1]")
    private Output<List<InstanceStateInfo>> stateInfos;

    /**
     * @return Additional information about the state of the instance.
     * Structure is documented below.
     * 
     */
    public Output<List<InstanceStateInfo>> stateInfos() {
        return this.stateInfos;
    }
    /**
     * Optional. Immutable. In-transit encryption mode of the instance.
     * Possible values:
     * TRANSIT_ENCRYPTION_DISABLED
     * SERVER_AUTHENTICATION
     * 
     */
    @Export(name="transitEncryptionMode", refs={String.class}, tree="[0]")
    private Output<String> transitEncryptionMode;

    /**
     * @return Optional. Immutable. In-transit encryption mode of the instance.
     * Possible values:
     * TRANSIT_ENCRYPTION_DISABLED
     * SERVER_AUTHENTICATION
     * 
     */
    public Output<String> transitEncryptionMode() {
        return this.transitEncryptionMode;
    }
    /**
     * Output only. System assigned, unique identifier for the instance.
     * 
     */
    @Export(name="uid", refs={String.class}, tree="[0]")
    private Output<String> uid;

    /**
     * @return Output only. System assigned, unique identifier for the instance.
     * 
     */
    public Output<String> uid() {
        return this.uid;
    }
    /**
     * Output only. Latest update timestamp of the instance.
     * 
     */
    @Export(name="updateTime", refs={String.class}, tree="[0]")
    private Output<String> updateTime;

    /**
     * @return Output only. Latest update timestamp of the instance.
     * 
     */
    public Output<String> updateTime() {
        return this.updateTime;
    }
    /**
     * Zone distribution configuration for allocation of instance resources.
     * Structure is documented below.
     * 
     */
    @Export(name="zoneDistributionConfig", refs={InstanceZoneDistributionConfig.class}, tree="[0]")
    private Output<InstanceZoneDistributionConfig> zoneDistributionConfig;

    /**
     * @return Zone distribution configuration for allocation of instance resources.
     * Structure is documented below.
     * 
     */
    public Output<InstanceZoneDistributionConfig> zoneDistributionConfig() {
        return this.zoneDistributionConfig;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Instance(java.lang.String name) {
        this(name, InstanceArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Instance(java.lang.String name, InstanceArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Instance(java.lang.String name, InstanceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:memorystore/instance:Instance", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Instance(java.lang.String name, Output<java.lang.String> id, @Nullable InstanceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:memorystore/instance:Instance", name, state, makeResourceOptions(options, id), false);
    }

    private static InstanceArgs makeArgs(InstanceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? InstanceArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "effectiveLabels",
                "pulumiLabels"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Instance get(java.lang.String name, Output<java.lang.String> id, @Nullable InstanceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Instance(name, id, state, options);
    }
}
