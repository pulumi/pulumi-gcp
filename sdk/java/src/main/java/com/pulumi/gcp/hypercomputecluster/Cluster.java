// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.hypercomputecluster;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.hypercomputecluster.ClusterArgs;
import com.pulumi.gcp.hypercomputecluster.inputs.ClusterState;
import com.pulumi.gcp.hypercomputecluster.outputs.ClusterComputeResource;
import com.pulumi.gcp.hypercomputecluster.outputs.ClusterNetworkResource;
import com.pulumi.gcp.hypercomputecluster.outputs.ClusterOrchestrator;
import com.pulumi.gcp.hypercomputecluster.outputs.ClusterStorageResource;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * A collection of virtual machines and connected resources forming a high-performance computing cluster capable of running large-scale, tightly coupled workloads. A cluster combines a set a compute resources that perform computations, storage resources that contain inputs and store outputs, an orchestrator that is responsible for assigning jobs to compute resources, and network resources that connect everything together.
 * 
 * ## Example Usage
 * 
 * ### Hypercomputecluster Cluster Basic
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.organizations.OrganizationsFunctions;
 * import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
 * import com.pulumi.gcp.hypercomputecluster.Cluster;
 * import com.pulumi.gcp.hypercomputecluster.ClusterArgs;
 * import com.pulumi.gcp.hypercomputecluster.inputs.ClusterNetworkResourceArgs;
 * import com.pulumi.gcp.hypercomputecluster.inputs.ClusterNetworkResourceConfigArgs;
 * import com.pulumi.gcp.hypercomputecluster.inputs.ClusterNetworkResourceConfigNewNetworkArgs;
 * import com.pulumi.gcp.hypercomputecluster.inputs.ClusterComputeResourceArgs;
 * import com.pulumi.gcp.hypercomputecluster.inputs.ClusterComputeResourceConfigArgs;
 * import com.pulumi.gcp.hypercomputecluster.inputs.ClusterComputeResourceConfigNewOnDemandInstancesArgs;
 * import com.pulumi.gcp.hypercomputecluster.inputs.ClusterOrchestratorArgs;
 * import com.pulumi.gcp.hypercomputecluster.inputs.ClusterOrchestratorSlurmArgs;
 * import com.pulumi.gcp.hypercomputecluster.inputs.ClusterOrchestratorSlurmLoginNodesArgs;
 * import com.pulumi.gcp.hypercomputecluster.inputs.ClusterOrchestratorSlurmLoginNodesBootDiskArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         final var project = OrganizationsFunctions.getProject(GetProjectArgs.builder()
 *             .build());
 * 
 *         final var projectId = project.name();
 * 
 *         var cluster = new Cluster("cluster", ClusterArgs.builder()
 *             .clusterId("my-cluster")
 *             .location("us-central1")
 *             .description("Cluster Director instance created through Terraform")
 *             .networkResources(ClusterNetworkResourceArgs.builder()
 *                 .id("network1")
 *                 .config(ClusterNetworkResourceConfigArgs.builder()
 *                     .newNetwork(ClusterNetworkResourceConfigNewNetworkArgs.builder()
 *                         .description("Network one")
 *                         .network(String.format("projects/%s/global/networks/cluster-net1", projectId))
 *                         .build())
 *                     .build())
 *                 .build())
 *             .computeResources(ClusterComputeResourceArgs.builder()
 *                 .id("compute1")
 *                 .config(ClusterComputeResourceConfigArgs.builder()
 *                     .newOnDemandInstances(ClusterComputeResourceConfigNewOnDemandInstancesArgs.builder()
 *                         .machineType("n2-standard-2")
 *                         .zone("us-central1-a")
 *                         .build())
 *                     .build())
 *                 .build())
 *             .orchestrator(ClusterOrchestratorArgs.builder()
 *                 .slurm(ClusterOrchestratorSlurmArgs.builder()
 *                     .loginNodes(ClusterOrchestratorSlurmLoginNodesArgs.builder()
 *                         .machineType("n2-standard-2")
 *                         .count("1")
 *                         .zone("us-central1-a")
 *                         .bootDisk(ClusterOrchestratorSlurmLoginNodesBootDiskArgs.builder()
 *                             .sizeGb("100")
 *                             .type("pd-balanced")
 *                             .build())
 *                         .build())
 *                     .nodeSets(ClusterOrchestratorSlurmNodeSetArgs.builder()
 *                         .id("nodeset1")
 *                         .computeId("compute1")
 *                         .staticNodeCount("1")
 *                         .computeInstance(ClusterOrchestratorSlurmNodeSetComputeInstanceArgs.builder()
 *                             .bootDisk(ClusterOrchestratorSlurmNodeSetComputeInstanceBootDiskArgs.builder()
 *                                 .sizeGb("100")
 *                                 .type("pd-balanced")
 *                                 .build())
 *                             .build())
 *                         .build())
 *                     .partitions(ClusterOrchestratorSlurmPartitionArgs.builder()
 *                         .id("partition1")
 *                         .nodeSetIds("nodeset1")
 *                         .build())
 *                     .defaultPartition("partition1")
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Import
 * 
 * Cluster can be imported using any of these accepted formats:
 * 
 * * `projects/{{project}}/locations/{{location}}/clusters/{{cluster_id}}`
 * * `{{project}}/{{location}}/{{cluster_id}}`
 * * `{{location}}/{{cluster_id}}`
 * 
 * When using the `pulumi import` command, Cluster can be imported using one of the formats above. For example:
 * 
 * ```sh
 * $ pulumi import gcp:hypercomputecluster/cluster:Cluster default projects/{{project}}/locations/{{location}}/clusters/{{cluster_id}}
 * $ pulumi import gcp:hypercomputecluster/cluster:Cluster default {{project}}/{{location}}/{{cluster_id}}
 * $ pulumi import gcp:hypercomputecluster/cluster:Cluster default {{location}}/{{cluster_id}}
 * ```
 * 
 */
@ResourceType(type="gcp:hypercomputecluster/cluster:Cluster")
public class Cluster extends com.pulumi.resources.CustomResource {
    /**
     * ID of the cluster to create. Must conform to
     * [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
     * alphanumeric, and at most 63 characters).
     * 
     */
    @Export(name="clusterId", refs={String.class}, tree="[0]")
    private Output<String> clusterId;

    /**
     * @return ID of the cluster to create. Must conform to
     * [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
     * alphanumeric, and at most 63 characters).
     * 
     */
    public Output<String> clusterId() {
        return this.clusterId;
    }
    /**
     * Compute resources available to the cluster. Keys specify the ID of the
     * compute resource by which it can be referenced elsewhere, and must conform
     * to [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
     * alphanumeric, and at most 63 characters).
     * Structure is documented below.
     * 
     */
    @Export(name="computeResources", refs={List.class,ClusterComputeResource.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ClusterComputeResource>> computeResources;

    /**
     * @return Compute resources available to the cluster. Keys specify the ID of the
     * compute resource by which it can be referenced elsewhere, and must conform
     * to [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
     * alphanumeric, and at most 63 characters).
     * Structure is documented below.
     * 
     */
    public Output<Optional<List<ClusterComputeResource>>> computeResources() {
        return Codegen.optional(this.computeResources);
    }
    /**
     * Time that the cluster was originally created.
     * 
     */
    @Export(name="createTime", refs={String.class}, tree="[0]")
    private Output<String> createTime;

    /**
     * @return Time that the cluster was originally created.
     * 
     */
    public Output<String> createTime() {
        return this.createTime;
    }
    /**
     * User-provided description of the cluster.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return User-provided description of the cluster.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     * 
     */
    @Export(name="effectiveLabels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> effectiveLabels;

    /**
     * @return All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     * 
     */
    public Output<Map<String,String>> effectiveLabels() {
        return this.effectiveLabels;
    }
    /**
     * [Labels](https://cloud.google.com/compute/docs/labeling-resources) applied
     * to the cluster. Labels can be used to organize clusters and to filter them
     * in queries.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     * 
     */
    @Export(name="labels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> labels;

    /**
     * @return [Labels](https://cloud.google.com/compute/docs/labeling-resources) applied
     * to the cluster. Labels can be used to organize clusters and to filter them
     * in queries.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> labels() {
        return Codegen.optional(this.labels);
    }
    /**
     * Resource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122.
     * 
     */
    @Export(name="location", refs={String.class}, tree="[0]")
    private Output<String> location;

    /**
     * @return Resource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122.
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * Identifier. [Relative resource name](https://google.aip.dev/122) of the cluster, in the
     * format `projects/{project}/locations/{location}/clusters/{cluster}`.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return Identifier. [Relative resource name](https://google.aip.dev/122) of the cluster, in the
     * format `projects/{project}/locations/{location}/clusters/{cluster}`.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Network resources available to the cluster. Must contain at most one value.
     * Keys specify the ID of the network resource by which it can be referenced
     * elsewhere, and must conform to
     * [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
     * alphanumeric, and at most 63 characters).
     * Structure is documented below.
     * 
     */
    @Export(name="networkResources", refs={List.class,ClusterNetworkResource.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ClusterNetworkResource>> networkResources;

    /**
     * @return Network resources available to the cluster. Must contain at most one value.
     * Keys specify the ID of the network resource by which it can be referenced
     * elsewhere, and must conform to
     * [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
     * alphanumeric, and at most 63 characters).
     * Structure is documented below.
     * 
     */
    public Output<Optional<List<ClusterNetworkResource>>> networkResources() {
        return Codegen.optional(this.networkResources);
    }
    /**
     * The component responsible for scheduling and running workloads on the
     * cluster as well as providing the user interface for interacting with the
     * cluster at runtime.
     * Structure is documented below.
     * 
     */
    @Export(name="orchestrator", refs={ClusterOrchestrator.class}, tree="[0]")
    private Output</* @Nullable */ ClusterOrchestrator> orchestrator;

    /**
     * @return The component responsible for scheduling and running workloads on the
     * cluster as well as providing the user interface for interacting with the
     * cluster at runtime.
     * Structure is documented below.
     * 
     */
    public Output<Optional<ClusterOrchestrator>> orchestrator() {
        return Codegen.optional(this.orchestrator);
    }
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Export(name="project", refs={String.class}, tree="[0]")
    private Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Output<String> project() {
        return this.project;
    }
    /**
     * The combination of labels configured directly on the resource
     *  and default labels configured on the provider.
     * 
     */
    @Export(name="pulumiLabels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> pulumiLabels;

    /**
     * @return The combination of labels configured directly on the resource
     *  and default labels configured on the provider.
     * 
     */
    public Output<Map<String,String>> pulumiLabels() {
        return this.pulumiLabels;
    }
    /**
     * Indicates whether changes to the cluster are currently in flight. If this
     * is `true`, then the current state might not match the cluster&#39;s intended
     * state.
     * 
     */
    @Export(name="reconciling", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> reconciling;

    /**
     * @return Indicates whether changes to the cluster are currently in flight. If this
     * is `true`, then the current state might not match the cluster&#39;s intended
     * state.
     * 
     */
    public Output<Boolean> reconciling() {
        return this.reconciling;
    }
    /**
     * Storage resources available to the cluster. Keys specify the ID of the
     * storage resource by which it can be referenced elsewhere, and must conform
     * to [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
     * alphanumeric, and at most 63 characters).
     * Structure is documented below.
     * 
     */
    @Export(name="storageResources", refs={List.class,ClusterStorageResource.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ClusterStorageResource>> storageResources;

    /**
     * @return Storage resources available to the cluster. Keys specify the ID of the
     * storage resource by which it can be referenced elsewhere, and must conform
     * to [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
     * alphanumeric, and at most 63 characters).
     * Structure is documented below.
     * 
     */
    public Output<Optional<List<ClusterStorageResource>>> storageResources() {
        return Codegen.optional(this.storageResources);
    }
    /**
     * Time that the cluster was most recently updated.
     * 
     */
    @Export(name="updateTime", refs={String.class}, tree="[0]")
    private Output<String> updateTime;

    /**
     * @return Time that the cluster was most recently updated.
     * 
     */
    public Output<String> updateTime() {
        return this.updateTime;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Cluster(java.lang.String name) {
        this(name, ClusterArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Cluster(java.lang.String name, ClusterArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Cluster(java.lang.String name, ClusterArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:hypercomputecluster/cluster:Cluster", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Cluster(java.lang.String name, Output<java.lang.String> id, @Nullable ClusterState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:hypercomputecluster/cluster:Cluster", name, state, makeResourceOptions(options, id), false);
    }

    private static ClusterArgs makeArgs(ClusterArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? ClusterArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "effectiveLabels",
                "pulumiLabels"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Cluster get(java.lang.String name, Output<java.lang.String> id, @Nullable ClusterState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Cluster(name, id, state, options);
    }
}
