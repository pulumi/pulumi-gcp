// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.backupdisasterrecovery;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.backupdisasterrecovery.BackupVaultArgs;
import com.pulumi.gcp.backupdisasterrecovery.inputs.BackupVaultState;
import com.pulumi.gcp.backupdisasterrecovery.outputs.BackupVaultEncryptionConfig;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Container to store and organize immutable and indelible backups.
 * 
 * ## Example Usage
 * 
 * ### Backup Dr Backup Vault Simple
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.backupdisasterrecovery.BackupVault;
 * import com.pulumi.gcp.backupdisasterrecovery.BackupVaultArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var backup_vault_test = new BackupVault("backup-vault-test", BackupVaultArgs.builder()
 *             .location("us-central1")
 *             .backupVaultId("backup-vault-test")
 *             .description("This is a second backup vault built by Terraform.")
 *             .backupMinimumEnforcedRetentionDuration("100000s")
 *             .annotations(Map.ofEntries(
 *                 Map.entry("annotations1", "bar1"),
 *                 Map.entry("annotations2", "baz1")
 *             ))
 *             .labels(Map.ofEntries(
 *                 Map.entry("foo", "bar1"),
 *                 Map.entry("bar", "baz1")
 *             ))
 *             .forceUpdate(true)
 *             .accessRestriction("WITHIN_ORGANIZATION")
 *             .backupRetentionInheritance("INHERIT_VAULT_RETENTION")
 *             .ignoreInactiveDatasources(true)
 *             .ignoreBackupPlanReferences(true)
 *             .allowMissing(true)
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * ### Backup Dr Backup Vault Cmek
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.organizations.OrganizationsFunctions;
 * import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
 * import com.pulumi.gcp.backupdisasterrecovery.BackupVault;
 * import com.pulumi.gcp.backupdisasterrecovery.BackupVaultArgs;
 * import com.pulumi.gcp.backupdisasterrecovery.inputs.BackupVaultEncryptionConfigArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         final var testProject = OrganizationsFunctions.getProject(GetProjectArgs.builder()
 *             .projectId("my-project-name")
 *             .build());
 * 
 *         var backup_vault_cmek = new BackupVault("backup-vault-cmek", BackupVaultArgs.builder()
 *             .location("us-central1")
 *             .backupVaultId("backup-vault-cmek")
 *             .description("This is a second backup vault built by Terraform.")
 *             .backupMinimumEnforcedRetentionDuration("100000s")
 *             .annotations(Map.ofEntries(
 *                 Map.entry("annotations1", "bar1"),
 *                 Map.entry("annotations2", "baz1")
 *             ))
 *             .labels(Map.ofEntries(
 *                 Map.entry("foo", "bar1"),
 *                 Map.entry("bar", "baz1")
 *             ))
 *             .encryptionConfig(BackupVaultEncryptionConfigArgs.builder()
 *                 .kmsKeyName("bkpvault-key")
 *                 .build())
 *             .forceUpdate(true)
 *             .accessRestriction("WITHIN_ORGANIZATION")
 *             .backupRetentionInheritance("INHERIT_VAULT_RETENTION")
 *             .ignoreInactiveDatasources(true)
 *             .ignoreBackupPlanReferences(true)
 *             .allowMissing(true)
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Import
 * 
 * BackupVault can be imported using any of these accepted formats:
 * 
 * * `projects/{{project}}/locations/{{location}}/backupVaults/{{backup_vault_id}}`
 * 
 * * `{{project}}/{{location}}/{{backup_vault_id}}`
 * 
 * * `{{location}}/{{backup_vault_id}}`
 * 
 * When using the `pulumi import` command, BackupVault can be imported using one of the formats above. For example:
 * 
 * ```sh
 * $ pulumi import gcp:backupdisasterrecovery/backupVault:BackupVault default projects/{{project}}/locations/{{location}}/backupVaults/{{backup_vault_id}}
 * ```
 * 
 * ```sh
 * $ pulumi import gcp:backupdisasterrecovery/backupVault:BackupVault default {{project}}/{{location}}/{{backup_vault_id}}
 * ```
 * 
 * ```sh
 * $ pulumi import gcp:backupdisasterrecovery/backupVault:BackupVault default {{location}}/{{backup_vault_id}}
 * ```
 * 
 */
@ResourceType(type="gcp:backupdisasterrecovery/backupVault:BackupVault")
public class BackupVault extends com.pulumi.resources.CustomResource {
    /**
     * Access restriction for the backup vault. Default value is `WITHIN_ORGANIZATION` if not provided during creation.
     * Default value is `WITHIN_ORGANIZATION`.
     * Possible values are: `ACCESS_RESTRICTION_UNSPECIFIED`, `WITHIN_PROJECT`, `WITHIN_ORGANIZATION`, `UNRESTRICTED`, `WITHIN_ORG_BUT_UNRESTRICTED_FOR_BA`.
     * 
     */
    @Export(name="accessRestriction", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> accessRestriction;

    /**
     * @return Access restriction for the backup vault. Default value is `WITHIN_ORGANIZATION` if not provided during creation.
     * Default value is `WITHIN_ORGANIZATION`.
     * Possible values are: `ACCESS_RESTRICTION_UNSPECIFIED`, `WITHIN_PROJECT`, `WITHIN_ORGANIZATION`, `UNRESTRICTED`, `WITHIN_ORG_BUT_UNRESTRICTED_FOR_BA`.
     * 
     */
    public Output<Optional<String>> accessRestriction() {
        return Codegen.optional(this.accessRestriction);
    }
    /**
     * Allow idempotent deletion of backup vault. The request will still succeed in case the backup vault does not exist.
     * 
     */
    @Export(name="allowMissing", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowMissing;

    /**
     * @return Allow idempotent deletion of backup vault. The request will still succeed in case the backup vault does not exist.
     * 
     */
    public Output<Optional<Boolean>> allowMissing() {
        return Codegen.optional(this.allowMissing);
    }
    /**
     * Optional. User annotations. See https://google.aip.dev/128#annotations
     * Stores small amounts of arbitrary data.
     * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
     * Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
     * 
     */
    @Export(name="annotations", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> annotations;

    /**
     * @return Optional. User annotations. See https://google.aip.dev/128#annotations
     * Stores small amounts of arbitrary data.
     * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
     * Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> annotations() {
        return Codegen.optional(this.annotations);
    }
    /**
     * Output only. The number of backups in this backup vault.
     * 
     */
    @Export(name="backupCount", refs={String.class}, tree="[0]")
    private Output<String> backupCount;

    /**
     * @return Output only. The number of backups in this backup vault.
     * 
     */
    public Output<String> backupCount() {
        return this.backupCount;
    }
    /**
     * Required. The default and minimum enforced retention for each backup within the backup vault. The enforced retention for each backup can be extended.
     * 
     */
    @Export(name="backupMinimumEnforcedRetentionDuration", refs={String.class}, tree="[0]")
    private Output<String> backupMinimumEnforcedRetentionDuration;

    /**
     * @return Required. The default and minimum enforced retention for each backup within the backup vault. The enforced retention for each backup can be extended.
     * 
     */
    public Output<String> backupMinimumEnforcedRetentionDuration() {
        return this.backupMinimumEnforcedRetentionDuration;
    }
    /**
     * How a backup&#39;s enforced retention end time is inherited. Default value is `INHERIT_VAULT_RETENTION` if not provided during creation.
     * Possible values are: `BACKUP_RETENTION_INHERITANCE_UNSPECIFIED`, `INHERIT_VAULT_RETENTION`, `MATCH_BACKUP_EXPIRE_TIME`.
     * 
     */
    @Export(name="backupRetentionInheritance", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> backupRetentionInheritance;

    /**
     * @return How a backup&#39;s enforced retention end time is inherited. Default value is `INHERIT_VAULT_RETENTION` if not provided during creation.
     * Possible values are: `BACKUP_RETENTION_INHERITANCE_UNSPECIFIED`, `INHERIT_VAULT_RETENTION`, `MATCH_BACKUP_EXPIRE_TIME`.
     * 
     */
    public Output<Optional<String>> backupRetentionInheritance() {
        return Codegen.optional(this.backupRetentionInheritance);
    }
    /**
     * Required. ID of the requesting object.
     * 
     */
    @Export(name="backupVaultId", refs={String.class}, tree="[0]")
    private Output<String> backupVaultId;

    /**
     * @return Required. ID of the requesting object.
     * 
     */
    public Output<String> backupVaultId() {
        return this.backupVaultId;
    }
    /**
     * Output only. The time when the instance was created.
     * 
     */
    @Export(name="createTime", refs={String.class}, tree="[0]")
    private Output<String> createTime;

    /**
     * @return Output only. The time when the instance was created.
     * 
     */
    public Output<String> createTime() {
        return this.createTime;
    }
    /**
     * Output only. Set to true when there are no backups nested under this resource.
     * 
     */
    @Export(name="deletable", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> deletable;

    /**
     * @return Output only. Set to true when there are no backups nested under this resource.
     * 
     */
    public Output<Boolean> deletable() {
        return this.deletable;
    }
    /**
     * Optional. The description of the BackupVault instance (2048 characters or less).
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return Optional. The description of the BackupVault instance (2048 characters or less).
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    @Export(name="effectiveAnnotations", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> effectiveAnnotations;

    public Output<Map<String,String>> effectiveAnnotations() {
        return this.effectiveAnnotations;
    }
    /**
     * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     * 
     */
    @Export(name="effectiveLabels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> effectiveLabels;

    /**
     * @return All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     * 
     */
    public Output<Map<String,String>> effectiveLabels() {
        return this.effectiveLabels;
    }
    /**
     * Optional. Time after which the BackupVault resource is locked.
     * 
     */
    @Export(name="effectiveTime", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> effectiveTime;

    /**
     * @return Optional. Time after which the BackupVault resource is locked.
     * 
     */
    public Output<Optional<String>> effectiveTime() {
        return Codegen.optional(this.effectiveTime);
    }
    /**
     * Encryption configuration for the backup vault.
     * Structure is documented below.
     * 
     */
    @Export(name="encryptionConfig", refs={BackupVaultEncryptionConfig.class}, tree="[0]")
    private Output</* @Nullable */ BackupVaultEncryptionConfig> encryptionConfig;

    /**
     * @return Encryption configuration for the backup vault.
     * Structure is documented below.
     * 
     */
    public Output<Optional<BackupVaultEncryptionConfig>> encryptionConfig() {
        return Codegen.optional(this.encryptionConfig);
    }
    /**
     * Optional. Server specified ETag for the backup vault resource to prevent simultaneous updates from overwiting each other.
     * 
     */
    @Export(name="etag", refs={String.class}, tree="[0]")
    private Output<String> etag;

    /**
     * @return Optional. Server specified ETag for the backup vault resource to prevent simultaneous updates from overwiting each other.
     * 
     */
    public Output<String> etag() {
        return this.etag;
    }
    /**
     * (Optional, Deprecated)
     * If set, the following restrictions against deletion of the backup vault instance can be overridden:
     * * deletion of a backup vault instance containing no backups, but still containing empty datasources.
     * * deletion of a backup vault instance that is being referenced by an active backup plan.
     * 
     * &gt; **Warning:** `forceDelete` is deprecated and will be removed in a future major release. Use `ignoreInactiveDatasources` instead.
     * 
     * @deprecated
     * `forceDelete` is deprecated and will be removed in a future major release. Use `ignoreInactiveDatasources` instead.
     * 
     */
    @Deprecated /* `forceDelete` is deprecated and will be removed in a future major release. Use `ignoreInactiveDatasources` instead. */
    @Export(name="forceDelete", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> forceDelete;

    /**
     * @return (Optional, Deprecated)
     * If set, the following restrictions against deletion of the backup vault instance can be overridden:
     * * deletion of a backup vault instance containing no backups, but still containing empty datasources.
     * * deletion of a backup vault instance that is being referenced by an active backup plan.
     * 
     * &gt; **Warning:** `forceDelete` is deprecated and will be removed in a future major release. Use `ignoreInactiveDatasources` instead.
     * 
     */
    public Output<Optional<Boolean>> forceDelete() {
        return Codegen.optional(this.forceDelete);
    }
    /**
     * If set, allow update to extend the minimum enforced retention for backup vault. This overrides
     * the restriction against conflicting retention periods. This conflict may occur when the
     * expiration schedule defined by the associated backup plan is shorter than the minimum
     * retention set by the backup vault.
     * 
     */
    @Export(name="forceUpdate", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> forceUpdate;

    /**
     * @return If set, allow update to extend the minimum enforced retention for backup vault. This overrides
     * the restriction against conflicting retention periods. This conflict may occur when the
     * expiration schedule defined by the associated backup plan is shorter than the minimum
     * retention set by the backup vault.
     * 
     */
    public Output<Optional<Boolean>> forceUpdate() {
        return Codegen.optional(this.forceUpdate);
    }
    /**
     * If set, the following restrictions against deletion of the backup vault instance can be overridden:
     * * deletion of a backup vault instance that is being referenced by an active backup plan.
     * 
     */
    @Export(name="ignoreBackupPlanReferences", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> ignoreBackupPlanReferences;

    /**
     * @return If set, the following restrictions against deletion of the backup vault instance can be overridden:
     * * deletion of a backup vault instance that is being referenced by an active backup plan.
     * 
     */
    public Output<Optional<Boolean>> ignoreBackupPlanReferences() {
        return Codegen.optional(this.ignoreBackupPlanReferences);
    }
    /**
     * If set, the following restrictions against deletion of the backup vault instance can be overridden:
     * * deletion of a backup vault instance containing no backups, but still containing empty datasources.
     * 
     */
    @Export(name="ignoreInactiveDatasources", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> ignoreInactiveDatasources;

    /**
     * @return If set, the following restrictions against deletion of the backup vault instance can be overridden:
     * * deletion of a backup vault instance containing no backups, but still containing empty datasources.
     * 
     */
    public Output<Optional<Boolean>> ignoreInactiveDatasources() {
        return Codegen.optional(this.ignoreInactiveDatasources);
    }
    /**
     * Optional. Resource labels to represent user provided metadata.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     * 
     */
    @Export(name="labels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> labels;

    /**
     * @return Optional. Resource labels to represent user provided metadata.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     * 
     */
    public Output<Optional<Map<String,String>>> labels() {
        return Codegen.optional(this.labels);
    }
    /**
     * The GCP location for the backup vault.
     * 
     */
    @Export(name="location", refs={String.class}, tree="[0]")
    private Output<String> location;

    /**
     * @return The GCP location for the backup vault.
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * Output only. Identifier. The resource name.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return Output only. Identifier. The resource name.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Export(name="project", refs={String.class}, tree="[0]")
    private Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Output<String> project() {
        return this.project;
    }
    /**
     * The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     * 
     */
    @Export(name="pulumiLabels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> pulumiLabels;

    /**
     * @return The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     * 
     */
    public Output<Map<String,String>> pulumiLabels() {
        return this.pulumiLabels;
    }
    /**
     * Output only. Service account used by the BackupVault Service for this BackupVault.  The user should grant this account permissions in their workload project to enable the service to run backups and restores there.
     * 
     */
    @Export(name="serviceAccount", refs={String.class}, tree="[0]")
    private Output<String> serviceAccount;

    /**
     * @return Output only. Service account used by the BackupVault Service for this BackupVault.  The user should grant this account permissions in their workload project to enable the service to run backups and restores there.
     * 
     */
    public Output<String> serviceAccount() {
        return this.serviceAccount;
    }
    /**
     * Output only. The BackupVault resource instance state.
     * Possible values:
     * STATE_UNSPECIFIED
     * CREATING
     * ACTIVE
     * DELETING
     * ERROR
     * 
     */
    @Export(name="state", refs={String.class}, tree="[0]")
    private Output<String> state;

    /**
     * @return Output only. The BackupVault resource instance state.
     * Possible values:
     * STATE_UNSPECIFIED
     * CREATING
     * ACTIVE
     * DELETING
     * ERROR
     * 
     */
    public Output<String> state() {
        return this.state;
    }
    /**
     * Output only. Total size of the storage used by all backup resources.
     * 
     */
    @Export(name="totalStoredBytes", refs={String.class}, tree="[0]")
    private Output<String> totalStoredBytes;

    /**
     * @return Output only. Total size of the storage used by all backup resources.
     * 
     */
    public Output<String> totalStoredBytes() {
        return this.totalStoredBytes;
    }
    /**
     * Output only. Output only Immutable after resource creation until resource deletion.
     * 
     */
    @Export(name="uid", refs={String.class}, tree="[0]")
    private Output<String> uid;

    /**
     * @return Output only. Output only Immutable after resource creation until resource deletion.
     * 
     */
    public Output<String> uid() {
        return this.uid;
    }
    /**
     * Output only. The time when the instance was updated.
     * 
     */
    @Export(name="updateTime", refs={String.class}, tree="[0]")
    private Output<String> updateTime;

    /**
     * @return Output only. The time when the instance was updated.
     * 
     */
    public Output<String> updateTime() {
        return this.updateTime;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public BackupVault(java.lang.String name) {
        this(name, BackupVaultArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public BackupVault(java.lang.String name, BackupVaultArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public BackupVault(java.lang.String name, BackupVaultArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:backupdisasterrecovery/backupVault:BackupVault", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private BackupVault(java.lang.String name, Output<java.lang.String> id, @Nullable BackupVaultState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:backupdisasterrecovery/backupVault:BackupVault", name, state, makeResourceOptions(options, id), false);
    }

    private static BackupVaultArgs makeArgs(BackupVaultArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? BackupVaultArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "effectiveLabels",
                "pulumiLabels"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static BackupVault get(java.lang.String name, Output<java.lang.String> id, @Nullable BackupVaultState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new BackupVault(name, id, state, options);
    }
}
