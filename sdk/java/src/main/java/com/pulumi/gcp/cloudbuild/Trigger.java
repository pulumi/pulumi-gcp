// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.cloudbuild;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.cloudbuild.TriggerArgs;
import com.pulumi.gcp.cloudbuild.inputs.TriggerState;
import com.pulumi.gcp.cloudbuild.outputs.TriggerApprovalConfig;
import com.pulumi.gcp.cloudbuild.outputs.TriggerBuild;
import com.pulumi.gcp.cloudbuild.outputs.TriggerGitFileSource;
import com.pulumi.gcp.cloudbuild.outputs.TriggerGithub;
import com.pulumi.gcp.cloudbuild.outputs.TriggerPubsubConfig;
import com.pulumi.gcp.cloudbuild.outputs.TriggerSourceToBuild;
import com.pulumi.gcp.cloudbuild.outputs.TriggerTriggerTemplate;
import com.pulumi.gcp.cloudbuild.outputs.TriggerWebhookConfig;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Configuration for an automated build in response to source repository changes.
 * 
 * To get more information about Trigger, see:
 * 
 * * [API documentation](https://cloud.google.com/cloud-build/docs/api/reference/rest/v1/projects.triggers)
 * * How-to Guides
 *     * [Automating builds using build triggers](https://cloud.google.com/cloud-build/docs/running-builds/automate-builds)
 * 
 * &gt; **Note:** You can retrieve the email of the Cloud Build Service Account used in jobs by using the `gcp.projects.ServiceIdentity` resource.
 * 
 * ## Example Usage
 * ### Cloudbuild Trigger Filename
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerTriggerTemplateArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var filename_trigger = new Trigger(&#34;filename-trigger&#34;, TriggerArgs.builder()        
 *             .filename(&#34;cloudbuild.yaml&#34;)
 *             .location(&#34;us-central1&#34;)
 *             .substitutions(Map.ofEntries(
 *                 Map.entry(&#34;_BAZ&#34;, &#34;qux&#34;),
 *                 Map.entry(&#34;_FOO&#34;, &#34;bar&#34;)
 *             ))
 *             .triggerTemplate(TriggerTriggerTemplateArgs.builder()
 *                 .branchName(&#34;main&#34;)
 *                 .repoName(&#34;my-repo&#34;)
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### Cloudbuild Trigger Build
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildArtifactsArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildArtifactsObjectsArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildAvailableSecretsArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildOptionsArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildSourceArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildSourceStorageSourceArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerTriggerTemplateArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var build_trigger = new Trigger(&#34;build-trigger&#34;, TriggerArgs.builder()        
 *             .build(TriggerBuildArgs.builder()
 *                 .artifacts(TriggerBuildArtifactsArgs.builder()
 *                     .images(&#34;gcr.io/$PROJECT_ID/$REPO_NAME:$COMMIT_SHA&#34;)
 *                     .objects(TriggerBuildArtifactsObjectsArgs.builder()
 *                         .location(&#34;gs://bucket/path/to/somewhere/&#34;)
 *                         .paths(&#34;path&#34;)
 *                         .build())
 *                     .build())
 *                 .availableSecrets(TriggerBuildAvailableSecretsArgs.builder()
 *                     .secretManager(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
 *                     .build())
 *                 .logsBucket(&#34;gs://mybucket/logs&#34;)
 *                 .options(TriggerBuildOptionsArgs.builder()
 *                     .diskSizeGb(100)
 *                     .dynamicSubstitutions(true)
 *                     .env(&#34;ekey = evalue&#34;)
 *                     .logStreamingOption(&#34;STREAM_OFF&#34;)
 *                     .logging(&#34;LEGACY&#34;)
 *                     .machineType(&#34;N1_HIGHCPU_8&#34;)
 *                     .requestedVerifyOption(&#34;VERIFIED&#34;)
 *                     .secretEnv(&#34;secretenv = svalue&#34;)
 *                     .sourceProvenanceHash(&#34;MD5&#34;)
 *                     .substitutionOption(&#34;ALLOW_LOOSE&#34;)
 *                     .volumes(TriggerBuildOptionsVolumeArgs.builder()
 *                         .name(&#34;v1&#34;)
 *                         .path(&#34;v1&#34;)
 *                         .build())
 *                     .workerPool(&#34;pool&#34;)
 *                     .build())
 *                 .queueTtl(&#34;20s&#34;)
 *                 .secrets(TriggerBuildSecretArgs.builder()
 *                     .kmsKeyName(&#34;projects/myProject/locations/global/keyRings/keyring-name/cryptoKeys/key-name&#34;)
 *                     .secretEnv(Map.of(&#34;PASSWORD&#34;, &#34;ZW5jcnlwdGVkLXBhc3N3b3JkCg==&#34;))
 *                     .build())
 *                 .source(TriggerBuildSourceArgs.builder()
 *                     .storageSource(TriggerBuildSourceStorageSourceArgs.builder()
 *                         .bucket(&#34;mybucket&#34;)
 *                         .object(&#34;source_code.tar.gz&#34;)
 *                         .build())
 *                     .build())
 *                 .steps(                
 *                     TriggerBuildStepArgs.builder()
 *                         .args(                        
 *                             &#34;cp&#34;,
 *                             &#34;gs://mybucket/remotefile.zip&#34;,
 *                             &#34;localfile.zip&#34;)
 *                         .name(&#34;gcr.io/cloud-builders/gsutil&#34;)
 *                         .secretEnv(&#34;MY_SECRET&#34;)
 *                         .timeout(&#34;120s&#34;)
 *                         .build(),
 *                     TriggerBuildStepArgs.builder()
 *                         .name(&#34;ubuntu&#34;)
 *                         .script(&#34;echo hello&#34;)
 *                         .build())
 *                 .substitutions(Map.ofEntries(
 *                     Map.entry(&#34;_BAZ&#34;, &#34;qux&#34;),
 *                     Map.entry(&#34;_FOO&#34;, &#34;bar&#34;)
 *                 ))
 *                 .tags(                
 *                     &#34;build&#34;,
 *                     &#34;newFeature&#34;)
 *                 .build())
 *             .location(&#34;global&#34;)
 *             .triggerTemplate(TriggerTriggerTemplateArgs.builder()
 *                 .branchName(&#34;main&#34;)
 *                 .repoName(&#34;my-repo&#34;)
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### Cloudbuild Trigger Service Account
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.organizations.OrganizationsFunctions;
 * import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
 * import com.pulumi.gcp.serviceAccount.Account;
 * import com.pulumi.gcp.serviceAccount.AccountArgs;
 * import com.pulumi.gcp.projects.IAMMember;
 * import com.pulumi.gcp.projects.IAMMemberArgs;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerTriggerTemplateArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         final var project = OrganizationsFunctions.getProject();
 * 
 *         var cloudbuildServiceAccount = new Account(&#34;cloudbuildServiceAccount&#34;, AccountArgs.builder()        
 *             .accountId(&#34;my-service-account&#34;)
 *             .build());
 * 
 *         var actAs = new IAMMember(&#34;actAs&#34;, IAMMemberArgs.builder()        
 *             .project(project.applyValue(getProjectResult -&gt; getProjectResult.projectId()))
 *             .role(&#34;roles/iam.serviceAccountUser&#34;)
 *             .member(cloudbuildServiceAccount.email().applyValue(email -&gt; String.format(&#34;serviceAccount:%s&#34;, email)))
 *             .build());
 * 
 *         var logsWriter = new IAMMember(&#34;logsWriter&#34;, IAMMemberArgs.builder()        
 *             .project(project.applyValue(getProjectResult -&gt; getProjectResult.projectId()))
 *             .role(&#34;roles/logging.logWriter&#34;)
 *             .member(cloudbuildServiceAccount.email().applyValue(email -&gt; String.format(&#34;serviceAccount:%s&#34;, email)))
 *             .build());
 * 
 *         var service_account_trigger = new Trigger(&#34;service-account-trigger&#34;, TriggerArgs.builder()        
 *             .triggerTemplate(TriggerTriggerTemplateArgs.builder()
 *                 .branchName(&#34;main&#34;)
 *                 .repoName(&#34;my-repo&#34;)
 *                 .build())
 *             .serviceAccount(cloudbuildServiceAccount.id())
 *             .filename(&#34;cloudbuild.yaml&#34;)
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(                
 *                     actAs,
 *                     logsWriter)
 *                 .build());
 * 
 *     }
 * }
 * ```
 * ### Cloudbuild Trigger Include Build Logs
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGithubArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGithubPushArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var include_build_logs_trigger = new Trigger(&#34;include-build-logs-trigger&#34;, TriggerArgs.builder()        
 *             .filename(&#34;cloudbuild.yaml&#34;)
 *             .github(TriggerGithubArgs.builder()
 *                 .name(&#34;terraform-provider-google-beta&#34;)
 *                 .owner(&#34;hashicorp&#34;)
 *                 .push(TriggerGithubPushArgs.builder()
 *                     .branch(&#34;^main$&#34;)
 *                     .build())
 *                 .build())
 *             .includeBuildLogs(&#34;INCLUDE_BUILD_LOGS_WITH_STATUS&#34;)
 *             .location(&#34;us-central1&#34;)
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### Cloudbuild Trigger Pubsub Config
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.pubsub.Topic;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerPubsubConfigArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerSourceToBuildArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGitFileSourceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var mytopic = new Topic(&#34;mytopic&#34;);
 * 
 *         var pubsub_config_trigger = new Trigger(&#34;pubsub-config-trigger&#34;, TriggerArgs.builder()        
 *             .location(&#34;us-central1&#34;)
 *             .description(&#34;acceptance test example pubsub build trigger&#34;)
 *             .pubsubConfig(TriggerPubsubConfigArgs.builder()
 *                 .topic(mytopic.id())
 *                 .build())
 *             .sourceToBuild(TriggerSourceToBuildArgs.builder()
 *                 .uri(&#34;https://hashicorp/terraform-provider-google-beta&#34;)
 *                 .ref(&#34;refs/heads/main&#34;)
 *                 .repoType(&#34;GITHUB&#34;)
 *                 .build())
 *             .gitFileSource(TriggerGitFileSourceArgs.builder()
 *                 .path(&#34;cloudbuild.yaml&#34;)
 *                 .uri(&#34;https://hashicorp/terraform-provider-google-beta&#34;)
 *                 .revision(&#34;refs/heads/main&#34;)
 *                 .repoType(&#34;GITHUB&#34;)
 *                 .build())
 *             .substitutions(Map.of(&#34;_ACTION&#34;, &#34;$(body.message.data.action)&#34;))
 *             .filter(&#34;_ACTION.matches(&#39;INSERT&#39;)&#34;)
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### Cloudbuild Trigger Webhook Config
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.secretmanager.Secret;
 * import com.pulumi.gcp.secretmanager.SecretArgs;
 * import com.pulumi.gcp.secretmanager.inputs.SecretReplicationArgs;
 * import com.pulumi.gcp.secretmanager.inputs.SecretReplicationUserManagedArgs;
 * import com.pulumi.gcp.secretmanager.SecretVersion;
 * import com.pulumi.gcp.secretmanager.SecretVersionArgs;
 * import com.pulumi.gcp.organizations.OrganizationsFunctions;
 * import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
 * import com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;
 * import com.pulumi.gcp.secretmanager.SecretIamPolicy;
 * import com.pulumi.gcp.secretmanager.SecretIamPolicyArgs;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerWebhookConfigArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerSourceToBuildArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGitFileSourceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var webhookTriggerSecretKey = new Secret(&#34;webhookTriggerSecretKey&#34;, SecretArgs.builder()        
 *             .secretId(&#34;webhook_trigger-secret-key-1&#34;)
 *             .replication(SecretReplicationArgs.builder()
 *                 .userManaged(SecretReplicationUserManagedArgs.builder()
 *                     .replicas(SecretReplicationUserManagedReplicaArgs.builder()
 *                         .location(&#34;us-central1&#34;)
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *         var webhookTriggerSecretKeyData = new SecretVersion(&#34;webhookTriggerSecretKeyData&#34;, SecretVersionArgs.builder()        
 *             .secret(webhookTriggerSecretKey.id())
 *             .secretData(&#34;secretkeygoeshere&#34;)
 *             .build());
 * 
 *         final var project = OrganizationsFunctions.getProject();
 * 
 *         final var secretAccessor = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()
 *             .bindings(GetIAMPolicyBindingArgs.builder()
 *                 .role(&#34;roles/secretmanager.secretAccessor&#34;)
 *                 .members(String.format(&#34;serviceAccount:service-%s@gcp-sa-cloudbuild.iam.gserviceaccount.com&#34;, project.applyValue(getProjectResult -&gt; getProjectResult.number())))
 *                 .build())
 *             .build());
 * 
 *         var policy = new SecretIamPolicy(&#34;policy&#34;, SecretIamPolicyArgs.builder()        
 *             .project(webhookTriggerSecretKey.project())
 *             .secretId(webhookTriggerSecretKey.secretId())
 *             .policyData(secretAccessor.applyValue(getIAMPolicyResult -&gt; getIAMPolicyResult.policyData()))
 *             .build());
 * 
 *         var webhook_config_trigger = new Trigger(&#34;webhook-config-trigger&#34;, TriggerArgs.builder()        
 *             .description(&#34;acceptance test example webhook build trigger&#34;)
 *             .webhookConfig(TriggerWebhookConfigArgs.builder()
 *                 .secret(webhookTriggerSecretKeyData.id())
 *                 .build())
 *             .sourceToBuild(TriggerSourceToBuildArgs.builder()
 *                 .uri(&#34;https://hashicorp/terraform-provider-google-beta&#34;)
 *                 .ref(&#34;refs/heads/main&#34;)
 *                 .repoType(&#34;GITHUB&#34;)
 *                 .build())
 *             .gitFileSource(TriggerGitFileSourceArgs.builder()
 *                 .path(&#34;cloudbuild.yaml&#34;)
 *                 .uri(&#34;https://hashicorp/terraform-provider-google-beta&#34;)
 *                 .revision(&#34;refs/heads/main&#34;)
 *                 .repoType(&#34;GITHUB&#34;)
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * ```
 * ### Cloudbuild Trigger Manual
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerApprovalConfigArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGitFileSourceArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerSourceToBuildArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var manual_trigger = new Trigger(&#34;manual-trigger&#34;, TriggerArgs.builder()        
 *             .approvalConfig(TriggerApprovalConfigArgs.builder()
 *                 .approvalRequired(true)
 *                 .build())
 *             .gitFileSource(TriggerGitFileSourceArgs.builder()
 *                 .path(&#34;cloudbuild.yaml&#34;)
 *                 .repoType(&#34;GITHUB&#34;)
 *                 .revision(&#34;refs/heads/main&#34;)
 *                 .uri(&#34;https://hashicorp/terraform-provider-google-beta&#34;)
 *                 .build())
 *             .sourceToBuild(TriggerSourceToBuildArgs.builder()
 *                 .ref(&#34;refs/heads/main&#34;)
 *                 .repoType(&#34;GITHUB&#34;)
 *                 .uri(&#34;https://hashicorp/terraform-provider-google-beta&#34;)
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * ```
 * 
 * ## Import
 * 
 * Trigger can be imported using any of these accepted formats
 * 
 * ```sh
 *  $ pulumi import gcp:cloudbuild/trigger:Trigger default projects/{{project}}/locations/{{location}}/triggers/{{trigger_id}}
 * ```
 * 
 * ```sh
 *  $ pulumi import gcp:cloudbuild/trigger:Trigger default projects/{{project}}/triggers/{{trigger_id}}
 * ```
 * 
 * ```sh
 *  $ pulumi import gcp:cloudbuild/trigger:Trigger default {{project}}/{{trigger_id}}
 * ```
 * 
 * ```sh
 *  $ pulumi import gcp:cloudbuild/trigger:Trigger default {{trigger_id}}
 * ```
 * 
 */
@ResourceType(type="gcp:cloudbuild/trigger:Trigger")
public class Trigger extends com.pulumi.resources.CustomResource {
    /**
     * Configuration for manual approval to start a build invocation of this BuildTrigger.
     * Builds created by this trigger will require approval before they execute.
     * Any user with a Cloud Build Approver role for the project can approve a build.
     * Structure is documented below.
     * 
     */
    @Export(name="approvalConfig", type=TriggerApprovalConfig.class, parameters={})
    private Output<TriggerApprovalConfig> approvalConfig;

    /**
     * @return Configuration for manual approval to start a build invocation of this BuildTrigger.
     * Builds created by this trigger will require approval before they execute.
     * Any user with a Cloud Build Approver role for the project can approve a build.
     * Structure is documented below.
     * 
     */
    public Output<TriggerApprovalConfig> approvalConfig() {
        return this.approvalConfig;
    }
    /**
     * Contents of the build template. Either a filename or build template must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="build", type=TriggerBuild.class, parameters={})
    private Output</* @Nullable */ TriggerBuild> build;

    /**
     * @return Contents of the build template. Either a filename or build template must be provided.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerBuild>> build() {
        return Codegen.optional(this.build);
    }
    /**
     * Time when the trigger was created.
     * 
     */
    @Export(name="createTime", type=String.class, parameters={})
    private Output<String> createTime;

    /**
     * @return Time when the trigger was created.
     * 
     */
    public Output<String> createTime() {
        return this.createTime;
    }
    /**
     * Human-readable description of the trigger.
     * 
     */
    @Export(name="description", type=String.class, parameters={})
    private Output</* @Nullable */ String> description;

    /**
     * @return Human-readable description of the trigger.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Whether the trigger is disabled or not. If true, the trigger will never result in a build.
     * 
     */
    @Export(name="disabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> disabled;

    /**
     * @return Whether the trigger is disabled or not. If true, the trigger will never result in a build.
     * 
     */
    public Output<Optional<Boolean>> disabled() {
        return Codegen.optional(this.disabled);
    }
    /**
     * Path, from the source root, to a file whose contents is used for the template.
     * Either a filename or build template must be provided. Set this only when using trigger_template or github.
     * When using Pub/Sub, Webhook or Manual set the file name using git_file_source instead.
     * 
     */
    @Export(name="filename", type=String.class, parameters={})
    private Output</* @Nullable */ String> filename;

    /**
     * @return Path, from the source root, to a file whose contents is used for the template.
     * Either a filename or build template must be provided. Set this only when using trigger_template or github.
     * When using Pub/Sub, Webhook or Manual set the file name using git_file_source instead.
     * 
     */
    public Output<Optional<String>> filename() {
        return Codegen.optional(this.filename);
    }
    /**
     * A Common Expression Language string. Used only with Pub/Sub and Webhook.
     * 
     */
    @Export(name="filter", type=String.class, parameters={})
    private Output</* @Nullable */ String> filter;

    /**
     * @return A Common Expression Language string. Used only with Pub/Sub and Webhook.
     * 
     */
    public Output<Optional<String>> filter() {
        return Codegen.optional(this.filter);
    }
    /**
     * The file source describing the local or remote Build template.
     * Structure is documented below.
     * 
     */
    @Export(name="gitFileSource", type=TriggerGitFileSource.class, parameters={})
    private Output</* @Nullable */ TriggerGitFileSource> gitFileSource;

    /**
     * @return The file source describing the local or remote Build template.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerGitFileSource>> gitFileSource() {
        return Codegen.optional(this.gitFileSource);
    }
    /**
     * Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
     * One of `trigger_template`, `github`, `pubsub_config` or `webhook_config` must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="github", type=TriggerGithub.class, parameters={})
    private Output</* @Nullable */ TriggerGithub> github;

    /**
     * @return Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
     * One of `trigger_template`, `github`, `pubsub_config` or `webhook_config` must be provided.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerGithub>> github() {
        return Codegen.optional(this.github);
    }
    /**
     * ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
     * extended with support for `**`.
     * If ignoredFiles and changed files are both empty, then they are not
     * used to determine whether or not to trigger a build.
     * If ignoredFiles is not empty, then we ignore any files that match any
     * of the ignored_file globs. If the change has no files that are outside
     * of the ignoredFiles globs, then we do not trigger a build.
     * 
     */
    @Export(name="ignoredFiles", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> ignoredFiles;

    /**
     * @return ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
     * extended with support for `**`.
     * If ignoredFiles and changed files are both empty, then they are not
     * used to determine whether or not to trigger a build.
     * If ignoredFiles is not empty, then we ignore any files that match any
     * of the ignored_file globs. If the change has no files that are outside
     * of the ignoredFiles globs, then we do not trigger a build.
     * 
     */
    public Output<Optional<List<String>>> ignoredFiles() {
        return Codegen.optional(this.ignoredFiles);
    }
    /**
     * Build logs will be sent back to GitHub as part of the checkrun
     * result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or
     * INCLUDE_BUILD_LOGS_WITH_STATUS
     * Possible values are `INCLUDE_BUILD_LOGS_UNSPECIFIED` and `INCLUDE_BUILD_LOGS_WITH_STATUS`.
     * 
     */
    @Export(name="includeBuildLogs", type=String.class, parameters={})
    private Output</* @Nullable */ String> includeBuildLogs;

    /**
     * @return Build logs will be sent back to GitHub as part of the checkrun
     * result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or
     * INCLUDE_BUILD_LOGS_WITH_STATUS
     * Possible values are `INCLUDE_BUILD_LOGS_UNSPECIFIED` and `INCLUDE_BUILD_LOGS_WITH_STATUS`.
     * 
     */
    public Output<Optional<String>> includeBuildLogs() {
        return Codegen.optional(this.includeBuildLogs);
    }
    /**
     * ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
     * extended with support for `**`.
     * If any of the files altered in the commit pass the ignoredFiles filter
     * and includedFiles is empty, then as far as this filter is concerned, we
     * should trigger the build.
     * If any of the files altered in the commit pass the ignoredFiles filter
     * and includedFiles is not empty, then we make sure that at least one of
     * those files matches a includedFiles glob. If not, then we do not trigger
     * a build.
     * 
     */
    @Export(name="includedFiles", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> includedFiles;

    /**
     * @return ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
     * extended with support for `**`.
     * If any of the files altered in the commit pass the ignoredFiles filter
     * and includedFiles is empty, then as far as this filter is concerned, we
     * should trigger the build.
     * If any of the files altered in the commit pass the ignoredFiles filter
     * and includedFiles is not empty, then we make sure that at least one of
     * those files matches a includedFiles glob. If not, then we do not trigger
     * a build.
     * 
     */
    public Output<Optional<List<String>>> includedFiles() {
        return Codegen.optional(this.includedFiles);
    }
    /**
     * Cloud Storage bucket and optional object path, in the form &#34;gs://bucket/path/to/somewhere/&#34;.
     * Files in the workspace matching any path pattern will be uploaded to Cloud Storage with
     * this location as a prefix.
     * 
     */
    @Export(name="location", type=String.class, parameters={})
    private Output</* @Nullable */ String> location;

    /**
     * @return Cloud Storage bucket and optional object path, in the form &#34;gs://bucket/path/to/somewhere/&#34;.
     * Files in the workspace matching any path pattern will be uploaded to Cloud Storage with
     * this location as a prefix.
     * 
     */
    public Output<Optional<String>> location() {
        return Codegen.optional(this.location);
    }
    /**
     * Name of the volume to mount.
     * Volume names must be unique per build step and must be valid names for Docker volumes.
     * Each named volume must be used by at least two build steps.
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return Name of the volume to mount.
     * Volume names must be unique per build step and must be valid names for Docker volumes.
     * Each named volume must be used by at least two build steps.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Export(name="project", type=String.class, parameters={})
    private Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Output<String> project() {
        return this.project;
    }
    /**
     * PubsubConfig describes the configuration of a trigger that creates
     * a build whenever a Pub/Sub message is published.
     * One of `trigger_template`, `github`, `pubsub_config` `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="pubsubConfig", type=TriggerPubsubConfig.class, parameters={})
    private Output</* @Nullable */ TriggerPubsubConfig> pubsubConfig;

    /**
     * @return PubsubConfig describes the configuration of a trigger that creates
     * a build whenever a Pub/Sub message is published.
     * One of `trigger_template`, `github`, `pubsub_config` `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerPubsubConfig>> pubsubConfig() {
        return Codegen.optional(this.pubsubConfig);
    }
    /**
     * The service account used for all user-controlled operations including
     * triggers.patch, triggers.run, builds.create, and builds.cancel.
     * If no service account is set, then the standard Cloud Build service account
     * ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.
     * Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
     * 
     */
    @Export(name="serviceAccount", type=String.class, parameters={})
    private Output</* @Nullable */ String> serviceAccount;

    /**
     * @return The service account used for all user-controlled operations including
     * triggers.patch, triggers.run, builds.create, and builds.cancel.
     * If no service account is set, then the standard Cloud Build service account
     * ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.
     * Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
     * 
     */
    public Output<Optional<String>> serviceAccount() {
        return Codegen.optional(this.serviceAccount);
    }
    /**
     * The repo and ref of the repository from which to build.
     * This field is used only for those triggers that do not respond to SCM events.
     * Triggers that respond to such events build source at whatever commit caused the event.
     * This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
     * One of `trigger_template`, `github`, `pubsub_config` `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="sourceToBuild", type=TriggerSourceToBuild.class, parameters={})
    private Output</* @Nullable */ TriggerSourceToBuild> sourceToBuild;

    /**
     * @return The repo and ref of the repository from which to build.
     * This field is used only for those triggers that do not respond to SCM events.
     * Triggers that respond to such events build source at whatever commit caused the event.
     * This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
     * One of `trigger_template`, `github`, `pubsub_config` `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerSourceToBuild>> sourceToBuild() {
        return Codegen.optional(this.sourceToBuild);
    }
    /**
     * Substitutions to use in a triggered build. Should only be used with triggers.run
     * 
     */
    @Export(name="substitutions", type=Map.class, parameters={String.class, String.class})
    private Output</* @Nullable */ Map<String,String>> substitutions;

    /**
     * @return Substitutions to use in a triggered build. Should only be used with triggers.run
     * 
     */
    public Output<Optional<Map<String,String>>> substitutions() {
        return Codegen.optional(this.substitutions);
    }
    /**
     * Tags for annotation of a Build. These are not docker tags.
     * 
     */
    @Export(name="tags", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> tags;

    /**
     * @return Tags for annotation of a Build. These are not docker tags.
     * 
     */
    public Output<Optional<List<String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * The unique identifier for the trigger.
     * 
     */
    @Export(name="triggerId", type=String.class, parameters={})
    private Output<String> triggerId;

    /**
     * @return The unique identifier for the trigger.
     * 
     */
    public Output<String> triggerId() {
        return this.triggerId;
    }
    /**
     * Template describing the types of source changes to trigger a build.
     * Branch and tag names in trigger templates are interpreted as regular
     * expressions. Any branch or tag change that matches that regular
     * expression will trigger a build.
     * One of `trigger_template`, `github`, `pubsub_config`, `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="triggerTemplate", type=TriggerTriggerTemplate.class, parameters={})
    private Output</* @Nullable */ TriggerTriggerTemplate> triggerTemplate;

    /**
     * @return Template describing the types of source changes to trigger a build.
     * Branch and tag names in trigger templates are interpreted as regular
     * expressions. Any branch or tag change that matches that regular
     * expression will trigger a build.
     * One of `trigger_template`, `github`, `pubsub_config`, `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerTriggerTemplate>> triggerTemplate() {
        return Codegen.optional(this.triggerTemplate);
    }
    /**
     * WebhookConfig describes the configuration of a trigger that creates
     * a build whenever a webhook is sent to a trigger&#39;s webhook URL.
     * One of `trigger_template`, `github`, `pubsub_config` `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="webhookConfig", type=TriggerWebhookConfig.class, parameters={})
    private Output</* @Nullable */ TriggerWebhookConfig> webhookConfig;

    /**
     * @return WebhookConfig describes the configuration of a trigger that creates
     * a build whenever a webhook is sent to a trigger&#39;s webhook URL.
     * One of `trigger_template`, `github`, `pubsub_config` `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerWebhookConfig>> webhookConfig() {
        return Codegen.optional(this.webhookConfig);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Trigger(String name) {
        this(name, TriggerArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Trigger(String name, @Nullable TriggerArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Trigger(String name, @Nullable TriggerArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:cloudbuild/trigger:Trigger", name, args == null ? TriggerArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private Trigger(String name, Output<String> id, @Nullable TriggerState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:cloudbuild/trigger:Trigger", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Trigger get(String name, Output<String> id, @Nullable TriggerState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Trigger(name, id, state, options);
    }
}
