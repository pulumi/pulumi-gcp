// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.cloudbuild;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.Utilities;
import com.pulumi.gcp.cloudbuild.TriggerArgs;
import com.pulumi.gcp.cloudbuild.inputs.TriggerState;
import com.pulumi.gcp.cloudbuild.outputs.TriggerApprovalConfig;
import com.pulumi.gcp.cloudbuild.outputs.TriggerBitbucketServerTriggerConfig;
import com.pulumi.gcp.cloudbuild.outputs.TriggerBuild;
import com.pulumi.gcp.cloudbuild.outputs.TriggerGitFileSource;
import com.pulumi.gcp.cloudbuild.outputs.TriggerGithub;
import com.pulumi.gcp.cloudbuild.outputs.TriggerPubsubConfig;
import com.pulumi.gcp.cloudbuild.outputs.TriggerRepositoryEventConfig;
import com.pulumi.gcp.cloudbuild.outputs.TriggerSourceToBuild;
import com.pulumi.gcp.cloudbuild.outputs.TriggerTriggerTemplate;
import com.pulumi.gcp.cloudbuild.outputs.TriggerWebhookConfig;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Configuration for an automated build in response to source repository changes.
 * 
 * To get more information about Trigger, see:
 * 
 * * [API documentation](https://cloud.google.com/cloud-build/docs/api/reference/rest/v1/projects.triggers)
 * * How-to Guides
 *     * [Automating builds using build triggers](https://cloud.google.com/cloud-build/docs/running-builds/automate-builds)
 * 
 * &gt; **Note:** You can retrieve the email of the Cloud Build Service Account used in jobs by using the `gcp.projects.ServiceIdentity` resource.
 * 
 * ## Example Usage
 * 
 * ### Cloudbuild Trigger Filename
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerTriggerTemplateArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var filename_trigger = new Trigger("filename-trigger", TriggerArgs.builder()
 *             .location("us-central1")
 *             .triggerTemplate(TriggerTriggerTemplateArgs.builder()
 *                 .branchName("main")
 *                 .repoName("my-repo")
 *                 .build())
 *             .substitutions(Map.ofEntries(
 *                 Map.entry("_FOO", "bar"),
 *                 Map.entry("_BAZ", "qux")
 *             ))
 *             .filename("cloudbuild.yaml")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Build
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerTriggerTemplateArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildSourceArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildSourceStorageSourceArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildAvailableSecretsArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildArtifactsArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildArtifactsObjectsArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildOptionsArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var build_trigger = new Trigger("build-trigger", TriggerArgs.builder()
 *             .name("my-trigger")
 *             .location("global")
 *             .triggerTemplate(TriggerTriggerTemplateArgs.builder()
 *                 .branchName("main")
 *                 .repoName("my-repo")
 *                 .build())
 *             .build(TriggerBuildArgs.builder()
 *                 .steps(                
 *                     TriggerBuildStepArgs.builder()
 *                         .name("gcr.io/cloud-builders/gsutil")
 *                         .args(                        
 *                             "cp",
 *                             "gs://mybucket/remotefile.zip",
 *                             "localfile.zip")
 *                         .timeout("120s")
 *                         .secretEnvs("MY_SECRET")
 *                         .build(),
 *                     TriggerBuildStepArgs.builder()
 *                         .name("ubuntu")
 *                         .script("echo hello")
 *                         .build())
 *                 .source(TriggerBuildSourceArgs.builder()
 *                     .storageSource(TriggerBuildSourceStorageSourceArgs.builder()
 *                         .bucket("mybucket")
 *                         .object("source_code.tar.gz")
 *                         .build())
 *                     .build())
 *                 .tags(                
 *                     "build",
 *                     "newFeature")
 *                 .substitutions(Map.ofEntries(
 *                     Map.entry("_FOO", "bar"),
 *                     Map.entry("_BAZ", "qux")
 *                 ))
 *                 .queueTtl("20s")
 *                 .logsBucket("gs://mybucket/logs")
 *                 .secrets(TriggerBuildSecretArgs.builder()
 *                     .kmsKeyName("projects/myProject/locations/global/keyRings/keyring-name/cryptoKeys/key-name")
 *                     .secretEnv(Map.of("PASSWORD", "ZW5jcnlwdGVkLXBhc3N3b3JkCg=="))
 *                     .build())
 *                 .availableSecrets(TriggerBuildAvailableSecretsArgs.builder()
 *                     .secretManagers(TriggerBuildAvailableSecretsSecretManagerArgs.builder()
 *                         .env("MY_SECRET")
 *                         .versionName("projects/myProject/secrets/mySecret/versions/latest")
 *                         .build())
 *                     .build())
 *                 .artifacts(TriggerBuildArtifactsArgs.builder()
 *                     .images("gcr.io/$PROJECT_ID/$REPO_NAME:$COMMIT_SHA")
 *                     .objects(TriggerBuildArtifactsObjectsArgs.builder()
 *                         .location("gs://bucket/path/to/somewhere/")
 *                         .paths("path")
 *                         .build())
 *                     .npmPackages(TriggerBuildArtifactsNpmPackageArgs.builder()
 *                         .packagePath("package.json")
 *                         .repository("https://us-west1-npm.pkg.dev/myProject/quickstart-nodejs-repo")
 *                         .build())
 *                     .pythonPackages(TriggerBuildArtifactsPythonPackageArgs.builder()
 *                         .paths("dist/*")
 *                         .repository("https://us-west1-python.pkg.dev/myProject/quickstart-python-repo")
 *                         .build())
 *                     .mavenArtifacts(TriggerBuildArtifactsMavenArtifactArgs.builder()
 *                         .repository("https://us-west1-maven.pkg.dev/myProject/quickstart-java-repo")
 *                         .path("/workspace/my-app/target/my-app-1.0.SNAPSHOT.jar")
 *                         .artifactId("my-app")
 *                         .groupId("com.mycompany.app")
 *                         .version("1.0")
 *                         .build())
 *                     .build())
 *                 .options(TriggerBuildOptionsArgs.builder()
 *                     .sourceProvenanceHashes("MD5")
 *                     .requestedVerifyOption("VERIFIED")
 *                     .machineType("N1_HIGHCPU_8")
 *                     .diskSizeGb(100)
 *                     .substitutionOption("ALLOW_LOOSE")
 *                     .dynamicSubstitutions(true)
 *                     .logStreamingOption("STREAM_OFF")
 *                     .workerPool("pool")
 *                     .logging("LEGACY")
 *                     .envs("ekey = evalue")
 *                     .secretEnvs("secretenv = svalue")
 *                     .volumes(TriggerBuildOptionsVolumeArgs.builder()
 *                         .name("v1")
 *                         .path("v1")
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Service Account
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.organizations.OrganizationsFunctions;
 * import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
 * import com.pulumi.gcp.serviceaccount.Account;
 * import com.pulumi.gcp.serviceaccount.AccountArgs;
 * import com.pulumi.gcp.projects.IAMMember;
 * import com.pulumi.gcp.projects.IAMMemberArgs;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerTriggerTemplateArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         final var project = OrganizationsFunctions.getProject(GetProjectArgs.builder()
 *             .build());
 * 
 *         var cloudbuildServiceAccount = new Account("cloudbuildServiceAccount", AccountArgs.builder()
 *             .accountId("cloud-sa")
 *             .build());
 * 
 *         var actAs = new IAMMember("actAs", IAMMemberArgs.builder()
 *             .project(project.projectId())
 *             .role("roles/iam.serviceAccountUser")
 *             .member(cloudbuildServiceAccount.email().applyValue(_email -> String.format("serviceAccount:%s", _email)))
 *             .build());
 * 
 *         var logsWriter = new IAMMember("logsWriter", IAMMemberArgs.builder()
 *             .project(project.projectId())
 *             .role("roles/logging.logWriter")
 *             .member(cloudbuildServiceAccount.email().applyValue(_email -> String.format("serviceAccount:%s", _email)))
 *             .build());
 * 
 *         var service_account_trigger = new Trigger("service-account-trigger", TriggerArgs.builder()
 *             .triggerTemplate(TriggerTriggerTemplateArgs.builder()
 *                 .branchName("main")
 *                 .repoName("my-repo")
 *                 .build())
 *             .serviceAccount(cloudbuildServiceAccount.id())
 *             .filename("cloudbuild.yaml")
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(                
 *                     actAs,
 *                     logsWriter)
 *                 .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Include Build Logs
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGithubArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGithubPushArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var include_build_logs_trigger = new Trigger("include-build-logs-trigger", TriggerArgs.builder()
 *             .location("us-central1")
 *             .name("include-build-logs-trigger")
 *             .filename("cloudbuild.yaml")
 *             .github(TriggerGithubArgs.builder()
 *                 .owner("hashicorp")
 *                 .name("terraform-provider-google-beta")
 *                 .push(TriggerGithubPushArgs.builder()
 *                     .branch("^main$")
 *                     .build())
 *                 .build())
 *             .includeBuildLogs("INCLUDE_BUILD_LOGS_WITH_STATUS")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Pubsub Config
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.pubsub.Topic;
 * import com.pulumi.gcp.pubsub.TopicArgs;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerPubsubConfigArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerSourceToBuildArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGitFileSourceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var mytopic = new Topic("mytopic", TopicArgs.builder()
 *             .name("my-topic")
 *             .build());
 * 
 *         var pubsub_config_trigger = new Trigger("pubsub-config-trigger", TriggerArgs.builder()
 *             .location("us-central1")
 *             .name("pubsub-trigger")
 *             .description("acceptance test example pubsub build trigger")
 *             .pubsubConfig(TriggerPubsubConfigArgs.builder()
 *                 .topic(mytopic.id())
 *                 .build())
 *             .sourceToBuild(TriggerSourceToBuildArgs.builder()
 *                 .uri("https://hashicorp/terraform-provider-google-beta")
 *                 .ref("refs/heads/main")
 *                 .repoType("GITHUB")
 *                 .build())
 *             .gitFileSource(TriggerGitFileSourceArgs.builder()
 *                 .path("cloudbuild.yaml")
 *                 .uri("https://hashicorp/terraform-provider-google-beta")
 *                 .revision("refs/heads/main")
 *                 .repoType("GITHUB")
 *                 .build())
 *             .substitutions(Map.of("_ACTION", "$(body.message.data.action)"))
 *             .filter("_ACTION.matches('INSERT')")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Webhook Config
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.secretmanager.Secret;
 * import com.pulumi.gcp.secretmanager.SecretArgs;
 * import com.pulumi.gcp.secretmanager.inputs.SecretReplicationArgs;
 * import com.pulumi.gcp.secretmanager.inputs.SecretReplicationUserManagedArgs;
 * import com.pulumi.gcp.secretmanager.SecretVersion;
 * import com.pulumi.gcp.secretmanager.SecretVersionArgs;
 * import com.pulumi.gcp.organizations.OrganizationsFunctions;
 * import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
 * import com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;
 * import com.pulumi.gcp.secretmanager.SecretIamPolicy;
 * import com.pulumi.gcp.secretmanager.SecretIamPolicyArgs;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerWebhookConfigArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerSourceToBuildArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGitFileSourceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App }{{@code
 *     public static void main(String[] args) }{{@code
 *         Pulumi.run(App::stack);
 *     }}{@code
 * 
 *     public static void stack(Context ctx) }{{@code
 *         var webhookTriggerSecretKey = new Secret("webhookTriggerSecretKey", SecretArgs.builder()
 *             .secretId("webhook-trigger-secret-key")
 *             .replication(SecretReplicationArgs.builder()
 *                 .userManaged(SecretReplicationUserManagedArgs.builder()
 *                     .replicas(SecretReplicationUserManagedReplicaArgs.builder()
 *                         .location("us-central1")
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *         var webhookTriggerSecretKeyData = new SecretVersion("webhookTriggerSecretKeyData", SecretVersionArgs.builder()
 *             .secret(webhookTriggerSecretKey.id())
 *             .secretData("secretkeygoeshere")
 *             .build());
 * 
 *         final var project = OrganizationsFunctions.getProject(GetProjectArgs.builder()
 *             .build());
 * 
 *         final var secretAccessor = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()
 *             .bindings(GetIAMPolicyBindingArgs.builder()
 *                 .role("roles/secretmanager.secretAccessor")
 *                 .members(String.format("serviceAccount:service-%s}{@literal @}{@code gcp-sa-cloudbuild.iam.gserviceaccount.com", project.number()))
 *                 .build())
 *             .build());
 * 
 *         var policy = new SecretIamPolicy("policy", SecretIamPolicyArgs.builder()
 *             .project(webhookTriggerSecretKey.project())
 *             .secretId(webhookTriggerSecretKey.secretId())
 *             .policyData(secretAccessor.policyData())
 *             .build());
 * 
 *         var webhook_config_trigger = new Trigger("webhook-config-trigger", TriggerArgs.builder()
 *             .name("webhook-trigger")
 *             .description("acceptance test example webhook build trigger")
 *             .webhookConfig(TriggerWebhookConfigArgs.builder()
 *                 .secret(webhookTriggerSecretKeyData.id())
 *                 .build())
 *             .sourceToBuild(TriggerSourceToBuildArgs.builder()
 *                 .uri("https://hashicorp/terraform-provider-google-beta")
 *                 .ref("refs/heads/main")
 *                 .repoType("GITHUB")
 *                 .build())
 *             .gitFileSource(TriggerGitFileSourceArgs.builder()
 *                 .path("cloudbuild.yaml")
 *                 .uri("https://hashicorp/terraform-provider-google-beta")
 *                 .revision("refs/heads/main")
 *                 .repoType("GITHUB")
 *                 .build())
 *             .build());
 * 
 *     }}{@code
 * }}{@code
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Manual
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerSourceToBuildArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGitFileSourceArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerApprovalConfigArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var manual_trigger = new Trigger("manual-trigger", TriggerArgs.builder()
 *             .name("manual-trigger")
 *             .sourceToBuild(TriggerSourceToBuildArgs.builder()
 *                 .uri("https://hashicorp/terraform-provider-google-beta")
 *                 .ref("refs/heads/main")
 *                 .repoType("GITHUB")
 *                 .build())
 *             .gitFileSource(TriggerGitFileSourceArgs.builder()
 *                 .path("cloudbuild.yaml")
 *                 .uri("https://hashicorp/terraform-provider-google-beta")
 *                 .revision("refs/heads/main")
 *                 .repoType("GITHUB")
 *                 .build())
 *             .approvalConfig(TriggerApprovalConfigArgs.builder()
 *                 .approvalRequired(true)
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Manual Github Enterprise
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerSourceToBuildArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGitFileSourceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var manual_ghe_trigger = new Trigger("manual-ghe-trigger", TriggerArgs.builder()
 *             .name("")
 *             .sourceToBuild(TriggerSourceToBuildArgs.builder()
 *                 .uri("https://hashicorp/terraform-provider-google-beta")
 *                 .ref("refs/heads/main")
 *                 .repoType("GITHUB")
 *                 .githubEnterpriseConfig("projects/myProject/locations/global/githubEnterpriseConfigs/configID")
 *                 .build())
 *             .gitFileSource(TriggerGitFileSourceArgs.builder()
 *                 .path("cloudbuild.yaml")
 *                 .uri("https://hashicorp/terraform-provider-google-beta")
 *                 .revision("refs/heads/main")
 *                 .repoType("GITHUB")
 *                 .githubEnterpriseConfig("projects/myProject/locations/global/githubEnterpriseConfigs/configID")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Manual Bitbucket Server
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerSourceToBuildArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGitFileSourceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var manual_bitbucket_trigger = new Trigger("manual-bitbucket-trigger", TriggerArgs.builder()
 *             .name("terraform-manual-bbs-trigger")
 *             .sourceToBuild(TriggerSourceToBuildArgs.builder()
 *                 .uri("https://bbs.com/scm/stag/test-repo.git")
 *                 .ref("refs/heads/main")
 *                 .repoType("BITBUCKET_SERVER")
 *                 .bitbucketServerConfig("projects/myProject/locations/global/bitbucketServerConfigs/configID")
 *                 .build())
 *             .gitFileSource(TriggerGitFileSourceArgs.builder()
 *                 .path("cloudbuild.yaml")
 *                 .uri("https://bbs.com/scm/stag/test-repo.git")
 *                 .revision("refs/heads/main")
 *                 .repoType("BITBUCKET_SERVER")
 *                 .bitbucketServerConfig("projects/myProject/locations/global/bitbucketServerConfigs/configID")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Repo
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuildv2.Connection;
 * import com.pulumi.gcp.cloudbuildv2.ConnectionArgs;
 * import com.pulumi.gcp.cloudbuildv2.inputs.ConnectionGithubConfigArgs;
 * import com.pulumi.gcp.cloudbuildv2.inputs.ConnectionGithubConfigAuthorizerCredentialArgs;
 * import com.pulumi.gcp.cloudbuildv2.Repository;
 * import com.pulumi.gcp.cloudbuildv2.RepositoryArgs;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerRepositoryEventConfigArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerRepositoryEventConfigPushArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var my_connection = new Connection("my-connection", ConnectionArgs.builder()
 *             .location("us-central1")
 *             .name("my-connection")
 *             .githubConfig(ConnectionGithubConfigArgs.builder()
 *                 .appInstallationId(123123)
 *                 .authorizerCredential(ConnectionGithubConfigAuthorizerCredentialArgs.builder()
 *                     .oauthTokenSecretVersion("projects/my-project/secrets/github-pat-secret/versions/latest")
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *         var my_repository = new Repository("my-repository", RepositoryArgs.builder()
 *             .name("my-repo")
 *             .parentConnection(my_connection.id())
 *             .remoteUri("https://github.com/myuser/my-repo.git")
 *             .build());
 * 
 *         var repo_trigger = new Trigger("repo-trigger", TriggerArgs.builder()
 *             .location("us-central1")
 *             .repositoryEventConfig(TriggerRepositoryEventConfigArgs.builder()
 *                 .repository(my_repository.id())
 *                 .push(TriggerRepositoryEventConfigPushArgs.builder()
 *                     .branch("feature-.*")
 *                     .build())
 *                 .build())
 *             .filename("cloudbuild.yaml")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Bitbucket Server Push
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBitbucketServerTriggerConfigArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBitbucketServerTriggerConfigPushArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var bbs_push_trigger = new Trigger("bbs-push-trigger", TriggerArgs.builder()
 *             .name("bbs-push-trigger")
 *             .location("us-central1")
 *             .bitbucketServerTriggerConfig(TriggerBitbucketServerTriggerConfigArgs.builder()
 *                 .repoSlug("bbs-push-trigger")
 *                 .projectKey("STAG")
 *                 .bitbucketServerConfigResource("projects/123456789/locations/us-central1/bitbucketServerConfigs/myBitbucketConfig")
 *                 .push(TriggerBitbucketServerTriggerConfigPushArgs.builder()
 *                     .tag("^0.1.*")
 *                     .invertRegex(true)
 *                     .build())
 *                 .build())
 *             .filename("cloudbuild.yaml")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Bitbucket Server Pull Request
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBitbucketServerTriggerConfigArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBitbucketServerTriggerConfigPullRequestArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var bbs_pull_request_trigger = new Trigger("bbs-pull-request-trigger", TriggerArgs.builder()
 *             .name("ghe-trigger")
 *             .location("us-central1")
 *             .bitbucketServerTriggerConfig(TriggerBitbucketServerTriggerConfigArgs.builder()
 *                 .repoSlug("terraform-provider-google")
 *                 .projectKey("STAG")
 *                 .bitbucketServerConfigResource("projects/123456789/locations/us-central1/bitbucketServerConfigs/myBitbucketConfig")
 *                 .pullRequest(TriggerBitbucketServerTriggerConfigPullRequestArgs.builder()
 *                     .branch("^master$")
 *                     .invertRegex(false)
 *                     .commentControl("COMMENTS_ENABLED")
 *                     .build())
 *                 .build())
 *             .filename("cloudbuild.yaml")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Github Enterprise
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGithubArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGithubPushArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var ghe_trigger = new Trigger("ghe-trigger", TriggerArgs.builder()
 *             .name("ghe-trigger")
 *             .location("us-central1")
 *             .github(TriggerGithubArgs.builder()
 *                 .owner("hashicorp")
 *                 .name("terraform-provider-google")
 *                 .push(TriggerGithubPushArgs.builder()
 *                     .branch("^main$")
 *                     .build())
 *                 .enterpriseConfigResourceName("projects/123456789/locations/us-central1/githubEnterpriseConfigs/configID")
 *                 .build())
 *             .filename("cloudbuild.yaml")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Allow Failure
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerTriggerTemplateArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildSourceArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildSourceStorageSourceArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildAvailableSecretsArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildArtifactsArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildArtifactsObjectsArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildOptionsArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var allow_failure_trigger = new Trigger("allow-failure-trigger", TriggerArgs.builder()
 *             .name("my-trigger")
 *             .location("global")
 *             .triggerTemplate(TriggerTriggerTemplateArgs.builder()
 *                 .branchName("main")
 *                 .repoName("my-repo")
 *                 .build())
 *             .build(TriggerBuildArgs.builder()
 *                 .steps(TriggerBuildStepArgs.builder()
 *                     .name("ubuntu")
 *                     .args(                    
 *                         "-c",
 *                         "exit 1")
 *                     .allowFailure(true)
 *                     .build())
 *                 .source(TriggerBuildSourceArgs.builder()
 *                     .storageSource(TriggerBuildSourceStorageSourceArgs.builder()
 *                         .bucket("mybucket")
 *                         .object("source_code.tar.gz")
 *                         .build())
 *                     .build())
 *                 .tags(                
 *                     "build",
 *                     "newFeature")
 *                 .substitutions(Map.ofEntries(
 *                     Map.entry("_FOO", "bar"),
 *                     Map.entry("_BAZ", "qux")
 *                 ))
 *                 .queueTtl("20s")
 *                 .logsBucket("gs://mybucket/logs")
 *                 .secrets(TriggerBuildSecretArgs.builder()
 *                     .kmsKeyName("projects/myProject/locations/global/keyRings/keyring-name/cryptoKeys/key-name")
 *                     .secretEnv(Map.of("PASSWORD", "ZW5jcnlwdGVkLXBhc3N3b3JkCg=="))
 *                     .build())
 *                 .availableSecrets(TriggerBuildAvailableSecretsArgs.builder()
 *                     .secretManagers(TriggerBuildAvailableSecretsSecretManagerArgs.builder()
 *                         .env("MY_SECRET")
 *                         .versionName("projects/myProject/secrets/mySecret/versions/latest")
 *                         .build())
 *                     .build())
 *                 .artifacts(TriggerBuildArtifactsArgs.builder()
 *                     .images("gcr.io/$PROJECT_ID/$REPO_NAME:$COMMIT_SHA")
 *                     .objects(TriggerBuildArtifactsObjectsArgs.builder()
 *                         .location("gs://bucket/path/to/somewhere/")
 *                         .paths("path")
 *                         .build())
 *                     .build())
 *                 .options(TriggerBuildOptionsArgs.builder()
 *                     .sourceProvenanceHashes("MD5")
 *                     .requestedVerifyOption("VERIFIED")
 *                     .machineType("N1_HIGHCPU_8")
 *                     .diskSizeGb(100)
 *                     .substitutionOption("ALLOW_LOOSE")
 *                     .dynamicSubstitutions(true)
 *                     .logStreamingOption("STREAM_OFF")
 *                     .workerPool("pool")
 *                     .logging("LEGACY")
 *                     .envs("ekey = evalue")
 *                     .secretEnvs("secretenv = svalue")
 *                     .volumes(TriggerBuildOptionsVolumeArgs.builder()
 *                         .name("v1")
 *                         .path("v1")
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Allow Exit Codes
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerTriggerTemplateArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildSourceArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildSourceStorageSourceArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildAvailableSecretsArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildArtifactsArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildArtifactsObjectsArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerBuildOptionsArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var allow_exit_codes_trigger = new Trigger("allow-exit-codes-trigger", TriggerArgs.builder()
 *             .name("my-trigger")
 *             .location("global")
 *             .triggerTemplate(TriggerTriggerTemplateArgs.builder()
 *                 .branchName("main")
 *                 .repoName("my-repo")
 *                 .build())
 *             .build(TriggerBuildArgs.builder()
 *                 .steps(TriggerBuildStepArgs.builder()
 *                     .name("ubuntu")
 *                     .args(                    
 *                         "-c",
 *                         "exit 1")
 *                     .allowExitCodes(                    
 *                         1,
 *                         3)
 *                     .build())
 *                 .source(TriggerBuildSourceArgs.builder()
 *                     .storageSource(TriggerBuildSourceStorageSourceArgs.builder()
 *                         .bucket("mybucket")
 *                         .object("source_code.tar.gz")
 *                         .build())
 *                     .build())
 *                 .tags(                
 *                     "build",
 *                     "newFeature")
 *                 .substitutions(Map.ofEntries(
 *                     Map.entry("_FOO", "bar"),
 *                     Map.entry("_BAZ", "qux")
 *                 ))
 *                 .queueTtl("20s")
 *                 .logsBucket("gs://mybucket/logs")
 *                 .secrets(TriggerBuildSecretArgs.builder()
 *                     .kmsKeyName("projects/myProject/locations/global/keyRings/keyring-name/cryptoKeys/key-name")
 *                     .secretEnv(Map.of("PASSWORD", "ZW5jcnlwdGVkLXBhc3N3b3JkCg=="))
 *                     .build())
 *                 .availableSecrets(TriggerBuildAvailableSecretsArgs.builder()
 *                     .secretManagers(TriggerBuildAvailableSecretsSecretManagerArgs.builder()
 *                         .env("MY_SECRET")
 *                         .versionName("projects/myProject/secrets/mySecret/versions/latest")
 *                         .build())
 *                     .build())
 *                 .artifacts(TriggerBuildArtifactsArgs.builder()
 *                     .images("gcr.io/$PROJECT_ID/$REPO_NAME:$COMMIT_SHA")
 *                     .objects(TriggerBuildArtifactsObjectsArgs.builder()
 *                         .location("gs://bucket/path/to/somewhere/")
 *                         .paths("path")
 *                         .build())
 *                     .build())
 *                 .options(TriggerBuildOptionsArgs.builder()
 *                     .sourceProvenanceHashes("MD5")
 *                     .requestedVerifyOption("VERIFIED")
 *                     .machineType("N1_HIGHCPU_8")
 *                     .diskSizeGb(100)
 *                     .substitutionOption("ALLOW_LOOSE")
 *                     .dynamicSubstitutions(true)
 *                     .logStreamingOption("STREAM_OFF")
 *                     .workerPool("pool")
 *                     .logging("LEGACY")
 *                     .envs("ekey = evalue")
 *                     .secretEnvs("secretenv = svalue")
 *                     .volumes(TriggerBuildOptionsVolumeArgs.builder()
 *                         .name("v1")
 *                         .path("v1")
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ### Cloudbuild Trigger Pubsub With Repo
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gcp.cloudbuildv2.Connection;
 * import com.pulumi.gcp.cloudbuildv2.ConnectionArgs;
 * import com.pulumi.gcp.cloudbuildv2.inputs.ConnectionGithubConfigArgs;
 * import com.pulumi.gcp.cloudbuildv2.inputs.ConnectionGithubConfigAuthorizerCredentialArgs;
 * import com.pulumi.gcp.cloudbuildv2.Repository;
 * import com.pulumi.gcp.cloudbuildv2.RepositoryArgs;
 * import com.pulumi.gcp.pubsub.Topic;
 * import com.pulumi.gcp.pubsub.TopicArgs;
 * import com.pulumi.gcp.cloudbuild.Trigger;
 * import com.pulumi.gcp.cloudbuild.TriggerArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerPubsubConfigArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerSourceToBuildArgs;
 * import com.pulumi.gcp.cloudbuild.inputs.TriggerGitFileSourceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var my_connection = new Connection("my-connection", ConnectionArgs.builder()
 *             .location("us-central1")
 *             .name("my-connection")
 *             .githubConfig(ConnectionGithubConfigArgs.builder()
 *                 .appInstallationId(123123)
 *                 .authorizerCredential(ConnectionGithubConfigAuthorizerCredentialArgs.builder()
 *                     .oauthTokenSecretVersion("projects/my-project/secrets/github-pat-secret/versions/latest")
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *         var my_repository = new Repository("my-repository", RepositoryArgs.builder()
 *             .name("my-repo")
 *             .parentConnection(my_connection.id())
 *             .remoteUri("https://github.com/myuser/my-repo.git")
 *             .build());
 * 
 *         var mytopic = new Topic("mytopic", TopicArgs.builder()
 *             .name("my-topic")
 *             .build());
 * 
 *         var pubsub_with_repo_trigger = new Trigger("pubsub-with-repo-trigger", TriggerArgs.builder()
 *             .name("pubsub-with-repo-trigger")
 *             .location("us-central1")
 *             .pubsubConfig(TriggerPubsubConfigArgs.builder()
 *                 .topic(mytopic.id())
 *                 .build())
 *             .sourceToBuild(TriggerSourceToBuildArgs.builder()
 *                 .repository(my_repository.id())
 *                 .ref("refs/heads/main")
 *                 .repoType("GITHUB")
 *                 .build())
 *             .gitFileSource(TriggerGitFileSourceArgs.builder()
 *                 .path("cloudbuild.yaml")
 *                 .repository(my_repository.id())
 *                 .revision("refs/heads/main")
 *                 .repoType("GITHUB")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Import
 * 
 * Trigger can be imported using any of these accepted formats:
 * 
 * * `projects/{{project}}/locations/{{location}}/triggers/{{trigger_id}}`
 * 
 * * `projects/{{project}}/triggers/{{trigger_id}}`
 * 
 * * `{{project}}/{{trigger_id}}`
 * 
 * * `{{trigger_id}}`
 * 
 * When using the `pulumi import` command, Trigger can be imported using one of the formats above. For example:
 * 
 * ```sh
 * $ pulumi import gcp:cloudbuild/trigger:Trigger default projects/{{project}}/locations/{{location}}/triggers/{{trigger_id}}
 * ```
 * 
 * ```sh
 * $ pulumi import gcp:cloudbuild/trigger:Trigger default projects/{{project}}/triggers/{{trigger_id}}
 * ```
 * 
 * ```sh
 * $ pulumi import gcp:cloudbuild/trigger:Trigger default {{project}}/{{trigger_id}}
 * ```
 * 
 * ```sh
 * $ pulumi import gcp:cloudbuild/trigger:Trigger default {{trigger_id}}
 * ```
 * 
 */
@ResourceType(type="gcp:cloudbuild/trigger:Trigger")
public class Trigger extends com.pulumi.resources.CustomResource {
    /**
     * Configuration for manual approval to start a build invocation of this BuildTrigger.
     * Builds created by this trigger will require approval before they execute.
     * Any user with a Cloud Build Approver role for the project can approve a build.
     * Structure is documented below.
     * 
     */
    @Export(name="approvalConfig", refs={TriggerApprovalConfig.class}, tree="[0]")
    private Output<TriggerApprovalConfig> approvalConfig;

    /**
     * @return Configuration for manual approval to start a build invocation of this BuildTrigger.
     * Builds created by this trigger will require approval before they execute.
     * Any user with a Cloud Build Approver role for the project can approve a build.
     * Structure is documented below.
     * 
     */
    public Output<TriggerApprovalConfig> approvalConfig() {
        return this.approvalConfig;
    }
    /**
     * BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
     * Structure is documented below.
     * 
     */
    @Export(name="bitbucketServerTriggerConfig", refs={TriggerBitbucketServerTriggerConfig.class}, tree="[0]")
    private Output</* @Nullable */ TriggerBitbucketServerTriggerConfig> bitbucketServerTriggerConfig;

    /**
     * @return BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerBitbucketServerTriggerConfig>> bitbucketServerTriggerConfig() {
        return Codegen.optional(this.bitbucketServerTriggerConfig);
    }
    /**
     * Contents of the build template. Either a filename or build template must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="build", refs={TriggerBuild.class}, tree="[0]")
    private Output</* @Nullable */ TriggerBuild> build;

    /**
     * @return Contents of the build template. Either a filename or build template must be provided.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerBuild>> build() {
        return Codegen.optional(this.build);
    }
    /**
     * Time when the trigger was created.
     * 
     */
    @Export(name="createTime", refs={String.class}, tree="[0]")
    private Output<String> createTime;

    /**
     * @return Time when the trigger was created.
     * 
     */
    public Output<String> createTime() {
        return this.createTime;
    }
    /**
     * Human-readable description of the trigger.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return Human-readable description of the trigger.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Whether the trigger is disabled or not. If true, the trigger will never result in a build.
     * 
     */
    @Export(name="disabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> disabled;

    /**
     * @return Whether the trigger is disabled or not. If true, the trigger will never result in a build.
     * 
     */
    public Output<Optional<Boolean>> disabled() {
        return Codegen.optional(this.disabled);
    }
    /**
     * Path, from the source root, to a file whose contents is used for the template.
     * Either a filename or build template must be provided. Set this only when using trigger_template or github.
     * When using Pub/Sub, Webhook or Manual set the file name using git_file_source instead.
     * 
     */
    @Export(name="filename", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> filename;

    /**
     * @return Path, from the source root, to a file whose contents is used for the template.
     * Either a filename or build template must be provided. Set this only when using trigger_template or github.
     * When using Pub/Sub, Webhook or Manual set the file name using git_file_source instead.
     * 
     */
    public Output<Optional<String>> filename() {
        return Codegen.optional(this.filename);
    }
    /**
     * A Common Expression Language string. Used only with Pub/Sub and Webhook.
     * 
     */
    @Export(name="filter", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> filter;

    /**
     * @return A Common Expression Language string. Used only with Pub/Sub and Webhook.
     * 
     */
    public Output<Optional<String>> filter() {
        return Codegen.optional(this.filter);
    }
    /**
     * The file source describing the local or remote Build template.
     * Structure is documented below.
     * 
     */
    @Export(name="gitFileSource", refs={TriggerGitFileSource.class}, tree="[0]")
    private Output</* @Nullable */ TriggerGitFileSource> gitFileSource;

    /**
     * @return The file source describing the local or remote Build template.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerGitFileSource>> gitFileSource() {
        return Codegen.optional(this.gitFileSource);
    }
    /**
     * Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
     * One of `trigger_template`, `github`, `pubsub_config` or `webhook_config` must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="github", refs={TriggerGithub.class}, tree="[0]")
    private Output</* @Nullable */ TriggerGithub> github;

    /**
     * @return Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
     * One of `trigger_template`, `github`, `pubsub_config` or `webhook_config` must be provided.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerGithub>> github() {
        return Codegen.optional(this.github);
    }
    /**
     * ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
     * extended with support for `**`.
     * If ignoredFiles and changed files are both empty, then they are not
     * used to determine whether or not to trigger a build.
     * If ignoredFiles is not empty, then we ignore any files that match any
     * of the ignored_file globs. If the change has no files that are outside
     * of the ignoredFiles globs, then we do not trigger a build.
     * 
     */
    @Export(name="ignoredFiles", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> ignoredFiles;

    /**
     * @return ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
     * extended with support for `**`.
     * If ignoredFiles and changed files are both empty, then they are not
     * used to determine whether or not to trigger a build.
     * If ignoredFiles is not empty, then we ignore any files that match any
     * of the ignored_file globs. If the change has no files that are outside
     * of the ignoredFiles globs, then we do not trigger a build.
     * 
     */
    public Output<Optional<List<String>>> ignoredFiles() {
        return Codegen.optional(this.ignoredFiles);
    }
    /**
     * Build logs will be sent back to GitHub as part of the checkrun
     * result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or
     * INCLUDE_BUILD_LOGS_WITH_STATUS
     * Possible values are: `INCLUDE_BUILD_LOGS_UNSPECIFIED`, `INCLUDE_BUILD_LOGS_WITH_STATUS`.
     * 
     */
    @Export(name="includeBuildLogs", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> includeBuildLogs;

    /**
     * @return Build logs will be sent back to GitHub as part of the checkrun
     * result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or
     * INCLUDE_BUILD_LOGS_WITH_STATUS
     * Possible values are: `INCLUDE_BUILD_LOGS_UNSPECIFIED`, `INCLUDE_BUILD_LOGS_WITH_STATUS`.
     * 
     */
    public Output<Optional<String>> includeBuildLogs() {
        return Codegen.optional(this.includeBuildLogs);
    }
    /**
     * ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
     * extended with support for `**`.
     * If any of the files altered in the commit pass the ignoredFiles filter
     * and includedFiles is empty, then as far as this filter is concerned, we
     * should trigger the build.
     * If any of the files altered in the commit pass the ignoredFiles filter
     * and includedFiles is not empty, then we make sure that at least one of
     * those files matches a includedFiles glob. If not, then we do not trigger
     * a build.
     * 
     */
    @Export(name="includedFiles", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> includedFiles;

    /**
     * @return ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
     * extended with support for `**`.
     * If any of the files altered in the commit pass the ignoredFiles filter
     * and includedFiles is empty, then as far as this filter is concerned, we
     * should trigger the build.
     * If any of the files altered in the commit pass the ignoredFiles filter
     * and includedFiles is not empty, then we make sure that at least one of
     * those files matches a includedFiles glob. If not, then we do not trigger
     * a build.
     * 
     */
    public Output<Optional<List<String>>> includedFiles() {
        return Codegen.optional(this.includedFiles);
    }
    /**
     * The [Cloud Build location](https://cloud.google.com/build/docs/locations) for the trigger.
     * If not specified, &#34;global&#34; is used.
     * 
     */
    @Export(name="location", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> location;

    /**
     * @return The [Cloud Build location](https://cloud.google.com/build/docs/locations) for the trigger.
     * If not specified, &#34;global&#34; is used.
     * 
     */
    public Output<Optional<String>> location() {
        return Codegen.optional(this.location);
    }
    /**
     * Name of the trigger. Must be unique within the project.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return Name of the trigger. Must be unique within the project.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Export(name="project", refs={String.class}, tree="[0]")
    private Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Output<String> project() {
        return this.project;
    }
    /**
     * PubsubConfig describes the configuration of a trigger that creates
     * a build whenever a Pub/Sub message is published.
     * One of `trigger_template`, `github`, `pubsub_config` `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="pubsubConfig", refs={TriggerPubsubConfig.class}, tree="[0]")
    private Output</* @Nullable */ TriggerPubsubConfig> pubsubConfig;

    /**
     * @return PubsubConfig describes the configuration of a trigger that creates
     * a build whenever a Pub/Sub message is published.
     * One of `trigger_template`, `github`, `pubsub_config` `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerPubsubConfig>> pubsubConfig() {
        return Codegen.optional(this.pubsubConfig);
    }
    /**
     * The configuration of a trigger that creates a build whenever an event from Repo API is received.
     * Structure is documented below.
     * 
     */
    @Export(name="repositoryEventConfig", refs={TriggerRepositoryEventConfig.class}, tree="[0]")
    private Output</* @Nullable */ TriggerRepositoryEventConfig> repositoryEventConfig;

    /**
     * @return The configuration of a trigger that creates a build whenever an event from Repo API is received.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerRepositoryEventConfig>> repositoryEventConfig() {
        return Codegen.optional(this.repositoryEventConfig);
    }
    /**
     * The service account used for all user-controlled operations including
     * triggers.patch, triggers.run, builds.create, and builds.cancel.
     * If no service account is set, then the standard Cloud Build service account
     * ([PROJECT_NUM]{@literal @}system.gserviceaccount.com) will be used instead.
     * Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
     * 
     */
    @Export(name="serviceAccount", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> serviceAccount;

    /**
     * @return The service account used for all user-controlled operations including
     * triggers.patch, triggers.run, builds.create, and builds.cancel.
     * If no service account is set, then the standard Cloud Build service account
     * ([PROJECT_NUM]{@literal @}system.gserviceaccount.com) will be used instead.
     * Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
     * 
     */
    public Output<Optional<String>> serviceAccount() {
        return Codegen.optional(this.serviceAccount);
    }
    /**
     * The repo and ref of the repository from which to build.
     * This field is used only for those triggers that do not respond to SCM events.
     * Triggers that respond to such events build source at whatever commit caused the event.
     * This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
     * One of `trigger_template`, `github`, `pubsub_config` `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="sourceToBuild", refs={TriggerSourceToBuild.class}, tree="[0]")
    private Output</* @Nullable */ TriggerSourceToBuild> sourceToBuild;

    /**
     * @return The repo and ref of the repository from which to build.
     * This field is used only for those triggers that do not respond to SCM events.
     * Triggers that respond to such events build source at whatever commit caused the event.
     * This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
     * One of `trigger_template`, `github`, `pubsub_config` `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerSourceToBuild>> sourceToBuild() {
        return Codegen.optional(this.sourceToBuild);
    }
    /**
     * Substitutions data for Build resource.
     * 
     */
    @Export(name="substitutions", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> substitutions;

    /**
     * @return Substitutions data for Build resource.
     * 
     */
    public Output<Optional<Map<String,String>>> substitutions() {
        return Codegen.optional(this.substitutions);
    }
    /**
     * Tags for annotation of a BuildTrigger
     * 
     */
    @Export(name="tags", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> tags;

    /**
     * @return Tags for annotation of a BuildTrigger
     * 
     */
    public Output<Optional<List<String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * The unique identifier for the trigger.
     * 
     */
    @Export(name="triggerId", refs={String.class}, tree="[0]")
    private Output<String> triggerId;

    /**
     * @return The unique identifier for the trigger.
     * 
     */
    public Output<String> triggerId() {
        return this.triggerId;
    }
    /**
     * Template describing the types of source changes to trigger a build.
     * Branch and tag names in trigger templates are interpreted as regular
     * expressions. Any branch or tag change that matches that regular
     * expression will trigger a build.
     * One of `trigger_template`, `github`, `pubsub_config`, `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="triggerTemplate", refs={TriggerTriggerTemplate.class}, tree="[0]")
    private Output</* @Nullable */ TriggerTriggerTemplate> triggerTemplate;

    /**
     * @return Template describing the types of source changes to trigger a build.
     * Branch and tag names in trigger templates are interpreted as regular
     * expressions. Any branch or tag change that matches that regular
     * expression will trigger a build.
     * One of `trigger_template`, `github`, `pubsub_config`, `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerTriggerTemplate>> triggerTemplate() {
        return Codegen.optional(this.triggerTemplate);
    }
    /**
     * WebhookConfig describes the configuration of a trigger that creates
     * a build whenever a webhook is sent to a trigger&#39;s webhook URL.
     * One of `trigger_template`, `github`, `pubsub_config` `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="webhookConfig", refs={TriggerWebhookConfig.class}, tree="[0]")
    private Output</* @Nullable */ TriggerWebhookConfig> webhookConfig;

    /**
     * @return WebhookConfig describes the configuration of a trigger that creates
     * a build whenever a webhook is sent to a trigger&#39;s webhook URL.
     * One of `trigger_template`, `github`, `pubsub_config` `webhook_config` or `source_to_build` must be provided.
     * Structure is documented below.
     * 
     */
    public Output<Optional<TriggerWebhookConfig>> webhookConfig() {
        return Codegen.optional(this.webhookConfig);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Trigger(java.lang.String name) {
        this(name, TriggerArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Trigger(java.lang.String name, @Nullable TriggerArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Trigger(java.lang.String name, @Nullable TriggerArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:cloudbuild/trigger:Trigger", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Trigger(java.lang.String name, Output<java.lang.String> id, @Nullable TriggerState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gcp:cloudbuild/trigger:Trigger", name, state, makeResourceOptions(options, id), false);
    }

    private static TriggerArgs makeArgs(@Nullable TriggerArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? TriggerArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Trigger get(java.lang.String name, Output<java.lang.String> id, @Nullable TriggerState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Trigger(name, id, state, options);
    }
}
