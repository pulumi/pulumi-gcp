// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.gkebackup.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.gcp.gkebackup.outputs.RestorePlanRestoreConfigTransformationRuleResourceFilterGroupKind;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class RestorePlanRestoreConfigTransformationRuleResourceFilter {
    /**
     * @return (Filtering parameter) Any resource subject to transformation must
     * belong to one of the listed &#34;types&#34;. If this field is not provided,
     * no type filtering will be performed
     * (all resources of all types matching previous filtering parameters
     * will be candidates for transformation).
     * Structure is documented below.
     * 
     */
    private @Nullable List<RestorePlanRestoreConfigTransformationRuleResourceFilterGroupKind> groupKinds;
    /**
     * @return This is a JSONPath expression that matches specific fields of
     * candidate resources and it operates as a filtering parameter
     * (resources that are not matched with this expression will not
     * be candidates for transformation).
     * 
     */
    private @Nullable String jsonPath;
    /**
     * @return (Filtering parameter) Any resource subject to transformation must
     * be contained within one of the listed Kubernetes Namespace in the
     * Backup. If this field is not provided, no namespace filtering will
     * be performed (all resources in all Namespaces, including all
     * cluster-scoped resources, will be candidates for transformation).
     * To mix cluster-scoped and namespaced resources in the same rule,
     * use an empty string (&#34;&#34;) as one of the target namespaces.
     * 
     */
    private @Nullable List<String> namespaces;

    private RestorePlanRestoreConfigTransformationRuleResourceFilter() {}
    /**
     * @return (Filtering parameter) Any resource subject to transformation must
     * belong to one of the listed &#34;types&#34;. If this field is not provided,
     * no type filtering will be performed
     * (all resources of all types matching previous filtering parameters
     * will be candidates for transformation).
     * Structure is documented below.
     * 
     */
    public List<RestorePlanRestoreConfigTransformationRuleResourceFilterGroupKind> groupKinds() {
        return this.groupKinds == null ? List.of() : this.groupKinds;
    }
    /**
     * @return This is a JSONPath expression that matches specific fields of
     * candidate resources and it operates as a filtering parameter
     * (resources that are not matched with this expression will not
     * be candidates for transformation).
     * 
     */
    public Optional<String> jsonPath() {
        return Optional.ofNullable(this.jsonPath);
    }
    /**
     * @return (Filtering parameter) Any resource subject to transformation must
     * be contained within one of the listed Kubernetes Namespace in the
     * Backup. If this field is not provided, no namespace filtering will
     * be performed (all resources in all Namespaces, including all
     * cluster-scoped resources, will be candidates for transformation).
     * To mix cluster-scoped and namespaced resources in the same rule,
     * use an empty string (&#34;&#34;) as one of the target namespaces.
     * 
     */
    public List<String> namespaces() {
        return this.namespaces == null ? List.of() : this.namespaces;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(RestorePlanRestoreConfigTransformationRuleResourceFilter defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable List<RestorePlanRestoreConfigTransformationRuleResourceFilterGroupKind> groupKinds;
        private @Nullable String jsonPath;
        private @Nullable List<String> namespaces;
        public Builder() {}
        public Builder(RestorePlanRestoreConfigTransformationRuleResourceFilter defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.groupKinds = defaults.groupKinds;
    	      this.jsonPath = defaults.jsonPath;
    	      this.namespaces = defaults.namespaces;
        }

        @CustomType.Setter
        public Builder groupKinds(@Nullable List<RestorePlanRestoreConfigTransformationRuleResourceFilterGroupKind> groupKinds) {
            this.groupKinds = groupKinds;
            return this;
        }
        public Builder groupKinds(RestorePlanRestoreConfigTransformationRuleResourceFilterGroupKind... groupKinds) {
            return groupKinds(List.of(groupKinds));
        }
        @CustomType.Setter
        public Builder jsonPath(@Nullable String jsonPath) {
            this.jsonPath = jsonPath;
            return this;
        }
        @CustomType.Setter
        public Builder namespaces(@Nullable List<String> namespaces) {
            this.namespaces = namespaces;
            return this;
        }
        public Builder namespaces(String... namespaces) {
            return namespaces(List.of(namespaces));
        }
        public RestorePlanRestoreConfigTransformationRuleResourceFilter build() {
            final var o = new RestorePlanRestoreConfigTransformationRuleResourceFilter();
            o.groupKinds = groupKinds;
            o.jsonPath = jsonPath;
            o.namespaces = namespaces;
            return o;
        }
    }
}
