// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.hypercomputecluster.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.hypercomputecluster.inputs.ClusterOrchestratorSlurmNodeSetComputeInstanceArgs;
import com.pulumi.gcp.hypercomputecluster.inputs.ClusterOrchestratorSlurmNodeSetStorageConfigArgs;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ClusterOrchestratorSlurmNodeSetArgs extends com.pulumi.resources.ResourceArgs {

    public static final ClusterOrchestratorSlurmNodeSetArgs Empty = new ClusterOrchestratorSlurmNodeSetArgs();

    /**
     * ID of the compute resource on which this nodeset will run. Must match a key
     * in the cluster&#39;s compute_resources.
     * 
     */
    @Import(name="computeId")
    private @Nullable Output<String> computeId;

    /**
     * @return ID of the compute resource on which this nodeset will run. Must match a key
     * in the cluster&#39;s compute_resources.
     * 
     */
    public Optional<Output<String>> computeId() {
        return Optional.ofNullable(this.computeId);
    }

    /**
     * When set in a SlurmNodeSet, indicates that the nodeset should be backed
     * by Compute Engine VM instances.
     * Structure is documented below.
     * 
     */
    @Import(name="computeInstance")
    private @Nullable Output<ClusterOrchestratorSlurmNodeSetComputeInstanceArgs> computeInstance;

    /**
     * @return When set in a SlurmNodeSet, indicates that the nodeset should be backed
     * by Compute Engine VM instances.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ClusterOrchestratorSlurmNodeSetComputeInstanceArgs>> computeInstance() {
        return Optional.ofNullable(this.computeInstance);
    }

    /**
     * Identifier for the nodeset, which allows it to be referenced by partitions.
     * Must conform to
     * [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
     * alphanumeric, and at most 63 characters).
     * 
     */
    @Import(name="id", required=true)
    private Output<String> id;

    /**
     * @return Identifier for the nodeset, which allows it to be referenced by partitions.
     * Must conform to
     * [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
     * alphanumeric, and at most 63 characters).
     * 
     */
    public Output<String> id() {
        return this.id;
    }

    /**
     * Controls how many additional nodes a cluster can bring online to handle
     * workloads. Set this value to enable dynamic node creation and limit the
     * number of additional nodes the cluster can bring online. Leave empty if you
     * do not want the cluster to create nodes dynamically, and instead rely only
     * on static nodes.
     * 
     */
    @Import(name="maxDynamicNodeCount")
    private @Nullable Output<String> maxDynamicNodeCount;

    /**
     * @return Controls how many additional nodes a cluster can bring online to handle
     * workloads. Set this value to enable dynamic node creation and limit the
     * number of additional nodes the cluster can bring online. Leave empty if you
     * do not want the cluster to create nodes dynamically, and instead rely only
     * on static nodes.
     * 
     */
    public Optional<Output<String>> maxDynamicNodeCount() {
        return Optional.ofNullable(this.maxDynamicNodeCount);
    }

    /**
     * Number of nodes to be statically created for this nodeset. The cluster will
     * attempt to ensure that at least this many nodes exist at all times.
     * 
     */
    @Import(name="staticNodeCount")
    private @Nullable Output<String> staticNodeCount;

    /**
     * @return Number of nodes to be statically created for this nodeset. The cluster will
     * attempt to ensure that at least this many nodes exist at all times.
     * 
     */
    public Optional<Output<String>> staticNodeCount() {
        return Optional.ofNullable(this.staticNodeCount);
    }

    /**
     * How storage resources should be mounted on each compute
     * node.
     * Structure is documented below.
     * 
     */
    @Import(name="storageConfigs")
    private @Nullable Output<List<ClusterOrchestratorSlurmNodeSetStorageConfigArgs>> storageConfigs;

    /**
     * @return How storage resources should be mounted on each compute
     * node.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<ClusterOrchestratorSlurmNodeSetStorageConfigArgs>>> storageConfigs() {
        return Optional.ofNullable(this.storageConfigs);
    }

    private ClusterOrchestratorSlurmNodeSetArgs() {}

    private ClusterOrchestratorSlurmNodeSetArgs(ClusterOrchestratorSlurmNodeSetArgs $) {
        this.computeId = $.computeId;
        this.computeInstance = $.computeInstance;
        this.id = $.id;
        this.maxDynamicNodeCount = $.maxDynamicNodeCount;
        this.staticNodeCount = $.staticNodeCount;
        this.storageConfigs = $.storageConfigs;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ClusterOrchestratorSlurmNodeSetArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ClusterOrchestratorSlurmNodeSetArgs $;

        public Builder() {
            $ = new ClusterOrchestratorSlurmNodeSetArgs();
        }

        public Builder(ClusterOrchestratorSlurmNodeSetArgs defaults) {
            $ = new ClusterOrchestratorSlurmNodeSetArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param computeId ID of the compute resource on which this nodeset will run. Must match a key
         * in the cluster&#39;s compute_resources.
         * 
         * @return builder
         * 
         */
        public Builder computeId(@Nullable Output<String> computeId) {
            $.computeId = computeId;
            return this;
        }

        /**
         * @param computeId ID of the compute resource on which this nodeset will run. Must match a key
         * in the cluster&#39;s compute_resources.
         * 
         * @return builder
         * 
         */
        public Builder computeId(String computeId) {
            return computeId(Output.of(computeId));
        }

        /**
         * @param computeInstance When set in a SlurmNodeSet, indicates that the nodeset should be backed
         * by Compute Engine VM instances.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder computeInstance(@Nullable Output<ClusterOrchestratorSlurmNodeSetComputeInstanceArgs> computeInstance) {
            $.computeInstance = computeInstance;
            return this;
        }

        /**
         * @param computeInstance When set in a SlurmNodeSet, indicates that the nodeset should be backed
         * by Compute Engine VM instances.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder computeInstance(ClusterOrchestratorSlurmNodeSetComputeInstanceArgs computeInstance) {
            return computeInstance(Output.of(computeInstance));
        }

        /**
         * @param id Identifier for the nodeset, which allows it to be referenced by partitions.
         * Must conform to
         * [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
         * alphanumeric, and at most 63 characters).
         * 
         * @return builder
         * 
         */
        public Builder id(Output<String> id) {
            $.id = id;
            return this;
        }

        /**
         * @param id Identifier for the nodeset, which allows it to be referenced by partitions.
         * Must conform to
         * [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
         * alphanumeric, and at most 63 characters).
         * 
         * @return builder
         * 
         */
        public Builder id(String id) {
            return id(Output.of(id));
        }

        /**
         * @param maxDynamicNodeCount Controls how many additional nodes a cluster can bring online to handle
         * workloads. Set this value to enable dynamic node creation and limit the
         * number of additional nodes the cluster can bring online. Leave empty if you
         * do not want the cluster to create nodes dynamically, and instead rely only
         * on static nodes.
         * 
         * @return builder
         * 
         */
        public Builder maxDynamicNodeCount(@Nullable Output<String> maxDynamicNodeCount) {
            $.maxDynamicNodeCount = maxDynamicNodeCount;
            return this;
        }

        /**
         * @param maxDynamicNodeCount Controls how many additional nodes a cluster can bring online to handle
         * workloads. Set this value to enable dynamic node creation and limit the
         * number of additional nodes the cluster can bring online. Leave empty if you
         * do not want the cluster to create nodes dynamically, and instead rely only
         * on static nodes.
         * 
         * @return builder
         * 
         */
        public Builder maxDynamicNodeCount(String maxDynamicNodeCount) {
            return maxDynamicNodeCount(Output.of(maxDynamicNodeCount));
        }

        /**
         * @param staticNodeCount Number of nodes to be statically created for this nodeset. The cluster will
         * attempt to ensure that at least this many nodes exist at all times.
         * 
         * @return builder
         * 
         */
        public Builder staticNodeCount(@Nullable Output<String> staticNodeCount) {
            $.staticNodeCount = staticNodeCount;
            return this;
        }

        /**
         * @param staticNodeCount Number of nodes to be statically created for this nodeset. The cluster will
         * attempt to ensure that at least this many nodes exist at all times.
         * 
         * @return builder
         * 
         */
        public Builder staticNodeCount(String staticNodeCount) {
            return staticNodeCount(Output.of(staticNodeCount));
        }

        /**
         * @param storageConfigs How storage resources should be mounted on each compute
         * node.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder storageConfigs(@Nullable Output<List<ClusterOrchestratorSlurmNodeSetStorageConfigArgs>> storageConfigs) {
            $.storageConfigs = storageConfigs;
            return this;
        }

        /**
         * @param storageConfigs How storage resources should be mounted on each compute
         * node.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder storageConfigs(List<ClusterOrchestratorSlurmNodeSetStorageConfigArgs> storageConfigs) {
            return storageConfigs(Output.of(storageConfigs));
        }

        /**
         * @param storageConfigs How storage resources should be mounted on each compute
         * node.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder storageConfigs(ClusterOrchestratorSlurmNodeSetStorageConfigArgs... storageConfigs) {
            return storageConfigs(List.of(storageConfigs));
        }

        public ClusterOrchestratorSlurmNodeSetArgs build() {
            if ($.id == null) {
                throw new MissingRequiredPropertyException("ClusterOrchestratorSlurmNodeSetArgs", "id");
            }
            return $;
        }
    }

}
