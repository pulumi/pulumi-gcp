// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.discoveryengine.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.discoveryengine.inputs.DataConnectorEntityArgs;
import com.pulumi.gcp.discoveryengine.inputs.DataConnectorErrorArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DataConnectorState extends com.pulumi.resources.ResourceArgs {

    public static final DataConnectorState Empty = new DataConnectorState();

    /**
     * State of the action connector. This reflects whether the action connector
     * is initializing, active or has encountered errors. The possible value can be:
     * &#39;STATE_UNSPECIFIED&#39;, &#39;CREATING&#39;, &#39;ACTIVE&#39;, &#39;FAILED&#39;, &#39;RUNNING&#39;, &#39;WARNING&#39;,
     * &#39;INITIALIZATION_FAILED&#39;, &#39;UPDATING&#39;.
     * 
     */
    @Import(name="actionState")
    private @Nullable Output<String> actionState;

    /**
     * @return State of the action connector. This reflects whether the action connector
     * is initializing, active or has encountered errors. The possible value can be:
     * &#39;STATE_UNSPECIFIED&#39;, &#39;CREATING&#39;, &#39;ACTIVE&#39;, &#39;FAILED&#39;, &#39;RUNNING&#39;, &#39;WARNING&#39;,
     * &#39;INITIALIZATION_FAILED&#39;, &#39;UPDATING&#39;.
     * 
     */
    public Optional<Output<String>> actionState() {
        return Optional.ofNullable(this.actionState);
    }

    /**
     * Indicates whether full syncs are paused for this connector
     * 
     */
    @Import(name="autoRunDisabled")
    private @Nullable Output<Boolean> autoRunDisabled;

    /**
     * @return Indicates whether full syncs are paused for this connector
     * 
     */
    public Optional<Output<Boolean>> autoRunDisabled() {
        return Optional.ofNullable(this.autoRunDisabled);
    }

    /**
     * User actions that must be completed before the connector can start syncing data.
     * The possible values can be: &#39;ALLOWLIST_STATIC_IP&#39;, &#39;ALLOWLIST_IN_SERVICE_ATTACHMENT&#39;.
     * 
     */
    @Import(name="blockingReasons")
    private @Nullable Output<List<String>> blockingReasons;

    /**
     * @return User actions that must be completed before the connector can start syncing data.
     * The possible values can be: &#39;ALLOWLIST_STATIC_IP&#39;, &#39;ALLOWLIST_IN_SERVICE_ATTACHMENT&#39;.
     * 
     */
    public Optional<Output<List<String>>> blockingReasons() {
        return Optional.ofNullable(this.blockingReasons);
    }

    /**
     * The display name of the Collection.
     * Should be human readable, used to display collections in the Console
     * Dashboard. UTF-8 encoded string with limit of 1024 characters.
     * 
     */
    @Import(name="collectionDisplayName")
    private @Nullable Output<String> collectionDisplayName;

    /**
     * @return The display name of the Collection.
     * Should be human readable, used to display collections in the Console
     * Dashboard. UTF-8 encoded string with limit of 1024 characters.
     * 
     */
    public Optional<Output<String>> collectionDisplayName() {
        return Optional.ofNullable(this.collectionDisplayName);
    }

    /**
     * The ID to use for the Collection, which will become the final component
     * of the Collection&#39;s resource name. A new Collection is created as
     * part of the DataConnector setup. DataConnector is a singleton
     * resource under Collection, managing all DataStores of the Collection.
     * This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
     * standard with a length limit of 63 characters. Otherwise, an
     * INVALID_ARGUMENT error is returned.
     * 
     */
    @Import(name="collectionId")
    private @Nullable Output<String> collectionId;

    /**
     * @return The ID to use for the Collection, which will become the final component
     * of the Collection&#39;s resource name. A new Collection is created as
     * part of the DataConnector setup. DataConnector is a singleton
     * resource under Collection, managing all DataStores of the Collection.
     * This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
     * standard with a length limit of 63 characters. Otherwise, an
     * INVALID_ARGUMENT error is returned.
     * 
     */
    public Optional<Output<String>> collectionId() {
        return Optional.ofNullable(this.collectionId);
    }

    /**
     * The modes enabled for this connector. The possible value can be:
     * &#39;DATA_INGESTION&#39;, &#39;ACTIONS&#39;, &#39;FEDERATED&#39;
     * &#39;EUA&#39;, &#39;FEDERATED_AND_EUA&#39;.
     * 
     */
    @Import(name="connectorModes")
    private @Nullable Output<List<String>> connectorModes;

    /**
     * @return The modes enabled for this connector. The possible value can be:
     * &#39;DATA_INGESTION&#39;, &#39;ACTIONS&#39;, &#39;FEDERATED&#39;
     * &#39;EUA&#39;, &#39;FEDERATED_AND_EUA&#39;.
     * 
     */
    public Optional<Output<List<String>>> connectorModes() {
        return Optional.ofNullable(this.connectorModes);
    }

    /**
     * The type of connector. Each source can only map to one type.
     * For example, salesforce, confluence and jira have THIRD_PARTY connector
     * type. It is not mutable once set by system. The possible value can be:
     * &#39;CONNECTOR_TYPE_UNSPECIFIED&#39;, &#39;THIRD_PARTY&#39;, &#39;GCP_FHIR&#39;, &#39;BIG_QUERY&#39;,
     * &#39;GCS&#39;, &#39;GOOGLE_MAIL&#39;, &#39;GOOGLE_CALENDAR&#39;, &#39;GOOGLE_DRIVE&#39;,
     * &#39;NATIVE_CLOUD_IDENTITY&#39;, &#39;THIRD_PARTY_FEDERATED&#39;, &#39;THIRD_PARTY_EUA&#39;, &#39;GCNV&#39;.
     * 
     */
    @Import(name="connectorType")
    private @Nullable Output<String> connectorType;

    /**
     * @return The type of connector. Each source can only map to one type.
     * For example, salesforce, confluence and jira have THIRD_PARTY connector
     * type. It is not mutable once set by system. The possible value can be:
     * &#39;CONNECTOR_TYPE_UNSPECIFIED&#39;, &#39;THIRD_PARTY&#39;, &#39;GCP_FHIR&#39;, &#39;BIG_QUERY&#39;,
     * &#39;GCS&#39;, &#39;GOOGLE_MAIL&#39;, &#39;GOOGLE_CALENDAR&#39;, &#39;GOOGLE_DRIVE&#39;,
     * &#39;NATIVE_CLOUD_IDENTITY&#39;, &#39;THIRD_PARTY_FEDERATED&#39;, &#39;THIRD_PARTY_EUA&#39;, &#39;GCNV&#39;.
     * 
     */
    public Optional<Output<String>> connectorType() {
        return Optional.ofNullable(this.connectorType);
    }

    /**
     * Timestamp when the DataConnector was created.
     * 
     */
    @Import(name="createTime")
    private @Nullable Output<String> createTime;

    /**
     * @return Timestamp when the DataConnector was created.
     * 
     */
    public Optional<Output<String>> createTime() {
        return Optional.ofNullable(this.createTime);
    }

    /**
     * The name of the data source.
     * Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
     * 
     */
    @Import(name="dataSource")
    private @Nullable Output<String> dataSource;

    /**
     * @return The name of the data source.
     * Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
     * 
     */
    public Optional<Output<String>> dataSource() {
        return Optional.ofNullable(this.dataSource);
    }

    /**
     * List of entities from the connected data source to ingest.
     * Structure is documented below.
     * 
     */
    @Import(name="entities")
    private @Nullable Output<List<DataConnectorEntityArgs>> entities;

    /**
     * @return List of entities from the connected data source to ingest.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<DataConnectorEntityArgs>>> entities() {
        return Optional.ofNullable(this.entities);
    }

    /**
     * The errors from initialization or from the latest connector run.
     * Structure is documented below.
     * 
     */
    @Import(name="errors")
    private @Nullable Output<List<DataConnectorErrorArgs>> errors;

    /**
     * @return The errors from initialization or from the latest connector run.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<DataConnectorErrorArgs>>> errors() {
        return Optional.ofNullable(this.errors);
    }

    /**
     * The refresh interval specifically for incremental data syncs. If unset,
     * incremental syncs will use the default from env, set to 3hrs.
     * The minimum is 30 minutes and maximum is 7 days. Applicable to only 3P
     * connectors. When the refresh interval is
     * set to the same value as the incremental refresh interval, incremental
     * sync will be disabled.
     * 
     */
    @Import(name="incrementalRefreshInterval")
    private @Nullable Output<String> incrementalRefreshInterval;

    /**
     * @return The refresh interval specifically for incremental data syncs. If unset,
     * incremental syncs will use the default from env, set to 3hrs.
     * The minimum is 30 minutes and maximum is 7 days. Applicable to only 3P
     * connectors. When the refresh interval is
     * set to the same value as the incremental refresh interval, incremental
     * sync will be disabled.
     * 
     */
    public Optional<Output<String>> incrementalRefreshInterval() {
        return Optional.ofNullable(this.incrementalRefreshInterval);
    }

    /**
     * Indicates whether incremental syncs are paused for this connector.
     * 
     */
    @Import(name="incrementalSyncDisabled")
    private @Nullable Output<Boolean> incrementalSyncDisabled;

    /**
     * @return Indicates whether incremental syncs are paused for this connector.
     * 
     */
    public Optional<Output<Boolean>> incrementalSyncDisabled() {
        return Optional.ofNullable(this.incrementalSyncDisabled);
    }

    /**
     * Params needed to access the source in the format of json string.
     * 
     */
    @Import(name="jsonParams")
    private @Nullable Output<String> jsonParams;

    /**
     * @return Params needed to access the source in the format of json string.
     * 
     */
    public Optional<Output<String>> jsonParams() {
        return Optional.ofNullable(this.jsonParams);
    }

    /**
     * The KMS key to be used to protect the DataStores managed by this connector.
     * Must be set for requests that need to comply with CMEK Org Policy
     * protections.
     * If this field is set and processed successfully, the DataStores created by
     * this connector will be protected by the KMS key.
     * 
     */
    @Import(name="kmsKeyName")
    private @Nullable Output<String> kmsKeyName;

    /**
     * @return The KMS key to be used to protect the DataStores managed by this connector.
     * Must be set for requests that need to comply with CMEK Org Policy
     * protections.
     * If this field is set and processed successfully, the DataStores created by
     * this connector will be protected by the KMS key.
     * 
     */
    public Optional<Output<String>> kmsKeyName() {
        return Optional.ofNullable(this.kmsKeyName);
    }

    /**
     * For periodic connectors only, the last time a data sync was completed.
     * 
     */
    @Import(name="lastSyncTime")
    private @Nullable Output<String> lastSyncTime;

    /**
     * @return For periodic connectors only, the last time a data sync was completed.
     * 
     */
    public Optional<Output<String>> lastSyncTime() {
        return Optional.ofNullable(this.lastSyncTime);
    }

    /**
     * The most recent timestamp when this [DataConnector][] was paused,
     * affecting all functionalities such as data synchronization.
     * Pausing a connector has the following effects:
     * - All functionalities, including data synchronization, are halted.
     * - Any ongoing data synchronization job will be canceled.
     * - No future data synchronization runs will be scheduled nor can be
     *   triggered.
     * 
     */
    @Import(name="latestPauseTime")
    private @Nullable Output<String> latestPauseTime;

    /**
     * @return The most recent timestamp when this [DataConnector][] was paused,
     * affecting all functionalities such as data synchronization.
     * Pausing a connector has the following effects:
     * - All functionalities, including data synchronization, are halted.
     * - Any ongoing data synchronization job will be canceled.
     * - No future data synchronization runs will be scheduled nor can be
     *   triggered.
     * 
     */
    public Optional<Output<String>> latestPauseTime() {
        return Optional.ofNullable(this.latestPauseTime);
    }

    /**
     * The geographic location where the data store should reside. The value can
     * only be one of &#34;global&#34;, &#34;us&#34; and &#34;eu&#34;.
     * 
     */
    @Import(name="location")
    private @Nullable Output<String> location;

    /**
     * @return The geographic location where the data store should reside. The value can
     * only be one of &#34;global&#34;, &#34;us&#34; and &#34;eu&#34;.
     * 
     */
    public Optional<Output<String>> location() {
        return Optional.ofNullable(this.location);
    }

    /**
     * The full resource name of the Data Connector.
     * Format: `projects/*&#47;locations/*&#47;collections/*&#47;dataConnector`.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The full resource name of the Data Connector.
     * Format: `projects/*&#47;locations/*&#47;collections/*&#47;dataConnector`.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Params needed to access the source in the format of String-to-String (Key, Value) pairs.
     * 
     */
    @Import(name="params")
    private @Nullable Output<Map<String,String>> params;

    /**
     * @return Params needed to access the source in the format of String-to-String (Key, Value) pairs.
     * 
     */
    public Optional<Output<Map<String,String>>> params() {
        return Optional.ofNullable(this.params);
    }

    /**
     * The tenant project ID associated with private connectivity connectors.
     * This project must be allowlisted by in order for the connector to function.
     * 
     */
    @Import(name="privateConnectivityProjectId")
    private @Nullable Output<String> privateConnectivityProjectId;

    /**
     * @return The tenant project ID associated with private connectivity connectors.
     * This project must be allowlisted by in order for the connector to function.
     * 
     */
    public Optional<Output<String>> privateConnectivityProjectId() {
        return Optional.ofNullable(this.privateConnectivityProjectId);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * The real-time sync state. The possible values can be:
     * &#39;STATE_UNSPECIFIED&#39;, &#39;CREATING&#39;, &#39;ACTIVE&#39;, &#39;FAILED&#39;, &#39;RUNNING&#39;, &#39;WARNING&#39;,
     * &#39;INITIALIZATION_FAILED&#39;, &#39;UPDATING&#39;.
     * 
     */
    @Import(name="realtimeState")
    private @Nullable Output<String> realtimeState;

    /**
     * @return The real-time sync state. The possible values can be:
     * &#39;STATE_UNSPECIFIED&#39;, &#39;CREATING&#39;, &#39;ACTIVE&#39;, &#39;FAILED&#39;, &#39;RUNNING&#39;, &#39;WARNING&#39;,
     * &#39;INITIALIZATION_FAILED&#39;, &#39;UPDATING&#39;.
     * 
     */
    public Optional<Output<String>> realtimeState() {
        return Optional.ofNullable(this.realtimeState);
    }

    /**
     * The refresh interval for data sync. If duration is set to 0, the data will
     * be synced in real time. The streaming feature is not supported yet. The
     * minimum is 30 minutes and maximum is 7 days. When the refresh interval is
     * set to the same value as the incremental refresh interval, incremental
     * sync will be disabled.
     * 
     */
    @Import(name="refreshInterval")
    private @Nullable Output<String> refreshInterval;

    /**
     * @return The refresh interval for data sync. If duration is set to 0, the data will
     * be synced in real time. The streaming feature is not supported yet. The
     * minimum is 30 minutes and maximum is 7 days. When the refresh interval is
     * set to the same value as the incremental refresh interval, incremental
     * sync will be disabled.
     * 
     */
    public Optional<Output<String>> refreshInterval() {
        return Optional.ofNullable(this.refreshInterval);
    }

    /**
     * The state of connector. The possible value can be:
     * &#39;STATE_UNSPECIFIED&#39;, &#39;CREATING&#39;, &#39;ACTIVE&#39;, &#39;FAILED&#39;, &#39;RUNNING&#39;, &#39;WARNING&#39;,
     * &#39;INITIALIZATION_FAILED&#39;, &#39;UPDATING&#39;.
     * 
     */
    @Import(name="state")
    private @Nullable Output<String> state;

    /**
     * @return The state of connector. The possible value can be:
     * &#39;STATE_UNSPECIFIED&#39;, &#39;CREATING&#39;, &#39;ACTIVE&#39;, &#39;FAILED&#39;, &#39;RUNNING&#39;, &#39;WARNING&#39;,
     * &#39;INITIALIZATION_FAILED&#39;, &#39;UPDATING&#39;.
     * 
     */
    public Optional<Output<String>> state() {
        return Optional.ofNullable(this.state);
    }

    /**
     * The static IP addresses used by this connector.
     * 
     */
    @Import(name="staticIpAddresses")
    private @Nullable Output<List<String>> staticIpAddresses;

    /**
     * @return The static IP addresses used by this connector.
     * 
     */
    public Optional<Output<List<String>>> staticIpAddresses() {
        return Optional.ofNullable(this.staticIpAddresses);
    }

    /**
     * Whether customer has enabled static IP addresses for this connector.
     * 
     */
    @Import(name="staticIpEnabled")
    private @Nullable Output<Boolean> staticIpEnabled;

    /**
     * @return Whether customer has enabled static IP addresses for this connector.
     * 
     */
    public Optional<Output<Boolean>> staticIpEnabled() {
        return Optional.ofNullable(this.staticIpEnabled);
    }

    /**
     * The data synchronization mode supported by the data connector. The possible value can be:
     * &#39;PERIODIC&#39;, &#39;STREAMING&#39;.
     * 
     */
    @Import(name="syncMode")
    private @Nullable Output<String> syncMode;

    /**
     * @return The data synchronization mode supported by the data connector. The possible value can be:
     * &#39;PERIODIC&#39;, &#39;STREAMING&#39;.
     * 
     */
    public Optional<Output<String>> syncMode() {
        return Optional.ofNullable(this.syncMode);
    }

    /**
     * Timestamp when the DataConnector was updated.
     * 
     */
    @Import(name="updateTime")
    private @Nullable Output<String> updateTime;

    /**
     * @return Timestamp when the DataConnector was updated.
     * 
     */
    public Optional<Output<String>> updateTime() {
        return Optional.ofNullable(this.updateTime);
    }

    private DataConnectorState() {}

    private DataConnectorState(DataConnectorState $) {
        this.actionState = $.actionState;
        this.autoRunDisabled = $.autoRunDisabled;
        this.blockingReasons = $.blockingReasons;
        this.collectionDisplayName = $.collectionDisplayName;
        this.collectionId = $.collectionId;
        this.connectorModes = $.connectorModes;
        this.connectorType = $.connectorType;
        this.createTime = $.createTime;
        this.dataSource = $.dataSource;
        this.entities = $.entities;
        this.errors = $.errors;
        this.incrementalRefreshInterval = $.incrementalRefreshInterval;
        this.incrementalSyncDisabled = $.incrementalSyncDisabled;
        this.jsonParams = $.jsonParams;
        this.kmsKeyName = $.kmsKeyName;
        this.lastSyncTime = $.lastSyncTime;
        this.latestPauseTime = $.latestPauseTime;
        this.location = $.location;
        this.name = $.name;
        this.params = $.params;
        this.privateConnectivityProjectId = $.privateConnectivityProjectId;
        this.project = $.project;
        this.realtimeState = $.realtimeState;
        this.refreshInterval = $.refreshInterval;
        this.state = $.state;
        this.staticIpAddresses = $.staticIpAddresses;
        this.staticIpEnabled = $.staticIpEnabled;
        this.syncMode = $.syncMode;
        this.updateTime = $.updateTime;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DataConnectorState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DataConnectorState $;

        public Builder() {
            $ = new DataConnectorState();
        }

        public Builder(DataConnectorState defaults) {
            $ = new DataConnectorState(Objects.requireNonNull(defaults));
        }

        /**
         * @param actionState State of the action connector. This reflects whether the action connector
         * is initializing, active or has encountered errors. The possible value can be:
         * &#39;STATE_UNSPECIFIED&#39;, &#39;CREATING&#39;, &#39;ACTIVE&#39;, &#39;FAILED&#39;, &#39;RUNNING&#39;, &#39;WARNING&#39;,
         * &#39;INITIALIZATION_FAILED&#39;, &#39;UPDATING&#39;.
         * 
         * @return builder
         * 
         */
        public Builder actionState(@Nullable Output<String> actionState) {
            $.actionState = actionState;
            return this;
        }

        /**
         * @param actionState State of the action connector. This reflects whether the action connector
         * is initializing, active or has encountered errors. The possible value can be:
         * &#39;STATE_UNSPECIFIED&#39;, &#39;CREATING&#39;, &#39;ACTIVE&#39;, &#39;FAILED&#39;, &#39;RUNNING&#39;, &#39;WARNING&#39;,
         * &#39;INITIALIZATION_FAILED&#39;, &#39;UPDATING&#39;.
         * 
         * @return builder
         * 
         */
        public Builder actionState(String actionState) {
            return actionState(Output.of(actionState));
        }

        /**
         * @param autoRunDisabled Indicates whether full syncs are paused for this connector
         * 
         * @return builder
         * 
         */
        public Builder autoRunDisabled(@Nullable Output<Boolean> autoRunDisabled) {
            $.autoRunDisabled = autoRunDisabled;
            return this;
        }

        /**
         * @param autoRunDisabled Indicates whether full syncs are paused for this connector
         * 
         * @return builder
         * 
         */
        public Builder autoRunDisabled(Boolean autoRunDisabled) {
            return autoRunDisabled(Output.of(autoRunDisabled));
        }

        /**
         * @param blockingReasons User actions that must be completed before the connector can start syncing data.
         * The possible values can be: &#39;ALLOWLIST_STATIC_IP&#39;, &#39;ALLOWLIST_IN_SERVICE_ATTACHMENT&#39;.
         * 
         * @return builder
         * 
         */
        public Builder blockingReasons(@Nullable Output<List<String>> blockingReasons) {
            $.blockingReasons = blockingReasons;
            return this;
        }

        /**
         * @param blockingReasons User actions that must be completed before the connector can start syncing data.
         * The possible values can be: &#39;ALLOWLIST_STATIC_IP&#39;, &#39;ALLOWLIST_IN_SERVICE_ATTACHMENT&#39;.
         * 
         * @return builder
         * 
         */
        public Builder blockingReasons(List<String> blockingReasons) {
            return blockingReasons(Output.of(blockingReasons));
        }

        /**
         * @param blockingReasons User actions that must be completed before the connector can start syncing data.
         * The possible values can be: &#39;ALLOWLIST_STATIC_IP&#39;, &#39;ALLOWLIST_IN_SERVICE_ATTACHMENT&#39;.
         * 
         * @return builder
         * 
         */
        public Builder blockingReasons(String... blockingReasons) {
            return blockingReasons(List.of(blockingReasons));
        }

        /**
         * @param collectionDisplayName The display name of the Collection.
         * Should be human readable, used to display collections in the Console
         * Dashboard. UTF-8 encoded string with limit of 1024 characters.
         * 
         * @return builder
         * 
         */
        public Builder collectionDisplayName(@Nullable Output<String> collectionDisplayName) {
            $.collectionDisplayName = collectionDisplayName;
            return this;
        }

        /**
         * @param collectionDisplayName The display name of the Collection.
         * Should be human readable, used to display collections in the Console
         * Dashboard. UTF-8 encoded string with limit of 1024 characters.
         * 
         * @return builder
         * 
         */
        public Builder collectionDisplayName(String collectionDisplayName) {
            return collectionDisplayName(Output.of(collectionDisplayName));
        }

        /**
         * @param collectionId The ID to use for the Collection, which will become the final component
         * of the Collection&#39;s resource name. A new Collection is created as
         * part of the DataConnector setup. DataConnector is a singleton
         * resource under Collection, managing all DataStores of the Collection.
         * This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
         * standard with a length limit of 63 characters. Otherwise, an
         * INVALID_ARGUMENT error is returned.
         * 
         * @return builder
         * 
         */
        public Builder collectionId(@Nullable Output<String> collectionId) {
            $.collectionId = collectionId;
            return this;
        }

        /**
         * @param collectionId The ID to use for the Collection, which will become the final component
         * of the Collection&#39;s resource name. A new Collection is created as
         * part of the DataConnector setup. DataConnector is a singleton
         * resource under Collection, managing all DataStores of the Collection.
         * This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
         * standard with a length limit of 63 characters. Otherwise, an
         * INVALID_ARGUMENT error is returned.
         * 
         * @return builder
         * 
         */
        public Builder collectionId(String collectionId) {
            return collectionId(Output.of(collectionId));
        }

        /**
         * @param connectorModes The modes enabled for this connector. The possible value can be:
         * &#39;DATA_INGESTION&#39;, &#39;ACTIONS&#39;, &#39;FEDERATED&#39;
         * &#39;EUA&#39;, &#39;FEDERATED_AND_EUA&#39;.
         * 
         * @return builder
         * 
         */
        public Builder connectorModes(@Nullable Output<List<String>> connectorModes) {
            $.connectorModes = connectorModes;
            return this;
        }

        /**
         * @param connectorModes The modes enabled for this connector. The possible value can be:
         * &#39;DATA_INGESTION&#39;, &#39;ACTIONS&#39;, &#39;FEDERATED&#39;
         * &#39;EUA&#39;, &#39;FEDERATED_AND_EUA&#39;.
         * 
         * @return builder
         * 
         */
        public Builder connectorModes(List<String> connectorModes) {
            return connectorModes(Output.of(connectorModes));
        }

        /**
         * @param connectorModes The modes enabled for this connector. The possible value can be:
         * &#39;DATA_INGESTION&#39;, &#39;ACTIONS&#39;, &#39;FEDERATED&#39;
         * &#39;EUA&#39;, &#39;FEDERATED_AND_EUA&#39;.
         * 
         * @return builder
         * 
         */
        public Builder connectorModes(String... connectorModes) {
            return connectorModes(List.of(connectorModes));
        }

        /**
         * @param connectorType The type of connector. Each source can only map to one type.
         * For example, salesforce, confluence and jira have THIRD_PARTY connector
         * type. It is not mutable once set by system. The possible value can be:
         * &#39;CONNECTOR_TYPE_UNSPECIFIED&#39;, &#39;THIRD_PARTY&#39;, &#39;GCP_FHIR&#39;, &#39;BIG_QUERY&#39;,
         * &#39;GCS&#39;, &#39;GOOGLE_MAIL&#39;, &#39;GOOGLE_CALENDAR&#39;, &#39;GOOGLE_DRIVE&#39;,
         * &#39;NATIVE_CLOUD_IDENTITY&#39;, &#39;THIRD_PARTY_FEDERATED&#39;, &#39;THIRD_PARTY_EUA&#39;, &#39;GCNV&#39;.
         * 
         * @return builder
         * 
         */
        public Builder connectorType(@Nullable Output<String> connectorType) {
            $.connectorType = connectorType;
            return this;
        }

        /**
         * @param connectorType The type of connector. Each source can only map to one type.
         * For example, salesforce, confluence and jira have THIRD_PARTY connector
         * type. It is not mutable once set by system. The possible value can be:
         * &#39;CONNECTOR_TYPE_UNSPECIFIED&#39;, &#39;THIRD_PARTY&#39;, &#39;GCP_FHIR&#39;, &#39;BIG_QUERY&#39;,
         * &#39;GCS&#39;, &#39;GOOGLE_MAIL&#39;, &#39;GOOGLE_CALENDAR&#39;, &#39;GOOGLE_DRIVE&#39;,
         * &#39;NATIVE_CLOUD_IDENTITY&#39;, &#39;THIRD_PARTY_FEDERATED&#39;, &#39;THIRD_PARTY_EUA&#39;, &#39;GCNV&#39;.
         * 
         * @return builder
         * 
         */
        public Builder connectorType(String connectorType) {
            return connectorType(Output.of(connectorType));
        }

        /**
         * @param createTime Timestamp when the DataConnector was created.
         * 
         * @return builder
         * 
         */
        public Builder createTime(@Nullable Output<String> createTime) {
            $.createTime = createTime;
            return this;
        }

        /**
         * @param createTime Timestamp when the DataConnector was created.
         * 
         * @return builder
         * 
         */
        public Builder createTime(String createTime) {
            return createTime(Output.of(createTime));
        }

        /**
         * @param dataSource The name of the data source.
         * Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
         * 
         * @return builder
         * 
         */
        public Builder dataSource(@Nullable Output<String> dataSource) {
            $.dataSource = dataSource;
            return this;
        }

        /**
         * @param dataSource The name of the data source.
         * Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
         * 
         * @return builder
         * 
         */
        public Builder dataSource(String dataSource) {
            return dataSource(Output.of(dataSource));
        }

        /**
         * @param entities List of entities from the connected data source to ingest.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder entities(@Nullable Output<List<DataConnectorEntityArgs>> entities) {
            $.entities = entities;
            return this;
        }

        /**
         * @param entities List of entities from the connected data source to ingest.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder entities(List<DataConnectorEntityArgs> entities) {
            return entities(Output.of(entities));
        }

        /**
         * @param entities List of entities from the connected data source to ingest.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder entities(DataConnectorEntityArgs... entities) {
            return entities(List.of(entities));
        }

        /**
         * @param errors The errors from initialization or from the latest connector run.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder errors(@Nullable Output<List<DataConnectorErrorArgs>> errors) {
            $.errors = errors;
            return this;
        }

        /**
         * @param errors The errors from initialization or from the latest connector run.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder errors(List<DataConnectorErrorArgs> errors) {
            return errors(Output.of(errors));
        }

        /**
         * @param errors The errors from initialization or from the latest connector run.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder errors(DataConnectorErrorArgs... errors) {
            return errors(List.of(errors));
        }

        /**
         * @param incrementalRefreshInterval The refresh interval specifically for incremental data syncs. If unset,
         * incremental syncs will use the default from env, set to 3hrs.
         * The minimum is 30 minutes and maximum is 7 days. Applicable to only 3P
         * connectors. When the refresh interval is
         * set to the same value as the incremental refresh interval, incremental
         * sync will be disabled.
         * 
         * @return builder
         * 
         */
        public Builder incrementalRefreshInterval(@Nullable Output<String> incrementalRefreshInterval) {
            $.incrementalRefreshInterval = incrementalRefreshInterval;
            return this;
        }

        /**
         * @param incrementalRefreshInterval The refresh interval specifically for incremental data syncs. If unset,
         * incremental syncs will use the default from env, set to 3hrs.
         * The minimum is 30 minutes and maximum is 7 days. Applicable to only 3P
         * connectors. When the refresh interval is
         * set to the same value as the incremental refresh interval, incremental
         * sync will be disabled.
         * 
         * @return builder
         * 
         */
        public Builder incrementalRefreshInterval(String incrementalRefreshInterval) {
            return incrementalRefreshInterval(Output.of(incrementalRefreshInterval));
        }

        /**
         * @param incrementalSyncDisabled Indicates whether incremental syncs are paused for this connector.
         * 
         * @return builder
         * 
         */
        public Builder incrementalSyncDisabled(@Nullable Output<Boolean> incrementalSyncDisabled) {
            $.incrementalSyncDisabled = incrementalSyncDisabled;
            return this;
        }

        /**
         * @param incrementalSyncDisabled Indicates whether incremental syncs are paused for this connector.
         * 
         * @return builder
         * 
         */
        public Builder incrementalSyncDisabled(Boolean incrementalSyncDisabled) {
            return incrementalSyncDisabled(Output.of(incrementalSyncDisabled));
        }

        /**
         * @param jsonParams Params needed to access the source in the format of json string.
         * 
         * @return builder
         * 
         */
        public Builder jsonParams(@Nullable Output<String> jsonParams) {
            $.jsonParams = jsonParams;
            return this;
        }

        /**
         * @param jsonParams Params needed to access the source in the format of json string.
         * 
         * @return builder
         * 
         */
        public Builder jsonParams(String jsonParams) {
            return jsonParams(Output.of(jsonParams));
        }

        /**
         * @param kmsKeyName The KMS key to be used to protect the DataStores managed by this connector.
         * Must be set for requests that need to comply with CMEK Org Policy
         * protections.
         * If this field is set and processed successfully, the DataStores created by
         * this connector will be protected by the KMS key.
         * 
         * @return builder
         * 
         */
        public Builder kmsKeyName(@Nullable Output<String> kmsKeyName) {
            $.kmsKeyName = kmsKeyName;
            return this;
        }

        /**
         * @param kmsKeyName The KMS key to be used to protect the DataStores managed by this connector.
         * Must be set for requests that need to comply with CMEK Org Policy
         * protections.
         * If this field is set and processed successfully, the DataStores created by
         * this connector will be protected by the KMS key.
         * 
         * @return builder
         * 
         */
        public Builder kmsKeyName(String kmsKeyName) {
            return kmsKeyName(Output.of(kmsKeyName));
        }

        /**
         * @param lastSyncTime For periodic connectors only, the last time a data sync was completed.
         * 
         * @return builder
         * 
         */
        public Builder lastSyncTime(@Nullable Output<String> lastSyncTime) {
            $.lastSyncTime = lastSyncTime;
            return this;
        }

        /**
         * @param lastSyncTime For periodic connectors only, the last time a data sync was completed.
         * 
         * @return builder
         * 
         */
        public Builder lastSyncTime(String lastSyncTime) {
            return lastSyncTime(Output.of(lastSyncTime));
        }

        /**
         * @param latestPauseTime The most recent timestamp when this [DataConnector][] was paused,
         * affecting all functionalities such as data synchronization.
         * Pausing a connector has the following effects:
         * - All functionalities, including data synchronization, are halted.
         * - Any ongoing data synchronization job will be canceled.
         * - No future data synchronization runs will be scheduled nor can be
         *   triggered.
         * 
         * @return builder
         * 
         */
        public Builder latestPauseTime(@Nullable Output<String> latestPauseTime) {
            $.latestPauseTime = latestPauseTime;
            return this;
        }

        /**
         * @param latestPauseTime The most recent timestamp when this [DataConnector][] was paused,
         * affecting all functionalities such as data synchronization.
         * Pausing a connector has the following effects:
         * - All functionalities, including data synchronization, are halted.
         * - Any ongoing data synchronization job will be canceled.
         * - No future data synchronization runs will be scheduled nor can be
         *   triggered.
         * 
         * @return builder
         * 
         */
        public Builder latestPauseTime(String latestPauseTime) {
            return latestPauseTime(Output.of(latestPauseTime));
        }

        /**
         * @param location The geographic location where the data store should reside. The value can
         * only be one of &#34;global&#34;, &#34;us&#34; and &#34;eu&#34;.
         * 
         * @return builder
         * 
         */
        public Builder location(@Nullable Output<String> location) {
            $.location = location;
            return this;
        }

        /**
         * @param location The geographic location where the data store should reside. The value can
         * only be one of &#34;global&#34;, &#34;us&#34; and &#34;eu&#34;.
         * 
         * @return builder
         * 
         */
        public Builder location(String location) {
            return location(Output.of(location));
        }

        /**
         * @param name The full resource name of the Data Connector.
         * Format: `projects/*&#47;locations/*&#47;collections/*&#47;dataConnector`.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The full resource name of the Data Connector.
         * Format: `projects/*&#47;locations/*&#47;collections/*&#47;dataConnector`.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param params Params needed to access the source in the format of String-to-String (Key, Value) pairs.
         * 
         * @return builder
         * 
         */
        public Builder params(@Nullable Output<Map<String,String>> params) {
            $.params = params;
            return this;
        }

        /**
         * @param params Params needed to access the source in the format of String-to-String (Key, Value) pairs.
         * 
         * @return builder
         * 
         */
        public Builder params(Map<String,String> params) {
            return params(Output.of(params));
        }

        /**
         * @param privateConnectivityProjectId The tenant project ID associated with private connectivity connectors.
         * This project must be allowlisted by in order for the connector to function.
         * 
         * @return builder
         * 
         */
        public Builder privateConnectivityProjectId(@Nullable Output<String> privateConnectivityProjectId) {
            $.privateConnectivityProjectId = privateConnectivityProjectId;
            return this;
        }

        /**
         * @param privateConnectivityProjectId The tenant project ID associated with private connectivity connectors.
         * This project must be allowlisted by in order for the connector to function.
         * 
         * @return builder
         * 
         */
        public Builder privateConnectivityProjectId(String privateConnectivityProjectId) {
            return privateConnectivityProjectId(Output.of(privateConnectivityProjectId));
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param realtimeState The real-time sync state. The possible values can be:
         * &#39;STATE_UNSPECIFIED&#39;, &#39;CREATING&#39;, &#39;ACTIVE&#39;, &#39;FAILED&#39;, &#39;RUNNING&#39;, &#39;WARNING&#39;,
         * &#39;INITIALIZATION_FAILED&#39;, &#39;UPDATING&#39;.
         * 
         * @return builder
         * 
         */
        public Builder realtimeState(@Nullable Output<String> realtimeState) {
            $.realtimeState = realtimeState;
            return this;
        }

        /**
         * @param realtimeState The real-time sync state. The possible values can be:
         * &#39;STATE_UNSPECIFIED&#39;, &#39;CREATING&#39;, &#39;ACTIVE&#39;, &#39;FAILED&#39;, &#39;RUNNING&#39;, &#39;WARNING&#39;,
         * &#39;INITIALIZATION_FAILED&#39;, &#39;UPDATING&#39;.
         * 
         * @return builder
         * 
         */
        public Builder realtimeState(String realtimeState) {
            return realtimeState(Output.of(realtimeState));
        }

        /**
         * @param refreshInterval The refresh interval for data sync. If duration is set to 0, the data will
         * be synced in real time. The streaming feature is not supported yet. The
         * minimum is 30 minutes and maximum is 7 days. When the refresh interval is
         * set to the same value as the incremental refresh interval, incremental
         * sync will be disabled.
         * 
         * @return builder
         * 
         */
        public Builder refreshInterval(@Nullable Output<String> refreshInterval) {
            $.refreshInterval = refreshInterval;
            return this;
        }

        /**
         * @param refreshInterval The refresh interval for data sync. If duration is set to 0, the data will
         * be synced in real time. The streaming feature is not supported yet. The
         * minimum is 30 minutes and maximum is 7 days. When the refresh interval is
         * set to the same value as the incremental refresh interval, incremental
         * sync will be disabled.
         * 
         * @return builder
         * 
         */
        public Builder refreshInterval(String refreshInterval) {
            return refreshInterval(Output.of(refreshInterval));
        }

        /**
         * @param state The state of connector. The possible value can be:
         * &#39;STATE_UNSPECIFIED&#39;, &#39;CREATING&#39;, &#39;ACTIVE&#39;, &#39;FAILED&#39;, &#39;RUNNING&#39;, &#39;WARNING&#39;,
         * &#39;INITIALIZATION_FAILED&#39;, &#39;UPDATING&#39;.
         * 
         * @return builder
         * 
         */
        public Builder state(@Nullable Output<String> state) {
            $.state = state;
            return this;
        }

        /**
         * @param state The state of connector. The possible value can be:
         * &#39;STATE_UNSPECIFIED&#39;, &#39;CREATING&#39;, &#39;ACTIVE&#39;, &#39;FAILED&#39;, &#39;RUNNING&#39;, &#39;WARNING&#39;,
         * &#39;INITIALIZATION_FAILED&#39;, &#39;UPDATING&#39;.
         * 
         * @return builder
         * 
         */
        public Builder state(String state) {
            return state(Output.of(state));
        }

        /**
         * @param staticIpAddresses The static IP addresses used by this connector.
         * 
         * @return builder
         * 
         */
        public Builder staticIpAddresses(@Nullable Output<List<String>> staticIpAddresses) {
            $.staticIpAddresses = staticIpAddresses;
            return this;
        }

        /**
         * @param staticIpAddresses The static IP addresses used by this connector.
         * 
         * @return builder
         * 
         */
        public Builder staticIpAddresses(List<String> staticIpAddresses) {
            return staticIpAddresses(Output.of(staticIpAddresses));
        }

        /**
         * @param staticIpAddresses The static IP addresses used by this connector.
         * 
         * @return builder
         * 
         */
        public Builder staticIpAddresses(String... staticIpAddresses) {
            return staticIpAddresses(List.of(staticIpAddresses));
        }

        /**
         * @param staticIpEnabled Whether customer has enabled static IP addresses for this connector.
         * 
         * @return builder
         * 
         */
        public Builder staticIpEnabled(@Nullable Output<Boolean> staticIpEnabled) {
            $.staticIpEnabled = staticIpEnabled;
            return this;
        }

        /**
         * @param staticIpEnabled Whether customer has enabled static IP addresses for this connector.
         * 
         * @return builder
         * 
         */
        public Builder staticIpEnabled(Boolean staticIpEnabled) {
            return staticIpEnabled(Output.of(staticIpEnabled));
        }

        /**
         * @param syncMode The data synchronization mode supported by the data connector. The possible value can be:
         * &#39;PERIODIC&#39;, &#39;STREAMING&#39;.
         * 
         * @return builder
         * 
         */
        public Builder syncMode(@Nullable Output<String> syncMode) {
            $.syncMode = syncMode;
            return this;
        }

        /**
         * @param syncMode The data synchronization mode supported by the data connector. The possible value can be:
         * &#39;PERIODIC&#39;, &#39;STREAMING&#39;.
         * 
         * @return builder
         * 
         */
        public Builder syncMode(String syncMode) {
            return syncMode(Output.of(syncMode));
        }

        /**
         * @param updateTime Timestamp when the DataConnector was updated.
         * 
         * @return builder
         * 
         */
        public Builder updateTime(@Nullable Output<String> updateTime) {
            $.updateTime = updateTime;
            return this;
        }

        /**
         * @param updateTime Timestamp when the DataConnector was updated.
         * 
         * @return builder
         * 
         */
        public Builder updateTime(String updateTime) {
            return updateTime(Output.of(updateTime));
        }

        public DataConnectorState build() {
            return $;
        }
    }

}
