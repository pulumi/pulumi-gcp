// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.discoveryengine;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.gcp.discoveryengine.inputs.DataConnectorEntityArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DataConnectorArgs extends com.pulumi.resources.ResourceArgs {

    public static final DataConnectorArgs Empty = new DataConnectorArgs();

    /**
     * Indicates whether full syncs are paused for this connector
     * 
     */
    @Import(name="autoRunDisabled")
    private @Nullable Output<Boolean> autoRunDisabled;

    /**
     * @return Indicates whether full syncs are paused for this connector
     * 
     */
    public Optional<Output<Boolean>> autoRunDisabled() {
        return Optional.ofNullable(this.autoRunDisabled);
    }

    /**
     * The display name of the Collection.
     * Should be human readable, used to display collections in the Console
     * Dashboard. UTF-8 encoded string with limit of 1024 characters.
     * 
     */
    @Import(name="collectionDisplayName", required=true)
    private Output<String> collectionDisplayName;

    /**
     * @return The display name of the Collection.
     * Should be human readable, used to display collections in the Console
     * Dashboard. UTF-8 encoded string with limit of 1024 characters.
     * 
     */
    public Output<String> collectionDisplayName() {
        return this.collectionDisplayName;
    }

    /**
     * The ID to use for the Collection, which will become the final component
     * of the Collection&#39;s resource name. A new Collection is created as
     * part of the DataConnector setup. DataConnector is a singleton
     * resource under Collection, managing all DataStores of the Collection.
     * This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
     * standard with a length limit of 63 characters. Otherwise, an
     * INVALID_ARGUMENT error is returned.
     * 
     */
    @Import(name="collectionId", required=true)
    private Output<String> collectionId;

    /**
     * @return The ID to use for the Collection, which will become the final component
     * of the Collection&#39;s resource name. A new Collection is created as
     * part of the DataConnector setup. DataConnector is a singleton
     * resource under Collection, managing all DataStores of the Collection.
     * This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
     * standard with a length limit of 63 characters. Otherwise, an
     * INVALID_ARGUMENT error is returned.
     * 
     */
    public Output<String> collectionId() {
        return this.collectionId;
    }

    /**
     * The modes enabled for this connector. The possible value can be:
     * &#39;DATA_INGESTION&#39;, &#39;ACTIONS&#39;, &#39;FEDERATED&#39;
     * &#39;EUA&#39;, &#39;FEDERATED_AND_EUA&#39;.
     * 
     */
    @Import(name="connectorModes")
    private @Nullable Output<List<String>> connectorModes;

    /**
     * @return The modes enabled for this connector. The possible value can be:
     * &#39;DATA_INGESTION&#39;, &#39;ACTIONS&#39;, &#39;FEDERATED&#39;
     * &#39;EUA&#39;, &#39;FEDERATED_AND_EUA&#39;.
     * 
     */
    public Optional<Output<List<String>>> connectorModes() {
        return Optional.ofNullable(this.connectorModes);
    }

    /**
     * The name of the data source.
     * Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
     * 
     */
    @Import(name="dataSource", required=true)
    private Output<String> dataSource;

    /**
     * @return The name of the data source.
     * Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
     * 
     */
    public Output<String> dataSource() {
        return this.dataSource;
    }

    /**
     * List of entities from the connected data source to ingest.
     * Structure is documented below.
     * 
     */
    @Import(name="entities")
    private @Nullable Output<List<DataConnectorEntityArgs>> entities;

    /**
     * @return List of entities from the connected data source to ingest.
     * Structure is documented below.
     * 
     */
    public Optional<Output<List<DataConnectorEntityArgs>>> entities() {
        return Optional.ofNullable(this.entities);
    }

    /**
     * The refresh interval specifically for incremental data syncs. If unset,
     * incremental syncs will use the default from env, set to 3hrs.
     * The minimum is 30 minutes and maximum is 7 days. Applicable to only 3P
     * connectors. When the refresh interval is
     * set to the same value as the incremental refresh interval, incremental
     * sync will be disabled.
     * 
     */
    @Import(name="incrementalRefreshInterval")
    private @Nullable Output<String> incrementalRefreshInterval;

    /**
     * @return The refresh interval specifically for incremental data syncs. If unset,
     * incremental syncs will use the default from env, set to 3hrs.
     * The minimum is 30 minutes and maximum is 7 days. Applicable to only 3P
     * connectors. When the refresh interval is
     * set to the same value as the incremental refresh interval, incremental
     * sync will be disabled.
     * 
     */
    public Optional<Output<String>> incrementalRefreshInterval() {
        return Optional.ofNullable(this.incrementalRefreshInterval);
    }

    /**
     * Indicates whether incremental syncs are paused for this connector.
     * 
     */
    @Import(name="incrementalSyncDisabled")
    private @Nullable Output<Boolean> incrementalSyncDisabled;

    /**
     * @return Indicates whether incremental syncs are paused for this connector.
     * 
     */
    public Optional<Output<Boolean>> incrementalSyncDisabled() {
        return Optional.ofNullable(this.incrementalSyncDisabled);
    }

    /**
     * Params needed to access the source in the format of json string.
     * 
     */
    @Import(name="jsonParams")
    private @Nullable Output<String> jsonParams;

    /**
     * @return Params needed to access the source in the format of json string.
     * 
     */
    public Optional<Output<String>> jsonParams() {
        return Optional.ofNullable(this.jsonParams);
    }

    /**
     * The KMS key to be used to protect the DataStores managed by this connector.
     * Must be set for requests that need to comply with CMEK Org Policy
     * protections.
     * If this field is set and processed successfully, the DataStores created by
     * this connector will be protected by the KMS key.
     * 
     */
    @Import(name="kmsKeyName")
    private @Nullable Output<String> kmsKeyName;

    /**
     * @return The KMS key to be used to protect the DataStores managed by this connector.
     * Must be set for requests that need to comply with CMEK Org Policy
     * protections.
     * If this field is set and processed successfully, the DataStores created by
     * this connector will be protected by the KMS key.
     * 
     */
    public Optional<Output<String>> kmsKeyName() {
        return Optional.ofNullable(this.kmsKeyName);
    }

    /**
     * The geographic location where the data store should reside. The value can
     * only be one of &#34;global&#34;, &#34;us&#34; and &#34;eu&#34;.
     * 
     */
    @Import(name="location", required=true)
    private Output<String> location;

    /**
     * @return The geographic location where the data store should reside. The value can
     * only be one of &#34;global&#34;, &#34;us&#34; and &#34;eu&#34;.
     * 
     */
    public Output<String> location() {
        return this.location;
    }

    /**
     * Params needed to access the source in the format of String-to-String (Key, Value) pairs.
     * 
     */
    @Import(name="params")
    private @Nullable Output<Map<String,String>> params;

    /**
     * @return Params needed to access the source in the format of String-to-String (Key, Value) pairs.
     * 
     */
    public Optional<Output<Map<String,String>>> params() {
        return Optional.ofNullable(this.params);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * The refresh interval for data sync. If duration is set to 0, the data will
     * be synced in real time. The streaming feature is not supported yet. The
     * minimum is 30 minutes and maximum is 7 days. When the refresh interval is
     * set to the same value as the incremental refresh interval, incremental
     * sync will be disabled.
     * 
     */
    @Import(name="refreshInterval", required=true)
    private Output<String> refreshInterval;

    /**
     * @return The refresh interval for data sync. If duration is set to 0, the data will
     * be synced in real time. The streaming feature is not supported yet. The
     * minimum is 30 minutes and maximum is 7 days. When the refresh interval is
     * set to the same value as the incremental refresh interval, incremental
     * sync will be disabled.
     * 
     */
    public Output<String> refreshInterval() {
        return this.refreshInterval;
    }

    /**
     * Whether customer has enabled static IP addresses for this connector.
     * 
     */
    @Import(name="staticIpEnabled")
    private @Nullable Output<Boolean> staticIpEnabled;

    /**
     * @return Whether customer has enabled static IP addresses for this connector.
     * 
     */
    public Optional<Output<Boolean>> staticIpEnabled() {
        return Optional.ofNullable(this.staticIpEnabled);
    }

    /**
     * The data synchronization mode supported by the data connector. The possible value can be:
     * &#39;PERIODIC&#39;, &#39;STREAMING&#39;.
     * 
     */
    @Import(name="syncMode")
    private @Nullable Output<String> syncMode;

    /**
     * @return The data synchronization mode supported by the data connector. The possible value can be:
     * &#39;PERIODIC&#39;, &#39;STREAMING&#39;.
     * 
     */
    public Optional<Output<String>> syncMode() {
        return Optional.ofNullable(this.syncMode);
    }

    private DataConnectorArgs() {}

    private DataConnectorArgs(DataConnectorArgs $) {
        this.autoRunDisabled = $.autoRunDisabled;
        this.collectionDisplayName = $.collectionDisplayName;
        this.collectionId = $.collectionId;
        this.connectorModes = $.connectorModes;
        this.dataSource = $.dataSource;
        this.entities = $.entities;
        this.incrementalRefreshInterval = $.incrementalRefreshInterval;
        this.incrementalSyncDisabled = $.incrementalSyncDisabled;
        this.jsonParams = $.jsonParams;
        this.kmsKeyName = $.kmsKeyName;
        this.location = $.location;
        this.params = $.params;
        this.project = $.project;
        this.refreshInterval = $.refreshInterval;
        this.staticIpEnabled = $.staticIpEnabled;
        this.syncMode = $.syncMode;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DataConnectorArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DataConnectorArgs $;

        public Builder() {
            $ = new DataConnectorArgs();
        }

        public Builder(DataConnectorArgs defaults) {
            $ = new DataConnectorArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param autoRunDisabled Indicates whether full syncs are paused for this connector
         * 
         * @return builder
         * 
         */
        public Builder autoRunDisabled(@Nullable Output<Boolean> autoRunDisabled) {
            $.autoRunDisabled = autoRunDisabled;
            return this;
        }

        /**
         * @param autoRunDisabled Indicates whether full syncs are paused for this connector
         * 
         * @return builder
         * 
         */
        public Builder autoRunDisabled(Boolean autoRunDisabled) {
            return autoRunDisabled(Output.of(autoRunDisabled));
        }

        /**
         * @param collectionDisplayName The display name of the Collection.
         * Should be human readable, used to display collections in the Console
         * Dashboard. UTF-8 encoded string with limit of 1024 characters.
         * 
         * @return builder
         * 
         */
        public Builder collectionDisplayName(Output<String> collectionDisplayName) {
            $.collectionDisplayName = collectionDisplayName;
            return this;
        }

        /**
         * @param collectionDisplayName The display name of the Collection.
         * Should be human readable, used to display collections in the Console
         * Dashboard. UTF-8 encoded string with limit of 1024 characters.
         * 
         * @return builder
         * 
         */
        public Builder collectionDisplayName(String collectionDisplayName) {
            return collectionDisplayName(Output.of(collectionDisplayName));
        }

        /**
         * @param collectionId The ID to use for the Collection, which will become the final component
         * of the Collection&#39;s resource name. A new Collection is created as
         * part of the DataConnector setup. DataConnector is a singleton
         * resource under Collection, managing all DataStores of the Collection.
         * This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
         * standard with a length limit of 63 characters. Otherwise, an
         * INVALID_ARGUMENT error is returned.
         * 
         * @return builder
         * 
         */
        public Builder collectionId(Output<String> collectionId) {
            $.collectionId = collectionId;
            return this;
        }

        /**
         * @param collectionId The ID to use for the Collection, which will become the final component
         * of the Collection&#39;s resource name. A new Collection is created as
         * part of the DataConnector setup. DataConnector is a singleton
         * resource under Collection, managing all DataStores of the Collection.
         * This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
         * standard with a length limit of 63 characters. Otherwise, an
         * INVALID_ARGUMENT error is returned.
         * 
         * @return builder
         * 
         */
        public Builder collectionId(String collectionId) {
            return collectionId(Output.of(collectionId));
        }

        /**
         * @param connectorModes The modes enabled for this connector. The possible value can be:
         * &#39;DATA_INGESTION&#39;, &#39;ACTIONS&#39;, &#39;FEDERATED&#39;
         * &#39;EUA&#39;, &#39;FEDERATED_AND_EUA&#39;.
         * 
         * @return builder
         * 
         */
        public Builder connectorModes(@Nullable Output<List<String>> connectorModes) {
            $.connectorModes = connectorModes;
            return this;
        }

        /**
         * @param connectorModes The modes enabled for this connector. The possible value can be:
         * &#39;DATA_INGESTION&#39;, &#39;ACTIONS&#39;, &#39;FEDERATED&#39;
         * &#39;EUA&#39;, &#39;FEDERATED_AND_EUA&#39;.
         * 
         * @return builder
         * 
         */
        public Builder connectorModes(List<String> connectorModes) {
            return connectorModes(Output.of(connectorModes));
        }

        /**
         * @param connectorModes The modes enabled for this connector. The possible value can be:
         * &#39;DATA_INGESTION&#39;, &#39;ACTIONS&#39;, &#39;FEDERATED&#39;
         * &#39;EUA&#39;, &#39;FEDERATED_AND_EUA&#39;.
         * 
         * @return builder
         * 
         */
        public Builder connectorModes(String... connectorModes) {
            return connectorModes(List.of(connectorModes));
        }

        /**
         * @param dataSource The name of the data source.
         * Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
         * 
         * @return builder
         * 
         */
        public Builder dataSource(Output<String> dataSource) {
            $.dataSource = dataSource;
            return this;
        }

        /**
         * @param dataSource The name of the data source.
         * Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
         * 
         * @return builder
         * 
         */
        public Builder dataSource(String dataSource) {
            return dataSource(Output.of(dataSource));
        }

        /**
         * @param entities List of entities from the connected data source to ingest.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder entities(@Nullable Output<List<DataConnectorEntityArgs>> entities) {
            $.entities = entities;
            return this;
        }

        /**
         * @param entities List of entities from the connected data source to ingest.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder entities(List<DataConnectorEntityArgs> entities) {
            return entities(Output.of(entities));
        }

        /**
         * @param entities List of entities from the connected data source to ingest.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder entities(DataConnectorEntityArgs... entities) {
            return entities(List.of(entities));
        }

        /**
         * @param incrementalRefreshInterval The refresh interval specifically for incremental data syncs. If unset,
         * incremental syncs will use the default from env, set to 3hrs.
         * The minimum is 30 minutes and maximum is 7 days. Applicable to only 3P
         * connectors. When the refresh interval is
         * set to the same value as the incremental refresh interval, incremental
         * sync will be disabled.
         * 
         * @return builder
         * 
         */
        public Builder incrementalRefreshInterval(@Nullable Output<String> incrementalRefreshInterval) {
            $.incrementalRefreshInterval = incrementalRefreshInterval;
            return this;
        }

        /**
         * @param incrementalRefreshInterval The refresh interval specifically for incremental data syncs. If unset,
         * incremental syncs will use the default from env, set to 3hrs.
         * The minimum is 30 minutes and maximum is 7 days. Applicable to only 3P
         * connectors. When the refresh interval is
         * set to the same value as the incremental refresh interval, incremental
         * sync will be disabled.
         * 
         * @return builder
         * 
         */
        public Builder incrementalRefreshInterval(String incrementalRefreshInterval) {
            return incrementalRefreshInterval(Output.of(incrementalRefreshInterval));
        }

        /**
         * @param incrementalSyncDisabled Indicates whether incremental syncs are paused for this connector.
         * 
         * @return builder
         * 
         */
        public Builder incrementalSyncDisabled(@Nullable Output<Boolean> incrementalSyncDisabled) {
            $.incrementalSyncDisabled = incrementalSyncDisabled;
            return this;
        }

        /**
         * @param incrementalSyncDisabled Indicates whether incremental syncs are paused for this connector.
         * 
         * @return builder
         * 
         */
        public Builder incrementalSyncDisabled(Boolean incrementalSyncDisabled) {
            return incrementalSyncDisabled(Output.of(incrementalSyncDisabled));
        }

        /**
         * @param jsonParams Params needed to access the source in the format of json string.
         * 
         * @return builder
         * 
         */
        public Builder jsonParams(@Nullable Output<String> jsonParams) {
            $.jsonParams = jsonParams;
            return this;
        }

        /**
         * @param jsonParams Params needed to access the source in the format of json string.
         * 
         * @return builder
         * 
         */
        public Builder jsonParams(String jsonParams) {
            return jsonParams(Output.of(jsonParams));
        }

        /**
         * @param kmsKeyName The KMS key to be used to protect the DataStores managed by this connector.
         * Must be set for requests that need to comply with CMEK Org Policy
         * protections.
         * If this field is set and processed successfully, the DataStores created by
         * this connector will be protected by the KMS key.
         * 
         * @return builder
         * 
         */
        public Builder kmsKeyName(@Nullable Output<String> kmsKeyName) {
            $.kmsKeyName = kmsKeyName;
            return this;
        }

        /**
         * @param kmsKeyName The KMS key to be used to protect the DataStores managed by this connector.
         * Must be set for requests that need to comply with CMEK Org Policy
         * protections.
         * If this field is set and processed successfully, the DataStores created by
         * this connector will be protected by the KMS key.
         * 
         * @return builder
         * 
         */
        public Builder kmsKeyName(String kmsKeyName) {
            return kmsKeyName(Output.of(kmsKeyName));
        }

        /**
         * @param location The geographic location where the data store should reside. The value can
         * only be one of &#34;global&#34;, &#34;us&#34; and &#34;eu&#34;.
         * 
         * @return builder
         * 
         */
        public Builder location(Output<String> location) {
            $.location = location;
            return this;
        }

        /**
         * @param location The geographic location where the data store should reside. The value can
         * only be one of &#34;global&#34;, &#34;us&#34; and &#34;eu&#34;.
         * 
         * @return builder
         * 
         */
        public Builder location(String location) {
            return location(Output.of(location));
        }

        /**
         * @param params Params needed to access the source in the format of String-to-String (Key, Value) pairs.
         * 
         * @return builder
         * 
         */
        public Builder params(@Nullable Output<Map<String,String>> params) {
            $.params = params;
            return this;
        }

        /**
         * @param params Params needed to access the source in the format of String-to-String (Key, Value) pairs.
         * 
         * @return builder
         * 
         */
        public Builder params(Map<String,String> params) {
            return params(Output.of(params));
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param refreshInterval The refresh interval for data sync. If duration is set to 0, the data will
         * be synced in real time. The streaming feature is not supported yet. The
         * minimum is 30 minutes and maximum is 7 days. When the refresh interval is
         * set to the same value as the incremental refresh interval, incremental
         * sync will be disabled.
         * 
         * @return builder
         * 
         */
        public Builder refreshInterval(Output<String> refreshInterval) {
            $.refreshInterval = refreshInterval;
            return this;
        }

        /**
         * @param refreshInterval The refresh interval for data sync. If duration is set to 0, the data will
         * be synced in real time. The streaming feature is not supported yet. The
         * minimum is 30 minutes and maximum is 7 days. When the refresh interval is
         * set to the same value as the incremental refresh interval, incremental
         * sync will be disabled.
         * 
         * @return builder
         * 
         */
        public Builder refreshInterval(String refreshInterval) {
            return refreshInterval(Output.of(refreshInterval));
        }

        /**
         * @param staticIpEnabled Whether customer has enabled static IP addresses for this connector.
         * 
         * @return builder
         * 
         */
        public Builder staticIpEnabled(@Nullable Output<Boolean> staticIpEnabled) {
            $.staticIpEnabled = staticIpEnabled;
            return this;
        }

        /**
         * @param staticIpEnabled Whether customer has enabled static IP addresses for this connector.
         * 
         * @return builder
         * 
         */
        public Builder staticIpEnabled(Boolean staticIpEnabled) {
            return staticIpEnabled(Output.of(staticIpEnabled));
        }

        /**
         * @param syncMode The data synchronization mode supported by the data connector. The possible value can be:
         * &#39;PERIODIC&#39;, &#39;STREAMING&#39;.
         * 
         * @return builder
         * 
         */
        public Builder syncMode(@Nullable Output<String> syncMode) {
            $.syncMode = syncMode;
            return this;
        }

        /**
         * @param syncMode The data synchronization mode supported by the data connector. The possible value can be:
         * &#39;PERIODIC&#39;, &#39;STREAMING&#39;.
         * 
         * @return builder
         * 
         */
        public Builder syncMode(String syncMode) {
            return syncMode(Output.of(syncMode));
        }

        public DataConnectorArgs build() {
            if ($.collectionDisplayName == null) {
                throw new MissingRequiredPropertyException("DataConnectorArgs", "collectionDisplayName");
            }
            if ($.collectionId == null) {
                throw new MissingRequiredPropertyException("DataConnectorArgs", "collectionId");
            }
            if ($.dataSource == null) {
                throw new MissingRequiredPropertyException("DataConnectorArgs", "dataSource");
            }
            if ($.location == null) {
                throw new MissingRequiredPropertyException("DataConnectorArgs", "location");
            }
            if ($.refreshInterval == null) {
                throw new MissingRequiredPropertyException("DataConnectorArgs", "refreshInterval");
            }
            return $;
        }
    }

}
