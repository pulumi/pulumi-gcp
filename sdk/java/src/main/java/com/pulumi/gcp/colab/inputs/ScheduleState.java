// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.colab.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.colab.inputs.ScheduleCreateNotebookExecutionJobRequestArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ScheduleState extends com.pulumi.resources.ResourceArgs {

    public static final ScheduleState Empty = new ScheduleState();

    /**
     * Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
     * 
     */
    @Import(name="allowQueueing")
    private @Nullable Output<Boolean> allowQueueing;

    /**
     * @return Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
     * 
     */
    public Optional<Output<Boolean>> allowQueueing() {
        return Optional.ofNullable(this.allowQueueing);
    }

    /**
     * Request for google_colab_notebook_execution.
     * Structure is documented below.
     * 
     */
    @Import(name="createNotebookExecutionJobRequest")
    private @Nullable Output<ScheduleCreateNotebookExecutionJobRequestArgs> createNotebookExecutionJobRequest;

    /**
     * @return Request for google_colab_notebook_execution.
     * Structure is documented below.
     * 
     */
    public Optional<Output<ScheduleCreateNotebookExecutionJobRequestArgs>> createNotebookExecutionJobRequest() {
        return Optional.ofNullable(this.createNotebookExecutionJobRequest);
    }

    /**
     * Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
     * 
     */
    @Import(name="cron")
    private @Nullable Output<String> cron;

    /**
     * @return Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
     * 
     */
    public Optional<Output<String>> cron() {
        return Optional.ofNullable(this.cron);
    }

    /**
     * Desired state of the Colab Schedule. Set this field to `ACTIVE` to start/resume the schedule, and `PAUSED` to pause the schedule.
     * 
     */
    @Import(name="desiredState")
    private @Nullable Output<String> desiredState;

    /**
     * @return Desired state of the Colab Schedule. Set this field to `ACTIVE` to start/resume the schedule, and `PAUSED` to pause the schedule.
     * 
     */
    public Optional<Output<String>> desiredState() {
        return Optional.ofNullable(this.desiredState);
    }

    /**
     * Required. The display name of the Schedule.
     * 
     */
    @Import(name="displayName")
    private @Nullable Output<String> displayName;

    /**
     * @return Required. The display name of the Schedule.
     * 
     */
    public Optional<Output<String>> displayName() {
        return Optional.ofNullable(this.displayName);
    }

    /**
     * Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either end_time is reached or when scheduled_run_count &gt;= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     * 
     */
    @Import(name="endTime")
    private @Nullable Output<String> endTime;

    /**
     * @return Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either end_time is reached or when scheduled_run_count &gt;= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     * 
     */
    public Optional<Output<String>> endTime() {
        return Optional.ofNullable(this.endTime);
    }

    /**
     * The location for the resource: https://cloud.google.com/colab/docs/locations
     * 
     */
    @Import(name="location")
    private @Nullable Output<String> location;

    /**
     * @return The location for the resource: https://cloud.google.com/colab/docs/locations
     * 
     */
    public Optional<Output<String>> location() {
        return Optional.ofNullable(this.location);
    }

    /**
     * Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
     * 
     */
    @Import(name="maxConcurrentRunCount")
    private @Nullable Output<String> maxConcurrentRunCount;

    /**
     * @return Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
     * 
     */
    public Optional<Output<String>> maxConcurrentRunCount() {
        return Optional.ofNullable(this.maxConcurrentRunCount);
    }

    /**
     * Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount &gt;= maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
     * 
     */
    @Import(name="maxRunCount")
    private @Nullable Output<String> maxRunCount;

    /**
     * @return Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount &gt;= maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
     * 
     */
    public Optional<Output<String>> maxRunCount() {
        return Optional.ofNullable(this.maxRunCount);
    }

    /**
     * The resource name of the Schedule
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The resource name of the Schedule
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     * 
     */
    @Import(name="startTime")
    private @Nullable Output<String> startTime;

    /**
     * @return The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     * 
     */
    public Optional<Output<String>> startTime() {
        return Optional.ofNullable(this.startTime);
    }

    /**
     * Output only. The state of the schedule.
     * 
     */
    @Import(name="state")
    private @Nullable Output<String> state;

    /**
     * @return Output only. The state of the schedule.
     * 
     */
    public Optional<Output<String>> state() {
        return Optional.ofNullable(this.state);
    }

    private ScheduleState() {}

    private ScheduleState(ScheduleState $) {
        this.allowQueueing = $.allowQueueing;
        this.createNotebookExecutionJobRequest = $.createNotebookExecutionJobRequest;
        this.cron = $.cron;
        this.desiredState = $.desiredState;
        this.displayName = $.displayName;
        this.endTime = $.endTime;
        this.location = $.location;
        this.maxConcurrentRunCount = $.maxConcurrentRunCount;
        this.maxRunCount = $.maxRunCount;
        this.name = $.name;
        this.project = $.project;
        this.startTime = $.startTime;
        this.state = $.state;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ScheduleState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ScheduleState $;

        public Builder() {
            $ = new ScheduleState();
        }

        public Builder(ScheduleState defaults) {
            $ = new ScheduleState(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowQueueing Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
         * 
         * @return builder
         * 
         */
        public Builder allowQueueing(@Nullable Output<Boolean> allowQueueing) {
            $.allowQueueing = allowQueueing;
            return this;
        }

        /**
         * @param allowQueueing Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
         * 
         * @return builder
         * 
         */
        public Builder allowQueueing(Boolean allowQueueing) {
            return allowQueueing(Output.of(allowQueueing));
        }

        /**
         * @param createNotebookExecutionJobRequest Request for google_colab_notebook_execution.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder createNotebookExecutionJobRequest(@Nullable Output<ScheduleCreateNotebookExecutionJobRequestArgs> createNotebookExecutionJobRequest) {
            $.createNotebookExecutionJobRequest = createNotebookExecutionJobRequest;
            return this;
        }

        /**
         * @param createNotebookExecutionJobRequest Request for google_colab_notebook_execution.
         * Structure is documented below.
         * 
         * @return builder
         * 
         */
        public Builder createNotebookExecutionJobRequest(ScheduleCreateNotebookExecutionJobRequestArgs createNotebookExecutionJobRequest) {
            return createNotebookExecutionJobRequest(Output.of(createNotebookExecutionJobRequest));
        }

        /**
         * @param cron Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
         * 
         * @return builder
         * 
         */
        public Builder cron(@Nullable Output<String> cron) {
            $.cron = cron;
            return this;
        }

        /**
         * @param cron Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
         * 
         * @return builder
         * 
         */
        public Builder cron(String cron) {
            return cron(Output.of(cron));
        }

        /**
         * @param desiredState Desired state of the Colab Schedule. Set this field to `ACTIVE` to start/resume the schedule, and `PAUSED` to pause the schedule.
         * 
         * @return builder
         * 
         */
        public Builder desiredState(@Nullable Output<String> desiredState) {
            $.desiredState = desiredState;
            return this;
        }

        /**
         * @param desiredState Desired state of the Colab Schedule. Set this field to `ACTIVE` to start/resume the schedule, and `PAUSED` to pause the schedule.
         * 
         * @return builder
         * 
         */
        public Builder desiredState(String desiredState) {
            return desiredState(Output.of(desiredState));
        }

        /**
         * @param displayName Required. The display name of the Schedule.
         * 
         * @return builder
         * 
         */
        public Builder displayName(@Nullable Output<String> displayName) {
            $.displayName = displayName;
            return this;
        }

        /**
         * @param displayName Required. The display name of the Schedule.
         * 
         * @return builder
         * 
         */
        public Builder displayName(String displayName) {
            return displayName(Output.of(displayName));
        }

        /**
         * @param endTime Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either end_time is reached or when scheduled_run_count &gt;= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
         * 
         * @return builder
         * 
         */
        public Builder endTime(@Nullable Output<String> endTime) {
            $.endTime = endTime;
            return this;
        }

        /**
         * @param endTime Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either end_time is reached or when scheduled_run_count &gt;= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
         * 
         * @return builder
         * 
         */
        public Builder endTime(String endTime) {
            return endTime(Output.of(endTime));
        }

        /**
         * @param location The location for the resource: https://cloud.google.com/colab/docs/locations
         * 
         * @return builder
         * 
         */
        public Builder location(@Nullable Output<String> location) {
            $.location = location;
            return this;
        }

        /**
         * @param location The location for the resource: https://cloud.google.com/colab/docs/locations
         * 
         * @return builder
         * 
         */
        public Builder location(String location) {
            return location(Output.of(location));
        }

        /**
         * @param maxConcurrentRunCount Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
         * 
         * @return builder
         * 
         */
        public Builder maxConcurrentRunCount(@Nullable Output<String> maxConcurrentRunCount) {
            $.maxConcurrentRunCount = maxConcurrentRunCount;
            return this;
        }

        /**
         * @param maxConcurrentRunCount Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
         * 
         * @return builder
         * 
         */
        public Builder maxConcurrentRunCount(String maxConcurrentRunCount) {
            return maxConcurrentRunCount(Output.of(maxConcurrentRunCount));
        }

        /**
         * @param maxRunCount Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount &gt;= maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
         * 
         * @return builder
         * 
         */
        public Builder maxRunCount(@Nullable Output<String> maxRunCount) {
            $.maxRunCount = maxRunCount;
            return this;
        }

        /**
         * @param maxRunCount Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount &gt;= maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
         * 
         * @return builder
         * 
         */
        public Builder maxRunCount(String maxRunCount) {
            return maxRunCount(Output.of(maxRunCount));
        }

        /**
         * @param name The resource name of the Schedule
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The resource name of the Schedule
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        /**
         * @param project The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         * 
         * @return builder
         * 
         */
        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param startTime The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
         * 
         * @return builder
         * 
         */
        public Builder startTime(@Nullable Output<String> startTime) {
            $.startTime = startTime;
            return this;
        }

        /**
         * @param startTime The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
         * 
         * @return builder
         * 
         */
        public Builder startTime(String startTime) {
            return startTime(Output.of(startTime));
        }

        /**
         * @param state Output only. The state of the schedule.
         * 
         * @return builder
         * 
         */
        public Builder state(@Nullable Output<String> state) {
            $.state = state;
            return this;
        }

        /**
         * @param state Output only. The state of the schedule.
         * 
         * @return builder
         * 
         */
        public Builder state(String state) {
            return state(Output.of(state));
        }

        public ScheduleState build() {
            return $;
        }
    }

}
